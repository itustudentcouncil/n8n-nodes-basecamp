// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/identity/accesscontextmanager/v1/access_level.proto (package google.identity.accesscontextmanager.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { DeviceEncryptionStatus, DeviceManagementLevel, OsType } from "../type/device_resources_pb";
import { file_google_identity_accesscontextmanager_type_device_resources } from "../type/device_resources_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Expr } from "../../../type/expr_pb";
import { file_google_type_expr } from "../../../type/expr_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/identity/accesscontextmanager/v1/access_level.proto.
 */
export const file_google_identity_accesscontextmanager_v1_access_level: GenFile = /*@__PURE__*/
  fileDesc("Cjpnb29nbGUvaWRlbnRpdHkvYWNjZXNzY29udGV4dG1hbmFnZXIvdjEvYWNjZXNzX2xldmVsLnByb3RvEidnb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEiqgMKC0FjY2Vzc0xldmVsEgwKBG5hbWUYASABKAkSDQoFdGl0bGUYAiABKAkSEwoLZGVzY3JpcHRpb24YAyABKAkSRAoFYmFzaWMYBCABKAsyMy5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuQmFzaWNMZXZlbEgAEkYKBmN1c3RvbRgFIAEoCzI0Lmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5DdXN0b21MZXZlbEgAEi8KC2NyZWF0ZV90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIvCgt1cGRhdGVfdGltZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXA6cOpBbQovYWNjZXNzY29udGV4dG1hbmFnZXIuZ29vZ2xlYXBpcy5jb20vQWNjZXNzTGV2ZWwSOmFjY2Vzc1BvbGljaWVzL3thY2Nlc3NfcG9saWN5fS9hY2Nlc3NMZXZlbHMve2FjY2Vzc19sZXZlbH1CBwoFbGV2ZWwi7wEKCkJhc2ljTGV2ZWwSRgoKY29uZGl0aW9ucxgBIAMoCzIyLmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5Db25kaXRpb24SagoSY29tYmluaW5nX2Z1bmN0aW9uGAIgASgOMk4uZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLkJhc2ljTGV2ZWwuQ29uZGl0aW9uQ29tYmluaW5nRnVuY3Rpb24iLQoaQ29uZGl0aW9uQ29tYmluaW5nRnVuY3Rpb24SBwoDQU5EEAASBgoCT1IQASLDAQoJQ29uZGl0aW9uEhYKDmlwX3N1Ym5ldHdvcmtzGAEgAygJEkwKDWRldmljZV9wb2xpY3kYAiABKAsyNS5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuRGV2aWNlUG9saWN5Eh4KFnJlcXVpcmVkX2FjY2Vzc19sZXZlbHMYAyADKAkSDgoGbmVnYXRlGAUgASgIEg8KB21lbWJlcnMYBiADKAkSDwoHcmVnaW9ucxgHIAMoCSIuCgtDdXN0b21MZXZlbBIfCgRleHByGAEgASgLMhEuZ29vZ2xlLnR5cGUuRXhwciKJAwoMRGV2aWNlUG9saWN5EhoKEnJlcXVpcmVfc2NyZWVubG9jaxgBIAEoCBJmChthbGxvd2VkX2VuY3J5cHRpb25fc3RhdHVzZXMYAiADKA4yQS5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudHlwZS5EZXZpY2VFbmNyeXB0aW9uU3RhdHVzEk0KDm9zX2NvbnN0cmFpbnRzGAMgAygLMjUuZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLk9zQ29uc3RyYWludBJqCiBhbGxvd2VkX2RldmljZV9tYW5hZ2VtZW50X2xldmVscxgGIAMoDjJALmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci50eXBlLkRldmljZU1hbmFnZW1lbnRMZXZlbBIeChZyZXF1aXJlX2FkbWluX2FwcHJvdmFsGAcgASgIEhoKEnJlcXVpcmVfY29ycF9vd25lZBgIIAEoCCKPAQoMT3NDb25zdHJhaW50EkIKB29zX3R5cGUYASABKA4yMS5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudHlwZS5Pc1R5cGUSFwoPbWluaW11bV92ZXJzaW9uGAIgASgJEiIKGnJlcXVpcmVfdmVyaWZpZWRfY2hyb21lX29zGAMgASgIQqcCCitjb20uZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxQhBBY2Nlc3NMZXZlbFByb3RvUAFaXGNsb3VkLmdvb2dsZS5jb20vZ28vYWNjZXNzY29udGV4dG1hbmFnZXIvYXBpdjEvYWNjZXNzY29udGV4dG1hbmFnZXJwYjthY2Nlc3Njb250ZXh0bWFuYWdlcnBiogIER0FDTaoCJ0dvb2dsZS5JZGVudGl0eS5BY2Nlc3NDb250ZXh0TWFuYWdlci5WMcoCJ0dvb2dsZVxJZGVudGl0eVxBY2Nlc3NDb250ZXh0TWFuYWdlclxWMeoCKkdvb2dsZTo6SWRlbnRpdHk6OkFjY2Vzc0NvbnRleHRNYW5hZ2VyOjpWMWIGcHJvdG8z", [file_google_api_resource, file_google_identity_accesscontextmanager_type_device_resources, file_google_protobuf_timestamp, file_google_type_expr]);

/**
 * An `AccessLevel` is a label that can be applied to requests to Google Cloud
 * services, along with a list of requirements necessary for the label to be
 * applied.
 *
 * @generated from message google.identity.accesscontextmanager.v1.AccessLevel
 */
export type AccessLevel = Message<"google.identity.accesscontextmanager.v1.AccessLevel"> & {
  /**
   * Required. Resource name for the Access Level. The `short_name` component
   * must begin with a letter and only include alphanumeric and '_'. Format:
   * `accessPolicies/{access_policy}/accessLevels/{access_level}`. The maximum
   * length of the `access_level` component is 50 characters.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * Description of the `AccessLevel` and its use. Does not affect behavior.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Required. Describes the necessary conditions for the level to apply.
   *
   * @generated from oneof google.identity.accesscontextmanager.v1.AccessLevel.level
   */
  level: {
    /**
     * A `BasicLevel` composed of `Conditions`.
     *
     * @generated from field: google.identity.accesscontextmanager.v1.BasicLevel basic = 4;
     */
    value: BasicLevel;
    case: "basic";
  } | {
    /**
     * A `CustomLevel` written in the Common Expression Language.
     *
     * @generated from field: google.identity.accesscontextmanager.v1.CustomLevel custom = 5;
     */
    value: CustomLevel;
    case: "custom";
  } | { case: undefined; value?: undefined };

  /**
   * Output only. Time the `AccessLevel` was created in UTC.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  /**
   * Output only. Time the `AccessLevel` was updated in UTC.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 7;
   */
  updateTime?: Timestamp;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.AccessLevel.
 * Use `create(AccessLevelSchema)` to create a new message.
 */
export const AccessLevelSchema: GenMessage<AccessLevel> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 0);

/**
 * `BasicLevel` is an `AccessLevel` using a set of recommended features.
 *
 * @generated from message google.identity.accesscontextmanager.v1.BasicLevel
 */
export type BasicLevel = Message<"google.identity.accesscontextmanager.v1.BasicLevel"> & {
  /**
   * Required. A list of requirements for the `AccessLevel` to be granted.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.Condition conditions = 1;
   */
  conditions: Condition[];

  /**
   * How the `conditions` list should be combined to determine if a request is
   * granted this `AccessLevel`. If AND is used, each `Condition` in
   * `conditions` must be satisfied for the `AccessLevel` to be applied. If OR
   * is used, at least one `Condition` in `conditions` must be satisfied for the
   * `AccessLevel` to be applied. Default behavior is AND.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.BasicLevel.ConditionCombiningFunction combining_function = 2;
   */
  combiningFunction: BasicLevel_ConditionCombiningFunction;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.BasicLevel.
 * Use `create(BasicLevelSchema)` to create a new message.
 */
export const BasicLevelSchema: GenMessage<BasicLevel> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 1);

/**
 * Options for how the `conditions` list should be combined to determine if
 * this `AccessLevel` is applied. Default is AND.
 *
 * @generated from enum google.identity.accesscontextmanager.v1.BasicLevel.ConditionCombiningFunction
 */
export enum BasicLevel_ConditionCombiningFunction {
  /**
   * All `Conditions` must be true for the `BasicLevel` to be true.
   *
   * @generated from enum value: AND = 0;
   */
  AND = 0,

  /**
   * If at least one `Condition` is true, then the `BasicLevel` is true.
   *
   * @generated from enum value: OR = 1;
   */
  OR = 1,
}

/**
 * Describes the enum google.identity.accesscontextmanager.v1.BasicLevel.ConditionCombiningFunction.
 */
export const BasicLevel_ConditionCombiningFunctionSchema: GenEnum<BasicLevel_ConditionCombiningFunction> = /*@__PURE__*/
  enumDesc(file_google_identity_accesscontextmanager_v1_access_level, 1, 0);

/**
 * A condition necessary for an `AccessLevel` to be granted. The Condition is an
 * AND over its fields. So a Condition is true if: 1) the request IP is from one
 * of the listed subnetworks AND 2) the originating device complies with the
 * listed device policy AND 3) all listed access levels are granted AND 4) the
 * request was sent at a time allowed by the DateTimeRestriction.
 *
 * @generated from message google.identity.accesscontextmanager.v1.Condition
 */
export type Condition = Message<"google.identity.accesscontextmanager.v1.Condition"> & {
  /**
   * CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for
   * a CIDR IP address block, the specified IP address portion must be properly
   * truncated (i.e. all the host bits must be zero) or the input is considered
   * malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is
   * not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas
   * "2001:db8::1/32" is not. The originating IP of a request must be in one of
   * the listed subnets in order for this Condition to be true. If empty, all IP
   * addresses are allowed.
   *
   * @generated from field: repeated string ip_subnetworks = 1;
   */
  ipSubnetworks: string[];

  /**
   * Device specific restrictions, all restrictions must hold for the
   * Condition to be true. If not specified, all devices are allowed.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.DevicePolicy device_policy = 2;
   */
  devicePolicy?: DevicePolicy;

  /**
   * A list of other access levels defined in the same `Policy`, referenced by
   * resource name. Referencing an `AccessLevel` which does not exist is an
   * error. All access levels listed must be granted for the Condition
   * to be true. Example:
   * "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
   *
   * @generated from field: repeated string required_access_levels = 3;
   */
  requiredAccessLevels: string[];

  /**
   * Whether to negate the Condition. If true, the Condition becomes a NAND over
   * its non-empty fields, each field must be false for the Condition overall to
   * be satisfied. Defaults to false.
   *
   * @generated from field: bool negate = 5;
   */
  negate: boolean;

  /**
   * The request must be made by one of the provided user or service
   * accounts. Groups are not supported.
   * Syntax:
   * `user:{emailid}`
   * `serviceAccount:{emailid}`
   * If not specified, a request may come from any user.
   *
   * @generated from field: repeated string members = 6;
   */
  members: string[];

  /**
   * The request must originate from one of the provided countries/regions.
   * Must be valid ISO 3166-1 alpha-2 codes.
   *
   * @generated from field: repeated string regions = 7;
   */
  regions: string[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.Condition.
 * Use `create(ConditionSchema)` to create a new message.
 */
export const ConditionSchema: GenMessage<Condition> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 2);

/**
 * `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language
 * to represent the necessary conditions for the level to apply to a request.
 * See CEL spec at: https://github.com/google/cel-spec
 *
 * @generated from message google.identity.accesscontextmanager.v1.CustomLevel
 */
export type CustomLevel = Message<"google.identity.accesscontextmanager.v1.CustomLevel"> & {
  /**
   * Required. A Cloud CEL expression evaluating to a boolean.
   *
   * @generated from field: google.type.Expr expr = 1;
   */
  expr?: Expr;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.CustomLevel.
 * Use `create(CustomLevelSchema)` to create a new message.
 */
export const CustomLevelSchema: GenMessage<CustomLevel> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 3);

/**
 * `DevicePolicy` specifies device specific restrictions necessary to acquire a
 * given access level. A `DevicePolicy` specifies requirements for requests from
 * devices to be granted access levels, it does not do any enforcement on the
 * device. `DevicePolicy` acts as an AND over all specified fields, and each
 * repeated field is an OR over its elements. Any unset fields are ignored. For
 * example, if the proto is { os_type : DESKTOP_WINDOWS, os_type :
 * DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be
 * true for requests originating from encrypted Linux desktops and encrypted
 * Windows desktops.
 *
 * @generated from message google.identity.accesscontextmanager.v1.DevicePolicy
 */
export type DevicePolicy = Message<"google.identity.accesscontextmanager.v1.DevicePolicy"> & {
  /**
   * Whether or not screenlock is required for the DevicePolicy to be true.
   * Defaults to `false`.
   *
   * @generated from field: bool require_screenlock = 1;
   */
  requireScreenlock: boolean;

  /**
   * Allowed encryptions statuses, an empty list allows all statuses.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.type.DeviceEncryptionStatus allowed_encryption_statuses = 2;
   */
  allowedEncryptionStatuses: DeviceEncryptionStatus[];

  /**
   * Allowed OS versions, an empty list allows all types and all versions.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.OsConstraint os_constraints = 3;
   */
  osConstraints: OsConstraint[];

  /**
   * Allowed device management levels, an empty list allows all management
   * levels.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.type.DeviceManagementLevel allowed_device_management_levels = 6;
   */
  allowedDeviceManagementLevels: DeviceManagementLevel[];

  /**
   * Whether the device needs to be approved by the customer admin.
   *
   * @generated from field: bool require_admin_approval = 7;
   */
  requireAdminApproval: boolean;

  /**
   * Whether the device needs to be corp owned.
   *
   * @generated from field: bool require_corp_owned = 8;
   */
  requireCorpOwned: boolean;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.DevicePolicy.
 * Use `create(DevicePolicySchema)` to create a new message.
 */
export const DevicePolicySchema: GenMessage<DevicePolicy> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 4);

/**
 * A restriction on the OS type and version of devices making requests.
 *
 * @generated from message google.identity.accesscontextmanager.v1.OsConstraint
 */
export type OsConstraint = Message<"google.identity.accesscontextmanager.v1.OsConstraint"> & {
  /**
   * Required. The allowed OS type.
   *
   * @generated from field: google.identity.accesscontextmanager.type.OsType os_type = 1;
   */
  osType: OsType;

  /**
   * The minimum allowed OS version. If not set, any version of this OS
   * satisfies the constraint. Format: `"major.minor.patch"`.
   * Examples: `"10.5.301"`, `"9.2.1"`.
   *
   * @generated from field: string minimum_version = 2;
   */
  minimumVersion: string;

  /**
   * Only allows requests from devices with a verified Chrome OS.
   * Verifications includes requirements that the device is enterprise-managed,
   * conformant to domain policies, and the caller has permission to call
   * the API targeted by the request.
   *
   * @generated from field: bool require_verified_chrome_os = 3;
   */
  requireVerifiedChromeOs: boolean;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.OsConstraint.
 * Use `create(OsConstraintSchema)` to create a new message.
 */
export const OsConstraintSchema: GenMessage<OsConstraint> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_access_level, 5);

