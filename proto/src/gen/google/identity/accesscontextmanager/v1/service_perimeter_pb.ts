// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/identity/accesscontextmanager/v1/service_perimeter.proto (package google.identity.accesscontextmanager.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/identity/accesscontextmanager/v1/service_perimeter.proto.
 */
export const file_google_identity_accesscontextmanager_v1_service_perimeter: GenFile = /*@__PURE__*/
  fileDesc("Cj9nb29nbGUvaWRlbnRpdHkvYWNjZXNzY29udGV4dG1hbmFnZXIvdjEvc2VydmljZV9wZXJpbWV0ZXIucHJvdG8SJ2dvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MSKTBQoQU2VydmljZVBlcmltZXRlchIMCgRuYW1lGAEgASgJEg0KBXRpdGxlGAIgASgJEhMKC2Rlc2NyaXB0aW9uGAMgASgJEi8KC2NyZWF0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIvCgt1cGRhdGVfdGltZRgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASXwoOcGVyaW1ldGVyX3R5cGUYBiABKA4yRy5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuU2VydmljZVBlcmltZXRlci5QZXJpbWV0ZXJUeXBlEk8KBnN0YXR1cxgHIAEoCzI/Lmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5TZXJ2aWNlUGVyaW1ldGVyQ29uZmlnEk0KBHNwZWMYCCABKAsyPy5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuU2VydmljZVBlcmltZXRlckNvbmZpZxIhChl1c2VfZXhwbGljaXRfZHJ5X3J1bl9zcGVjGAkgASgIIkYKDVBlcmltZXRlclR5cGUSGgoWUEVSSU1FVEVSX1RZUEVfUkVHVUxBUhAAEhkKFVBFUklNRVRFUl9UWVBFX0JSSURHRRABOn/qQXwKNGFjY2Vzc2NvbnRleHRtYW5hZ2VyLmdvb2dsZWFwaXMuY29tL1NlcnZpY2VQZXJpbWV0ZXISRGFjY2Vzc1BvbGljaWVzL3thY2Nlc3NfcG9saWN5fS9zZXJ2aWNlUGVyaW1ldGVycy97c2VydmljZV9wZXJpbWV0ZXJ9IrUPChZTZXJ2aWNlUGVyaW1ldGVyQ29uZmlnEhEKCXJlc291cmNlcxgBIAMoCRIVCg1hY2Nlc3NfbGV2ZWxzGAIgAygJEhsKE3Jlc3RyaWN0ZWRfc2VydmljZXMYBCADKAkSdgoXdnBjX2FjY2Vzc2libGVfc2VydmljZXMYCiABKAsyVS5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuU2VydmljZVBlcmltZXRlckNvbmZpZy5WcGNBY2Nlc3NpYmxlU2VydmljZXMSZwoQaW5ncmVzc19wb2xpY2llcxgIIAMoCzJNLmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5TZXJ2aWNlUGVyaW1ldGVyQ29uZmlnLkluZ3Jlc3NQb2xpY3kSZQoPZWdyZXNzX3BvbGljaWVzGAkgAygLMkwuZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuRWdyZXNzUG9saWN5Gk0KFVZwY0FjY2Vzc2libGVTZXJ2aWNlcxIaChJlbmFibGVfcmVzdHJpY3Rpb24YASABKAgSGAoQYWxsb3dlZF9zZXJ2aWNlcxgCIAMoCRpACg5NZXRob2RTZWxlY3RvchIQCgZtZXRob2QYASABKAlIABIUCgpwZXJtaXNzaW9uGAIgASgJSABCBgoEa2luZBqOAQoMQXBpT3BlcmF0aW9uEhQKDHNlcnZpY2VfbmFtZRgBIAEoCRJoChBtZXRob2Rfc2VsZWN0b3JzGAIgAygLMk4uZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuTWV0aG9kU2VsZWN0b3IaRQoNSW5ncmVzc1NvdXJjZRIWCgxhY2Nlc3NfbGV2ZWwYASABKAlIABISCghyZXNvdXJjZRgCIAEoCUgAQggKBnNvdXJjZRrmAQoLSW5ncmVzc0Zyb20SXgoHc291cmNlcxgBIAMoCzJNLmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5TZXJ2aWNlUGVyaW1ldGVyQ29uZmlnLkluZ3Jlc3NTb3VyY2USEgoKaWRlbnRpdGllcxgCIAMoCRJjCg1pZGVudGl0eV90eXBlGAMgASgOMkwuZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuSWRlbnRpdHlUeXBlGoABCglJbmdyZXNzVG8SYAoKb3BlcmF0aW9ucxgBIAMoCzJMLmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5TZXJ2aWNlUGVyaW1ldGVyQ29uZmlnLkFwaU9wZXJhdGlvbhIRCglyZXNvdXJjZXMYAiADKAka0QEKDUluZ3Jlc3NQb2xpY3kSYQoMaW5ncmVzc19mcm9tGAEgASgLMksuZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuSW5ncmVzc0Zyb20SXQoKaW5ncmVzc190bxgCIAEoCzJJLmdvb2dsZS5pZGVudGl0eS5hY2Nlc3Njb250ZXh0bWFuYWdlci52MS5TZXJ2aWNlUGVyaW1ldGVyQ29uZmlnLkluZ3Jlc3NUbxqFAQoKRWdyZXNzRnJvbRISCgppZGVudGl0aWVzGAEgAygJEmMKDWlkZW50aXR5X3R5cGUYAiABKA4yTC5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuU2VydmljZVBlcmltZXRlckNvbmZpZy5JZGVudGl0eVR5cGUamwEKCEVncmVzc1RvEhEKCXJlc291cmNlcxgBIAMoCRJgCgpvcGVyYXRpb25zGAIgAygLMkwuZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuQXBpT3BlcmF0aW9uEhoKEmV4dGVybmFsX3Jlc291cmNlcxgDIAMoCRrMAQoMRWdyZXNzUG9saWN5El8KC2VncmVzc19mcm9tGAEgASgLMkouZ29vZ2xlLmlkZW50aXR5LmFjY2Vzc2NvbnRleHRtYW5hZ2VyLnYxLlNlcnZpY2VQZXJpbWV0ZXJDb25maWcuRWdyZXNzRnJvbRJbCgllZ3Jlc3NfdG8YAiABKAsySC5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjEuU2VydmljZVBlcmltZXRlckNvbmZpZy5FZ3Jlc3NUbyJuCgxJZGVudGl0eVR5cGUSHQoZSURFTlRJVFlfVFlQRV9VTlNQRUNJRklFRBAAEhAKDEFOWV9JREVOVElUWRABEhQKEEFOWV9VU0VSX0FDQ09VTlQQAhIXChNBTllfU0VSVklDRV9BQ0NPVU5UEANCrAIKK2NvbS5nb29nbGUuaWRlbnRpdHkuYWNjZXNzY29udGV4dG1hbmFnZXIudjFCFVNlcnZpY2VQZXJpbWV0ZXJQcm90b1ABWlxjbG91ZC5nb29nbGUuY29tL2dvL2FjY2Vzc2NvbnRleHRtYW5hZ2VyL2FwaXYxL2FjY2Vzc2NvbnRleHRtYW5hZ2VycGI7YWNjZXNzY29udGV4dG1hbmFnZXJwYqICBEdBQ02qAidHb29nbGUuSWRlbnRpdHkuQWNjZXNzQ29udGV4dE1hbmFnZXIuVjHKAidHb29nbGVcSWRlbnRpdHlcQWNjZXNzQ29udGV4dE1hbmFnZXJcVjHqAipHb29nbGU6OklkZW50aXR5OjpBY2Nlc3NDb250ZXh0TWFuYWdlcjo6VjFiBnByb3RvMw", [file_google_api_resource, file_google_protobuf_timestamp]);

/**
 * `ServicePerimeter` describes a set of Google Cloud resources which can freely
 * import and export data amongst themselves, but not export outside of the
 * `ServicePerimeter`. If a request with a source within this `ServicePerimeter`
 * has a target outside of the `ServicePerimeter`, the request will be blocked.
 * Otherwise the request is allowed. There are two types of Service Perimeter -
 * Regular and Bridge. Regular Service Perimeters cannot overlap, a single
 * Google Cloud project can only belong to a single regular Service Perimeter.
 * Service Perimeter Bridges can contain only Google Cloud projects as members,
 * a single Google Cloud project may belong to multiple Service Perimeter
 * Bridges.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeter
 */
export type ServicePerimeter = Message<"google.identity.accesscontextmanager.v1.ServicePerimeter"> & {
  /**
   * Required. Resource name for the ServicePerimeter.  The `short_name`
   * component must begin with a letter and only include alphanumeric and '_'.
   * Format:
   * `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Human readable title. Must be unique within the Policy.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * Description of the `ServicePerimeter` and its use. Does not affect
   * behavior.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Output only. Time the `ServicePerimeter` was created in UTC.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * Output only. Time the `ServicePerimeter` was updated in UTC.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime?: Timestamp;

  /**
   * Perimeter type indicator. A single project is
   * allowed to be a member of single regular perimeter, but multiple service
   * perimeter bridges. A project cannot be a included in a perimeter bridge
   * without being included in regular perimeter. For perimeter bridges,
   * the restricted service list as well as access level lists must be
   * empty.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeter.PerimeterType perimeter_type = 6;
   */
  perimeterType: ServicePerimeter_PerimeterType;

  /**
   * Current ServicePerimeter configuration. Specifies sets of resources,
   * restricted services and access levels that determine perimeter
   * content and boundaries.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig status = 7;
   */
  status?: ServicePerimeterConfig;

  /**
   * Proposed (or dry run) ServicePerimeter configuration. This configuration
   * allows to specify and test ServicePerimeter configuration without enforcing
   * actual access restrictions. Only allowed to be set when the
   * "use_explicit_dry_run_spec" flag is set.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig spec = 8;
   */
  spec?: ServicePerimeterConfig;

  /**
   * Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly
   * exists  for all Service Perimeters, and that spec is identical to the
   * status for those Service Perimeters. When this flag is set, it inhibits the
   * generation of the implicit spec, thereby allowing the user to explicitly
   * provide a configuration ("spec") to use in a dry-run version of the Service
   * Perimeter. This allows the user to test changes to the enforced config
   * ("status") without actually enforcing them. This testing is done through
   * analyzing the differences between currently enforced and suggested
   * restrictions. use_explicit_dry_run_spec must bet set to True if any of the
   * fields in the spec are set to non-default values.
   *
   * @generated from field: bool use_explicit_dry_run_spec = 9;
   */
  useExplicitDryRunSpec: boolean;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeter.
 * Use `create(ServicePerimeterSchema)` to create a new message.
 */
export const ServicePerimeterSchema: GenMessage<ServicePerimeter> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 0);

/**
 * Specifies the type of the Perimeter. There are two types: regular and
 * bridge. Regular Service Perimeter contains resources, access levels, and
 * restricted services. Every resource can be in at most ONE
 * regular Service Perimeter.
 *
 * In addition to being in a regular service perimeter, a resource can also
 * be in zero or more perimeter bridges.  A perimeter bridge only contains
 * resources.  Cross project operations are permitted if all effected
 * resources share some perimeter (whether bridge or regular). Perimeter
 * Bridge does not contain access levels or services: those are governed
 * entirely by the regular perimeter that resource is in.
 *
 * Perimeter Bridges are typically useful when building more complex toplogies
 * with many independent perimeters that need to share some data with a common
 * perimeter, but should not be able to share data among themselves.
 *
 * @generated from enum google.identity.accesscontextmanager.v1.ServicePerimeter.PerimeterType
 */
export enum ServicePerimeter_PerimeterType {
  /**
   * Regular Perimeter.
   *
   * @generated from enum value: PERIMETER_TYPE_REGULAR = 0;
   */
  REGULAR = 0,

  /**
   * Perimeter Bridge.
   *
   * @generated from enum value: PERIMETER_TYPE_BRIDGE = 1;
   */
  BRIDGE = 1,
}

/**
 * Describes the enum google.identity.accesscontextmanager.v1.ServicePerimeter.PerimeterType.
 */
export const ServicePerimeter_PerimeterTypeSchema: GenEnum<ServicePerimeter_PerimeterType> = /*@__PURE__*/
  enumDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 0, 0);

/**
 * `ServicePerimeterConfig` specifies a set of Google Cloud resources that
 * describe specific Service Perimeter configuration.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig
 */
export type ServicePerimeterConfig = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig"> & {
  /**
   * A list of Google Cloud resources that are inside of the service perimeter.
   * Currently only projects are allowed. Format: `projects/{project_number}`
   *
   * @generated from field: repeated string resources = 1;
   */
  resources: string[];

  /**
   * A list of `AccessLevel` resource names that allow resources within the
   * `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed
   * must be in the same policy as this `ServicePerimeter`. Referencing a
   * nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are
   * listed, resources within the perimeter can only be accessed via Google
   * Cloud calls with request origins within the perimeter. Example:
   * `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`.
   * For Service Perimeter Bridge, must be empty.
   *
   * @generated from field: repeated string access_levels = 2;
   */
  accessLevels: string[];

  /**
   * Google Cloud services that are subject to the Service Perimeter
   * restrictions. For example, if `storage.googleapis.com` is specified, access
   * to the storage buckets inside the perimeter must meet the perimeter's
   * access restrictions.
   *
   * @generated from field: repeated string restricted_services = 4;
   */
  restrictedServices: string[];

  /**
   * Configuration for APIs allowed within Perimeter.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.VpcAccessibleServices vpc_accessible_services = 10;
   */
  vpcAccessibleServices?: ServicePerimeterConfig_VpcAccessibleServices;

  /**
   * List of [IngressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply to the perimeter. A perimeter may have multiple [IngressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy],
   * each of which is evaluated separately. Access is granted if any [Ingress
   * Policy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * grants it. Must be empty for a perimeter bridge.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy ingress_policies = 8;
   */
  ingressPolicies: ServicePerimeterConfig_IngressPolicy[];

  /**
   * List of [EgressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply to the perimeter. A perimeter may have multiple [EgressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy],
   * each of which is evaluated separately. Access is granted if any
   * [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * grants it. Must be empty for a perimeter bridge.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy egress_policies = 9;
   */
  egressPolicies: ServicePerimeterConfig_EgressPolicy[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.
 * Use `create(ServicePerimeterConfigSchema)` to create a new message.
 */
export const ServicePerimeterConfigSchema: GenMessage<ServicePerimeterConfig> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1);

/**
 * Specifies how APIs are allowed to communicate within the Service
 * Perimeter.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.VpcAccessibleServices
 */
export type ServicePerimeterConfig_VpcAccessibleServices = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.VpcAccessibleServices"> & {
  /**
   * Whether to restrict API calls within the Service Perimeter to the list of
   * APIs specified in 'allowed_services'.
   *
   * @generated from field: bool enable_restriction = 1;
   */
  enableRestriction: boolean;

  /**
   * The list of APIs usable within the Service Perimeter. Must be empty
   * unless 'enable_restriction' is True. You can specify a list of individual
   * services, as well as include the 'RESTRICTED-SERVICES' value, which
   * automatically includes all of the services protected by the perimeter.
   *
   * @generated from field: repeated string allowed_services = 2;
   */
  allowedServices: string[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.VpcAccessibleServices.
 * Use `create(ServicePerimeterConfig_VpcAccessibleServicesSchema)` to create a new message.
 */
export const ServicePerimeterConfig_VpcAccessibleServicesSchema: GenMessage<ServicePerimeterConfig_VpcAccessibleServices> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 0);

/**
 * An allowed method or permission of a service specified in [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector
 */
export type ServicePerimeterConfig_MethodSelector = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector"> & {
  /**
   * The API method name or Cloud IAM permission name to allow.
   *
   * @generated from oneof google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector.kind
   */
  kind: {
    /**
     * Value for `method` should be a valid method name for the corresponding
     * `service_name` in [ApiOperation]
     * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
     * If `*` used as value for `method`, then ALL methods and permissions are
     * allowed.
     *
     * @generated from field: string method = 1;
     */
    value: string;
    case: "method";
  } | {
    /**
     * Value for `permission` should be a valid Cloud IAM permission for the
     * corresponding `service_name` in [ApiOperation]
     * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
     *
     * @generated from field: string permission = 2;
     */
    value: string;
    case: "permission";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector.
 * Use `create(ServicePerimeterConfig_MethodSelectorSchema)` to create a new message.
 */
export const ServicePerimeterConfig_MethodSelectorSchema: GenMessage<ServicePerimeterConfig_MethodSelector> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 1);

/**
 * Identification for an API Operation.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation
 */
export type ServicePerimeterConfig_ApiOperation = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation"> & {
  /**
   * The name of the API whose methods or permissions the [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * or [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * want to allow. A single [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * with `service_name` field set to `*` will allow all methods AND
   * permissions for all services.
   *
   * @generated from field: string service_name = 1;
   */
  serviceName: string;

  /**
   * API methods or permissions to allow. Method or permission must belong to
   * the service specified by `service_name` field. A single [MethodSelector]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector]
   * entry with `*` specified for the `method` field will allow all methods
   * AND permissions for the service specified in `service_name`.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector method_selectors = 2;
   */
  methodSelectors: ServicePerimeterConfig_MethodSelector[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation.
 * Use `create(ServicePerimeterConfig_ApiOperationSchema)` to create a new message.
 */
export const ServicePerimeterConfig_ApiOperationSchema: GenMessage<ServicePerimeterConfig_ApiOperation> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 2);

/**
 * The source that [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * authorizes access from.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource
 */
export type ServicePerimeterConfig_IngressSource = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource"> & {
  /**
   * Allowed ingress source. It can be one of [AccessLevel]
   * [google.identity.accesscontextmanager.v1.AccessLevel] or Google
   * Cloud resource.
   *
   * @generated from oneof google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource.source
   */
  source: {
    /**
     * An [AccessLevel]
     * [google.identity.accesscontextmanager.v1.AccessLevel] resource
     * name that allow resources within the [ServicePerimeters]
     * [google.identity.accesscontextmanager.v1.ServicePerimeter] to be
     * accessed from the internet. [AccessLevels]
     * [google.identity.accesscontextmanager.v1.AccessLevel] listed must
     * be in the same policy as this [ServicePerimeter]
     * [google.identity.accesscontextmanager.v1.ServicePerimeter].
     * Referencing a nonexistent [AccessLevel]
     * [google.identity.accesscontextmanager.v1.AccessLevel] will cause
     * an error. If no [AccessLevel]
     * [google.identity.accesscontextmanager.v1.AccessLevel] names are
     * listed, resources within the perimeter can only be accessed via Google
     * Cloud calls with request origins within the perimeter. Example:
     * `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is
     * specified for `access_level`, then all [IngressSources]
     * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource]
     * will be allowed.
     *
     * @generated from field: string access_level = 1;
     */
    value: string;
    case: "accessLevel";
  } | {
    /**
     * A Google Cloud resource that is allowed to ingress the perimeter.
     * Requests from these resources will be allowed to access perimeter data.
     * Currently only projects are allowed.
     * Format: `projects/{project_number}`
     * The project may be in any Google Cloud organization, not just the
     * organization that the perimeter is defined in. `*` is not allowed, the
     * case of allowing all Google Cloud resources only is not supported.
     *
     * @generated from field: string resource = 2;
     */
    value: string;
    case: "resource";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource.
 * Use `create(ServicePerimeterConfig_IngressSourceSchema)` to create a new message.
 */
export const ServicePerimeterConfig_IngressSourceSchema: GenMessage<ServicePerimeterConfig_IngressSource> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 3);

/**
 * Defines the conditions under which an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request. Conditions are based on information about the source of
 * the request. The request must satisfy what is defined in `sources` AND
 * identity related fields in order to match.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom
 */
export type ServicePerimeterConfig_IngressFrom = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom"> & {
  /**
   * Sources that this [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * authorizes access from.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource sources = 1;
   */
  sources: ServicePerimeterConfig_IngressSource[];

  /**
   * A list of identities that are allowed access through this ingress
   * policy. Should be in the format of email address. The email address
   * should represent individual user or service account only.
   *
   * @generated from field: repeated string identities = 2;
   */
  identities: string[];

  /**
   * Specifies the type of identities that are allowed access from outside the
   * perimeter. If left unspecified, then members of `identities` field will
   * be allowed access.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType identity_type = 3;
   */
  identityType: ServicePerimeterConfig_IdentityType;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom.
 * Use `create(ServicePerimeterConfig_IngressFromSchema)` to create a new message.
 */
export const ServicePerimeterConfig_IngressFromSchema: GenMessage<ServicePerimeterConfig_IngressFrom> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 4);

/**
 * Defines the conditions under which an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request. Conditions are based on information about the
 * [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
 * intended to be performed on the target resource of the request. The request
 * must satisfy what is defined in `operations` AND `resources` in order to
 * match.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressTo
 */
export type ServicePerimeterConfig_IngressTo = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressTo"> & {
  /**
   * A list of [ApiOperations]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * allowed to be performed by the sources specified in corresponding
   * [IngressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
   * in this [ServicePerimeter]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter].
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation operations = 1;
   */
  operations: ServicePerimeterConfig_ApiOperation[];

  /**
   * A list of resources, currently only projects in the form
   * `projects/<projectnumber>`, protected by this [ServicePerimeter]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter] that are
   * allowed to be accessed by sources defined in the corresponding
   * [IngressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom].
   * If a single `*` is specified, then access to all resources inside the
   * perimeter are allowed.
   *
   * @generated from field: repeated string resources = 2;
   */
  resources: string[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressTo.
 * Use `create(ServicePerimeterConfig_IngressToSchema)` to create a new message.
 */
export const ServicePerimeterConfig_IngressToSchema: GenMessage<ServicePerimeterConfig_IngressTo> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 5);

/**
 * Policy for ingress into [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter].
 *
 * [IngressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * match requests based on `ingress_from` and `ingress_to` stanzas.  For an
 * ingress policy to match, both the `ingress_from` and `ingress_to` stanzas
 * must be matched. If an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request, the request is allowed through the perimeter boundary
 * from outside the perimeter.
 *
 * For example, access from the internet can be allowed either
 * based on an [AccessLevel]
 * [google.identity.accesscontextmanager.v1.AccessLevel] or, for traffic
 * hosted on Google Cloud, the project of the source network. For access from
 * private networks, using the project of the hosting network is required.
 *
 * Individual ingress policies can be limited by restricting which
 * services and/or actions they match using the `ingress_to` field.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy
 */
export type ServicePerimeterConfig_IngressPolicy = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy"> & {
  /**
   * Defines the conditions on the source of a request causing this
   * [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom ingress_from = 1;
   */
  ingressFrom?: ServicePerimeterConfig_IngressFrom;

  /**
   * Defines the conditions on the [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * and request destination that cause this [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressTo ingress_to = 2;
   */
  ingressTo?: ServicePerimeterConfig_IngressTo;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy.
 * Use `create(ServicePerimeterConfig_IngressPolicySchema)` to create a new message.
 */
export const ServicePerimeterConfig_IngressPolicySchema: GenMessage<ServicePerimeterConfig_IngressPolicy> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 6);

/**
 * Defines the conditions under which an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request. Conditions based on information about the source of the
 * request. Note that if the destination of the request is also protected by a
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
 * an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * which allows access in order for this request to succeed.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom
 */
export type ServicePerimeterConfig_EgressFrom = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom"> & {
  /**
   * A list of identities that are allowed access through this [EgressPolicy].
   * Should be in the format of email address. The email address should
   * represent individual user or service account only.
   *
   * @generated from field: repeated string identities = 1;
   */
  identities: string[];

  /**
   * Specifies the type of identities that are allowed access to outside the
   * perimeter. If left unspecified, then members of `identities` field will
   * be allowed access.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType identity_type = 2;
   */
  identityType: ServicePerimeterConfig_IdentityType;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom.
 * Use `create(ServicePerimeterConfig_EgressFromSchema)` to create a new message.
 */
export const ServicePerimeterConfig_EgressFromSchema: GenMessage<ServicePerimeterConfig_EgressFrom> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 7);

/**
 * Defines the conditions under which an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request. Conditions are based on information about the
 * [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
 * intended to be performed on the `resources` specified. Note that if the
 * destination of the request is also protected by a [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
 * an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * which allows access in order for this request to succeed. The request must
 * match `operations` AND `resources` fields in order to be allowed egress out
 * of the perimeter.
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo
 */
export type ServicePerimeterConfig_EgressTo = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo"> & {
  /**
   * A list of resources, currently only projects in the form
   * `projects/<projectnumber>`, that are allowed to be accessed by sources
   * defined in the corresponding [EgressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
   * A request matches if it contains a resource in this list.  If `*` is
   * specified for `resources`, then this [EgressTo]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo]
   * rule will authorize access to all resources outside the perimeter.
   *
   * @generated from field: repeated string resources = 1;
   */
  resources: string[];

  /**
   * A list of [ApiOperations]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * allowed to be performed by the sources specified in the corresponding
   * [EgressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
   * A request matches if it uses an operation/service in this list.
   *
   * @generated from field: repeated google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation operations = 2;
   */
  operations: ServicePerimeterConfig_ApiOperation[];

  /**
   * A list of external resources that are allowed to be accessed. Only AWS
   * and Azure resources are supported. For Amazon S3, the supported format is
   * s3://BUCKET_NAME. For Azure Storage, the supported format is
   * azure://myaccount.blob.core.windows.net/CONTAINER_NAME. A request matches
   * if it contains an external resource in this list (Example:
   * s3://bucket/path). Currently '*' is not allowed.
   *
   * @generated from field: repeated string external_resources = 3;
   */
  externalResources: string[];
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo.
 * Use `create(ServicePerimeterConfig_EgressToSchema)` to create a new message.
 */
export const ServicePerimeterConfig_EgressToSchema: GenMessage<ServicePerimeterConfig_EgressTo> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 8);

/**
 * Policy for egress from perimeter.
 *
 * [EgressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * match requests based on `egress_from` and `egress_to` stanzas.  For an
 * [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * to match, both `egress_from` and `egress_to` stanzas must be matched. If an
 * [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request, the request is allowed to span the [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] boundary.
 * For example, an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * can be used to allow VMs on networks within the [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] to access a
 * defined set of projects outside the perimeter in certain contexts (e.g. to
 * read data from a Cloud Storage bucket or query against a BigQuery dataset).
 *
 * [EgressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * are concerned with the *resources* that a request relates as well as the
 * API services and API actions being used.  They do not related to the
 * direction of data movement.  More detailed documentation for this concept
 * can be found in the descriptions of [EgressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
 * and [EgressTo]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo].
 *
 * @generated from message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy
 */
export type ServicePerimeterConfig_EgressPolicy = Message<"google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy"> & {
  /**
   * Defines conditions on the source of a request causing this [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom egress_from = 1;
   */
  egressFrom?: ServicePerimeterConfig_EgressFrom;

  /**
   * Defines the conditions on the [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * and destination resources that cause this [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply.
   *
   * @generated from field: google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo egress_to = 2;
   */
  egressTo?: ServicePerimeterConfig_EgressTo;
};

/**
 * Describes the message google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy.
 * Use `create(ServicePerimeterConfig_EgressPolicySchema)` to create a new message.
 */
export const ServicePerimeterConfig_EgressPolicySchema: GenMessage<ServicePerimeterConfig_EgressPolicy> = /*@__PURE__*/
  messageDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 9);

/**
 * Specifies the types of identities that are allowed access in either
 * [IngressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
 * or [EgressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
 * rules.
 *
 * @generated from enum google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType
 */
export enum ServicePerimeterConfig_IdentityType {
  /**
   * No blanket identity group specified.
   *
   * @generated from enum value: IDENTITY_TYPE_UNSPECIFIED = 0;
   */
  IDENTITY_TYPE_UNSPECIFIED = 0,

  /**
   * Authorize access from all identities outside the perimeter.
   *
   * @generated from enum value: ANY_IDENTITY = 1;
   */
  ANY_IDENTITY = 1,

  /**
   * Authorize access from all human users outside the perimeter.
   *
   * @generated from enum value: ANY_USER_ACCOUNT = 2;
   */
  ANY_USER_ACCOUNT = 2,

  /**
   * Authorize access from all service accounts outside the perimeter.
   *
   * @generated from enum value: ANY_SERVICE_ACCOUNT = 3;
   */
  ANY_SERVICE_ACCOUNT = 3,
}

/**
 * Describes the enum google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IdentityType.
 */
export const ServicePerimeterConfig_IdentityTypeSchema: GenEnum<ServicePerimeterConfig_IdentityType> = /*@__PURE__*/
  enumDesc(file_google_identity_accesscontextmanager_v1_service_perimeter, 1, 0);

