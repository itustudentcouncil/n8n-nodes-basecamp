// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/bigtable/admin/v2/types.proto (package google.bigtable.admin.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/bigtable/admin/v2/types.proto.
 */
export const file_google_bigtable_admin_v2_types: GenFile = /*@__PURE__*/
  fileDesc("CiRnb29nbGUvYmlndGFibGUvYWRtaW4vdjIvdHlwZXMucHJvdG8SGGdvb2dsZS5iaWd0YWJsZS5hZG1pbi52MiKaEgoEVHlwZRI6CgpieXRlc190eXBlGAEgASgLMiQuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQnl0ZXNIABI8CgtzdHJpbmdfdHlwZRgCIAEoCzIlLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLlN0cmluZ0gAEjoKCmludDY0X3R5cGUYBSABKAsyJC5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5JbnQ2NEgAEj4KDGZsb2F0MzJfdHlwZRgMIAEoCzImLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkZsb2F0MzJIABI+CgxmbG9hdDY0X3R5cGUYCSABKAsyJi5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5GbG9hdDY0SAASOAoJYm9vbF90eXBlGAggASgLMiMuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQm9vbEgAEkIKDnRpbWVzdGFtcF90eXBlGAogASgLMiguZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuVGltZXN0YW1wSAASOAoJZGF0ZV90eXBlGAsgASgLMiMuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuRGF0ZUgAEkIKDmFnZ3JlZ2F0ZV90eXBlGAYgASgLMiguZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQWdncmVnYXRlSAASPAoLc3RydWN0X3R5cGUYByABKAsyJS5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5TdHJ1Y3RIABI6CgphcnJheV90eXBlGAMgASgLMiQuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQXJyYXlIABI2CghtYXBfdHlwZRgEIAEoCzIiLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLk1hcEgAGqkBCgVCeXRlcxI/CghlbmNvZGluZxgBIAEoCzItLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkJ5dGVzLkVuY29kaW5nGl8KCEVuY29kaW5nEkAKA3JhdxgBIAEoCzIxLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkJ5dGVzLkVuY29kaW5nLlJhd0gAGgUKA1Jhd0IKCghlbmNvZGluZxqfAgoGU3RyaW5nEkAKCGVuY29kaW5nGAEgASgLMi4uZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuU3RyaW5nLkVuY29kaW5nGtIBCghFbmNvZGluZxJOCgh1dGY4X3JhdxgBIAEoCzI2Lmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLlN0cmluZy5FbmNvZGluZy5VdGY4UmF3QgIYAUgAEk4KCnV0ZjhfYnl0ZXMYAiABKAsyOC5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5TdHJpbmcuRW5jb2RpbmcuVXRmOEJ5dGVzSAAaDQoHVXRmOFJhdzoCGAEaCwoJVXRmOEJ5dGVzQgoKCGVuY29kaW5nGocCCgVJbnQ2NBI/CghlbmNvZGluZxgBIAEoCzItLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkludDY0LkVuY29kaW5nGrwBCghFbmNvZGluZxJYChBiaWdfZW5kaWFuX2J5dGVzGAEgASgLMjwuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuSW50NjQuRW5jb2RpbmcuQmlnRW5kaWFuQnl0ZXNIABpKCg5CaWdFbmRpYW5CeXRlcxI4CgpieXRlc190eXBlGAEgASgLMiQuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQnl0ZXNCCgoIZW5jb2RpbmcaBgoEQm9vbBoJCgdGbG9hdDMyGgkKB0Zsb2F0NjQaCwoJVGltZXN0YW1wGgYKBERhdGUakAEKBlN0cnVjdBI7CgZmaWVsZHMYASADKAsyKy5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5TdHJ1Y3QuRmllbGQaSQoFRmllbGQSEgoKZmllbGRfbmFtZRgBIAEoCRIsCgR0eXBlGAIgASgLMh4uZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUaPQoFQXJyYXkSNAoMZWxlbWVudF90eXBlGAEgASgLMh4uZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUaawoDTWFwEjAKCGtleV90eXBlGAEgASgLMh4uZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUSMgoKdmFsdWVfdHlwZRgCIAEoCzIeLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlGtsDCglBZ2dyZWdhdGUSMgoKaW5wdXRfdHlwZRgBIAEoCzIeLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlEjcKCnN0YXRlX3R5cGUYAiABKAsyHi5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZUID4EEDEjsKA3N1bRgEIAEoCzIsLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkFnZ3JlZ2F0ZS5TdW1IABJlChJobGxwcF91bmlxdWVfY291bnQYBSABKAsyRy5nb29nbGUuYmlndGFibGUuYWRtaW4udjIuVHlwZS5BZ2dyZWdhdGUuSHlwZXJMb2dMb2dQbHVzUGx1c1VuaXF1ZUNvdW50SAASOwoDbWF4GAYgASgLMiwuZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyLlR5cGUuQWdncmVnYXRlLk1heEgAEjsKA21pbhgHIAEoCzIsLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52Mi5UeXBlLkFnZ3JlZ2F0ZS5NaW5IABoFCgNTdW0aBQoDTWF4GgUKA01pbhogCh5IeXBlckxvZ0xvZ1BsdXNQbHVzVW5pcXVlQ291bnRCDAoKYWdncmVnYXRvckIGCgRraW5kQs0BChxjb20uZ29vZ2xlLmJpZ3RhYmxlLmFkbWluLnYyQgpUeXBlc1Byb3RvUAFaOGNsb3VkLmdvb2dsZS5jb20vZ28vYmlndGFibGUvYWRtaW4vYXBpdjIvYWRtaW5wYjthZG1pbnBiqgIeR29vZ2xlLkNsb3VkLkJpZ3RhYmxlLkFkbWluLlYyygIeR29vZ2xlXENsb3VkXEJpZ3RhYmxlXEFkbWluXFYy6gIiR29vZ2xlOjpDbG91ZDo6QmlndGFibGU6OkFkbWluOjpWMmIGcHJvdG8z", [file_google_api_field_behavior]);

/**
 * `Type` represents the type of data that is written to, read from, or stored
 * in Bigtable. It is heavily based on the GoogleSQL standard to help maintain
 * familiarity and consistency across products and features.
 *
 * For compatibility with Bigtable's existing untyped APIs, each `Type` includes
 * an `Encoding` which describes how to convert to/from the underlying data.
 *
 * Each encoding also defines the following properties:
 *
 *  * Order-preserving: Does the encoded value sort consistently with the
 *    original typed value? Note that Bigtable will always sort data based on
 *    the raw encoded value, *not* the decoded type.
 *     - Example: BYTES values sort in the same order as their raw encodings.
 *     - Counterexample: Encoding INT64 as a fixed-width decimal string does
 *       *not* preserve sort order when dealing with negative numbers.
 *       `INT64(1) > INT64(-1)`, but `STRING("-00001") > STRING("00001)`.
 *  * Self-delimiting: If we concatenate two encoded values, can we always tell
 *    where the first one ends and the second one begins?
 *     - Example: If we encode INT64s to fixed-width STRINGs, the first value
 *       will always contain exactly N digits, possibly preceded by a sign.
 *     - Counterexample: If we concatenate two UTF-8 encoded STRINGs, we have
 *       no way to tell where the first one ends.
 *  * Compatibility: Which other systems have matching encoding schemes? For
 *    example, does this encoding have a GoogleSQL equivalent? HBase? Java?
 *
 * @generated from message google.bigtable.admin.v2.Type
 */
export type Type = Message<"google.bigtable.admin.v2.Type"> & {
  /**
   * The kind of type that this represents.
   *
   * @generated from oneof google.bigtable.admin.v2.Type.kind
   */
  kind: {
    /**
     * Bytes
     *
     * @generated from field: google.bigtable.admin.v2.Type.Bytes bytes_type = 1;
     */
    value: Type_Bytes;
    case: "bytesType";
  } | {
    /**
     * String
     *
     * @generated from field: google.bigtable.admin.v2.Type.String string_type = 2;
     */
    value: Type_String;
    case: "stringType";
  } | {
    /**
     * Int64
     *
     * @generated from field: google.bigtable.admin.v2.Type.Int64 int64_type = 5;
     */
    value: Type_Int64;
    case: "int64Type";
  } | {
    /**
     * Float32
     *
     * @generated from field: google.bigtable.admin.v2.Type.Float32 float32_type = 12;
     */
    value: Type_Float32;
    case: "float32Type";
  } | {
    /**
     * Float64
     *
     * @generated from field: google.bigtable.admin.v2.Type.Float64 float64_type = 9;
     */
    value: Type_Float64;
    case: "float64Type";
  } | {
    /**
     * Bool
     *
     * @generated from field: google.bigtable.admin.v2.Type.Bool bool_type = 8;
     */
    value: Type_Bool;
    case: "boolType";
  } | {
    /**
     * Timestamp
     *
     * @generated from field: google.bigtable.admin.v2.Type.Timestamp timestamp_type = 10;
     */
    value: Type_Timestamp;
    case: "timestampType";
  } | {
    /**
     * Date
     *
     * @generated from field: google.bigtable.admin.v2.Type.Date date_type = 11;
     */
    value: Type_Date;
    case: "dateType";
  } | {
    /**
     * Aggregate
     *
     * @generated from field: google.bigtable.admin.v2.Type.Aggregate aggregate_type = 6;
     */
    value: Type_Aggregate;
    case: "aggregateType";
  } | {
    /**
     * Struct
     *
     * @generated from field: google.bigtable.admin.v2.Type.Struct struct_type = 7;
     */
    value: Type_Struct;
    case: "structType";
  } | {
    /**
     * Array
     *
     * @generated from field: google.bigtable.admin.v2.Type.Array array_type = 3;
     */
    value: Type_Array;
    case: "arrayType";
  } | {
    /**
     * Map
     *
     * @generated from field: google.bigtable.admin.v2.Type.Map map_type = 4;
     */
    value: Type_Map;
    case: "mapType";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.admin.v2.Type.
 * Use `create(TypeSchema)` to create a new message.
 */
export const TypeSchema: GenMessage<Type> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0);

/**
 * Bytes
 * Values of type `Bytes` are stored in `Value.bytes_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Bytes
 */
export type Type_Bytes = Message<"google.bigtable.admin.v2.Type.Bytes"> & {
  /**
   * The encoding to use when converting to/from lower level types.
   *
   * @generated from field: google.bigtable.admin.v2.Type.Bytes.Encoding encoding = 1;
   */
  encoding?: Type_Bytes_Encoding;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Bytes.
 * Use `create(Type_BytesSchema)` to create a new message.
 */
export const Type_BytesSchema: GenMessage<Type_Bytes> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 0);

/**
 * Rules used to convert to/from lower level types.
 *
 * @generated from message google.bigtable.admin.v2.Type.Bytes.Encoding
 */
export type Type_Bytes_Encoding = Message<"google.bigtable.admin.v2.Type.Bytes.Encoding"> & {
  /**
   * Which encoding to use.
   *
   * @generated from oneof google.bigtable.admin.v2.Type.Bytes.Encoding.encoding
   */
  encoding: {
    /**
     * Use `Raw` encoding.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Bytes.Encoding.Raw raw = 1;
     */
    value: Type_Bytes_Encoding_Raw;
    case: "raw";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Bytes.Encoding.
 * Use `create(Type_Bytes_EncodingSchema)` to create a new message.
 */
export const Type_Bytes_EncodingSchema: GenMessage<Type_Bytes_Encoding> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 0, 0);

/**
 * Leaves the value "as-is"
 * * Order-preserving? Yes
 * * Self-delimiting? No
 * * Compatibility? N/A
 *
 * @generated from message google.bigtable.admin.v2.Type.Bytes.Encoding.Raw
 */
export type Type_Bytes_Encoding_Raw = Message<"google.bigtable.admin.v2.Type.Bytes.Encoding.Raw"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Bytes.Encoding.Raw.
 * Use `create(Type_Bytes_Encoding_RawSchema)` to create a new message.
 */
export const Type_Bytes_Encoding_RawSchema: GenMessage<Type_Bytes_Encoding_Raw> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 0, 0, 0);

/**
 * String
 * Values of type `String` are stored in `Value.string_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.String
 */
export type Type_String = Message<"google.bigtable.admin.v2.Type.String"> & {
  /**
   * The encoding to use when converting to/from lower level types.
   *
   * @generated from field: google.bigtable.admin.v2.Type.String.Encoding encoding = 1;
   */
  encoding?: Type_String_Encoding;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.String.
 * Use `create(Type_StringSchema)` to create a new message.
 */
export const Type_StringSchema: GenMessage<Type_String> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 1);

/**
 * Rules used to convert to/from lower level types.
 *
 * @generated from message google.bigtable.admin.v2.Type.String.Encoding
 */
export type Type_String_Encoding = Message<"google.bigtable.admin.v2.Type.String.Encoding"> & {
  /**
   * Which encoding to use.
   *
   * @generated from oneof google.bigtable.admin.v2.Type.String.Encoding.encoding
   */
  encoding: {
    /**
     * Deprecated: if set, converts to an empty `utf8_bytes`.
     *
     * @generated from field: google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw utf8_raw = 1 [deprecated = true];
     * @deprecated
     */
    value: Type_String_Encoding_Utf8Raw;
    case: "utf8Raw";
  } | {
    /**
     * Use `Utf8Bytes` encoding.
     *
     * @generated from field: google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes utf8_bytes = 2;
     */
    value: Type_String_Encoding_Utf8Bytes;
    case: "utf8Bytes";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.admin.v2.Type.String.Encoding.
 * Use `create(Type_String_EncodingSchema)` to create a new message.
 */
export const Type_String_EncodingSchema: GenMessage<Type_String_Encoding> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 1, 0);

/**
 * Deprecated: prefer the equivalent `Utf8Bytes`.
 *
 * @generated from message google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw
 * @deprecated
 */
export type Type_String_Encoding_Utf8Raw = Message<"google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw.
 * Use `create(Type_String_Encoding_Utf8RawSchema)` to create a new message.
 * @deprecated
 */
export const Type_String_Encoding_Utf8RawSchema: GenMessage<Type_String_Encoding_Utf8Raw> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 1, 0, 0);

/**
 * UTF-8 encoding
 * * Order-preserving? Yes (code point order)
 * * Self-delimiting? No
 * * Compatibility?
 *    - BigQuery Federation `TEXT` encoding
 *    - HBase `Bytes.toBytes`
 *    - Java `String#getBytes(StandardCharsets.UTF_8)`
 *
 * @generated from message google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes
 */
export type Type_String_Encoding_Utf8Bytes = Message<"google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes.
 * Use `create(Type_String_Encoding_Utf8BytesSchema)` to create a new message.
 */
export const Type_String_Encoding_Utf8BytesSchema: GenMessage<Type_String_Encoding_Utf8Bytes> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 1, 0, 1);

/**
 * Int64
 * Values of type `Int64` are stored in `Value.int_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Int64
 */
export type Type_Int64 = Message<"google.bigtable.admin.v2.Type.Int64"> & {
  /**
   * The encoding to use when converting to/from lower level types.
   *
   * @generated from field: google.bigtable.admin.v2.Type.Int64.Encoding encoding = 1;
   */
  encoding?: Type_Int64_Encoding;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Int64.
 * Use `create(Type_Int64Schema)` to create a new message.
 */
export const Type_Int64Schema: GenMessage<Type_Int64> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 2);

/**
 * Rules used to convert to/from lower level types.
 *
 * @generated from message google.bigtable.admin.v2.Type.Int64.Encoding
 */
export type Type_Int64_Encoding = Message<"google.bigtable.admin.v2.Type.Int64.Encoding"> & {
  /**
   * Which encoding to use.
   *
   * @generated from oneof google.bigtable.admin.v2.Type.Int64.Encoding.encoding
   */
  encoding: {
    /**
     * Use `BigEndianBytes` encoding.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes big_endian_bytes = 1;
     */
    value: Type_Int64_Encoding_BigEndianBytes;
    case: "bigEndianBytes";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Int64.Encoding.
 * Use `create(Type_Int64_EncodingSchema)` to create a new message.
 */
export const Type_Int64_EncodingSchema: GenMessage<Type_Int64_Encoding> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 2, 0);

/**
 * Encodes the value as an 8-byte big endian twos complement `Bytes`
 * value.
 * * Order-preserving? No (positive values only)
 * * Self-delimiting? Yes
 * * Compatibility?
 *    - BigQuery Federation `BINARY` encoding
 *    - HBase `Bytes.toBytes`
 *    - Java `ByteBuffer.putLong()` with `ByteOrder.BIG_ENDIAN`
 *
 * @generated from message google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes
 */
export type Type_Int64_Encoding_BigEndianBytes = Message<"google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes"> & {
  /**
   * Deprecated: ignored if set.
   *
   * @generated from field: google.bigtable.admin.v2.Type.Bytes bytes_type = 1;
   */
  bytesType?: Type_Bytes;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes.
 * Use `create(Type_Int64_Encoding_BigEndianBytesSchema)` to create a new message.
 */
export const Type_Int64_Encoding_BigEndianBytesSchema: GenMessage<Type_Int64_Encoding_BigEndianBytes> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 2, 0, 0);

/**
 * bool
 * Values of type `Bool` are stored in `Value.bool_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Bool
 */
export type Type_Bool = Message<"google.bigtable.admin.v2.Type.Bool"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Bool.
 * Use `create(Type_BoolSchema)` to create a new message.
 */
export const Type_BoolSchema: GenMessage<Type_Bool> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 3);

/**
 * Float32
 * Values of type `Float32` are stored in `Value.float_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Float32
 */
export type Type_Float32 = Message<"google.bigtable.admin.v2.Type.Float32"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Float32.
 * Use `create(Type_Float32Schema)` to create a new message.
 */
export const Type_Float32Schema: GenMessage<Type_Float32> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 4);

/**
 * Float64
 * Values of type `Float64` are stored in `Value.float_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Float64
 */
export type Type_Float64 = Message<"google.bigtable.admin.v2.Type.Float64"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Float64.
 * Use `create(Type_Float64Schema)` to create a new message.
 */
export const Type_Float64Schema: GenMessage<Type_Float64> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 5);

/**
 * Timestamp
 * Values of type `Timestamp` are stored in `Value.timestamp_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Timestamp
 */
export type Type_Timestamp = Message<"google.bigtable.admin.v2.Type.Timestamp"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Timestamp.
 * Use `create(Type_TimestampSchema)` to create a new message.
 */
export const Type_TimestampSchema: GenMessage<Type_Timestamp> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 6);

/**
 * Date
 * Values of type `Date` are stored in `Value.date_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Date
 */
export type Type_Date = Message<"google.bigtable.admin.v2.Type.Date"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Date.
 * Use `create(Type_DateSchema)` to create a new message.
 */
export const Type_DateSchema: GenMessage<Type_Date> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 7);

/**
 * A structured data value, consisting of fields which map to dynamically
 * typed values.
 * Values of type `Struct` are stored in `Value.array_value` where entries are
 * in the same order and number as `field_types`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Struct
 */
export type Type_Struct = Message<"google.bigtable.admin.v2.Type.Struct"> & {
  /**
   * The names and types of the fields in this struct.
   *
   * @generated from field: repeated google.bigtable.admin.v2.Type.Struct.Field fields = 1;
   */
  fields: Type_Struct_Field[];
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Struct.
 * Use `create(Type_StructSchema)` to create a new message.
 */
export const Type_StructSchema: GenMessage<Type_Struct> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 8);

/**
 * A struct field and its type.
 *
 * @generated from message google.bigtable.admin.v2.Type.Struct.Field
 */
export type Type_Struct_Field = Message<"google.bigtable.admin.v2.Type.Struct.Field"> & {
  /**
   * The field name (optional). Fields without a `field_name` are considered
   * anonymous and cannot be referenced by name.
   *
   * @generated from field: string field_name = 1;
   */
  fieldName: string;

  /**
   * The type of values in this field.
   *
   * @generated from field: google.bigtable.admin.v2.Type type = 2;
   */
  type?: Type;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Struct.Field.
 * Use `create(Type_Struct_FieldSchema)` to create a new message.
 */
export const Type_Struct_FieldSchema: GenMessage<Type_Struct_Field> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 8, 0);

/**
 * An ordered list of elements of a given type.
 * Values of type `Array` are stored in `Value.array_value`.
 *
 * @generated from message google.bigtable.admin.v2.Type.Array
 */
export type Type_Array = Message<"google.bigtable.admin.v2.Type.Array"> & {
  /**
   * The type of the elements in the array. This must not be `Array`.
   *
   * @generated from field: google.bigtable.admin.v2.Type element_type = 1;
   */
  elementType?: Type;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Array.
 * Use `create(Type_ArraySchema)` to create a new message.
 */
export const Type_ArraySchema: GenMessage<Type_Array> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 9);

/**
 * A mapping of keys to values of a given type.
 * Values of type `Map` are stored in a `Value.array_value` where each entry
 * is another `Value.array_value` with two elements (the key and the value,
 * in that order).
 * Normally encoded Map values won't have repeated keys, however, clients are
 * expected to handle the case in which they do. If the same key appears
 * multiple times, the _last_ value takes precedence.
 *
 * @generated from message google.bigtable.admin.v2.Type.Map
 */
export type Type_Map = Message<"google.bigtable.admin.v2.Type.Map"> & {
  /**
   * The type of a map key.
   * Only `Bytes`, `String`, and `Int64` are allowed as key types.
   *
   * @generated from field: google.bigtable.admin.v2.Type key_type = 1;
   */
  keyType?: Type;

  /**
   * The type of the values in a map.
   *
   * @generated from field: google.bigtable.admin.v2.Type value_type = 2;
   */
  valueType?: Type;
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Map.
 * Use `create(Type_MapSchema)` to create a new message.
 */
export const Type_MapSchema: GenMessage<Type_Map> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 10);

/**
 * A value that combines incremental updates into a summarized value.
 *
 * Data is never directly written or read using type `Aggregate`. Writes will
 * provide either the `input_type` or `state_type`, and reads will always
 * return the `state_type` .
 *
 * @generated from message google.bigtable.admin.v2.Type.Aggregate
 */
export type Type_Aggregate = Message<"google.bigtable.admin.v2.Type.Aggregate"> & {
  /**
   * Type of the inputs that are accumulated by this `Aggregate`, which must
   * specify a full encoding.
   * Use `AddInput` mutations to accumulate new inputs.
   *
   * @generated from field: google.bigtable.admin.v2.Type input_type = 1;
   */
  inputType?: Type;

  /**
   * Output only. Type that holds the internal accumulator state for the
   * `Aggregate`. This is a function of the `input_type` and `aggregator`
   * chosen, and will always specify a full encoding.
   *
   * @generated from field: google.bigtable.admin.v2.Type state_type = 2;
   */
  stateType?: Type;

  /**
   * Which aggregator function to use. The configured types must match.
   *
   * @generated from oneof google.bigtable.admin.v2.Type.Aggregate.aggregator
   */
  aggregator: {
    /**
     * Sum aggregator.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Aggregate.Sum sum = 4;
     */
    value: Type_Aggregate_Sum;
    case: "sum";
  } | {
    /**
     * HyperLogLogPlusPlusUniqueCount aggregator.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount hllpp_unique_count = 5;
     */
    value: Type_Aggregate_HyperLogLogPlusPlusUniqueCount;
    case: "hllppUniqueCount";
  } | {
    /**
     * Max aggregator.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Aggregate.Max max = 6;
     */
    value: Type_Aggregate_Max;
    case: "max";
  } | {
    /**
     * Min aggregator.
     *
     * @generated from field: google.bigtable.admin.v2.Type.Aggregate.Min min = 7;
     */
    value: Type_Aggregate_Min;
    case: "min";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Aggregate.
 * Use `create(Type_AggregateSchema)` to create a new message.
 */
export const Type_AggregateSchema: GenMessage<Type_Aggregate> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 11);

/**
 * Computes the sum of the input values.
 * Allowed input: `Int64`
 * State: same as input
 *
 * @generated from message google.bigtable.admin.v2.Type.Aggregate.Sum
 */
export type Type_Aggregate_Sum = Message<"google.bigtable.admin.v2.Type.Aggregate.Sum"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Aggregate.Sum.
 * Use `create(Type_Aggregate_SumSchema)` to create a new message.
 */
export const Type_Aggregate_SumSchema: GenMessage<Type_Aggregate_Sum> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 11, 0);

/**
 * Computes the max of the input values.
 * Allowed input: `Int64`
 * State: same as input
 *
 * @generated from message google.bigtable.admin.v2.Type.Aggregate.Max
 */
export type Type_Aggregate_Max = Message<"google.bigtable.admin.v2.Type.Aggregate.Max"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Aggregate.Max.
 * Use `create(Type_Aggregate_MaxSchema)` to create a new message.
 */
export const Type_Aggregate_MaxSchema: GenMessage<Type_Aggregate_Max> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 11, 1);

/**
 * Computes the min of the input values.
 * Allowed input: `Int64`
 * State: same as input
 *
 * @generated from message google.bigtable.admin.v2.Type.Aggregate.Min
 */
export type Type_Aggregate_Min = Message<"google.bigtable.admin.v2.Type.Aggregate.Min"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Aggregate.Min.
 * Use `create(Type_Aggregate_MinSchema)` to create a new message.
 */
export const Type_Aggregate_MinSchema: GenMessage<Type_Aggregate_Min> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 11, 2);

/**
 * Computes an approximate unique count over the input values. When using
 * raw data as input, be careful to use a consistent encoding. Otherwise
 * the same value encoded differently could count more than once, or two
 * distinct values could count as identical.
 * Input: Any, or omit for Raw
 * State: TBD
 * Special state conversions: `Int64` (the unique count estimate)
 *
 * @generated from message google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount
 */
export type Type_Aggregate_HyperLogLogPlusPlusUniqueCount = Message<"google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount"> & {
};

/**
 * Describes the message google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount.
 * Use `create(Type_Aggregate_HyperLogLogPlusPlusUniqueCountSchema)` to create a new message.
 */
export const Type_Aggregate_HyperLogLogPlusPlusUniqueCountSchema: GenMessage<Type_Aggregate_HyperLogLogPlusPlusUniqueCount> = /*@__PURE__*/
  messageDesc(file_google_bigtable_admin_v2_types, 0, 11, 3);

