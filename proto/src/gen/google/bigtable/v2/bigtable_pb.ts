// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/bigtable/v2/bigtable.proto (package google.bigtable.v2, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import { file_google_api_resource } from "../../api/resource_pb";
import { file_google_api_routing } from "../../api/routing_pb";
import type { Mutation, PartialResultSet, ProtoFormat, ReadModifyWriteRule, ResultSetMetadata, Row, RowFilter, RowSet, StreamContinuationToken, StreamContinuationTokens, StreamPartition, Value } from "./data_pb";
import { file_google_bigtable_v2_data } from "./data_pb";
import type { RequestStats } from "./request_stats_pb";
import { file_google_bigtable_v2_request_stats } from "./request_stats_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/bigtable/v2/bigtable.proto.
 */
export const file_google_bigtable_v2_bigtable: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvYmlndGFibGUvdjIvYmlndGFibGUucHJvdG8SEmdvb2dsZS5iaWd0YWJsZS52MiL1AwoPUmVhZFJvd3NSZXF1ZXN0Ej4KCnRhYmxlX25hbWUYASABKAlCKuBBAfpBJAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRJRChRhdXRob3JpemVkX3ZpZXdfbmFtZRgJIAEoCUIz4EEB+kEtCitiaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL0F1dGhvcml6ZWRWaWV3EhYKDmFwcF9wcm9maWxlX2lkGAUgASgJEigKBHJvd3MYAiABKAsyGi5nb29nbGUuYmlndGFibGUudjIuUm93U2V0Ei0KBmZpbHRlchgDIAEoCzIdLmdvb2dsZS5iaWd0YWJsZS52Mi5Sb3dGaWx0ZXISEgoKcm93c19saW1pdBgEIAEoAxJQChJyZXF1ZXN0X3N0YXRzX3ZpZXcYBiABKA4yNC5nb29nbGUuYmlndGFibGUudjIuUmVhZFJvd3NSZXF1ZXN0LlJlcXVlc3RTdGF0c1ZpZXcSEAoIcmV2ZXJzZWQYByABKAgiZgoQUmVxdWVzdFN0YXRzVmlldxIiCh5SRVFVRVNUX1NUQVRTX1ZJRVdfVU5TUEVDSUZJRUQQABIWChJSRVFVRVNUX1NUQVRTX05PTkUQARIWChJSRVFVRVNUX1NUQVRTX0ZVTEwQAiKxAwoQUmVhZFJvd3NSZXNwb25zZRI+CgZjaHVua3MYASADKAsyLi5nb29nbGUuYmlndGFibGUudjIuUmVhZFJvd3NSZXNwb25zZS5DZWxsQ2h1bmsSHAoUbGFzdF9zY2FubmVkX3Jvd19rZXkYAiABKAwSNwoNcmVxdWVzdF9zdGF0cxgDIAEoCzIgLmdvb2dsZS5iaWd0YWJsZS52Mi5SZXF1ZXN0U3RhdHMahQIKCUNlbGxDaHVuaxIPCgdyb3dfa2V5GAEgASgMEjEKC2ZhbWlseV9uYW1lGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlEi4KCXF1YWxpZmllchgDIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlEhgKEHRpbWVzdGFtcF9taWNyb3MYBCABKAMSDgoGbGFiZWxzGAUgAygJEg0KBXZhbHVlGAYgASgMEhIKCnZhbHVlX3NpemUYByABKAUSEwoJcmVzZXRfcm93GAggASgISAASFAoKY29tbWl0X3JvdxgJIAEoCEgAQgwKCnJvd19zdGF0dXMiwQEKFFNhbXBsZVJvd0tleXNSZXF1ZXN0Ej4KCnRhYmxlX25hbWUYASABKAlCKuBBAfpBJAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRJRChRhdXRob3JpemVkX3ZpZXdfbmFtZRgEIAEoCUIz4EEB+kEtCitiaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL0F1dGhvcml6ZWRWaWV3EhYKDmFwcF9wcm9maWxlX2lkGAIgASgJIj4KFVNhbXBsZVJvd0tleXNSZXNwb25zZRIPCgdyb3dfa2V5GAEgASgMEhQKDG9mZnNldF9ieXRlcxgCIAEoAyKJAgoQTXV0YXRlUm93UmVxdWVzdBI+Cgp0YWJsZV9uYW1lGAEgASgJQirgQQH6QSQKImJpZ3RhYmxlYWRtaW4uZ29vZ2xlYXBpcy5jb20vVGFibGUSUQoUYXV0aG9yaXplZF92aWV3X25hbWUYBiABKAlCM+BBAfpBLQorYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9BdXRob3JpemVkVmlldxIWCg5hcHBfcHJvZmlsZV9pZBgEIAEoCRIUCgdyb3dfa2V5GAIgASgMQgPgQQISNAoJbXV0YXRpb25zGAMgAygLMhwuZ29vZ2xlLmJpZ3RhYmxlLnYyLk11dGF0aW9uQgPgQQIiEwoRTXV0YXRlUm93UmVzcG9uc2Ui0QIKEU11dGF0ZVJvd3NSZXF1ZXN0Ej4KCnRhYmxlX25hbWUYASABKAlCKuBBAfpBJAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRJRChRhdXRob3JpemVkX3ZpZXdfbmFtZRgFIAEoCUIz4EEB+kEtCitiaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL0F1dGhvcml6ZWRWaWV3EhYKDmFwcF9wcm9maWxlX2lkGAMgASgJEkEKB2VudHJpZXMYAiADKAsyKy5nb29nbGUuYmlndGFibGUudjIuTXV0YXRlUm93c1JlcXVlc3QuRW50cnlCA+BBAhpOCgVFbnRyeRIPCgdyb3dfa2V5GAEgASgMEjQKCW11dGF0aW9ucxgCIAMoCzIcLmdvb2dsZS5iaWd0YWJsZS52Mi5NdXRhdGlvbkID4EECIuQBChJNdXRhdGVSb3dzUmVzcG9uc2USPQoHZW50cmllcxgBIAMoCzIsLmdvb2dsZS5iaWd0YWJsZS52Mi5NdXRhdGVSb3dzUmVzcG9uc2UuRW50cnkSPwoPcmF0ZV9saW1pdF9pbmZvGAMgASgLMiEuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJhdGVMaW1pdEluZm9IAIgBARo6CgVFbnRyeRINCgVpbmRleBgBIAEoAxIiCgZzdGF0dXMYAiABKAsyEi5nb29nbGUucnBjLlN0YXR1c0ISChBfcmF0ZV9saW1pdF9pbmZvIkoKDVJhdGVMaW1pdEluZm8SKQoGcGVyaW9kGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEg4KBmZhY3RvchgCIAEoASKBAwoYQ2hlY2tBbmRNdXRhdGVSb3dSZXF1ZXN0Ej4KCnRhYmxlX25hbWUYASABKAlCKuBBAfpBJAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRJRChRhdXRob3JpemVkX3ZpZXdfbmFtZRgJIAEoCUIz4EEB+kEtCitiaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL0F1dGhvcml6ZWRWaWV3EhYKDmFwcF9wcm9maWxlX2lkGAcgASgJEhQKB3Jvd19rZXkYAiABKAxCA+BBAhI3ChBwcmVkaWNhdGVfZmlsdGVyGAYgASgLMh0uZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd0ZpbHRlchI0Cg50cnVlX211dGF0aW9ucxgEIAMoCzIcLmdvb2dsZS5iaWd0YWJsZS52Mi5NdXRhdGlvbhI1Cg9mYWxzZV9tdXRhdGlvbnMYBSADKAsyHC5nb29nbGUuYmlndGFibGUudjIuTXV0YXRpb24iNgoZQ2hlY2tBbmRNdXRhdGVSb3dSZXNwb25zZRIZChFwcmVkaWNhdGVfbWF0Y2hlZBgBIAEoCCJpChJQaW5nQW5kV2FybVJlcXVlc3QSOwoEbmFtZRgBIAEoCUIt4EEC+kEnCiViaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL0luc3RhbmNlEhYKDmFwcF9wcm9maWxlX2lkGAIgASgJIhUKE1BpbmdBbmRXYXJtUmVzcG9uc2UimQIKGVJlYWRNb2RpZnlXcml0ZVJvd1JlcXVlc3QSPgoKdGFibGVfbmFtZRgBIAEoCUIq4EEB+kEkCiJiaWd0YWJsZWFkbWluLmdvb2dsZWFwaXMuY29tL1RhYmxlElEKFGF1dGhvcml6ZWRfdmlld19uYW1lGAYgASgJQjPgQQH6QS0KK2JpZ3RhYmxlYWRtaW4uZ29vZ2xlYXBpcy5jb20vQXV0aG9yaXplZFZpZXcSFgoOYXBwX3Byb2ZpbGVfaWQYBCABKAkSFAoHcm93X2tleRgCIAEoDEID4EECEjsKBXJ1bGVzGAMgAygLMicuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJlYWRNb2RpZnlXcml0ZVJ1bGVCA+BBAiJCChpSZWFkTW9kaWZ5V3JpdGVSb3dSZXNwb25zZRIkCgNyb3cYASABKAsyFy5nb29nbGUuYmlndGFibGUudjIuUm93IoYBCixHZW5lcmF0ZUluaXRpYWxDaGFuZ2VTdHJlYW1QYXJ0aXRpb25zUmVxdWVzdBI+Cgp0YWJsZV9uYW1lGAEgASgJQirgQQL6QSQKImJpZ3RhYmxlYWRtaW4uZ29vZ2xlYXBpcy5jb20vVGFibGUSFgoOYXBwX3Byb2ZpbGVfaWQYAiABKAkiZwotR2VuZXJhdGVJbml0aWFsQ2hhbmdlU3RyZWFtUGFydGl0aW9uc1Jlc3BvbnNlEjYKCXBhcnRpdGlvbhgBIAEoCzIjLmdvb2dsZS5iaWd0YWJsZS52Mi5TdHJlYW1QYXJ0aXRpb24imwMKF1JlYWRDaGFuZ2VTdHJlYW1SZXF1ZXN0Ej4KCnRhYmxlX25hbWUYASABKAlCKuBBAvpBJAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRIWCg5hcHBfcHJvZmlsZV9pZBgCIAEoCRI2CglwYXJ0aXRpb24YAyABKAsyIy5nb29nbGUuYmlndGFibGUudjIuU3RyZWFtUGFydGl0aW9uEjAKCnN0YXJ0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAASSwoTY29udGludWF0aW9uX3Rva2VucxgGIAEoCzIsLmdvb2dsZS5iaWd0YWJsZS52Mi5TdHJlYW1Db250aW51YXRpb25Ub2tlbnNIABIsCghlbmRfdGltZRgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNQoSaGVhcnRiZWF0X2R1cmF0aW9uGAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgwKCnN0YXJ0X2Zyb20iqQoKGFJlYWRDaGFuZ2VTdHJlYW1SZXNwb25zZRJOCgtkYXRhX2NoYW5nZRgBIAEoCzI3Lmdvb2dsZS5iaWd0YWJsZS52Mi5SZWFkQ2hhbmdlU3RyZWFtUmVzcG9uc2UuRGF0YUNoYW5nZUgAEksKCWhlYXJ0YmVhdBgCIAEoCzI2Lmdvb2dsZS5iaWd0YWJsZS52Mi5SZWFkQ2hhbmdlU3RyZWFtUmVzcG9uc2UuSGVhcnRiZWF0SAASUAoMY2xvc2Vfc3RyZWFtGAMgASgLMjguZ29vZ2xlLmJpZ3RhYmxlLnYyLlJlYWRDaGFuZ2VTdHJlYW1SZXNwb25zZS5DbG9zZVN0cmVhbUgAGvQBCg1NdXRhdGlvbkNodW5rElgKCmNodW5rX2luZm8YASABKAsyRC5nb29nbGUuYmlndGFibGUudjIuUmVhZENoYW5nZVN0cmVhbVJlc3BvbnNlLk11dGF0aW9uQ2h1bmsuQ2h1bmtJbmZvEi4KCG11dGF0aW9uGAIgASgLMhwuZ29vZ2xlLmJpZ3RhYmxlLnYyLk11dGF0aW9uGlkKCUNodW5rSW5mbxIaChJjaHVua2VkX3ZhbHVlX3NpemUYASABKAUSHAoUY2h1bmtlZF92YWx1ZV9vZmZzZXQYAiABKAUSEgoKbGFzdF9jaHVuaxgDIAEoCBrGAwoKRGF0YUNoYW5nZRJKCgR0eXBlGAEgASgOMjwuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJlYWRDaGFuZ2VTdHJlYW1SZXNwb25zZS5EYXRhQ2hhbmdlLlR5cGUSGQoRc291cmNlX2NsdXN0ZXJfaWQYAiABKAkSDwoHcm93X2tleRgDIAEoDBI0ChBjb21taXRfdGltZXN0YW1wGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBISCgp0aWVicmVha2VyGAUgASgFEkoKBmNodW5rcxgGIAMoCzI6Lmdvb2dsZS5iaWd0YWJsZS52Mi5SZWFkQ2hhbmdlU3RyZWFtUmVzcG9uc2UuTXV0YXRpb25DaHVuaxIMCgRkb25lGAggASgIEg0KBXRva2VuGAkgASgJEjsKF2VzdGltYXRlZF9sb3dfd2F0ZXJtYXJrGAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJQCgRUeXBlEhQKEFRZUEVfVU5TUEVDSUZJRUQQABIICgRVU0VSEAESFgoSR0FSQkFHRV9DT0xMRUNUSU9OEAISEAoMQ09OVElOVUFUSU9OEAMakQEKCUhlYXJ0YmVhdBJHChJjb250aW51YXRpb25fdG9rZW4YASABKAsyKy5nb29nbGUuYmlndGFibGUudjIuU3RyZWFtQ29udGludWF0aW9uVG9rZW4SOwoXZXN0aW1hdGVkX2xvd193YXRlcm1hcmsYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGrgBCgtDbG9zZVN0cmVhbRIiCgZzdGF0dXMYASABKAsyEi5nb29nbGUucnBjLlN0YXR1cxJIChNjb250aW51YXRpb25fdG9rZW5zGAIgAygLMisuZ29vZ2xlLmJpZ3RhYmxlLnYyLlN0cmVhbUNvbnRpbnVhdGlvblRva2VuEjsKDm5ld19wYXJ0aXRpb25zGAMgAygLMiMuZ29vZ2xlLmJpZ3RhYmxlLnYyLlN0cmVhbVBhcnRpdGlvbkIPCg1zdHJlYW1fcmVjb3JkIoMDChNFeGVjdXRlUXVlcnlSZXF1ZXN0EkQKDWluc3RhbmNlX25hbWUYASABKAlCLeBBAvpBJwolYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9JbnN0YW5jZRIbCg5hcHBfcHJvZmlsZV9pZBgCIAEoCUID4EEBEhIKBXF1ZXJ5GAMgASgJQgPgQQISNwoMcHJvdG9fZm9ybWF0GAQgASgLMh8uZ29vZ2xlLmJpZ3RhYmxlLnYyLlByb3RvRm9ybWF0SAASGQoMcmVzdW1lX3Rva2VuGAggASgMQgPgQQESSAoGcGFyYW1zGAcgAygLMjMuZ29vZ2xlLmJpZ3RhYmxlLnYyLkV4ZWN1dGVRdWVyeVJlcXVlc3QuUGFyYW1zRW50cnlCA+BBAhpICgtQYXJhbXNFbnRyeRILCgNrZXkYASABKAkSKAoFdmFsdWUYAiABKAsyGS5nb29nbGUuYmlndGFibGUudjIuVmFsdWU6AjgBQg0KC2RhdGFfZm9ybWF0IpYBChRFeGVjdXRlUXVlcnlSZXNwb25zZRI5CghtZXRhZGF0YRgBIAEoCzIlLmdvb2dsZS5iaWd0YWJsZS52Mi5SZXN1bHRTZXRNZXRhZGF0YUgAEjcKB3Jlc3VsdHMYAiABKAsyJC5nb29nbGUuYmlndGFibGUudjIuUGFydGlhbFJlc3VsdFNldEgAQgoKCHJlc3BvbnNlMp0kCghCaWd0YWJsZRLbAwoIUmVhZFJvd3MSIy5nb29nbGUuYmlndGFibGUudjIuUmVhZFJvd3NSZXF1ZXN0GiQuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJlYWRSb3dzUmVzcG9uc2UigQPaQQp0YWJsZV9uYW1l2kEZdGFibGVfbmFtZSxhcHBfcHJvZmlsZV9pZILT5JMCmgE6ASpaWjoBKiJVL3YyL3thdXRob3JpemVkX3ZpZXdfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qL2F1dGhvcml6ZWRWaWV3cy8qfTpyZWFkUm93cyI5L3YyL3t0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9OnJlYWRSb3dzitPkkwKwARI6Cgp0YWJsZV9uYW1lEix7dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfRIQCg5hcHBfcHJvZmlsZV9pZBJgChRhdXRob3JpemVkX3ZpZXdfbmFtZRJIe2F1dGhvcml6ZWRfdmlld19uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyovYXV0aG9yaXplZFZpZXdzLyp9MAES7gMKDVNhbXBsZVJvd0tleXMSKC5nb29nbGUuYmlndGFibGUudjIuU2FtcGxlUm93S2V5c1JlcXVlc3QaKS5nb29nbGUuYmlndGFibGUudjIuU2FtcGxlUm93S2V5c1Jlc3BvbnNlIoUD2kEKdGFibGVfbmFtZdpBGXRhYmxlX25hbWUsYXBwX3Byb2ZpbGVfaWSC0+STAp4BWlwSWi92Mi97YXV0aG9yaXplZF92aWV3X25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKi9hdXRob3JpemVkVmlld3MvKn06c2FtcGxlUm93S2V5cxI+L3YyL3t0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9OnNhbXBsZVJvd0tleXOK0+STArABEjoKCnRhYmxlX25hbWUSLHt0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9EhAKDmFwcF9wcm9maWxlX2lkEmAKFGF1dGhvcml6ZWRfdmlld19uYW1lEkh7YXV0aG9yaXplZF92aWV3X25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKi9hdXRob3JpemVkVmlld3MvKn0wARKCBAoJTXV0YXRlUm93EiQuZ29vZ2xlLmJpZ3RhYmxlLnYyLk11dGF0ZVJvd1JlcXVlc3QaJS5nb29nbGUuYmlndGFibGUudjIuTXV0YXRlUm93UmVzcG9uc2UipwPaQRx0YWJsZV9uYW1lLHJvd19rZXksbXV0YXRpb25z2kErdGFibGVfbmFtZSxyb3dfa2V5LG11dGF0aW9ucyxhcHBfcHJvZmlsZV9pZILT5JMCnAE6ASpaWzoBKiJWL3YyL3thdXRob3JpemVkX3ZpZXdfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qL2F1dGhvcml6ZWRWaWV3cy8qfTptdXRhdGVSb3ciOi92Mi97dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfTptdXRhdGVSb3eK0+STArABEjoKCnRhYmxlX25hbWUSLHt0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9EhAKDmFwcF9wcm9maWxlX2lkEmAKFGF1dGhvcml6ZWRfdmlld19uYW1lEkh7YXV0aG9yaXplZF92aWV3X25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKi9hdXRob3JpemVkVmlld3MvKn0S9QMKCk11dGF0ZVJvd3MSJS5nb29nbGUuYmlndGFibGUudjIuTXV0YXRlUm93c1JlcXVlc3QaJi5nb29nbGUuYmlndGFibGUudjIuTXV0YXRlUm93c1Jlc3BvbnNlIpUD2kESdGFibGVfbmFtZSxlbnRyaWVz2kEhdGFibGVfbmFtZSxlbnRyaWVzLGFwcF9wcm9maWxlX2lkgtPkkwKeAToBKlpcOgEqIlcvdjIve2F1dGhvcml6ZWRfdmlld19uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyovYXV0aG9yaXplZFZpZXdzLyp9Om11dGF0ZVJvd3MiOy92Mi97dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfTptdXRhdGVSb3dzitPkkwKwARI6Cgp0YWJsZV9uYW1lEix7dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfRIQCg5hcHBfcHJvZmlsZV9pZBJgChRhdXRob3JpemVkX3ZpZXdfbmFtZRJIe2F1dGhvcml6ZWRfdmlld19uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyovYXV0aG9yaXplZFZpZXdzLyp9MAES9gQKEUNoZWNrQW5kTXV0YXRlUm93EiwuZ29vZ2xlLmJpZ3RhYmxlLnYyLkNoZWNrQW5kTXV0YXRlUm93UmVxdWVzdBotLmdvb2dsZS5iaWd0YWJsZS52Mi5DaGVja0FuZE11dGF0ZVJvd1Jlc3BvbnNlIoME2kFCdGFibGVfbmFtZSxyb3dfa2V5LHByZWRpY2F0ZV9maWx0ZXIsdHJ1ZV9tdXRhdGlvbnMsZmFsc2VfbXV0YXRpb25z2kFRdGFibGVfbmFtZSxyb3dfa2V5LHByZWRpY2F0ZV9maWx0ZXIsdHJ1ZV9tdXRhdGlvbnMsZmFsc2VfbXV0YXRpb25zLGFwcF9wcm9maWxlX2lkgtPkkwKsAToBKlpjOgEqIl4vdjIve2F1dGhvcml6ZWRfdmlld19uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyovYXV0aG9yaXplZFZpZXdzLyp9OmNoZWNrQW5kTXV0YXRlUm93IkIvdjIve3RhYmxlX25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKn06Y2hlY2tBbmRNdXRhdGVSb3eK0+STArABEjoKCnRhYmxlX25hbWUSLHt0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9EhAKDmFwcF9wcm9maWxlX2lkEmAKFGF1dGhvcml6ZWRfdmlld19uYW1lEkh7YXV0aG9yaXplZF92aWV3X25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKi9hdXRob3JpemVkVmlld3MvKn0S7gEKC1BpbmdBbmRXYXJtEiYuZ29vZ2xlLmJpZ3RhYmxlLnYyLlBpbmdBbmRXYXJtUmVxdWVzdBonLmdvb2dsZS5iaWd0YWJsZS52Mi5QaW5nQW5kV2FybVJlc3BvbnNlIo0B2kEEbmFtZdpBE25hbWUsYXBwX3Byb2ZpbGVfaWSC0+STAis6ASoiJi92Mi97bmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qfTpwaW5nitPkkwI5EiUKBG5hbWUSHXtuYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyp9EhAKDmFwcF9wcm9maWxlX2lkEqcEChJSZWFkTW9kaWZ5V3JpdGVSb3cSLS5nb29nbGUuYmlndGFibGUudjIuUmVhZE1vZGlmeVdyaXRlUm93UmVxdWVzdBouLmdvb2dsZS5iaWd0YWJsZS52Mi5SZWFkTW9kaWZ5V3JpdGVSb3dSZXNwb25zZSKxA9pBGHRhYmxlX25hbWUscm93X2tleSxydWxlc9pBJ3RhYmxlX25hbWUscm93X2tleSxydWxlcyxhcHBfcHJvZmlsZV9pZILT5JMCrgE6ASpaZDoBKiJfL3YyL3thdXRob3JpemVkX3ZpZXdfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qL2F1dGhvcml6ZWRWaWV3cy8qfTpyZWFkTW9kaWZ5V3JpdGVSb3ciQy92Mi97dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfTpyZWFkTW9kaWZ5V3JpdGVSb3eK0+STArABEjoKCnRhYmxlX25hbWUSLHt0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9EhAKDmFwcF9wcm9maWxlX2lkEmAKFGF1dGhvcml6ZWRfdmlld19uYW1lEkh7YXV0aG9yaXplZF92aWV3X25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi90YWJsZXMvKi9hdXRob3JpemVkVmlld3MvKn0SuwIKJUdlbmVyYXRlSW5pdGlhbENoYW5nZVN0cmVhbVBhcnRpdGlvbnMSQC5nb29nbGUuYmlndGFibGUudjIuR2VuZXJhdGVJbml0aWFsQ2hhbmdlU3RyZWFtUGFydGl0aW9uc1JlcXVlc3QaQS5nb29nbGUuYmlndGFibGUudjIuR2VuZXJhdGVJbml0aWFsQ2hhbmdlU3RyZWFtUGFydGl0aW9uc1Jlc3BvbnNlIooB2kEKdGFibGVfbmFtZdpBGXRhYmxlX25hbWUsYXBwX3Byb2ZpbGVfaWSC0+STAls6ASoiVi92Mi97dGFibGVfbmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL3RhYmxlcy8qfTpnZW5lcmF0ZUluaXRpYWxDaGFuZ2VTdHJlYW1QYXJ0aXRpb25zMAES5gEKEFJlYWRDaGFuZ2VTdHJlYW0SKy5nb29nbGUuYmlndGFibGUudjIuUmVhZENoYW5nZVN0cmVhbVJlcXVlc3QaLC5nb29nbGUuYmlndGFibGUudjIuUmVhZENoYW5nZVN0cmVhbVJlc3BvbnNlInXaQQp0YWJsZV9uYW1l2kEZdGFibGVfbmFtZSxhcHBfcHJvZmlsZV9pZILT5JMCRjoBKiJBL3YyL3t0YWJsZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyovdGFibGVzLyp9OnJlYWRDaGFuZ2VTdHJlYW0wARKrAgoMRXhlY3V0ZVF1ZXJ5EicuZ29vZ2xlLmJpZ3RhYmxlLnYyLkV4ZWN1dGVRdWVyeVJlcXVlc3QaKC5nb29nbGUuYmlndGFibGUudjIuRXhlY3V0ZVF1ZXJ5UmVzcG9uc2UixQHaQRNpbnN0YW5jZV9uYW1lLHF1ZXJ52kEiaW5zdGFuY2VfbmFtZSxxdWVyeSxhcHBfcHJvZmlsZV9pZILT5JMCPDoBKiI3L3YyL3tpbnN0YW5jZV9uYW1lPXByb2plY3RzLyovaW5zdGFuY2VzLyp9OmV4ZWN1dGVRdWVyeYrT5JMCQhIuCg1pbnN0YW5jZV9uYW1lEh17bmFtZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qfRIQCg5hcHBfcHJvZmlsZV9pZDABGtsCykEXYmlndGFibGUuZ29vZ2xlYXBpcy5jb23SQb0CaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9iaWd0YWJsZS5kYXRhLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvYmlndGFibGUuZGF0YS5yZWFkb25seSxodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLWJpZ3RhYmxlLmRhdGEsaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1iaWd0YWJsZS5kYXRhLnJlYWRvbmx5LGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0saHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybS5yZWFkLW9ubHlC9AMKFmNvbS5nb29nbGUuYmlndGFibGUudjJCDUJpZ3RhYmxlUHJvdG9QAVo4Y2xvdWQuZ29vZ2xlLmNvbS9nby9iaWd0YWJsZS9hcGl2Mi9iaWd0YWJsZXBiO2JpZ3RhYmxlcGKqAhhHb29nbGUuQ2xvdWQuQmlndGFibGUuVjLKAhhHb29nbGVcQ2xvdWRcQmlndGFibGVcVjLqAhtHb29nbGU6OkNsb3VkOjpCaWd0YWJsZTo6VjLqQVAKJWJpZ3RhYmxlYWRtaW4uZ29vZ2xlYXBpcy5jb20vSW5zdGFuY2USJ3Byb2plY3RzL3twcm9qZWN0fS9pbnN0YW5jZXMve2luc3RhbmNlfepBXAoiYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9UYWJsZRI2cHJvamVjdHMve3Byb2plY3R9L2luc3RhbmNlcy97aW5zdGFuY2V9L3RhYmxlcy97dGFibGV96kGHAQorYmlndGFibGVhZG1pbi5nb29nbGVhcGlzLmNvbS9BdXRob3JpemVkVmlldxJYcHJvamVjdHMve3Byb2plY3R9L2luc3RhbmNlcy97aW5zdGFuY2V9L3RhYmxlcy97dGFibGV9L2F1dGhvcml6ZWRWaWV3cy97YXV0aG9yaXplZF92aWV3fWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_api_routing, file_google_bigtable_v2_data, file_google_bigtable_v2_request_stats, file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers, file_google_rpc_status]);

/**
 * Request message for Bigtable.ReadRows.
 *
 * @generated from message google.bigtable.v2.ReadRowsRequest
 */
export type ReadRowsRequest = Message<"google.bigtable.v2.ReadRowsRequest"> & {
  /**
   * Optional. The unique name of the table from which to read.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView from which to read.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 9;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 5;
   */
  appProfileId: string;

  /**
   * The row keys and/or ranges to read sequentially. If not specified, reads
   * from all rows.
   *
   * @generated from field: google.bigtable.v2.RowSet rows = 2;
   */
  rows?: RowSet;

  /**
   * The filter to apply to the contents of the specified row(s). If unset,
   * reads the entirety of each row.
   *
   * @generated from field: google.bigtable.v2.RowFilter filter = 3;
   */
  filter?: RowFilter;

  /**
   * The read will stop after committing to N rows' worth of results. The
   * default (zero) is to return all results.
   *
   * @generated from field: int64 rows_limit = 4;
   */
  rowsLimit: bigint;

  /**
   * The view into RequestStats, as described above.
   *
   * @generated from field: google.bigtable.v2.ReadRowsRequest.RequestStatsView request_stats_view = 6;
   */
  requestStatsView: ReadRowsRequest_RequestStatsView;

  /**
   * Experimental API - Please note that this API is currently experimental
   * and can change in the future.
   *
   * Return rows in lexiographical descending order of the row keys. The row
   * contents will not be affected by this flag.
   *
   * Example result set:
   *
   *     [
   *       {key: "k2", "f:col1": "v1", "f:col2": "v1"},
   *       {key: "k1", "f:col1": "v2", "f:col2": "v2"}
   *     ]
   *
   * @generated from field: bool reversed = 7;
   */
  reversed: boolean;
};

/**
 * Describes the message google.bigtable.v2.ReadRowsRequest.
 * Use `create(ReadRowsRequestSchema)` to create a new message.
 */
export const ReadRowsRequestSchema: GenMessage<ReadRowsRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 0);

/**
 * The desired view into RequestStats that should be returned in the response.
 *
 * See also: RequestStats message.
 *
 * @generated from enum google.bigtable.v2.ReadRowsRequest.RequestStatsView
 */
export enum ReadRowsRequest_RequestStatsView {
  /**
   * The default / unset value. The API will default to the NONE option below.
   *
   * @generated from enum value: REQUEST_STATS_VIEW_UNSPECIFIED = 0;
   */
  REQUEST_STATS_VIEW_UNSPECIFIED = 0,

  /**
   * Do not include any RequestStats in the response. This will leave the
   * RequestStats embedded message unset in the response.
   *
   * @generated from enum value: REQUEST_STATS_NONE = 1;
   */
  REQUEST_STATS_NONE = 1,

  /**
   * Include the full set of available RequestStats in the response,
   * applicable to this read.
   *
   * @generated from enum value: REQUEST_STATS_FULL = 2;
   */
  REQUEST_STATS_FULL = 2,
}

/**
 * Describes the enum google.bigtable.v2.ReadRowsRequest.RequestStatsView.
 */
export const ReadRowsRequest_RequestStatsViewSchema: GenEnum<ReadRowsRequest_RequestStatsView> = /*@__PURE__*/
  enumDesc(file_google_bigtable_v2_bigtable, 0, 0);

/**
 * Response message for Bigtable.ReadRows.
 *
 * @generated from message google.bigtable.v2.ReadRowsResponse
 */
export type ReadRowsResponse = Message<"google.bigtable.v2.ReadRowsResponse"> & {
  /**
   * A collection of a row's contents as part of the read request.
   *
   * @generated from field: repeated google.bigtable.v2.ReadRowsResponse.CellChunk chunks = 1;
   */
  chunks: ReadRowsResponse_CellChunk[];

  /**
   * Optionally the server might return the row key of the last row it
   * has scanned.  The client can use this to construct a more
   * efficient retry request if needed: any row keys or portions of
   * ranges less than this row key can be dropped from the request.
   * This is primarily useful for cases where the server has read a
   * lot of data that was filtered out since the last committed row
   * key, allowing the client to skip that work on a retry.
   *
   * @generated from field: bytes last_scanned_row_key = 2;
   */
  lastScannedRowKey: Uint8Array;

  /**
   *
   * If requested, provide enhanced query performance statistics. The semantics
   * dictate:
   *   * request_stats is empty on every (streamed) response, except
   *   * request_stats has non-empty information after all chunks have been
   *     streamed, where the ReadRowsResponse message only contains
   *     request_stats.
   *       * For example, if a read request would have returned an empty
   *         response instead a single ReadRowsResponse is streamed with empty
   *         chunks and request_stats filled.
   *
   * Visually, response messages will stream as follows:
   *    ... -> {chunks: [...]} -> {chunks: [], request_stats: {...}}
   *   \______________________/  \________________________________/
   *       Primary response         Trailer of RequestStats info
   *
   * Or if the read did not return any values:
   *   {chunks: [], request_stats: {...}}
   *   \________________________________/
   *      Trailer of RequestStats info
   *
   * @generated from field: google.bigtable.v2.RequestStats request_stats = 3;
   */
  requestStats?: RequestStats;
};

/**
 * Describes the message google.bigtable.v2.ReadRowsResponse.
 * Use `create(ReadRowsResponseSchema)` to create a new message.
 */
export const ReadRowsResponseSchema: GenMessage<ReadRowsResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 1);

/**
 * Specifies a piece of a row's contents returned as part of the read
 * response stream.
 *
 * @generated from message google.bigtable.v2.ReadRowsResponse.CellChunk
 */
export type ReadRowsResponse_CellChunk = Message<"google.bigtable.v2.ReadRowsResponse.CellChunk"> & {
  /**
   * The row key for this chunk of data.  If the row key is empty,
   * this CellChunk is a continuation of the same row as the previous
   * CellChunk in the response stream, even if that CellChunk was in a
   * previous ReadRowsResponse message.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey: Uint8Array;

  /**
   * The column family name for this chunk of data.  If this message
   * is not present this CellChunk is a continuation of the same column
   * family as the previous CellChunk.  The empty string can occur as a
   * column family name in a response so clients must check
   * explicitly for the presence of this message, not just for
   * `family_name.value` being non-empty.
   *
   * @generated from field: google.protobuf.StringValue family_name = 2;
   */
  familyName?: string;

  /**
   * The column qualifier for this chunk of data.  If this message
   * is not present, this CellChunk is a continuation of the same column
   * as the previous CellChunk.  Column qualifiers may be empty so
   * clients must check for the presence of this message, not just
   * for `qualifier.value` being non-empty.
   *
   * @generated from field: google.protobuf.BytesValue qualifier = 3;
   */
  qualifier?: Uint8Array;

  /**
   * The cell's stored timestamp, which also uniquely identifies it
   * within its column.  Values are always expressed in
   * microseconds, but individual tables may set a coarser
   * granularity to further restrict the allowed values. For
   * example, a table which specifies millisecond granularity will
   * only allow values of `timestamp_micros` which are multiples of
   * 1000.  Timestamps are only set in the first CellChunk per cell
   * (for cells split into multiple chunks).
   *
   * @generated from field: int64 timestamp_micros = 4;
   */
  timestampMicros: bigint;

  /**
   * Labels applied to the cell by a
   * [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
   * on the first CellChunk per cell.
   *
   * @generated from field: repeated string labels = 5;
   */
  labels: string[];

  /**
   * The value stored in the cell.  Cell values can be split across
   * multiple CellChunks.  In that case only the value field will be
   * set in CellChunks after the first: the timestamp and labels
   * will only be present in the first CellChunk, even if the first
   * CellChunk came in a previous ReadRowsResponse.
   *
   * @generated from field: bytes value = 6;
   */
  value: Uint8Array;

  /**
   * If this CellChunk is part of a chunked cell value and this is
   * not the final chunk of that cell, value_size will be set to the
   * total length of the cell value.  The client can use this size
   * to pre-allocate memory to hold the full cell value.
   *
   * @generated from field: int32 value_size = 7;
   */
  valueSize: number;

  /**
   * Signals to the client concerning previous CellChunks received.
   *
   * @generated from oneof google.bigtable.v2.ReadRowsResponse.CellChunk.row_status
   */
  rowStatus: {
    /**
     * Indicates that the client should drop all previous chunks for
     * `row_key`, as it will be re-read from the beginning.
     *
     * @generated from field: bool reset_row = 8;
     */
    value: boolean;
    case: "resetRow";
  } | {
    /**
     * Indicates that the client can safely process all previous chunks for
     * `row_key`, as its data has been fully read.
     *
     * @generated from field: bool commit_row = 9;
     */
    value: boolean;
    case: "commitRow";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ReadRowsResponse.CellChunk.
 * Use `create(ReadRowsResponse_CellChunkSchema)` to create a new message.
 */
export const ReadRowsResponse_CellChunkSchema: GenMessage<ReadRowsResponse_CellChunk> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 1, 0);

/**
 * Request message for Bigtable.SampleRowKeys.
 *
 * @generated from message google.bigtable.v2.SampleRowKeysRequest
 */
export type SampleRowKeysRequest = Message<"google.bigtable.v2.SampleRowKeysRequest"> & {
  /**
   * Optional. The unique name of the table from which to sample row keys.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView from which to sample row
   * keys.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 4;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 2;
   */
  appProfileId: string;
};

/**
 * Describes the message google.bigtable.v2.SampleRowKeysRequest.
 * Use `create(SampleRowKeysRequestSchema)` to create a new message.
 */
export const SampleRowKeysRequestSchema: GenMessage<SampleRowKeysRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 2);

/**
 * Response message for Bigtable.SampleRowKeys.
 *
 * @generated from message google.bigtable.v2.SampleRowKeysResponse
 */
export type SampleRowKeysResponse = Message<"google.bigtable.v2.SampleRowKeysResponse"> & {
  /**
   * Sorted streamed sequence of sample row keys in the table. The table might
   * have contents before the first row key in the list and after the last one,
   * but a key containing the empty string indicates "end of table" and will be
   * the last response given, if present.
   * Note that row keys in this list may not have ever been written to or read
   * from, and users should therefore not make any assumptions about the row key
   * structure that are specific to their use case.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey: Uint8Array;

  /**
   * Approximate total storage space used by all rows in the table which precede
   * `row_key`. Buffering the contents of all rows between two subsequent
   * samples would require space roughly equal to the difference in their
   * `offset_bytes` fields.
   *
   * @generated from field: int64 offset_bytes = 2;
   */
  offsetBytes: bigint;
};

/**
 * Describes the message google.bigtable.v2.SampleRowKeysResponse.
 * Use `create(SampleRowKeysResponseSchema)` to create a new message.
 */
export const SampleRowKeysResponseSchema: GenMessage<SampleRowKeysResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 3);

/**
 * Request message for Bigtable.MutateRow.
 *
 * @generated from message google.bigtable.v2.MutateRowRequest
 */
export type MutateRowRequest = Message<"google.bigtable.v2.MutateRowRequest"> & {
  /**
   * Optional. The unique name of the table to which the mutation should be
   * applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView to which the mutation
   * should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 6;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 4;
   */
  appProfileId: string;

  /**
   * Required. The key of the row to which the mutation should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey: Uint8Array;

  /**
   * Required. Changes to be atomically applied to the specified row. Entries
   * are applied in order, meaning that earlier mutations can be masked by later
   * ones. Must contain at least one entry and at most 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation mutations = 3;
   */
  mutations: Mutation[];
};

/**
 * Describes the message google.bigtable.v2.MutateRowRequest.
 * Use `create(MutateRowRequestSchema)` to create a new message.
 */
export const MutateRowRequestSchema: GenMessage<MutateRowRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 4);

/**
 * Response message for Bigtable.MutateRow.
 *
 * @generated from message google.bigtable.v2.MutateRowResponse
 */
export type MutateRowResponse = Message<"google.bigtable.v2.MutateRowResponse"> & {
};

/**
 * Describes the message google.bigtable.v2.MutateRowResponse.
 * Use `create(MutateRowResponseSchema)` to create a new message.
 */
export const MutateRowResponseSchema: GenMessage<MutateRowResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 5);

/**
 * Request message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v2.MutateRowsRequest
 */
export type MutateRowsRequest = Message<"google.bigtable.v2.MutateRowsRequest"> & {
  /**
   * Optional. The unique name of the table to which the mutations should be
   * applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView to which the mutations
   * should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 5;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 3;
   */
  appProfileId: string;

  /**
   * Required. The row keys and corresponding mutations to be applied in bulk.
   * Each entry is applied as an atomic mutation, but the entries may be
   * applied in arbitrary order (even between entries for the same row).
   * At least one entry must be specified, and in total the entries can
   * contain at most 100000 mutations.
   *
   * @generated from field: repeated google.bigtable.v2.MutateRowsRequest.Entry entries = 2;
   */
  entries: MutateRowsRequest_Entry[];
};

/**
 * Describes the message google.bigtable.v2.MutateRowsRequest.
 * Use `create(MutateRowsRequestSchema)` to create a new message.
 */
export const MutateRowsRequestSchema: GenMessage<MutateRowsRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 6);

/**
 * A mutation for a given row.
 *
 * @generated from message google.bigtable.v2.MutateRowsRequest.Entry
 */
export type MutateRowsRequest_Entry = Message<"google.bigtable.v2.MutateRowsRequest.Entry"> & {
  /**
   * The key of the row to which the `mutations` should be applied.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey: Uint8Array;

  /**
   * Required. Changes to be atomically applied to the specified row.
   * Mutations are applied in order, meaning that earlier mutations can be
   * masked by later ones. You must specify at least one mutation.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation mutations = 2;
   */
  mutations: Mutation[];
};

/**
 * Describes the message google.bigtable.v2.MutateRowsRequest.Entry.
 * Use `create(MutateRowsRequest_EntrySchema)` to create a new message.
 */
export const MutateRowsRequest_EntrySchema: GenMessage<MutateRowsRequest_Entry> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 6, 0);

/**
 * Response message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v2.MutateRowsResponse
 */
export type MutateRowsResponse = Message<"google.bigtable.v2.MutateRowsResponse"> & {
  /**
   * One or more results for Entries from the batch request.
   *
   * @generated from field: repeated google.bigtable.v2.MutateRowsResponse.Entry entries = 1;
   */
  entries: MutateRowsResponse_Entry[];

  /**
   * Information about how client should limit the rate (QPS). Primirily used by
   * supported official Cloud Bigtable clients. If unset, the rate limit info is
   * not provided by the server.
   *
   * @generated from field: optional google.bigtable.v2.RateLimitInfo rate_limit_info = 3;
   */
  rateLimitInfo?: RateLimitInfo;
};

/**
 * Describes the message google.bigtable.v2.MutateRowsResponse.
 * Use `create(MutateRowsResponseSchema)` to create a new message.
 */
export const MutateRowsResponseSchema: GenMessage<MutateRowsResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 7);

/**
 * The result of applying a passed mutation in the original request.
 *
 * @generated from message google.bigtable.v2.MutateRowsResponse.Entry
 */
export type MutateRowsResponse_Entry = Message<"google.bigtable.v2.MutateRowsResponse.Entry"> & {
  /**
   * The index into the original request's `entries` list of the Entry
   * for which a result is being reported.
   *
   * @generated from field: int64 index = 1;
   */
  index: bigint;

  /**
   * The result of the request Entry identified by `index`.
   * Depending on how requests are batched during execution, it is possible
   * for one Entry to fail due to an error with another Entry. In the event
   * that this occurs, the same error will be reported for both entries.
   *
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;
};

/**
 * Describes the message google.bigtable.v2.MutateRowsResponse.Entry.
 * Use `create(MutateRowsResponse_EntrySchema)` to create a new message.
 */
export const MutateRowsResponse_EntrySchema: GenMessage<MutateRowsResponse_Entry> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 7, 0);

/**
 * Information about how client should adjust the load to Bigtable.
 *
 * @generated from message google.bigtable.v2.RateLimitInfo
 */
export type RateLimitInfo = Message<"google.bigtable.v2.RateLimitInfo"> & {
  /**
   * Time that clients should wait before adjusting the target rate again.
   * If clients adjust rate too frequently, the impact of the previous
   * adjustment may not have been taken into account and may
   * over-throttle or under-throttle. If clients adjust rate too slowly, they
   * will not be responsive to load changes on server side, and may
   * over-throttle or under-throttle.
   *
   * @generated from field: google.protobuf.Duration period = 1;
   */
  period?: Duration;

  /**
   * If it has been at least one `period` since the last load adjustment, the
   * client should multiply the current load by this value to get the new target
   * load. For example, if the current load is 100 and `factor` is 0.8, the new
   * target load should be 80. After adjusting, the client should ignore
   * `factor` until another `period` has passed.
   *
   * The client can measure its load using any unit that's comparable over time
   * For example, QPS can be used as long as each request involves a similar
   * amount of work.
   *
   * @generated from field: double factor = 2;
   */
  factor: number;
};

/**
 * Describes the message google.bigtable.v2.RateLimitInfo.
 * Use `create(RateLimitInfoSchema)` to create a new message.
 */
export const RateLimitInfoSchema: GenMessage<RateLimitInfo> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 8);

/**
 * Request message for Bigtable.CheckAndMutateRow.
 *
 * @generated from message google.bigtable.v2.CheckAndMutateRowRequest
 */
export type CheckAndMutateRowRequest = Message<"google.bigtable.v2.CheckAndMutateRowRequest"> & {
  /**
   * Optional. The unique name of the table to which the conditional mutation
   * should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView to which the conditional
   * mutation should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 9;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 7;
   */
  appProfileId: string;

  /**
   * Required. The key of the row to which the conditional mutation should be
   * applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey: Uint8Array;

  /**
   * The filter to be applied to the contents of the specified row. Depending
   * on whether or not any results are yielded, either `true_mutations` or
   * `false_mutations` will be executed. If unset, checks that the row contains
   * any values at all.
   *
   * @generated from field: google.bigtable.v2.RowFilter predicate_filter = 6;
   */
  predicateFilter?: RowFilter;

  /**
   * Changes to be atomically applied to the specified row if `predicate_filter`
   * yields at least one cell when applied to `row_key`. Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if `false_mutations` is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation true_mutations = 4;
   */
  trueMutations: Mutation[];

  /**
   * Changes to be atomically applied to the specified row if `predicate_filter`
   * does not yield any cells when applied to `row_key`. Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if `true_mutations` is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation false_mutations = 5;
   */
  falseMutations: Mutation[];
};

/**
 * Describes the message google.bigtable.v2.CheckAndMutateRowRequest.
 * Use `create(CheckAndMutateRowRequestSchema)` to create a new message.
 */
export const CheckAndMutateRowRequestSchema: GenMessage<CheckAndMutateRowRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 9);

/**
 * Response message for Bigtable.CheckAndMutateRow.
 *
 * @generated from message google.bigtable.v2.CheckAndMutateRowResponse
 */
export type CheckAndMutateRowResponse = Message<"google.bigtable.v2.CheckAndMutateRowResponse"> & {
  /**
   * Whether or not the request's `predicate_filter` yielded any results for
   * the specified row.
   *
   * @generated from field: bool predicate_matched = 1;
   */
  predicateMatched: boolean;
};

/**
 * Describes the message google.bigtable.v2.CheckAndMutateRowResponse.
 * Use `create(CheckAndMutateRowResponseSchema)` to create a new message.
 */
export const CheckAndMutateRowResponseSchema: GenMessage<CheckAndMutateRowResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 10);

/**
 * Request message for client connection keep-alive and warming.
 *
 * @generated from message google.bigtable.v2.PingAndWarmRequest
 */
export type PingAndWarmRequest = Message<"google.bigtable.v2.PingAndWarmRequest"> & {
  /**
   * Required. The unique name of the instance to check permissions for as well
   * as respond. Values are of the form
   * `projects/<project>/instances/<instance>`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 2;
   */
  appProfileId: string;
};

/**
 * Describes the message google.bigtable.v2.PingAndWarmRequest.
 * Use `create(PingAndWarmRequestSchema)` to create a new message.
 */
export const PingAndWarmRequestSchema: GenMessage<PingAndWarmRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 11);

/**
 * Response message for Bigtable.PingAndWarm connection keepalive and warming.
 *
 * @generated from message google.bigtable.v2.PingAndWarmResponse
 */
export type PingAndWarmResponse = Message<"google.bigtable.v2.PingAndWarmResponse"> & {
};

/**
 * Describes the message google.bigtable.v2.PingAndWarmResponse.
 * Use `create(PingAndWarmResponseSchema)` to create a new message.
 */
export const PingAndWarmResponseSchema: GenMessage<PingAndWarmResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 12);

/**
 * Request message for Bigtable.ReadModifyWriteRow.
 *
 * @generated from message google.bigtable.v2.ReadModifyWriteRowRequest
 */
export type ReadModifyWriteRowRequest = Message<"google.bigtable.v2.ReadModifyWriteRowRequest"> & {
  /**
   * Optional. The unique name of the table to which the read/modify/write rules
   * should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * Optional. The unique name of the AuthorizedView to which the
   * read/modify/write rules should be applied.
   *
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>/authorizedViews/<authorized_view>`.
   *
   * @generated from field: string authorized_view_name = 6;
   */
  authorizedViewName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   *
   * @generated from field: string app_profile_id = 4;
   */
  appProfileId: string;

  /**
   * Required. The key of the row to which the read/modify/write rules should be
   * applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey: Uint8Array;

  /**
   * Required. Rules specifying how the specified row's contents are to be
   * transformed into writes. Entries are applied in order, meaning that earlier
   * rules will affect the results of later ones.
   *
   * @generated from field: repeated google.bigtable.v2.ReadModifyWriteRule rules = 3;
   */
  rules: ReadModifyWriteRule[];
};

/**
 * Describes the message google.bigtable.v2.ReadModifyWriteRowRequest.
 * Use `create(ReadModifyWriteRowRequestSchema)` to create a new message.
 */
export const ReadModifyWriteRowRequestSchema: GenMessage<ReadModifyWriteRowRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 13);

/**
 * Response message for Bigtable.ReadModifyWriteRow.
 *
 * @generated from message google.bigtable.v2.ReadModifyWriteRowResponse
 */
export type ReadModifyWriteRowResponse = Message<"google.bigtable.v2.ReadModifyWriteRowResponse"> & {
  /**
   * A Row containing the new contents of all cells modified by the request.
   *
   * @generated from field: google.bigtable.v2.Row row = 1;
   */
  row?: Row;
};

/**
 * Describes the message google.bigtable.v2.ReadModifyWriteRowResponse.
 * Use `create(ReadModifyWriteRowResponseSchema)` to create a new message.
 */
export const ReadModifyWriteRowResponseSchema: GenMessage<ReadModifyWriteRowResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 14);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * Request message for Bigtable.GenerateInitialChangeStreamPartitions.
 *
 * @generated from message google.bigtable.v2.GenerateInitialChangeStreamPartitionsRequest
 */
export type GenerateInitialChangeStreamPartitionsRequest = Message<"google.bigtable.v2.GenerateInitialChangeStreamPartitionsRequest"> & {
  /**
   * Required. The unique name of the table from which to get change stream
   * partitions. Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   * Change streaming must be enabled on the table.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   * Single cluster routing must be configured on the profile.
   *
   * @generated from field: string app_profile_id = 2;
   */
  appProfileId: string;
};

/**
 * Describes the message google.bigtable.v2.GenerateInitialChangeStreamPartitionsRequest.
 * Use `create(GenerateInitialChangeStreamPartitionsRequestSchema)` to create a new message.
 */
export const GenerateInitialChangeStreamPartitionsRequestSchema: GenMessage<GenerateInitialChangeStreamPartitionsRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 15);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * Response message for Bigtable.GenerateInitialChangeStreamPartitions.
 *
 * @generated from message google.bigtable.v2.GenerateInitialChangeStreamPartitionsResponse
 */
export type GenerateInitialChangeStreamPartitionsResponse = Message<"google.bigtable.v2.GenerateInitialChangeStreamPartitionsResponse"> & {
  /**
   * A partition of the change stream.
   *
   * @generated from field: google.bigtable.v2.StreamPartition partition = 1;
   */
  partition?: StreamPartition;
};

/**
 * Describes the message google.bigtable.v2.GenerateInitialChangeStreamPartitionsResponse.
 * Use `create(GenerateInitialChangeStreamPartitionsResponseSchema)` to create a new message.
 */
export const GenerateInitialChangeStreamPartitionsResponseSchema: GenMessage<GenerateInitialChangeStreamPartitionsResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 16);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * Request message for Bigtable.ReadChangeStream.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamRequest
 */
export type ReadChangeStreamRequest = Message<"google.bigtable.v2.ReadChangeStreamRequest"> & {
  /**
   * Required. The unique name of the table from which to read a change stream.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   * Change streaming must be enabled on the table.
   *
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * This value specifies routing for replication. If not specified, the
   * "default" application profile will be used.
   * Single cluster routing must be configured on the profile.
   *
   * @generated from field: string app_profile_id = 2;
   */
  appProfileId: string;

  /**
   * The partition to read changes from.
   *
   * @generated from field: google.bigtable.v2.StreamPartition partition = 3;
   */
  partition?: StreamPartition;

  /**
   * Options for describing where we want to start reading from the stream.
   *
   * @generated from oneof google.bigtable.v2.ReadChangeStreamRequest.start_from
   */
  startFrom: {
    /**
     * Start reading the stream at the specified timestamp. This timestamp must
     * be within the change stream retention period, less than or equal to the
     * current time, and after change stream creation, whichever is greater.
     * This value is inclusive and will be truncated to microsecond granularity.
     *
     * @generated from field: google.protobuf.Timestamp start_time = 4;
     */
    value: Timestamp;
    case: "startTime";
  } | {
    /**
     * Tokens that describe how to resume reading a stream where reading
     * previously left off. If specified, changes will be read starting at the
     * the position. Tokens are delivered on the stream as part of `Heartbeat`
     * and `CloseStream` messages.
     *
     * If a single token is provided, the token’s partition must exactly match
     * the request’s partition. If multiple tokens are provided, as in the case
     * of a partition merge, the union of the token partitions must exactly
     * cover the request’s partition. Otherwise, INVALID_ARGUMENT will be
     * returned.
     *
     * @generated from field: google.bigtable.v2.StreamContinuationTokens continuation_tokens = 6;
     */
    value: StreamContinuationTokens;
    case: "continuationTokens";
  } | { case: undefined; value?: undefined };

  /**
   * If specified, OK will be returned when the stream advances beyond
   * this time. Otherwise, changes will be continuously delivered on the stream.
   * This value is inclusive and will be truncated to microsecond granularity.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 5;
   */
  endTime?: Timestamp;

  /**
   * If specified, the duration between `Heartbeat` messages on the stream.
   * Otherwise, defaults to 5 seconds.
   *
   * @generated from field: google.protobuf.Duration heartbeat_duration = 7;
   */
  heartbeatDuration?: Duration;
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamRequest.
 * Use `create(ReadChangeStreamRequestSchema)` to create a new message.
 */
export const ReadChangeStreamRequestSchema: GenMessage<ReadChangeStreamRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 17);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * Response message for Bigtable.ReadChangeStream.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse
 */
export type ReadChangeStreamResponse = Message<"google.bigtable.v2.ReadChangeStreamResponse"> & {
  /**
   * The data or control message on the stream.
   *
   * @generated from oneof google.bigtable.v2.ReadChangeStreamResponse.stream_record
   */
  streamRecord: {
    /**
     * A mutation to the partition.
     *
     * @generated from field: google.bigtable.v2.ReadChangeStreamResponse.DataChange data_change = 1;
     */
    value: ReadChangeStreamResponse_DataChange;
    case: "dataChange";
  } | {
    /**
     * A periodic heartbeat message.
     *
     * @generated from field: google.bigtable.v2.ReadChangeStreamResponse.Heartbeat heartbeat = 2;
     */
    value: ReadChangeStreamResponse_Heartbeat;
    case: "heartbeat";
  } | {
    /**
     * An indication that the stream should be closed.
     *
     * @generated from field: google.bigtable.v2.ReadChangeStreamResponse.CloseStream close_stream = 3;
     */
    value: ReadChangeStreamResponse_CloseStream;
    case: "closeStream";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.
 * Use `create(ReadChangeStreamResponseSchema)` to create a new message.
 */
export const ReadChangeStreamResponseSchema: GenMessage<ReadChangeStreamResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18);

/**
 * A partial or complete mutation.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse.MutationChunk
 */
export type ReadChangeStreamResponse_MutationChunk = Message<"google.bigtable.v2.ReadChangeStreamResponse.MutationChunk"> & {
  /**
   * If set, then the mutation is a `SetCell` with a chunked value across
   * multiple messages.
   *
   * @generated from field: google.bigtable.v2.ReadChangeStreamResponse.MutationChunk.ChunkInfo chunk_info = 1;
   */
  chunkInfo?: ReadChangeStreamResponse_MutationChunk_ChunkInfo;

  /**
   * If this is a continuation of a chunked message (`chunked_value_offset` >
   * 0), ignore all fields except the `SetCell`'s value and merge it with
   * the previous message by concatenating the value fields.
   *
   * @generated from field: google.bigtable.v2.Mutation mutation = 2;
   */
  mutation?: Mutation;
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.MutationChunk.
 * Use `create(ReadChangeStreamResponse_MutationChunkSchema)` to create a new message.
 */
export const ReadChangeStreamResponse_MutationChunkSchema: GenMessage<ReadChangeStreamResponse_MutationChunk> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18, 0);

/**
 * Information about the chunking of this mutation.
 * Only `SetCell` mutations can be chunked, and all chunks for a `SetCell`
 * will be delivered contiguously with no other mutation types interleaved.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse.MutationChunk.ChunkInfo
 */
export type ReadChangeStreamResponse_MutationChunk_ChunkInfo = Message<"google.bigtable.v2.ReadChangeStreamResponse.MutationChunk.ChunkInfo"> & {
  /**
   * The total value size of all the chunks that make up the `SetCell`.
   *
   * @generated from field: int32 chunked_value_size = 1;
   */
  chunkedValueSize: number;

  /**
   * The byte offset of this chunk into the total value size of the
   * mutation.
   *
   * @generated from field: int32 chunked_value_offset = 2;
   */
  chunkedValueOffset: number;

  /**
   * When true, this is the last chunk of a chunked `SetCell`.
   *
   * @generated from field: bool last_chunk = 3;
   */
  lastChunk: boolean;
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.MutationChunk.ChunkInfo.
 * Use `create(ReadChangeStreamResponse_MutationChunk_ChunkInfoSchema)` to create a new message.
 */
export const ReadChangeStreamResponse_MutationChunk_ChunkInfoSchema: GenMessage<ReadChangeStreamResponse_MutationChunk_ChunkInfo> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18, 0, 0);

/**
 * A message corresponding to one or more mutations to the partition
 * being streamed. A single logical `DataChange` message may also be split
 * across a sequence of multiple individual messages. Messages other than
 * the first in a sequence will only have the `type` and `chunks` fields
 * populated, with the final message in the sequence also containing `done`
 * set to true.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse.DataChange
 */
export type ReadChangeStreamResponse_DataChange = Message<"google.bigtable.v2.ReadChangeStreamResponse.DataChange"> & {
  /**
   * The type of the mutation.
   *
   * @generated from field: google.bigtable.v2.ReadChangeStreamResponse.DataChange.Type type = 1;
   */
  type: ReadChangeStreamResponse_DataChange_Type;

  /**
   * The cluster where the mutation was applied.
   * Not set when `type` is `GARBAGE_COLLECTION`.
   *
   * @generated from field: string source_cluster_id = 2;
   */
  sourceClusterId: string;

  /**
   * The row key for all mutations that are part of this `DataChange`.
   * If the `DataChange` is chunked across multiple messages, then this field
   * will only be set for the first message.
   *
   * @generated from field: bytes row_key = 3;
   */
  rowKey: Uint8Array;

  /**
   * The timestamp at which the mutation was applied on the Bigtable server.
   *
   * @generated from field: google.protobuf.Timestamp commit_timestamp = 4;
   */
  commitTimestamp?: Timestamp;

  /**
   * A value that lets stream consumers reconstruct Bigtable's
   * conflict resolution semantics.
   * https://cloud.google.com/bigtable/docs/writes#conflict-resolution
   * In the event that the same row key, column family, column qualifier,
   * timestamp are modified on different clusters at the same
   * `commit_timestamp`, the mutation with the larger `tiebreaker` will be the
   * one chosen for the eventually consistent state of the system.
   *
   * @generated from field: int32 tiebreaker = 5;
   */
  tiebreaker: number;

  /**
   * The mutations associated with this change to the partition.
   * May contain complete mutations or chunks of a multi-message chunked
   * `DataChange` record.
   *
   * @generated from field: repeated google.bigtable.v2.ReadChangeStreamResponse.MutationChunk chunks = 6;
   */
  chunks: ReadChangeStreamResponse_MutationChunk[];

  /**
   * When true, indicates that the entire `DataChange` has been read
   * and the client can safely process the message.
   *
   * @generated from field: bool done = 8;
   */
  done: boolean;

  /**
   * An encoded position for this stream's partition to restart reading from.
   * This token is for the StreamPartition from the request.
   *
   * @generated from field: string token = 9;
   */
  token: string;

  /**
   * An estimate of the commit timestamp that is usually lower than or equal
   * to any timestamp for a record that will be delivered in the future on the
   * stream. It is possible that, under particular circumstances that a future
   * record has a timestamp is is lower than a previously seen timestamp. For
   * an example usage see
   * https://beam.apache.org/documentation/basics/#watermarks
   *
   * @generated from field: google.protobuf.Timestamp estimated_low_watermark = 10;
   */
  estimatedLowWatermark?: Timestamp;
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.DataChange.
 * Use `create(ReadChangeStreamResponse_DataChangeSchema)` to create a new message.
 */
export const ReadChangeStreamResponse_DataChangeSchema: GenMessage<ReadChangeStreamResponse_DataChange> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18, 1);

/**
 * The type of mutation.
 *
 * @generated from enum google.bigtable.v2.ReadChangeStreamResponse.DataChange.Type
 */
export enum ReadChangeStreamResponse_DataChange_Type {
  /**
   * The type is unspecified.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * A user-initiated mutation.
   *
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * A system-initiated mutation as part of garbage collection.
   * https://cloud.google.com/bigtable/docs/garbage-collection
   *
   * @generated from enum value: GARBAGE_COLLECTION = 2;
   */
  GARBAGE_COLLECTION = 2,

  /**
   * This is a continuation of a multi-message change.
   *
   * @generated from enum value: CONTINUATION = 3;
   */
  CONTINUATION = 3,
}

/**
 * Describes the enum google.bigtable.v2.ReadChangeStreamResponse.DataChange.Type.
 */
export const ReadChangeStreamResponse_DataChange_TypeSchema: GenEnum<ReadChangeStreamResponse_DataChange_Type> = /*@__PURE__*/
  enumDesc(file_google_bigtable_v2_bigtable, 18, 1, 0);

/**
 * A periodic message with information that can be used to checkpoint
 * the state of a stream.
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse.Heartbeat
 */
export type ReadChangeStreamResponse_Heartbeat = Message<"google.bigtable.v2.ReadChangeStreamResponse.Heartbeat"> & {
  /**
   * A token that can be provided to a subsequent `ReadChangeStream` call
   * to pick up reading at the current stream position.
   *
   * @generated from field: google.bigtable.v2.StreamContinuationToken continuation_token = 1;
   */
  continuationToken?: StreamContinuationToken;

  /**
   * An estimate of the commit timestamp that is usually lower than or equal
   * to any timestamp for a record that will be delivered in the future on the
   * stream. It is possible that, under particular circumstances that a future
   * record has a timestamp is is lower than a previously seen timestamp. For
   * an example usage see
   * https://beam.apache.org/documentation/basics/#watermarks
   *
   * @generated from field: google.protobuf.Timestamp estimated_low_watermark = 2;
   */
  estimatedLowWatermark?: Timestamp;
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.Heartbeat.
 * Use `create(ReadChangeStreamResponse_HeartbeatSchema)` to create a new message.
 */
export const ReadChangeStreamResponse_HeartbeatSchema: GenMessage<ReadChangeStreamResponse_Heartbeat> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18, 2);

/**
 * A message indicating that the client should stop reading from the stream.
 * If status is OK and `continuation_tokens` & `new_partitions` are empty, the
 * stream has finished (for example if there was an `end_time` specified).
 * If `continuation_tokens` & `new_partitions` are present, then a change in
 * partitioning requires the client to open a new stream for each token to
 * resume reading. Example:
 *                                  [B,      D) ends
 *                                       |
 *                                       v
 *               new_partitions:  [A,  C) [C,  E)
 * continuation_tokens.partitions:  [B,C) [C,D)
 *                                  ^---^ ^---^
 *                                  ^     ^
 *                                  |     |
 *                                  |     StreamContinuationToken 2
 *                                  |
 *                                  StreamContinuationToken 1
 * To read the new partition [A,C), supply the continuation tokens whose
 * ranges cover the new partition, for example ContinuationToken[A,B) &
 * ContinuationToken[B,C).
 *
 * @generated from message google.bigtable.v2.ReadChangeStreamResponse.CloseStream
 */
export type ReadChangeStreamResponse_CloseStream = Message<"google.bigtable.v2.ReadChangeStreamResponse.CloseStream"> & {
  /**
   * The status of the stream.
   *
   * @generated from field: google.rpc.Status status = 1;
   */
  status?: Status;

  /**
   * If non-empty, contains the information needed to resume reading their
   * associated partitions.
   *
   * @generated from field: repeated google.bigtable.v2.StreamContinuationToken continuation_tokens = 2;
   */
  continuationTokens: StreamContinuationToken[];

  /**
   * If non-empty, contains the new partitions to start reading from, which
   * are related to but not necessarily identical to the partitions for the
   * above `continuation_tokens`.
   *
   * @generated from field: repeated google.bigtable.v2.StreamPartition new_partitions = 3;
   */
  newPartitions: StreamPartition[];
};

/**
 * Describes the message google.bigtable.v2.ReadChangeStreamResponse.CloseStream.
 * Use `create(ReadChangeStreamResponse_CloseStreamSchema)` to create a new message.
 */
export const ReadChangeStreamResponse_CloseStreamSchema: GenMessage<ReadChangeStreamResponse_CloseStream> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 18, 3);

/**
 * Request message for Bigtable.ExecuteQuery
 *
 * @generated from message google.bigtable.v2.ExecuteQueryRequest
 */
export type ExecuteQueryRequest = Message<"google.bigtable.v2.ExecuteQueryRequest"> & {
  /**
   * Required. The unique name of the instance against which the query should be
   * executed.
   * Values are of the form `projects/<project>/instances/<instance>`
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName: string;

  /**
   * Optional. This value specifies routing for replication. If not specified,
   * the `default` application profile will be used.
   *
   * @generated from field: string app_profile_id = 2;
   */
  appProfileId: string;

  /**
   * Required. The query string.
   *
   * @generated from field: string query = 3;
   */
  query: string;

  /**
   * Required. Requested data format for the response.
   *
   * @generated from oneof google.bigtable.v2.ExecuteQueryRequest.data_format
   */
  dataFormat: {
    /**
     * Protocol buffer format as described by ProtoSchema and ProtoRows
     * messages.
     *
     * @generated from field: google.bigtable.v2.ProtoFormat proto_format = 4;
     */
    value: ProtoFormat;
    case: "protoFormat";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. If this request is resuming a previously interrupted query
   * execution, `resume_token` should be copied from the last
   * PartialResultSet yielded before the interruption. Doing this
   * enables the query execution to resume where the last one left
   * off.
   * The rest of the request parameters must exactly match the
   * request that yielded this token. Otherwise the request will fail.
   *
   * @generated from field: bytes resume_token = 8;
   */
  resumeToken: Uint8Array;

  /**
   * Required. params contains string type keys and Bigtable type values that
   * bind to placeholders in the query string. In query string, a parameter
   * placeholder consists of the
   * `@` character followed by the parameter name (for example, `@firstName`) in
   * the query string.
   *
   * For example, if
   * `params["firstName"] = bytes_value: "foo" type {bytes_type {}}`
   *  then `@firstName` will be replaced with googlesql bytes value "foo" in the
   *  query string during query evaluation.
   *
   * In case of Value.kind is not set, it will be set to corresponding null
   * value in googlesql.
   *  `params["firstName"] =  type {string_type {}}`
   *  then `@firstName` will be replaced with googlesql null string.
   *
   * Value.type should always be set and no inference of type will be made from
   * Value.kind. If Value.type is not set, we will return INVALID_ARGUMENT
   * error.
   *
   * @generated from field: map<string, google.bigtable.v2.Value> params = 7;
   */
  params: { [key: string]: Value };
};

/**
 * Describes the message google.bigtable.v2.ExecuteQueryRequest.
 * Use `create(ExecuteQueryRequestSchema)` to create a new message.
 */
export const ExecuteQueryRequestSchema: GenMessage<ExecuteQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 19);

/**
 * Response message for Bigtable.ExecuteQuery
 *
 * @generated from message google.bigtable.v2.ExecuteQueryResponse
 */
export type ExecuteQueryResponse = Message<"google.bigtable.v2.ExecuteQueryResponse"> & {
  /**
   * The first response streamed from the server is of type `ResultSetMetadata`
   * and includes information about the columns and types of the result set.
   * From there on, we stream `PartialResultSet` messages with no additional
   * information. `PartialResultSet` will contain `resume_token` to restart the
   * response if query interrupts. In case of resumption with `resume_token`,
   * the server will not resend the ResultSetMetadata.
   *
   * @generated from oneof google.bigtable.v2.ExecuteQueryResponse.response
   */
  response: {
    /**
     * Structure of rows in this response stream. The first (and only the first)
     * response streamed from the server will be of this type.
     *
     * @generated from field: google.bigtable.v2.ResultSetMetadata metadata = 1;
     */
    value: ResultSetMetadata;
    case: "metadata";
  } | {
    /**
     * A partial result set with row data potentially including additional
     * instructions on how recent past and future partial responses should be
     * interpreted.
     *
     * @generated from field: google.bigtable.v2.PartialResultSet results = 2;
     */
    value: PartialResultSet;
    case: "results";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ExecuteQueryResponse.
 * Use `create(ExecuteQueryResponseSchema)` to create a new message.
 */
export const ExecuteQueryResponseSchema: GenMessage<ExecuteQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_bigtable, 20);

/**
 * Service for reading from and writing to existing Bigtable tables.
 *
 * @generated from service google.bigtable.v2.Bigtable
 */
export const Bigtable: GenService<{
  /**
   * Streams back the contents of all requested rows in key order, optionally
   * applying the same Reader filter to each. Depending on their size,
   * rows and cells may be broken up across multiple responses, but
   * atomicity of each row will still be preserved. See the
   * ReadRowsResponse documentation for details.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.ReadRows
   */
  readRows: {
    methodKind: "server_streaming";
    input: typeof ReadRowsRequestSchema;
    output: typeof ReadRowsResponseSchema;
  },
  /**
   * Returns a sample of row keys in the table. The returned row keys will
   * delimit contiguous sections of the table of approximately equal size,
   * which can be used to break up the data for distributed tasks like
   * mapreduces.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.SampleRowKeys
   */
  sampleRowKeys: {
    methodKind: "server_streaming";
    input: typeof SampleRowKeysRequestSchema;
    output: typeof SampleRowKeysResponseSchema;
  },
  /**
   * Mutates a row atomically. Cells already present in the row are left
   * unchanged unless explicitly changed by `mutation`.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.MutateRow
   */
  mutateRow: {
    methodKind: "unary";
    input: typeof MutateRowRequestSchema;
    output: typeof MutateRowResponseSchema;
  },
  /**
   * Mutates multiple rows in a batch. Each individual row is mutated
   * atomically as in MutateRow, but the entire batch is not executed
   * atomically.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.MutateRows
   */
  mutateRows: {
    methodKind: "server_streaming";
    input: typeof MutateRowsRequestSchema;
    output: typeof MutateRowsResponseSchema;
  },
  /**
   * Mutates a row atomically based on the output of a predicate Reader filter.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.CheckAndMutateRow
   */
  checkAndMutateRow: {
    methodKind: "unary";
    input: typeof CheckAndMutateRowRequestSchema;
    output: typeof CheckAndMutateRowResponseSchema;
  },
  /**
   * Warm up associated instance metadata for this connection.
   * This call is not required but may be useful for connection keep-alive.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.PingAndWarm
   */
  pingAndWarm: {
    methodKind: "unary";
    input: typeof PingAndWarmRequestSchema;
    output: typeof PingAndWarmResponseSchema;
  },
  /**
   * Modifies a row atomically on the server. The method reads the latest
   * existing timestamp and value from the specified columns and writes a new
   * entry based on pre-defined read/modify/write rules. The new value for the
   * timestamp is the greater of the existing timestamp or the current server
   * time. The method returns the new contents of all modified cells.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.ReadModifyWriteRow
   */
  readModifyWriteRow: {
    methodKind: "unary";
    input: typeof ReadModifyWriteRowRequestSchema;
    output: typeof ReadModifyWriteRowResponseSchema;
  },
  /**
   * NOTE: This API is intended to be used by Apache Beam BigtableIO.
   * Returns the current list of partitions that make up the table's
   * change stream. The union of partitions will cover the entire keyspace.
   * Partitions can be read with `ReadChangeStream`.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.GenerateInitialChangeStreamPartitions
   */
  generateInitialChangeStreamPartitions: {
    methodKind: "server_streaming";
    input: typeof GenerateInitialChangeStreamPartitionsRequestSchema;
    output: typeof GenerateInitialChangeStreamPartitionsResponseSchema;
  },
  /**
   * NOTE: This API is intended to be used by Apache Beam BigtableIO.
   * Reads changes from a table's change stream. Changes will
   * reflect both user-initiated mutations and mutations that are caused by
   * garbage collection.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.ReadChangeStream
   */
  readChangeStream: {
    methodKind: "server_streaming";
    input: typeof ReadChangeStreamRequestSchema;
    output: typeof ReadChangeStreamResponseSchema;
  },
  /**
   * Executes a BTQL query against a particular Cloud Bigtable instance.
   *
   * @generated from rpc google.bigtable.v2.Bigtable.ExecuteQuery
   */
  executeQuery: {
    methodKind: "server_streaming";
    input: typeof ExecuteQueryRequestSchema;
    output: typeof ExecuteQueryResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_bigtable_v2_bigtable, 0);

