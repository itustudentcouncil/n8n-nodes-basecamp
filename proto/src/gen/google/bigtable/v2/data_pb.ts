// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/bigtable/v2/data.proto (package google.bigtable.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import type { Type } from "./types_pb";
import { file_google_bigtable_v2_types } from "./types_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Date } from "../../type/date_pb";
import { file_google_type_date } from "../../type/date_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/bigtable/v2/data.proto.
 */
export const file_google_bigtable_v2_data: GenFile = /*@__PURE__*/
  fileDesc("Ch1nb29nbGUvYmlndGFibGUvdjIvZGF0YS5wcm90bxISZ29vZ2xlLmJpZ3RhYmxlLnYyIkAKA1JvdxILCgNrZXkYASABKAwSLAoIZmFtaWxpZXMYAiADKAsyGi5nb29nbGUuYmlndGFibGUudjIuRmFtaWx5IkMKBkZhbWlseRIMCgRuYW1lGAEgASgJEisKB2NvbHVtbnMYAiADKAsyGi5nb29nbGUuYmlndGFibGUudjIuQ29sdW1uIkQKBkNvbHVtbhIRCglxdWFsaWZpZXIYASABKAwSJwoFY2VsbHMYAiADKAsyGC5nb29nbGUuYmlndGFibGUudjIuQ2VsbCI/CgRDZWxsEhgKEHRpbWVzdGFtcF9taWNyb3MYASABKAMSDQoFdmFsdWUYAiABKAwSDgoGbGFiZWxzGAMgAygJIvQCCgVWYWx1ZRImCgR0eXBlGAcgASgLMhguZ29vZ2xlLmJpZ3RhYmxlLnYyLlR5cGUSEwoJcmF3X3ZhbHVlGAggASgMSAASHgoUcmF3X3RpbWVzdGFtcF9taWNyb3MYCSABKANIABIVCgtieXRlc192YWx1ZRgCIAEoDEgAEhYKDHN0cmluZ192YWx1ZRgDIAEoCUgAEhMKCWludF92YWx1ZRgGIAEoA0gAEhQKCmJvb2xfdmFsdWUYCiABKAhIABIVCgtmbG9hdF92YWx1ZRgLIAEoAUgAEjUKD3RpbWVzdGFtcF92YWx1ZRgMIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIABInCgpkYXRlX3ZhbHVlGA0gASgLMhEuZ29vZ2xlLnR5cGUuRGF0ZUgAEjUKC2FycmF5X3ZhbHVlGAQgASgLMh4uZ29vZ2xlLmJpZ3RhYmxlLnYyLkFycmF5VmFsdWVIAEIGCgRraW5kIjcKCkFycmF5VmFsdWUSKQoGdmFsdWVzGAEgAygLMhkuZ29vZ2xlLmJpZ3RhYmxlLnYyLlZhbHVlIooBCghSb3dSYW5nZRIaChBzdGFydF9rZXlfY2xvc2VkGAEgASgMSAASGAoOc3RhcnRfa2V5X29wZW4YAiABKAxIABIWCgxlbmRfa2V5X29wZW4YAyABKAxIARIYCg5lbmRfa2V5X2Nsb3NlZBgEIAEoDEgBQgsKCXN0YXJ0X2tleUIJCgdlbmRfa2V5IkwKBlJvd1NldBIQCghyb3dfa2V5cxgBIAMoDBIwCgpyb3dfcmFuZ2VzGAIgAygLMhwuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd1JhbmdlIsYBCgtDb2x1bW5SYW5nZRITCgtmYW1pbHlfbmFtZRgBIAEoCRIgChZzdGFydF9xdWFsaWZpZXJfY2xvc2VkGAIgASgMSAASHgoUc3RhcnRfcXVhbGlmaWVyX29wZW4YAyABKAxIABIeChRlbmRfcXVhbGlmaWVyX2Nsb3NlZBgEIAEoDEgBEhwKEmVuZF9xdWFsaWZpZXJfb3BlbhgFIAEoDEgBQhEKD3N0YXJ0X3F1YWxpZmllckIPCg1lbmRfcXVhbGlmaWVyIk4KDlRpbWVzdGFtcFJhbmdlEh4KFnN0YXJ0X3RpbWVzdGFtcF9taWNyb3MYASABKAMSHAoUZW5kX3RpbWVzdGFtcF9taWNyb3MYAiABKAMimAEKClZhbHVlUmFuZ2USHAoSc3RhcnRfdmFsdWVfY2xvc2VkGAEgASgMSAASGgoQc3RhcnRfdmFsdWVfb3BlbhgCIAEoDEgAEhoKEGVuZF92YWx1ZV9jbG9zZWQYAyABKAxIARIYCg5lbmRfdmFsdWVfb3BlbhgEIAEoDEgBQg0KC3N0YXJ0X3ZhbHVlQgsKCWVuZF92YWx1ZSLfCAoJUm93RmlsdGVyEjQKBWNoYWluGAEgASgLMiMuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd0ZpbHRlci5DaGFpbkgAEj4KCmludGVybGVhdmUYAiABKAsyKC5nb29nbGUuYmlndGFibGUudjIuUm93RmlsdGVyLkludGVybGVhdmVIABI8Cgljb25kaXRpb24YAyABKAsyJy5nb29nbGUuYmlndGFibGUudjIuUm93RmlsdGVyLkNvbmRpdGlvbkgAEg4KBHNpbmsYECABKAhIABIZCg9wYXNzX2FsbF9maWx0ZXIYESABKAhIABIaChBibG9ja19hbGxfZmlsdGVyGBIgASgISAASHgoUcm93X2tleV9yZWdleF9maWx0ZXIYBCABKAxIABIbChFyb3dfc2FtcGxlX2ZpbHRlchgOIAEoAUgAEiIKGGZhbWlseV9uYW1lX3JlZ2V4X2ZpbHRlchgFIAEoCUgAEicKHWNvbHVtbl9xdWFsaWZpZXJfcmVnZXhfZmlsdGVyGAYgASgMSAASPgoTY29sdW1uX3JhbmdlX2ZpbHRlchgHIAEoCzIfLmdvb2dsZS5iaWd0YWJsZS52Mi5Db2x1bW5SYW5nZUgAEkQKFnRpbWVzdGFtcF9yYW5nZV9maWx0ZXIYCCABKAsyIi5nb29nbGUuYmlndGFibGUudjIuVGltZXN0YW1wUmFuZ2VIABIcChJ2YWx1ZV9yZWdleF9maWx0ZXIYCSABKAxIABI8ChJ2YWx1ZV9yYW5nZV9maWx0ZXIYDyABKAsyHi5nb29nbGUuYmlndGFibGUudjIuVmFsdWVSYW5nZUgAEiUKG2NlbGxzX3Blcl9yb3dfb2Zmc2V0X2ZpbHRlchgKIAEoBUgAEiQKGmNlbGxzX3Blcl9yb3dfbGltaXRfZmlsdGVyGAsgASgFSAASJwodY2VsbHNfcGVyX2NvbHVtbl9saW1pdF9maWx0ZXIYDCABKAVIABIhChdzdHJpcF92YWx1ZV90cmFuc2Zvcm1lchgNIAEoCEgAEiEKF2FwcGx5X2xhYmVsX3RyYW5zZm9ybWVyGBMgASgJSAAaNwoFQ2hhaW4SLgoHZmlsdGVycxgBIAMoCzIdLmdvb2dsZS5iaWd0YWJsZS52Mi5Sb3dGaWx0ZXIaPAoKSW50ZXJsZWF2ZRIuCgdmaWx0ZXJzGAEgAygLMh0uZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd0ZpbHRlchqtAQoJQ29uZGl0aW9uEjcKEHByZWRpY2F0ZV9maWx0ZXIYASABKAsyHS5nb29nbGUuYmlndGFibGUudjIuUm93RmlsdGVyEjIKC3RydWVfZmlsdGVyGAIgASgLMh0uZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd0ZpbHRlchIzCgxmYWxzZV9maWx0ZXIYAyABKAsyHS5nb29nbGUuYmlndGFibGUudjIuUm93RmlsdGVyQggKBmZpbHRlciKtCAoITXV0YXRpb24SOAoIc2V0X2NlbGwYASABKAsyJC5nb29nbGUuYmlndGFibGUudjIuTXV0YXRpb24uU2V0Q2VsbEgAEj0KC2FkZF90b19jZWxsGAUgASgLMiYuZ29vZ2xlLmJpZ3RhYmxlLnYyLk11dGF0aW9uLkFkZFRvQ2VsbEgAEkEKDW1lcmdlX3RvX2NlbGwYBiABKAsyKC5nb29nbGUuYmlndGFibGUudjIuTXV0YXRpb24uTWVyZ2VUb0NlbGxIABJLChJkZWxldGVfZnJvbV9jb2x1bW4YAiABKAsyLS5nb29nbGUuYmlndGFibGUudjIuTXV0YXRpb24uRGVsZXRlRnJvbUNvbHVtbkgAEksKEmRlbGV0ZV9mcm9tX2ZhbWlseRgDIAEoCzItLmdvb2dsZS5iaWd0YWJsZS52Mi5NdXRhdGlvbi5EZWxldGVGcm9tRmFtaWx5SAASRQoPZGVsZXRlX2Zyb21fcm93GAQgASgLMiouZ29vZ2xlLmJpZ3RhYmxlLnYyLk11dGF0aW9uLkRlbGV0ZUZyb21Sb3dIABphCgdTZXRDZWxsEhMKC2ZhbWlseV9uYW1lGAEgASgJEhgKEGNvbHVtbl9xdWFsaWZpZXIYAiABKAwSGAoQdGltZXN0YW1wX21pY3JvcxgDIAEoAxINCgV2YWx1ZRgEIAEoDBqtAQoJQWRkVG9DZWxsEhMKC2ZhbWlseV9uYW1lGAEgASgJEjMKEGNvbHVtbl9xdWFsaWZpZXIYAiABKAsyGS5nb29nbGUuYmlndGFibGUudjIuVmFsdWUSLAoJdGltZXN0YW1wGAMgASgLMhkuZ29vZ2xlLmJpZ3RhYmxlLnYyLlZhbHVlEigKBWlucHV0GAQgASgLMhkuZ29vZ2xlLmJpZ3RhYmxlLnYyLlZhbHVlGq8BCgtNZXJnZVRvQ2VsbBITCgtmYW1pbHlfbmFtZRgBIAEoCRIzChBjb2x1bW5fcXVhbGlmaWVyGAIgASgLMhkuZ29vZ2xlLmJpZ3RhYmxlLnYyLlZhbHVlEiwKCXRpbWVzdGFtcBgDIAEoCzIZLmdvb2dsZS5iaWd0YWJsZS52Mi5WYWx1ZRIoCgVpbnB1dBgEIAEoCzIZLmdvb2dsZS5iaWd0YWJsZS52Mi5WYWx1ZRp5ChBEZWxldGVGcm9tQ29sdW1uEhMKC2ZhbWlseV9uYW1lGAEgASgJEhgKEGNvbHVtbl9xdWFsaWZpZXIYAiABKAwSNgoKdGltZV9yYW5nZRgDIAEoCzIiLmdvb2dsZS5iaWd0YWJsZS52Mi5UaW1lc3RhbXBSYW5nZRonChBEZWxldGVGcm9tRmFtaWx5EhMKC2ZhbWlseV9uYW1lGAEgASgJGg8KDURlbGV0ZUZyb21Sb3dCCgoIbXV0YXRpb24igAEKE1JlYWRNb2RpZnlXcml0ZVJ1bGUSEwoLZmFtaWx5X25hbWUYASABKAkSGAoQY29sdW1uX3F1YWxpZmllchgCIAEoDBIWCgxhcHBlbmRfdmFsdWUYAyABKAxIABIaChBpbmNyZW1lbnRfYW1vdW50GAQgASgDSABCBgoEcnVsZSJCCg9TdHJlYW1QYXJ0aXRpb24SLwoJcm93X3JhbmdlGAEgASgLMhwuZ29vZ2xlLmJpZ3RhYmxlLnYyLlJvd1JhbmdlIlcKGFN0cmVhbUNvbnRpbnVhdGlvblRva2VucxI7CgZ0b2tlbnMYASADKAsyKy5nb29nbGUuYmlndGFibGUudjIuU3RyZWFtQ29udGludWF0aW9uVG9rZW4iYAoXU3RyZWFtQ29udGludWF0aW9uVG9rZW4SNgoJcGFydGl0aW9uGAEgASgLMiMuZ29vZ2xlLmJpZ3RhYmxlLnYyLlN0cmVhbVBhcnRpdGlvbhINCgV0b2tlbhgCIAEoCSINCgtQcm90b0Zvcm1hdCJGCg5Db2x1bW5NZXRhZGF0YRIMCgRuYW1lGAEgASgJEiYKBHR5cGUYAiABKAsyGC5nb29nbGUuYmlndGFibGUudjIuVHlwZSJCCgtQcm90b1NjaGVtYRIzCgdjb2x1bW5zGAEgAygLMiIuZ29vZ2xlLmJpZ3RhYmxlLnYyLkNvbHVtbk1ldGFkYXRhIlYKEVJlc3VsdFNldE1ldGFkYXRhEjcKDHByb3RvX3NjaGVtYRgBIAEoCzIfLmdvb2dsZS5iaWd0YWJsZS52Mi5Qcm90b1NjaGVtYUgAQggKBnNjaGVtYSI2CglQcm90b1Jvd3MSKQoGdmFsdWVzGAIgAygLMhkuZ29vZ2xlLmJpZ3RhYmxlLnYyLlZhbHVlIiQKDlByb3RvUm93c0JhdGNoEhIKCmJhdGNoX2RhdGEYASABKAwilgEKEFBhcnRpYWxSZXN1bHRTZXQSPgoQcHJvdG9fcm93c19iYXRjaBgDIAEoCzIiLmdvb2dsZS5iaWd0YWJsZS52Mi5Qcm90b1Jvd3NCYXRjaEgAEhQKDHJlc3VtZV90b2tlbhgFIAEoDBIcChRlc3RpbWF0ZWRfYmF0Y2hfc2l6ZRgEIAEoBUIOCgxwYXJ0aWFsX3Jvd3NCswEKFmNvbS5nb29nbGUuYmlndGFibGUudjJCCURhdGFQcm90b1ABWjhjbG91ZC5nb29nbGUuY29tL2dvL2JpZ3RhYmxlL2FwaXYyL2JpZ3RhYmxlcGI7YmlndGFibGVwYqoCGEdvb2dsZS5DbG91ZC5CaWd0YWJsZS5WMsoCGEdvb2dsZVxDbG91ZFxCaWd0YWJsZVxWMuoCG0dvb2dsZTo6Q2xvdWQ6OkJpZ3RhYmxlOjpWMmIGcHJvdG8z", [file_google_api_field_behavior, file_google_bigtable_v2_types, file_google_protobuf_timestamp, file_google_type_date]);

/**
 * Specifies the complete (requested) contents of a single row of a table.
 * Rows which exceed 256MiB in size cannot be read in full.
 *
 * @generated from message google.bigtable.v2.Row
 */
export type Row = Message<"google.bigtable.v2.Row"> & {
  /**
   * The unique key which identifies this row within its table. This is the same
   * key that's used to identify the row in, for example, a MutateRowRequest.
   * May contain any non-empty byte string up to 4KiB in length.
   *
   * @generated from field: bytes key = 1;
   */
  key: Uint8Array;

  /**
   * May be empty, but only if the entire row is empty.
   * The mutual ordering of column families is not specified.
   *
   * @generated from field: repeated google.bigtable.v2.Family families = 2;
   */
  families: Family[];
};

/**
 * Describes the message google.bigtable.v2.Row.
 * Use `create(RowSchema)` to create a new message.
 */
export const RowSchema: GenMessage<Row> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 0);

/**
 * Specifies (some of) the contents of a single row/column family intersection
 * of a table.
 *
 * @generated from message google.bigtable.v2.Family
 */
export type Family = Message<"google.bigtable.v2.Family"> & {
  /**
   * The unique key which identifies this family within its row. This is the
   * same key that's used to identify the family in, for example, a RowFilter
   * which sets its "family_name_regex_filter" field.
   * Must match `[-_.a-zA-Z0-9]+`, except that AggregatingRowProcessors may
   * produce cells in a sentinel family with an empty name.
   * Must be no greater than 64 characters in length.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Must not be empty. Sorted in order of increasing "qualifier".
   *
   * @generated from field: repeated google.bigtable.v2.Column columns = 2;
   */
  columns: Column[];
};

/**
 * Describes the message google.bigtable.v2.Family.
 * Use `create(FamilySchema)` to create a new message.
 */
export const FamilySchema: GenMessage<Family> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 1);

/**
 * Specifies (some of) the contents of a single row/column intersection of a
 * table.
 *
 * @generated from message google.bigtable.v2.Column
 */
export type Column = Message<"google.bigtable.v2.Column"> & {
  /**
   * The unique key which identifies this column within its family. This is the
   * same key that's used to identify the column in, for example, a RowFilter
   * which sets its `column_qualifier_regex_filter` field.
   * May contain any byte string, including the empty string, up to 16kiB in
   * length.
   *
   * @generated from field: bytes qualifier = 1;
   */
  qualifier: Uint8Array;

  /**
   * Must not be empty. Sorted in order of decreasing "timestamp_micros".
   *
   * @generated from field: repeated google.bigtable.v2.Cell cells = 2;
   */
  cells: Cell[];
};

/**
 * Describes the message google.bigtable.v2.Column.
 * Use `create(ColumnSchema)` to create a new message.
 */
export const ColumnSchema: GenMessage<Column> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 2);

/**
 * Specifies (some of) the contents of a single row/column/timestamp of a table.
 *
 * @generated from message google.bigtable.v2.Cell
 */
export type Cell = Message<"google.bigtable.v2.Cell"> & {
  /**
   * The cell's stored timestamp, which also uniquely identifies it within
   * its column.
   * Values are always expressed in microseconds, but individual tables may set
   * a coarser granularity to further restrict the allowed values. For
   * example, a table which specifies millisecond granularity will only allow
   * values of `timestamp_micros` which are multiples of 1000.
   *
   * @generated from field: int64 timestamp_micros = 1;
   */
  timestampMicros: bigint;

  /**
   * The value stored in the cell.
   * May contain any byte string, including the empty string, up to 100MiB in
   * length.
   *
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * Labels applied to the cell by a [RowFilter][google.bigtable.v2.RowFilter].
   *
   * @generated from field: repeated string labels = 3;
   */
  labels: string[];
};

/**
 * Describes the message google.bigtable.v2.Cell.
 * Use `create(CellSchema)` to create a new message.
 */
export const CellSchema: GenMessage<Cell> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 3);

/**
 * `Value` represents a dynamically typed value.
 * The typed fields in `Value` are used as a transport encoding for the actual
 * value (which may be of a more complex type). See the documentation of the
 * `Type` message for more details.
 *
 * @generated from message google.bigtable.v2.Value
 */
export type Value = Message<"google.bigtable.v2.Value"> & {
  /**
   * The verified `Type` of this `Value`, if it cannot be inferred.
   *
   * Read results will never specify the encoding for `type` since the value
   * will already have been decoded by the server. Furthermore, the `type` will
   * be omitted entirely if it can be inferred from a previous response. The
   * exact semantics for inferring `type` will vary, and are therefore
   * documented separately for each read method.
   *
   * When using composite types (Struct, Array, Map) only the outermost `Value`
   * will specify the `type`. This top-level `type` will define the types for
   * any nested `Struct' fields, `Array` elements, or `Map` key/value pairs.
   * If a nested `Value` provides a `type` on write, the request will be
   * rejected with INVALID_ARGUMENT.
   *
   * @generated from field: google.bigtable.v2.Type type = 7;
   */
  type?: Type;

  /**
   * Options for transporting values within the protobuf type system. A given
   * `kind` may support more than one `type` and vice versa. On write, this is
   * roughly analogous to a GoogleSQL literal.
   *
   * The value is `NULL` if none of the fields in `kind` is set. If `type` is
   * also omitted on write, we will infer it based on the schema.
   *
   * @generated from oneof google.bigtable.v2.Value.kind
   */
  kind: {
    /**
     * Represents a raw byte sequence with no type information.
     * The `type` field must be omitted.
     *
     * @generated from field: bytes raw_value = 8;
     */
    value: Uint8Array;
    case: "rawValue";
  } | {
    /**
     * Represents a raw cell timestamp with no type information.
     * The `type` field must be omitted.
     *
     * @generated from field: int64 raw_timestamp_micros = 9;
     */
    value: bigint;
    case: "rawTimestampMicros";
  } | {
    /**
     * Represents a typed value transported as a byte sequence.
     *
     * @generated from field: bytes bytes_value = 2;
     */
    value: Uint8Array;
    case: "bytesValue";
  } | {
    /**
     * Represents a typed value transported as a string.
     *
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * Represents a typed value transported as an integer.
     *
     * @generated from field: int64 int_value = 6;
     */
    value: bigint;
    case: "intValue";
  } | {
    /**
     * Represents a typed value transported as a boolean.
     *
     * @generated from field: bool bool_value = 10;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * Represents a typed value transported as a floating point number.
     *
     * @generated from field: double float_value = 11;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * Represents a typed value transported as a timestamp.
     *
     * @generated from field: google.protobuf.Timestamp timestamp_value = 12;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * Represents a typed value transported as a date.
     *
     * @generated from field: google.type.Date date_value = 13;
     */
    value: Date;
    case: "dateValue";
  } | {
    /**
     * Represents a typed value transported as a sequence of values.
     * To differentiate between `Struct`, `Array`, and `Map`, the outermost
     * `Value` must provide an explicit `type` on write. This `type` will
     * apply recursively to the nested `Struct` fields, `Array` elements,
     * or `Map` key/value pairs, which *must not* supply their own `type`.
     *
     * @generated from field: google.bigtable.v2.ArrayValue array_value = 4;
     */
    value: ArrayValue;
    case: "arrayValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.Value.
 * Use `create(ValueSchema)` to create a new message.
 */
export const ValueSchema: GenMessage<Value> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 4);

/**
 * `ArrayValue` is an ordered list of `Value`.
 *
 * @generated from message google.bigtable.v2.ArrayValue
 */
export type ArrayValue = Message<"google.bigtable.v2.ArrayValue"> & {
  /**
   * The ordered elements in the array.
   *
   * @generated from field: repeated google.bigtable.v2.Value values = 1;
   */
  values: Value[];
};

/**
 * Describes the message google.bigtable.v2.ArrayValue.
 * Use `create(ArrayValueSchema)` to create a new message.
 */
export const ArrayValueSchema: GenMessage<ArrayValue> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 5);

/**
 * Specifies a contiguous range of rows.
 *
 * @generated from message google.bigtable.v2.RowRange
 */
export type RowRange = Message<"google.bigtable.v2.RowRange"> & {
  /**
   * The row key at which to start the range.
   * If neither field is set, interpreted as the empty string, inclusive.
   *
   * @generated from oneof google.bigtable.v2.RowRange.start_key
   */
  startKey: {
    /**
     * Used when giving an inclusive lower bound for the range.
     *
     * @generated from field: bytes start_key_closed = 1;
     */
    value: Uint8Array;
    case: "startKeyClosed";
  } | {
    /**
     * Used when giving an exclusive lower bound for the range.
     *
     * @generated from field: bytes start_key_open = 2;
     */
    value: Uint8Array;
    case: "startKeyOpen";
  } | { case: undefined; value?: undefined };

  /**
   * The row key at which to end the range.
   * If neither field is set, interpreted as the infinite row key, exclusive.
   *
   * @generated from oneof google.bigtable.v2.RowRange.end_key
   */
  endKey: {
    /**
     * Used when giving an exclusive upper bound for the range.
     *
     * @generated from field: bytes end_key_open = 3;
     */
    value: Uint8Array;
    case: "endKeyOpen";
  } | {
    /**
     * Used when giving an inclusive upper bound for the range.
     *
     * @generated from field: bytes end_key_closed = 4;
     */
    value: Uint8Array;
    case: "endKeyClosed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.RowRange.
 * Use `create(RowRangeSchema)` to create a new message.
 */
export const RowRangeSchema: GenMessage<RowRange> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 6);

/**
 * Specifies a non-contiguous set of rows.
 *
 * @generated from message google.bigtable.v2.RowSet
 */
export type RowSet = Message<"google.bigtable.v2.RowSet"> & {
  /**
   * Single rows included in the set.
   *
   * @generated from field: repeated bytes row_keys = 1;
   */
  rowKeys: Uint8Array[];

  /**
   * Contiguous row ranges included in the set.
   *
   * @generated from field: repeated google.bigtable.v2.RowRange row_ranges = 2;
   */
  rowRanges: RowRange[];
};

/**
 * Describes the message google.bigtable.v2.RowSet.
 * Use `create(RowSetSchema)` to create a new message.
 */
export const RowSetSchema: GenMessage<RowSet> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 7);

/**
 * Specifies a contiguous range of columns within a single column family.
 * The range spans from &lt;column_family&gt;:&lt;start_qualifier&gt; to
 * &lt;column_family&gt;:&lt;end_qualifier&gt;, where both bounds can be either
 * inclusive or exclusive.
 *
 * @generated from message google.bigtable.v2.ColumnRange
 */
export type ColumnRange = Message<"google.bigtable.v2.ColumnRange"> & {
  /**
   * The name of the column family within which this range falls.
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The column qualifier at which to start the range (within `column_family`).
   * If neither field is set, interpreted as the empty string, inclusive.
   *
   * @generated from oneof google.bigtable.v2.ColumnRange.start_qualifier
   */
  startQualifier: {
    /**
     * Used when giving an inclusive lower bound for the range.
     *
     * @generated from field: bytes start_qualifier_closed = 2;
     */
    value: Uint8Array;
    case: "startQualifierClosed";
  } | {
    /**
     * Used when giving an exclusive lower bound for the range.
     *
     * @generated from field: bytes start_qualifier_open = 3;
     */
    value: Uint8Array;
    case: "startQualifierOpen";
  } | { case: undefined; value?: undefined };

  /**
   * The column qualifier at which to end the range (within `column_family`).
   * If neither field is set, interpreted as the infinite string, exclusive.
   *
   * @generated from oneof google.bigtable.v2.ColumnRange.end_qualifier
   */
  endQualifier: {
    /**
     * Used when giving an inclusive upper bound for the range.
     *
     * @generated from field: bytes end_qualifier_closed = 4;
     */
    value: Uint8Array;
    case: "endQualifierClosed";
  } | {
    /**
     * Used when giving an exclusive upper bound for the range.
     *
     * @generated from field: bytes end_qualifier_open = 5;
     */
    value: Uint8Array;
    case: "endQualifierOpen";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ColumnRange.
 * Use `create(ColumnRangeSchema)` to create a new message.
 */
export const ColumnRangeSchema: GenMessage<ColumnRange> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 8);

/**
 * Specified a contiguous range of microsecond timestamps.
 *
 * @generated from message google.bigtable.v2.TimestampRange
 */
export type TimestampRange = Message<"google.bigtable.v2.TimestampRange"> & {
  /**
   * Inclusive lower bound. If left empty, interpreted as 0.
   *
   * @generated from field: int64 start_timestamp_micros = 1;
   */
  startTimestampMicros: bigint;

  /**
   * Exclusive upper bound. If left empty, interpreted as infinity.
   *
   * @generated from field: int64 end_timestamp_micros = 2;
   */
  endTimestampMicros: bigint;
};

/**
 * Describes the message google.bigtable.v2.TimestampRange.
 * Use `create(TimestampRangeSchema)` to create a new message.
 */
export const TimestampRangeSchema: GenMessage<TimestampRange> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 9);

/**
 * Specifies a contiguous range of raw byte values.
 *
 * @generated from message google.bigtable.v2.ValueRange
 */
export type ValueRange = Message<"google.bigtable.v2.ValueRange"> & {
  /**
   * The value at which to start the range.
   * If neither field is set, interpreted as the empty string, inclusive.
   *
   * @generated from oneof google.bigtable.v2.ValueRange.start_value
   */
  startValue: {
    /**
     * Used when giving an inclusive lower bound for the range.
     *
     * @generated from field: bytes start_value_closed = 1;
     */
    value: Uint8Array;
    case: "startValueClosed";
  } | {
    /**
     * Used when giving an exclusive lower bound for the range.
     *
     * @generated from field: bytes start_value_open = 2;
     */
    value: Uint8Array;
    case: "startValueOpen";
  } | { case: undefined; value?: undefined };

  /**
   * The value at which to end the range.
   * If neither field is set, interpreted as the infinite string, exclusive.
   *
   * @generated from oneof google.bigtable.v2.ValueRange.end_value
   */
  endValue: {
    /**
     * Used when giving an inclusive upper bound for the range.
     *
     * @generated from field: bytes end_value_closed = 3;
     */
    value: Uint8Array;
    case: "endValueClosed";
  } | {
    /**
     * Used when giving an exclusive upper bound for the range.
     *
     * @generated from field: bytes end_value_open = 4;
     */
    value: Uint8Array;
    case: "endValueOpen";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ValueRange.
 * Use `create(ValueRangeSchema)` to create a new message.
 */
export const ValueRangeSchema: GenMessage<ValueRange> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 10);

/**
 * Takes a row as input and produces an alternate view of the row based on
 * specified rules. For example, a RowFilter might trim down a row to include
 * just the cells from columns matching a given regular expression, or might
 * return all the cells of a row but not their values. More complicated filters
 * can be composed out of these components to express requests such as, "within
 * every column of a particular family, give just the two most recent cells
 * which are older than timestamp X."
 *
 * There are two broad categories of RowFilters (true filters and transformers),
 * as well as two ways to compose simple filters into more complex ones
 * (chains and interleaves). They work as follows:
 *
 * * True filters alter the input row by excluding some of its cells wholesale
 * from the output row. An example of a true filter is the `value_regex_filter`,
 * which excludes cells whose values don't match the specified pattern. All
 * regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
 * in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
 * important point to keep in mind is that `RE2(.)` is equivalent by default to
 * `RE2([^\n])`, meaning that it does not match newlines. When attempting to
 * match an arbitrary byte, you should therefore use the escape sequence `\C`,
 * which may need to be further escaped as `\\C` in your client language.
 *
 * * Transformers alter the input row by changing the values of some of its
 * cells in the output, without excluding them completely. Currently, the only
 * supported transformer is the `strip_value_transformer`, which replaces every
 * cell's value with the empty string.
 *
 * * Chains and interleaves are described in more detail in the
 * RowFilter.Chain and RowFilter.Interleave documentation.
 *
 * The total serialized size of a RowFilter message must not
 * exceed 20480 bytes, and RowFilters may not be nested within each other
 * (in Chains or Interleaves) to a depth of more than 20.
 *
 * @generated from message google.bigtable.v2.RowFilter
 */
export type RowFilter = Message<"google.bigtable.v2.RowFilter"> & {
  /**
   * Which of the possible RowFilter types to apply. If none are set, this
   * RowFilter returns all cells in the input row.
   *
   * @generated from oneof google.bigtable.v2.RowFilter.filter
   */
  filter: {
    /**
     * Applies several RowFilters to the data in sequence, progressively
     * narrowing the results.
     *
     * @generated from field: google.bigtable.v2.RowFilter.Chain chain = 1;
     */
    value: RowFilter_Chain;
    case: "chain";
  } | {
    /**
     * Applies several RowFilters to the data in parallel and combines the
     * results.
     *
     * @generated from field: google.bigtable.v2.RowFilter.Interleave interleave = 2;
     */
    value: RowFilter_Interleave;
    case: "interleave";
  } | {
    /**
     * Applies one of two possible RowFilters to the data based on the output of
     * a predicate RowFilter.
     *
     * @generated from field: google.bigtable.v2.RowFilter.Condition condition = 3;
     */
    value: RowFilter_Condition;
    case: "condition";
  } | {
    /**
     * ADVANCED USE ONLY.
     * Hook for introspection into the RowFilter. Outputs all cells directly to
     * the output of the read rather than to any parent filter. Consider the
     * following example:
     *
     *     Chain(
     *       FamilyRegex("A"),
     *       Interleave(
     *         All(),
     *         Chain(Label("foo"), Sink())
     *       ),
     *       QualifierRegex("B")
     *     )
     *
     *                         A,A,1,w
     *                         A,B,2,x
     *                         B,B,4,z
     *                            |
     *                     FamilyRegex("A")
     *                            |
     *                         A,A,1,w
     *                         A,B,2,x
     *                            |
     *               +------------+-------------+
     *               |                          |
     *             All()                    Label(foo)
     *               |                          |
     *            A,A,1,w              A,A,1,w,labels:[foo]
     *            A,B,2,x              A,B,2,x,labels:[foo]
     *               |                          |
     *               |                        Sink() --------------+
     *               |                          |                  |
     *               +------------+      x------+          A,A,1,w,labels:[foo]
     *                            |                        A,B,2,x,labels:[foo]
     *                         A,A,1,w                             |
     *                         A,B,2,x                             |
     *                            |                                |
     *                    QualifierRegex("B")                      |
     *                            |                                |
     *                         A,B,2,x                             |
     *                            |                                |
     *                            +--------------------------------+
     *                            |
     *                         A,A,1,w,labels:[foo]
     *                         A,B,2,x,labels:[foo]  // could be switched
     *                         A,B,2,x               // could be switched
     *
     * Despite being excluded by the qualifier filter, a copy of every cell
     * that reaches the sink is present in the final result.
     *
     * As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
     * duplicate cells are possible, and appear in an unspecified mutual order.
     * In this case we have a duplicate with column "A:B" and timestamp 2,
     * because one copy passed through the all filter while the other was
     * passed through the label and sink. Note that one copy has label "foo",
     * while the other does not.
     *
     * Cannot be used within the `predicate_filter`, `true_filter`, or
     * `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
     *
     * @generated from field: bool sink = 16;
     */
    value: boolean;
    case: "sink";
  } | {
    /**
     * Matches all cells, regardless of input. Functionally equivalent to
     * leaving `filter` unset, but included for completeness.
     *
     * @generated from field: bool pass_all_filter = 17;
     */
    value: boolean;
    case: "passAllFilter";
  } | {
    /**
     * Does not match any cells, regardless of input. Useful for temporarily
     * disabling just part of a filter.
     *
     * @generated from field: bool block_all_filter = 18;
     */
    value: boolean;
    case: "blockAllFilter";
  } | {
    /**
     * Matches only cells from rows whose keys satisfy the given RE2 regex. In
     * other words, passes through the entire row when the key matches, and
     * otherwise produces an empty row.
     * Note that, since row keys can contain arbitrary bytes, the `\C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `\n`, which may be present in a
     * binary key.
     *
     * @generated from field: bytes row_key_regex_filter = 4;
     */
    value: Uint8Array;
    case: "rowKeyRegexFilter";
  } | {
    /**
     * Matches all cells from a row with probability p, and matches no cells
     * from the row with probability 1-p.
     *
     * @generated from field: double row_sample_filter = 14;
     */
    value: number;
    case: "rowSampleFilter";
  } | {
    /**
     * Matches only cells from columns whose families satisfy the given RE2
     * regex. For technical reasons, the regex must not contain the `:`
     * character, even if it is not being used as a literal.
     * Note that, since column families cannot contain the new line character
     * `\n`, it is sufficient to use `.` as a full wildcard when matching
     * column family names.
     *
     * @generated from field: string family_name_regex_filter = 5;
     */
    value: string;
    case: "familyNameRegexFilter";
  } | {
    /**
     * Matches only cells from columns whose qualifiers satisfy the given RE2
     * regex.
     * Note that, since column qualifiers can contain arbitrary bytes, the `\C`
     * escape sequence must be used if a true wildcard is desired. The `.`
     * character will not match the new line character `\n`, which may be
     * present in a binary qualifier.
     *
     * @generated from field: bytes column_qualifier_regex_filter = 6;
     */
    value: Uint8Array;
    case: "columnQualifierRegexFilter";
  } | {
    /**
     * Matches only cells from columns within the given range.
     *
     * @generated from field: google.bigtable.v2.ColumnRange column_range_filter = 7;
     */
    value: ColumnRange;
    case: "columnRangeFilter";
  } | {
    /**
     * Matches only cells with timestamps within the given range.
     *
     * @generated from field: google.bigtable.v2.TimestampRange timestamp_range_filter = 8;
     */
    value: TimestampRange;
    case: "timestampRangeFilter";
  } | {
    /**
     * Matches only cells with values that satisfy the given regular expression.
     * Note that, since cell values can contain arbitrary bytes, the `\C` escape
     * sequence must be used if a true wildcard is desired. The `.` character
     * will not match the new line character `\n`, which may be present in a
     * binary value.
     *
     * @generated from field: bytes value_regex_filter = 9;
     */
    value: Uint8Array;
    case: "valueRegexFilter";
  } | {
    /**
     * Matches only cells with values that fall within the given range.
     *
     * @generated from field: google.bigtable.v2.ValueRange value_range_filter = 15;
     */
    value: ValueRange;
    case: "valueRangeFilter";
  } | {
    /**
     * Skips the first N cells of each row, matching all subsequent cells.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_row_offset_filter = 10;
     */
    value: number;
    case: "cellsPerRowOffsetFilter";
  } | {
    /**
     * Matches only the first N cells of each row.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_row_limit_filter = 11;
     */
    value: number;
    case: "cellsPerRowLimitFilter";
  } | {
    /**
     * Matches only the most recent N cells within each column. For example,
     * if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
     * skip all earlier cells in `foo:bar`, and then begin matching again in
     * column `foo:bar2`.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_column_limit_filter = 12;
     */
    value: number;
    case: "cellsPerColumnLimitFilter";
  } | {
    /**
     * Replaces each cell's value with the empty string.
     *
     * @generated from field: bool strip_value_transformer = 13;
     */
    value: boolean;
    case: "stripValueTransformer";
  } | {
    /**
     * Applies the given label to all cells in the output row. This allows
     * the client to determine which results were produced from which part of
     * the filter.
     *
     * Values must be at most 15 characters in length, and match the RE2
     * pattern `[a-z0-9\\-]+`
     *
     * Due to a technical limitation, it is not currently possible to apply
     * multiple labels to a cell. As a result, a Chain may have no more than
     * one sub-filter which contains a `apply_label_transformer`. It is okay for
     * an Interleave to contain multiple `apply_label_transformers`, as they
     * will be applied to separate copies of the input. This may be relaxed in
     * the future.
     *
     * @generated from field: string apply_label_transformer = 19;
     */
    value: string;
    case: "applyLabelTransformer";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.RowFilter.
 * Use `create(RowFilterSchema)` to create a new message.
 */
export const RowFilterSchema: GenMessage<RowFilter> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 11);

/**
 * A RowFilter which sends rows through several RowFilters in sequence.
 *
 * @generated from message google.bigtable.v2.RowFilter.Chain
 */
export type RowFilter_Chain = Message<"google.bigtable.v2.RowFilter.Chain"> & {
  /**
   * The elements of "filters" are chained together to process the input row:
   * in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
   * The full chain is executed atomically.
   *
   * @generated from field: repeated google.bigtable.v2.RowFilter filters = 1;
   */
  filters: RowFilter[];
};

/**
 * Describes the message google.bigtable.v2.RowFilter.Chain.
 * Use `create(RowFilter_ChainSchema)` to create a new message.
 */
export const RowFilter_ChainSchema: GenMessage<RowFilter_Chain> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 11, 0);

/**
 * A RowFilter which sends each row to each of several component
 * RowFilters and interleaves the results.
 *
 * @generated from message google.bigtable.v2.RowFilter.Interleave
 */
export type RowFilter_Interleave = Message<"google.bigtable.v2.RowFilter.Interleave"> & {
  /**
   * The elements of "filters" all process a copy of the input row, and the
   * results are pooled, sorted, and combined into a single output row.
   * If multiple cells are produced with the same column and timestamp,
   * they will all appear in the output row in an unspecified mutual order.
   * Consider the following example, with three filters:
   *
   *                                  input row
   *                                      |
   *            -----------------------------------------------------
   *            |                         |                         |
   *           f(0)                      f(1)                      f(2)
   *            |                         |                         |
   *     1: foo,bar,10,x             foo,bar,10,z              far,bar,7,a
   *     2: foo,blah,11,z            far,blah,5,x              far,blah,5,x
   *            |                         |                         |
   *            -----------------------------------------------------
   *                                      |
   *     1:                      foo,bar,10,z   // could have switched with #2
   *     2:                      foo,bar,10,x   // could have switched with #1
   *     3:                      foo,blah,11,z
   *     4:                      far,bar,7,a
   *     5:                      far,blah,5,x   // identical to #6
   *     6:                      far,blah,5,x   // identical to #5
   *
   * All interleaved filters are executed atomically.
   *
   * @generated from field: repeated google.bigtable.v2.RowFilter filters = 1;
   */
  filters: RowFilter[];
};

/**
 * Describes the message google.bigtable.v2.RowFilter.Interleave.
 * Use `create(RowFilter_InterleaveSchema)` to create a new message.
 */
export const RowFilter_InterleaveSchema: GenMessage<RowFilter_Interleave> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 11, 1);

/**
 * A RowFilter which evaluates one of two possible RowFilters, depending on
 * whether or not a predicate RowFilter outputs any cells from the input row.
 *
 * IMPORTANT NOTE: The predicate filter does not execute atomically with the
 * true and false filters, which may lead to inconsistent or unexpected
 * results. Additionally, Condition filters have poor performance, especially
 * when filters are set for the false condition.
 *
 * @generated from message google.bigtable.v2.RowFilter.Condition
 */
export type RowFilter_Condition = Message<"google.bigtable.v2.RowFilter.Condition"> & {
  /**
   * If `predicate_filter` outputs any cells, then `true_filter` will be
   * evaluated on the input row. Otherwise, `false_filter` will be evaluated.
   *
   * @generated from field: google.bigtable.v2.RowFilter predicate_filter = 1;
   */
  predicateFilter?: RowFilter;

  /**
   * The filter to apply to the input row if `predicate_filter` returns any
   * results. If not provided, no results will be returned in the true case.
   *
   * @generated from field: google.bigtable.v2.RowFilter true_filter = 2;
   */
  trueFilter?: RowFilter;

  /**
   * The filter to apply to the input row if `predicate_filter` does not
   * return any results. If not provided, no results will be returned in the
   * false case.
   *
   * @generated from field: google.bigtable.v2.RowFilter false_filter = 3;
   */
  falseFilter?: RowFilter;
};

/**
 * Describes the message google.bigtable.v2.RowFilter.Condition.
 * Use `create(RowFilter_ConditionSchema)` to create a new message.
 */
export const RowFilter_ConditionSchema: GenMessage<RowFilter_Condition> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 11, 2);

/**
 * Specifies a particular change to be made to the contents of a row.
 *
 * @generated from message google.bigtable.v2.Mutation
 */
export type Mutation = Message<"google.bigtable.v2.Mutation"> & {
  /**
   * Which of the possible Mutation types to apply.
   *
   * @generated from oneof google.bigtable.v2.Mutation.mutation
   */
  mutation: {
    /**
     * Set a cell's value.
     *
     * @generated from field: google.bigtable.v2.Mutation.SetCell set_cell = 1;
     */
    value: Mutation_SetCell;
    case: "setCell";
  } | {
    /**
     * Incrementally updates an `Aggregate` cell.
     *
     * @generated from field: google.bigtable.v2.Mutation.AddToCell add_to_cell = 5;
     */
    value: Mutation_AddToCell;
    case: "addToCell";
  } | {
    /**
     * Merges accumulated state to an `Aggregate` cell.
     *
     * @generated from field: google.bigtable.v2.Mutation.MergeToCell merge_to_cell = 6;
     */
    value: Mutation_MergeToCell;
    case: "mergeToCell";
  } | {
    /**
     * Deletes cells from a column.
     *
     * @generated from field: google.bigtable.v2.Mutation.DeleteFromColumn delete_from_column = 2;
     */
    value: Mutation_DeleteFromColumn;
    case: "deleteFromColumn";
  } | {
    /**
     * Deletes cells from a column family.
     *
     * @generated from field: google.bigtable.v2.Mutation.DeleteFromFamily delete_from_family = 3;
     */
    value: Mutation_DeleteFromFamily;
    case: "deleteFromFamily";
  } | {
    /**
     * Deletes cells from the entire row.
     *
     * @generated from field: google.bigtable.v2.Mutation.DeleteFromRow delete_from_row = 4;
     */
    value: Mutation_DeleteFromRow;
    case: "deleteFromRow";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.Mutation.
 * Use `create(MutationSchema)` to create a new message.
 */
export const MutationSchema: GenMessage<Mutation> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12);

/**
 * A Mutation which sets the value of the specified cell.
 *
 * @generated from message google.bigtable.v2.Mutation.SetCell
 */
export type Mutation_SetCell = Message<"google.bigtable.v2.Mutation.SetCell"> & {
  /**
   * The name of the family into which new data should be written.
   * Must match `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The qualifier of the column into which new data should be written.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier: Uint8Array;

  /**
   * The timestamp of the cell into which new data should be written.
   * Use -1 for current Bigtable server time.
   * Otherwise, the client should set this value itself, noting that the
   * default value is a timestamp of zero if the field is left unspecified.
   * Values must match the granularity of the table (e.g. micros, millis).
   *
   * @generated from field: int64 timestamp_micros = 3;
   */
  timestampMicros: bigint;

  /**
   * The value to be written into the specified cell.
   *
   * @generated from field: bytes value = 4;
   */
  value: Uint8Array;
};

/**
 * Describes the message google.bigtable.v2.Mutation.SetCell.
 * Use `create(Mutation_SetCellSchema)` to create a new message.
 */
export const Mutation_SetCellSchema: GenMessage<Mutation_SetCell> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 0);

/**
 * A Mutation which incrementally updates a cell in an `Aggregate` family.
 *
 * @generated from message google.bigtable.v2.Mutation.AddToCell
 */
export type Mutation_AddToCell = Message<"google.bigtable.v2.Mutation.AddToCell"> & {
  /**
   * The name of the `Aggregate` family into which new data should be added.
   * This must be a family with a `value_type` of `Aggregate`.
   * Format: `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The qualifier of the column into which new data should be added. This
   * must be a `raw_value`.
   *
   * @generated from field: google.bigtable.v2.Value column_qualifier = 2;
   */
  columnQualifier?: Value;

  /**
   * The timestamp of the cell to which new data should be added. This must
   * be a `raw_timestamp_micros` that matches the table's `granularity`.
   *
   * @generated from field: google.bigtable.v2.Value timestamp = 3;
   */
  timestamp?: Value;

  /**
   * The input value to be accumulated into the specified cell. This must be
   * compatible with the family's `value_type.input_type`.
   *
   * @generated from field: google.bigtable.v2.Value input = 4;
   */
  input?: Value;
};

/**
 * Describes the message google.bigtable.v2.Mutation.AddToCell.
 * Use `create(Mutation_AddToCellSchema)` to create a new message.
 */
export const Mutation_AddToCellSchema: GenMessage<Mutation_AddToCell> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 1);

/**
 * A Mutation which merges accumulated state into a cell in an `Aggregate`
 * family.
 *
 * @generated from message google.bigtable.v2.Mutation.MergeToCell
 */
export type Mutation_MergeToCell = Message<"google.bigtable.v2.Mutation.MergeToCell"> & {
  /**
   * The name of the `Aggregate` family into which new data should be added.
   * This must be a family with a `value_type` of `Aggregate`.
   * Format: `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The qualifier of the column into which new data should be added. This
   * must be a `raw_value`.
   *
   * @generated from field: google.bigtable.v2.Value column_qualifier = 2;
   */
  columnQualifier?: Value;

  /**
   * The timestamp of the cell to which new data should be added. This must
   * be a `raw_timestamp_micros` that matches the table's `granularity`.
   *
   * @generated from field: google.bigtable.v2.Value timestamp = 3;
   */
  timestamp?: Value;

  /**
   * The input value to be merged into the specified cell. This must be
   * compatible with the family's `value_type.state_type`. Merging `NULL` is
   * allowed, but has no effect.
   *
   * @generated from field: google.bigtable.v2.Value input = 4;
   */
  input?: Value;
};

/**
 * Describes the message google.bigtable.v2.Mutation.MergeToCell.
 * Use `create(Mutation_MergeToCellSchema)` to create a new message.
 */
export const Mutation_MergeToCellSchema: GenMessage<Mutation_MergeToCell> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 2);

/**
 * A Mutation which deletes cells from the specified column, optionally
 * restricting the deletions to a given timestamp range.
 *
 * @generated from message google.bigtable.v2.Mutation.DeleteFromColumn
 */
export type Mutation_DeleteFromColumn = Message<"google.bigtable.v2.Mutation.DeleteFromColumn"> & {
  /**
   * The name of the family from which cells should be deleted.
   * Must match `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The qualifier of the column from which cells should be deleted.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier: Uint8Array;

  /**
   * The range of timestamps within which cells should be deleted.
   *
   * @generated from field: google.bigtable.v2.TimestampRange time_range = 3;
   */
  timeRange?: TimestampRange;
};

/**
 * Describes the message google.bigtable.v2.Mutation.DeleteFromColumn.
 * Use `create(Mutation_DeleteFromColumnSchema)` to create a new message.
 */
export const Mutation_DeleteFromColumnSchema: GenMessage<Mutation_DeleteFromColumn> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 3);

/**
 * A Mutation which deletes all cells from the specified column family.
 *
 * @generated from message google.bigtable.v2.Mutation.DeleteFromFamily
 */
export type Mutation_DeleteFromFamily = Message<"google.bigtable.v2.Mutation.DeleteFromFamily"> & {
  /**
   * The name of the family from which cells should be deleted.
   * Must match `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;
};

/**
 * Describes the message google.bigtable.v2.Mutation.DeleteFromFamily.
 * Use `create(Mutation_DeleteFromFamilySchema)` to create a new message.
 */
export const Mutation_DeleteFromFamilySchema: GenMessage<Mutation_DeleteFromFamily> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 4);

/**
 * A Mutation which deletes all cells from the containing row.
 *
 * @generated from message google.bigtable.v2.Mutation.DeleteFromRow
 */
export type Mutation_DeleteFromRow = Message<"google.bigtable.v2.Mutation.DeleteFromRow"> & {
};

/**
 * Describes the message google.bigtable.v2.Mutation.DeleteFromRow.
 * Use `create(Mutation_DeleteFromRowSchema)` to create a new message.
 */
export const Mutation_DeleteFromRowSchema: GenMessage<Mutation_DeleteFromRow> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 12, 5);

/**
 * Specifies an atomic read/modify/write operation on the latest value of the
 * specified column.
 *
 * @generated from message google.bigtable.v2.ReadModifyWriteRule
 */
export type ReadModifyWriteRule = Message<"google.bigtable.v2.ReadModifyWriteRule"> & {
  /**
   * The name of the family to which the read/modify/write should be applied.
   * Must match `[-_.a-zA-Z0-9]+`
   *
   * @generated from field: string family_name = 1;
   */
  familyName: string;

  /**
   * The qualifier of the column to which the read/modify/write should be
   * applied.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier: Uint8Array;

  /**
   * The rule used to determine the column's new latest value from its current
   * latest value.
   *
   * @generated from oneof google.bigtable.v2.ReadModifyWriteRule.rule
   */
  rule: {
    /**
     * Rule specifying that `append_value` be appended to the existing value.
     * If the targeted cell is unset, it will be treated as containing the
     * empty string.
     *
     * @generated from field: bytes append_value = 3;
     */
    value: Uint8Array;
    case: "appendValue";
  } | {
    /**
     * Rule specifying that `increment_amount` be added to the existing value.
     * If the targeted cell is unset, it will be treated as containing a zero.
     * Otherwise, the targeted cell must contain an 8-byte value (interpreted
     * as a 64-bit big-endian signed integer), or the entire request will fail.
     *
     * @generated from field: int64 increment_amount = 4;
     */
    value: bigint;
    case: "incrementAmount";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ReadModifyWriteRule.
 * Use `create(ReadModifyWriteRuleSchema)` to create a new message.
 */
export const ReadModifyWriteRuleSchema: GenMessage<ReadModifyWriteRule> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 13);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * A partition of a change stream.
 *
 * @generated from message google.bigtable.v2.StreamPartition
 */
export type StreamPartition = Message<"google.bigtable.v2.StreamPartition"> & {
  /**
   * The row range covered by this partition and is specified by
   * [`start_key_closed`, `end_key_open`).
   *
   * @generated from field: google.bigtable.v2.RowRange row_range = 1;
   */
  rowRange?: RowRange;
};

/**
 * Describes the message google.bigtable.v2.StreamPartition.
 * Use `create(StreamPartitionSchema)` to create a new message.
 */
export const StreamPartitionSchema: GenMessage<StreamPartition> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 14);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * The information required to continue reading the data from multiple
 * `StreamPartitions` from where a previous read left off.
 *
 * @generated from message google.bigtable.v2.StreamContinuationTokens
 */
export type StreamContinuationTokens = Message<"google.bigtable.v2.StreamContinuationTokens"> & {
  /**
   * List of continuation tokens.
   *
   * @generated from field: repeated google.bigtable.v2.StreamContinuationToken tokens = 1;
   */
  tokens: StreamContinuationToken[];
};

/**
 * Describes the message google.bigtable.v2.StreamContinuationTokens.
 * Use `create(StreamContinuationTokensSchema)` to create a new message.
 */
export const StreamContinuationTokensSchema: GenMessage<StreamContinuationTokens> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 15);

/**
 * NOTE: This API is intended to be used by Apache Beam BigtableIO.
 * The information required to continue reading the data from a
 * `StreamPartition` from where a previous read left off.
 *
 * @generated from message google.bigtable.v2.StreamContinuationToken
 */
export type StreamContinuationToken = Message<"google.bigtable.v2.StreamContinuationToken"> & {
  /**
   * The partition that this token applies to.
   *
   * @generated from field: google.bigtable.v2.StreamPartition partition = 1;
   */
  partition?: StreamPartition;

  /**
   * An encoded position in the stream to restart reading from.
   *
   * @generated from field: string token = 2;
   */
  token: string;
};

/**
 * Describes the message google.bigtable.v2.StreamContinuationToken.
 * Use `create(StreamContinuationTokenSchema)` to create a new message.
 */
export const StreamContinuationTokenSchema: GenMessage<StreamContinuationToken> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 16);

/**
 * Protocol buffers format descriptor, as described by Messages ProtoSchema and
 * ProtoRows
 *
 * @generated from message google.bigtable.v2.ProtoFormat
 */
export type ProtoFormat = Message<"google.bigtable.v2.ProtoFormat"> & {
};

/**
 * Describes the message google.bigtable.v2.ProtoFormat.
 * Use `create(ProtoFormatSchema)` to create a new message.
 */
export const ProtoFormatSchema: GenMessage<ProtoFormat> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 17);

/**
 * Describes a column in a Bigtable Query Language result set.
 *
 * @generated from message google.bigtable.v2.ColumnMetadata
 */
export type ColumnMetadata = Message<"google.bigtable.v2.ColumnMetadata"> & {
  /**
   * The name of the column.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The type of the column.
   *
   * @generated from field: google.bigtable.v2.Type type = 2;
   */
  type?: Type;
};

/**
 * Describes the message google.bigtable.v2.ColumnMetadata.
 * Use `create(ColumnMetadataSchema)` to create a new message.
 */
export const ColumnMetadataSchema: GenMessage<ColumnMetadata> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 18);

/**
 * ResultSet schema in proto format
 *
 * @generated from message google.bigtable.v2.ProtoSchema
 */
export type ProtoSchema = Message<"google.bigtable.v2.ProtoSchema"> & {
  /**
   * The columns in the result set.
   *
   * @generated from field: repeated google.bigtable.v2.ColumnMetadata columns = 1;
   */
  columns: ColumnMetadata[];
};

/**
 * Describes the message google.bigtable.v2.ProtoSchema.
 * Use `create(ProtoSchemaSchema)` to create a new message.
 */
export const ProtoSchemaSchema: GenMessage<ProtoSchema> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 19);

/**
 * Describes the structure of a Bigtable result set.
 *
 * @generated from message google.bigtable.v2.ResultSetMetadata
 */
export type ResultSetMetadata = Message<"google.bigtable.v2.ResultSetMetadata"> & {
  /**
   * The schema of the ResultSet, contains ordered list of column names
   * with types
   *
   * @generated from oneof google.bigtable.v2.ResultSetMetadata.schema
   */
  schema: {
    /**
     * Schema in proto format
     *
     * @generated from field: google.bigtable.v2.ProtoSchema proto_schema = 1;
     */
    value: ProtoSchema;
    case: "protoSchema";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.bigtable.v2.ResultSetMetadata.
 * Use `create(ResultSetMetadataSchema)` to create a new message.
 */
export const ResultSetMetadataSchema: GenMessage<ResultSetMetadata> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 20);

/**
 * Rows represented in proto format.
 *
 * This should be constructed by concatenating the `batch_data` from each
 * of the relevant `ProtoRowsBatch` messages and parsing the result as a
 * `ProtoRows` message.
 *
 * @generated from message google.bigtable.v2.ProtoRows
 */
export type ProtoRows = Message<"google.bigtable.v2.ProtoRows"> & {
  /**
   * A proto rows message consists of a list of values. Every N complete values
   * defines a row, where N is equal to the  number of entries in the
   * `metadata.proto_schema.columns` value received in the first response.
   *
   * @generated from field: repeated google.bigtable.v2.Value values = 2;
   */
  values: Value[];
};

/**
 * Describes the message google.bigtable.v2.ProtoRows.
 * Use `create(ProtoRowsSchema)` to create a new message.
 */
export const ProtoRowsSchema: GenMessage<ProtoRows> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 21);

/**
 * Batch of serialized ProtoRows.
 *
 * @generated from message google.bigtable.v2.ProtoRowsBatch
 */
export type ProtoRowsBatch = Message<"google.bigtable.v2.ProtoRowsBatch"> & {
  /**
   * Merge partial results by concatenating these bytes, then parsing the
   * overall value as a `ProtoRows` message.
   *
   * @generated from field: bytes batch_data = 1;
   */
  batchData: Uint8Array;
};

/**
 * Describes the message google.bigtable.v2.ProtoRowsBatch.
 * Use `create(ProtoRowsBatchSchema)` to create a new message.
 */
export const ProtoRowsBatchSchema: GenMessage<ProtoRowsBatch> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 22);

/**
 * A partial result set from the streaming query API.
 * CBT client will buffer partial_rows from result_sets until it gets a
 * resumption_token.
 *
 * @generated from message google.bigtable.v2.PartialResultSet
 */
export type PartialResultSet = Message<"google.bigtable.v2.PartialResultSet"> & {
  /**
   * Partial Rows in one of the supported formats. It may require many
   * PartialResultSets to stream a batch of rows that can decoded on the client.
   * The client should buffer partial_rows until it gets a `resume_token`,
   * at which point the batch is complete and can be decoded and yielded to the
   * user. Each sub-message documents the appropriate way to combine results.
   *
   * @generated from oneof google.bigtable.v2.PartialResultSet.partial_rows
   */
  partialRows: {
    /**
     * Partial rows in serialized ProtoRows format.
     *
     * @generated from field: google.bigtable.v2.ProtoRowsBatch proto_rows_batch = 3;
     */
    value: ProtoRowsBatch;
    case: "protoRowsBatch";
  } | { case: undefined; value?: undefined };

  /**
   * An opaque token sent by the server to allow query resumption and signal
   * the client to accumulate `partial_rows` since the last non-empty
   * `resume_token`. On resumption, the resumed query will return the remaining
   * rows for this query.
   *
   * If there is a batch in progress, a non-empty `resume_token`
   * means that that the batch of `partial_rows` will be complete after merging
   * the `partial_rows` from this response. The client must only yield
   * completed batches to the application, and must ensure that any future
   * retries send the latest token to avoid returning duplicate data.
   *
   * The server may set 'resume_token' without a 'partial_rows'. If there is a
   * batch in progress the client should yield it.
   *
   * The server will also send a sentinel `resume_token` when last batch of
   * `partial_rows` is sent. If the client retries the ExecuteQueryRequest with
   * the sentinel `resume_token`, the server will emit it again without any
   * `partial_rows`, then return OK.
   *
   * @generated from field: bytes resume_token = 5;
   */
  resumeToken: Uint8Array;

  /**
   * Estimated size of a new batch. The server will always set this when
   * returning the first `partial_rows` of a batch, and will not set it at any
   * other time.
   *
   * The client can use this estimate to allocate an initial buffer for the
   * batched results. This helps minimize the number of allocations required,
   * though the buffer size may still need to be increased if the estimate is
   * too low.
   *
   * @generated from field: int32 estimated_batch_size = 4;
   */
  estimatedBatchSize: number;
};

/**
 * Describes the message google.bigtable.v2.PartialResultSet.
 * Use `create(PartialResultSetSchema)` to create a new message.
 */
export const PartialResultSetSchema: GenMessage<PartialResultSet> = /*@__PURE__*/
  messageDesc(file_google_bigtable_v2_data, 23);

