// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/firestore/v1/firestore.proto (package google.firestore.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import type { AggregationResult } from "./aggregation_result_pb";
import { file_google_firestore_v1_aggregation_result } from "./aggregation_result_pb";
import type { DocumentMask, Precondition, TransactionOptions } from "./common_pb";
import { file_google_firestore_v1_common } from "./common_pb";
import type { Document, DocumentSchema } from "./document_pb";
import { file_google_firestore_v1_document } from "./document_pb";
import type { Cursor, StructuredAggregationQuery, StructuredQuery } from "./query_pb";
import { file_google_firestore_v1_query } from "./query_pb";
import type { ExplainMetrics, ExplainOptions } from "./query_profile_pb";
import { file_google_firestore_v1_query_profile } from "./query_profile_pb";
import type { DocumentChange, DocumentDelete, DocumentRemove, ExistenceFilter, Write, WriteResult } from "./write_pb";
import { file_google_firestore_v1_write } from "./write_pb";
import type { EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/firestore/v1/firestore.proto.
 */
export const file_google_firestore_v1_firestore: GenFile = /*@__PURE__*/
  fileDesc("CiNnb29nbGUvZmlyZXN0b3JlL3YxL2ZpcmVzdG9yZS5wcm90bxITZ29vZ2xlLmZpcmVzdG9yZS52MSK4AQoSR2V0RG9jdW1lbnRSZXF1ZXN0EhEKBG5hbWUYASABKAlCA+BBAhIvCgRtYXNrGAIgASgLMiEuZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudE1hc2sSFQoLdHJhbnNhY3Rpb24YAyABKAxIABIvCglyZWFkX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSABCFgoUY29uc2lzdGVuY3lfc2VsZWN0b3IiuwIKFExpc3REb2N1bWVudHNSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECEhoKDWNvbGxlY3Rpb25faWQYAiABKAlCA+BBARIWCglwYWdlX3NpemUYAyABKAVCA+BBARIXCgpwYWdlX3Rva2VuGAQgASgJQgPgQQESFQoIb3JkZXJfYnkYBiABKAlCA+BBARI0CgRtYXNrGAcgASgLMiEuZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudE1hc2tCA+BBARIVCgt0cmFuc2FjdGlvbhgIIAEoDEgAEi8KCXJlYWRfdGltZRgKIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIABIUCgxzaG93X21pc3NpbmcYDCABKAhCFgoUY29uc2lzdGVuY3lfc2VsZWN0b3IiYgoVTGlzdERvY3VtZW50c1Jlc3BvbnNlEjAKCWRvY3VtZW50cxgBIAMoCzIdLmdvb2dsZS5maXJlc3RvcmUudjEuRG9jdW1lbnQSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIsQBChVDcmVhdGVEb2N1bWVudFJlcXVlc3QSEwoGcGFyZW50GAEgASgJQgPgQQISGgoNY29sbGVjdGlvbl9pZBgCIAEoCUID4EECEhMKC2RvY3VtZW50X2lkGAMgASgJEjQKCGRvY3VtZW50GAQgASgLMh0uZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudEID4EECEi8KBG1hc2sYBSABKAsyIS5nb29nbGUuZmlyZXN0b3JlLnYxLkRvY3VtZW50TWFzayLzAQoVVXBkYXRlRG9jdW1lbnRSZXF1ZXN0EjQKCGRvY3VtZW50GAEgASgLMh0uZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudEID4EECEjYKC3VwZGF0ZV9tYXNrGAIgASgLMiEuZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudE1hc2sSLwoEbWFzaxgDIAEoCzIhLmdvb2dsZS5maXJlc3RvcmUudjEuRG9jdW1lbnRNYXNrEjsKEGN1cnJlbnRfZG9jdW1lbnQYBCABKAsyIS5nb29nbGUuZmlyZXN0b3JlLnYxLlByZWNvbmRpdGlvbiJnChVEZWxldGVEb2N1bWVudFJlcXVlc3QSEQoEbmFtZRgBIAEoCUID4EECEjsKEGN1cnJlbnRfZG9jdW1lbnQYAiABKAsyIS5nb29nbGUuZmlyZXN0b3JlLnYxLlByZWNvbmRpdGlvbiKZAgoYQmF0Y2hHZXREb2N1bWVudHNSZXF1ZXN0EhUKCGRhdGFiYXNlGAEgASgJQgPgQQISEQoJZG9jdW1lbnRzGAIgAygJEi8KBG1hc2sYAyABKAsyIS5nb29nbGUuZmlyZXN0b3JlLnYxLkRvY3VtZW50TWFzaxIVCgt0cmFuc2FjdGlvbhgEIAEoDEgAEkIKD25ld190cmFuc2FjdGlvbhgFIAEoCzInLmdvb2dsZS5maXJlc3RvcmUudjEuVHJhbnNhY3Rpb25PcHRpb25zSAASLwoJcmVhZF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAQhYKFGNvbnNpc3RlbmN5X3NlbGVjdG9yIqwBChlCYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlEi4KBWZvdW5kGAEgASgLMh0uZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudEgAEhEKB21pc3NpbmcYAiABKAlIABITCgt0cmFuc2FjdGlvbhgDIAEoDBItCglyZWFkX3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQggKBnJlc3VsdCJqChdCZWdpblRyYW5zYWN0aW9uUmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEjgKB29wdGlvbnMYAiABKAsyJy5nb29nbGUuZmlyZXN0b3JlLnYxLlRyYW5zYWN0aW9uT3B0aW9ucyIvChhCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2USEwoLdHJhbnNhY3Rpb24YASABKAwiZwoNQ29tbWl0UmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEioKBndyaXRlcxgCIAMoCzIaLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGUSEwoLdHJhbnNhY3Rpb24YAyABKAwiegoOQ29tbWl0UmVzcG9uc2USNwoNd3JpdGVfcmVzdWx0cxgBIAMoCzIgLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGVSZXN1bHQSLwoLY29tbWl0X3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIkIKD1JvbGxiYWNrUmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEhgKC3RyYW5zYWN0aW9uGAIgASgMQgPgQQIi3QIKD1J1blF1ZXJ5UmVxdWVzdBITCgZwYXJlbnQYASABKAlCA+BBAhJAChBzdHJ1Y3R1cmVkX3F1ZXJ5GAIgASgLMiQuZ29vZ2xlLmZpcmVzdG9yZS52MS5TdHJ1Y3R1cmVkUXVlcnlIABIVCgt0cmFuc2FjdGlvbhgFIAEoDEgBEkIKD25ld190cmFuc2FjdGlvbhgGIAEoCzInLmdvb2dsZS5maXJlc3RvcmUudjEuVHJhbnNhY3Rpb25PcHRpb25zSAESLwoJcmVhZF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgBEkEKD2V4cGxhaW5fb3B0aW9ucxgKIAEoCzIjLmdvb2dsZS5maXJlc3RvcmUudjEuRXhwbGFpbk9wdGlvbnNCA+BBAUIMCgpxdWVyeV90eXBlQhYKFGNvbnNpc3RlbmN5X3NlbGVjdG9yIocCChBSdW5RdWVyeVJlc3BvbnNlEhMKC3RyYW5zYWN0aW9uGAIgASgMEi8KCGRvY3VtZW50GAEgASgLMh0uZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudBItCglyZWFkX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhcKD3NraXBwZWRfcmVzdWx0cxgEIAEoBRIOCgRkb25lGAYgASgISAASPAoPZXhwbGFpbl9tZXRyaWNzGAsgASgLMiMuZ29vZ2xlLmZpcmVzdG9yZS52MS5FeHBsYWluTWV0cmljc0IXChVjb250aW51YXRpb25fc2VsZWN0b3Ii/wIKGlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECElcKHHN0cnVjdHVyZWRfYWdncmVnYXRpb25fcXVlcnkYAiABKAsyLy5nb29nbGUuZmlyZXN0b3JlLnYxLlN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5SAASFQoLdHJhbnNhY3Rpb24YBCABKAxIARJCCg9uZXdfdHJhbnNhY3Rpb24YBSABKAsyJy5nb29nbGUuZmlyZXN0b3JlLnYxLlRyYW5zYWN0aW9uT3B0aW9uc0gBEi8KCXJlYWRfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIARJBCg9leHBsYWluX29wdGlvbnMYCCABKAsyIy5nb29nbGUuZmlyZXN0b3JlLnYxLkV4cGxhaW5PcHRpb25zQgPgQQFCDAoKcXVlcnlfdHlwZUIWChRjb25zaXN0ZW5jeV9zZWxlY3RvciLXAQobUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlEjYKBnJlc3VsdBgBIAEoCzImLmdvb2dsZS5maXJlc3RvcmUudjEuQWdncmVnYXRpb25SZXN1bHQSEwoLdHJhbnNhY3Rpb24YAiABKAwSLQoJcmVhZF90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI8Cg9leHBsYWluX21ldHJpY3MYCiABKAsyIy5nb29nbGUuZmlyZXN0b3JlLnYxLkV4cGxhaW5NZXRyaWNzIoUCChVQYXJ0aXRpb25RdWVyeVJlcXVlc3QSEwoGcGFyZW50GAEgASgJQgPgQQISQAoQc3RydWN0dXJlZF9xdWVyeRgCIAEoCzIkLmdvb2dsZS5maXJlc3RvcmUudjEuU3RydWN0dXJlZFF1ZXJ5SAASFwoPcGFydGl0aW9uX2NvdW50GAMgASgDEhIKCnBhZ2VfdG9rZW4YBCABKAkSEQoJcGFnZV9zaXplGAUgASgFEi8KCXJlYWRfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIAUIMCgpxdWVyeV90eXBlQhYKFGNvbnNpc3RlbmN5X3NlbGVjdG9yImIKFlBhcnRpdGlvblF1ZXJ5UmVzcG9uc2USLwoKcGFydGl0aW9ucxgBIAMoCzIbLmdvb2dsZS5maXJlc3RvcmUudjEuQ3Vyc29yEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSLoAQoMV3JpdGVSZXF1ZXN0EhUKCGRhdGFiYXNlGAEgASgJQgPgQQISEQoJc3RyZWFtX2lkGAIgASgJEioKBndyaXRlcxgDIAMoCzIaLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGUSFAoMc3RyZWFtX3Rva2VuGAQgASgMEj0KBmxhYmVscxgFIAMoCzItLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGVSZXF1ZXN0LkxhYmVsc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiogEKDVdyaXRlUmVzcG9uc2USEQoJc3RyZWFtX2lkGAEgASgJEhQKDHN0cmVhbV90b2tlbhgCIAEoDBI3Cg13cml0ZV9yZXN1bHRzGAMgAygLMiAuZ29vZ2xlLmZpcmVzdG9yZS52MS5Xcml0ZVJlc3VsdBIvCgtjb21taXRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi8gEKDUxpc3RlblJlcXVlc3QSFQoIZGF0YWJhc2UYASABKAlCA+BBAhIxCgphZGRfdGFyZ2V0GAIgASgLMhsuZ29vZ2xlLmZpcmVzdG9yZS52MS5UYXJnZXRIABIXCg1yZW1vdmVfdGFyZ2V0GAMgASgFSAASPgoGbGFiZWxzGAQgAygLMi4uZ29vZ2xlLmZpcmVzdG9yZS52MS5MaXN0ZW5SZXF1ZXN0LkxhYmVsc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFCDwoNdGFyZ2V0X2NoYW5nZSLVAgoOTGlzdGVuUmVzcG9uc2USOgoNdGFyZ2V0X2NoYW5nZRgCIAEoCzIhLmdvb2dsZS5maXJlc3RvcmUudjEuVGFyZ2V0Q2hhbmdlSAASPgoPZG9jdW1lbnRfY2hhbmdlGAMgASgLMiMuZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudENoYW5nZUgAEj4KD2RvY3VtZW50X2RlbGV0ZRgEIAEoCzIjLmdvb2dsZS5maXJlc3RvcmUudjEuRG9jdW1lbnREZWxldGVIABI+Cg9kb2N1bWVudF9yZW1vdmUYBiABKAsyIy5nb29nbGUuZmlyZXN0b3JlLnYxLkRvY3VtZW50UmVtb3ZlSAASNgoGZmlsdGVyGAUgASgLMiQuZ29vZ2xlLmZpcmVzdG9yZS52MS5FeGlzdGVuY2VGaWx0ZXJIAEIPCg1yZXNwb25zZV90eXBlItYDCgZUYXJnZXQSOAoFcXVlcnkYAiABKAsyJy5nb29nbGUuZmlyZXN0b3JlLnYxLlRhcmdldC5RdWVyeVRhcmdldEgAEkAKCWRvY3VtZW50cxgDIAEoCzIrLmdvb2dsZS5maXJlc3RvcmUudjEuVGFyZ2V0LkRvY3VtZW50c1RhcmdldEgAEhYKDHJlc3VtZV90b2tlbhgEIAEoDEgBEi8KCXJlYWRfdGltZRgLIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIARIRCgl0YXJnZXRfaWQYBSABKAUSDAoEb25jZRgGIAEoCBIzCg5leHBlY3RlZF9jb3VudBgMIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlGiQKD0RvY3VtZW50c1RhcmdldBIRCglkb2N1bWVudHMYAiADKAkabQoLUXVlcnlUYXJnZXQSDgoGcGFyZW50GAEgASgJEkAKEHN0cnVjdHVyZWRfcXVlcnkYAiABKAsyJC5nb29nbGUuZmlyZXN0b3JlLnYxLlN0cnVjdHVyZWRRdWVyeUgAQgwKCnF1ZXJ5X3R5cGVCDQoLdGFyZ2V0X3R5cGVCDQoLcmVzdW1lX3R5cGUiqgIKDFRhcmdldENoYW5nZRJOChJ0YXJnZXRfY2hhbmdlX3R5cGUYASABKA4yMi5nb29nbGUuZmlyZXN0b3JlLnYxLlRhcmdldENoYW5nZS5UYXJnZXRDaGFuZ2VUeXBlEhIKCnRhcmdldF9pZHMYAiADKAUSIQoFY2F1c2UYAyABKAsyEi5nb29nbGUucnBjLlN0YXR1cxIUCgxyZXN1bWVfdG9rZW4YBCABKAwSLQoJcmVhZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJOChBUYXJnZXRDaGFuZ2VUeXBlEg0KCU5PX0NIQU5HRRAAEgcKA0FERBABEgoKBlJFTU9WRRACEgsKB0NVUlJFTlQQAxIJCgVSRVNFVBAEIp8BChhMaXN0Q29sbGVjdGlvbklkc1JlcXVlc3QSEwoGcGFyZW50GAEgASgJQgPgQQISEQoJcGFnZV9zaXplGAIgASgFEhIKCnBhZ2VfdG9rZW4YAyABKAkSLwoJcmVhZF90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAQhYKFGNvbnNpc3RlbmN5X3NlbGVjdG9yIkwKGUxpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2USFgoOY29sbGVjdGlvbl9pZHMYASADKAkSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIskBChFCYXRjaFdyaXRlUmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEioKBndyaXRlcxgCIAMoCzIaLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGUSQgoGbGFiZWxzGAMgAygLMjIuZ29vZ2xlLmZpcmVzdG9yZS52MS5CYXRjaFdyaXRlUmVxdWVzdC5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBInEKEkJhdGNoV3JpdGVSZXNwb25zZRI3Cg13cml0ZV9yZXN1bHRzGAEgAygLMiAuZ29vZ2xlLmZpcmVzdG9yZS52MS5Xcml0ZVJlc3VsdBIiCgZzdGF0dXMYAiADKAsyEi5nb29nbGUucnBjLlN0YXR1czLaGQoJRmlyZXN0b3JlEo8BCgtHZXREb2N1bWVudBInLmdvb2dsZS5maXJlc3RvcmUudjEuR2V0RG9jdW1lbnRSZXF1ZXN0Gh0uZ29vZ2xlLmZpcmVzdG9yZS52MS5Eb2N1bWVudCI4gtPkkwIyEjAvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0S9QEKDUxpc3REb2N1bWVudHMSKS5nb29nbGUuZmlyZXN0b3JlLnYxLkxpc3REb2N1bWVudHNSZXF1ZXN0GiouZ29vZ2xlLmZpcmVzdG9yZS52MS5MaXN0RG9jdW1lbnRzUmVzcG9uc2UijAGC0+STAoUBWj8SPS92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfS97Y29sbGVjdGlvbl9pZH0SQi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9L3tjb2xsZWN0aW9uX2lkfRK/AQoOVXBkYXRlRG9jdW1lbnQSKi5nb29nbGUuZmlyZXN0b3JlLnYxLlVwZGF0ZURvY3VtZW50UmVxdWVzdBodLmdvb2dsZS5maXJlc3RvcmUudjEuRG9jdW1lbnQiYtpBFGRvY3VtZW50LHVwZGF0ZV9tYXNrgtPkkwJFOghkb2N1bWVudDI5L3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9EpUBCg5EZWxldGVEb2N1bWVudBIqLmdvb2dsZS5maXJlc3RvcmUudjEuRGVsZXRlRG9jdW1lbnRSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5Ij/aQQRuYW1lgtPkkwIyKjAvdjEve25hbWU9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0SuQEKEUJhdGNoR2V0RG9jdW1lbnRzEi0uZ29vZ2xlLmZpcmVzdG9yZS52MS5CYXRjaEdldERvY3VtZW50c1JlcXVlc3QaLi5nb29nbGUuZmlyZXN0b3JlLnYxLkJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2UiQ4LT5JMCPToBKiI4L3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXQwARLHAQoQQmVnaW5UcmFuc2FjdGlvbhIsLmdvb2dsZS5maXJlc3RvcmUudjEuQmVnaW5UcmFuc2FjdGlvblJlcXVlc3QaLS5nb29nbGUuZmlyZXN0b3JlLnYxLkJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZSJW2kEIZGF0YWJhc2WC0+STAkU6ASoiQC92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb24SpgEKBkNvbW1pdBIiLmdvb2dsZS5maXJlc3RvcmUudjEuQ29tbWl0UmVxdWVzdBojLmdvb2dsZS5maXJlc3RvcmUudjEuQ29tbWl0UmVzcG9uc2UiU9pBD2RhdGFiYXNlLHdyaXRlc4LT5JMCOzoBKiI2L3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6Y29tbWl0EqQBCghSb2xsYmFjaxIkLmdvb2dsZS5maXJlc3RvcmUudjEuUm9sbGJhY2tSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IlraQRRkYXRhYmFzZSx0cmFuc2FjdGlvboLT5JMCPToBKiI4L3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2sS3wEKCFJ1blF1ZXJ5EiQuZ29vZ2xlLmZpcmVzdG9yZS52MS5SdW5RdWVyeVJlcXVlc3QaJS5nb29nbGUuZmlyZXN0b3JlLnYxLlJ1blF1ZXJ5UmVzcG9uc2UigwGC0+STAn06ASpaQDoBKiI7L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnkiNi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpydW5RdWVyeTABEpcCChNSdW5BZ2dyZWdhdGlvblF1ZXJ5Ei8uZ29vZ2xlLmZpcmVzdG9yZS52MS5SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdBowLmdvb2dsZS5maXJlc3RvcmUudjEuUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlIpoBgtPkkwKTAToBKlpLOgEqIkYvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5BZ2dyZWdhdGlvblF1ZXJ5IkEvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeTABEvwBCg5QYXJ0aXRpb25RdWVyeRIqLmdvb2dsZS5maXJlc3RvcmUudjEuUGFydGl0aW9uUXVlcnlSZXF1ZXN0GisuZ29vZ2xlLmZpcmVzdG9yZS52MS5QYXJ0aXRpb25RdWVyeVJlc3BvbnNlIpABgtPkkwKJAToBKlpGOgEqIkEvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpwYXJ0aXRpb25RdWVyeSI8L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnBhcnRpdGlvblF1ZXJ5EpQBCgVXcml0ZRIhLmdvb2dsZS5maXJlc3RvcmUudjEuV3JpdGVSZXF1ZXN0GiIuZ29vZ2xlLmZpcmVzdG9yZS52MS5Xcml0ZVJlc3BvbnNlIkCC0+STAjo6ASoiNS92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlKAEwARKYAQoGTGlzdGVuEiIuZ29vZ2xlLmZpcmVzdG9yZS52MS5MaXN0ZW5SZXF1ZXN0GiMuZ29vZ2xlLmZpcmVzdG9yZS52MS5MaXN0ZW5SZXNwb25zZSJBgtPkkwI7OgEqIjYvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpsaXN0ZW4oATABEpQCChFMaXN0Q29sbGVjdGlvbklkcxItLmdvb2dsZS5maXJlc3RvcmUudjEuTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0Gi4uZ29vZ2xlLmZpcmVzdG9yZS52MS5MaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlIp8B2kEGcGFyZW50gtPkkwKPAToBKlpJOgEqIkQvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkcyI/L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzEqQBCgpCYXRjaFdyaXRlEiYuZ29vZ2xlLmZpcmVzdG9yZS52MS5CYXRjaFdyaXRlUmVxdWVzdBonLmdvb2dsZS5maXJlc3RvcmUudjEuQmF0Y2hXcml0ZVJlc3BvbnNlIkWC0+STAj86ASoiOi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoV3JpdGUSrwEKDkNyZWF0ZURvY3VtZW50EiouZ29vZ2xlLmZpcmVzdG9yZS52MS5DcmVhdGVEb2N1bWVudFJlcXVlc3QaHS5nb29nbGUuZmlyZXN0b3JlLnYxLkRvY3VtZW50IlKC0+STAkw6CGRvY3VtZW50IkAvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9GnbKQRhmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb23SQVhodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlQr8BChdjb20uZ29vZ2xlLmZpcmVzdG9yZS52MUIORmlyZXN0b3JlUHJvdG9QAVo7Y2xvdWQuZ29vZ2xlLmNvbS9nby9maXJlc3RvcmUvYXBpdjEvZmlyZXN0b3JlcGI7ZmlyZXN0b3JlcGKqAhlHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxygIZR29vZ2xlXENsb3VkXEZpcmVzdG9yZVxWMeoCHEdvb2dsZTo6Q2xvdWQ6OkZpcmVzdG9yZTo6VjFiBnByb3RvMw", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_firestore_v1_aggregation_result, file_google_firestore_v1_common, file_google_firestore_v1_document, file_google_firestore_v1_query, file_google_firestore_v1_query_profile, file_google_firestore_v1_write, file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_protobuf_wrappers, file_google_rpc_status]);

/**
 * The request for
 * [Firestore.GetDocument][google.firestore.v1.Firestore.GetDocument].
 *
 * @generated from message google.firestore.v1.GetDocumentRequest
 */
export type GetDocumentRequest = Message<"google.firestore.v1.GetDocumentRequest"> & {
  /**
   * Required. The resource name of the Document to get. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1.DocumentMask mask = 2;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.GetDocumentRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads the document in a transaction.
     *
     * @generated from field: bytes transaction = 3;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Reads the version of the document at the given time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 5;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.GetDocumentRequest.
 * Use `create(GetDocumentRequestSchema)` to create a new message.
 */
export const GetDocumentRequestSchema: GenMessage<GetDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 0);

/**
 * The request for
 * [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1.ListDocumentsRequest
 */
export type ListDocumentsRequest = Message<"google.firestore.v1.ListDocumentsRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. The collection ID, relative to `parent`, to list.
   *
   * For example: `chatrooms` or `messages`.
   *
   * This is optional, and when not provided, Firestore will list documents
   * from all collections under the provided `parent`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId: string;

  /**
   * Optional. The maximum number of documents to return in a single response.
   *
   * Firestore may return fewer than this value.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Optional. A page token, received from a previous `ListDocuments` response.
   *
   * Provide this to retrieve the subsequent page. When paginating, all other
   * parameters (with the exception of `page_size`) must match the values set
   * in the request that generated the page token.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * Optional. The optional ordering of the documents to return.
   *
   * For example: `priority desc, __name__ desc`.
   *
   * This mirrors the [`ORDER BY`][google.firestore.v1.StructuredQuery.order_by]
   * used in Firestore queries but in a string representation. When absent,
   * documents are ordered based on `__name__ ASC`.
   *
   * @generated from field: string order_by = 6;
   */
  orderBy: string;

  /**
   * Optional. The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1.DocumentMask mask = 7;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.ListDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Perform the read as part of an already active transaction.
     *
     * @generated from field: bytes transaction = 8;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Perform the read at the provided time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 10;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * If the list should show missing documents.
   *
   * A document is missing if it does not exist, but there are sub-documents
   * nested underneath it. When true, such missing documents will be returned
   * with a key but will not have fields,
   * [`create_time`][google.firestore.v1.Document.create_time], or
   * [`update_time`][google.firestore.v1.Document.update_time] set.
   *
   * Requests with `show_missing` may not specify `where` or `order_by`.
   *
   * @generated from field: bool show_missing = 12;
   */
  showMissing: boolean;
};

/**
 * Describes the message google.firestore.v1.ListDocumentsRequest.
 * Use `create(ListDocumentsRequestSchema)` to create a new message.
 */
export const ListDocumentsRequestSchema: GenMessage<ListDocumentsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 1);

/**
 * The response for
 * [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1.ListDocumentsResponse
 */
export type ListDocumentsResponse = Message<"google.firestore.v1.ListDocumentsResponse"> & {
  /**
   * The Documents found.
   *
   * @generated from field: repeated google.firestore.v1.Document documents = 1;
   */
  documents: Document[];

  /**
   * A token to retrieve the next page of documents.
   *
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1.ListDocumentsResponse.
 * Use `create(ListDocumentsResponseSchema)` to create a new message.
 */
export const ListDocumentsResponseSchema: GenMessage<ListDocumentsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 2);

/**
 * The request for
 * [Firestore.CreateDocument][google.firestore.v1.Firestore.CreateDocument].
 *
 * @generated from message google.firestore.v1.CreateDocumentRequest
 */
export type CreateDocumentRequest = Message<"google.firestore.v1.CreateDocumentRequest"> & {
  /**
   * Required. The parent resource. For example:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The collection ID, relative to `parent`, to list. For example:
   * `chatrooms`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId: string;

  /**
   * The client-assigned document ID to use for this document.
   *
   * Optional. If not specified, an ID will be assigned by the service.
   *
   * @generated from field: string document_id = 3;
   */
  documentId: string;

  /**
   * Required. The document to create. `name` must not be set.
   *
   * @generated from field: google.firestore.v1.Document document = 4;
   */
  document?: Document;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1.DocumentMask mask = 5;
   */
  mask?: DocumentMask;
};

/**
 * Describes the message google.firestore.v1.CreateDocumentRequest.
 * Use `create(CreateDocumentRequestSchema)` to create a new message.
 */
export const CreateDocumentRequestSchema: GenMessage<CreateDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 3);

/**
 * The request for
 * [Firestore.UpdateDocument][google.firestore.v1.Firestore.UpdateDocument].
 *
 * @generated from message google.firestore.v1.UpdateDocumentRequest
 */
export type UpdateDocumentRequest = Message<"google.firestore.v1.UpdateDocumentRequest"> & {
  /**
   * Required. The updated document.
   * Creates the document if it does not already exist.
   *
   * @generated from field: google.firestore.v1.Document document = 1;
   */
  document?: Document;

  /**
   * The fields to update.
   * None of the field paths in the mask may contain a reserved name.
   *
   * If the document exists on the server and has fields not referenced in the
   * mask, they are left unchanged.
   * Fields referenced in the mask, but not present in the input document, are
   * deleted from the document on the server.
   *
   * @generated from field: google.firestore.v1.DocumentMask update_mask = 2;
   */
  updateMask?: DocumentMask;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1.Precondition current_document = 4;
   */
  currentDocument?: Precondition;
};

/**
 * Describes the message google.firestore.v1.UpdateDocumentRequest.
 * Use `create(UpdateDocumentRequestSchema)` to create a new message.
 */
export const UpdateDocumentRequestSchema: GenMessage<UpdateDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 4);

/**
 * The request for
 * [Firestore.DeleteDocument][google.firestore.v1.Firestore.DeleteDocument].
 *
 * @generated from message google.firestore.v1.DeleteDocumentRequest
 */
export type DeleteDocumentRequest = Message<"google.firestore.v1.DeleteDocumentRequest"> & {
  /**
   * Required. The resource name of the Document to delete. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1.Precondition current_document = 2;
   */
  currentDocument?: Precondition;
};

/**
 * Describes the message google.firestore.v1.DeleteDocumentRequest.
 * Use `create(DeleteDocumentRequestSchema)` to create a new message.
 */
export const DeleteDocumentRequestSchema: GenMessage<DeleteDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 5);

/**
 * The request for
 * [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1.BatchGetDocumentsRequest
 */
export type BatchGetDocumentsRequest = Message<"google.firestore.v1.BatchGetDocumentsRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of the
   * given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[];

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field will
   * not be returned in the response.
   *
   * @generated from field: google.firestore.v1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.BatchGetDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 4;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1.TransactionOptions new_transaction = 5;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.BatchGetDocumentsRequest.
 * Use `create(BatchGetDocumentsRequestSchema)` to create a new message.
 */
export const BatchGetDocumentsRequestSchema: GenMessage<BatchGetDocumentsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 6);

/**
 * The streamed response for
 * [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1.BatchGetDocumentsResponse
 */
export type BatchGetDocumentsResponse = Message<"google.firestore.v1.BatchGetDocumentsResponse"> & {
  /**
   * A single result.
   * This can be empty if the server is just returning a transaction.
   *
   * @generated from oneof google.firestore.v1.BatchGetDocumentsResponse.result
   */
  result: {
    /**
     * A document that was requested.
     *
     * @generated from field: google.firestore.v1.Document found = 1;
     */
    value: Document;
    case: "found";
  } | {
    /**
     * A document name that was requested but does not exist. In the format:
     * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     * @generated from field: string missing = 2;
     */
    value: string;
    case: "missing";
  } | { case: undefined; value?: undefined };

  /**
   * The transaction that was started as part of this request.
   * Will only be set in the first response, and only if
   * [BatchGetDocumentsRequest.new_transaction][google.firestore.v1.BatchGetDocumentsRequest.new_transaction]
   * was set in the request.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction: Uint8Array;

  /**
   * The time at which the document was read.
   * This may be monotically increasing, in this case the previous documents in
   * the result stream are guaranteed not to have changed between their
   * read_time and this one.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 4;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1.BatchGetDocumentsResponse.
 * Use `create(BatchGetDocumentsResponseSchema)` to create a new message.
 */
export const BatchGetDocumentsResponseSchema: GenMessage<BatchGetDocumentsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 7);

/**
 * The request for
 * [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1.BeginTransactionRequest
 */
export type BeginTransactionRequest = Message<"google.firestore.v1.BeginTransactionRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The options for the transaction.
   * Defaults to a read-write transaction.
   *
   * @generated from field: google.firestore.v1.TransactionOptions options = 2;
   */
  options?: TransactionOptions;
};

/**
 * Describes the message google.firestore.v1.BeginTransactionRequest.
 * Use `create(BeginTransactionRequestSchema)` to create a new message.
 */
export const BeginTransactionRequestSchema: GenMessage<BeginTransactionRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 8);

/**
 * The response for
 * [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1.BeginTransactionResponse
 */
export type BeginTransactionResponse = Message<"google.firestore.v1.BeginTransactionResponse"> & {
  /**
   * The transaction that was started.
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1.BeginTransactionResponse.
 * Use `create(BeginTransactionResponseSchema)` to create a new message.
 */
export const BeginTransactionResponseSchema: GenMessage<BeginTransactionResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 9);

/**
 * The request for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1.CommitRequest
 */
export type CommitRequest = Message<"google.firestore.v1.CommitRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   *
   * @generated from field: repeated google.firestore.v1.Write writes = 2;
   */
  writes: Write[];

  /**
   * If set, applies all writes in this transaction, and commits it.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1.CommitRequest.
 * Use `create(CommitRequestSchema)` to create a new message.
 */
export const CommitRequestSchema: GenMessage<CommitRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 10);

/**
 * The response for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1.CommitResponse
 */
export type CommitResponse = Message<"google.firestore.v1.CommitResponse"> & {
  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1.WriteResult write_results = 1;
   */
  writeResults: WriteResult[];

  /**
   * The time at which the commit occurred. Any read with an equal or greater
   * `read_time` is guaranteed to see the effects of the commit.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 2;
   */
  commitTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1.CommitResponse.
 * Use `create(CommitResponseSchema)` to create a new message.
 */
export const CommitResponseSchema: GenMessage<CommitResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 11);

/**
 * The request for [Firestore.Rollback][google.firestore.v1.Firestore.Rollback].
 *
 * @generated from message google.firestore.v1.RollbackRequest
 */
export type RollbackRequest = Message<"google.firestore.v1.RollbackRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * Required. The transaction to roll back.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1.RollbackRequest.
 * Use `create(RollbackRequestSchema)` to create a new message.
 */
export const RollbackRequestSchema: GenMessage<RollbackRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 12);

/**
 * The request for [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1.RunQueryRequest
 */
export type RunQueryRequest = Message<"google.firestore.v1.RunQueryRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1.RunQueryRequest.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.RunQueryRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Run the query within an already active transaction.
     *
     * The value here is the opaque transaction ID to execute the query in.
     *
     * @generated from field: bytes transaction = 5;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1.TransactionOptions new_transaction = 6;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. Explain options for the query. If set, additional query
   * statistics will be returned. If not, only query results will be returned.
   *
   * @generated from field: google.firestore.v1.ExplainOptions explain_options = 10;
   */
  explainOptions?: ExplainOptions;
};

/**
 * Describes the message google.firestore.v1.RunQueryRequest.
 * Use `create(RunQueryRequestSchema)` to create a new message.
 */
export const RunQueryRequestSchema: GenMessage<RunQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 13);

/**
 * The response for
 * [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1.RunQueryResponse
 */
export type RunQueryResponse = Message<"google.firestore.v1.RunQueryResponse"> & {
  /**
   * The transaction that was started as part of this request.
   * Can only be set in the first response, and only if
   * [RunQueryRequest.new_transaction][google.firestore.v1.RunQueryRequest.new_transaction]
   * was set in the request. If set, no other fields will be set in this
   * response.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction: Uint8Array;

  /**
   * A query result, not set when reporting partial progress.
   *
   * @generated from field: google.firestore.v1.Document document = 1;
   */
  document?: Document;

  /**
   * The time at which the document was read. This may be monotonically
   * increasing; in this case, the previous documents in the result stream are
   * guaranteed not to have changed between their `read_time` and this one.
   *
   * If the query returns no results, a response with `read_time` and no
   * `document` will be sent, and this represents the time at which the query
   * was run.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 3;
   */
  readTime?: Timestamp;

  /**
   * The number of results that have been skipped due to an offset between
   * the last response and the current response.
   *
   * @generated from field: int32 skipped_results = 4;
   */
  skippedResults: number;

  /**
   * The continuation mode for the query. If present, it indicates the current
   * query response stream has finished. This can be set with or without a
   * `document` present, but when set, no more results are returned.
   *
   * @generated from oneof google.firestore.v1.RunQueryResponse.continuation_selector
   */
  continuationSelector: {
    /**
     * If present, Firestore has completely finished the request and no more
     * documents will be returned.
     *
     * @generated from field: bool done = 6;
     */
    value: boolean;
    case: "done";
  } | { case: undefined; value?: undefined };

  /**
   * Query explain metrics. This is only present when the
   * [RunQueryRequest.explain_options][google.firestore.v1.RunQueryRequest.explain_options]
   * is provided, and it is sent only once with the last response in the stream.
   *
   * @generated from field: google.firestore.v1.ExplainMetrics explain_metrics = 11;
   */
  explainMetrics?: ExplainMetrics;
};

/**
 * Describes the message google.firestore.v1.RunQueryResponse.
 * Use `create(RunQueryResponseSchema)` to create a new message.
 */
export const RunQueryResponseSchema: GenMessage<RunQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 14);

/**
 * The request for
 * [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
 *
 * @generated from message google.firestore.v1.RunAggregationQueryRequest
 */
export type RunAggregationQueryRequest = Message<"google.firestore.v1.RunAggregationQueryRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1.RunAggregationQueryRequest.query_type
   */
  queryType: {
    /**
     * An aggregation query.
     *
     * @generated from field: google.firestore.v1.StructuredAggregationQuery structured_aggregation_query = 2;
     */
    value: StructuredAggregationQuery;
    case: "structuredAggregationQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The consistency mode for the query, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.RunAggregationQueryRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Run the aggregation within an already active transaction.
     *
     * The value here is the opaque transaction ID to execute the query in.
     *
     * @generated from field: bytes transaction = 4;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction as part of the query, defaulting to read-only.
     *
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1.TransactionOptions new_transaction = 5;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Executes the query at the given timestamp.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 6;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. Explain options for the query. If set, additional query
   * statistics will be returned. If not, only query results will be returned.
   *
   * @generated from field: google.firestore.v1.ExplainOptions explain_options = 8;
   */
  explainOptions?: ExplainOptions;
};

/**
 * Describes the message google.firestore.v1.RunAggregationQueryRequest.
 * Use `create(RunAggregationQueryRequestSchema)` to create a new message.
 */
export const RunAggregationQueryRequestSchema: GenMessage<RunAggregationQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 15);

/**
 * The response for
 * [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
 *
 * @generated from message google.firestore.v1.RunAggregationQueryResponse
 */
export type RunAggregationQueryResponse = Message<"google.firestore.v1.RunAggregationQueryResponse"> & {
  /**
   * A single aggregation result.
   *
   * Not present when reporting partial progress.
   *
   * @generated from field: google.firestore.v1.AggregationResult result = 1;
   */
  result?: AggregationResult;

  /**
   * The transaction that was started as part of this request.
   *
   * Only present on the first response when the request requested to start
   * a new transaction.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction: Uint8Array;

  /**
   * The time at which the aggregate result was computed. This is always
   * monotonically increasing; in this case, the previous AggregationResult in
   * the result stream are guaranteed not to have changed between their
   * `read_time` and this one.
   *
   * If the query returns no results, a response with `read_time` and no
   * `result` will be sent, and this represents the time at which the query
   * was run.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 3;
   */
  readTime?: Timestamp;

  /**
   * Query explain metrics. This is only present when the
   * [RunAggregationQueryRequest.explain_options][google.firestore.v1.RunAggregationQueryRequest.explain_options]
   * is provided, and it is sent only once with the last response in the stream.
   *
   * @generated from field: google.firestore.v1.ExplainMetrics explain_metrics = 10;
   */
  explainMetrics?: ExplainMetrics;
};

/**
 * Describes the message google.firestore.v1.RunAggregationQueryResponse.
 * Use `create(RunAggregationQueryResponseSchema)` to create a new message.
 */
export const RunAggregationQueryResponseSchema: GenMessage<RunAggregationQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 16);

/**
 * The request for
 * [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
 *
 * @generated from message google.firestore.v1.PartitionQueryRequest
 */
export type PartitionQueryRequest = Message<"google.firestore.v1.PartitionQueryRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents`.
   * Document resource names are not supported; only database resource names
   * can be specified.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to partition.
   *
   * @generated from oneof google.firestore.v1.PartitionQueryRequest.query_type
   */
  queryType: {
    /**
     * A structured query.
     * Query must specify collection with all descendants and be ordered by name
     * ascending. Other filters, order bys, limits, offsets, and start/end
     * cursors are not supported.
     *
     * @generated from field: google.firestore.v1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The desired maximum number of partition points.
   * The partitions may be returned across multiple pages of results.
   * The number must be positive. The actual number of partitions
   * returned may be fewer.
   *
   * For example, this may be set to one fewer than the number of parallel
   * queries to be run, or in running a data pipeline job, one fewer than the
   * number of workers or compute instances available.
   *
   * @generated from field: int64 partition_count = 3;
   */
  partitionCount: bigint;

  /**
   * The `next_page_token` value returned from a previous call to
   * PartitionQuery that may be used to get an additional set of results.
   * There are no ordering guarantees between sets of results. Thus, using
   * multiple sets of results will require merging the different result sets.
   *
   * For example, two subsequent calls using a page_token may return:
   *
   *  * cursor B, cursor M, cursor Q
   *  * cursor A, cursor U, cursor W
   *
   * To obtain a complete result set ordered with respect to the results of the
   * query supplied to PartitionQuery, the results sets should be merged:
   * cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * The maximum number of partitions to return in this call, subject to
   * `partition_count`.
   *
   * For example, if `partition_count` = 10 and `page_size` = 8, the first call
   * to PartitionQuery will return up to 8 partitions and a `next_page_token`
   * if more results exist. A second call to PartitionQuery will return up to
   * 2 partitions, to complete the total of 10 specified in `partition_count`.
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize: number;

  /**
   * The consistency mode for this request.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.PartitionQueryRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents as they were at the given time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 6;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.PartitionQueryRequest.
 * Use `create(PartitionQueryRequestSchema)` to create a new message.
 */
export const PartitionQueryRequestSchema: GenMessage<PartitionQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 17);

/**
 * The response for
 * [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
 *
 * @generated from message google.firestore.v1.PartitionQueryResponse
 */
export type PartitionQueryResponse = Message<"google.firestore.v1.PartitionQueryResponse"> & {
  /**
   * Partition results.
   * Each partition is a split point that can be used by RunQuery as a starting
   * or end point for the query results. The RunQuery requests must be made with
   * the same query supplied to this PartitionQuery request. The partition
   * cursors will be ordered according to same ordering as the results of the
   * query supplied to PartitionQuery.
   *
   * For example, if a PartitionQuery request returns partition cursors A and B,
   * running the following three queries will return the entire result set of
   * the original query:
   *
   *  * query, end_at A
   *  * query, start_at A, end_at B
   *  * query, start_at B
   *
   * An empty result may indicate that the query has too few results to be
   * partitioned, or that the query is not yet supported for partitioning.
   *
   * @generated from field: repeated google.firestore.v1.Cursor partitions = 1;
   */
  partitions: Cursor[];

  /**
   * A page token that may be used to request an additional set of results, up
   * to the number specified by `partition_count` in the PartitionQuery request.
   * If blank, there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1.PartitionQueryResponse.
 * Use `create(PartitionQueryResponseSchema)` to create a new message.
 */
export const PartitionQueryResponseSchema: GenMessage<PartitionQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 18);

/**
 * The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
 *
 * The first request creates a stream, or resumes an existing one from a token.
 *
 * When creating a new stream, the server replies with a response containing
 * only an ID and a token, to use in the next request.
 *
 * When resuming a stream, the server first streams any responses later than the
 * given token, then a response containing only an up-to-date token, to use in
 * the next request.
 *
 * @generated from message google.firestore.v1.WriteRequest
 */
export type WriteRequest = Message<"google.firestore.v1.WriteRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   * This is only required in the first message.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The ID of the write stream to resume.
   * This may only be set in the first message. When left empty, a new write
   * stream will be created.
   *
   * @generated from field: string stream_id = 2;
   */
  streamId: string;

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   * This must be empty on the first request.
   * This may be empty on the last request.
   * This must not be empty on all other requests.
   *
   * @generated from field: repeated google.firestore.v1.Write writes = 3;
   */
  writes: Write[];

  /**
   * A stream token that was previously sent by the server.
   *
   * The client should set this field to the token from the most recent
   * [WriteResponse][google.firestore.v1.WriteResponse] it has received. This
   * acknowledges that the client has received responses up to this token. After
   * sending this token, earlier tokens may not be used anymore.
   *
   * The server may close the stream if there are too many unacknowledged
   * responses.
   *
   * Leave this field unset when creating a new stream. To resume a stream at
   * a specific point, set this field and the `stream_id` field.
   *
   * Leave this field unset when creating a new stream.
   *
   * @generated from field: bytes stream_token = 4;
   */
  streamToken: Uint8Array;

  /**
   * Labels associated with this write request.
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1.WriteRequest.
 * Use `create(WriteRequestSchema)` to create a new message.
 */
export const WriteRequestSchema: GenMessage<WriteRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 19);

/**
 * The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
 *
 * @generated from message google.firestore.v1.WriteResponse
 */
export type WriteResponse = Message<"google.firestore.v1.WriteResponse"> & {
  /**
   * The ID of the stream.
   * Only set on the first message, when a new stream was created.
   *
   * @generated from field: string stream_id = 1;
   */
  streamId: string;

  /**
   * A token that represents the position of this response in the stream.
   * This can be used by a client to resume the stream at this point.
   *
   * This field is always set.
   *
   * @generated from field: bytes stream_token = 2;
   */
  streamToken: Uint8Array;

  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1.WriteResult write_results = 3;
   */
  writeResults: WriteResult[];

  /**
   * The time at which the commit occurred. Any read with an equal or greater
   * `read_time` is guaranteed to see the effects of the write.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 4;
   */
  commitTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1.WriteResponse.
 * Use `create(WriteResponseSchema)` to create a new message.
 */
export const WriteResponseSchema: GenMessage<WriteResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 20);

/**
 * A request for [Firestore.Listen][google.firestore.v1.Firestore.Listen]
 *
 * @generated from message google.firestore.v1.ListenRequest
 */
export type ListenRequest = Message<"google.firestore.v1.ListenRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The supported target changes.
   *
   * @generated from oneof google.firestore.v1.ListenRequest.target_change
   */
  targetChange: {
    /**
     * A target to add to this stream.
     *
     * @generated from field: google.firestore.v1.Target add_target = 2;
     */
    value: Target;
    case: "addTarget";
  } | {
    /**
     * The ID of a target to remove from this stream.
     *
     * @generated from field: int32 remove_target = 3;
     */
    value: number;
    case: "removeTarget";
  } | { case: undefined; value?: undefined };

  /**
   * Labels associated with this target change.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1.ListenRequest.
 * Use `create(ListenRequestSchema)` to create a new message.
 */
export const ListenRequestSchema: GenMessage<ListenRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 21);

/**
 * The response for [Firestore.Listen][google.firestore.v1.Firestore.Listen].
 *
 * @generated from message google.firestore.v1.ListenResponse
 */
export type ListenResponse = Message<"google.firestore.v1.ListenResponse"> & {
  /**
   * The supported responses.
   *
   * @generated from oneof google.firestore.v1.ListenResponse.response_type
   */
  responseType: {
    /**
     * Targets have changed.
     *
     * @generated from field: google.firestore.v1.TargetChange target_change = 2;
     */
    value: TargetChange;
    case: "targetChange";
  } | {
    /**
     * A [Document][google.firestore.v1.Document] has changed.
     *
     * @generated from field: google.firestore.v1.DocumentChange document_change = 3;
     */
    value: DocumentChange;
    case: "documentChange";
  } | {
    /**
     * A [Document][google.firestore.v1.Document] has been deleted.
     *
     * @generated from field: google.firestore.v1.DocumentDelete document_delete = 4;
     */
    value: DocumentDelete;
    case: "documentDelete";
  } | {
    /**
     * A [Document][google.firestore.v1.Document] has been removed from a target
     * (because it is no longer relevant to that target).
     *
     * @generated from field: google.firestore.v1.DocumentRemove document_remove = 6;
     */
    value: DocumentRemove;
    case: "documentRemove";
  } | {
    /**
     * A filter to apply to the set of documents previously returned for the
     * given target.
     *
     * Returned when documents may have been removed from the given target, but
     * the exact documents are unknown.
     *
     * @generated from field: google.firestore.v1.ExistenceFilter filter = 5;
     */
    value: ExistenceFilter;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.ListenResponse.
 * Use `create(ListenResponseSchema)` to create a new message.
 */
export const ListenResponseSchema: GenMessage<ListenResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 22);

/**
 * A specification of a set of documents to listen to.
 *
 * @generated from message google.firestore.v1.Target
 */
export type Target = Message<"google.firestore.v1.Target"> & {
  /**
   * The type of target to listen to.
   *
   * @generated from oneof google.firestore.v1.Target.target_type
   */
  targetType: {
    /**
     * A target specified by a query.
     *
     * @generated from field: google.firestore.v1.Target.QueryTarget query = 2;
     */
    value: Target_QueryTarget;
    case: "query";
  } | {
    /**
     * A target specified by a set of document names.
     *
     * @generated from field: google.firestore.v1.Target.DocumentsTarget documents = 3;
     */
    value: Target_DocumentsTarget;
    case: "documents";
  } | { case: undefined; value?: undefined };

  /**
   * When to start listening.
   *
   * If specified, only the matching Documents that have been updated AFTER the
   * `resume_token` or `read_time` will be returned. Otherwise, all matching
   * Documents are returned before any subsequent changes.
   *
   * @generated from oneof google.firestore.v1.Target.resume_type
   */
  resumeType: {
    /**
     * A resume token from a prior
     * [TargetChange][google.firestore.v1.TargetChange] for an identical target.
     *
     * Using a resume token with a different target is unsupported and may fail.
     *
     * @generated from field: bytes resume_token = 4;
     */
    value: Uint8Array;
    case: "resumeToken";
  } | {
    /**
     * Start listening after a specific `read_time`.
     *
     * The client must know the state of matching documents at this time.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 11;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * The target ID that identifies the target on the stream. Must be a positive
   * number and non-zero.
   *
   * If `target_id` is 0 (or unspecified), the server will assign an ID for this
   * target and return that in a `TargetChange::ADD` event. Once a target with
   * `target_id=0` is added, all subsequent targets must also have
   * `target_id=0`. If an `AddTarget` request with `target_id != 0` is
   * sent to the server after a target with `target_id=0` is added, the server
   * will immediately send a response with a `TargetChange::Remove` event.
   *
   * Note that if the client sends multiple `AddTarget` requests
   * without an ID, the order of IDs returned in `TargetChage.target_ids` are
   * undefined. Therefore, clients should provide a target ID instead of relying
   * on the server to assign one.
   *
   * If `target_id` is non-zero, there must not be an existing active target on
   * this stream with the same ID.
   *
   * @generated from field: int32 target_id = 5;
   */
  targetId: number;

  /**
   * If the target should be removed once it is current and consistent.
   *
   * @generated from field: bool once = 6;
   */
  once: boolean;

  /**
   * The number of documents that last matched the query at the resume token or
   * read time.
   *
   * This value is only relevant when a `resume_type` is provided. This value
   * being present and greater than zero signals that the client wants
   * `ExistenceFilter.unchanged_names` to be included in the response.
   *
   * @generated from field: google.protobuf.Int32Value expected_count = 12;
   */
  expectedCount?: number;
};

/**
 * Describes the message google.firestore.v1.Target.
 * Use `create(TargetSchema)` to create a new message.
 */
export const TargetSchema: GenMessage<Target> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 23);

/**
 * A target specified by a set of documents names.
 *
 * @generated from message google.firestore.v1.Target.DocumentsTarget
 */
export type Target_DocumentsTarget = Message<"google.firestore.v1.Target.DocumentsTarget"> & {
  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of
   * the given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[];
};

/**
 * Describes the message google.firestore.v1.Target.DocumentsTarget.
 * Use `create(Target_DocumentsTargetSchema)` to create a new message.
 */
export const Target_DocumentsTargetSchema: GenMessage<Target_DocumentsTarget> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 23, 0);

/**
 * A target specified by a query.
 *
 * @generated from message google.firestore.v1.Target.QueryTarget
 */
export type Target_QueryTarget = Message<"google.firestore.v1.Target.QueryTarget"> & {
  /**
   * The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1.Target.QueryTarget.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.Target.QueryTarget.
 * Use `create(Target_QueryTargetSchema)` to create a new message.
 */
export const Target_QueryTargetSchema: GenMessage<Target_QueryTarget> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 23, 1);

/**
 * Targets being watched have changed.
 *
 * @generated from message google.firestore.v1.TargetChange
 */
export type TargetChange = Message<"google.firestore.v1.TargetChange"> & {
  /**
   * The type of change that occurred.
   *
   * @generated from field: google.firestore.v1.TargetChange.TargetChangeType target_change_type = 1;
   */
  targetChangeType: TargetChange_TargetChangeType;

  /**
   * The target IDs of targets that have changed.
   *
   * If empty, the change applies to all targets.
   *
   * The order of the target IDs is not defined.
   *
   * @generated from field: repeated int32 target_ids = 2;
   */
  targetIds: number[];

  /**
   * The error that resulted in this change, if applicable.
   *
   * @generated from field: google.rpc.Status cause = 3;
   */
  cause?: Status;

  /**
   * A token that can be used to resume the stream for the given `target_ids`,
   * or all targets if `target_ids` is empty.
   *
   * Not set on every target change.
   *
   * @generated from field: bytes resume_token = 4;
   */
  resumeToken: Uint8Array;

  /**
   * The consistent `read_time` for the given `target_ids` (omitted when the
   * target_ids are not at a consistent snapshot).
   *
   * The stream is guaranteed to send a `read_time` with `target_ids` empty
   * whenever the entire stream reaches a new consistent snapshot. ADD,
   * CURRENT, and RESET messages are guaranteed to (eventually) result in a
   * new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
   *
   * For a given stream, `read_time` is guaranteed to be monotonically
   * increasing.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 6;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1.TargetChange.
 * Use `create(TargetChangeSchema)` to create a new message.
 */
export const TargetChangeSchema: GenMessage<TargetChange> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 24);

/**
 * The type of change.
 *
 * @generated from enum google.firestore.v1.TargetChange.TargetChangeType
 */
export enum TargetChange_TargetChangeType {
  /**
   * No change has occurred. Used only to send an updated `resume_token`.
   *
   * @generated from enum value: NO_CHANGE = 0;
   */
  NO_CHANGE = 0,

  /**
   * The targets have been added.
   *
   * @generated from enum value: ADD = 1;
   */
  ADD = 1,

  /**
   * The targets have been removed.
   *
   * @generated from enum value: REMOVE = 2;
   */
  REMOVE = 2,

  /**
   * The targets reflect all changes committed before the targets were added
   * to the stream.
   *
   * This will be sent after or with a `read_time` that is greater than or
   * equal to the time at which the targets were added.
   *
   * Listeners can wait for this change if read-after-write semantics
   * are desired.
   *
   * @generated from enum value: CURRENT = 3;
   */
  CURRENT = 3,

  /**
   * The targets have been reset, and a new initial state for the targets
   * will be returned in subsequent changes.
   *
   * After the initial state is complete, `CURRENT` will be returned even
   * if the target was previously indicated to be `CURRENT`.
   *
   * @generated from enum value: RESET = 4;
   */
  RESET = 4,
}

/**
 * Describes the enum google.firestore.v1.TargetChange.TargetChangeType.
 */
export const TargetChange_TargetChangeTypeSchema: GenEnum<TargetChange_TargetChangeType> = /*@__PURE__*/
  enumDesc(file_google_firestore_v1_firestore, 24, 0);

/**
 * The request for
 * [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1.ListCollectionIdsRequest
 */
export type ListCollectionIdsRequest = Message<"google.firestore.v1.ListCollectionIdsRequest"> & {
  /**
   * Required. The parent document. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of results to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token. Must be a value from
   * [ListCollectionIdsResponse][google.firestore.v1.ListCollectionIdsResponse].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * The consistency mode for this request.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1.ListCollectionIdsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents as they were at the given time.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 4;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1.ListCollectionIdsRequest.
 * Use `create(ListCollectionIdsRequestSchema)` to create a new message.
 */
export const ListCollectionIdsRequestSchema: GenMessage<ListCollectionIdsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 25);

/**
 * The response from
 * [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1.ListCollectionIdsResponse
 */
export type ListCollectionIdsResponse = Message<"google.firestore.v1.ListCollectionIdsResponse"> & {
  /**
   * The collection ids.
   *
   * @generated from field: repeated string collection_ids = 1;
   */
  collectionIds: string[];

  /**
   * A page token that may be used to continue the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1.ListCollectionIdsResponse.
 * Use `create(ListCollectionIdsResponseSchema)` to create a new message.
 */
export const ListCollectionIdsResponseSchema: GenMessage<ListCollectionIdsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 26);

/**
 * The request for
 * [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
 *
 * @generated from message google.firestore.v1.BatchWriteRequest
 */
export type BatchWriteRequest = Message<"google.firestore.v1.BatchWriteRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The writes to apply.
   *
   * Method does not apply writes atomically and does not guarantee ordering.
   * Each write succeeds or fails independently. You cannot write to the same
   * document more than once per request.
   *
   * @generated from field: repeated google.firestore.v1.Write writes = 2;
   */
  writes: Write[];

  /**
   * Labels associated with this batch write.
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1.BatchWriteRequest.
 * Use `create(BatchWriteRequestSchema)` to create a new message.
 */
export const BatchWriteRequestSchema: GenMessage<BatchWriteRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 27);

/**
 * The response from
 * [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
 *
 * @generated from message google.firestore.v1.BatchWriteResponse
 */
export type BatchWriteResponse = Message<"google.firestore.v1.BatchWriteResponse"> & {
  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1.WriteResult write_results = 1;
   */
  writeResults: WriteResult[];

  /**
   * The status of applying the writes.
   *
   * This i-th write status corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.rpc.Status status = 2;
   */
  status: Status[];
};

/**
 * Describes the message google.firestore.v1.BatchWriteResponse.
 * Use `create(BatchWriteResponseSchema)` to create a new message.
 */
export const BatchWriteResponseSchema: GenMessage<BatchWriteResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1_firestore, 28);

/**
 * The Cloud Firestore service.
 *
 * Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
 * document database that simplifies storing, syncing, and querying data for
 * your mobile, web, and IoT apps at global scale. Its client libraries provide
 * live synchronization and offline support, while its security features and
 * integrations with Firebase and Google Cloud Platform accelerate building
 * truly serverless apps.
 *
 * @generated from service google.firestore.v1.Firestore
 */
export const Firestore: GenService<{
  /**
   * Gets a single document.
   *
   * @generated from rpc google.firestore.v1.Firestore.GetDocument
   */
  getDocument: {
    methodKind: "unary";
    input: typeof GetDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
  /**
   * Lists documents.
   *
   * @generated from rpc google.firestore.v1.Firestore.ListDocuments
   */
  listDocuments: {
    methodKind: "unary";
    input: typeof ListDocumentsRequestSchema;
    output: typeof ListDocumentsResponseSchema;
  },
  /**
   * Updates or inserts a document.
   *
   * @generated from rpc google.firestore.v1.Firestore.UpdateDocument
   */
  updateDocument: {
    methodKind: "unary";
    input: typeof UpdateDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
  /**
   * Deletes a document.
   *
   * @generated from rpc google.firestore.v1.Firestore.DeleteDocument
   */
  deleteDocument: {
    methodKind: "unary";
    input: typeof DeleteDocumentRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets multiple documents.
   *
   * Documents returned by this method are not guaranteed to be returned in the
   * same order that they were requested.
   *
   * @generated from rpc google.firestore.v1.Firestore.BatchGetDocuments
   */
  batchGetDocuments: {
    methodKind: "server_streaming";
    input: typeof BatchGetDocumentsRequestSchema;
    output: typeof BatchGetDocumentsResponseSchema;
  },
  /**
   * Starts a new transaction.
   *
   * @generated from rpc google.firestore.v1.Firestore.BeginTransaction
   */
  beginTransaction: {
    methodKind: "unary";
    input: typeof BeginTransactionRequestSchema;
    output: typeof BeginTransactionResponseSchema;
  },
  /**
   * Commits a transaction, while optionally updating documents.
   *
   * @generated from rpc google.firestore.v1.Firestore.Commit
   */
  commit: {
    methodKind: "unary";
    input: typeof CommitRequestSchema;
    output: typeof CommitResponseSchema;
  },
  /**
   * Rolls back a transaction.
   *
   * @generated from rpc google.firestore.v1.Firestore.Rollback
   */
  rollback: {
    methodKind: "unary";
    input: typeof RollbackRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Runs a query.
   *
   * @generated from rpc google.firestore.v1.Firestore.RunQuery
   */
  runQuery: {
    methodKind: "server_streaming";
    input: typeof RunQueryRequestSchema;
    output: typeof RunQueryResponseSchema;
  },
  /**
   * Runs an aggregation query.
   *
   * Rather than producing [Document][google.firestore.v1.Document] results like
   * [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery], this API
   * allows running an aggregation to produce a series of
   * [AggregationResult][google.firestore.v1.AggregationResult] server-side.
   *
   * High-Level Example:
   *
   * ```
   * -- Return the number of documents in table given a filter.
   * SELECT COUNT(*) FROM ( SELECT * FROM k where a = true );
   * ```
   *
   * @generated from rpc google.firestore.v1.Firestore.RunAggregationQuery
   */
  runAggregationQuery: {
    methodKind: "server_streaming";
    input: typeof RunAggregationQueryRequestSchema;
    output: typeof RunAggregationQueryResponseSchema;
  },
  /**
   * Partitions a query by returning partition cursors that can be used to run
   * the query in parallel. The returned partition cursors are split points that
   * can be used by RunQuery as starting/end points for the query results.
   *
   * @generated from rpc google.firestore.v1.Firestore.PartitionQuery
   */
  partitionQuery: {
    methodKind: "unary";
    input: typeof PartitionQueryRequestSchema;
    output: typeof PartitionQueryResponseSchema;
  },
  /**
   * Streams batches of document updates and deletes, in order. This method is
   * only available via gRPC or WebChannel (not REST).
   *
   * @generated from rpc google.firestore.v1.Firestore.Write
   */
  write: {
    methodKind: "bidi_streaming";
    input: typeof WriteRequestSchema;
    output: typeof WriteResponseSchema;
  },
  /**
   * Listens to changes. This method is only available via gRPC or WebChannel
   * (not REST).
   *
   * @generated from rpc google.firestore.v1.Firestore.Listen
   */
  listen: {
    methodKind: "bidi_streaming";
    input: typeof ListenRequestSchema;
    output: typeof ListenResponseSchema;
  },
  /**
   * Lists all the collection IDs underneath a document.
   *
   * @generated from rpc google.firestore.v1.Firestore.ListCollectionIds
   */
  listCollectionIds: {
    methodKind: "unary";
    input: typeof ListCollectionIdsRequestSchema;
    output: typeof ListCollectionIdsResponseSchema;
  },
  /**
   * Applies a batch of write operations.
   *
   * The BatchWrite method does not apply the write operations atomically
   * and can apply them out of order. Method does not allow more than one write
   * per document. Each write succeeds or fails independently. See the
   * [BatchWriteResponse][google.firestore.v1.BatchWriteResponse] for the
   * success status of each write.
   *
   * If you require an atomically applied set of writes, use
   * [Commit][google.firestore.v1.Firestore.Commit] instead.
   *
   * @generated from rpc google.firestore.v1.Firestore.BatchWrite
   */
  batchWrite: {
    methodKind: "unary";
    input: typeof BatchWriteRequestSchema;
    output: typeof BatchWriteResponseSchema;
  },
  /**
   * Creates a new document.
   *
   * @generated from rpc google.firestore.v1.Firestore.CreateDocument
   */
  createDocument: {
    methodKind: "unary";
    input: typeof CreateDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_firestore_v1_firestore, 0);

