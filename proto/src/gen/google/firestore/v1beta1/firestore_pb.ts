// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/firestore/v1beta1/firestore.proto (package google.firestore.v1beta1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import type { DocumentMask, Precondition, TransactionOptions } from "./common_pb";
import { file_google_firestore_v1beta1_common } from "./common_pb";
import type { Document, DocumentSchema } from "./document_pb";
import { file_google_firestore_v1beta1_document } from "./document_pb";
import type { Cursor, StructuredQuery } from "./query_pb";
import { file_google_firestore_v1beta1_query } from "./query_pb";
import type { DocumentChange, DocumentDelete, DocumentRemove, ExistenceFilter, Write, WriteResult } from "./write_pb";
import { file_google_firestore_v1beta1_write } from "./write_pb";
import type { EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/firestore/v1beta1/firestore.proto.
 */
export const file_google_firestore_v1beta1_firestore: GenFile = /*@__PURE__*/
  fileDesc("Cihnb29nbGUvZmlyZXN0b3JlL3YxYmV0YTEvZmlyZXN0b3JlLnByb3RvEhhnb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEivQEKEkdldERvY3VtZW50UmVxdWVzdBIRCgRuYW1lGAEgASgJQgPgQQISNAoEbWFzaxgCIAEoCzImLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudE1hc2sSFQoLdHJhbnNhY3Rpb24YAyABKAxIABIvCglyZWFkX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSABCFgoUY29uc2lzdGVuY3lfc2VsZWN0b3IirAIKFExpc3REb2N1bWVudHNSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECEhoKDWNvbGxlY3Rpb25faWQYAiABKAlCA+BBAhIRCglwYWdlX3NpemUYAyABKAUSEgoKcGFnZV90b2tlbhgEIAEoCRIQCghvcmRlcl9ieRgGIAEoCRI0CgRtYXNrGAcgASgLMiYuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50TWFzaxIVCgt0cmFuc2FjdGlvbhgIIAEoDEgAEi8KCXJlYWRfdGltZRgKIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIABIUCgxzaG93X21pc3NpbmcYDCABKAhCFgoUY29uc2lzdGVuY3lfc2VsZWN0b3IiZwoVTGlzdERvY3VtZW50c1Jlc3BvbnNlEjUKCWRvY3VtZW50cxgBIAMoCzIiLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudBIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkizgEKFUNyZWF0ZURvY3VtZW50UmVxdWVzdBITCgZwYXJlbnQYASABKAlCA+BBAhIaCg1jb2xsZWN0aW9uX2lkGAIgASgJQgPgQQISEwoLZG9jdW1lbnRfaWQYAyABKAkSOQoIZG9jdW1lbnQYBCABKAsyIi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuRG9jdW1lbnRCA+BBAhI0CgRtYXNrGAUgASgLMiYuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50TWFzayKHAgoVVXBkYXRlRG9jdW1lbnRSZXF1ZXN0EjkKCGRvY3VtZW50GAEgASgLMiIuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50QgPgQQISOwoLdXBkYXRlX21hc2sYAiABKAsyJi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuRG9jdW1lbnRNYXNrEjQKBG1hc2sYAyABKAsyJi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuRG9jdW1lbnRNYXNrEkAKEGN1cnJlbnRfZG9jdW1lbnQYBCABKAsyJi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuUHJlY29uZGl0aW9uImwKFURlbGV0ZURvY3VtZW50UmVxdWVzdBIRCgRuYW1lGAEgASgJQgPgQQISQAoQY3VycmVudF9kb2N1bWVudBgCIAEoCzImLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5QcmVjb25kaXRpb24iowIKGEJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEhEKCWRvY3VtZW50cxgCIAMoCRI0CgRtYXNrGAMgASgLMiYuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50TWFzaxIVCgt0cmFuc2FjdGlvbhgEIAEoDEgAEkcKD25ld190cmFuc2FjdGlvbhgFIAEoCzIsLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5UcmFuc2FjdGlvbk9wdGlvbnNIABIvCglyZWFkX3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSABCFgoUY29uc2lzdGVuY3lfc2VsZWN0b3IisQEKGUJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2USMwoFZm91bmQYASABKAsyIi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuRG9jdW1lbnRIABIRCgdtaXNzaW5nGAIgASgJSAASEwoLdHJhbnNhY3Rpb24YAyABKAwSLQoJcmVhZF90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIICgZyZXN1bHQibwoXQmVnaW5UcmFuc2FjdGlvblJlcXVlc3QSFQoIZGF0YWJhc2UYASABKAlCA+BBAhI9CgdvcHRpb25zGAIgASgLMiwuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlRyYW5zYWN0aW9uT3B0aW9ucyIvChhCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2USEwoLdHJhbnNhY3Rpb24YASABKAwibAoNQ29tbWl0UmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEi8KBndyaXRlcxgCIAMoCzIfLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Xcml0ZRITCgt0cmFuc2FjdGlvbhgDIAEoDCJ/Cg5Db21taXRSZXNwb25zZRI8Cg13cml0ZV9yZXN1bHRzGAEgAygLMiUuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLldyaXRlUmVzdWx0Ei8KC2NvbW1pdF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJCCg9Sb2xsYmFja1JlcXVlc3QSFQoIZGF0YWJhc2UYASABKAlCA+BBAhIYCgt0cmFuc2FjdGlvbhgCIAEoDEID4EECIqQCCg9SdW5RdWVyeVJlcXVlc3QSEwoGcGFyZW50GAEgASgJQgPgQQISRQoQc3RydWN0dXJlZF9xdWVyeRgCIAEoCzIpLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5TdHJ1Y3R1cmVkUXVlcnlIABIVCgt0cmFuc2FjdGlvbhgFIAEoDEgBEkcKD25ld190cmFuc2FjdGlvbhgGIAEoCzIsLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5UcmFuc2FjdGlvbk9wdGlvbnNIARIvCglyZWFkX3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAFCDAoKcXVlcnlfdHlwZUIWChRjb25zaXN0ZW5jeV9zZWxlY3RvciKlAQoQUnVuUXVlcnlSZXNwb25zZRITCgt0cmFuc2FjdGlvbhgCIAEoDBI0Cghkb2N1bWVudBgBIAEoCzIiLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudBItCglyZWFkX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhcKD3NraXBwZWRfcmVzdWx0cxgEIAEoBSLBAQoVUGFydGl0aW9uUXVlcnlSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECEkUKEHN0cnVjdHVyZWRfcXVlcnkYAiABKAsyKS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuU3RydWN0dXJlZFF1ZXJ5SAASFwoPcGFydGl0aW9uX2NvdW50GAMgASgDEhIKCnBhZ2VfdG9rZW4YBCABKAkSEQoJcGFnZV9zaXplGAUgASgFQgwKCnF1ZXJ5X3R5cGUiZwoWUGFydGl0aW9uUXVlcnlSZXNwb25zZRI0CgpwYXJ0aXRpb25zGAEgAygLMiAuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkN1cnNvchIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAki8gEKDFdyaXRlUmVxdWVzdBIVCghkYXRhYmFzZRgBIAEoCUID4EECEhEKCXN0cmVhbV9pZBgCIAEoCRIvCgZ3cml0ZXMYAyADKAsyHy5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuV3JpdGUSFAoMc3RyZWFtX3Rva2VuGAQgASgMEkIKBmxhYmVscxgFIAMoCzIyLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Xcml0ZVJlcXVlc3QuTGFiZWxzRW50cnkaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKnAQoNV3JpdGVSZXNwb25zZRIRCglzdHJlYW1faWQYASABKAkSFAoMc3RyZWFtX3Rva2VuGAIgASgMEjwKDXdyaXRlX3Jlc3VsdHMYAyADKAsyJS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuV3JpdGVSZXN1bHQSLwoLY29tbWl0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIvwBCg1MaXN0ZW5SZXF1ZXN0EhUKCGRhdGFiYXNlGAEgASgJQgPgQQISNgoKYWRkX3RhcmdldBgCIAEoCzIgLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5UYXJnZXRIABIXCg1yZW1vdmVfdGFyZ2V0GAMgASgFSAASQwoGbGFiZWxzGAQgAygLMjMuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkxpc3RlblJlcXVlc3QuTGFiZWxzRW50cnkaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIPCg10YXJnZXRfY2hhbmdlIu4CCg5MaXN0ZW5SZXNwb25zZRI/Cg10YXJnZXRfY2hhbmdlGAIgASgLMiYuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlRhcmdldENoYW5nZUgAEkMKD2RvY3VtZW50X2NoYW5nZRgDIAEoCzIoLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudENoYW5nZUgAEkMKD2RvY3VtZW50X2RlbGV0ZRgEIAEoCzIoLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudERlbGV0ZUgAEkMKD2RvY3VtZW50X3JlbW92ZRgGIAEoCzIoLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudFJlbW92ZUgAEjsKBmZpbHRlchgFIAEoCzIpLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5FeGlzdGVuY2VGaWx0ZXJIAEIPCg1yZXNwb25zZV90eXBlIrADCgZUYXJnZXQSPQoFcXVlcnkYAiABKAsyLC5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuVGFyZ2V0LlF1ZXJ5VGFyZ2V0SAASRQoJZG9jdW1lbnRzGAMgASgLMjAuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlRhcmdldC5Eb2N1bWVudHNUYXJnZXRIABIWCgxyZXN1bWVfdG9rZW4YBCABKAxIARIvCglyZWFkX3RpbWUYCyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAESEQoJdGFyZ2V0X2lkGAUgASgFEgwKBG9uY2UYBiABKAgaJAoPRG9jdW1lbnRzVGFyZ2V0EhEKCWRvY3VtZW50cxgCIAMoCRpyCgtRdWVyeVRhcmdldBIOCgZwYXJlbnQYASABKAkSRQoQc3RydWN0dXJlZF9xdWVyeRgCIAEoCzIpLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5TdHJ1Y3R1cmVkUXVlcnlIAEIMCgpxdWVyeV90eXBlQg0KC3RhcmdldF90eXBlQg0KC3Jlc3VtZV90eXBlIq8CCgxUYXJnZXRDaGFuZ2USUwoSdGFyZ2V0X2NoYW5nZV90eXBlGAEgASgOMjcuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlRhcmdldENoYW5nZS5UYXJnZXRDaGFuZ2VUeXBlEhIKCnRhcmdldF9pZHMYAiADKAUSIQoFY2F1c2UYAyABKAsyEi5nb29nbGUucnBjLlN0YXR1cxIUCgxyZXN1bWVfdG9rZW4YBCABKAwSLQoJcmVhZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJOChBUYXJnZXRDaGFuZ2VUeXBlEg0KCU5PX0NIQU5HRRAAEgcKA0FERBABEgoKBlJFTU9WRRACEgsKB0NVUlJFTlQQAxIJCgVSRVNFVBAEIlYKGExpc3RDb2xsZWN0aW9uSWRzUmVxdWVzdBITCgZwYXJlbnQYASABKAlCA+BBAhIRCglwYWdlX3NpemUYAiABKAUSEgoKcGFnZV90b2tlbhgDIAEoCSJMChlMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlEhYKDmNvbGxlY3Rpb25faWRzGAEgAygJEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSLTAQoRQmF0Y2hXcml0ZVJlcXVlc3QSFQoIZGF0YWJhc2UYASABKAlCA+BBAhIvCgZ3cml0ZXMYAiADKAsyHy5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuV3JpdGUSRwoGbGFiZWxzGAMgAygLMjcuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkJhdGNoV3JpdGVSZXF1ZXN0LkxhYmVsc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEidgoSQmF0Y2hXcml0ZVJlc3BvbnNlEjwKDXdyaXRlX3Jlc3VsdHMYASADKAsyJS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuV3JpdGVSZXN1bHQSIgoGc3RhdHVzGAIgAygLMhIuZ29vZ2xlLnJwYy5TdGF0dXMy5BgKCUZpcmVzdG9yZRKeAQoLR2V0RG9jdW1lbnQSLC5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuR2V0RG9jdW1lbnRSZXF1ZXN0GiIuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50Ij2C0+STAjcSNS92MWJldGExL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9EsEBCg1MaXN0RG9jdW1lbnRzEi4uZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkxpc3REb2N1bWVudHNSZXF1ZXN0Gi8uZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkxpc3REb2N1bWVudHNSZXNwb25zZSJPgtPkkwJJEkcvdjFiZXRhMS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9L3tjb2xsZWN0aW9uX2lkfRLOAQoOVXBkYXRlRG9jdW1lbnQSLy5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuVXBkYXRlRG9jdW1lbnRSZXF1ZXN0GiIuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkRvY3VtZW50ImfaQRRkb2N1bWVudCx1cGRhdGVfbWFza4LT5JMCSjoIZG9jdW1lbnQyPi92MWJldGExL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Ep8BCg5EZWxldGVEb2N1bWVudBIvLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5EZWxldGVEb2N1bWVudFJlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiRNpBBG5hbWWC0+STAjcqNS92MWJldGExL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9EsgBChFCYXRjaEdldERvY3VtZW50cxIyLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5CYXRjaEdldERvY3VtZW50c1JlcXVlc3QaMy5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZSJIgtPkkwJCOgEqIj0vdjFiZXRhMS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoR2V0MAES1gEKEEJlZ2luVHJhbnNhY3Rpb24SMS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuQmVnaW5UcmFuc2FjdGlvblJlcXVlc3QaMi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuQmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlIlvaQQhkYXRhYmFzZYLT5JMCSjoBKiJFL3YxYmV0YTEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiZWdpblRyYW5zYWN0aW9uErUBCgZDb21taXQSJy5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuQ29tbWl0UmVxdWVzdBooLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Db21taXRSZXNwb25zZSJY2kEPZGF0YWJhc2Usd3JpdGVzgtPkkwJAOgEqIjsvdjFiZXRhMS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmNvbW1pdBKuAQoIUm9sbGJhY2sSKS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuUm9sbGJhY2tSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5Il/aQRRkYXRhYmFzZSx0cmFuc2FjdGlvboLT5JMCQjoBKiI9L3YxYmV0YTEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFjaxL0AQoIUnVuUXVlcnkSKS5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuUnVuUXVlcnlSZXF1ZXN0GiouZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlJ1blF1ZXJ5UmVzcG9uc2UijgGC0+STAocBOgEqWkU6ASoiQC92MWJldGExL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnkiOy92MWJldGExL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5MAESkAIKDlBhcnRpdGlvblF1ZXJ5Ei8uZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLlBhcnRpdGlvblF1ZXJ5UmVxdWVzdBowLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5QYXJ0aXRpb25RdWVyeVJlc3BvbnNlIpoBgtPkkwKTAToBKlpLOgEqIkYvdjFiZXRhMS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5IkEvdjFiZXRhMS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeRKjAQoFV3JpdGUSJi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuV3JpdGVSZXF1ZXN0GicuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLldyaXRlUmVzcG9uc2UiRYLT5JMCPzoBKiI6L3YxYmV0YTEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czp3cml0ZSgBMAESpwEKBkxpc3RlbhInLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5MaXN0ZW5SZXF1ZXN0GiguZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkxpc3RlblJlc3BvbnNlIkaC0+STAkA6ASoiOy92MWJldGExL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuKAEwARKoAgoRTGlzdENvbGxlY3Rpb25JZHMSMi5nb29nbGUuZmlyZXN0b3JlLnYxYmV0YTEuTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0GjMuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkxpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2UiqQHaQQZwYXJlbnSC0+STApkBOgEqWk46ASoiSS92MWJldGExL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06bGlzdENvbGxlY3Rpb25JZHMiRC92MWJldGExL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzErMBCgpCYXRjaFdyaXRlEisuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkJhdGNoV3JpdGVSZXF1ZXN0GiwuZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkJhdGNoV3JpdGVSZXNwb25zZSJKgtPkkwJEOgEqIj8vdjFiZXRhMS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJhdGNoV3JpdGUSvgEKDkNyZWF0ZURvY3VtZW50Ei8uZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExLkNyZWF0ZURvY3VtZW50UmVxdWVzdBoiLmdvb2dsZS5maXJlc3RvcmUudjFiZXRhMS5Eb2N1bWVudCJXgtPkkwJROghkb2N1bWVudCJFL3YxYmV0YTEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9GnbKQRhmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb23SQVhodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlQt8BChxjb20uZ29vZ2xlLmZpcmVzdG9yZS52MWJldGExQg5GaXJlc3RvcmVQcm90b1ABWkBjbG91ZC5nb29nbGUuY29tL2dvL2ZpcmVzdG9yZS9hcGl2MWJldGExL2ZpcmVzdG9yZXBiO2ZpcmVzdG9yZXBiogIER0NGU6oCHkdvb2dsZS5DbG91ZC5GaXJlc3RvcmUuVjFCZXRhMcoCHkdvb2dsZVxDbG91ZFxGaXJlc3RvcmVcVjFiZXRhMeoCIUdvb2dsZTo6Q2xvdWQ6OkZpcmVzdG9yZTo6VjFiZXRhMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_firestore_v1beta1_common, file_google_firestore_v1beta1_document, file_google_firestore_v1beta1_query, file_google_firestore_v1beta1_write, file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_rpc_status]);

/**
 * The request for [Firestore.GetDocument][google.firestore.v1beta1.Firestore.GetDocument].
 *
 * @generated from message google.firestore.v1beta1.GetDocumentRequest
 */
export type GetDocumentRequest = Message<"google.firestore.v1beta1.GetDocumentRequest"> & {
  /**
   * Required. The resource name of the Document to get. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 2;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.GetDocumentRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads the document in a transaction.
     *
     * @generated from field: bytes transaction = 3;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Reads the version of the document at the given time.
     * This may not be older than 270 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 5;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1beta1.GetDocumentRequest.
 * Use `create(GetDocumentRequestSchema)` to create a new message.
 */
export const GetDocumentRequestSchema: GenMessage<GetDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 0);

/**
 * The request for [Firestore.ListDocuments][google.firestore.v1beta1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1beta1.ListDocumentsRequest
 */
export type ListDocumentsRequest = Message<"google.firestore.v1beta1.ListDocumentsRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`
   * or `messages`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId: string;

  /**
   * The maximum number of documents to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * The `next_page_token` value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * The order to sort results by. For example: `priority desc, name`.
   *
   * @generated from field: string order_by = 6;
   */
  orderBy: string;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 7;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.ListDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 8;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 270 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 10;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * If the list should show missing documents. A missing document is a
   * document that does not exist but has sub-documents. These documents will
   * be returned with a key but will not have fields, [Document.create_time][google.firestore.v1beta1.Document.create_time],
   * or [Document.update_time][google.firestore.v1beta1.Document.update_time] set.
   *
   * Requests with `show_missing` may not specify `where` or
   * `order_by`.
   *
   * @generated from field: bool show_missing = 12;
   */
  showMissing: boolean;
};

/**
 * Describes the message google.firestore.v1beta1.ListDocumentsRequest.
 * Use `create(ListDocumentsRequestSchema)` to create a new message.
 */
export const ListDocumentsRequestSchema: GenMessage<ListDocumentsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 1);

/**
 * The response for [Firestore.ListDocuments][google.firestore.v1beta1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1beta1.ListDocumentsResponse
 */
export type ListDocumentsResponse = Message<"google.firestore.v1beta1.ListDocumentsResponse"> & {
  /**
   * The Documents found.
   *
   * @generated from field: repeated google.firestore.v1beta1.Document documents = 1;
   */
  documents: Document[];

  /**
   * The next page token.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1beta1.ListDocumentsResponse.
 * Use `create(ListDocumentsResponseSchema)` to create a new message.
 */
export const ListDocumentsResponseSchema: GenMessage<ListDocumentsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 2);

/**
 * The request for [Firestore.CreateDocument][google.firestore.v1beta1.Firestore.CreateDocument].
 *
 * @generated from message google.firestore.v1beta1.CreateDocumentRequest
 */
export type CreateDocumentRequest = Message<"google.firestore.v1beta1.CreateDocumentRequest"> & {
  /**
   * Required. The parent resource. For example:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId: string;

  /**
   * The client-assigned document ID to use for this document.
   *
   * Optional. If not specified, an ID will be assigned by the service.
   *
   * @generated from field: string document_id = 3;
   */
  documentId: string;

  /**
   * Required. The document to create. `name` must not be set.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 4;
   */
  document?: Document;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 5;
   */
  mask?: DocumentMask;
};

/**
 * Describes the message google.firestore.v1beta1.CreateDocumentRequest.
 * Use `create(CreateDocumentRequestSchema)` to create a new message.
 */
export const CreateDocumentRequestSchema: GenMessage<CreateDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 3);

/**
 * The request for [Firestore.UpdateDocument][google.firestore.v1beta1.Firestore.UpdateDocument].
 *
 * @generated from message google.firestore.v1beta1.UpdateDocumentRequest
 */
export type UpdateDocumentRequest = Message<"google.firestore.v1beta1.UpdateDocumentRequest"> & {
  /**
   * Required. The updated document.
   * Creates the document if it does not already exist.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The fields to update.
   * None of the field paths in the mask may contain a reserved name.
   *
   * If the document exists on the server and has fields not referenced in the
   * mask, they are left unchanged.
   * Fields referenced in the mask, but not present in the input document, are
   * deleted from the document on the server.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask update_mask = 2;
   */
  updateMask?: DocumentMask;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1beta1.Precondition current_document = 4;
   */
  currentDocument?: Precondition;
};

/**
 * Describes the message google.firestore.v1beta1.UpdateDocumentRequest.
 * Use `create(UpdateDocumentRequestSchema)` to create a new message.
 */
export const UpdateDocumentRequestSchema: GenMessage<UpdateDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 4);

/**
 * The request for [Firestore.DeleteDocument][google.firestore.v1beta1.Firestore.DeleteDocument].
 *
 * @generated from message google.firestore.v1beta1.DeleteDocumentRequest
 */
export type DeleteDocumentRequest = Message<"google.firestore.v1beta1.DeleteDocumentRequest"> & {
  /**
   * Required. The resource name of the Document to delete. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1beta1.Precondition current_document = 2;
   */
  currentDocument?: Precondition;
};

/**
 * Describes the message google.firestore.v1beta1.DeleteDocumentRequest.
 * Use `create(DeleteDocumentRequestSchema)` to create a new message.
 */
export const DeleteDocumentRequestSchema: GenMessage<DeleteDocumentRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 5);

/**
 * The request for [Firestore.BatchGetDocuments][google.firestore.v1beta1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1beta1.BatchGetDocumentsRequest
 */
export type BatchGetDocumentsRequest = Message<"google.firestore.v1beta1.BatchGetDocumentsRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of the
   * given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[];

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field will
   * not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.BatchGetDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 4;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions new_transaction = 5;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 270 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1beta1.BatchGetDocumentsRequest.
 * Use `create(BatchGetDocumentsRequestSchema)` to create a new message.
 */
export const BatchGetDocumentsRequestSchema: GenMessage<BatchGetDocumentsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 6);

/**
 * The streamed response for [Firestore.BatchGetDocuments][google.firestore.v1beta1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1beta1.BatchGetDocumentsResponse
 */
export type BatchGetDocumentsResponse = Message<"google.firestore.v1beta1.BatchGetDocumentsResponse"> & {
  /**
   * A single result.
   * This can be empty if the server is just returning a transaction.
   *
   * @generated from oneof google.firestore.v1beta1.BatchGetDocumentsResponse.result
   */
  result: {
    /**
     * A document that was requested.
     *
     * @generated from field: google.firestore.v1beta1.Document found = 1;
     */
    value: Document;
    case: "found";
  } | {
    /**
     * A document name that was requested but does not exist. In the format:
     * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     * @generated from field: string missing = 2;
     */
    value: string;
    case: "missing";
  } | { case: undefined; value?: undefined };

  /**
   * The transaction that was started as part of this request.
   * Will only be set in the first response, and only if
   * [BatchGetDocumentsRequest.new_transaction][google.firestore.v1beta1.BatchGetDocumentsRequest.new_transaction] was set in the request.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction: Uint8Array;

  /**
   * The time at which the document was read.
   * This may be monotically increasing, in this case the previous documents in
   * the result stream are guaranteed not to have changed between their
   * read_time and this one.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 4;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1beta1.BatchGetDocumentsResponse.
 * Use `create(BatchGetDocumentsResponseSchema)` to create a new message.
 */
export const BatchGetDocumentsResponseSchema: GenMessage<BatchGetDocumentsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 7);

/**
 * The request for [Firestore.BeginTransaction][google.firestore.v1beta1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1beta1.BeginTransactionRequest
 */
export type BeginTransactionRequest = Message<"google.firestore.v1beta1.BeginTransactionRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The options for the transaction.
   * Defaults to a read-write transaction.
   *
   * @generated from field: google.firestore.v1beta1.TransactionOptions options = 2;
   */
  options?: TransactionOptions;
};

/**
 * Describes the message google.firestore.v1beta1.BeginTransactionRequest.
 * Use `create(BeginTransactionRequestSchema)` to create a new message.
 */
export const BeginTransactionRequestSchema: GenMessage<BeginTransactionRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 8);

/**
 * The response for [Firestore.BeginTransaction][google.firestore.v1beta1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1beta1.BeginTransactionResponse
 */
export type BeginTransactionResponse = Message<"google.firestore.v1beta1.BeginTransactionResponse"> & {
  /**
   * The transaction that was started.
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1beta1.BeginTransactionResponse.
 * Use `create(BeginTransactionResponseSchema)` to create a new message.
 */
export const BeginTransactionResponseSchema: GenMessage<BeginTransactionResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 9);

/**
 * The request for [Firestore.Commit][google.firestore.v1beta1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1beta1.CommitRequest
 */
export type CommitRequest = Message<"google.firestore.v1beta1.CommitRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   *
   * @generated from field: repeated google.firestore.v1beta1.Write writes = 2;
   */
  writes: Write[];

  /**
   * If set, applies all writes in this transaction, and commits it.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1beta1.CommitRequest.
 * Use `create(CommitRequestSchema)` to create a new message.
 */
export const CommitRequestSchema: GenMessage<CommitRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 10);

/**
 * The response for [Firestore.Commit][google.firestore.v1beta1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1beta1.CommitResponse
 */
export type CommitResponse = Message<"google.firestore.v1beta1.CommitResponse"> & {
  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1beta1.WriteResult write_results = 1;
   */
  writeResults: WriteResult[];

  /**
   * The time at which the commit occurred. Any read with an equal or greater
   * `read_time` is guaranteed to see the effects of the commit.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 2;
   */
  commitTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1beta1.CommitResponse.
 * Use `create(CommitResponseSchema)` to create a new message.
 */
export const CommitResponseSchema: GenMessage<CommitResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 11);

/**
 * The request for [Firestore.Rollback][google.firestore.v1beta1.Firestore.Rollback].
 *
 * @generated from message google.firestore.v1beta1.RollbackRequest
 */
export type RollbackRequest = Message<"google.firestore.v1beta1.RollbackRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * Required. The transaction to roll back.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.firestore.v1beta1.RollbackRequest.
 * Use `create(RollbackRequestSchema)` to create a new message.
 */
export const RollbackRequestSchema: GenMessage<RollbackRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 12);

/**
 * The request for [Firestore.RunQuery][google.firestore.v1beta1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1beta1.RunQueryRequest
 */
export type RunQueryRequest = Message<"google.firestore.v1beta1.RunQueryRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1beta1.RunQueryRequest.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1beta1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.RunQueryRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 5;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions new_transaction = 6;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 270 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1beta1.RunQueryRequest.
 * Use `create(RunQueryRequestSchema)` to create a new message.
 */
export const RunQueryRequestSchema: GenMessage<RunQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 13);

/**
 * The response for [Firestore.RunQuery][google.firestore.v1beta1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1beta1.RunQueryResponse
 */
export type RunQueryResponse = Message<"google.firestore.v1beta1.RunQueryResponse"> & {
  /**
   * The transaction that was started as part of this request.
   * Can only be set in the first response, and only if
   * [RunQueryRequest.new_transaction][google.firestore.v1beta1.RunQueryRequest.new_transaction] was set in the request.
   * If set, no other fields will be set in this response.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction: Uint8Array;

  /**
   * A query result.
   * Not set when reporting partial progress.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The time at which the document was read. This may be monotonically
   * increasing; in this case, the previous documents in the result stream are
   * guaranteed not to have changed between their `read_time` and this one.
   *
   * If the query returns no results, a response with `read_time` and no
   * `document` will be sent, and this represents the time at which the query
   * was run.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 3;
   */
  readTime?: Timestamp;

  /**
   * The number of results that have been skipped due to an offset between
   * the last response and the current response.
   *
   * @generated from field: int32 skipped_results = 4;
   */
  skippedResults: number;
};

/**
 * Describes the message google.firestore.v1beta1.RunQueryResponse.
 * Use `create(RunQueryResponseSchema)` to create a new message.
 */
export const RunQueryResponseSchema: GenMessage<RunQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 14);

/**
 * The request for [Firestore.PartitionQuery][google.firestore.v1beta1.Firestore.PartitionQuery].
 *
 * @generated from message google.firestore.v1beta1.PartitionQueryRequest
 */
export type PartitionQueryRequest = Message<"google.firestore.v1beta1.PartitionQueryRequest"> & {
  /**
   * Required. The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents`.
   * Document resource names are not supported; only database resource names
   * can be specified.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to partition.
   *
   * @generated from oneof google.firestore.v1beta1.PartitionQueryRequest.query_type
   */
  queryType: {
    /**
     * A structured query.
     * Query must specify collection with all descendants and be ordered by name
     * ascending. Other filters, order bys, limits, offsets, and start/end
     * cursors are not supported.
     *
     * @generated from field: google.firestore.v1beta1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The desired maximum number of partition points.
   * The partitions may be returned across multiple pages of results.
   * The number must be positive. The actual number of partitions
   * returned may be fewer.
   *
   * For example, this may be set to one fewer than the number of parallel
   * queries to be run, or in running a data pipeline job, one fewer than the
   * number of workers or compute instances available.
   *
   * @generated from field: int64 partition_count = 3;
   */
  partitionCount: bigint;

  /**
   * The `next_page_token` value returned from a previous call to
   * PartitionQuery that may be used to get an additional set of results.
   * There are no ordering guarantees between sets of results. Thus, using
   * multiple sets of results will require merging the different result sets.
   *
   * For example, two subsequent calls using a page_token may return:
   *
   *  * cursor B, cursor M, cursor Q
   *  * cursor A, cursor U, cursor W
   *
   * To obtain a complete result set ordered with respect to the results of the
   * query supplied to PartitionQuery, the results sets should be merged:
   * cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * The maximum number of partitions to return in this call, subject to
   * `partition_count`.
   *
   * For example, if `partition_count` = 10 and `page_size` = 8, the first call
   * to PartitionQuery will return up to 8 partitions and a `next_page_token`
   * if more results exist. A second call to PartitionQuery will return up to
   * 2 partitions, to complete the total of 10 specified in `partition_count`.
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize: number;
};

/**
 * Describes the message google.firestore.v1beta1.PartitionQueryRequest.
 * Use `create(PartitionQueryRequestSchema)` to create a new message.
 */
export const PartitionQueryRequestSchema: GenMessage<PartitionQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 15);

/**
 * The response for [Firestore.PartitionQuery][google.firestore.v1beta1.Firestore.PartitionQuery].
 *
 * @generated from message google.firestore.v1beta1.PartitionQueryResponse
 */
export type PartitionQueryResponse = Message<"google.firestore.v1beta1.PartitionQueryResponse"> & {
  /**
   * Partition results.
   * Each partition is a split point that can be used by RunQuery as a starting
   * or end point for the query results. The RunQuery requests must be made with
   * the same query supplied to this PartitionQuery request. The partition
   * cursors will be ordered according to same ordering as the results of the
   * query supplied to PartitionQuery.
   *
   * For example, if a PartitionQuery request returns partition cursors A and B,
   * running the following three queries will return the entire result set of
   * the original query:
   *
   *  * query, end_at A
   *  * query, start_at A, end_at B
   *  * query, start_at B
   *
   * An empty result may indicate that the query has too few results to be
   * partitioned.
   *
   * @generated from field: repeated google.firestore.v1beta1.Cursor partitions = 1;
   */
  partitions: Cursor[];

  /**
   * A page token that may be used to request an additional set of results, up
   * to the number specified by `partition_count` in the PartitionQuery request.
   * If blank, there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1beta1.PartitionQueryResponse.
 * Use `create(PartitionQueryResponseSchema)` to create a new message.
 */
export const PartitionQueryResponseSchema: GenMessage<PartitionQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 16);

/**
 * The request for [Firestore.Write][google.firestore.v1beta1.Firestore.Write].
 *
 * The first request creates a stream, or resumes an existing one from a token.
 *
 * When creating a new stream, the server replies with a response containing
 * only an ID and a token, to use in the next request.
 *
 * When resuming a stream, the server first streams any responses later than the
 * given token, then a response containing only an up-to-date token, to use in
 * the next request.
 *
 * @generated from message google.firestore.v1beta1.WriteRequest
 */
export type WriteRequest = Message<"google.firestore.v1beta1.WriteRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   * This is only required in the first message.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The ID of the write stream to resume.
   * This may only be set in the first message. When left empty, a new write
   * stream will be created.
   *
   * @generated from field: string stream_id = 2;
   */
  streamId: string;

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   * This must be empty on the first request.
   * This may be empty on the last request.
   * This must not be empty on all other requests.
   *
   * @generated from field: repeated google.firestore.v1beta1.Write writes = 3;
   */
  writes: Write[];

  /**
   * A stream token that was previously sent by the server.
   *
   * The client should set this field to the token from the most recent
   * [WriteResponse][google.firestore.v1beta1.WriteResponse] it has received. This acknowledges that the client has
   * received responses up to this token. After sending this token, earlier
   * tokens may not be used anymore.
   *
   * The server may close the stream if there are too many unacknowledged
   * responses.
   *
   * Leave this field unset when creating a new stream. To resume a stream at
   * a specific point, set this field and the `stream_id` field.
   *
   * Leave this field unset when creating a new stream.
   *
   * @generated from field: bytes stream_token = 4;
   */
  streamToken: Uint8Array;

  /**
   * Labels associated with this write request.
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1beta1.WriteRequest.
 * Use `create(WriteRequestSchema)` to create a new message.
 */
export const WriteRequestSchema: GenMessage<WriteRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 17);

/**
 * The response for [Firestore.Write][google.firestore.v1beta1.Firestore.Write].
 *
 * @generated from message google.firestore.v1beta1.WriteResponse
 */
export type WriteResponse = Message<"google.firestore.v1beta1.WriteResponse"> & {
  /**
   * The ID of the stream.
   * Only set on the first message, when a new stream was created.
   *
   * @generated from field: string stream_id = 1;
   */
  streamId: string;

  /**
   * A token that represents the position of this response in the stream.
   * This can be used by a client to resume the stream at this point.
   *
   * This field is always set.
   *
   * @generated from field: bytes stream_token = 2;
   */
  streamToken: Uint8Array;

  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1beta1.WriteResult write_results = 3;
   */
  writeResults: WriteResult[];

  /**
   * The time at which the commit occurred. Any read with an equal or greater
   * `read_time` is guaranteed to see the effects of the write.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 4;
   */
  commitTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1beta1.WriteResponse.
 * Use `create(WriteResponseSchema)` to create a new message.
 */
export const WriteResponseSchema: GenMessage<WriteResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 18);

/**
 * A request for [Firestore.Listen][google.firestore.v1beta1.Firestore.Listen]
 *
 * @generated from message google.firestore.v1beta1.ListenRequest
 */
export type ListenRequest = Message<"google.firestore.v1beta1.ListenRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The supported target changes.
   *
   * @generated from oneof google.firestore.v1beta1.ListenRequest.target_change
   */
  targetChange: {
    /**
     * A target to add to this stream.
     *
     * @generated from field: google.firestore.v1beta1.Target add_target = 2;
     */
    value: Target;
    case: "addTarget";
  } | {
    /**
     * The ID of a target to remove from this stream.
     *
     * @generated from field: int32 remove_target = 3;
     */
    value: number;
    case: "removeTarget";
  } | { case: undefined; value?: undefined };

  /**
   * Labels associated with this target change.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1beta1.ListenRequest.
 * Use `create(ListenRequestSchema)` to create a new message.
 */
export const ListenRequestSchema: GenMessage<ListenRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 19);

/**
 * The response for [Firestore.Listen][google.firestore.v1beta1.Firestore.Listen].
 *
 * @generated from message google.firestore.v1beta1.ListenResponse
 */
export type ListenResponse = Message<"google.firestore.v1beta1.ListenResponse"> & {
  /**
   * The supported responses.
   *
   * @generated from oneof google.firestore.v1beta1.ListenResponse.response_type
   */
  responseType: {
    /**
     * Targets have changed.
     *
     * @generated from field: google.firestore.v1beta1.TargetChange target_change = 2;
     */
    value: TargetChange;
    case: "targetChange";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has changed.
     *
     * @generated from field: google.firestore.v1beta1.DocumentChange document_change = 3;
     */
    value: DocumentChange;
    case: "documentChange";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has been deleted.
     *
     * @generated from field: google.firestore.v1beta1.DocumentDelete document_delete = 4;
     */
    value: DocumentDelete;
    case: "documentDelete";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has been removed from a target (because it is no longer
     * relevant to that target).
     *
     * @generated from field: google.firestore.v1beta1.DocumentRemove document_remove = 6;
     */
    value: DocumentRemove;
    case: "documentRemove";
  } | {
    /**
     * A filter to apply to the set of documents previously returned for the
     * given target.
     *
     * Returned when documents may have been removed from the given target, but
     * the exact documents are unknown.
     *
     * @generated from field: google.firestore.v1beta1.ExistenceFilter filter = 5;
     */
    value: ExistenceFilter;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1beta1.ListenResponse.
 * Use `create(ListenResponseSchema)` to create a new message.
 */
export const ListenResponseSchema: GenMessage<ListenResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 20);

/**
 * A specification of a set of documents to listen to.
 *
 * @generated from message google.firestore.v1beta1.Target
 */
export type Target = Message<"google.firestore.v1beta1.Target"> & {
  /**
   * The type of target to listen to.
   *
   * @generated from oneof google.firestore.v1beta1.Target.target_type
   */
  targetType: {
    /**
     * A target specified by a query.
     *
     * @generated from field: google.firestore.v1beta1.Target.QueryTarget query = 2;
     */
    value: Target_QueryTarget;
    case: "query";
  } | {
    /**
     * A target specified by a set of document names.
     *
     * @generated from field: google.firestore.v1beta1.Target.DocumentsTarget documents = 3;
     */
    value: Target_DocumentsTarget;
    case: "documents";
  } | { case: undefined; value?: undefined };

  /**
   * When to start listening.
   *
   * If not specified, all matching Documents are returned before any
   * subsequent changes.
   *
   * @generated from oneof google.firestore.v1beta1.Target.resume_type
   */
  resumeType: {
    /**
     * A resume token from a prior [TargetChange][google.firestore.v1beta1.TargetChange] for an identical target.
     *
     * Using a resume token with a different target is unsupported and may fail.
     *
     * @generated from field: bytes resume_token = 4;
     */
    value: Uint8Array;
    case: "resumeToken";
  } | {
    /**
     * Start listening after a specific `read_time`.
     *
     * The client must know the state of matching documents at this time.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 11;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };

  /**
   * The target ID that identifies the target on the stream. Must be a positive
   * number and non-zero.
   *
   * @generated from field: int32 target_id = 5;
   */
  targetId: number;

  /**
   * If the target should be removed once it is current and consistent.
   *
   * @generated from field: bool once = 6;
   */
  once: boolean;
};

/**
 * Describes the message google.firestore.v1beta1.Target.
 * Use `create(TargetSchema)` to create a new message.
 */
export const TargetSchema: GenMessage<Target> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 21);

/**
 * A target specified by a set of documents names.
 *
 * @generated from message google.firestore.v1beta1.Target.DocumentsTarget
 */
export type Target_DocumentsTarget = Message<"google.firestore.v1beta1.Target.DocumentsTarget"> & {
  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of
   * the given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[];
};

/**
 * Describes the message google.firestore.v1beta1.Target.DocumentsTarget.
 * Use `create(Target_DocumentsTargetSchema)` to create a new message.
 */
export const Target_DocumentsTargetSchema: GenMessage<Target_DocumentsTarget> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 21, 0);

/**
 * A target specified by a query.
 *
 * @generated from message google.firestore.v1beta1.Target.QueryTarget
 */
export type Target_QueryTarget = Message<"google.firestore.v1beta1.Target.QueryTarget"> & {
  /**
   * The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1beta1.Target.QueryTarget.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1beta1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.firestore.v1beta1.Target.QueryTarget.
 * Use `create(Target_QueryTargetSchema)` to create a new message.
 */
export const Target_QueryTargetSchema: GenMessage<Target_QueryTarget> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 21, 1);

/**
 * Targets being watched have changed.
 *
 * @generated from message google.firestore.v1beta1.TargetChange
 */
export type TargetChange = Message<"google.firestore.v1beta1.TargetChange"> & {
  /**
   * The type of change that occurred.
   *
   * @generated from field: google.firestore.v1beta1.TargetChange.TargetChangeType target_change_type = 1;
   */
  targetChangeType: TargetChange_TargetChangeType;

  /**
   * The target IDs of targets that have changed.
   *
   * If empty, the change applies to all targets.
   *
   * The order of the target IDs is not defined.
   *
   * @generated from field: repeated int32 target_ids = 2;
   */
  targetIds: number[];

  /**
   * The error that resulted in this change, if applicable.
   *
   * @generated from field: google.rpc.Status cause = 3;
   */
  cause?: Status;

  /**
   * A token that can be used to resume the stream for the given `target_ids`,
   * or all targets if `target_ids` is empty.
   *
   * Not set on every target change.
   *
   * @generated from field: bytes resume_token = 4;
   */
  resumeToken: Uint8Array;

  /**
   * The consistent `read_time` for the given `target_ids` (omitted when the
   * target_ids are not at a consistent snapshot).
   *
   * The stream is guaranteed to send a `read_time` with `target_ids` empty
   * whenever the entire stream reaches a new consistent snapshot. ADD,
   * CURRENT, and RESET messages are guaranteed to (eventually) result in a
   * new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
   *
   * For a given stream, `read_time` is guaranteed to be monotonically
   * increasing.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 6;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.firestore.v1beta1.TargetChange.
 * Use `create(TargetChangeSchema)` to create a new message.
 */
export const TargetChangeSchema: GenMessage<TargetChange> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 22);

/**
 * The type of change.
 *
 * @generated from enum google.firestore.v1beta1.TargetChange.TargetChangeType
 */
export enum TargetChange_TargetChangeType {
  /**
   * No change has occurred. Used only to send an updated `resume_token`.
   *
   * @generated from enum value: NO_CHANGE = 0;
   */
  NO_CHANGE = 0,

  /**
   * The targets have been added.
   *
   * @generated from enum value: ADD = 1;
   */
  ADD = 1,

  /**
   * The targets have been removed.
   *
   * @generated from enum value: REMOVE = 2;
   */
  REMOVE = 2,

  /**
   * The targets reflect all changes committed before the targets were added
   * to the stream.
   *
   * This will be sent after or with a `read_time` that is greater than or
   * equal to the time at which the targets were added.
   *
   * Listeners can wait for this change if read-after-write semantics
   * are desired.
   *
   * @generated from enum value: CURRENT = 3;
   */
  CURRENT = 3,

  /**
   * The targets have been reset, and a new initial state for the targets
   * will be returned in subsequent changes.
   *
   * After the initial state is complete, `CURRENT` will be returned even
   * if the target was previously indicated to be `CURRENT`.
   *
   * @generated from enum value: RESET = 4;
   */
  RESET = 4,
}

/**
 * Describes the enum google.firestore.v1beta1.TargetChange.TargetChangeType.
 */
export const TargetChange_TargetChangeTypeSchema: GenEnum<TargetChange_TargetChangeType> = /*@__PURE__*/
  enumDesc(file_google_firestore_v1beta1_firestore, 22, 0);

/**
 * The request for [Firestore.ListCollectionIds][google.firestore.v1beta1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1beta1.ListCollectionIdsRequest
 */
export type ListCollectionIdsRequest = Message<"google.firestore.v1beta1.ListCollectionIdsRequest"> & {
  /**
   * Required. The parent document. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of results to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token. Must be a value from
   * [ListCollectionIdsResponse][google.firestore.v1beta1.ListCollectionIdsResponse].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.firestore.v1beta1.ListCollectionIdsRequest.
 * Use `create(ListCollectionIdsRequestSchema)` to create a new message.
 */
export const ListCollectionIdsRequestSchema: GenMessage<ListCollectionIdsRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 23);

/**
 * The response from [Firestore.ListCollectionIds][google.firestore.v1beta1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1beta1.ListCollectionIdsResponse
 */
export type ListCollectionIdsResponse = Message<"google.firestore.v1beta1.ListCollectionIdsResponse"> & {
  /**
   * The collection ids.
   *
   * @generated from field: repeated string collection_ids = 1;
   */
  collectionIds: string[];

  /**
   * A page token that may be used to continue the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.firestore.v1beta1.ListCollectionIdsResponse.
 * Use `create(ListCollectionIdsResponseSchema)` to create a new message.
 */
export const ListCollectionIdsResponseSchema: GenMessage<ListCollectionIdsResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 24);

/**
 * The request for [Firestore.BatchWrite][google.firestore.v1beta1.Firestore.BatchWrite].
 *
 * @generated from message google.firestore.v1beta1.BatchWriteRequest
 */
export type BatchWriteRequest = Message<"google.firestore.v1beta1.BatchWriteRequest"> & {
  /**
   * Required. The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * The writes to apply.
   *
   * Method does not apply writes atomically and does not guarantee ordering.
   * Each write succeeds or fails independently. You cannot write to the same
   * document more than once per request.
   *
   * @generated from field: repeated google.firestore.v1beta1.Write writes = 2;
   */
  writes: Write[];

  /**
   * Labels associated with this batch write.
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.firestore.v1beta1.BatchWriteRequest.
 * Use `create(BatchWriteRequestSchema)` to create a new message.
 */
export const BatchWriteRequestSchema: GenMessage<BatchWriteRequest> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 25);

/**
 * The response from [Firestore.BatchWrite][google.firestore.v1beta1.Firestore.BatchWrite].
 *
 * @generated from message google.firestore.v1beta1.BatchWriteResponse
 */
export type BatchWriteResponse = Message<"google.firestore.v1beta1.BatchWriteResponse"> & {
  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1beta1.WriteResult write_results = 1;
   */
  writeResults: WriteResult[];

  /**
   * The status of applying the writes.
   *
   * This i-th write status corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.rpc.Status status = 2;
   */
  status: Status[];
};

/**
 * Describes the message google.firestore.v1beta1.BatchWriteResponse.
 * Use `create(BatchWriteResponseSchema)` to create a new message.
 */
export const BatchWriteResponseSchema: GenMessage<BatchWriteResponse> = /*@__PURE__*/
  messageDesc(file_google_firestore_v1beta1_firestore, 26);

/**
 * The Cloud Firestore service.
 *
 * Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
 * document database that simplifies storing, syncing, and querying data for
 * your mobile, web, and IoT apps at global scale. Its client libraries provide
 * live synchronization and offline support, while its security features and
 * integrations with Firebase and Google Cloud Platform (GCP) accelerate
 * building truly serverless apps.
 *
 * @generated from service google.firestore.v1beta1.Firestore
 */
export const Firestore: GenService<{
  /**
   * Gets a single document.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.GetDocument
   */
  getDocument: {
    methodKind: "unary";
    input: typeof GetDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
  /**
   * Lists documents.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.ListDocuments
   */
  listDocuments: {
    methodKind: "unary";
    input: typeof ListDocumentsRequestSchema;
    output: typeof ListDocumentsResponseSchema;
  },
  /**
   * Updates or inserts a document.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.UpdateDocument
   */
  updateDocument: {
    methodKind: "unary";
    input: typeof UpdateDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
  /**
   * Deletes a document.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.DeleteDocument
   */
  deleteDocument: {
    methodKind: "unary";
    input: typeof DeleteDocumentRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets multiple documents.
   *
   * Documents returned by this method are not guaranteed to be returned in the
   * same order that they were requested.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.BatchGetDocuments
   */
  batchGetDocuments: {
    methodKind: "server_streaming";
    input: typeof BatchGetDocumentsRequestSchema;
    output: typeof BatchGetDocumentsResponseSchema;
  },
  /**
   * Starts a new transaction.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.BeginTransaction
   */
  beginTransaction: {
    methodKind: "unary";
    input: typeof BeginTransactionRequestSchema;
    output: typeof BeginTransactionResponseSchema;
  },
  /**
   * Commits a transaction, while optionally updating documents.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.Commit
   */
  commit: {
    methodKind: "unary";
    input: typeof CommitRequestSchema;
    output: typeof CommitResponseSchema;
  },
  /**
   * Rolls back a transaction.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.Rollback
   */
  rollback: {
    methodKind: "unary";
    input: typeof RollbackRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Runs a query.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.RunQuery
   */
  runQuery: {
    methodKind: "server_streaming";
    input: typeof RunQueryRequestSchema;
    output: typeof RunQueryResponseSchema;
  },
  /**
   * Partitions a query by returning partition cursors that can be used to run
   * the query in parallel. The returned partition cursors are split points that
   * can be used by RunQuery as starting/end points for the query results.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.PartitionQuery
   */
  partitionQuery: {
    methodKind: "unary";
    input: typeof PartitionQueryRequestSchema;
    output: typeof PartitionQueryResponseSchema;
  },
  /**
   * Streams batches of document updates and deletes, in order.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.Write
   */
  write: {
    methodKind: "bidi_streaming";
    input: typeof WriteRequestSchema;
    output: typeof WriteResponseSchema;
  },
  /**
   * Listens to changes.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.Listen
   */
  listen: {
    methodKind: "bidi_streaming";
    input: typeof ListenRequestSchema;
    output: typeof ListenResponseSchema;
  },
  /**
   * Lists all the collection IDs underneath a document.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.ListCollectionIds
   */
  listCollectionIds: {
    methodKind: "unary";
    input: typeof ListCollectionIdsRequestSchema;
    output: typeof ListCollectionIdsResponseSchema;
  },
  /**
   * Applies a batch of write operations.
   *
   * The BatchWrite method does not apply the write operations atomically
   * and can apply them out of order. Method does not allow more than one write
   * per document. Each write succeeds or fails independently. See the
   * [BatchWriteResponse][google.firestore.v1beta1.BatchWriteResponse] for the success status of each write.
   *
   * If you require an atomically applied set of writes, use
   * [Commit][google.firestore.v1beta1.Firestore.Commit] instead.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.BatchWrite
   */
  batchWrite: {
    methodKind: "unary";
    input: typeof BatchWriteRequestSchema;
    output: typeof BatchWriteResponseSchema;
  },
  /**
   * Creates a new document.
   *
   * @generated from rpc google.firestore.v1beta1.Firestore.CreateDocument
   */
  createDocument: {
    methodKind: "unary";
    input: typeof CreateDocumentRequestSchema;
    output: typeof DocumentSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_firestore_v1beta1_firestore, 0);

