// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/maps/fleetengine/v1/vehicles.proto (package maps.fleetengine.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { NavigationStatus, TerminalLocation, TripType, TripWaypoint, VehicleAttribute, VehicleLocation } from "./fleetengine_pb";
import { file_google_maps_fleetengine_v1_fleetengine } from "./fleetengine_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/maps/fleetengine/v1/vehicles.proto.
 */
export const file_google_maps_fleetengine_v1_vehicles: GenFile = /*@__PURE__*/
  fileDesc("Cilnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhpY2xlcy5wcm90bxITbWFwcy5mbGVldGVuZ2luZS52MSLiCwoHVmVoaWNsZRIRCgRuYW1lGAEgASgJQgPgQQMSOAoNdmVoaWNsZV9zdGF0ZRgCIAEoDjIhLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZVN0YXRlEjsKFHN1cHBvcnRlZF90cmlwX3R5cGVzGAMgAygOMh0ubWFwcy5mbGVldGVuZ2luZS52MS5UcmlwVHlwZRIaCg1jdXJyZW50X3RyaXBzGAQgAygJQgPgQQMSOwoNbGFzdF9sb2NhdGlvbhgFIAEoCzIkLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZUxvY2F0aW9uEhgKEG1heGltdW1fY2FwYWNpdHkYBiABKAUSOQoKYXR0cmlidXRlcxgIIAMoCzIlLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZUF0dHJpYnV0ZRJDCgx2ZWhpY2xlX3R5cGUYCSABKAsyKC5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGUuVmVoaWNsZVR5cGVCA+BBAhI4Cg1saWNlbnNlX3BsYXRlGAogASgLMiEubWFwcy5mbGVldGVuZ2luZS52MS5MaWNlbnNlUGxhdGUSOAoFcm91dGUYDCADKAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRlcm1pbmFsTG9jYXRpb25CAhgBEh0KFWN1cnJlbnRfcm91dGVfc2VnbWVudBgUIAEoCRJUCh1jdXJyZW50X3JvdXRlX3NlZ21lbnRfdHJhZmZpYxgcIAEoCzIoLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJhZmZpY1BvbHlsaW5lRGF0YUID4EEEEkYKHWN1cnJlbnRfcm91dGVfc2VnbWVudF92ZXJzaW9uGA8gASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEkoKH2N1cnJlbnRfcm91dGVfc2VnbWVudF9lbmRfcG9pbnQYGCABKAsyIS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBXYXlwb2ludBI+ChlyZW1haW5pbmdfZGlzdGFuY2VfbWV0ZXJzGBIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUSOQoVZXRhX3RvX2ZpcnN0X3dheXBvaW50GBMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJAChZyZW1haW5pbmdfdGltZV9zZWNvbmRzGBkgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVCA+BBBBI0Cgl3YXlwb2ludHMYFiADKAsyIS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBXYXlwb2ludBI6ChF3YXlwb2ludHNfdmVyc2lvbhgQIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxIcChRiYWNrX3RvX2JhY2tfZW5hYmxlZBgXIAEoCBJAChFuYXZpZ2F0aW9uX3N0YXR1cxgaIAEoDjIlLm1hcHMuZmxlZXRlbmdpbmUudjEuTmF2aWdhdGlvblN0YXR1cxJBCg9kZXZpY2Vfc2V0dGluZ3MYGyABKAsyIy5tYXBzLmZsZWV0ZW5naW5lLnYxLkRldmljZVNldHRpbmdzQgPgQQQauAEKC1ZlaGljbGVUeXBlEkMKCGNhdGVnb3J5GAEgASgOMjEubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlLlZlaGljbGVUeXBlLkNhdGVnb3J5ImQKCENhdGVnb3J5EgsKB1VOS05PV04QABIICgRBVVRPEAESCAoEVEFYSRACEgkKBVRSVUNLEAMSDwoLVFdPX1dIRUVMRVIQBBILCgdCSUNZQ0xFEAUSDgoKUEVERVNUUklBThAGOlDqQU0KImZsZWV0ZW5naW5lLmdvb2dsZWFwaXMuY29tL1ZlaGljbGUSJ3Byb3ZpZGVycy97cHJvdmlkZXJ9L3ZlaGljbGVzL3t2ZWhpY2xlfSKdAQoLQmF0dGVyeUluZm8SOgoOYmF0dGVyeV9zdGF0dXMYASABKA4yIi5tYXBzLmZsZWV0ZW5naW5lLnYxLkJhdHRlcnlTdGF0dXMSNgoMcG93ZXJfc291cmNlGAIgASgOMiAubWFwcy5mbGVldGVuZ2luZS52MS5Qb3dlclNvdXJjZRIaChJiYXR0ZXJ5X3BlcmNlbnRhZ2UYAyABKAIiygEKDkRldmljZVNldHRpbmdzEkwKGGxvY2F0aW9uX3Bvd2VyX3NhdmVfbW9kZRgBIAEoDjIqLm1hcHMuZmxlZXRlbmdpbmUudjEuTG9jYXRpb25Qb3dlclNhdmVNb2RlEhoKEmlzX3Bvd2VyX3NhdmVfbW9kZRgCIAEoCBIWCg5pc19pbnRlcmFjdGl2ZRgDIAEoCBI2CgxiYXR0ZXJ5X2luZm8YBCABKAsyIC5tYXBzLmZsZWV0ZW5naW5lLnYxLkJhdHRlcnlJbmZvIkEKDExpY2Vuc2VQbGF0ZRIZCgxjb3VudHJ5X2NvZGUYASABKAlCA+BBAhIWCg5sYXN0X2NoYXJhY3RlchgCIAEoCSL2AgokVmlzdWFsVHJhZmZpY1JlcG9ydFBvbHlsaW5lUmVuZGVyaW5nEmAKDHJvYWRfc3RyZXRjaBgBIAMoCzJFLm1hcHMuZmxlZXRlbmdpbmUudjEuVmlzdWFsVHJhZmZpY1JlcG9ydFBvbHlsaW5lUmVuZGVyaW5nLlJvYWRTdHJldGNoQgPgQQEa6wEKC1JvYWRTdHJldGNoEl8KBXN0eWxlGAEgASgOMksubWFwcy5mbGVldGVuZ2luZS52MS5WaXN1YWxUcmFmZmljUmVwb3J0UG9seWxpbmVSZW5kZXJpbmcuUm9hZFN0cmV0Y2guU3R5bGVCA+BBAhIaCg1vZmZzZXRfbWV0ZXJzGAIgASgFQgPgQQISGgoNbGVuZ3RoX21ldGVycxgDIAEoBUID4EECIkMKBVN0eWxlEhUKEVNUWUxFX1VOU1BFQ0lGSUVEEAASEgoOU0xPV0VSX1RSQUZGSUMQARIPCgtUUkFGRklDX0pBTRACImsKE1RyYWZmaWNQb2x5bGluZURhdGESVAoRdHJhZmZpY19yZW5kZXJpbmcYASABKAsyOS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZpc3VhbFRyYWZmaWNSZXBvcnRQb2x5bGluZVJlbmRlcmluZypCCgxWZWhpY2xlU3RhdGUSGQoVVU5LTk9XTl9WRUhJQ0xFX1NUQVRFEAASCwoHT0ZGTElORRABEgoKBk9OTElORRACKpICChVMb2NhdGlvblBvd2VyU2F2ZU1vZGUSJAogVU5LTk9XTl9MT0NBVElPTl9QT1dFUl9TQVZFX01PREUQABIbChdMT0NBVElPTl9NT0RFX05PX0NIQU5HRRABEi4KKkxPQ0FUSU9OX01PREVfR1BTX0RJU0FCTEVEX1dIRU5fU0NSRUVOX09GRhACEi4KKkxPQ0FUSU9OX01PREVfQUxMX0RJU0FCTEVEX1dIRU5fU0NSRUVOX09GRhADEiEKHUxPQ0FUSU9OX01PREVfRk9SRUdST1VORF9PTkxZEAQSMwovTE9DQVRJT05fTU9ERV9USFJPVFRMRV9SRVFVRVNUU19XSEVOX1NDUkVFTl9PRkYQBSrAAQoNQmF0dGVyeVN0YXR1cxIaChZVTktOT1dOX0JBVFRFUllfU1RBVFVTEAASGwoXQkFUVEVSWV9TVEFUVVNfQ0hBUkdJTkcQARIeChpCQVRURVJZX1NUQVRVU19ESVNDSEFSR0lORxACEhcKE0JBVFRFUllfU1RBVFVTX0ZVTEwQAxIfChtCQVRURVJZX1NUQVRVU19OT1RfQ0hBUkdJTkcQBBIcChhCQVRURVJZX1NUQVRVU19QT1dFUl9MT1cQBSqJAQoLUG93ZXJTb3VyY2USGAoUVU5LTk9XTl9QT1dFUl9TT1VSQ0UQABITCg9QT1dFUl9TT1VSQ0VfQUMQARIUChBQT1dFUl9TT1VSQ0VfVVNCEAISGQoVUE9XRVJfU09VUkNFX1dJUkVMRVNTEAMSGgoWUE9XRVJfU09VUkNFX1VOUExVR0dFRBAEQtABChpnb29nbGUubWFwcy5mbGVldGVuZ2luZS52MUIIVmVoaWNsZXNQAVpGY2xvdWQuZ29vZ2xlLmNvbS9nby9tYXBzL2ZsZWV0ZW5naW5lL2FwaXYxL2ZsZWV0ZW5naW5lcGI7ZmxlZXRlbmdpbmVwYqICA0NGRaoCGkdvb2dsZS5NYXBzLkZsZWV0RW5naW5lLlYxygIaR29vZ2xlXE1hcHNcRmxlZXRFbmdpbmVcVjHqAh1Hb29nbGU6Ok1hcHM6OkZsZWV0RW5naW5lOjpWMWIGcHJvdG8z", [file_google_api_field_behavior, file_google_api_resource, file_google_maps_fleetengine_v1_fleetengine, file_google_protobuf_timestamp, file_google_protobuf_wrappers]);

/**
 * Vehicle metadata.
 *
 * @generated from message maps.fleetengine.v1.Vehicle
 */
export type Vehicle = Message<"maps.fleetengine.v1.Vehicle"> & {
  /**
   * Output only. The unique name for this vehicle.
   * The format is `providers/{provider}/vehicles/{vehicle}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The vehicle state.
   *
   * @generated from field: maps.fleetengine.v1.VehicleState vehicle_state = 2;
   */
  vehicleState: VehicleState;

  /**
   * Trip types supported by this vehicle.
   *
   * @generated from field: repeated maps.fleetengine.v1.TripType supported_trip_types = 3;
   */
  supportedTripTypes: TripType[];

  /**
   * Output only. List of `trip_id`'s for trips currently assigned to this
   * vehicle.
   *
   * @generated from field: repeated string current_trips = 4;
   */
  currentTrips: string[];

  /**
   * Last reported location of the vehicle.
   *
   * @generated from field: maps.fleetengine.v1.VehicleLocation last_location = 5;
   */
  lastLocation?: VehicleLocation;

  /**
   * The total numbers of riders this vehicle can carry.  The driver is not
   * considered in this value. This value must be greater than or equal to one.
   *
   * @generated from field: int32 maximum_capacity = 6;
   */
  maximumCapacity: number;

  /**
   * List of vehicle attributes. A vehicle can have at most 100
   * attributes, and each attribute must have a unique key.
   *
   * @generated from field: repeated maps.fleetengine.v1.VehicleAttribute attributes = 8;
   */
  attributes: VehicleAttribute[];

  /**
   * Required. The type of this vehicle.  Can be used to filter vehicles in
   * `SearchVehicles` results.  Also influences ETA and route calculations.
   *
   * @generated from field: maps.fleetengine.v1.Vehicle.VehicleType vehicle_type = 9;
   */
  vehicleType?: Vehicle_VehicleType;

  /**
   * License plate information for the vehicle.
   *
   * @generated from field: maps.fleetengine.v1.LicensePlate license_plate = 10;
   */
  licensePlate?: LicensePlate;

  /**
   * Deprecated: Use `Vehicle.waypoints` instead.
   *
   * @generated from field: repeated maps.fleetengine.v1.TerminalLocation route = 12 [deprecated = true];
   * @deprecated
   */
  route: TerminalLocation[];

  /**
   * The polyline specifying the route the driver app intends to take to
   * the next waypoint. This list is also returned in
   * `Trip.current_route_segment` for all active trips assigned to the vehicle.
   *
   * Note: This field is intended only for use by the Driver SDK. Decoding is
   * not yet supported.
   *
   * @generated from field: string current_route_segment = 20;
   */
  currentRouteSegment: string;

  /**
   * Input only. Fleet Engine uses this information to improve journey sharing.
   * Note: This field is intended only for use by the Driver SDK.
   *
   * @generated from field: maps.fleetengine.v1.TrafficPolylineData current_route_segment_traffic = 28;
   */
  currentRouteSegmentTraffic?: TrafficPolylineData;

  /**
   * Output only. Time when `current_route_segment` was set. It can be stored by
   * the client and passed in future `GetVehicle` requests to prevent returning
   * routes that haven't changed.
   *
   * @generated from field: google.protobuf.Timestamp current_route_segment_version = 15;
   */
  currentRouteSegmentVersion?: Timestamp;

  /**
   * The waypoint where `current_route_segment` ends. This can be supplied by
   * drivers on `UpdateVehicle` calls either as a full trip waypoint, a waypoint
   * `LatLng`, or as the last `LatLng` of the `current_route_segment`. Fleet
   * Engine will then do its best to interpolate to an actual waypoint if it is
   * not fully specified. This field is ignored in `UpdateVehicle` calls unless
   * `current_route_segment` is also specified.
   *
   * @generated from field: maps.fleetengine.v1.TripWaypoint current_route_segment_end_point = 24;
   */
  currentRouteSegmentEndPoint?: TripWaypoint;

  /**
   * The remaining driving distance for the `current_route_segment`.
   * This value is also returned in `Trip.remaining_distance_meters` for all
   * active trips assigned to the vehicle. The value is unspecified if the
   * `current_route_segment` field is empty.
   *
   * @generated from field: google.protobuf.Int32Value remaining_distance_meters = 18;
   */
  remainingDistanceMeters?: number;

  /**
   * The ETA to the first entry in the `waypoints` field.  The value is
   * unspecified if the `waypoints` field is empty or the
   * `Vehicle.current_route_segment` field is empty.
   *
   * When updating a vehicle, `remaining_time_seconds` takes precedence over
   * `eta_to_first_waypoint` in the same request.
   *
   * @generated from field: google.protobuf.Timestamp eta_to_first_waypoint = 19;
   */
  etaToFirstWaypoint?: Timestamp;

  /**
   * Input only. The remaining driving time for the `current_route_segment`. The
   * value is unspecified if the `waypoints` field is empty or the
   * `Vehicle.current_route_segment` field is empty. This value should match
   * `eta_to_first_waypoint` - `current_time` if all parties are using the same
   * clock.
   *
   * When updating a vehicle, `remaining_time_seconds` takes precedence over
   * `eta_to_first_waypoint` in the same request.
   *
   * @generated from field: google.protobuf.Int32Value remaining_time_seconds = 25;
   */
  remainingTimeSeconds?: number;

  /**
   * The remaining waypoints assigned to this Vehicle.
   *
   * @generated from field: repeated maps.fleetengine.v1.TripWaypoint waypoints = 22;
   */
  waypoints: TripWaypoint[];

  /**
   * Output only. Last time the `waypoints` field was updated. Clients should
   * cache this value and pass it in `GetVehicleRequest` to ensure the
   * `waypoints` field is only returned if it is updated.
   *
   * @generated from field: google.protobuf.Timestamp waypoints_version = 16;
   */
  waypointsVersion?: Timestamp;

  /**
   * Indicates if the driver accepts back-to-back trips. If `true`,
   * `SearchVehicles` may include the vehicle even if it is currently assigned
   * to a trip. The default value is `false`.
   *
   * @generated from field: bool back_to_back_enabled = 23;
   */
  backToBackEnabled: boolean;

  /**
   * The vehicle's navigation status.
   *
   * @generated from field: maps.fleetengine.v1.NavigationStatus navigation_status = 26;
   */
  navigationStatus: NavigationStatus;

  /**
   * Input only. Information about settings in the mobile device being used by
   * the driver.
   *
   * @generated from field: maps.fleetengine.v1.DeviceSettings device_settings = 27;
   */
  deviceSettings?: DeviceSettings;
};

/**
 * Describes the message maps.fleetengine.v1.Vehicle.
 * Use `create(VehicleSchema)` to create a new message.
 */
export const VehicleSchema: GenMessage<Vehicle> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 0);

/**
 * The type of vehicle.
 *
 * @generated from message maps.fleetengine.v1.Vehicle.VehicleType
 */
export type Vehicle_VehicleType = Message<"maps.fleetengine.v1.Vehicle.VehicleType"> & {
  /**
   * Vehicle type category
   *
   * @generated from field: maps.fleetengine.v1.Vehicle.VehicleType.Category category = 1;
   */
  category: Vehicle_VehicleType_Category;
};

/**
 * Describes the message maps.fleetengine.v1.Vehicle.VehicleType.
 * Use `create(Vehicle_VehicleTypeSchema)` to create a new message.
 */
export const Vehicle_VehicleTypeSchema: GenMessage<Vehicle_VehicleType> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 0, 0);

/**
 * Vehicle type categories
 *
 * @generated from enum maps.fleetengine.v1.Vehicle.VehicleType.Category
 */
export enum Vehicle_VehicleType_Category {
  /**
   * Default, used for unspecified or unrecognized vehicle categories.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * An automobile.
   *
   * @generated from enum value: AUTO = 1;
   */
  AUTO = 1,

  /**
   * Any vehicle that acts as a taxi (typically licensed or regulated).
   *
   * @generated from enum value: TAXI = 2;
   */
  TAXI = 2,

  /**
   * Generally, a vehicle with a large storage capacity.
   *
   * @generated from enum value: TRUCK = 3;
   */
  TRUCK = 3,

  /**
   * A motorcycle, moped, or other two-wheeled vehicle
   *
   * @generated from enum value: TWO_WHEELER = 4;
   */
  TWO_WHEELER = 4,

  /**
   * Human-powered transport.
   *
   * @generated from enum value: BICYCLE = 5;
   */
  BICYCLE = 5,

  /**
   * A human transporter, typically walking or running, traveling along
   * pedestrian pathways.
   *
   * @generated from enum value: PEDESTRIAN = 6;
   */
  PEDESTRIAN = 6,
}

/**
 * Describes the enum maps.fleetengine.v1.Vehicle.VehicleType.Category.
 */
export const Vehicle_VehicleType_CategorySchema: GenEnum<Vehicle_VehicleType_Category> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 0, 0, 0);

/**
 * Information about the device's battery.
 *
 * @generated from message maps.fleetengine.v1.BatteryInfo
 */
export type BatteryInfo = Message<"maps.fleetengine.v1.BatteryInfo"> & {
  /**
   * Status of the battery, whether full or charging etc.
   *
   * @generated from field: maps.fleetengine.v1.BatteryStatus battery_status = 1;
   */
  batteryStatus: BatteryStatus;

  /**
   * Status of battery power source.
   *
   * @generated from field: maps.fleetengine.v1.PowerSource power_source = 2;
   */
  powerSource: PowerSource;

  /**
   * Current battery percentage [0-100].
   *
   * @generated from field: float battery_percentage = 3;
   */
  batteryPercentage: number;
};

/**
 * Describes the message maps.fleetengine.v1.BatteryInfo.
 * Use `create(BatteryInfoSchema)` to create a new message.
 */
export const BatteryInfoSchema: GenMessage<BatteryInfo> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 1);

/**
 * Information about various settings on the mobile device.
 *
 * @generated from message maps.fleetengine.v1.DeviceSettings
 */
export type DeviceSettings = Message<"maps.fleetengine.v1.DeviceSettings"> & {
  /**
   * How location features are set to behave on the device when battery saver is
   * on.
   *
   * @generated from field: maps.fleetengine.v1.LocationPowerSaveMode location_power_save_mode = 1;
   */
  locationPowerSaveMode: LocationPowerSaveMode;

  /**
   * Whether the device is currently in power save mode.
   *
   * @generated from field: bool is_power_save_mode = 2;
   */
  isPowerSaveMode: boolean;

  /**
   * Whether the device is in an interactive state.
   *
   * @generated from field: bool is_interactive = 3;
   */
  isInteractive: boolean;

  /**
   * Information about the battery state.
   *
   * @generated from field: maps.fleetengine.v1.BatteryInfo battery_info = 4;
   */
  batteryInfo?: BatteryInfo;
};

/**
 * Describes the message maps.fleetengine.v1.DeviceSettings.
 * Use `create(DeviceSettingsSchema)` to create a new message.
 */
export const DeviceSettingsSchema: GenMessage<DeviceSettings> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 2);

/**
 * The license plate information of the Vehicle.  To avoid storing
 * personally-identifiable information, only the minimum information
 * about the license plate is stored as part of the entity.
 *
 * @generated from message maps.fleetengine.v1.LicensePlate
 */
export type LicensePlate = Message<"maps.fleetengine.v1.LicensePlate"> & {
  /**
   * Required. CLDR Country/Region Code.  For example, `US` for United States,
   * or `IN` for India.
   *
   * @generated from field: string country_code = 1;
   */
  countryCode: string;

  /**
   * The last digit of the license plate or "-1" to denote no numeric value
   * is present in the license plate.
   *
   * * "ABC 1234" -> "4"
   * * "AB 123 CD" -> "3"
   * * "ABCDEF" -> "-1"
   *
   * @generated from field: string last_character = 2;
   */
  lastCharacter: string;
};

/**
 * Describes the message maps.fleetengine.v1.LicensePlate.
 * Use `create(LicensePlateSchema)` to create a new message.
 */
export const LicensePlateSchema: GenMessage<LicensePlate> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 3);

/**
 * Describes how clients should color one portion of the polyline along the
 * route.
 *
 * @generated from message maps.fleetengine.v1.VisualTrafficReportPolylineRendering
 */
export type VisualTrafficReportPolylineRendering = Message<"maps.fleetengine.v1.VisualTrafficReportPolylineRendering"> & {
  /**
   * Optional. Road stretches that should be rendered along the polyline.
   * Stretches are guaranteed to not overlap, and do not necessarily span the
   * full route.
   *
   * In the absence of a road stretch to style, the client should apply the
   * default for the route.
   *
   * @generated from field: repeated maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch road_stretch = 1;
   */
  roadStretch: VisualTrafficReportPolylineRendering_RoadStretch[];
};

/**
 * Describes the message maps.fleetengine.v1.VisualTrafficReportPolylineRendering.
 * Use `create(VisualTrafficReportPolylineRenderingSchema)` to create a new message.
 */
export const VisualTrafficReportPolylineRenderingSchema: GenMessage<VisualTrafficReportPolylineRendering> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 4);

/**
 * One road stretch that should be rendered.
 *
 * @generated from message maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch
 */
export type VisualTrafficReportPolylineRendering_RoadStretch = Message<"maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch"> & {
  /**
   * Required. The style to apply.
   *
   * @generated from field: maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch.Style style = 1;
   */
  style: VisualTrafficReportPolylineRendering_RoadStretch_Style;

  /**
   * Required. The style should be applied between `[offset_meters,
   * offset_meters + length_meters)`.
   *
   * @generated from field: int32 offset_meters = 2;
   */
  offsetMeters: number;

  /**
   * Required. The length of the path where to apply the style.
   *
   * @generated from field: int32 length_meters = 3;
   */
  lengthMeters: number;
};

/**
 * Describes the message maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch.
 * Use `create(VisualTrafficReportPolylineRendering_RoadStretchSchema)` to create a new message.
 */
export const VisualTrafficReportPolylineRendering_RoadStretchSchema: GenMessage<VisualTrafficReportPolylineRendering_RoadStretch> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 4, 0);

/**
 * The traffic style, indicating traffic speed.
 *
 * @generated from enum maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch.Style
 */
export enum VisualTrafficReportPolylineRendering_RoadStretch_Style {
  /**
   * No style selected.
   *
   * @generated from enum value: STYLE_UNSPECIFIED = 0;
   */
  STYLE_UNSPECIFIED = 0,

  /**
   * Traffic is slowing down.
   *
   * @generated from enum value: SLOWER_TRAFFIC = 1;
   */
  SLOWER_TRAFFIC = 1,

  /**
   * There is a traffic jam.
   *
   * @generated from enum value: TRAFFIC_JAM = 2;
   */
  TRAFFIC_JAM = 2,
}

/**
 * Describes the enum maps.fleetengine.v1.VisualTrafficReportPolylineRendering.RoadStretch.Style.
 */
export const VisualTrafficReportPolylineRendering_RoadStretch_StyleSchema: GenEnum<VisualTrafficReportPolylineRendering_RoadStretch_Style> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 4, 0, 0);

/**
 * Traffic conditions along the expected vehicle route.
 *
 * @generated from message maps.fleetengine.v1.TrafficPolylineData
 */
export type TrafficPolylineData = Message<"maps.fleetengine.v1.TrafficPolylineData"> & {
  /**
   * A polyline rendering of how fast traffic is for all regions along
   * one stretch of a customer ride.
   *
   * @generated from field: maps.fleetengine.v1.VisualTrafficReportPolylineRendering traffic_rendering = 1;
   */
  trafficRendering?: VisualTrafficReportPolylineRendering;
};

/**
 * Describes the message maps.fleetengine.v1.TrafficPolylineData.
 * Use `create(TrafficPolylineDataSchema)` to create a new message.
 */
export const TrafficPolylineDataSchema: GenMessage<TrafficPolylineData> = /*@__PURE__*/
  messageDesc(file_google_maps_fleetengine_v1_vehicles, 5);

/**
 * The state of a `Vehicle`.
 *
 * @generated from enum maps.fleetengine.v1.VehicleState
 */
export enum VehicleState {
  /**
   * Default, used for unspecified or unrecognized vehicle states.
   *
   * @generated from enum value: UNKNOWN_VEHICLE_STATE = 0;
   */
  UNKNOWN_VEHICLE_STATE = 0,

  /**
   * The vehicle is not accepting new trips. Note: the vehicle may continue to
   * operate in this state while completing a trip assigned to it.
   *
   * @generated from enum value: OFFLINE = 1;
   */
  OFFLINE = 1,

  /**
   * The vehicle is accepting new trips.
   *
   * @generated from enum value: ONLINE = 2;
   */
  ONLINE = 2,
}

/**
 * Describes the enum maps.fleetengine.v1.VehicleState.
 */
export const VehicleStateSchema: GenEnum<VehicleState> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 0);

/**
 * How location features are configured to behave on the mobile device when the
 * devices "battery saver" feature is on.
 * (https://developer.android.com/reference/android/os/PowerManager#getLocationPowerSaveMode())
 *
 * @generated from enum maps.fleetengine.v1.LocationPowerSaveMode
 */
export enum LocationPowerSaveMode {
  /**
   * Undefined LocationPowerSaveMode
   *
   * @generated from enum value: UNKNOWN_LOCATION_POWER_SAVE_MODE = 0;
   */
  UNKNOWN_LOCATION_POWER_SAVE_MODE = 0,

  /**
   * Either the location providers shouldn't be affected by battery saver, or
   * battery saver is off.
   *
   * @generated from enum value: LOCATION_MODE_NO_CHANGE = 1;
   */
  LOCATION_MODE_NO_CHANGE = 1,

  /**
   * The GPS based location provider should be disabled when battery saver is on
   * and the device is non-interactive.
   *
   * @generated from enum value: LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 2;
   */
  LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 2,

  /**
   * All location providers should be disabled when battery saver is on and the
   * device is non-interactive.
   *
   * @generated from enum value: LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 3;
   */
  LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 3,

  /**
   * All the location providers will be kept available, but location fixes
   * should only be provided to foreground apps.
   *
   * @generated from enum value: LOCATION_MODE_FOREGROUND_ONLY = 4;
   */
  LOCATION_MODE_FOREGROUND_ONLY = 4,

  /**
   * Location will not be turned off, but LocationManager will throttle all
   * requests to providers when the device is non-interactive.
   *
   * @generated from enum value: LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF = 5;
   */
  LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF = 5,
}

/**
 * Describes the enum maps.fleetengine.v1.LocationPowerSaveMode.
 */
export const LocationPowerSaveModeSchema: GenEnum<LocationPowerSaveMode> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 1);

/**
 * Status of the battery, whether full or charging etc.
 *
 * @generated from enum maps.fleetengine.v1.BatteryStatus
 */
export enum BatteryStatus {
  /**
   * Battery status unknown.
   *
   * @generated from enum value: UNKNOWN_BATTERY_STATUS = 0;
   */
  UNKNOWN_BATTERY_STATUS = 0,

  /**
   * Battery is being charged.
   *
   * @generated from enum value: BATTERY_STATUS_CHARGING = 1;
   */
  BATTERY_STATUS_CHARGING = 1,

  /**
   * Battery is discharging.
   *
   * @generated from enum value: BATTERY_STATUS_DISCHARGING = 2;
   */
  BATTERY_STATUS_DISCHARGING = 2,

  /**
   * Battery is full.
   *
   * @generated from enum value: BATTERY_STATUS_FULL = 3;
   */
  BATTERY_STATUS_FULL = 3,

  /**
   * Battery is not charging.
   *
   * @generated from enum value: BATTERY_STATUS_NOT_CHARGING = 4;
   */
  BATTERY_STATUS_NOT_CHARGING = 4,

  /**
   * Battery is low on power.
   *
   * @generated from enum value: BATTERY_STATUS_POWER_LOW = 5;
   */
  BATTERY_STATUS_POWER_LOW = 5,
}

/**
 * Describes the enum maps.fleetengine.v1.BatteryStatus.
 */
export const BatteryStatusSchema: GenEnum<BatteryStatus> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 2);

/**
 * Type of the charger being used to charge the battery.
 *
 * @generated from enum maps.fleetengine.v1.PowerSource
 */
export enum PowerSource {
  /**
   * Power source unknown.
   *
   * @generated from enum value: UNKNOWN_POWER_SOURCE = 0;
   */
  UNKNOWN_POWER_SOURCE = 0,

  /**
   * Power source is an AC charger.
   *
   * @generated from enum value: POWER_SOURCE_AC = 1;
   */
  POWER_SOURCE_AC = 1,

  /**
   * Power source is a USB port.
   *
   * @generated from enum value: POWER_SOURCE_USB = 2;
   */
  POWER_SOURCE_USB = 2,

  /**
   * Power source is wireless.
   *
   * @generated from enum value: POWER_SOURCE_WIRELESS = 3;
   */
  POWER_SOURCE_WIRELESS = 3,

  /**
   * Battery is unplugged.
   *
   * @generated from enum value: POWER_SOURCE_UNPLUGGED = 4;
   */
  POWER_SOURCE_UNPLUGGED = 4,
}

/**
 * Describes the enum maps.fleetengine.v1.PowerSource.
 */
export const PowerSourceSchema: GenEnum<PowerSource> = /*@__PURE__*/
  enumDesc(file_google_maps_fleetengine_v1_vehicles, 3);

