// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/maps/solar/v1/solar_service.proto (package google.maps.solar.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { HttpBodySchema } from "../../../api/httpbody_pb";
import { file_google_api_httpbody } from "../../../api/httpbody_pb";
import type { Date } from "../../../type/date_pb";
import { file_google_type_date } from "../../../type/date_pb";
import type { LatLng } from "../../../type/latlng_pb";
import { file_google_type_latlng } from "../../../type/latlng_pb";
import type { Money } from "../../../type/money_pb";
import { file_google_type_money } from "../../../type/money_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/maps/solar/v1/solar_service.proto.
 */
export const file_google_maps_solar_v1_solar_service: GenFile = /*@__PURE__*/
  fileDesc("Cihnb29nbGUvbWFwcy9zb2xhci92MS9zb2xhcl9zZXJ2aWNlLnByb3RvEhRnb29nbGUubWFwcy5zb2xhci52MSK6AQoiRmluZENsb3Nlc3RCdWlsZGluZ0luc2lnaHRzUmVxdWVzdBIqCghsb2NhdGlvbhgBIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZ0ID4EECEkMKEHJlcXVpcmVkX3F1YWxpdHkYAyABKA4yJC5nb29nbGUubWFwcy5zb2xhci52MS5JbWFnZXJ5UXVhbGl0eUID4EEBEiMKFmV4YWN0X3F1YWxpdHlfcmVxdWlyZWQYBCABKAhCA+BBASJNCglMYXRMbmdCb3gSHwoCc3cYASABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSHwoCbmUYAiABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcitwMKEEJ1aWxkaW5nSW5zaWdodHMSDAoEbmFtZRgBIAEoCRIjCgZjZW50ZXIYAiABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSNQoMYm91bmRpbmdfYm94GAkgASgLMh8uZ29vZ2xlLm1hcHMuc29sYXIudjEuTGF0TG5nQm94EicKDGltYWdlcnlfZGF0ZRgDIAEoCzIRLmdvb2dsZS50eXBlLkRhdGUSMQoWaW1hZ2VyeV9wcm9jZXNzZWRfZGF0ZRgLIAEoCzIRLmdvb2dsZS50eXBlLkRhdGUSEwoLcG9zdGFsX2NvZGUYBCABKAkSGwoTYWRtaW5pc3RyYXRpdmVfYXJlYRgFIAEoCRIYChBzdGF0aXN0aWNhbF9hcmVhGAYgASgJEhMKC3JlZ2lvbl9jb2RlGAcgASgJEj0KD3NvbGFyX3BvdGVudGlhbBgIIAEoCzIkLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlNvbGFyUG90ZW50aWFsEj0KD2ltYWdlcnlfcXVhbGl0eRgKIAEoDjIkLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkltYWdlcnlRdWFsaXR5IrIFCg5Tb2xhclBvdGVudGlhbBIeChZtYXhfYXJyYXlfcGFuZWxzX2NvdW50GAEgASgFEhwKFHBhbmVsX2NhcGFjaXR5X3dhdHRzGAkgASgCEhsKE3BhbmVsX2hlaWdodF9tZXRlcnMYCiABKAISGgoScGFuZWxfd2lkdGhfbWV0ZXJzGAsgASgCEhwKFHBhbmVsX2xpZmV0aW1lX3llYXJzGAwgASgFEh4KFm1heF9hcnJheV9hcmVhX21ldGVyczIYAiABKAISIwobbWF4X3N1bnNoaW5lX2hvdXJzX3Blcl95ZWFyGAMgASgCEicKH2NhcmJvbl9vZmZzZXRfZmFjdG9yX2tnX3Blcl9td2gYBCABKAISRAoQd2hvbGVfcm9vZl9zdGF0cxgFIAEoCzIqLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlNpemVBbmRTdW5zaGluZVN0YXRzEkIKDmJ1aWxkaW5nX3N0YXRzGA0gASgLMiouZ29vZ2xlLm1hcHMuc29sYXIudjEuU2l6ZUFuZFN1bnNoaW5lU3RhdHMSUQoScm9vZl9zZWdtZW50X3N0YXRzGAYgAygLMjUuZ29vZ2xlLm1hcHMuc29sYXIudjEuUm9vZlNlZ21lbnRTaXplQW5kU3Vuc2hpbmVTdGF0cxI2Cgxzb2xhcl9wYW5lbHMYDiADKAsyIC5nb29nbGUubWFwcy5zb2xhci52MS5Tb2xhclBhbmVsEkMKE3NvbGFyX3BhbmVsX2NvbmZpZ3MYByADKAsyJi5nb29nbGUubWFwcy5zb2xhci52MS5Tb2xhclBhbmVsQ29uZmlnEkMKEmZpbmFuY2lhbF9hbmFseXNlcxgIIAMoCzInLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkZpbmFuY2lhbEFuYWx5c2lzIuYCCh9Sb29mU2VnbWVudFNpemVBbmRTdW5zaGluZVN0YXRzEhoKDXBpdGNoX2RlZ3JlZXMYASABKAJIAIgBARIcCg9hemltdXRoX2RlZ3JlZXMYAiABKAJIAYgBARI5CgVzdGF0cxgDIAEoCzIqLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlNpemVBbmRTdW5zaGluZVN0YXRzEiMKBmNlbnRlchgEIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxI1Cgxib3VuZGluZ19ib3gYBSABKAsyHy5nb29nbGUubWFwcy5zb2xhci52MS5MYXRMbmdCb3gSKgodcGxhbmVfaGVpZ2h0X2F0X2NlbnRlcl9tZXRlcnMYBiABKAJIAogBAUIQCg5fcGl0Y2hfZGVncmVlc0ISChBfYXppbXV0aF9kZWdyZWVzQiAKHl9wbGFuZV9oZWlnaHRfYXRfY2VudGVyX21ldGVycyJlChRTaXplQW5kU3Vuc2hpbmVTdGF0cxIUCgxhcmVhX21ldGVyczIYASABKAISGgoSc3Vuc2hpbmVfcXVhbnRpbGVzGAIgAygCEhsKE2dyb3VuZF9hcmVhX21ldGVyczIYAyABKAIivwEKClNvbGFyUGFuZWwSIwoGY2VudGVyGAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nEkAKC29yaWVudGF0aW9uGAIgASgOMisuZ29vZ2xlLm1hcHMuc29sYXIudjEuU29sYXJQYW5lbE9yaWVudGF0aW9uEhwKFHllYXJseV9lbmVyZ3lfZGNfa3doGAMgASgCEhoKDXNlZ21lbnRfaW5kZXgYBCABKAVIAIgBAUIQCg5fc2VnbWVudF9pbmRleCKQAQoQU29sYXJQYW5lbENvbmZpZxIUCgxwYW5lbHNfY291bnQYASABKAUSHAoUeWVhcmx5X2VuZXJneV9kY19rd2gYAiABKAISSAoWcm9vZl9zZWdtZW50X3N1bW1hcmllcxgEIAMoCzIoLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlJvb2ZTZWdtZW50U3VtbWFyeSLWAQoSUm9vZlNlZ21lbnRTdW1tYXJ5EhoKDXBpdGNoX2RlZ3JlZXMYAiABKAJIAIgBARIcCg9hemltdXRoX2RlZ3JlZXMYAyABKAJIAYgBARIUCgxwYW5lbHNfY291bnQYByABKAUSHAoUeWVhcmx5X2VuZXJneV9kY19rd2gYCCABKAISGgoNc2VnbWVudF9pbmRleBgJIAEoBUgCiAEBQhAKDl9waXRjaF9kZWdyZWVzQhIKEF9hemltdXRoX2RlZ3JlZXNCEAoOX3NlZ21lbnRfaW5kZXgiyAMKEUZpbmFuY2lhbEFuYWx5c2lzEigKDG1vbnRobHlfYmlsbBgDIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5EhQKDGRlZmF1bHRfYmlsbBgEIAEoCBIdChVhdmVyYWdlX2t3aF9wZXJfbW9udGgYBSABKAISHwoScGFuZWxfY29uZmlnX2luZGV4GAYgASgFSACIAQESQQoRZmluYW5jaWFsX2RldGFpbHMYByABKAsyJi5nb29nbGUubWFwcy5zb2xhci52MS5GaW5hbmNpYWxEZXRhaWxzEj0KD2xlYXNpbmdfc2F2aW5ncxgIIAEoCzIkLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkxlYXNpbmdTYXZpbmdzEkgKFWNhc2hfcHVyY2hhc2Vfc2F2aW5ncxgJIAEoCzIpLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkNhc2hQdXJjaGFzZVNhdmluZ3MSUAoZZmluYW5jZWRfcHVyY2hhc2Vfc2F2aW5ncxgKIAEoCzItLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkZpbmFuY2VkUHVyY2hhc2VTYXZpbmdzQhUKE19wYW5lbF9jb25maWdfaW5kZXgihwQKEEZpbmFuY2lhbERldGFpbHMSHwoXaW5pdGlhbF9hY19rd2hfcGVyX3llYXIYASABKAISOwofcmVtYWluaW5nX2xpZmV0aW1lX3V0aWxpdHlfYmlsbBgCIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5Ei0KEWZlZGVyYWxfaW5jZW50aXZlGAMgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSKwoPc3RhdGVfaW5jZW50aXZlGAQgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSLQoRdXRpbGl0eV9pbmNlbnRpdmUYBSABKAsyEi5nb29nbGUudHlwZS5Nb25leRIvChNsaWZldGltZV9zcmVjX3RvdGFsGAYgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSPQohY29zdF9vZl9lbGVjdHJpY2l0eV93aXRob3V0X3NvbGFyGAcgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSHAoUbmV0X21ldGVyaW5nX2FsbG93ZWQYCCABKAgSHQoQc29sYXJfcGVyY2VudGFnZRgJIAEoAkgAiAEBEigKG3BlcmNlbnRhZ2VfZXhwb3J0ZWRfdG9fZ3JpZBgKIAEoAkgBiAEBQhMKEV9zb2xhcl9wZXJjZW50YWdlQh4KHF9wZXJjZW50YWdlX2V4cG9ydGVkX3RvX2dyaWQirgIKD1NhdmluZ3NPdmVyVGltZRIpCg1zYXZpbmdzX3llYXIxGAEgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSKgoOc2F2aW5nc195ZWFyMjAYAiABKAsyEi5nb29nbGUudHlwZS5Nb25leRI7Ch9wcmVzZW50X3ZhbHVlX29mX3NhdmluZ3NfeWVhcjIwGAMgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSLAoQc2F2aW5nc19saWZldGltZRgFIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5Ej0KIXByZXNlbnRfdmFsdWVfb2Zfc2F2aW5nc19saWZldGltZRgGIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5EhoKEmZpbmFuY2lhbGx5X3ZpYWJsZRgEIAEoCCKrAQoOTGVhc2luZ1NhdmluZ3MSFgoObGVhc2VzX2FsbG93ZWQYASABKAgSGAoQbGVhc2VzX3N1cHBvcnRlZBgCIAEoCBIvChNhbm51YWxfbGVhc2luZ19jb3N0GAMgASgLMhIuZ29vZ2xlLnR5cGUuTW9uZXkSNgoHc2F2aW5ncxgEIAEoCzIlLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlNhdmluZ3NPdmVyVGltZSL/AQoTQ2FzaFB1cmNoYXNlU2F2aW5ncxIuChJvdXRfb2ZfcG9ja2V0X2Nvc3QYASABKAsyEi5nb29nbGUudHlwZS5Nb25leRIoCgx1cGZyb250X2Nvc3QYAiABKAsyEi5nb29nbGUudHlwZS5Nb25leRIoCgxyZWJhdGVfdmFsdWUYAyABKAsyEi5nb29nbGUudHlwZS5Nb25leRIaCg1wYXliYWNrX3llYXJzGAQgASgCSACIAQESNgoHc2F2aW5ncxgFIAEoCzIlLmdvb2dsZS5tYXBzLnNvbGFyLnYxLlNhdmluZ3NPdmVyVGltZUIQCg5fcGF5YmFja195ZWFycyLIAQoXRmluYW5jZWRQdXJjaGFzZVNhdmluZ3MSLwoTYW5udWFsX2xvYW5fcGF5bWVudBgBIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5EigKDHJlYmF0ZV92YWx1ZRgCIAEoCzISLmdvb2dsZS50eXBlLk1vbmV5EhoKEmxvYW5faW50ZXJlc3RfcmF0ZRgDIAEoAhI2CgdzYXZpbmdzGAQgASgLMiUuZ29vZ2xlLm1hcHMuc29sYXIudjEuU2F2aW5nc092ZXJUaW1lIqACChRHZXREYXRhTGF5ZXJzUmVxdWVzdBIqCghsb2NhdGlvbhgBIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZ0ID4EECEhoKDXJhZGl1c19tZXRlcnMYAiABKAJCA+BBAhI2CgR2aWV3GAMgASgOMiMuZ29vZ2xlLm1hcHMuc29sYXIudjEuRGF0YUxheWVyVmlld0ID4EEBEkMKEHJlcXVpcmVkX3F1YWxpdHkYBSABKA4yJC5nb29nbGUubWFwcy5zb2xhci52MS5JbWFnZXJ5UXVhbGl0eUID4EEBEh4KEXBpeGVsX3NpemVfbWV0ZXJzGAYgASgCQgPgQQESIwoWZXhhY3RfcXVhbGl0eV9yZXF1aXJlZBgHIAEoCEID4EEBIqkCCgpEYXRhTGF5ZXJzEicKDGltYWdlcnlfZGF0ZRgBIAEoCzIRLmdvb2dsZS50eXBlLkRhdGUSMQoWaW1hZ2VyeV9wcm9jZXNzZWRfZGF0ZRgCIAEoCzIRLmdvb2dsZS50eXBlLkRhdGUSDwoHZHNtX3VybBgDIAEoCRIPCgdyZ2JfdXJsGAQgASgJEhAKCG1hc2tfdXJsGAUgASgJEhcKD2FubnVhbF9mbHV4X3VybBgGIAEoCRIYChBtb250aGx5X2ZsdXhfdXJsGAcgASgJEhkKEWhvdXJseV9zaGFkZV91cmxzGAggAygJEj0KD2ltYWdlcnlfcXVhbGl0eRgJIAEoDjIkLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkltYWdlcnlRdWFsaXR5IiQKEUdldEdlb1RpZmZSZXF1ZXN0Eg8KAmlkGAEgASgJQgPgQQIqqQEKDURhdGFMYXllclZpZXcSHwobREFUQV9MQVlFUl9WSUVXX1VOU1BFQ0lGSUVEEAASDQoJRFNNX0xBWUVSEAESEgoOSU1BR0VSWV9MQVlFUlMQAhIiCh5JTUFHRVJZX0FORF9BTk5VQUxfRkxVWF9MQVlFUlMQAxIfChtJTUFHRVJZX0FORF9BTExfRkxVWF9MQVlFUlMQBBIPCgtGVUxMX0xBWUVSUxAFKlAKDkltYWdlcnlRdWFsaXR5Eh8KG0lNQUdFUllfUVVBTElUWV9VTlNQRUNJRklFRBAAEggKBEhJR0gQARIKCgZNRURJVU0QAhIHCgNMT1cQAypdChVTb2xhclBhbmVsT3JpZW50YXRpb24SJwojU09MQVJfUEFORUxfT1JJRU5UQVRJT05fVU5TUEVDSUZJRUQQABINCglMQU5EU0NBUEUQARIMCghQT1JUUkFJVBACMt4DCgVTb2xhchKpAQobRmluZENsb3Nlc3RCdWlsZGluZ0luc2lnaHRzEjguZ29vZ2xlLm1hcHMuc29sYXIudjEuRmluZENsb3Nlc3RCdWlsZGluZ0luc2lnaHRzUmVxdWVzdBomLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkJ1aWxkaW5nSW5zaWdodHMiKILT5JMCIhIgL3YxL2J1aWxkaW5nSW5zaWdodHM6ZmluZENsb3Nlc3QSeQoNR2V0RGF0YUxheWVycxIqLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkdldERhdGFMYXllcnNSZXF1ZXN0GiAuZ29vZ2xlLm1hcHMuc29sYXIudjEuRGF0YUxheWVycyIagtPkkwIUEhIvdjEvZGF0YUxheWVyczpnZXQSZAoKR2V0R2VvVGlmZhInLmdvb2dsZS5tYXBzLnNvbGFyLnYxLkdldEdlb1RpZmZSZXF1ZXN0GhQuZ29vZ2xlLmFwaS5IdHRwQm9keSIXgtPkkwIREg8vdjEvZ2VvVGlmZjpnZXQaSMpBFHNvbGFyLmdvb2dsZWFwaXMuY29t0kEuaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybUK3AQoYY29tLmdvb2dsZS5tYXBzLnNvbGFyLnYxQhFTb2xhclNlcnZpY2VQcm90b1ABWjRjbG91ZC5nb29nbGUuY29tL2dvL21hcHMvc29sYXIvYXBpdjEvc29sYXJwYjtzb2xhcnBiogIHR0dNUFYxQaoCFEdvb2dsZS5NYXBzLlNvbGFyLlYxygIUR29vZ2xlXE1hcHNcU29sYXJcVjHqAhdHb29nbGU6Ok1hcHM6OlNvbGFyOjpWMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_httpbody, file_google_type_date, file_google_type_latlng, file_google_type_money]);

/**
 * Request message for `Solar.FindClosestBuildingInsights`.
 *
 * @generated from message google.maps.solar.v1.FindClosestBuildingInsightsRequest
 */
export type FindClosestBuildingInsightsRequest = Message<"google.maps.solar.v1.FindClosestBuildingInsightsRequest"> & {
  /**
   * Required. The longitude and latitude from which the API looks for the
   * nearest known building.
   *
   * @generated from field: google.type.LatLng location = 1;
   */
  location?: LatLng;

  /**
   * Optional. The minimum quality level allowed in the results. No result with
   * lower quality than this will be returned. Not specifying this is
   * equivalent to restricting to HIGH quality only.
   *
   * @generated from field: google.maps.solar.v1.ImageryQuality required_quality = 3;
   */
  requiredQuality: ImageryQuality;

  /**
   * Optional. Whether to require exact quality of the imagery.
   * If set to false, the `required_quality` field is interpreted as the minimum
   * required quality, such that HIGH quality imagery may be returned when
   * `required_quality` is set to MEDIUM.  If set to true, `required_quality`
   * is interpreted as the exact required quality and only `MEDIUM` quality
   * imagery is returned if `required_quality` is set to `MEDIUM`.
   *
   * @generated from field: bool exact_quality_required = 4;
   */
  exactQualityRequired: boolean;
};

/**
 * Describes the message google.maps.solar.v1.FindClosestBuildingInsightsRequest.
 * Use `create(FindClosestBuildingInsightsRequestSchema)` to create a new message.
 */
export const FindClosestBuildingInsightsRequestSchema: GenMessage<FindClosestBuildingInsightsRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 0);

/**
 * A bounding box in lat/lng coordinates.
 *
 * @generated from message google.maps.solar.v1.LatLngBox
 */
export type LatLngBox = Message<"google.maps.solar.v1.LatLngBox"> & {
  /**
   * The southwest corner of the box.
   *
   * @generated from field: google.type.LatLng sw = 1;
   */
  sw?: LatLng;

  /**
   * The northeast corner of the box.
   *
   * @generated from field: google.type.LatLng ne = 2;
   */
  ne?: LatLng;
};

/**
 * Describes the message google.maps.solar.v1.LatLngBox.
 * Use `create(LatLngBoxSchema)` to create a new message.
 */
export const LatLngBoxSchema: GenMessage<LatLngBox> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 1);

/**
 * Response message for `Solar.FindClosestBuildingInsights`.
 * Information about the location, dimensions, and solar potential of a
 * building.
 *
 * @generated from message google.maps.solar.v1.BuildingInsights
 */
export type BuildingInsights = Message<"google.maps.solar.v1.BuildingInsights"> & {
  /**
   * The resource name for the building, of the format `building/<place ID>`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A point near the center of the building.
   *
   * @generated from field: google.type.LatLng center = 2;
   */
  center?: LatLng;

  /**
   * The bounding box of the building.
   *
   * @generated from field: google.maps.solar.v1.LatLngBox bounding_box = 9;
   */
  boundingBox?: LatLngBox;

  /**
   * Date that the underlying imagery was acquired. This is approximate.
   *
   * @generated from field: google.type.Date imagery_date = 3;
   */
  imageryDate?: Date;

  /**
   * When processing was completed on this imagery.
   *
   * @generated from field: google.type.Date imagery_processed_date = 11;
   */
  imageryProcessedDate?: Date;

  /**
   * Postal code (e.g., US zip code) this building is contained by.
   *
   * @generated from field: string postal_code = 4;
   */
  postalCode: string;

  /**
   * Administrative area 1 (e.g., in the US, the state) that contains this
   * building. For example, in the US, the abbreviation might be "MA" or "CA."
   *
   * @generated from field: string administrative_area = 5;
   */
  administrativeArea: string;

  /**
   * Statistical area (e.g., US census tract) this building is in.
   *
   * @generated from field: string statistical_area = 6;
   */
  statisticalArea: string;

  /**
   * Region code for the country (or region) this building is in.
   *
   * @generated from field: string region_code = 7;
   */
  regionCode: string;

  /**
   * Solar potential of the building.
   *
   * @generated from field: google.maps.solar.v1.SolarPotential solar_potential = 8;
   */
  solarPotential?: SolarPotential;

  /**
   * The quality of the imagery used to compute the data for this building.
   *
   * @generated from field: google.maps.solar.v1.ImageryQuality imagery_quality = 10;
   */
  imageryQuality: ImageryQuality;
};

/**
 * Describes the message google.maps.solar.v1.BuildingInsights.
 * Use `create(BuildingInsightsSchema)` to create a new message.
 */
export const BuildingInsightsSchema: GenMessage<BuildingInsights> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 2);

/**
 * Information about the solar potential of a building. A number of
 * fields in this are defined in terms of "panels". The fields
 * [panel_capacity_watts]
 * [google.maps.solar.v1.SolarPotential.panel_capacity_watts],
 * [panel_height_meters]
 * [google.maps.solar.v1.SolarPotential.panel_height_meters],
 * and [panel_width_meters]
 * [google.maps.solar.v1.SolarPotential.panel_width_meters]
 * describe the parameters of the model of panel used in these
 * calculations.
 *
 * @generated from message google.maps.solar.v1.SolarPotential
 */
export type SolarPotential = Message<"google.maps.solar.v1.SolarPotential"> & {
  /**
   * Size of the maximum array - that is, the maximum number of panels that
   * can fit on the roof.
   *
   * @generated from field: int32 max_array_panels_count = 1;
   */
  maxArrayPanelsCount: number;

  /**
   * Capacity, in watts, of the panel used in the calculations.
   *
   * @generated from field: float panel_capacity_watts = 9;
   */
  panelCapacityWatts: number;

  /**
   * Height, in meters in portrait orientation, of the panel used in
   * the calculations.
   *
   * @generated from field: float panel_height_meters = 10;
   */
  panelHeightMeters: number;

  /**
   * Width, in meters in portrait orientation, of the panel used in
   * the calculations.
   *
   * @generated from field: float panel_width_meters = 11;
   */
  panelWidthMeters: number;

  /**
   * The expected lifetime, in years, of the solar panels. This is
   * used in the financial calculations.
   *
   * @generated from field: int32 panel_lifetime_years = 12;
   */
  panelLifetimeYears: number;

  /**
   * Size, in square meters, of the maximum array.
   *
   * @generated from field: float max_array_area_meters2 = 2;
   */
  maxArrayAreaMeters2: number;

  /**
   * Maximum number of sunshine hours received per year, by any point
   * on the roof. Sunshine hours are a measure of the total amount of
   * insolation (energy) received per year. 1 sunshine hour = 1 kWh per kW
   * (where kW refers to kW of capacity under Standard Testing Conditions).
   *
   * @generated from field: float max_sunshine_hours_per_year = 3;
   */
  maxSunshineHoursPerYear: number;

  /**
   * Equivalent amount of CO2 produced per MWh of grid electricity. This
   * is a measure of the carbon intensity of grid electricity displaced
   * by solar electricity.
   *
   * @generated from field: float carbon_offset_factor_kg_per_mwh = 4;
   */
  carbonOffsetFactorKgPerMwh: number;

  /**
   * Total size and sunlight quantiles for the part of the roof that
   * was assigned to some roof segment. Despite the name, this may not
   * include the entire building. See [building_stats]
   * [google.maps.solar.v1.SolarPotential.building_stats].
   *
   * @generated from field: google.maps.solar.v1.SizeAndSunshineStats whole_roof_stats = 5;
   */
  wholeRoofStats?: SizeAndSunshineStats;

  /**
   * Size and sunlight quantiles for the entire building, including
   * parts of the roof that were not assigned to some roof segment.
   * Because the orientations of these parts are not well
   * characterised, the roof area estimate is unreliable, but the
   * ground area estimate is reliable. It may be that a more reliable
   * whole building roof area can be obtained by scaling the roof area
   * from [whole_roof_stats]
   * [google.maps.solar.v1.SolarPotential.whole_roof_stats] by
   * the ratio of the ground areas of `building_stats` and
   * `whole_roof_stats`.
   *
   * @generated from field: google.maps.solar.v1.SizeAndSunshineStats building_stats = 13;
   */
  buildingStats?: SizeAndSunshineStats;

  /**
   * Size and sunlight quantiles for each roof segment.
   *
   * @generated from field: repeated google.maps.solar.v1.RoofSegmentSizeAndSunshineStats roof_segment_stats = 6;
   */
  roofSegmentStats: RoofSegmentSizeAndSunshineStats[];

  /**
   * Each [SolarPanel] [google.maps.solar.v1.SolarPanel]
   * describes a single solar panel. They are listed in the order that
   * the panel layout algorithm placed this. This is usually, though
   * not always, in decreasing order of annual energy production.
   *
   * @generated from field: repeated google.maps.solar.v1.SolarPanel solar_panels = 14;
   */
  solarPanels: SolarPanel[];

  /**
   * Each [SolarPanelConfig]
   * [google.maps.solar.v1.SolarPanelConfig] describes a
   * different arrangement of solar panels on the roof. They are in
   * order of increasing number of panels. The `SolarPanelConfig` with
   * [panels_count]
   * [google.maps.solar.v1.SolarPanelConfig.panels_count]=N is
   * based on the first N panels in the `solar_panels` list. This field is only
   * populated if at least 4 panels can fit on a roof.
   *
   * @generated from field: repeated google.maps.solar.v1.SolarPanelConfig solar_panel_configs = 7;
   */
  solarPanelConfigs: SolarPanelConfig[];

  /**
   * A [FinancialAnalysis]
   * [google.maps.solar.v1.FinancialAnalysis] gives the savings
   * from going solar assuming a given monthly bill and a given
   * electricity provider. They are in order of increasing order of
   * monthly bill amount. This field will be empty for buildings in
   * areas for which the Solar API does not have enough information to
   * perform financial computations.
   *
   * @generated from field: repeated google.maps.solar.v1.FinancialAnalysis financial_analyses = 8;
   */
  financialAnalyses: FinancialAnalysis[];
};

/**
 * Describes the message google.maps.solar.v1.SolarPotential.
 * Use `create(SolarPotentialSchema)` to create a new message.
 */
export const SolarPotentialSchema: GenMessage<SolarPotential> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 3);

/**
 * Information about the size and sunniness quantiles of a roof segment.
 *
 * @generated from message google.maps.solar.v1.RoofSegmentSizeAndSunshineStats
 */
export type RoofSegmentSizeAndSunshineStats = Message<"google.maps.solar.v1.RoofSegmentSizeAndSunshineStats"> & {
  /**
   * Angle of the roof segment relative to the theoretical ground plane.
   * 0 = parallel to the ground, 90 = perpendicular to the ground.
   *
   * @generated from field: optional float pitch_degrees = 1;
   */
  pitchDegrees?: number;

  /**
   * Compass direction the roof segment is pointing in. 0 = North, 90 =
   * East, 180 = South. For a "flat" roof segment (`pitch_degrees` very
   * near 0), azimuth is not well defined, so for consistency, we define it
   * arbitrarily to be 0 (North).
   *
   * @generated from field: optional float azimuth_degrees = 2;
   */
  azimuthDegrees?: number;

  /**
   * Total size and sunlight quantiles for the roof segment.
   *
   * @generated from field: google.maps.solar.v1.SizeAndSunshineStats stats = 3;
   */
  stats?: SizeAndSunshineStats;

  /**
   * A point near the center of the roof segment.
   *
   * @generated from field: google.type.LatLng center = 4;
   */
  center?: LatLng;

  /**
   * The bounding box of the roof segment.
   *
   * @generated from field: google.maps.solar.v1.LatLngBox bounding_box = 5;
   */
  boundingBox?: LatLngBox;

  /**
   * The height of the roof segment plane, in meters above sea level,
   * at the point designated by `center`. Together with the pitch,
   * azimuth, and center location, this fully defines the roof segment
   * plane.
   *
   * @generated from field: optional float plane_height_at_center_meters = 6;
   */
  planeHeightAtCenterMeters?: number;
};

/**
 * Describes the message google.maps.solar.v1.RoofSegmentSizeAndSunshineStats.
 * Use `create(RoofSegmentSizeAndSunshineStatsSchema)` to create a new message.
 */
export const RoofSegmentSizeAndSunshineStatsSchema: GenMessage<RoofSegmentSizeAndSunshineStats> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 4);

/**
 * Size and sunniness quantiles of a roof, or part of a roof.
 *
 * @generated from message google.maps.solar.v1.SizeAndSunshineStats
 */
export type SizeAndSunshineStats = Message<"google.maps.solar.v1.SizeAndSunshineStats"> & {
  /**
   * The area of the roof or roof segment, in m^2. This is the roof area
   * (accounting for tilt), not the ground footprint area.
   *
   * @generated from field: float area_meters2 = 1;
   */
  areaMeters2: number;

  /**
   * Quantiles of the pointwise sunniness across the area. If there
   * are N values here, this represents the (N-1)-iles. For example,
   * if there are 5 values, then they would be the quartiles (min,
   * 25%, 50%, 75%, max). Values are in annual kWh/kW like
   * [max_sunshine_hours_per_year]
   * [google.maps.solar.v1.SolarPotential.max_sunshine_hours_per_year].
   *
   * @generated from field: repeated float sunshine_quantiles = 2;
   */
  sunshineQuantiles: number[];

  /**
   * The ground footprint area covered by the roof or roof segment, in m^2.
   *
   * @generated from field: float ground_area_meters2 = 3;
   */
  groundAreaMeters2: number;
};

/**
 * Describes the message google.maps.solar.v1.SizeAndSunshineStats.
 * Use `create(SizeAndSunshineStatsSchema)` to create a new message.
 */
export const SizeAndSunshineStatsSchema: GenMessage<SizeAndSunshineStats> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 5);

/**
 * SolarPanel describes the position, orientation, and production of a
 * single solar panel. See the [panel_height_meters]
 * [google.maps.solar.v1.SolarPotential.panel_height_meters],
 * [panel_width_meters]
 * [google.maps.solar.v1.SolarPotential.panel_width_meters],
 * and [panel_capacity_watts]
 * [google.maps.solar.v1.SolarPotential.panel_capacity_watts]
 * fields in [SolarPotential]
 * [google.maps.solar.v1.SolarPotential] for information on the
 * parameters of the panel.
 *
 * @generated from message google.maps.solar.v1.SolarPanel
 */
export type SolarPanel = Message<"google.maps.solar.v1.SolarPanel"> & {
  /**
   * The centre of the panel.
   *
   * @generated from field: google.type.LatLng center = 1;
   */
  center?: LatLng;

  /**
   * The orientation of the panel.
   *
   * @generated from field: google.maps.solar.v1.SolarPanelOrientation orientation = 2;
   */
  orientation: SolarPanelOrientation;

  /**
   * How much sunlight energy this layout captures over the course of a
   * year, in DC kWh.
   *
   * @generated from field: float yearly_energy_dc_kwh = 3;
   */
  yearlyEnergyDcKwh: number;

  /**
   * Index in [roof_segment_stats]
   * [google.maps.solar.v1.SolarPotential.roof_segment_stats]
   * of the `RoofSegmentSizeAndSunshineStats` which corresponds to the
   * roof segment that this panel is placed on.
   *
   * @generated from field: optional int32 segment_index = 4;
   */
  segmentIndex?: number;
};

/**
 * Describes the message google.maps.solar.v1.SolarPanel.
 * Use `create(SolarPanelSchema)` to create a new message.
 */
export const SolarPanelSchema: GenMessage<SolarPanel> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 6);

/**
 * SolarPanelConfig describes a particular placement of solar panels
 * on the roof.
 *
 * @generated from message google.maps.solar.v1.SolarPanelConfig
 */
export type SolarPanelConfig = Message<"google.maps.solar.v1.SolarPanelConfig"> & {
  /**
   * Total number of panels. Note that this is redundant to (the sum
   * of) the corresponding fields in [roof_segment_summaries]
   * [google.maps.solar.v1.SolarPanelConfig.roof_segment_summaries].
   *
   * @generated from field: int32 panels_count = 1;
   */
  panelsCount: number;

  /**
   * How much sunlight energy this layout captures over the course of a
   * year, in DC kWh, assuming the panels described above.
   *
   * @generated from field: float yearly_energy_dc_kwh = 2;
   */
  yearlyEnergyDcKwh: number;

  /**
   * Information about the production of each roof segment that is carrying
   * at least one panel in this layout. `roof_segment_summaries[i]` describes
   * the i-th roof segment, including its size, expected production and
   * orientation.
   *
   * @generated from field: repeated google.maps.solar.v1.RoofSegmentSummary roof_segment_summaries = 4;
   */
  roofSegmentSummaries: RoofSegmentSummary[];
};

/**
 * Describes the message google.maps.solar.v1.SolarPanelConfig.
 * Use `create(SolarPanelConfigSchema)` to create a new message.
 */
export const SolarPanelConfigSchema: GenMessage<SolarPanelConfig> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 7);

/**
 * Information about a roof segment on the building, with some number of
 * panels placed on it.
 *
 * @generated from message google.maps.solar.v1.RoofSegmentSummary
 */
export type RoofSegmentSummary = Message<"google.maps.solar.v1.RoofSegmentSummary"> & {
  /**
   * Angle of the roof segment relative to the theoretical ground plane.
   * 0 = parallel to the ground, 90 = perpendicular to the ground.
   *
   * @generated from field: optional float pitch_degrees = 2;
   */
  pitchDegrees?: number;

  /**
   * Compass direction the roof segment is pointing in. 0 = North, 90 =
   * East, 180 = South. For a "flat" roof segment (`pitch_degrees` very
   * near 0), azimuth is not well defined, so for consistency, we define it
   * arbitrarily to be 0 (North).
   *
   * @generated from field: optional float azimuth_degrees = 3;
   */
  azimuthDegrees?: number;

  /**
   * The total number of panels on this segment.
   *
   * @generated from field: int32 panels_count = 7;
   */
  panelsCount: number;

  /**
   * How much sunlight energy this part of the layout captures over the
   * course of a year, in DC kWh, assuming the panels described above.
   *
   * @generated from field: float yearly_energy_dc_kwh = 8;
   */
  yearlyEnergyDcKwh: number;

  /**
   * Index in [roof_segment_stats]
   * [google.maps.solar.v1.SolarPotential.roof_segment_stats]
   * of the corresponding `RoofSegmentSizeAndSunshineStats`.
   *
   * @generated from field: optional int32 segment_index = 9;
   */
  segmentIndex?: number;
};

/**
 * Describes the message google.maps.solar.v1.RoofSegmentSummary.
 * Use `create(RoofSegmentSummarySchema)` to create a new message.
 */
export const RoofSegmentSummarySchema: GenMessage<RoofSegmentSummary> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 8);

/**
 * Analysis of the cost and benefits of the optimum solar layout for a
 * particular electric bill size.
 *
 * @generated from message google.maps.solar.v1.FinancialAnalysis
 */
export type FinancialAnalysis = Message<"google.maps.solar.v1.FinancialAnalysis"> & {
  /**
   * The monthly electric bill this analysis assumes.
   *
   * @generated from field: google.type.Money monthly_bill = 3;
   */
  monthlyBill?: Money;

  /**
   * Whether this is the bill size selected to be the default bill for the
   * area this building is in. Exactly one `FinancialAnalysis` in
   * `BuildingSolarPotential` should have `default_bill` set.
   *
   * @generated from field: bool default_bill = 4;
   */
  defaultBill: boolean;

  /**
   * How much electricity the house uses in an average month, based on the
   * bill size and the local electricity rates.
   *
   * @generated from field: float average_kwh_per_month = 5;
   */
  averageKwhPerMonth: number;

  /**
   * Index in [solar_panel_configs]
   * [google.maps.solar.v1.SolarPotential.solar_panel_configs]
   * of the optimum solar layout for this bill size. This can be -1
   * indicating that there is no layout. In this case, the remaining
   * submessages will be omitted.
   *
   * @generated from field: optional int32 panel_config_index = 6;
   */
  panelConfigIndex?: number;

  /**
   * Financial information that applies regardless of the financing method
   * used.
   *
   * @generated from field: google.maps.solar.v1.FinancialDetails financial_details = 7;
   */
  financialDetails?: FinancialDetails;

  /**
   * Cost and benefit of leasing the solar panels.
   *
   * @generated from field: google.maps.solar.v1.LeasingSavings leasing_savings = 8;
   */
  leasingSavings?: LeasingSavings;

  /**
   * Cost and benefit of buying the solar panels with cash.
   *
   * @generated from field: google.maps.solar.v1.CashPurchaseSavings cash_purchase_savings = 9;
   */
  cashPurchaseSavings?: CashPurchaseSavings;

  /**
   * Cost and benefit of buying the solar panels by financing the purchase.
   *
   * @generated from field: google.maps.solar.v1.FinancedPurchaseSavings financed_purchase_savings = 10;
   */
  financedPurchaseSavings?: FinancedPurchaseSavings;
};

/**
 * Describes the message google.maps.solar.v1.FinancialAnalysis.
 * Use `create(FinancialAnalysisSchema)` to create a new message.
 */
export const FinancialAnalysisSchema: GenMessage<FinancialAnalysis> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 9);

/**
 * Details of a financial analysis. Some of these details are already
 * stored at higher levels (e.g., out of pocket cost). Total money
 * amounts are over a lifetime period defined by the
 * [panel_lifetime_years]
 * [google.maps.solar.v1.SolarPotential.panel_lifetime_years]
 * field in [SolarPotential]
 * [google.maps.solar.v1.SolarPotential]. Note: The out of
 * pocket cost of purchasing the panels is given in the
 * [out_of_pocket_cost]
 * [google.maps.solar.v1.CashPurchaseSavings.out_of_pocket_cost]
 * field in [CashPurchaseSavings]
 * [google.maps.solar.v1.CashPurchaseSavings].
 *
 * @generated from message google.maps.solar.v1.FinancialDetails
 */
export type FinancialDetails = Message<"google.maps.solar.v1.FinancialDetails"> & {
  /**
   * How many AC kWh we think the solar panels will generate in their first
   * year.
   *
   * @generated from field: float initial_ac_kwh_per_year = 1;
   */
  initialAcKwhPerYear: number;

  /**
   * Utility bill for electricity not produced by solar, for the
   * lifetime of the panels.
   *
   * @generated from field: google.type.Money remaining_lifetime_utility_bill = 2;
   */
  remainingLifetimeUtilityBill?: Money;

  /**
   * Amount of money available from federal incentives; this applies if the
   * user buys (with or without a loan) the panels.
   *
   * @generated from field: google.type.Money federal_incentive = 3;
   */
  federalIncentive?: Money;

  /**
   * Amount of money available from state incentives; this applies if the
   * user buys (with or without a loan) the panels.
   *
   * @generated from field: google.type.Money state_incentive = 4;
   */
  stateIncentive?: Money;

  /**
   * Amount of money available from utility incentives; this applies if the
   * user buys (with or without a loan) the panels.
   *
   * @generated from field: google.type.Money utility_incentive = 5;
   */
  utilityIncentive?: Money;

  /**
   * Amount of money the user will receive from Solar Renewable Energy
   * Credits over the panel lifetime; this applies if the user buys
   * (with or without a loan) the panels.
   *
   * @generated from field: google.type.Money lifetime_srec_total = 6;
   */
  lifetimeSrecTotal?: Money;

  /**
   * Total cost of electricity the user would have paid over the
   * lifetime period if they didn't install solar.
   *
   * @generated from field: google.type.Money cost_of_electricity_without_solar = 7;
   */
  costOfElectricityWithoutSolar?: Money;

  /**
   * Whether net metering is allowed.
   *
   * @generated from field: bool net_metering_allowed = 8;
   */
  netMeteringAllowed: boolean;

  /**
   * Percentage (0-100) of the user's power supplied by solar.
   * Valid for the first year but approximately correct for future years.
   *
   * @generated from field: optional float solar_percentage = 9;
   */
  solarPercentage?: number;

  /**
   * The percentage (0-100) of solar electricity production we assumed was
   * exported to the grid, based on the first quarter of production. This
   * affects the calculations if net metering is not allowed.
   *
   * @generated from field: optional float percentage_exported_to_grid = 10;
   */
  percentageExportedToGrid?: number;
};

/**
 * Describes the message google.maps.solar.v1.FinancialDetails.
 * Use `create(FinancialDetailsSchema)` to create a new message.
 */
export const FinancialDetailsSchema: GenMessage<FinancialDetails> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 10);

/**
 * Financial information that's shared between different financing methods.
 *
 * @generated from message google.maps.solar.v1.SavingsOverTime
 */
export type SavingsOverTime = Message<"google.maps.solar.v1.SavingsOverTime"> & {
  /**
   * Savings in the first year after panel installation.
   *
   * @generated from field: google.type.Money savings_year1 = 1;
   */
  savingsYear1?: Money;

  /**
   * Savings in the first twenty years after panel installation.
   *
   * @generated from field: google.type.Money savings_year20 = 2;
   */
  savingsYear20?: Money;

  /**
   * Using the assumed discount rate, what is the present value of the
   * cumulative 20-year savings?
   *
   * @generated from field: google.type.Money present_value_of_savings_year20 = 3;
   */
  presentValueOfSavingsYear20?: Money;

  /**
   * Savings in the entire panel lifetime.
   *
   * @generated from field: google.type.Money savings_lifetime = 5;
   */
  savingsLifetime?: Money;

  /**
   * Using the assumed discount rate, what is the present value of the
   * cumulative lifetime savings?
   *
   * @generated from field: google.type.Money present_value_of_savings_lifetime = 6;
   */
  presentValueOfSavingsLifetime?: Money;

  /**
   * Indicates whether this scenario is financially viable.  Will be false for
   * scenarios with poor financial viability (e.g., money-losing).
   *
   * @generated from field: bool financially_viable = 4;
   */
  financiallyViable: boolean;
};

/**
 * Describes the message google.maps.solar.v1.SavingsOverTime.
 * Use `create(SavingsOverTimeSchema)` to create a new message.
 */
export const SavingsOverTimeSchema: GenMessage<SavingsOverTime> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 11);

/**
 * Cost and benefit of leasing a particular configuration of solar panels
 * with a particular electricity usage.
 *
 * @generated from message google.maps.solar.v1.LeasingSavings
 */
export type LeasingSavings = Message<"google.maps.solar.v1.LeasingSavings"> & {
  /**
   * Whether leases are allowed in this juristiction (leases are not
   * allowed in some states). If this field is false, then the values in
   * this message should probably be ignored.
   *
   * @generated from field: bool leases_allowed = 1;
   */
  leasesAllowed: boolean;

  /**
   * Whether leases are supported in this juristiction by the financial
   * calculation engine. If this field is false, then the values in this
   * message should probably be ignored. This is independent of
   * `leases_allowed`: in some areas leases are allowed, but under conditions
   * that aren't handled by the financial models.
   *
   * @generated from field: bool leases_supported = 2;
   */
  leasesSupported: boolean;

  /**
   * Estimated annual leasing cost.
   *
   * @generated from field: google.type.Money annual_leasing_cost = 3;
   */
  annualLeasingCost?: Money;

  /**
   * How much is saved (or not) over the lifetime period.
   *
   * @generated from field: google.maps.solar.v1.SavingsOverTime savings = 4;
   */
  savings?: SavingsOverTime;
};

/**
 * Describes the message google.maps.solar.v1.LeasingSavings.
 * Use `create(LeasingSavingsSchema)` to create a new message.
 */
export const LeasingSavingsSchema: GenMessage<LeasingSavings> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 12);

/**
 * Cost and benefit of an outright purchase of a particular configuration
 * of solar panels with a particular electricity usage.
 *
 * @generated from message google.maps.solar.v1.CashPurchaseSavings
 */
export type CashPurchaseSavings = Message<"google.maps.solar.v1.CashPurchaseSavings"> & {
  /**
   * Initial cost before tax incentives: the amount that must be paid
   * out-of-pocket. Contrast with `upfront_cost`, which is after tax incentives.
   *
   * @generated from field: google.type.Money out_of_pocket_cost = 1;
   */
  outOfPocketCost?: Money;

  /**
   * Initial cost after tax incentives: it's the amount that must be paid
   * during first year. Contrast with `out_of_pocket_cost`, which is before tax
   * incentives.
   *
   * @generated from field: google.type.Money upfront_cost = 2;
   */
  upfrontCost?: Money;

  /**
   * The value of all tax rebates.
   *
   * @generated from field: google.type.Money rebate_value = 3;
   */
  rebateValue?: Money;

  /**
   * Number of years until payback occurs. A negative value means payback
   * never occurs within the lifetime period.
   *
   * @generated from field: optional float payback_years = 4;
   */
  paybackYears?: number;

  /**
   * How much is saved (or not) over the lifetime period.
   *
   * @generated from field: google.maps.solar.v1.SavingsOverTime savings = 5;
   */
  savings?: SavingsOverTime;
};

/**
 * Describes the message google.maps.solar.v1.CashPurchaseSavings.
 * Use `create(CashPurchaseSavingsSchema)` to create a new message.
 */
export const CashPurchaseSavingsSchema: GenMessage<CashPurchaseSavings> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 13);

/**
 * Cost and benefit of using a loan to buy a particular configuration
 * of solar panels with a particular electricity usage.
 *
 * @generated from message google.maps.solar.v1.FinancedPurchaseSavings
 */
export type FinancedPurchaseSavings = Message<"google.maps.solar.v1.FinancedPurchaseSavings"> & {
  /**
   * Annual loan payments.
   *
   * @generated from field: google.type.Money annual_loan_payment = 1;
   */
  annualLoanPayment?: Money;

  /**
   * The value of all tax rebates (including Federal Investment Tax Credit
   * (ITC)).
   *
   * @generated from field: google.type.Money rebate_value = 2;
   */
  rebateValue?: Money;

  /**
   * The interest rate on loans assumed in this set of calculations.
   *
   * @generated from field: float loan_interest_rate = 3;
   */
  loanInterestRate: number;

  /**
   * How much is saved (or not) over the lifetime period.
   *
   * @generated from field: google.maps.solar.v1.SavingsOverTime savings = 4;
   */
  savings?: SavingsOverTime;
};

/**
 * Describes the message google.maps.solar.v1.FinancedPurchaseSavings.
 * Use `create(FinancedPurchaseSavingsSchema)` to create a new message.
 */
export const FinancedPurchaseSavingsSchema: GenMessage<FinancedPurchaseSavings> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 14);

/**
 * Request message for `Solar.GetDataLayers`.
 *
 * @generated from message google.maps.solar.v1.GetDataLayersRequest
 */
export type GetDataLayersRequest = Message<"google.maps.solar.v1.GetDataLayersRequest"> & {
  /**
   * Required. The longitude and latitude for the center of the region to get
   * data for.
   *
   * @generated from field: google.type.LatLng location = 1;
   */
  location?: LatLng;

  /**
   * Required. The radius, in meters, defining the region surrounding that
   * centre point for which data should be returned. The limitations
   * on this value are:
   *
   * * Any value up to 100m can always be specified.
   * * Values over 100m can be specified, as long as
   *   `radius_meters` <= `pixel_size_meters * 1000`.
   * * However, for values over 175m, the `DataLayerView` in the
   *   request must not include monthly flux or hourly shade.
   *
   * @generated from field: float radius_meters = 2;
   */
  radiusMeters: number;

  /**
   * Optional. The desired subset of the data to return.
   *
   * @generated from field: google.maps.solar.v1.DataLayerView view = 3;
   */
  view: DataLayerView;

  /**
   * Optional. The minimum quality level allowed in the results. No result with
   * lower quality than this will be returned. Not specifying this is
   * equivalent to restricting to HIGH quality only.
   *
   * @generated from field: google.maps.solar.v1.ImageryQuality required_quality = 5;
   */
  requiredQuality: ImageryQuality;

  /**
   * Optional. The minimum scale, in meters per pixel, of the data to return.
   * Values of 0.1 (the default, if this field is not set explicitly),
   * 0.25, 0.5, and 1.0 are supported. Imagery components whose normal
   * resolution is less than `pixel_size_meters` will be returned at
   * the resolution specified by `pixel_size_meters`; imagery
   * components whose normal resolution is equal to or greater than
   * `pixel_size_meters` will be returned at that normal resolution.
   *
   * @generated from field: float pixel_size_meters = 6;
   */
  pixelSizeMeters: number;

  /**
   * Optional. Whether to require exact quality of the imagery.
   * If set to false, the `required_quality` field is interpreted as the minimum
   * required quality, such that HIGH quality imagery may be returned when
   * `required_quality` is set to MEDIUM.  If set to true, `required_quality`
   * is interpreted as the exact required quality and only `MEDIUM` quality
   * imagery is returned if `required_quality` is set to `MEDIUM`.
   *
   * @generated from field: bool exact_quality_required = 7;
   */
  exactQualityRequired: boolean;
};

/**
 * Describes the message google.maps.solar.v1.GetDataLayersRequest.
 * Use `create(GetDataLayersRequestSchema)` to create a new message.
 */
export const GetDataLayersRequestSchema: GenMessage<GetDataLayersRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 15);

/**
 * Information about the solar potential of a region. The actual data
 * are contained in a number of GeoTIFF files covering the requested
 * region, for which this message contains URLs: Each string in the
 * `DataLayers` message contains a URL from which the
 * corresponding GeoTIFF can be fetched. These URLs are valid for a
 * few hours after they've been generated. Most of the GeoTIFF files
 * are at a resolution of 0.1m/pixel, but the monthly flux file is at
 * 0.5m/pixel, and the hourly shade files are at 1m/pixel. If a
 * `pixel_size_meters` value was specified in the
 * `GetDataLayersRequest`, then the minimum resolution in the GeoTIFF
 * files will be that value.
 *
 * @generated from message google.maps.solar.v1.DataLayers
 */
export type DataLayers = Message<"google.maps.solar.v1.DataLayers"> & {
  /**
   * When the source imagery (from which all the other data are derived) in this
   * region was taken. It is necessarily somewhat approximate, as the images may
   * have been taken over more than one day.
   *
   * @generated from field: google.type.Date imagery_date = 1;
   */
  imageryDate?: Date;

  /**
   * When processing was completed on this imagery.
   *
   * @generated from field: google.type.Date imagery_processed_date = 2;
   */
  imageryProcessedDate?: Date;

  /**
   * The URL for an image of the DSM (Digital Surface Model) of the region.
   * Values are in meters above EGM96 geoid (i.e., sea level). Invalid locations
   * (where we don't have data) are stored as -9999.
   *
   * @generated from field: string dsm_url = 3;
   */
  dsmUrl: string;

  /**
   * The URL for an image of RGB data (aerial photo) of the region.
   *
   * @generated from field: string rgb_url = 4;
   */
  rgbUrl: string;

  /**
   * The URL for the building mask image: one bit per pixel saying whether that
   * pixel is considered to be part of a rooftop or not.
   *
   * @generated from field: string mask_url = 5;
   */
  maskUrl: string;

  /**
   * The URL for the annual flux map (annual sunlight on roofs) of the region.
   * Values are kWh/kW/year. This is *unmasked flux*: flux is computed for every
   * location, not just building rooftops. Invalid locations are stored as
   * -9999: locations outside our coverage area will be invalid, and a few
   * locations inside the coverage area, where we were unable to calculate flux,
   * will also be invalid.
   *
   * @generated from field: string annual_flux_url = 6;
   */
  annualFluxUrl: string;

  /**
   * The URL for the monthly flux map (sunlight on roofs, broken down by month)
   * of the region. Values are kWh/kW/year. The GeoTIFF pointed to by this URL
   * will contain twelve bands, corresponding to January...December, in order.
   *
   * @generated from field: string monthly_flux_url = 7;
   */
  monthlyFluxUrl: string;

  /**
   * Twelve URLs for hourly shade, corresponding to January...December, in
   * order. Each GeoTIFF will contain 24 bands, corresponding to the 24 hours of
   * the day. Each pixel is a 32 bit integer, corresponding to the (up to) 31
   * days of that month; a 1 bit means that the corresponding location is able
   * to see the sun at that day, of that hour, of that month. Invalid locations
   * are stored as -9999 (since this is negative, it has bit 31 set, and no
   * valid value could have bit 31 set as that would correspond to the 32nd day
   * of the month).
   *
   * An example may be useful. If you want to know whether a point (at
   * pixel location (x, y)) saw sun at 4pm on the 22nd of June you
   * would:
   *
   * 1. fetch the sixth URL in this list (corresponding to June).
   * 1. look up the 17th channel (corresponding to 4pm).
   * 1. read the 32-bit value at (x, y).
   * 1. read bit 21 of the value (corresponding to the 22nd of the month).
   * 1. if that bit is a 1, then that spot saw the sun at 4pm 22 June.
   *
   * More formally:
   * Given `month` (1-12), `day` (1...month max; February has 28 days)
   * and `hour` (0-23), the shade/sun for that month/day/hour at a
   * position `(x, y)` is the bit
   * ```
   * (hourly_shade[month - 1])(x, y)[hour] & (1 << (day - 1))
   * ```
   * where `(x, y)` is spatial indexing, `[month - 1]` refers to
   * fetching the `month - 1`st URL (indexing from zero), `[hour]` is
   * indexing into the channels, and a final non-zero result means
   * "sunny". There are no leap days, and DST doesn't exist (all days
   * are 24 hours long; noon is always "standard time" noon).
   *
   * @generated from field: repeated string hourly_shade_urls = 8;
   */
  hourlyShadeUrls: string[];

  /**
   * The quality of the result's imagery.
   *
   * @generated from field: google.maps.solar.v1.ImageryQuality imagery_quality = 9;
   */
  imageryQuality: ImageryQuality;
};

/**
 * Describes the message google.maps.solar.v1.DataLayers.
 * Use `create(DataLayersSchema)` to create a new message.
 */
export const DataLayersSchema: GenMessage<DataLayers> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 16);

/**
 * Request message for `Solar.GetGeoTiff`.
 *
 * @generated from message google.maps.solar.v1.GetGeoTiffRequest
 */
export type GetGeoTiffRequest = Message<"google.maps.solar.v1.GetGeoTiffRequest"> & {
  /**
   * Required. The ID of the asset being requested.
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message google.maps.solar.v1.GetGeoTiffRequest.
 * Use `create(GetGeoTiffRequestSchema)` to create a new message.
 */
export const GetGeoTiffRequestSchema: GenMessage<GetGeoTiffRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_solar_v1_solar_service, 17);

/**
 * What subset of the solar information to return.
 *
 * @generated from enum google.maps.solar.v1.DataLayerView
 */
export enum DataLayerView {
  /**
   * Equivalent to FULL.
   *
   * @generated from enum value: DATA_LAYER_VIEW_UNSPECIFIED = 0;
   */
  DATA_LAYER_VIEW_UNSPECIFIED = 0,

  /**
   * Get the DSM only.
   *
   * @generated from enum value: DSM_LAYER = 1;
   */
  DSM_LAYER = 1,

  /**
   * Get the DSM, RGB, and mask.
   *
   * @generated from enum value: IMAGERY_LAYERS = 2;
   */
  IMAGERY_LAYERS = 2,

  /**
   * Get the DSM, RGB, mask, and annual flux.
   *
   * @generated from enum value: IMAGERY_AND_ANNUAL_FLUX_LAYERS = 3;
   */
  IMAGERY_AND_ANNUAL_FLUX_LAYERS = 3,

  /**
   * Get the DSM, RGB, mask, annual flux, and monthly flux.
   *
   * @generated from enum value: IMAGERY_AND_ALL_FLUX_LAYERS = 4;
   */
  IMAGERY_AND_ALL_FLUX_LAYERS = 4,

  /**
   * Get all data.
   *
   * @generated from enum value: FULL_LAYERS = 5;
   */
  FULL_LAYERS = 5,
}

/**
 * Describes the enum google.maps.solar.v1.DataLayerView.
 */
export const DataLayerViewSchema: GenEnum<DataLayerView> = /*@__PURE__*/
  enumDesc(file_google_maps_solar_v1_solar_service, 0);

/**
 * The quality of the imagery used to compute some API result.
 *
 * Note: Regardless of imagery quality level, DSM outputs always have a
 * resolution of 0.1 m/pixel, monthly flux outputs always have a resolution of
 * 0.5 m/pixel, and hourly shade outputs always have a resolution of 1 m/pixel.
 *
 * @generated from enum google.maps.solar.v1.ImageryQuality
 */
export enum ImageryQuality {
  /**
   * No quality is known.
   *
   * @generated from enum value: IMAGERY_QUALITY_UNSPECIFIED = 0;
   */
  IMAGERY_QUALITY_UNSPECIFIED = 0,

  /**
   * The underlying imagery and DSM data were processed at 0.1 m/pixel.
   *
   * @generated from enum value: HIGH = 1;
   */
  HIGH = 1,

  /**
   * The underlying imagery and DSM data were processed at 0.25 m/pixel.
   *
   * @generated from enum value: MEDIUM = 2;
   */
  MEDIUM = 2,

  /**
   * The underlying imagery and DSM data were processed at 0.5 m/pixel.
   *
   * @generated from enum value: LOW = 3;
   */
  LOW = 3,
}

/**
 * Describes the enum google.maps.solar.v1.ImageryQuality.
 */
export const ImageryQualitySchema: GenEnum<ImageryQuality> = /*@__PURE__*/
  enumDesc(file_google_maps_solar_v1_solar_service, 1);

/**
 * The orientation of a solar panel. This must be interpreted relative to the
 * azimuth of the roof segment that the panel is placed on.
 *
 * @generated from enum google.maps.solar.v1.SolarPanelOrientation
 */
export enum SolarPanelOrientation {
  /**
   * No panel orientation is known.
   *
   * @generated from enum value: SOLAR_PANEL_ORIENTATION_UNSPECIFIED = 0;
   */
  SOLAR_PANEL_ORIENTATION_UNSPECIFIED = 0,

  /**
   * A `LANDSCAPE` panel has its long edge perpendicular to the
   * azimuth direction of the roof segment that it is placed on.
   *
   * @generated from enum value: LANDSCAPE = 1;
   */
  LANDSCAPE = 1,

  /**
   * A `PORTRAIT` panel has its long edge parallel to the azimuth
   * direction of the roof segment that it is placed on.
   *
   * @generated from enum value: PORTRAIT = 2;
   */
  PORTRAIT = 2,
}

/**
 * Describes the enum google.maps.solar.v1.SolarPanelOrientation.
 */
export const SolarPanelOrientationSchema: GenEnum<SolarPanelOrientation> = /*@__PURE__*/
  enumDesc(file_google_maps_solar_v1_solar_service, 2);

/**
 * Service definition for the Solar API.
 *
 * @generated from service google.maps.solar.v1.Solar
 */
export const Solar: GenService<{
  /**
   * Locates the closest building to a query point. Returns an error with
   * code `NOT_FOUND` if there are no buildings within approximately 50m of the
   * query point.
   *
   * @generated from rpc google.maps.solar.v1.Solar.FindClosestBuildingInsights
   */
  findClosestBuildingInsights: {
    methodKind: "unary";
    input: typeof FindClosestBuildingInsightsRequestSchema;
    output: typeof BuildingInsightsSchema;
  },
  /**
   * Gets solar information for a region surrounding a location.
   * Returns an error with code `NOT_FOUND` if the location is outside
   * the coverage area.
   *
   * @generated from rpc google.maps.solar.v1.Solar.GetDataLayers
   */
  getDataLayers: {
    methodKind: "unary";
    input: typeof GetDataLayersRequestSchema;
    output: typeof DataLayersSchema;
  },
  /**
   * Returns an image by its ID.
   *
   * @generated from rpc google.maps.solar.v1.Solar.GetGeoTiff
   */
  getGeoTiff: {
    methodKind: "unary";
    input: typeof GetGeoTiffRequestSchema;
    output: typeof HttpBodySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_maps_solar_v1_solar_service, 0);

