// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/maps/routes/v1/route.proto (package google.maps.routes.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { Viewport } from "../../../geo/type/viewport_pb";
import { file_google_geo_type_viewport } from "../../../geo/type/viewport_pb";
import type { Polyline } from "./polyline_pb";
import { file_google_maps_routes_v1_polyline } from "./polyline_pb";
import type { Location } from "./waypoint_pb";
import { file_google_maps_routes_v1_waypoint } from "./waypoint_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration } from "@bufbuild/protobuf/wkt";
import type { Money } from "../../../type/money_pb";
import { file_google_type_money } from "../../../type/money_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/maps/routes/v1/route.proto.
 */
export const file_google_maps_routes_v1_route: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvbWFwcy9yb3V0ZXMvdjEvcm91dGUucHJvdG8SFWdvb2dsZS5tYXBzLnJvdXRlcy52MSKrAwoFUm91dGUSLQoEbGVncxgBIAMoCzIfLmdvb2dsZS5tYXBzLnJvdXRlcy52MS5Sb3V0ZUxlZxIXCg9kaXN0YW5jZV9tZXRlcnMYAiABKAUSKwoIZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMgoPc3RhdGljX2R1cmF0aW9uGAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjEKCHBvbHlsaW5lGAUgASgLMh8uZ29vZ2xlLm1hcHMucm91dGVzLnYxLlBvbHlsaW5lEhMKC2Rlc2NyaXB0aW9uGAYgASgJEhAKCHdhcm5pbmdzGAcgAygJEisKCHZpZXdwb3J0GAggASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdwb3J0EkMKD3RyYXZlbF9hZHZpc29yeRgJIAEoCzIqLmdvb2dsZS5tYXBzLnJvdXRlcy52MS5Sb3V0ZVRyYXZlbEFkdmlzb3J5Ei0KJW9wdGltaXplZF9pbnRlcm1lZGlhdGVfd2F5cG9pbnRfaW5kZXgYCiADKAUipgIKE1JvdXRlVHJhdmVsQWR2aXNvcnkSRgoTdHJhZmZpY19yZXN0cmljdGlvbhgBIAEoCzIpLmdvb2dsZS5tYXBzLnJvdXRlcy52MS5UcmFmZmljUmVzdHJpY3Rpb24SMgoJdG9sbF9pbmZvGAIgASgLMh8uZ29vZ2xlLm1hcHMucm91dGVzLnYxLlRvbGxJbmZvEkwKF3NwZWVkX3JlYWRpbmdfaW50ZXJ2YWxzGAMgAygLMisuZ29vZ2xlLm1hcHMucm91dGVzLnYxLlNwZWVkUmVhZGluZ0ludGVydmFsEkUKEWN1c3RvbV9sYXllcl9pbmZvGAQgASgLMiYuZ29vZ2xlLm1hcHMucm91dGVzLnYxLkN1c3RvbUxheWVySW5mb0ICGAEi4QEKFlJvdXRlTGVnVHJhdmVsQWR2aXNvcnkSMgoJdG9sbF9pbmZvGAEgASgLMh8uZ29vZ2xlLm1hcHMucm91dGVzLnYxLlRvbGxJbmZvEkwKF3NwZWVkX3JlYWRpbmdfaW50ZXJ2YWxzGAIgAygLMisuZ29vZ2xlLm1hcHMucm91dGVzLnYxLlNwZWVkUmVhZGluZ0ludGVydmFsEkUKEWN1c3RvbV9sYXllcl9pbmZvGAMgASgLMiYuZ29vZ2xlLm1hcHMucm91dGVzLnYxLkN1c3RvbUxheWVySW5mb0ICGAEiagoaUm91dGVMZWdTdGVwVHJhdmVsQWR2aXNvcnkSTAoXc3BlZWRfcmVhZGluZ19pbnRlcnZhbHMYASADKAsyKy5nb29nbGUubWFwcy5yb3V0ZXMudjEuU3BlZWRSZWFkaW5nSW50ZXJ2YWwigwEKElRyYWZmaWNSZXN0cmljdGlvbhJtCihsaWNlbnNlX3BsYXRlX2xhc3RfY2hhcmFjdGVyX3Jlc3RyaWN0aW9uGAEgASgLMjsuZ29vZ2xlLm1hcHMucm91dGVzLnYxLkxpY2Vuc2VQbGF0ZUxhc3RDaGFyYWN0ZXJSZXN0cmljdGlvbiJHCiRMaWNlbnNlUGxhdGVMYXN0Q2hhcmFjdGVyUmVzdHJpY3Rpb24SHwoXYWxsb3dlZF9sYXN0X2NoYXJhY3RlcnMYASADKAkiowMKCFJvdXRlTGVnEhcKD2Rpc3RhbmNlX21ldGVycxgBIAEoBRIrCghkdXJhdGlvbhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIyCg9zdGF0aWNfZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoIcG9seWxpbmUYBCABKAsyHy5nb29nbGUubWFwcy5yb3V0ZXMudjEuUG9seWxpbmUSNwoOc3RhcnRfbG9jYXRpb24YBSABKAsyHy5nb29nbGUubWFwcy5yb3V0ZXMudjEuTG9jYXRpb24SNQoMZW5kX2xvY2F0aW9uGAYgASgLMh8uZ29vZ2xlLm1hcHMucm91dGVzLnYxLkxvY2F0aW9uEjIKBXN0ZXBzGAcgAygLMiMuZ29vZ2xlLm1hcHMucm91dGVzLnYxLlJvdXRlTGVnU3RlcBJGCg90cmF2ZWxfYWR2aXNvcnkYCCABKAsyLS5nb29nbGUubWFwcy5yb3V0ZXMudjEuUm91dGVMZWdUcmF2ZWxBZHZpc29yeSI3CghUb2xsSW5mbxIrCg9lc3RpbWF0ZWRfcHJpY2UYASADKAsyEi5nb29nbGUudHlwZS5Nb25leSKYAwoMUm91dGVMZWdTdGVwEhcKD2Rpc3RhbmNlX21ldGVycxgBIAEoBRIyCg9zdGF0aWNfZHVyYXRpb24YAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoIcG9seWxpbmUYAyABKAsyHy5nb29nbGUubWFwcy5yb3V0ZXMudjEuUG9seWxpbmUSNwoOc3RhcnRfbG9jYXRpb24YBCABKAsyHy5nb29nbGUubWFwcy5yb3V0ZXMudjEuTG9jYXRpb24SNQoMZW5kX2xvY2F0aW9uGAUgASgLMh8uZ29vZ2xlLm1hcHMucm91dGVzLnYxLkxvY2F0aW9uEkwKFm5hdmlnYXRpb25faW5zdHJ1Y3Rpb24YBiABKAsyLC5nb29nbGUubWFwcy5yb3V0ZXMudjEuTmF2aWdhdGlvbkluc3RydWN0aW9uEkoKD3RyYXZlbF9hZHZpc29yeRgHIAEoCzIxLmdvb2dsZS5tYXBzLnJvdXRlcy52MS5Sb3V0ZUxlZ1N0ZXBUcmF2ZWxBZHZpc29yeSJgChVOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24SMQoIbWFuZXV2ZXIYASABKA4yHy5nb29nbGUubWFwcy5yb3V0ZXMudjEuTWFuZXV2ZXISFAoMaW5zdHJ1Y3Rpb25zGAIgASgJIuUBChRTcGVlZFJlYWRpbmdJbnRlcnZhbBIiChpzdGFydF9wb2x5bGluZV9wb2ludF9pbmRleBgBIAEoBRIgChhlbmRfcG9seWxpbmVfcG9pbnRfaW5kZXgYAiABKAUSQAoFc3BlZWQYAyABKA4yMS5nb29nbGUubWFwcy5yb3V0ZXMudjEuU3BlZWRSZWFkaW5nSW50ZXJ2YWwuU3BlZWQiRQoFU3BlZWQSFQoRU1BFRURfVU5TUEVDSUZJRUQQABIKCgZOT1JNQUwQARIICgRTTE9XEAISDwoLVFJBRkZJQ19KQU0QAyKwAgoPQ3VzdG9tTGF5ZXJJbmZvEkIKCWFyZWFfaW5mbxgBIAMoCzIvLmdvb2dsZS5tYXBzLnJvdXRlcy52MS5DdXN0b21MYXllckluZm8uQXJlYUluZm8SJgoedG90YWxfZGlzdGFuY2VfaW5fYXJlYXNfbWV0ZXJzGAIgASgCEjoKF3RvdGFsX2R1cmF0aW9uX2luX2FyZWFzGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uGnEKCEFyZWFJbmZvEg8KB2FyZWFfaWQYASABKAkSHwoXZGlzdGFuY2VfaW5fYXJlYV9tZXRlcnMYAiABKAISMwoQZHVyYXRpb25faW5fYXJlYRgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbjoCGAEq9wIKCE1hbmV1dmVyEhgKFE1BTkVVVkVSX1VOU1BFQ0lGSUVEEAASFAoQVFVSTl9TTElHSFRfTEVGVBABEhMKD1RVUk5fU0hBUlBfTEVGVBACEg4KClVUVVJOX0xFRlQQAxINCglUVVJOX0xFRlQQBBIVChFUVVJOX1NMSUdIVF9SSUdIVBAFEhQKEFRVUk5fU0hBUlBfUklHSFQQBhIPCgtVVFVSTl9SSUdIVBAHEg4KClRVUk5fUklHSFQQCBIMCghTVFJBSUdIVBAJEg0KCVJBTVBfTEVGVBAKEg4KClJBTVBfUklHSFQQCxIJCgVNRVJHRRAMEg0KCUZPUktfTEVGVBANEg4KCkZPUktfUklHSFQQDhIJCgVGRVJSWRAPEg8KC0ZFUlJZX1RSQUlOEBASEwoPUk9VTkRBQk9VVF9MRUZUEBESFAoQUk9VTkRBQk9VVF9SSUdIVBASEgoKBkRFUEFSVBATEg8KC05BTUVfQ0hBTkdFEBRCnAEKGWNvbS5nb29nbGUubWFwcy5yb3V0ZXMudjFCClJvdXRlUHJvdG9QAVo3Y2xvdWQuZ29vZ2xlLmNvbS9nby9tYXBzL3JvdXRlcy9hcGl2MS9yb3V0ZXNwYjtyb3V0ZXNwYvgBAaICBEdNUlOqAhVHb29nbGUuTWFwcy5Sb3V0ZXMuVjHKAhVHb29nbGVcTWFwc1xSb3V0ZXNcVjFiBnByb3RvMw", [file_google_api_field_behavior, file_google_geo_type_viewport, file_google_maps_routes_v1_polyline, file_google_maps_routes_v1_waypoint, file_google_protobuf_duration, file_google_type_money]);

/**
 * Encapsulates a route, which consists of a series of connected road segments
 * that join beginning, ending, and intermediate waypoints.
 *
 * @generated from message google.maps.routes.v1.Route
 */
export type Route = Message<"google.maps.routes.v1.Route"> & {
  /**
   * A collection of legs (path segments between waypoints) that make-up the
   * route. Each leg corresponds to the trip between two non-`via` Waypoints.
   * For example, a route with no intermediate waypoints has only one leg. A
   * route that includes one non-`via` intermediate waypoint has two legs. A
   * route that includes one `via` intermediate waypoint has one leg. The order
   * of the legs matches the order of Waypoints from `origin` to `intermediates`
   * to `destination`.
   *
   * @generated from field: repeated google.maps.routes.v1.RouteLeg legs = 1;
   */
  legs: RouteLeg[];

  /**
   * The travel distance of the route, in meters.
   *
   * @generated from field: int32 distance_meters = 2;
   */
  distanceMeters: number;

  /**
   * The length of time needed to navigate the route. If you set the
   * `routing_preference` to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If you set the `routing_preference` to either
   * `TRAFFIC_AWARE` or `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated
   * taking traffic conditions into account.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: Duration;

  /**
   * The duration of traveling through the route without taking traffic
   * conditions into consideration.
   *
   * @generated from field: google.protobuf.Duration static_duration = 4;
   */
  staticDuration?: Duration;

  /**
   * The overall route polyline. This polyline is the combined polyline of all
   * `legs`.
   *
   * @generated from field: google.maps.routes.v1.Polyline polyline = 5;
   */
  polyline?: Polyline;

  /**
   * A description of the route.
   *
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * An array of warnings to show when displaying the route.
   *
   * @generated from field: repeated string warnings = 7;
   */
  warnings: string[];

  /**
   * The viewport bounding box of the polyline.
   *
   * @generated from field: google.geo.type.Viewport viewport = 8;
   */
  viewport?: Viewport;

  /**
   * Additional information about the route.
   *
   * @generated from field: google.maps.routes.v1.RouteTravelAdvisory travel_advisory = 9;
   */
  travelAdvisory?: RouteTravelAdvisory;

  /**
   * If `ComputeRoutesRequest.optimize_waypoint_order` is set to true, this
   * field contains the optimized ordering of intermediates waypoints.
   * otherwise, this field is empty.
   * For example, suppose the input is Origin: LA; Intermediates: Dallas,
   * Bangor, Phoenix;  Destination: New York; and the optimized intermediate
   * waypoint order is:  Phoenix, Dallas, Bangor. Then this field contains the
   * values [2, 0, 1]. The index starts with 0 for the first intermediate
   * waypoint.
   *
   * @generated from field: repeated int32 optimized_intermediate_waypoint_index = 10;
   */
  optimizedIntermediateWaypointIndex: number[];
};

/**
 * Describes the message google.maps.routes.v1.Route.
 * Use `create(RouteSchema)` to create a new message.
 */
export const RouteSchema: GenMessage<Route> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 0);

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction etc.
 *
 * @generated from message google.maps.routes.v1.RouteTravelAdvisory
 */
export type RouteTravelAdvisory = Message<"google.maps.routes.v1.RouteTravelAdvisory"> & {
  /**
   * The traffic restriction that applies to the route. A vehicle that is
   * subject to the restriction is not allowed to travel on the route. As of
   * October 2019, only Jakarta, Indonesia takes into consideration.
   *
   * @generated from field: google.maps.routes.v1.TrafficRestriction traffic_restriction = 1;
   */
  trafficRestriction?: TrafficRestriction;

  /**
   * Encapsulates information about tolls on the Route.
   * This field is only populated if we expect there are tolls on the Route.
   * If this field is set but the `estimated_price` subfield is not populated,
   * we expect that road contains tolls but we do not know an estimated price.
   * If this field is not set, then we expect there is no toll on the Route.
   *
   * @generated from field: google.maps.routes.v1.TollInfo toll_info = 2;
   */
  tollInfo?: TollInfo;

  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the route without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   *
   * @generated from field: repeated google.maps.routes.v1.SpeedReadingInterval speed_reading_intervals = 3;
   */
  speedReadingIntervals: SpeedReadingInterval[];

  /**
   * Deprecated: This field will stop being populated soon.
   * Information related to the custom layer data that the customer specified
   * (e.g. time spent in a customer specified area).
   *
   * @generated from field: google.maps.routes.v1.CustomLayerInfo custom_layer_info = 4 [deprecated = true];
   * @deprecated
   */
  customLayerInfo?: CustomLayerInfo;
};

/**
 * Describes the message google.maps.routes.v1.RouteTravelAdvisory.
 * Use `create(RouteTravelAdvisorySchema)` to create a new message.
 */
export const RouteTravelAdvisorySchema: GenMessage<RouteTravelAdvisory> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 1);

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction etc. on a route leg.
 *
 * @generated from message google.maps.routes.v1.RouteLegTravelAdvisory
 */
export type RouteLegTravelAdvisory = Message<"google.maps.routes.v1.RouteLegTravelAdvisory"> & {
  /**
   * Encapsulates information about tolls on the specific `RouteLeg`.
   * This field is only populated if we expect there are tolls on the
   * `RouteLeg`. If this field is set but the `estimated_price` subfield is not
   * populated, we expect that road contains tolls but we do not know an
   * estimated price. If this field does not exist, then there is no toll on the
   * `RouteLeg`.
   *
   * @generated from field: google.maps.routes.v1.TollInfo toll_info = 1;
   */
  tollInfo?: TollInfo;

  /**
   * Speed reading intervals detailing traffic density. Applicable in case of
   * `TRAFFIC_AWARE` and `TRAFFIC_AWARE_OPTIMAL` routing preferences.
   * The intervals cover the entire polyline of the `RouteLeg` without overlap.
   * The start point of a specified interval is the same as the end point of the
   * preceding interval.
   *
   * Example:
   *
   *     polyline: A ---- B ---- C ---- D ---- E ---- F ---- G
   *     speed_reading_intervals: [A,C), [C,D), [D,G).
   *
   * @generated from field: repeated google.maps.routes.v1.SpeedReadingInterval speed_reading_intervals = 2;
   */
  speedReadingIntervals: SpeedReadingInterval[];

  /**
   * Deprecated: This field will stop being populated soon.
   * Information related to the custom layer data that the customer specified
   * (e.g. time spent in a customer specified area).
   *
   * @generated from field: google.maps.routes.v1.CustomLayerInfo custom_layer_info = 3 [deprecated = true];
   * @deprecated
   */
  customLayerInfo?: CustomLayerInfo;
};

/**
 * Describes the message google.maps.routes.v1.RouteLegTravelAdvisory.
 * Use `create(RouteLegTravelAdvisorySchema)` to create a new message.
 */
export const RouteLegTravelAdvisorySchema: GenMessage<RouteLegTravelAdvisory> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 2);

/**
 * Encapsulates the additional information that the user should be informed
 * about, such as possible traffic zone restriction on a leg step.
 *
 * @generated from message google.maps.routes.v1.RouteLegStepTravelAdvisory
 */
export type RouteLegStepTravelAdvisory = Message<"google.maps.routes.v1.RouteLegStepTravelAdvisory"> & {
  /**
   * NOTE: This field is not currently populated.
   *
   * @generated from field: repeated google.maps.routes.v1.SpeedReadingInterval speed_reading_intervals = 1;
   */
  speedReadingIntervals: SpeedReadingInterval[];
};

/**
 * Describes the message google.maps.routes.v1.RouteLegStepTravelAdvisory.
 * Use `create(RouteLegStepTravelAdvisorySchema)` to create a new message.
 */
export const RouteLegStepTravelAdvisorySchema: GenMessage<RouteLegStepTravelAdvisory> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 3);

/**
 * Encapsulates the traffic restriction applied to the route. As of October
 * 2019, only Jakarta, Indonesia takes into consideration.
 *
 * @generated from message google.maps.routes.v1.TrafficRestriction
 */
export type TrafficRestriction = Message<"google.maps.routes.v1.TrafficRestriction"> & {
  /**
   * The restriction based on the vehicle's license plate last character. If
   * this field does not exist, then no restriction on route.
   *
   * @generated from field: google.maps.routes.v1.LicensePlateLastCharacterRestriction license_plate_last_character_restriction = 1;
   */
  licensePlateLastCharacterRestriction?: LicensePlateLastCharacterRestriction;
};

/**
 * Describes the message google.maps.routes.v1.TrafficRestriction.
 * Use `create(TrafficRestrictionSchema)` to create a new message.
 */
export const TrafficRestrictionSchema: GenMessage<TrafficRestriction> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 4);

/**
 * Encapsulates the license plate last character restriction.
 *
 * @generated from message google.maps.routes.v1.LicensePlateLastCharacterRestriction
 */
export type LicensePlateLastCharacterRestriction = Message<"google.maps.routes.v1.LicensePlateLastCharacterRestriction"> & {
  /**
   * The allowed last character of a license plate of a vehicle. Only vehicles
   * whose license plate's last characters match these are allowed to travel on
   * the route. If empty, no vehicle is allowed.
   *
   * @generated from field: repeated string allowed_last_characters = 1;
   */
  allowedLastCharacters: string[];
};

/**
 * Describes the message google.maps.routes.v1.LicensePlateLastCharacterRestriction.
 * Use `create(LicensePlateLastCharacterRestrictionSchema)` to create a new message.
 */
export const LicensePlateLastCharacterRestrictionSchema: GenMessage<LicensePlateLastCharacterRestriction> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 5);

/**
 * Encapsulates a segment between non-`via` waypoints.
 *
 * @generated from message google.maps.routes.v1.RouteLeg
 */
export type RouteLeg = Message<"google.maps.routes.v1.RouteLeg"> & {
  /**
   * The travel distance of the route leg, in meters.
   *
   * @generated from field: int32 distance_meters = 1;
   */
  distanceMeters: number;

  /**
   * The length of time needed to navigate the leg. If the `route_preference`
   * is set to `TRAFFIC_UNAWARE`, then this value is the same as
   * `static_duration`. If the `route_preference` is either `TRAFFIC_AWARE` or
   * `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated taking traffic
   * conditions into account.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * The duration of traveling through the leg, calculated without taking
   * traffic conditions into consideration.
   *
   * @generated from field: google.protobuf.Duration static_duration = 3;
   */
  staticDuration?: Duration;

  /**
   * The overall polyline for this leg. This includes that each `step`'s
   * polyline.
   *
   * @generated from field: google.maps.routes.v1.Polyline polyline = 4;
   */
  polyline?: Polyline;

  /**
   * The start location of this leg. This might be different from the provided
   * `origin`. For example, when the provided `origin` is not near a road, this
   * is a point on the road.
   *
   * @generated from field: google.maps.routes.v1.Location start_location = 5;
   */
  startLocation?: Location;

  /**
   * The end location of this leg. This might be different from the provided
   * `destination`. For example, when the provided `destination` is not near a
   * road, this is a point on the road.
   *
   * @generated from field: google.maps.routes.v1.Location end_location = 6;
   */
  endLocation?: Location;

  /**
   * An array of steps denoting segments within this leg. Each step represents
   * one navigation instruction.
   *
   * @generated from field: repeated google.maps.routes.v1.RouteLegStep steps = 7;
   */
  steps: RouteLegStep[];

  /**
   * Encapsulates the additional information that the user should be informed
   * about, such as possible traffic zone restriction etc. on a route leg.
   *
   * @generated from field: google.maps.routes.v1.RouteLegTravelAdvisory travel_advisory = 8;
   */
  travelAdvisory?: RouteLegTravelAdvisory;
};

/**
 * Describes the message google.maps.routes.v1.RouteLeg.
 * Use `create(RouteLegSchema)` to create a new message.
 */
export const RouteLegSchema: GenMessage<RouteLeg> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 6);

/**
 * Encapsulates toll information on a `Route` or on a `RouteLeg`.
 *
 * @generated from message google.maps.routes.v1.TollInfo
 */
export type TollInfo = Message<"google.maps.routes.v1.TollInfo"> & {
  /**
   * The monetary amount of tolls for the corresponding `Route` or `RouteLeg`.
   * This list contains a money amount for each currency that is expected
   * to be charged by the toll stations. Typically this list contains only one
   * item for routes with tolls in one currency. For international trips, this
   * list may contain multiple items to reflect tolls in different currencies.
   *
   * @generated from field: repeated google.type.Money estimated_price = 1;
   */
  estimatedPrice: Money[];
};

/**
 * Describes the message google.maps.routes.v1.TollInfo.
 * Use `create(TollInfoSchema)` to create a new message.
 */
export const TollInfoSchema: GenMessage<TollInfo> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 7);

/**
 * Encapsulates a segment of a `RouteLeg`. A step corresponds to a single
 * navigation instruction. Route legs are made up of steps.
 *
 * @generated from message google.maps.routes.v1.RouteLegStep
 */
export type RouteLegStep = Message<"google.maps.routes.v1.RouteLegStep"> & {
  /**
   * The travel distance of this step, in meters. In some circumstances, this
   * field might not have a value.
   *
   * @generated from field: int32 distance_meters = 1;
   */
  distanceMeters: number;

  /**
   * The duration of travel through this step without taking traffic conditions
   * into consideration. In some circumstances, this field might not have a
   * value.
   *
   * @generated from field: google.protobuf.Duration static_duration = 2;
   */
  staticDuration?: Duration;

  /**
   * The polyline associated with this step.
   *
   * @generated from field: google.maps.routes.v1.Polyline polyline = 3;
   */
  polyline?: Polyline;

  /**
   * The start location of this step.
   *
   * @generated from field: google.maps.routes.v1.Location start_location = 4;
   */
  startLocation?: Location;

  /**
   * The end location of this step.
   *
   * @generated from field: google.maps.routes.v1.Location end_location = 5;
   */
  endLocation?: Location;

  /**
   * Navigation instructions.
   *
   * @generated from field: google.maps.routes.v1.NavigationInstruction navigation_instruction = 6;
   */
  navigationInstruction?: NavigationInstruction;

  /**
   * Encapsulates the additional information that the user should be informed
   * about, such as possible traffic zone restriction on a leg step.
   *
   * @generated from field: google.maps.routes.v1.RouteLegStepTravelAdvisory travel_advisory = 7;
   */
  travelAdvisory?: RouteLegStepTravelAdvisory;
};

/**
 * Describes the message google.maps.routes.v1.RouteLegStep.
 * Use `create(RouteLegStepSchema)` to create a new message.
 */
export const RouteLegStepSchema: GenMessage<RouteLegStep> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 8);

/**
 * @generated from message google.maps.routes.v1.NavigationInstruction
 */
export type NavigationInstruction = Message<"google.maps.routes.v1.NavigationInstruction"> & {
  /**
   * Encapsulates the navigation instructions for the current step (for example,
   * turn left, merge, or straight). This field determines which icon to
   * display.
   *
   * @generated from field: google.maps.routes.v1.Maneuver maneuver = 1;
   */
  maneuver: Maneuver;

  /**
   * Instructions for navigating this step.
   *
   * @generated from field: string instructions = 2;
   */
  instructions: string;
};

/**
 * Describes the message google.maps.routes.v1.NavigationInstruction.
 * Use `create(NavigationInstructionSchema)` to create a new message.
 */
export const NavigationInstructionSchema: GenMessage<NavigationInstruction> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 9);

/**
 * Traffic density indicator on a contiguous segment of a polyline or path.
 * Given a path with points P_0, P_1, ... , P_N (zero-based index), the
 * `SpeedReadingInterval` defines an interval and describes its traffic using
 * the following categories.
 *
 * @generated from message google.maps.routes.v1.SpeedReadingInterval
 */
export type SpeedReadingInterval = Message<"google.maps.routes.v1.SpeedReadingInterval"> & {
  /**
   * The starting index of this interval in the polyline.
   * In JSON, when the index is 0, the field appears to be unpopulated.
   *
   * @generated from field: int32 start_polyline_point_index = 1;
   */
  startPolylinePointIndex: number;

  /**
   * The ending index of this interval in the polyline.
   * In JSON, when the index is 0, the field appears to be unpopulated.
   *
   * @generated from field: int32 end_polyline_point_index = 2;
   */
  endPolylinePointIndex: number;

  /**
   * Traffic speed in this interval.
   *
   * @generated from field: google.maps.routes.v1.SpeedReadingInterval.Speed speed = 3;
   */
  speed: SpeedReadingInterval_Speed;
};

/**
 * Describes the message google.maps.routes.v1.SpeedReadingInterval.
 * Use `create(SpeedReadingIntervalSchema)` to create a new message.
 */
export const SpeedReadingIntervalSchema: GenMessage<SpeedReadingInterval> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 10);

/**
 * The classification of polyline speed based on traffic data.
 *
 * @generated from enum google.maps.routes.v1.SpeedReadingInterval.Speed
 */
export enum SpeedReadingInterval_Speed {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: SPEED_UNSPECIFIED = 0;
   */
  SPEED_UNSPECIFIED = 0,

  /**
   * Normal speed, no slowdown is detected.
   *
   * @generated from enum value: NORMAL = 1;
   */
  NORMAL = 1,

  /**
   * Slowdown detected, but no traffic jam formed.
   *
   * @generated from enum value: SLOW = 2;
   */
  SLOW = 2,

  /**
   * Traffic jam detected.
   *
   * @generated from enum value: TRAFFIC_JAM = 3;
   */
  TRAFFIC_JAM = 3,
}

/**
 * Describes the enum google.maps.routes.v1.SpeedReadingInterval.Speed.
 */
export const SpeedReadingInterval_SpeedSchema: GenEnum<SpeedReadingInterval_Speed> = /*@__PURE__*/
  enumDesc(file_google_maps_routes_v1_route, 10, 0);

/**
 * Deprecated: This field will stop being populated soon.
 * Encapsulates statistics about the time spent and distance travelled in a
 * custom area.
 *
 * @generated from message google.maps.routes.v1.CustomLayerInfo
 * @deprecated
 */
export type CustomLayerInfo = Message<"google.maps.routes.v1.CustomLayerInfo"> & {
  /**
   * Encapsulates information about areas in the custom layer on the Route.
   * This field is only populated if a route travels through areas in the
   * custom layer.
   *
   * @generated from field: repeated google.maps.routes.v1.CustomLayerInfo.AreaInfo area_info = 1;
   */
  areaInfo: CustomLayerInfo_AreaInfo[];

  /**
   * Total unique distance traveled across all activated areas in the provided
   * dataset (in meters). For example, if a route travels through the
   * intersection of area A and area B, the distance in the intersection region
   * is only added once to the `total_distance_in_areas_meters`.
   *
   * @generated from field: float total_distance_in_areas_meters = 2;
   */
  totalDistanceInAreasMeters: number;

  /**
   * Total time spent across all activated areas in the provided dataset.
   * For example, if a route travels through the intersection of area A and
   * area B, the time spent in the intersection region is only added once to the
   * `total_duration_in_areas`.
   *
   * @generated from field: google.protobuf.Duration total_duration_in_areas = 3;
   */
  totalDurationInAreas?: Duration;
};

/**
 * Describes the message google.maps.routes.v1.CustomLayerInfo.
 * Use `create(CustomLayerInfoSchema)` to create a new message.
 * @deprecated
 */
export const CustomLayerInfoSchema: GenMessage<CustomLayerInfo> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 11);

/**
 * Encapsulates areas related information on a `Route` or on a `RouteLeg`.
 *
 * @generated from message google.maps.routes.v1.CustomLayerInfo.AreaInfo
 * @deprecated
 */
export type CustomLayerInfo_AreaInfo = Message<"google.maps.routes.v1.CustomLayerInfo.AreaInfo"> & {
  /**
   * ID of an area inside a customer provided dataset. An area represents a
   * collection of polygons on the map that are of concern to the customer.
   * For example, the customer may be interested in knowing whether a
   * returned route is traveling through multiple busy city blocks during
   * a predefined period of time. An area ID is unique within a single
   * dataset uploaded by a customer. That is, a (`customer_id`, `dataset_id`,
   * `area_id`) triplet should uniquely identify a set of polygons on the map
   * that "activates" following a common schedule.
   *
   * @generated from field: string area_id = 1;
   */
  areaId: string;

  /**
   * Total distance traveled in the area (in meters).
   *
   * @generated from field: float distance_in_area_meters = 2;
   */
  distanceInAreaMeters: number;

  /**
   * Total time spent in the area.
   *
   * @generated from field: google.protobuf.Duration duration_in_area = 3;
   */
  durationInArea?: Duration;
};

/**
 * Describes the message google.maps.routes.v1.CustomLayerInfo.AreaInfo.
 * Use `create(CustomLayerInfo_AreaInfoSchema)` to create a new message.
 * @deprecated
 */
export const CustomLayerInfo_AreaInfoSchema: GenMessage<CustomLayerInfo_AreaInfo> = /*@__PURE__*/
  messageDesc(file_google_maps_routes_v1_route, 11, 0);

/**
 * A set of values that specify the navigation action to take for the current
 * step (for example, turn left, merge, or straight).
 *
 * @generated from enum google.maps.routes.v1.Maneuver
 */
export enum Maneuver {
  /**
   * Not used.
   *
   * @generated from enum value: MANEUVER_UNSPECIFIED = 0;
   */
  MANEUVER_UNSPECIFIED = 0,

  /**
   * Turn slightly to the left.
   *
   * @generated from enum value: TURN_SLIGHT_LEFT = 1;
   */
  TURN_SLIGHT_LEFT = 1,

  /**
   * Turn sharply to the left.
   *
   * @generated from enum value: TURN_SHARP_LEFT = 2;
   */
  TURN_SHARP_LEFT = 2,

  /**
   * Make a left u-turn.
   *
   * @generated from enum value: UTURN_LEFT = 3;
   */
  UTURN_LEFT = 3,

  /**
   * Turn left.
   *
   * @generated from enum value: TURN_LEFT = 4;
   */
  TURN_LEFT = 4,

  /**
   * Turn slightly to the right.
   *
   * @generated from enum value: TURN_SLIGHT_RIGHT = 5;
   */
  TURN_SLIGHT_RIGHT = 5,

  /**
   * Turn sharply to the right.
   *
   * @generated from enum value: TURN_SHARP_RIGHT = 6;
   */
  TURN_SHARP_RIGHT = 6,

  /**
   * Make a right u-turn.
   *
   * @generated from enum value: UTURN_RIGHT = 7;
   */
  UTURN_RIGHT = 7,

  /**
   * Turn right.
   *
   * @generated from enum value: TURN_RIGHT = 8;
   */
  TURN_RIGHT = 8,

  /**
   * Go straight.
   *
   * @generated from enum value: STRAIGHT = 9;
   */
  STRAIGHT = 9,

  /**
   * Take the left ramp.
   *
   * @generated from enum value: RAMP_LEFT = 10;
   */
  RAMP_LEFT = 10,

  /**
   * Take the right ramp.
   *
   * @generated from enum value: RAMP_RIGHT = 11;
   */
  RAMP_RIGHT = 11,

  /**
   * Merge into traffic.
   *
   * @generated from enum value: MERGE = 12;
   */
  MERGE = 12,

  /**
   * Take the left fork.
   *
   * @generated from enum value: FORK_LEFT = 13;
   */
  FORK_LEFT = 13,

  /**
   * Take the right fork.
   *
   * @generated from enum value: FORK_RIGHT = 14;
   */
  FORK_RIGHT = 14,

  /**
   * Take the ferry.
   *
   * @generated from enum value: FERRY = 15;
   */
  FERRY = 15,

  /**
   * Take the train leading onto the ferry.
   *
   * @generated from enum value: FERRY_TRAIN = 16;
   */
  FERRY_TRAIN = 16,

  /**
   * Turn left at the roundabout.
   *
   * @generated from enum value: ROUNDABOUT_LEFT = 17;
   */
  ROUNDABOUT_LEFT = 17,

  /**
   * Turn right at the roundabout.
   *
   * @generated from enum value: ROUNDABOUT_RIGHT = 18;
   */
  ROUNDABOUT_RIGHT = 18,

  /**
   * Initial maneuver.
   *
   * @generated from enum value: DEPART = 19;
   */
  DEPART = 19,

  /**
   * Used to indicate a street name change.
   *
   * @generated from enum value: NAME_CHANGE = 20;
   */
  NAME_CHANGE = 20,
}

/**
 * Describes the enum google.maps.routes.v1.Maneuver.
 */
export const ManeuverSchema: GenEnum<Maneuver> = /*@__PURE__*/
  enumDesc(file_google_maps_routes_v1_route, 0);

