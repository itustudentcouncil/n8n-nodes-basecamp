// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/maps/places/v1/places_service.proto (package google.maps.places.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { Viewport } from "../../../geo/type/viewport_pb";
import { file_google_geo_type_viewport } from "../../../geo/type/viewport_pb";
import type { ContextualContent } from "./contextual_content_pb";
import { file_google_maps_places_v1_contextual_content } from "./contextual_content_pb";
import type { EVConnectorType } from "./ev_charging_pb";
import { file_google_maps_places_v1_ev_charging } from "./ev_charging_pb";
import type { Circle } from "./geometry_pb";
import { file_google_maps_places_v1_geometry } from "./geometry_pb";
import type { Place, PlaceSchema, PriceLevel } from "./place_pb";
import { file_google_maps_places_v1_place } from "./place_pb";
import type { Polyline } from "./polyline_pb";
import { file_google_maps_places_v1_polyline } from "./polyline_pb";
import type { RouteModifiers } from "./route_modifiers_pb";
import { file_google_maps_places_v1_route_modifiers } from "./route_modifiers_pb";
import type { RoutingPreference } from "./routing_preference_pb";
import { file_google_maps_places_v1_routing_preference } from "./routing_preference_pb";
import type { RoutingSummary } from "./routing_summary_pb";
import { file_google_maps_places_v1_routing_summary } from "./routing_summary_pb";
import type { TravelMode } from "./travel_mode_pb";
import { file_google_maps_places_v1_travel_mode } from "./travel_mode_pb";
import type { LatLng } from "../../../type/latlng_pb";
import { file_google_type_latlng } from "../../../type/latlng_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/maps/places/v1/places_service.proto.
 */
export const file_google_maps_places_v1_places_service: GenFile = /*@__PURE__*/
  fileDesc("Cipnb29nbGUvbWFwcy9wbGFjZXMvdjEvcGxhY2VzX3NlcnZpY2UucHJvdG8SFWdvb2dsZS5tYXBzLnBsYWNlcy52MSKKAgoRUm91dGluZ1BhcmFtZXRlcnMSKAoGb3JpZ2luGAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nQgPgQQESOwoLdHJhdmVsX21vZGUYAiABKA4yIS5nb29nbGUubWFwcy5wbGFjZXMudjEuVHJhdmVsTW9kZUID4EEBEkMKD3JvdXRlX21vZGlmaWVycxgDIAEoCzIlLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Sb3V0ZU1vZGlmaWVyc0ID4EEBEkkKEnJvdXRpbmdfcHJlZmVyZW5jZRgEIAEoDjIoLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Sb3V0aW5nUHJlZmVyZW5jZUID4EEBIu4EChNTZWFyY2hOZWFyYnlSZXF1ZXN0EhUKDWxhbmd1YWdlX2NvZGUYASABKAkSEwoLcmVnaW9uX2NvZGUYAiABKAkSFgoOaW5jbHVkZWRfdHlwZXMYAyADKAkSFgoOZXhjbHVkZWRfdHlwZXMYBCADKAkSHgoWaW5jbHVkZWRfcHJpbWFyeV90eXBlcxgFIAMoCRIeChZleGNsdWRlZF9wcmltYXJ5X3R5cGVzGAYgAygJEhgKEG1heF9yZXN1bHRfY291bnQYByABKAUSYQoUbG9jYXRpb25fcmVzdHJpY3Rpb24YCCABKAsyPi5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoTmVhcmJ5UmVxdWVzdC5Mb2NhdGlvblJlc3RyaWN0aW9uQgPgQQISUgoPcmFua19wcmVmZXJlbmNlGAkgASgOMjkuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaE5lYXJieVJlcXVlc3QuUmFua1ByZWZlcmVuY2USSQoScm91dGluZ19wYXJhbWV0ZXJzGAogASgLMiguZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlJvdXRpbmdQYXJhbWV0ZXJzQgPgQQEaTgoTTG9jYXRpb25SZXN0cmljdGlvbhIvCgZjaXJjbGUYAiABKAsyHS5nb29nbGUubWFwcy5wbGFjZXMudjEuQ2lyY2xlSABCBgoEdHlwZSJPCg5SYW5rUHJlZmVyZW5jZRIfChtSQU5LX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRUQQABIMCghESVNUQU5DRRABEg4KClBPUFVMQVJJVFkQAiKGAQoUU2VhcmNoTmVhcmJ5UmVzcG9uc2USLAoGcGxhY2VzGAEgAygLMhwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlBsYWNlEkAKEXJvdXRpbmdfc3VtbWFyaWVzGAIgAygLMiUuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlJvdXRpbmdTdW1tYXJ5IvQJChFTZWFyY2hUZXh0UmVxdWVzdBIXCgp0ZXh0X3F1ZXJ5GAEgASgJQgPgQQISFQoNbGFuZ3VhZ2VfY29kZRgCIAEoCRITCgtyZWdpb25fY29kZRgDIAEoCRJQCg9yYW5rX3ByZWZlcmVuY2UYBCABKA4yNy5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlcXVlc3QuUmFua1ByZWZlcmVuY2USFQoNaW5jbHVkZWRfdHlwZRgGIAEoCRIQCghvcGVuX25vdxgHIAEoCBISCgptaW5fcmF0aW5nGAkgASgBEhgKEG1heF9yZXN1bHRfY291bnQYCiABKAUSNwoMcHJpY2VfbGV2ZWxzGAsgAygOMiEuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlByaWNlTGV2ZWwSHQoVc3RyaWN0X3R5cGVfZmlsdGVyaW5nGAwgASgIEkwKDWxvY2F0aW9uX2JpYXMYDSABKAsyNS5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlcXVlc3QuTG9jYXRpb25CaWFzEloKFGxvY2F0aW9uX3Jlc3RyaWN0aW9uGA4gASgLMjwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaFRleHRSZXF1ZXN0LkxvY2F0aW9uUmVzdHJpY3Rpb24SSwoKZXZfb3B0aW9ucxgPIAEoCzIyLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5TZWFyY2hUZXh0UmVxdWVzdC5FVk9wdGlvbnNCA+BBARJJChJyb3V0aW5nX3BhcmFtZXRlcnMYECABKAsyKC5nb29nbGUubWFwcy5wbGFjZXMudjEuUm91dGluZ1BhcmFtZXRlcnNCA+BBARJvCh1zZWFyY2hfYWxvbmdfcm91dGVfcGFyYW1ldGVycxgRIAEoCzJDLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5TZWFyY2hUZXh0UmVxdWVzdC5TZWFyY2hBbG9uZ1JvdXRlUGFyYW1ldGVyc0ID4EEBGncKDExvY2F0aW9uQmlhcxIuCglyZWN0YW5nbGUYASABKAsyGS5nb29nbGUuZ2VvLnR5cGUuVmlld3BvcnRIABIvCgZjaXJjbGUYAiABKAsyHS5nb29nbGUubWFwcy5wbGFjZXMudjEuQ2lyY2xlSABCBgoEdHlwZRpNChNMb2NhdGlvblJlc3RyaWN0aW9uEi4KCXJlY3RhbmdsZRgBIAEoCzIZLmdvb2dsZS5nZW8udHlwZS5WaWV3cG9ydEgAQgYKBHR5cGUaeAoJRVZPcHRpb25zEiUKGG1pbmltdW1fY2hhcmdpbmdfcmF0ZV9rdxgBIAEoAUID4EEBEkQKD2Nvbm5lY3Rvcl90eXBlcxgCIAMoDjImLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5FVkNvbm5lY3RvclR5cGVCA+BBARpUChpTZWFyY2hBbG9uZ1JvdXRlUGFyYW1ldGVycxI2Cghwb2x5bGluZRgBIAEoCzIfLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Qb2x5bGluZUID4EECIk4KDlJhbmtQcmVmZXJlbmNlEh8KG1JBTktfUFJFRkVSRU5DRV9VTlNQRUNJRklFRBAAEgwKCERJU1RBTkNFEAESDQoJUkVMRVZBTkNFEAIiywEKElNlYXJjaFRleHRSZXNwb25zZRIsCgZwbGFjZXMYASADKAsyHC5nb29nbGUubWFwcy5wbGFjZXMudjEuUGxhY2USQAoRcm91dGluZ19zdW1tYXJpZXMYAiADKAsyJS5nb29nbGUubWFwcy5wbGFjZXMudjEuUm91dGluZ1N1bW1hcnkSRQoTY29udGV4dHVhbF9jb250ZW50cxgDIAMoCzIoLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Db250ZXh0dWFsQ29udGVudCKmAQoUR2V0UGhvdG9NZWRpYVJlcXVlc3QSNgoEbmFtZRgBIAEoCUIo4EEC+kEiCiBwbGFjZXMuZ29vZ2xlYXBpcy5jb20vUGhvdG9NZWRpYRIZCgxtYXhfd2lkdGhfcHgYAiABKAVCA+BBARIaCg1tYXhfaGVpZ2h0X3B4GAMgASgFQgPgQQESHwoSc2tpcF9odHRwX3JlZGlyZWN0GAQgASgIQgPgQQEinwEKClBob3RvTWVkaWESDAoEbmFtZRgBIAEoCRIRCglwaG90b191cmkYAiABKAk6cOpBbQogcGxhY2VzLmdvb2dsZWFwaXMuY29tL1Bob3RvTWVkaWESMHBsYWNlcy97cGxhY2VfaWR9L3Bob3Rvcy97cGhvdG9fcmVmZXJlbmNlfS9tZWRpYSoLcGhvdG9NZWRpYXMyCnBob3RvTWVkaWEilgEKD0dldFBsYWNlUmVxdWVzdBIxCgRuYW1lGAEgASgJQiPgQQL6QR0KG3BsYWNlcy5nb29nbGVhcGlzLmNvbS9QbGFjZRIaCg1sYW5ndWFnZV9jb2RlGAIgASgJQgPgQQESGAoLcmVnaW9uX2NvZGUYAyABKAlCA+BBARIaCg1zZXNzaW9uX3Rva2VuGAQgASgJQgPgQQEi9AUKGUF1dG9jb21wbGV0ZVBsYWNlc1JlcXVlc3QSEgoFaW5wdXQYASABKAlCA+BBAhJZCg1sb2NhdGlvbl9iaWFzGAIgASgLMj0uZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1JlcXVlc3QuTG9jYXRpb25CaWFzQgPgQQESZwoUbG9jYXRpb25fcmVzdHJpY3Rpb24YAyABKAsyRC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVxdWVzdC5Mb2NhdGlvblJlc3RyaWN0aW9uQgPgQQESIwoWaW5jbHVkZWRfcHJpbWFyeV90eXBlcxgEIAMoCUID4EEBEiIKFWluY2x1ZGVkX3JlZ2lvbl9jb2RlcxgFIAMoCUID4EEBEhoKDWxhbmd1YWdlX2NvZGUYBiABKAlCA+BBARIYCgtyZWdpb25fY29kZRgHIAEoCUID4EEBEigKBm9yaWdpbhgIIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZ0ID4EEBEhkKDGlucHV0X29mZnNldBgJIAEoBUID4EEBEiYKGWluY2x1ZGVfcXVlcnlfcHJlZGljdGlvbnMYCiABKAhCA+BBARIaCg1zZXNzaW9uX3Rva2VuGAsgASgJQgPgQQEadwoMTG9jYXRpb25CaWFzEi4KCXJlY3RhbmdsZRgBIAEoCzIZLmdvb2dsZS5nZW8udHlwZS5WaWV3cG9ydEgAEi8KBmNpcmNsZRgCIAEoCzIdLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5DaXJjbGVIAEIGCgR0eXBlGn4KE0xvY2F0aW9uUmVzdHJpY3Rpb24SLgoJcmVjdGFuZ2xlGAEgASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdwb3J0SAASLwoGY2lyY2xlGAIgASgLMh0uZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkNpcmNsZUgAQgYKBHR5cGUiigoKGkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlElEKC3N1Z2dlc3Rpb25zGAEgAygLMjwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24amAkKClN1Z2dlc3Rpb24SaAoQcGxhY2VfcHJlZGljdGlvbhgBIAEoCzJMLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5BdXRvY29tcGxldGVQbGFjZXNSZXNwb25zZS5TdWdnZXN0aW9uLlBsYWNlUHJlZGljdGlvbkgAEmgKEHF1ZXJ5X3ByZWRpY3Rpb24YAiABKAsyTC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5RdWVyeVByZWRpY3Rpb25IABo3CgtTdHJpbmdSYW5nZRIUCgxzdGFydF9vZmZzZXQYASABKAUSEgoKZW5kX29mZnNldBgCIAEoBRp6Cg9Gb3JtYXR0YWJsZVRleHQSDAoEdGV4dBgBIAEoCRJZCgdtYXRjaGVzGAIgAygLMkguZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24uU3RyaW5nUmFuZ2Ua2QEKEFN0cnVjdHVyZWRGb3JtYXQSXwoJbWFpbl90ZXh0GAEgASgLMkwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24uRm9ybWF0dGFibGVUZXh0EmQKDnNlY29uZGFyeV90ZXh0GAIgASgLMkwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24uRm9ybWF0dGFibGVUZXh0GsICCg9QbGFjZVByZWRpY3Rpb24SLwoFcGxhY2UYASABKAlCIPpBHQobcGxhY2VzLmdvb2dsZWFwaXMuY29tL1BsYWNlEhAKCHBsYWNlX2lkGAIgASgJEloKBHRleHQYAyABKAsyTC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5Gb3JtYXR0YWJsZVRleHQSaAoRc3RydWN0dXJlZF9mb3JtYXQYBCABKAsyTS5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5TdHJ1Y3R1cmVkRm9ybWF0Eg0KBXR5cGVzGAUgAygJEhcKD2Rpc3RhbmNlX21ldGVycxgGIAEoBRrXAQoPUXVlcnlQcmVkaWN0aW9uEloKBHRleHQYASABKAsyTC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5Gb3JtYXR0YWJsZVRleHQSaAoRc3RydWN0dXJlZF9mb3JtYXQYAiABKAsyTS5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5TdHJ1Y3R1cmVkRm9ybWF0QgYKBGtpbmQy4QUKBlBsYWNlcxKLAQoMU2VhcmNoTmVhcmJ5EiouZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaE5lYXJieVJlcXVlc3QaKy5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoTmVhcmJ5UmVzcG9uc2UiIoLT5JMCHDoBKiIXL3YxL3BsYWNlczpzZWFyY2hOZWFyYnkSgwEKClNlYXJjaFRleHQSKC5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlcXVlc3QaKS5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlc3BvbnNlIiCC0+STAho6ASoiFS92MS9wbGFjZXM6c2VhcmNoVGV4dBKSAQoNR2V0UGhvdG9NZWRpYRIrLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5HZXRQaG90b01lZGlhUmVxdWVzdBohLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5QaG90b01lZGlhIjHaQQRuYW1lgtPkkwIkEiIvdjEve25hbWU9cGxhY2VzLyovcGhvdG9zLyovbWVkaWF9EnQKCEdldFBsYWNlEiYuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkdldFBsYWNlUmVxdWVzdBocLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5QbGFjZSIi2kEEbmFtZYLT5JMCFRITL3YxL3tuYW1lPXBsYWNlcy8qfRKdAQoSQXV0b2NvbXBsZXRlUGxhY2VzEjAuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1JlcXVlc3QaMS5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UiIoLT5JMCHDoBKiIXL3YxL3BsYWNlczphdXRvY29tcGxldGUaGMpBFXBsYWNlcy5nb29nbGVhcGlzLmNvbUKmAQoZY29tLmdvb2dsZS5tYXBzLnBsYWNlcy52MUISUGxhY2VzU2VydmljZVByb3RvUAFaN2Nsb3VkLmdvb2dsZS5jb20vZ28vbWFwcy9wbGFjZXMvYXBpdjEvcGxhY2VzcGI7cGxhY2VzcGL4AQGiAgZHTVBTVjGqAhVHb29nbGUuTWFwcy5QbGFjZXMuVjHKAhVHb29nbGVcTWFwc1xQbGFjZXNcVjFiBnByb3RvMw", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_geo_type_viewport, file_google_maps_places_v1_contextual_content, file_google_maps_places_v1_ev_charging, file_google_maps_places_v1_geometry, file_google_maps_places_v1_place, file_google_maps_places_v1_polyline, file_google_maps_places_v1_route_modifiers, file_google_maps_places_v1_routing_preference, file_google_maps_places_v1_routing_summary, file_google_maps_places_v1_travel_mode, file_google_type_latlng]);

/**
 * Parameters to configure the routing calculations to the places in the
 * response, both along a route (where result ranking will be influenced) and
 * for calculating travel times on results.
 *
 * @generated from message google.maps.places.v1.RoutingParameters
 */
export type RoutingParameters = Message<"google.maps.places.v1.RoutingParameters"> & {
  /**
   * Optional. An explicit routing origin that overrides the origin defined in
   * the polyline. By default, the polyline origin is used.
   *
   * @generated from field: google.type.LatLng origin = 1;
   */
  origin?: LatLng;

  /**
   * Optional. The travel mode.
   *
   * @generated from field: google.maps.places.v1.TravelMode travel_mode = 2;
   */
  travelMode: TravelMode;

  /**
   * Optional. The route modifiers.
   *
   * @generated from field: google.maps.places.v1.RouteModifiers route_modifiers = 3;
   */
  routeModifiers?: RouteModifiers;

  /**
   * Optional. Specifies how to compute the routing summaries. The server
   * attempts to use the selected routing preference to compute the route. The
   * traffic aware routing preference is only available for the `DRIVE` or
   * `TWO_WHEELER` `travelMode`.
   *
   * @generated from field: google.maps.places.v1.RoutingPreference routing_preference = 4;
   */
  routingPreference: RoutingPreference;
};

/**
 * Describes the message google.maps.places.v1.RoutingParameters.
 * Use `create(RoutingParametersSchema)` to create a new message.
 */
export const RoutingParametersSchema: GenMessage<RoutingParameters> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 0);

/**
 * Request proto for Search Nearby.
 *
 *
 *
 * @generated from message google.maps.places.v1.SearchNearbyRequest
 */
export type SearchNearbyRequest = Message<"google.maps.places.v1.SearchNearbyRequest"> & {
  /**
   * Place details will be displayed with the preferred language if available.
   * If the language code is unspecified or unrecognized, place details of any
   * language may be returned, with a preference for English if such details
   * exist.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   *
   * @generated from field: string language_code = 1;
   */
  languageCode: string;

  /**
   * The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   *
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   *
   * Note that 3-digit region codes are not currently supported.
   *
   * @generated from field: string region_code = 2;
   */
  regionCode: string;

  /**
   * Included Place type (eg, "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting types, i.e. a type appears in both
   * included_types and excluded_types, an INVALID_ARGUMENT error is
   * returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   *
   * @generated from field: repeated string included_types = 3;
   */
  includedTypes: string[];

  /**
   * Excluded Place type (eg, "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If the client provides both included_types (e.g. restaurant) and
   * excluded_types (e.g. cafe), then the response should include places that
   * are restaurant but not cafe. The response includes places that match at
   * least one of the included_types and none of the excluded_types.
   *
   * If there are any conflicting types, i.e. a type appears in both
   * included_types and excluded_types, an INVALID_ARGUMENT error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   *
   * @generated from field: repeated string excluded_types = 4;
   */
  excludedTypes: string[];

  /**
   * Included primary Place type (e.g. "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   * A place can only have a single primary type from the supported types table
   * associated with it.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting primary types, i.e. a type appears in both
   * included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
   * error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   *
   * @generated from field: repeated string included_primary_types = 5;
   */
  includedPrimaryTypes: string[];

  /**
   * Excluded primary Place type (e.g. "restaurant" or "gas_station") from
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * Up to 50 types from [Table
   * A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
   * may be specified.
   *
   * If there are any conflicting primary types, i.e. a type appears in both
   * included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
   * error is returned.
   *
   * If a Place type is specified with multiple type restrictions, only places
   * that satisfy all of the restrictions are returned. For example, if we
   * have {included_types = ["restaurant"], excluded_primary_types =
   * ["restaurant"]}, the returned places provide "restaurant"
   * related services but do not operate primarily as "restaurants".
   *
   * @generated from field: repeated string excluded_primary_types = 6;
   */
  excludedPrimaryTypes: string[];

  /**
   * Maximum number of results to return. It must be between 1 and 20 (default),
   * inclusively. If the number is unset, it falls back to the upper limit. If
   * the number is set to negative or exceeds the upper limit, an
   * INVALID_ARGUMENT error is returned.
   *
   * @generated from field: int32 max_result_count = 7;
   */
  maxResultCount: number;

  /**
   * Required. The region to search.
   *
   * @generated from field: google.maps.places.v1.SearchNearbyRequest.LocationRestriction location_restriction = 8;
   */
  locationRestriction?: SearchNearbyRequest_LocationRestriction;

  /**
   * How results will be ranked in the response.
   *
   * @generated from field: google.maps.places.v1.SearchNearbyRequest.RankPreference rank_preference = 9;
   */
  rankPreference: SearchNearbyRequest_RankPreference;

  /**
   * Optional. Parameters that affect the routing to the search results.
   *
   * @generated from field: google.maps.places.v1.RoutingParameters routing_parameters = 10;
   */
  routingParameters?: RoutingParameters;
};

/**
 * Describes the message google.maps.places.v1.SearchNearbyRequest.
 * Use `create(SearchNearbyRequestSchema)` to create a new message.
 */
export const SearchNearbyRequestSchema: GenMessage<SearchNearbyRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 1);

/**
 * The region to search.
 *
 * @generated from message google.maps.places.v1.SearchNearbyRequest.LocationRestriction
 */
export type SearchNearbyRequest_LocationRestriction = Message<"google.maps.places.v1.SearchNearbyRequest.LocationRestriction"> & {
  /**
   * @generated from oneof google.maps.places.v1.SearchNearbyRequest.LocationRestriction.type
   */
  type: {
    /**
     * A circle defined by center point and radius.
     *
     * @generated from field: google.maps.places.v1.Circle circle = 2;
     */
    value: Circle;
    case: "circle";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.SearchNearbyRequest.LocationRestriction.
 * Use `create(SearchNearbyRequest_LocationRestrictionSchema)` to create a new message.
 */
export const SearchNearbyRequest_LocationRestrictionSchema: GenMessage<SearchNearbyRequest_LocationRestriction> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 1, 0);

/**
 * How results will be ranked in the response.
 *
 * @generated from enum google.maps.places.v1.SearchNearbyRequest.RankPreference
 */
export enum SearchNearbyRequest_RankPreference {
  /**
   * RankPreference value not set. Will use rank by POPULARITY by default.
   *
   * @generated from enum value: RANK_PREFERENCE_UNSPECIFIED = 0;
   */
  RANK_PREFERENCE_UNSPECIFIED = 0,

  /**
   * Ranks results by distance.
   *
   * @generated from enum value: DISTANCE = 1;
   */
  DISTANCE = 1,

  /**
   * Ranks results by popularity.
   *
   * @generated from enum value: POPULARITY = 2;
   */
  POPULARITY = 2,
}

/**
 * Describes the enum google.maps.places.v1.SearchNearbyRequest.RankPreference.
 */
export const SearchNearbyRequest_RankPreferenceSchema: GenEnum<SearchNearbyRequest_RankPreference> = /*@__PURE__*/
  enumDesc(file_google_maps_places_v1_places_service, 1, 0);

/**
 * Response proto for Search Nearby.
 *
 *
 * @generated from message google.maps.places.v1.SearchNearbyResponse
 */
export type SearchNearbyResponse = Message<"google.maps.places.v1.SearchNearbyResponse"> & {
  /**
   * A list of places that meets user's requirements like places
   * types, number of places and specific location restriction.
   *
   * @generated from field: repeated google.maps.places.v1.Place places = 1;
   */
  places: Place[];

  /**
   * A list of routing summaries where each entry associates to the
   * corresponding place in the same index in the places field. If the routing
   * summary is not available for one of the places, it will contain an empty
   * entry. This list should have as many entries as the list of places if
   * requested.
   *
   * @generated from field: repeated google.maps.places.v1.RoutingSummary routing_summaries = 2;
   */
  routingSummaries: RoutingSummary[];
};

/**
 * Describes the message google.maps.places.v1.SearchNearbyResponse.
 * Use `create(SearchNearbyResponseSchema)` to create a new message.
 */
export const SearchNearbyResponseSchema: GenMessage<SearchNearbyResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 2);

/**
 * Request proto for SearchText.
 *
 *
 *
 * @generated from message google.maps.places.v1.SearchTextRequest
 */
export type SearchTextRequest = Message<"google.maps.places.v1.SearchTextRequest"> & {
  /**
   * Required. The text query for textual search.
   *
   * @generated from field: string text_query = 1;
   */
  textQuery: string;

  /**
   * Place details will be displayed with the preferred language if available.
   * If the language code is unspecified or unrecognized, place details of any
   * language may be returned, with a preference for English if such details
   * exist.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   *
   * @generated from field: string language_code = 2;
   */
  languageCode: string;

  /**
   * The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   *
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   *
   * Note that 3-digit region codes are not currently supported.
   *
   * @generated from field: string region_code = 3;
   */
  regionCode: string;

  /**
   * How results will be ranked in the response.
   *
   * @generated from field: google.maps.places.v1.SearchTextRequest.RankPreference rank_preference = 4;
   */
  rankPreference: SearchTextRequest_RankPreference;

  /**
   * The requested place type. Full list of types supported:
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   * Only support one included type.
   *
   * @generated from field: string included_type = 6;
   */
  includedType: string;

  /**
   * Used to restrict the search to places that are currently open.  The default
   * is false.
   *
   * @generated from field: bool open_now = 7;
   */
  openNow: boolean;

  /**
   * Filter out results whose average user rating is strictly less than this
   * limit. A valid value must be a float between 0 and 5 (inclusively) at a
   * 0.5 cadence i.e. [0, 0.5, 1.0, ... , 5.0] inclusively. The input rating
   * will round up to the nearest 0.5(ceiling). For instance, a rating of 0.6
   * will eliminate all results with a less than 1.0 rating.
   *
   * @generated from field: double min_rating = 9;
   */
  minRating: number;

  /**
   * Maximum number of results to return. It must be between 1 and 20,
   * inclusively. The default is 20.  If the number is unset, it falls back to
   * the upper limit. If the number is set to negative or exceeds the upper
   * limit, an INVALID_ARGUMENT error is returned.
   *
   * @generated from field: int32 max_result_count = 10;
   */
  maxResultCount: number;

  /**
   * Used to restrict the search to places that are marked as certain price
   * levels. Users can choose any combinations of price levels. Default to
   * select all price levels.
   *
   * @generated from field: repeated google.maps.places.v1.PriceLevel price_levels = 11;
   */
  priceLevels: PriceLevel[];

  /**
   * Used to set strict type filtering for included_type. If set to true, only
   * results of the same type will be returned. Default to false.
   *
   * @generated from field: bool strict_type_filtering = 12;
   */
  strictTypeFiltering: boolean;

  /**
   * The region to search. This location serves as a bias which means results
   * around given location might be returned. Cannot be set along with
   * location_restriction.
   *
   * @generated from field: google.maps.places.v1.SearchTextRequest.LocationBias location_bias = 13;
   */
  locationBias?: SearchTextRequest_LocationBias;

  /**
   * The region to search. This location serves as a restriction which means
   * results outside given location will not be returned. Cannot be set along
   * with location_bias.
   *
   * @generated from field: google.maps.places.v1.SearchTextRequest.LocationRestriction location_restriction = 14;
   */
  locationRestriction?: SearchTextRequest_LocationRestriction;

  /**
   * Optional. Set the searchable EV options of a place search request.
   *
   * @generated from field: google.maps.places.v1.SearchTextRequest.EVOptions ev_options = 15;
   */
  evOptions?: SearchTextRequest_EVOptions;

  /**
   * Optional. Additional parameters for routing to results.
   *
   * @generated from field: google.maps.places.v1.RoutingParameters routing_parameters = 16;
   */
  routingParameters?: RoutingParameters;

  /**
   * Optional. Additional parameters proto for searching along a route.
   *
   * @generated from field: google.maps.places.v1.SearchTextRequest.SearchAlongRouteParameters search_along_route_parameters = 17;
   */
  searchAlongRouteParameters?: SearchTextRequest_SearchAlongRouteParameters;
};

/**
 * Describes the message google.maps.places.v1.SearchTextRequest.
 * Use `create(SearchTextRequestSchema)` to create a new message.
 */
export const SearchTextRequestSchema: GenMessage<SearchTextRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 3);

/**
 * The region to search. This location serves as a bias which means results
 * around given location might be returned.
 *
 * @generated from message google.maps.places.v1.SearchTextRequest.LocationBias
 */
export type SearchTextRequest_LocationBias = Message<"google.maps.places.v1.SearchTextRequest.LocationBias"> & {
  /**
   * @generated from oneof google.maps.places.v1.SearchTextRequest.LocationBias.type
   */
  type: {
    /**
     * A rectangle box defined by northeast and southwest corner.
     * `rectangle.high()` must be the northeast point of the rectangle
     * viewport. `rectangle.low()` must be the southwest point of the
     * rectangle viewport. `rectangle.low().latitude()` cannot be greater than
     * `rectangle.high().latitude()`. This will result in an empty latitude
     * range. A rectangle viewport cannot be wider than 180 degrees.
     *
     * @generated from field: google.geo.type.Viewport rectangle = 1;
     */
    value: Viewport;
    case: "rectangle";
  } | {
    /**
     * A circle defined by center point and radius.
     *
     * @generated from field: google.maps.places.v1.Circle circle = 2;
     */
    value: Circle;
    case: "circle";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.SearchTextRequest.LocationBias.
 * Use `create(SearchTextRequest_LocationBiasSchema)` to create a new message.
 */
export const SearchTextRequest_LocationBiasSchema: GenMessage<SearchTextRequest_LocationBias> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 3, 0);

/**
 * The region to search. This location serves as a restriction which means
 * results outside given location will not be returned.
 *
 * @generated from message google.maps.places.v1.SearchTextRequest.LocationRestriction
 */
export type SearchTextRequest_LocationRestriction = Message<"google.maps.places.v1.SearchTextRequest.LocationRestriction"> & {
  /**
   * @generated from oneof google.maps.places.v1.SearchTextRequest.LocationRestriction.type
   */
  type: {
    /**
     * A rectangle box defined by northeast and southwest corner.
     * `rectangle.high()` must be the northeast point of the rectangle
     * viewport. `rectangle.low()` must be the southwest point of the
     * rectangle viewport. `rectangle.low().latitude()` cannot be greater than
     * `rectangle.high().latitude()`. This will result in an empty latitude
     * range. A rectangle viewport cannot be wider than 180 degrees.
     *
     * @generated from field: google.geo.type.Viewport rectangle = 1;
     */
    value: Viewport;
    case: "rectangle";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.SearchTextRequest.LocationRestriction.
 * Use `create(SearchTextRequest_LocationRestrictionSchema)` to create a new message.
 */
export const SearchTextRequest_LocationRestrictionSchema: GenMessage<SearchTextRequest_LocationRestriction> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 3, 1);

/**
 * Searchable EV options of a place search request.
 *
 * @generated from message google.maps.places.v1.SearchTextRequest.EVOptions
 */
export type SearchTextRequest_EVOptions = Message<"google.maps.places.v1.SearchTextRequest.EVOptions"> & {
  /**
   * Optional. Minimum required charging rate in kilowatts. A place with a
   * charging rate less than the specified rate is filtered out.
   *
   * @generated from field: double minimum_charging_rate_kw = 1;
   */
  minimumChargingRateKw: number;

  /**
   * Optional. The list of preferred EV connector types. A place that does not
   * support any of the listed connector types is filtered out.
   *
   * @generated from field: repeated google.maps.places.v1.EVConnectorType connector_types = 2;
   */
  connectorTypes: EVConnectorType[];
};

/**
 * Describes the message google.maps.places.v1.SearchTextRequest.EVOptions.
 * Use `create(SearchTextRequest_EVOptionsSchema)` to create a new message.
 */
export const SearchTextRequest_EVOptionsSchema: GenMessage<SearchTextRequest_EVOptions> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 3, 2);

/**
 * Specifies a precalculated polyline from the [Routes
 * API](https://developers.google.com/maps/documentation/routes) defining the
 * route to search. Searching along a route is similar to using the
 * `locationBias` or `locationRestriction` request option to bias the search
 * results. However, while the `locationBias` and `locationRestriction`
 * options let you specify a region to bias the search results, this option
 * lets you bias the results along a trip route.
 *
 * Results are not guaranteed to be along the route provided, but rather are
 * ranked within the search area defined by the polyline and, optionally, by
 * the `locationBias` or `locationRestriction` based on minimal detour times
 * from origin to destination. The results might be along an alternate route,
 * especially if the provided polyline does not define an optimal route from
 * origin to destination.
 *
 * @generated from message google.maps.places.v1.SearchTextRequest.SearchAlongRouteParameters
 */
export type SearchTextRequest_SearchAlongRouteParameters = Message<"google.maps.places.v1.SearchTextRequest.SearchAlongRouteParameters"> & {
  /**
   * Required. The route polyline.
   *
   * @generated from field: google.maps.places.v1.Polyline polyline = 1;
   */
  polyline?: Polyline;
};

/**
 * Describes the message google.maps.places.v1.SearchTextRequest.SearchAlongRouteParameters.
 * Use `create(SearchTextRequest_SearchAlongRouteParametersSchema)` to create a new message.
 */
export const SearchTextRequest_SearchAlongRouteParametersSchema: GenMessage<SearchTextRequest_SearchAlongRouteParameters> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 3, 3);

/**
 * How results will be ranked in the response.
 *
 * @generated from enum google.maps.places.v1.SearchTextRequest.RankPreference
 */
export enum SearchTextRequest_RankPreference {
  /**
   * For a categorical query such as "Restaurants in New York City", RELEVANCE
   * is the default. For non-categorical queries such as "Mountain View, CA"
   * we recommend that you leave rankPreference unset.
   *
   * @generated from enum value: RANK_PREFERENCE_UNSPECIFIED = 0;
   */
  RANK_PREFERENCE_UNSPECIFIED = 0,

  /**
   * Ranks results by distance.
   *
   * @generated from enum value: DISTANCE = 1;
   */
  DISTANCE = 1,

  /**
   * Ranks results by relevance. Sort order determined by normal ranking
   * stack.
   *
   * @generated from enum value: RELEVANCE = 2;
   */
  RELEVANCE = 2,
}

/**
 * Describes the enum google.maps.places.v1.SearchTextRequest.RankPreference.
 */
export const SearchTextRequest_RankPreferenceSchema: GenEnum<SearchTextRequest_RankPreference> = /*@__PURE__*/
  enumDesc(file_google_maps_places_v1_places_service, 3, 0);

/**
 * Response proto for SearchText.
 *
 *
 * @generated from message google.maps.places.v1.SearchTextResponse
 */
export type SearchTextResponse = Message<"google.maps.places.v1.SearchTextResponse"> & {
  /**
   * A list of places that meet the user's text search criteria.
   *
   * @generated from field: repeated google.maps.places.v1.Place places = 1;
   */
  places: Place[];

  /**
   * A list of routing summaries where each entry associates to the
   * corresponding place in the same index in the places field. If the routing
   * summary is not available for one of the places, it will contain an empty
   * entry. This list will have as many entries as the list of places if
   * requested.
   *
   * @generated from field: repeated google.maps.places.v1.RoutingSummary routing_summaries = 2;
   */
  routingSummaries: RoutingSummary[];

  /**
   * Experimental: See
   * https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
   * for more details.
   *
   * A list of contextual contents where each entry associates to the
   * corresponding place in the same index in the places field. The contents
   * that are relevant to the `text_query` in the request are preferred. If the
   * contextual content is not available for one of the places, it will return
   * non-contextual content. It will be empty only when the content is
   * unavailable for this place. This list will have as many entries as the
   * list of places if requested.
   *
   * @generated from field: repeated google.maps.places.v1.ContextualContent contextual_contents = 3;
   */
  contextualContents: ContextualContent[];
};

/**
 * Describes the message google.maps.places.v1.SearchTextResponse.
 * Use `create(SearchTextResponseSchema)` to create a new message.
 */
export const SearchTextResponseSchema: GenMessage<SearchTextResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 4);

/**
 * Request for fetching a photo of a place using a photo resource name.
 *
 * @generated from message google.maps.places.v1.GetPhotoMediaRequest
 */
export type GetPhotoMediaRequest = Message<"google.maps.places.v1.GetPhotoMediaRequest"> & {
  /**
   * Required. The resource name of a photo media in the format:
   * `places/{place_id}/photos/{photo_reference}/media`.
   *
   * The resource name of a photo as returned in a Place object's `photos.name`
   * field comes with the format
   * `places/{place_id}/photos/{photo_reference}`. You need to append `/media`
   * at the end of the photo resource to get the photo media resource name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. Specifies the maximum desired width, in pixels, of the image. If
   * the image is smaller than the values specified, the original image will be
   * returned. If the image is larger in either dimension, it will be scaled to
   * match the smaller of the two dimensions, restricted to its original aspect
   * ratio. Both the max_height_px and max_width_px properties accept an integer
   * between 1 and 4800, inclusively. If the value is not within the allowed
   * range, an INVALID_ARGUMENT error will be returned.
   *
   * At least one of max_height_px or max_width_px needs to be specified. If
   * neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
   * error will be returned.
   *
   * @generated from field: int32 max_width_px = 2;
   */
  maxWidthPx: number;

  /**
   * Optional. Specifies the maximum desired height, in pixels, of the image. If
   * the image is smaller than the values specified, the original image will be
   * returned. If the image is larger in either dimension, it will be scaled to
   * match the smaller of the two dimensions, restricted to its original aspect
   * ratio. Both the max_height_px and max_width_px properties accept an integer
   * between 1 and 4800, inclusively. If the value is not within the allowed
   * range, an INVALID_ARGUMENT error will be returned.
   *
   * At least one of max_height_px or max_width_px needs to be specified. If
   * neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
   * error will be returned.
   *
   * @generated from field: int32 max_height_px = 3;
   */
  maxHeightPx: number;

  /**
   * Optional. If set, skip the default HTTP redirect behavior and render a text
   * format (for example, in JSON format for HTTP use case) response. If not
   * set, an HTTP redirect will be issued to redirect the call to the image
   * media. This option is ignored for non-HTTP requests.
   *
   * @generated from field: bool skip_http_redirect = 4;
   */
  skipHttpRedirect: boolean;
};

/**
 * Describes the message google.maps.places.v1.GetPhotoMediaRequest.
 * Use `create(GetPhotoMediaRequestSchema)` to create a new message.
 */
export const GetPhotoMediaRequestSchema: GenMessage<GetPhotoMediaRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 5);

/**
 * A photo media from Places API.
 *
 * @generated from message google.maps.places.v1.PhotoMedia
 */
export type PhotoMedia = Message<"google.maps.places.v1.PhotoMedia"> & {
  /**
   * The resource name of a photo media in the format:
   * `places/{place_id}/photos/{photo_reference}/media`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A short-lived uri that can be used to render the photo.
   *
   * @generated from field: string photo_uri = 2;
   */
  photoUri: string;
};

/**
 * Describes the message google.maps.places.v1.PhotoMedia.
 * Use `create(PhotoMediaSchema)` to create a new message.
 */
export const PhotoMediaSchema: GenMessage<PhotoMedia> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 6);

/**
 * Request for fetching a Place based on its resource name, which is a string in
 * the `places/{place_id}` format.
 *
 * @generated from message google.maps.places.v1.GetPlaceRequest
 */
export type GetPlaceRequest = Message<"google.maps.places.v1.GetPlaceRequest"> & {
  /**
   * Required. The resource name of a place, in the `places/{place_id}` format.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. Place details will be displayed with the preferred language if
   * available.
   *
   * Current list of supported languages:
   * https://developers.google.com/maps/faq#languagesupport.
   *
   * @generated from field: string language_code = 2;
   */
  languageCode: string;

  /**
   * Optional. The Unicode country/region code (CLDR) of the location where the
   * request is coming from. This parameter is used to display the place
   * details, like region-specific place name, if available. The parameter can
   * affect results based on applicable law.
   * For more information, see
   * https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
   *
   *
   * Note that 3-digit region codes are not currently supported.
   *
   * @generated from field: string region_code = 3;
   */
  regionCode: string;

  /**
   * Optional. A string which identifies an Autocomplete session for billing
   * purposes. Must be a URL and filename safe base64 string with at most 36
   * ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
   * returned.
   *
   * The session begins when the user starts typing a query, and concludes when
   * they select a place and a call to Place Details or Address Validation is
   * made. Each session can have multiple queries, followed by one Place Details
   * or Address Validation request. The credentials used for each request within
   * a session must belong to the same Google Cloud Console project. Once a
   * session has concluded, the token is no longer valid; your app must generate
   * a fresh token for each session. If the `session_token` parameter is
   * omitted, or if you reuse a session token, the session is charged as if no
   * session token was provided (each request is billed separately).
   *
   * We recommend the following guidelines:
   *
   * * Use session tokens for all Place Autocomplete calls.
   * * Generate a fresh token for each session. Using a version 4 UUID is
   *   recommended.
   * * Ensure that the credentials used for all Place Autocomplete, Place
   *   Details, and Address Validation requests within a session belong to the
   *   same Cloud Console project.
   * * Be sure to pass a unique session token for each new session. Using the
   *   same token for more than one session will result in each request being
   *   billed individually.
   *
   * @generated from field: string session_token = 4;
   */
  sessionToken: string;
};

/**
 * Describes the message google.maps.places.v1.GetPlaceRequest.
 * Use `create(GetPlaceRequestSchema)` to create a new message.
 */
export const GetPlaceRequestSchema: GenMessage<GetPlaceRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 7);

/**
 * Request proto for AutocompletePlaces.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesRequest
 */
export type AutocompletePlacesRequest = Message<"google.maps.places.v1.AutocompletePlacesRequest"> & {
  /**
   * Required. The text string on which to search.
   *
   * @generated from field: string input = 1;
   */
  input: string;

  /**
   * Optional. Bias results to a specified location.
   *
   * At most one of `location_bias` or `location_restriction` should be set. If
   * neither are set, the results will be biased by IP address, meaning the IP
   * address will be mapped to an imprecise location and used as a biasing
   * signal.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesRequest.LocationBias location_bias = 2;
   */
  locationBias?: AutocompletePlacesRequest_LocationBias;

  /**
   * Optional. Restrict results to a specified location.
   *
   * At most one of `location_bias` or `location_restriction` should be set. If
   * neither are set, the results will be biased by IP address, meaning the IP
   * address will be mapped to an imprecise location and used as a biasing
   * signal.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesRequest.LocationRestriction location_restriction = 3;
   */
  locationRestriction?: AutocompletePlacesRequest_LocationRestriction;

  /**
   * Optional. Included primary Place type (for example, "restaurant" or
   * "gas_station") in Place Types
   * (https://developers.google.com/maps/documentation/places/web-service/place-types),
   * or only `(regions)`, or only `(cities)`. A Place is only returned if its
   * primary type is included in this list. Up to 5 values can be specified. If
   * no types are specified, all Place types are returned.
   *
   * @generated from field: repeated string included_primary_types = 4;
   */
  includedPrimaryTypes: string[];

  /**
   * Optional. Only include results in the specified regions, specified as up to
   * 15 CLDR two-character region codes. An empty set will not restrict the
   * results. If both `location_restriction` and `included_region_codes` are
   * set, the results will be located in the area of intersection.
   *
   * @generated from field: repeated string included_region_codes = 5;
   */
  includedRegionCodes: string[];

  /**
   * Optional. The language in which to return results. Defaults to en-US. The
   * results may be in mixed languages if the language used in `input` is
   * different from `language_code` or if the returned Place does not have a
   * translation from the local language to `language_code`.
   *
   * @generated from field: string language_code = 6;
   */
  languageCode: string;

  /**
   * Optional. The region code, specified as a CLDR two-character region code.
   * This affects address formatting, result ranking, and may influence what
   * results are returned. This does not restrict results to the specified
   * region. To restrict results to a region, use `region_code_restriction`.
   *
   * @generated from field: string region_code = 7;
   */
  regionCode: string;

  /**
   * Optional. The origin point from which to calculate geodesic distance to the
   * destination (returned as `distance_meters`). If this value is omitted,
   * geodesic distance will not be returned.
   *
   * @generated from field: google.type.LatLng origin = 8;
   */
  origin?: LatLng;

  /**
   * Optional. A zero-based Unicode character offset of `input` indicating the
   * cursor position in `input`. The cursor position may influence what
   * predictions are returned.
   *
   * If empty, defaults to the length of `input`.
   *
   * @generated from field: int32 input_offset = 9;
   */
  inputOffset: number;

  /**
   * Optional. If true, the response will include both Place and query
   * predictions. Otherwise the response will only return Place predictions.
   *
   * @generated from field: bool include_query_predictions = 10;
   */
  includeQueryPredictions: boolean;

  /**
   * Optional. A string which identifies an Autocomplete session for billing
   * purposes. Must be a URL and filename safe base64 string with at most 36
   * ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
   * returned.
   *
   * The session begins when the user starts typing a query, and concludes when
   * they select a place and a call to Place Details or Address Validation is
   * made. Each session can have multiple queries, followed by one Place Details
   * or Address Validation request. The credentials used for each request within
   * a session must belong to the same Google Cloud Console project. Once a
   * session has concluded, the token is no longer valid; your app must generate
   * a fresh token for each session. If the `session_token` parameter is
   * omitted, or if you reuse a session token, the session is charged as if no
   * session token was provided (each request is billed separately).
   *
   * We recommend the following guidelines:
   *
   * * Use session tokens for all Place Autocomplete calls.
   * * Generate a fresh token for each session. Using a version 4 UUID is
   *   recommended.
   * * Ensure that the credentials used for all Place Autocomplete, Place
   *   Details, and Address Validation requests within a session belong to the
   *   same Cloud Console project.
   * * Be sure to pass a unique session token for each new session. Using the
   *   same token for more than one session will result in each request being
   *   billed individually.
   *
   * @generated from field: string session_token = 11;
   */
  sessionToken: string;
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesRequest.
 * Use `create(AutocompletePlacesRequestSchema)` to create a new message.
 */
export const AutocompletePlacesRequestSchema: GenMessage<AutocompletePlacesRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 8);

/**
 * The region to search. The results may be biased around the specified
 * region.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesRequest.LocationBias
 */
export type AutocompletePlacesRequest_LocationBias = Message<"google.maps.places.v1.AutocompletePlacesRequest.LocationBias"> & {
  /**
   * @generated from oneof google.maps.places.v1.AutocompletePlacesRequest.LocationBias.type
   */
  type: {
    /**
     * A viewport defined by a northeast and a southwest corner.
     *
     * @generated from field: google.geo.type.Viewport rectangle = 1;
     */
    value: Viewport;
    case: "rectangle";
  } | {
    /**
     * A circle defined by a center point and radius.
     *
     * @generated from field: google.maps.places.v1.Circle circle = 2;
     */
    value: Circle;
    case: "circle";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesRequest.LocationBias.
 * Use `create(AutocompletePlacesRequest_LocationBiasSchema)` to create a new message.
 */
export const AutocompletePlacesRequest_LocationBiasSchema: GenMessage<AutocompletePlacesRequest_LocationBias> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 8, 0);

/**
 * The region to search. The results will be restricted to the specified
 * region.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesRequest.LocationRestriction
 */
export type AutocompletePlacesRequest_LocationRestriction = Message<"google.maps.places.v1.AutocompletePlacesRequest.LocationRestriction"> & {
  /**
   * @generated from oneof google.maps.places.v1.AutocompletePlacesRequest.LocationRestriction.type
   */
  type: {
    /**
     * A viewport defined by a northeast and a southwest corner.
     *
     * @generated from field: google.geo.type.Viewport rectangle = 1;
     */
    value: Viewport;
    case: "rectangle";
  } | {
    /**
     * A circle defined by a center point and radius.
     *
     * @generated from field: google.maps.places.v1.Circle circle = 2;
     */
    value: Circle;
    case: "circle";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesRequest.LocationRestriction.
 * Use `create(AutocompletePlacesRequest_LocationRestrictionSchema)` to create a new message.
 */
export const AutocompletePlacesRequest_LocationRestrictionSchema: GenMessage<AutocompletePlacesRequest_LocationRestriction> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 8, 1);

/**
 * Response proto for AutocompletePlaces.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse
 */
export type AutocompletePlacesResponse = Message<"google.maps.places.v1.AutocompletePlacesResponse"> & {
  /**
   * Contains a list of suggestions, ordered in descending order of relevance.
   *
   * @generated from field: repeated google.maps.places.v1.AutocompletePlacesResponse.Suggestion suggestions = 1;
   */
  suggestions: AutocompletePlacesResponse_Suggestion[];
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.
 * Use `create(AutocompletePlacesResponseSchema)` to create a new message.
 */
export const AutocompletePlacesResponseSchema: GenMessage<AutocompletePlacesResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9);

/**
 * An Autocomplete suggestion result.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion
 */
export type AutocompletePlacesResponse_Suggestion = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion"> & {
  /**
   * @generated from oneof google.maps.places.v1.AutocompletePlacesResponse.Suggestion.kind
   */
  kind: {
    /**
     * A prediction for a Place.
     *
     * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.PlacePrediction place_prediction = 1;
     */
    value: AutocompletePlacesResponse_Suggestion_PlacePrediction;
    case: "placePrediction";
  } | {
    /**
     * A prediction for a query.
     *
     * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.QueryPrediction query_prediction = 2;
     */
    value: AutocompletePlacesResponse_Suggestion_QueryPrediction;
    case: "queryPrediction";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.
 * Use `create(AutocompletePlacesResponse_SuggestionSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_SuggestionSchema: GenMessage<AutocompletePlacesResponse_Suggestion> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0);

/**
 * Identifies a substring within a given text.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StringRange
 */
export type AutocompletePlacesResponse_Suggestion_StringRange = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StringRange"> & {
  /**
   * Zero-based offset of the first Unicode character of the string
   * (inclusive).
   *
   * @generated from field: int32 start_offset = 1;
   */
  startOffset: number;

  /**
   * Zero-based offset of the last Unicode character (exclusive).
   *
   * @generated from field: int32 end_offset = 2;
   */
  endOffset: number;
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StringRange.
 * Use `create(AutocompletePlacesResponse_Suggestion_StringRangeSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_Suggestion_StringRangeSchema: GenMessage<AutocompletePlacesResponse_Suggestion_StringRange> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0, 0);

/**
 * Text representing a Place or query prediction. The text may be used as is
 * or formatted.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText
 */
export type AutocompletePlacesResponse_Suggestion_FormattableText = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText"> & {
  /**
   * Text that may be used as is or formatted with `matches`.
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * A list of string ranges identifying where the input request matched in
   * `text`. The ranges can be used to format specific parts of `text`. The
   * substrings may not be exact matches of `input` if the matching was
   * determined by criteria other than string matching (for example, spell
   * corrections or transliterations).
   *
   * These values are Unicode character offsets of `text`. The ranges are
   * guaranteed to be ordered in increasing offset values.
   *
   * @generated from field: repeated google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StringRange matches = 2;
   */
  matches: AutocompletePlacesResponse_Suggestion_StringRange[];
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText.
 * Use `create(AutocompletePlacesResponse_Suggestion_FormattableTextSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_Suggestion_FormattableTextSchema: GenMessage<AutocompletePlacesResponse_Suggestion_FormattableText> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0, 1);

/**
 * Contains a breakdown of a Place or query prediction into main text
 * and secondary text.
 *
 * For Place predictions, the main text contains the specific name of the
 * Place. For query predictions, the main text contains the query.
 *
 * The secondary text contains additional disambiguating features (such as a
 * city or region) to further identify the Place or refine the query.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StructuredFormat
 */
export type AutocompletePlacesResponse_Suggestion_StructuredFormat = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StructuredFormat"> & {
  /**
   * Represents the name of the Place or query.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText main_text = 1;
   */
  mainText?: AutocompletePlacesResponse_Suggestion_FormattableText;

  /**
   * Represents additional disambiguating features (such as a city or
   * region) to further identify the Place or refine the query.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText secondary_text = 2;
   */
  secondaryText?: AutocompletePlacesResponse_Suggestion_FormattableText;
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StructuredFormat.
 * Use `create(AutocompletePlacesResponse_Suggestion_StructuredFormatSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_Suggestion_StructuredFormatSchema: GenMessage<AutocompletePlacesResponse_Suggestion_StructuredFormat> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0, 2);

/**
 * Prediction results for a Place Autocomplete prediction.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.PlacePrediction
 */
export type AutocompletePlacesResponse_Suggestion_PlacePrediction = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion.PlacePrediction"> & {
  /**
   * The resource name of the suggested Place. This name can be used in
   * other APIs that accept Place names.
   *
   * @generated from field: string place = 1;
   */
  place: string;

  /**
   * The unique identifier of the suggested Place. This identifier can be
   * used in other APIs that accept Place IDs.
   *
   * @generated from field: string place_id = 2;
   */
  placeId: string;

  /**
   * Contains the human-readable name for the returned result. For
   * establishment results, this is usually the business name and address.
   *
   * `text` is recommended for developers who wish to show a single UI
   * element. Developers who wish to show two separate, but related, UI
   * elements may want to use `structured_format` instead. They are two
   * different ways to represent a Place prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * This text may be different from the `display_name` returned by
   * GetPlace.
   *
   * May be in mixed languages if the request `input` and `language_code`
   * are in different languages or if the Place does not have a translation
   * from the local language to `language_code`.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText text = 3;
   */
  text?: AutocompletePlacesResponse_Suggestion_FormattableText;

  /**
   * A breakdown of the Place prediction into main text containing the name
   * of the Place and secondary text containing additional disambiguating
   * features (such as a city or region).
   *
   * `structured_format` is recommended for developers who wish to show two
   * separate, but related, UI elements. Developers who wish to show a
   * single UI element may want to use `text` instead. They are two
   * different ways to represent a Place prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StructuredFormat structured_format = 4;
   */
  structuredFormat?: AutocompletePlacesResponse_Suggestion_StructuredFormat;

  /**
   * List of types that apply to this Place from Table A or Table B in
   * https://developers.google.com/maps/documentation/places/web-service/place-types.
   *
   * A type is a categorization of a Place. Places with shared types will
   * share similar characteristics.
   *
   * @generated from field: repeated string types = 5;
   */
  types: string[];

  /**
   * The length of the geodesic in meters from `origin` if `origin` is
   * specified. Certain predictions such as routes may not populate this
   * field.
   *
   * @generated from field: int32 distance_meters = 6;
   */
  distanceMeters: number;
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.PlacePrediction.
 * Use `create(AutocompletePlacesResponse_Suggestion_PlacePredictionSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_Suggestion_PlacePredictionSchema: GenMessage<AutocompletePlacesResponse_Suggestion_PlacePrediction> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0, 3);

/**
 * Prediction results for a Query Autocomplete prediction.
 *
 * @generated from message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.QueryPrediction
 */
export type AutocompletePlacesResponse_Suggestion_QueryPrediction = Message<"google.maps.places.v1.AutocompletePlacesResponse.Suggestion.QueryPrediction"> & {
  /**
   * The predicted text. This text does not represent a Place, but rather a
   * text query that could be used in a search endpoint (for example,
   * Text Search).
   *
   * `text` is recommended for developers who wish to show a single UI
   * element. Developers who wish to show two separate, but related, UI
   * elements may want to use `structured_format` instead. They are two
   * different ways to represent a query prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * May be in mixed languages if the request `input` and `language_code`
   * are in different languages or if part of the query does not have a
   * translation from the local language to `language_code`.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.FormattableText text = 1;
   */
  text?: AutocompletePlacesResponse_Suggestion_FormattableText;

  /**
   * A breakdown of the query prediction into main text containing the query
   * and secondary text containing additional disambiguating features (such
   * as a city or region).
   *
   * `structured_format` is recommended for developers who wish to show two
   * separate, but related, UI elements. Developers who wish to show a
   * single UI element may want to use `text` instead. They are two
   * different ways to represent a query prediction. Users should not try to
   * parse `structured_format` into `text` or vice versa.
   *
   * @generated from field: google.maps.places.v1.AutocompletePlacesResponse.Suggestion.StructuredFormat structured_format = 2;
   */
  structuredFormat?: AutocompletePlacesResponse_Suggestion_StructuredFormat;
};

/**
 * Describes the message google.maps.places.v1.AutocompletePlacesResponse.Suggestion.QueryPrediction.
 * Use `create(AutocompletePlacesResponse_Suggestion_QueryPredictionSchema)` to create a new message.
 */
export const AutocompletePlacesResponse_Suggestion_QueryPredictionSchema: GenMessage<AutocompletePlacesResponse_Suggestion_QueryPrediction> = /*@__PURE__*/
  messageDesc(file_google_maps_places_v1_places_service, 9, 0, 4);

/**
 * Service definition for the Places API.
 * Note: every request (except for Autocomplete requests) requires a field mask
 * set outside of the request proto (`all/*`, is not assumed). The field mask
 * can be set via the HTTP header `X-Goog-FieldMask`. See:
 * https://developers.google.com/maps/documentation/places/web-service/choose-fields
 *
 * @generated from service google.maps.places.v1.Places
 */
export const Places: GenService<{
  /**
   * Search for places near locations.
   *
   * @generated from rpc google.maps.places.v1.Places.SearchNearby
   */
  searchNearby: {
    methodKind: "unary";
    input: typeof SearchNearbyRequestSchema;
    output: typeof SearchNearbyResponseSchema;
  },
  /**
   * Text query based place search.
   *
   * @generated from rpc google.maps.places.v1.Places.SearchText
   */
  searchText: {
    methodKind: "unary";
    input: typeof SearchTextRequestSchema;
    output: typeof SearchTextResponseSchema;
  },
  /**
   * Get a photo media with a photo reference string.
   *
   * @generated from rpc google.maps.places.v1.Places.GetPhotoMedia
   */
  getPhotoMedia: {
    methodKind: "unary";
    input: typeof GetPhotoMediaRequestSchema;
    output: typeof PhotoMediaSchema;
  },
  /**
   * Get the details of a place based on its resource name, which is a string
   * in the `places/{place_id}` format.
   *
   * @generated from rpc google.maps.places.v1.Places.GetPlace
   */
  getPlace: {
    methodKind: "unary";
    input: typeof GetPlaceRequestSchema;
    output: typeof PlaceSchema;
  },
  /**
   * Returns predictions for the given input.
   *
   * @generated from rpc google.maps.places.v1.Places.AutocompletePlaces
   */
  autocompletePlaces: {
    methodKind: "unary";
    input: typeof AutocompletePlacesRequestSchema;
    output: typeof AutocompletePlacesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_maps_places_v1_places_service, 0);

