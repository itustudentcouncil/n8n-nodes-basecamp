// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/maps/playablelocations/v3/playablelocations.proto (package google.maps.playablelocations.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { Impression, PlayerReport } from "./resources_pb";
import { file_google_maps_playablelocations_v3_resources } from "./resources_pb";
import type { AreaFilter, Criterion, PlayableLocationList } from "./sample/resources_pb";
import { file_google_maps_playablelocations_v3_sample_resources } from "./sample/resources_pb";
import type { ClientInfo } from "../../unity/clientinfo_pb";
import { file_google_maps_unity_clientinfo } from "../../unity/clientinfo_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration } from "@bufbuild/protobuf/wkt";
import { file_google_api_client } from "../../../api/client_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/maps/playablelocations/v3/playablelocations.proto.
 */
export const file_google_maps_playablelocations_v3_playablelocations: GenFile = /*@__PURE__*/
  fileDesc("Cjhnb29nbGUvbWFwcy9wbGF5YWJsZWxvY2F0aW9ucy92My9wbGF5YWJsZWxvY2F0aW9ucy5wcm90bxIgZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMiugEKHlNhbXBsZVBsYXlhYmxlTG9jYXRpb25zUmVxdWVzdBJNCgthcmVhX2ZpbHRlchgBIAEoCzIzLmdvb2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLnNhbXBsZS5BcmVhRmlsdGVyQgPgQQISSQoIY3JpdGVyaWEYAiADKAsyMi5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0aW9ucy52My5zYW1wbGUuQ3JpdGVyaW9uQgPgQQIi2AIKH1NhbXBsZVBsYXlhYmxlTG9jYXRpb25zUmVzcG9uc2USiQEKHmxvY2F0aW9uc19wZXJfZ2FtZV9vYmplY3RfdHlwZRgBIAMoCzJhLmdvb2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLlNhbXBsZVBsYXlhYmxlTG9jYXRpb25zUmVzcG9uc2UuTG9jYXRpb25zUGVyR2FtZU9iamVjdFR5cGVFbnRyeRImCgN0dGwYCSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24agAEKH0xvY2F0aW9uc1BlckdhbWVPYmplY3RUeXBlRW50cnkSCwoDa2V5GAEgASgFEkwKBXZhbHVlGAIgASgLMj0uZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuc2FtcGxlLlBsYXlhYmxlTG9jYXRpb25MaXN0OgI4ASK4AQoXTG9nUGxheWVyUmVwb3J0c1JlcXVlc3QSSwoOcGxheWVyX3JlcG9ydHMYASADKAsyLi5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0aW9ucy52My5QbGF5ZXJSZXBvcnRCA+BBAhIXCgpyZXF1ZXN0X2lkGAIgASgJQgPgQQISNwoLY2xpZW50X2luZm8YAyABKAsyHS5nb29nbGUubWFwcy51bml0eS5DbGllbnRJbmZvQgPgQQIiGgoYTG9nUGxheWVyUmVwb3J0c1Jlc3BvbnNlIrEBChVMb2dJbXByZXNzaW9uc1JlcXVlc3QSRgoLaW1wcmVzc2lvbnMYASADKAsyLC5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0aW9ucy52My5JbXByZXNzaW9uQgPgQQISFwoKcmVxdWVzdF9pZBgCIAEoCUID4EECEjcKC2NsaWVudF9pbmZvGAMgASgLMh0uZ29vZ2xlLm1hcHMudW5pdHkuQ2xpZW50SW5mb0ID4EECIhgKFkxvZ0ltcHJlc3Npb25zUmVzcG9uc2Uy0wQKEVBsYXlhYmxlTG9jYXRpb25zEsYBChdTYW1wbGVQbGF5YWJsZUxvY2F0aW9ucxJALmdvb2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLlNhbXBsZVBsYXlhYmxlTG9jYXRpb25zUmVxdWVzdBpBLmdvb2dsZS5tYXBzLnBsYXlhYmxlbG9jYXRpb25zLnYzLlNhbXBsZVBsYXlhYmxlTG9jYXRpb25zUmVzcG9uc2UiJoLT5JMCIDoBKiIbL3YzOnNhbXBsZVBsYXlhYmxlTG9jYXRpb25zEqoBChBMb2dQbGF5ZXJSZXBvcnRzEjkuZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuTG9nUGxheWVyUmVwb3J0c1JlcXVlc3QaOi5nb29nbGUubWFwcy5wbGF5YWJsZWxvY2F0aW9ucy52My5Mb2dQbGF5ZXJSZXBvcnRzUmVzcG9uc2UiH4LT5JMCGToBKiIUL3YzOmxvZ1BsYXllclJlcG9ydHMSogEKDkxvZ0ltcHJlc3Npb25zEjcuZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuTG9nSW1wcmVzc2lvbnNSZXF1ZXN0GjguZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjMuTG9nSW1wcmVzc2lvbnNSZXNwb25zZSIdgtPkkwIXOgEqIhIvdjM6bG9nSW1wcmVzc2lvbnMaI8pBIHBsYXlhYmxlbG9jYXRpb25zLmdvb2dsZWFwaXMuY29tQucBCiRjb20uZ29vZ2xlLm1hcHMucGxheWFibGVsb2NhdGlvbnMudjNCFlBsYXlhYmxlTG9jYXRpb25zUHJvdG9QAVpYY2xvdWQuZ29vZ2xlLmNvbS9nby9tYXBzL3BsYXlhYmxlbG9jYXRpb25zL2FwaXYzL3BsYXlhYmxlbG9jYXRpb25zcGI7cGxheWFibGVsb2NhdGlvbnNwYqICBEdNUEyqAiBHb29nbGUuTWFwcy5QbGF5YWJsZUxvY2F0aW9ucy5WM8oCIEdvb2dsZVxNYXBzXFBsYXlhYmxlTG9jYXRpb25zXFYzYgZwcm90bzM", [file_google_api_annotations, file_google_api_field_behavior, file_google_maps_playablelocations_v3_resources, file_google_maps_playablelocations_v3_sample_resources, file_google_maps_unity_clientinfo, file_google_protobuf_duration, file_google_api_client]);

/**
 *
 * Life of a query:
 *
 * - When a game starts in a new location, your game server issues a
 * [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
 * request. The request specifies the S2 cell, and contains one or more
 * "criteria" for filtering:
 *
 * - Criterion 0: i locations for long-lived bases, or level 0 monsters, or...
 * - Criterion 1: j locations for short-lived bases, or level 1 monsters, ...
 * - Criterion 2: k locations for random objects.
 * - etc (up to 5 criterion may be specified).
 *
 * `PlayableLocationList` will then contain mutually
 * exclusive lists of `PlayableLocation` objects that satisfy each of
 * the criteria. Think of it as a collection of real-world locations that you
 * can then associate with your game state.
 *
 * Note: These points are impermanent in nature. E.g, parks can close, and
 * places can be removed.
 *
 * The response specifies how long you can expect the playable locations to
 * last. Once they expire, you should query the `samplePlayableLocations` API
 * again to get a fresh view of the real world.
 *
 * @generated from message google.maps.playablelocations.v3.SamplePlayableLocationsRequest
 */
export type SamplePlayableLocationsRequest = Message<"google.maps.playablelocations.v3.SamplePlayableLocationsRequest"> & {
  /**
   * Required. Specifies the area to search within for playable locations.
   *
   * @generated from field: google.maps.playablelocations.v3.sample.AreaFilter area_filter = 1;
   */
  areaFilter?: AreaFilter;

  /**
   * Required. Specifies one or more (up to 5) criteria for filtering the
   * returned playable locations.
   *
   * @generated from field: repeated google.maps.playablelocations.v3.sample.Criterion criteria = 2;
   */
  criteria: Criterion[];
};

/**
 * Describes the message google.maps.playablelocations.v3.SamplePlayableLocationsRequest.
 * Use `create(SamplePlayableLocationsRequestSchema)` to create a new message.
 */
export const SamplePlayableLocationsRequestSchema: GenMessage<SamplePlayableLocationsRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 0);

/**
 *
 * Response for the
 * [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
 * method.
 *
 * @generated from message google.maps.playablelocations.v3.SamplePlayableLocationsResponse
 */
export type SamplePlayableLocationsResponse = Message<"google.maps.playablelocations.v3.SamplePlayableLocationsResponse"> & {
  /**
   * Each PlayableLocation object corresponds to a game_object_type specified
   * in the request.
   *
   * @generated from field: map<int32, google.maps.playablelocations.v3.sample.PlayableLocationList> locations_per_game_object_type = 1;
   */
  locationsPerGameObjectType: { [key: number]: PlayableLocationList };

  /**
   * Required. Specifies the "time-to-live" for the set of playable locations.
   * You can use this value to determine how long to cache the set of playable
   * locations. After this length of time, your back-end game server should
   * issue a new
   * [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
   * request to get a fresh set of playable locations (because for example, they
   * might have been removed, a park might have closed for the day, a
   * business might have closed permanently).
   *
   * @generated from field: google.protobuf.Duration ttl = 9;
   */
  ttl?: Duration;
};

/**
 * Describes the message google.maps.playablelocations.v3.SamplePlayableLocationsResponse.
 * Use `create(SamplePlayableLocationsResponseSchema)` to create a new message.
 */
export const SamplePlayableLocationsResponseSchema: GenMessage<SamplePlayableLocationsResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 1);

/**
 * A request for logging your player's bad location reports.
 *
 * @generated from message google.maps.playablelocations.v3.LogPlayerReportsRequest
 */
export type LogPlayerReportsRequest = Message<"google.maps.playablelocations.v3.LogPlayerReportsRequest"> & {
  /**
   * Required. Player reports. The maximum number of player reports that you can
   * log at once is 50.
   *
   * @generated from field: repeated google.maps.playablelocations.v3.PlayerReport player_reports = 1;
   */
  playerReports: PlayerReport[];

  /**
   * Required. A string that uniquely identifies the log player reports request.
   * This allows you to detect duplicate requests. We recommend that you use
   * UUIDs for this value. The value must not exceed 50 characters.
   *
   * You should reuse the `request_id` only when retrying a request in the case
   * of a failure. In that case, the request must be identical to the one that
   * failed.
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;

  /**
   * Required. Information about the client device (for example, device model
   * and operating system).
   *
   * @generated from field: google.maps.unity.ClientInfo client_info = 3;
   */
  clientInfo?: ClientInfo;
};

/**
 * Describes the message google.maps.playablelocations.v3.LogPlayerReportsRequest.
 * Use `create(LogPlayerReportsRequestSchema)` to create a new message.
 */
export const LogPlayerReportsRequestSchema: GenMessage<LogPlayerReportsRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 2);

/**
 * A response for the
 * [LogPlayerReports][google.maps.playablelocations.v3.PlayableLocations.LogPlayerReports]
 * method.
 *
 * This method returns no data upon success.
 *
 * @generated from message google.maps.playablelocations.v3.LogPlayerReportsResponse
 */
export type LogPlayerReportsResponse = Message<"google.maps.playablelocations.v3.LogPlayerReportsResponse"> & {
};

/**
 * Describes the message google.maps.playablelocations.v3.LogPlayerReportsResponse.
 * Use `create(LogPlayerReportsResponseSchema)` to create a new message.
 */
export const LogPlayerReportsResponseSchema: GenMessage<LogPlayerReportsResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 3);

/**
 * A request for logging impressions.
 *
 * @generated from message google.maps.playablelocations.v3.LogImpressionsRequest
 */
export type LogImpressionsRequest = Message<"google.maps.playablelocations.v3.LogImpressionsRequest"> & {
  /**
   * Required. Impression event details. The maximum number of impression
   * reports that you can log at once is 50.
   *
   * @generated from field: repeated google.maps.playablelocations.v3.Impression impressions = 1;
   */
  impressions: Impression[];

  /**
   * Required. A string that uniquely identifies the log impressions request.
   * This allows you to detect duplicate requests. We recommend that you use
   * UUIDs for this value. The value must not exceed 50 characters.
   *
   * You should reuse the `request_id` only when retrying a request in case of
   * failure. In this case, the request must be identical to the one that
   * failed.
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;

  /**
   * Required. Information about the client device. For example, device model
   * and operating system.
   *
   * @generated from field: google.maps.unity.ClientInfo client_info = 3;
   */
  clientInfo?: ClientInfo;
};

/**
 * Describes the message google.maps.playablelocations.v3.LogImpressionsRequest.
 * Use `create(LogImpressionsRequestSchema)` to create a new message.
 */
export const LogImpressionsRequestSchema: GenMessage<LogImpressionsRequest> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 4);

/**
 * A response for the
 * [LogImpressions][google.maps.playablelocations.v3.PlayableLocations.LogImpressions]
 * method. This method returns no data upon success.
 *
 * @generated from message google.maps.playablelocations.v3.LogImpressionsResponse
 */
export type LogImpressionsResponse = Message<"google.maps.playablelocations.v3.LogImpressionsResponse"> & {
};

/**
 * Describes the message google.maps.playablelocations.v3.LogImpressionsResponse.
 * Use `create(LogImpressionsResponseSchema)` to create a new message.
 */
export const LogImpressionsResponseSchema: GenMessage<LogImpressionsResponse> = /*@__PURE__*/
  messageDesc(file_google_maps_playablelocations_v3_playablelocations, 5);

/**
 * The Playable Locations API for v3.
 *
 * @generated from service google.maps.playablelocations.v3.PlayableLocations
 */
export const PlayableLocations: GenService<{
  /**
   * Returns a set of playable locations that lie within a specified area,
   * that satisfy optional filter criteria.
   *
   * Note: Identical `SamplePlayableLocations` requests can return different
   * results as the state of the world changes over time.
   *
   * @generated from rpc google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations
   */
  samplePlayableLocations: {
    methodKind: "unary";
    input: typeof SamplePlayableLocationsRequestSchema;
    output: typeof SamplePlayableLocationsResponseSchema;
  },
  /**
   * Logs bad playable location reports submitted by players.
   *
   * Reports are not partially saved; either all reports are saved and this
   * request succeeds, or no reports are saved, and this request fails.
   *
   * @generated from rpc google.maps.playablelocations.v3.PlayableLocations.LogPlayerReports
   */
  logPlayerReports: {
    methodKind: "unary";
    input: typeof LogPlayerReportsRequestSchema;
    output: typeof LogPlayerReportsResponseSchema;
  },
  /**
   * Logs new events when playable locations are displayed, and when they are
   * interacted with.
   *
   * Impressions are not partially saved; either all impressions are saved and
   * this request succeeds, or no impressions are saved, and this request fails.
   *
   * @generated from rpc google.maps.playablelocations.v3.PlayableLocations.LogImpressions
   */
  logImpressions: {
    methodKind: "unary";
    input: typeof LogImpressionsRequestSchema;
    output: typeof LogImpressionsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_maps_playablelocations_v3_playablelocations, 0);

