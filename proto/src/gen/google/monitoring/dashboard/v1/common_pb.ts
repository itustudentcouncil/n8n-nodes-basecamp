// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/monitoring/dashboard/v1/common.proto (package google.monitoring.dashboard.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration } from "@bufbuild/protobuf/wkt";
import type { Interval } from "../../../type/interval_pb";
import { file_google_type_interval } from "../../../type/interval_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/monitoring/dashboard/v1/common.proto.
 */
export const file_google_monitoring_dashboard_v1_common: GenFile = /*@__PURE__*/
  fileDesc("Citnb29nbGUvbW9uaXRvcmluZy9kYXNoYm9hcmQvdjEvY29tbW9uLnByb3RvEh5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjEiwQcKC0FnZ3JlZ2F0aW9uEjMKEGFsaWdubWVudF9wZXJpb2QYASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24STwoScGVyX3Nlcmllc19hbGlnbmVyGAIgASgOMjMuZ29vZ2xlLm1vbml0b3JpbmcuZGFzaGJvYXJkLnYxLkFnZ3JlZ2F0aW9uLkFsaWduZXISUQoUY3Jvc3Nfc2VyaWVzX3JlZHVjZXIYBCABKA4yMy5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjEuQWdncmVnYXRpb24uUmVkdWNlchIXCg9ncm91cF9ieV9maWVsZHMYBSADKAkiiwMKB0FsaWduZXISDgoKQUxJR05fTk9ORRAAEg8KC0FMSUdOX0RFTFRBEAESDgoKQUxJR05fUkFURRACEhUKEUFMSUdOX0lOVEVSUE9MQVRFEAMSFAoQQUxJR05fTkVYVF9PTERFUhAEEg0KCUFMSUdOX01JThAKEg0KCUFMSUdOX01BWBALEg4KCkFMSUdOX01FQU4QDBIPCgtBTElHTl9DT1VOVBANEg0KCUFMSUdOX1NVTRAOEhAKDEFMSUdOX1NURERFVhAPEhQKEEFMSUdOX0NPVU5UX1RSVUUQEBIVChFBTElHTl9DT1VOVF9GQUxTRRAYEhcKE0FMSUdOX0ZSQUNUSU9OX1RSVUUQERIXChNBTElHTl9QRVJDRU5USUxFXzk5EBISFwoTQUxJR05fUEVSQ0VOVElMRV85NRATEhcKE0FMSUdOX1BFUkNFTlRJTEVfNTAQFBIXChNBTElHTl9QRVJDRU5USUxFXzA1EBUSGAoUQUxJR05fUEVSQ0VOVF9DSEFOR0UQFyKxAgoHUmVkdWNlchIPCgtSRURVQ0VfTk9ORRAAEg8KC1JFRFVDRV9NRUFOEAESDgoKUkVEVUNFX01JThACEg4KClJFRFVDRV9NQVgQAxIOCgpSRURVQ0VfU1VNEAQSEQoNUkVEVUNFX1NURERFVhAFEhAKDFJFRFVDRV9DT1VOVBAGEhUKEVJFRFVDRV9DT1VOVF9UUlVFEAcSFgoSUkVEVUNFX0NPVU5UX0ZBTFNFEA8SGAoUUkVEVUNFX0ZSQUNUSU9OX1RSVUUQCBIYChRSRURVQ0VfUEVSQ0VOVElMRV85ORAJEhgKFFJFRFVDRV9QRVJDRU5USUxFXzk1EAoSGAoUUkVEVUNFX1BFUkNFTlRJTEVfNTAQCxIYChRSRURVQ0VfUEVSQ0VOVElMRV8wNRAMIrMDChRQaWNrVGltZVNlcmllc0ZpbHRlchJTCg5yYW5raW5nX21ldGhvZBgBIAEoDjI7Lmdvb2dsZS5tb25pdG9yaW5nLmRhc2hib2FyZC52MS5QaWNrVGltZVNlcmllc0ZpbHRlci5NZXRob2QSFwoPbnVtX3RpbWVfc2VyaWVzGAIgASgFElEKCWRpcmVjdGlvbhgDIAEoDjI+Lmdvb2dsZS5tb25pdG9yaW5nLmRhc2hib2FyZC52MS5QaWNrVGltZVNlcmllc0ZpbHRlci5EaXJlY3Rpb24SJwoIaW50ZXJ2YWwYBCABKAsyFS5nb29nbGUudHlwZS5JbnRlcnZhbCJ0CgZNZXRob2QSFgoSTUVUSE9EX1VOU1BFQ0lGSUVEEAASDwoLTUVUSE9EX01FQU4QARIOCgpNRVRIT0RfTUFYEAISDgoKTUVUSE9EX01JThADEg4KCk1FVEhPRF9TVU0QBBIRCg1NRVRIT0RfTEFURVNUEAUiOwoJRGlyZWN0aW9uEhkKFURJUkVDVElPTl9VTlNQRUNJRklFRBAAEgcKA1RPUBABEgoKBkJPVFRPTRACItABChtTdGF0aXN0aWNhbFRpbWVTZXJpZXNGaWx0ZXISWgoOcmFua2luZ19tZXRob2QYASABKA4yQi5nb29nbGUubW9uaXRvcmluZy5kYXNoYm9hcmQudjEuU3RhdGlzdGljYWxUaW1lU2VyaWVzRmlsdGVyLk1ldGhvZBIXCg9udW1fdGltZV9zZXJpZXMYAiABKAUiPAoGTWV0aG9kEhYKEk1FVEhPRF9VTlNQRUNJRklFRBAAEhoKFk1FVEhPRF9DTFVTVEVSX09VVExJRVIQAUL0AQoiY29tLmdvb2dsZS5tb25pdG9yaW5nLmRhc2hib2FyZC52MUILQ29tbW9uUHJvdG9QAVpGY2xvdWQuZ29vZ2xlLmNvbS9nby9tb25pdG9yaW5nL2Rhc2hib2FyZC9hcGl2MS9kYXNoYm9hcmRwYjtkYXNoYm9hcmRwYqoCJEdvb2dsZS5DbG91ZC5Nb25pdG9yaW5nLkRhc2hib2FyZC5WMcoCJEdvb2dsZVxDbG91ZFxNb25pdG9yaW5nXERhc2hib2FyZFxWMeoCKEdvb2dsZTo6Q2xvdWQ6Ok1vbml0b3Jpbmc6OkRhc2hib2FyZDo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_google_type_interval]);

/**
 * Describes how to combine multiple time series to provide a different view of
 * the data.  Aggregation of time series is done in two steps. First, each time
 * series in the set is _aligned_ to the same time interval boundaries, then the
 * set of time series is optionally _reduced_ in number.
 *
 * Alignment consists of applying the `per_series_aligner` operation
 * to each time series after its data has been divided into regular
 * `alignment_period` time intervals. This process takes _all_ of the data
 * points in an alignment period, applies a mathematical transformation such as
 * averaging, minimum, maximum, delta, etc., and converts them into a single
 * data point per period.
 *
 * Reduction is when the aligned and transformed time series can optionally be
 * combined, reducing the number of time series through similar mathematical
 * transformations. Reduction involves applying a `cross_series_reducer` to
 * all the time series, optionally sorting the time series into subsets with
 * `group_by_fields`, and applying the reducer to each subset.
 *
 * The raw time series data can contain a huge amount of information from
 * multiple sources. Alignment and reduction transforms this mass of data into
 * a more manageable and representative collection of data, for example "the
 * 95% latency across the average of all tasks in a cluster". This
 * representative data can be more easily graphed and comprehended, and the
 * individual time series data is still available for later drilldown. For more
 * details, see [Filtering and
 * aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
 *
 * @generated from message google.monitoring.dashboard.v1.Aggregation
 */
export type Aggregation = Message<"google.monitoring.dashboard.v1.Aggregation"> & {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used
   * to divide the data in all the
   * [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
   * time. This will be done before the per-series aligner can be applied to
   * the data.
   *
   * The value must be at least 60 seconds. If a per-series aligner other than
   * `ALIGN_NONE` is specified, this field is required or an error is returned.
   * If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
   * specified, then this field is ignored.
   *
   * The maximum value of the `alignment_period` is 2 years, or 104 weeks.
   *
   * @generated from field: google.protobuf.Duration alignment_period = 1;
   */
  alignmentPeriod?: Duration;

  /**
   * An `Aligner` describes how to bring the data points in a single
   * time series into temporal alignment. Except for `ALIGN_NONE`, all
   * alignments cause all the data points in an `alignment_period` to be
   * mathematically grouped together, resulting in a single data point for
   * each `alignment_period` with end timestamp at the end of the period.
   *
   * Not all alignment operations may be applied to all time series. The valid
   * choices depend on the `metric_kind` and `value_type` of the original time
   * series. Alignment can change the `metric_kind` or the `value_type` of
   * the time series.
   *
   * Time series data must be aligned in order to perform cross-time
   * series reduction. If `cross_series_reducer` is specified, then
   * `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
   * and `alignment_period` must be specified; otherwise, an error is
   * returned.
   *
   * @generated from field: google.monitoring.dashboard.v1.Aggregation.Aligner per_series_aligner = 2;
   */
  perSeriesAligner: Aggregation_Aligner;

  /**
   * The reduction operation to be used to combine time series into a single
   * time series, where the value of each data point in the resulting series is
   * a function of all the already aligned values in the input time series.
   *
   * Not all reducer operations can be applied to all time series. The valid
   * choices depend on the `metric_kind` and the `value_type` of the original
   * time series. Reduction can yield a time series with a different
   * `metric_kind` or `value_type` than the input time series.
   *
   * Time series data must first be aligned (see `per_series_aligner`) in order
   * to perform cross-time series reduction. If `cross_series_reducer` is
   * specified, then `per_series_aligner` must be specified, and must not be
   * `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
   * error is returned.
   *
   * @generated from field: google.monitoring.dashboard.v1.Aggregation.Reducer cross_series_reducer = 4;
   */
  crossSeriesReducer: Aggregation_Reducer;

  /**
   * The set of fields to preserve when `cross_series_reducer` is
   * specified. The `group_by_fields` determine how the time series are
   * partitioned into subsets prior to applying the aggregation
   * operation. Each subset contains time series that have the same
   * value for each of the grouping fields. Each individual time
   * series is a member of exactly one subset. The
   * `cross_series_reducer` is applied to each subset of time series.
   * It is not possible to reduce across different resource types, so
   * this field implicitly contains `resource.type`.  Fields not
   * specified in `group_by_fields` are aggregated away.  If
   * `group_by_fields` is not specified and all the time series have
   * the same resource type, then the time series are aggregated into
   * a single output time series. If `cross_series_reducer` is not
   * defined, this field is ignored.
   *
   * @generated from field: repeated string group_by_fields = 5;
   */
  groupByFields: string[];
};

/**
 * Describes the message google.monitoring.dashboard.v1.Aggregation.
 * Use `create(AggregationSchema)` to create a new message.
 */
export const AggregationSchema: GenMessage<Aggregation> = /*@__PURE__*/
  messageDesc(file_google_monitoring_dashboard_v1_common, 0);

/**
 * The `Aligner` specifies the operation that will be applied to the data
 * points in each alignment period in a time series. Except for
 * `ALIGN_NONE`, which specifies that no operation be applied, each alignment
 * operation replaces the set of data values in each alignment period with
 * a single value: the result of applying the operation to the data values.
 * An aligned time series has a single data value at the end of each
 * `alignment_period`.
 *
 * An alignment operation can change the data type of the values, too. For
 * example, if you apply a counting operation to boolean values, the data
 * `value_type` in the original time series is `BOOLEAN`, but the `value_type`
 * in the aligned result is `INT64`.
 *
 * @generated from enum google.monitoring.dashboard.v1.Aggregation.Aligner
 */
export enum Aggregation_Aligner {
  /**
   * No alignment. Raw data is returned. Not valid if cross-series reduction
   * is requested. The `value_type` of the result is the same as the
   * `value_type` of the input.
   *
   * @generated from enum value: ALIGN_NONE = 0;
   */
  ALIGN_NONE = 0,

  /**
   * Align and convert to
   * [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
   * The output is `delta = y1 - y0`.
   *
   * This alignment is valid for
   * [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
   * `DELTA` metrics. If the selected alignment period results in periods
   * with no data, then the aligned value for such a period is created by
   * interpolation. The `value_type`  of the aligned result is the same as
   * the `value_type` of the input.
   *
   * @generated from enum value: ALIGN_DELTA = 1;
   */
  ALIGN_DELTA = 1,

  /**
   * Align and convert to a rate. The result is computed as
   * `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
   * Think of this aligner as providing the slope of the line that passes
   * through the value at the start and at the end of the `alignment_period`.
   *
   * This aligner is valid for `CUMULATIVE`
   * and `DELTA` metrics with numeric values. If the selected alignment
   * period results in periods with no data, then the aligned value for
   * such a period is created by interpolation. The output is a `GAUGE`
   * metric with `value_type` `DOUBLE`.
   *
   * If, by "rate", you mean "percentage change", see the
   * `ALIGN_PERCENT_CHANGE` aligner instead.
   *
   * @generated from enum value: ALIGN_RATE = 2;
   */
  ALIGN_RATE = 2,

  /**
   * Align by interpolating between adjacent points around the alignment
   * period boundary. This aligner is valid for `GAUGE` metrics with
   * numeric values. The `value_type` of the aligned result is the same as the
   * `value_type` of the input.
   *
   * @generated from enum value: ALIGN_INTERPOLATE = 3;
   */
  ALIGN_INTERPOLATE = 3,

  /**
   * Align by moving the most recent data point before the end of the
   * alignment period to the boundary at the end of the alignment
   * period. This aligner is valid for `GAUGE` metrics. The `value_type` of
   * the aligned result is the same as the `value_type` of the input.
   *
   * @generated from enum value: ALIGN_NEXT_OLDER = 4;
   */
  ALIGN_NEXT_OLDER = 4,

  /**
   * Align the time series by returning the minimum value in each alignment
   * period. This aligner is valid for `GAUGE` and `DELTA` metrics with
   * numeric values. The `value_type` of the aligned result is the same as
   * the `value_type` of the input.
   *
   * @generated from enum value: ALIGN_MIN = 10;
   */
  ALIGN_MIN = 10,

  /**
   * Align the time series by returning the maximum value in each alignment
   * period. This aligner is valid for `GAUGE` and `DELTA` metrics with
   * numeric values. The `value_type` of the aligned result is the same as
   * the `value_type` of the input.
   *
   * @generated from enum value: ALIGN_MAX = 11;
   */
  ALIGN_MAX = 11,

  /**
   * Align the time series by returning the mean value in each alignment
   * period. This aligner is valid for `GAUGE` and `DELTA` metrics with
   * numeric values. The `value_type` of the aligned result is `DOUBLE`.
   *
   * @generated from enum value: ALIGN_MEAN = 12;
   */
  ALIGN_MEAN = 12,

  /**
   * Align the time series by returning the number of values in each alignment
   * period. This aligner is valid for `GAUGE` and `DELTA` metrics with
   * numeric or Boolean values. The `value_type` of the aligned result is
   * `INT64`.
   *
   * @generated from enum value: ALIGN_COUNT = 13;
   */
  ALIGN_COUNT = 13,

  /**
   * Align the time series by returning the sum of the values in each
   * alignment period. This aligner is valid for `GAUGE` and `DELTA`
   * metrics with numeric and distribution values. The `value_type` of the
   * aligned result is the same as the `value_type` of the input.
   *
   * @generated from enum value: ALIGN_SUM = 14;
   */
  ALIGN_SUM = 14,

  /**
   * Align the time series by returning the standard deviation of the values
   * in each alignment period. This aligner is valid for `GAUGE` and
   * `DELTA` metrics with numeric values. The `value_type` of the output is
   * `DOUBLE`.
   *
   * @generated from enum value: ALIGN_STDDEV = 15;
   */
  ALIGN_STDDEV = 15,

  /**
   * Align the time series by returning the number of `True` values in
   * each alignment period. This aligner is valid for `GAUGE` metrics with
   * Boolean values. The `value_type` of the output is `INT64`.
   *
   * @generated from enum value: ALIGN_COUNT_TRUE = 16;
   */
  ALIGN_COUNT_TRUE = 16,

  /**
   * Align the time series by returning the number of `False` values in
   * each alignment period. This aligner is valid for `GAUGE` metrics with
   * Boolean values. The `value_type` of the output is `INT64`.
   *
   * @generated from enum value: ALIGN_COUNT_FALSE = 24;
   */
  ALIGN_COUNT_FALSE = 24,

  /**
   * Align the time series by returning the ratio of the number of `True`
   * values to the total number of values in each alignment period. This
   * aligner is valid for `GAUGE` metrics with Boolean values. The output
   * value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_FRACTION_TRUE = 17;
   */
  ALIGN_FRACTION_TRUE = 17,

  /**
   * Align the time series by using [percentile
   * aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
   * data point in each alignment period is the 99th percentile of all data
   * points in the period. This aligner is valid for `GAUGE` and `DELTA`
   * metrics with distribution values. The output is a `GAUGE` metric with
   * `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_PERCENTILE_99 = 18;
   */
  ALIGN_PERCENTILE_99 = 18,

  /**
   * Align the time series by using [percentile
   * aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
   * data point in each alignment period is the 95th percentile of all data
   * points in the period. This aligner is valid for `GAUGE` and `DELTA`
   * metrics with distribution values. The output is a `GAUGE` metric with
   * `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_PERCENTILE_95 = 19;
   */
  ALIGN_PERCENTILE_95 = 19,

  /**
   * Align the time series by using [percentile
   * aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
   * data point in each alignment period is the 50th percentile of all data
   * points in the period. This aligner is valid for `GAUGE` and `DELTA`
   * metrics with distribution values. The output is a `GAUGE` metric with
   * `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_PERCENTILE_50 = 20;
   */
  ALIGN_PERCENTILE_50 = 20,

  /**
   * Align the time series by using [percentile
   * aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
   * data point in each alignment period is the 5th percentile of all data
   * points in the period. This aligner is valid for `GAUGE` and `DELTA`
   * metrics with distribution values. The output is a `GAUGE` metric with
   * `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_PERCENTILE_05 = 21;
   */
  ALIGN_PERCENTILE_05 = 21,

  /**
   * Align and convert to a percentage change. This aligner is valid for
   * `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
   * `((current - previous)/previous) * 100`, where the value of `previous` is
   * determined based on the `alignment_period`.
   *
   * If the values of `current` and `previous` are both 0, then the returned
   * value is 0. If only `previous` is 0, the returned value is infinity.
   *
   * A 10-minute moving mean is computed at each point of the alignment period
   * prior to the above calculation to smooth the metric and prevent false
   * positives from very short-lived spikes. The moving mean is only
   * applicable for data whose values are `>= 0`. Any values `< 0` are
   * treated as a missing datapoint, and are ignored. While `DELTA`
   * metrics are accepted by this alignment, special care should be taken that
   * the values for the metric will always be positive. The output is a
   * `GAUGE` metric with `value_type` `DOUBLE`.
   *
   * @generated from enum value: ALIGN_PERCENT_CHANGE = 23;
   */
  ALIGN_PERCENT_CHANGE = 23,
}

/**
 * Describes the enum google.monitoring.dashboard.v1.Aggregation.Aligner.
 */
export const Aggregation_AlignerSchema: GenEnum<Aggregation_Aligner> = /*@__PURE__*/
  enumDesc(file_google_monitoring_dashboard_v1_common, 0, 0);

/**
 * A Reducer operation describes how to aggregate data points from multiple
 * time series into a single time series, where the value of each data point
 * in the resulting series is a function of all the already aligned values in
 * the input time series.
 *
 * @generated from enum google.monitoring.dashboard.v1.Aggregation.Reducer
 */
export enum Aggregation_Reducer {
  /**
   * No cross-time series reduction. The output of the `Aligner` is
   * returned.
   *
   * @generated from enum value: REDUCE_NONE = 0;
   */
  REDUCE_NONE = 0,

  /**
   * Reduce by computing the mean value across time series for each
   * alignment period. This reducer is valid for
   * [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
   * [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
   * numeric or distribution values. The `value_type` of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: REDUCE_MEAN = 1;
   */
  REDUCE_MEAN = 1,

  /**
   * Reduce by computing the minimum value across time series for each
   * alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
   * with numeric values. The `value_type` of the output is the same as the
   * `value_type` of the input.
   *
   * @generated from enum value: REDUCE_MIN = 2;
   */
  REDUCE_MIN = 2,

  /**
   * Reduce by computing the maximum value across time series for each
   * alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
   * with numeric values. The `value_type` of the output is the same as the
   * `value_type` of the input.
   *
   * @generated from enum value: REDUCE_MAX = 3;
   */
  REDUCE_MAX = 3,

  /**
   * Reduce by computing the sum across time series for each
   * alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
   * with numeric and distribution values. The `value_type` of the output is
   * the same as the `value_type` of the input.
   *
   * @generated from enum value: REDUCE_SUM = 4;
   */
  REDUCE_SUM = 4,

  /**
   * Reduce by computing the standard deviation across time series
   * for each alignment period. This reducer is valid for `DELTA` and
   * `GAUGE` metrics with numeric or distribution values. The `value_type`
   * of the output is `DOUBLE`.
   *
   * @generated from enum value: REDUCE_STDDEV = 5;
   */
  REDUCE_STDDEV = 5,

  /**
   * Reduce by computing the number of data points across time series
   * for each alignment period. This reducer is valid for `DELTA` and
   * `GAUGE` metrics of numeric, Boolean, distribution, and string
   * `value_type`. The `value_type` of the output is `INT64`.
   *
   * @generated from enum value: REDUCE_COUNT = 6;
   */
  REDUCE_COUNT = 6,

  /**
   * Reduce by computing the number of `True`-valued data points across time
   * series for each alignment period. This reducer is valid for `DELTA` and
   * `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
   * is `INT64`.
   *
   * @generated from enum value: REDUCE_COUNT_TRUE = 7;
   */
  REDUCE_COUNT_TRUE = 7,

  /**
   * Reduce by computing the number of `False`-valued data points across time
   * series for each alignment period. This reducer is valid for `DELTA` and
   * `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
   * is `INT64`.
   *
   * @generated from enum value: REDUCE_COUNT_FALSE = 15;
   */
  REDUCE_COUNT_FALSE = 15,

  /**
   * Reduce by computing the ratio of the number of `True`-valued data points
   * to the total number of data points for each alignment period. This
   * reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
   * The output value is in the range [0.0, 1.0] and has `value_type`
   * `DOUBLE`.
   *
   * @generated from enum value: REDUCE_FRACTION_TRUE = 8;
   */
  REDUCE_FRACTION_TRUE = 8,

  /**
   * Reduce by computing the [99th
   * percentile](https://en.wikipedia.org/wiki/Percentile) of data points
   * across time series for each alignment period. This reducer is valid for
   * `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
   * of the output is `DOUBLE`.
   *
   * @generated from enum value: REDUCE_PERCENTILE_99 = 9;
   */
  REDUCE_PERCENTILE_99 = 9,

  /**
   * Reduce by computing the [95th
   * percentile](https://en.wikipedia.org/wiki/Percentile) of data points
   * across time series for each alignment period. This reducer is valid for
   * `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
   * of the output is `DOUBLE`.
   *
   * @generated from enum value: REDUCE_PERCENTILE_95 = 10;
   */
  REDUCE_PERCENTILE_95 = 10,

  /**
   * Reduce by computing the [50th
   * percentile](https://en.wikipedia.org/wiki/Percentile) of data points
   * across time series for each alignment period. This reducer is valid for
   * `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
   * of the output is `DOUBLE`.
   *
   * @generated from enum value: REDUCE_PERCENTILE_50 = 11;
   */
  REDUCE_PERCENTILE_50 = 11,

  /**
   * Reduce by computing the [5th
   * percentile](https://en.wikipedia.org/wiki/Percentile) of data points
   * across time series for each alignment period. This reducer is valid for
   * `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
   * of the output is `DOUBLE`.
   *
   * @generated from enum value: REDUCE_PERCENTILE_05 = 12;
   */
  REDUCE_PERCENTILE_05 = 12,
}

/**
 * Describes the enum google.monitoring.dashboard.v1.Aggregation.Reducer.
 */
export const Aggregation_ReducerSchema: GenEnum<Aggregation_Reducer> = /*@__PURE__*/
  enumDesc(file_google_monitoring_dashboard_v1_common, 0, 1);

/**
 * Describes a ranking-based time series filter. Each input time series is
 * ranked with an aligner. The filter will allow up to `num_time_series` time
 * series to pass through it, selecting them based on the relative ranking.
 *
 * For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
 * and `num_time_series` is 3, then the 3 times series with the lowest mean
 * values will pass through the filter.
 *
 * @generated from message google.monitoring.dashboard.v1.PickTimeSeriesFilter
 */
export type PickTimeSeriesFilter = Message<"google.monitoring.dashboard.v1.PickTimeSeriesFilter"> & {
  /**
   * `ranking_method` is applied to each time series independently to produce
   * the value which will be used to compare the time series to other time
   * series.
   *
   * @generated from field: google.monitoring.dashboard.v1.PickTimeSeriesFilter.Method ranking_method = 1;
   */
  rankingMethod: PickTimeSeriesFilter_Method;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @generated from field: int32 num_time_series = 2;
   */
  numTimeSeries: number;

  /**
   * How to use the ranking to select time series that pass through the filter.
   *
   * @generated from field: google.monitoring.dashboard.v1.PickTimeSeriesFilter.Direction direction = 3;
   */
  direction: PickTimeSeriesFilter_Direction;

  /**
   * Select the top N streams/time series within this time interval
   *
   * @generated from field: google.type.Interval interval = 4;
   */
  interval?: Interval;
};

/**
 * Describes the message google.monitoring.dashboard.v1.PickTimeSeriesFilter.
 * Use `create(PickTimeSeriesFilterSchema)` to create a new message.
 */
export const PickTimeSeriesFilterSchema: GenMessage<PickTimeSeriesFilter> = /*@__PURE__*/
  messageDesc(file_google_monitoring_dashboard_v1_common, 1);

/**
 * The value reducers that can be applied to a `PickTimeSeriesFilter`.
 *
 * @generated from enum google.monitoring.dashboard.v1.PickTimeSeriesFilter.Method
 */
export enum PickTimeSeriesFilter_Method {
  /**
   * Not allowed. You must specify a different `Method` if you specify a
   * `PickTimeSeriesFilter`.
   *
   * @generated from enum value: METHOD_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Select the mean of all values.
   *
   * @generated from enum value: METHOD_MEAN = 1;
   */
  MEAN = 1,

  /**
   * Select the maximum value.
   *
   * @generated from enum value: METHOD_MAX = 2;
   */
  MAX = 2,

  /**
   * Select the minimum value.
   *
   * @generated from enum value: METHOD_MIN = 3;
   */
  MIN = 3,

  /**
   * Compute the sum of all values.
   *
   * @generated from enum value: METHOD_SUM = 4;
   */
  SUM = 4,

  /**
   * Select the most recent value.
   *
   * @generated from enum value: METHOD_LATEST = 5;
   */
  LATEST = 5,
}

/**
 * Describes the enum google.monitoring.dashboard.v1.PickTimeSeriesFilter.Method.
 */
export const PickTimeSeriesFilter_MethodSchema: GenEnum<PickTimeSeriesFilter_Method> = /*@__PURE__*/
  enumDesc(file_google_monitoring_dashboard_v1_common, 1, 0);

/**
 * Describes the ranking directions.
 *
 * @generated from enum google.monitoring.dashboard.v1.PickTimeSeriesFilter.Direction
 */
export enum PickTimeSeriesFilter_Direction {
  /**
   * Not allowed. You must specify a different `Direction` if you specify a
   * `PickTimeSeriesFilter`.
   *
   * @generated from enum value: DIRECTION_UNSPECIFIED = 0;
   */
  DIRECTION_UNSPECIFIED = 0,

  /**
   * Pass the highest `num_time_series` ranking inputs.
   *
   * @generated from enum value: TOP = 1;
   */
  TOP = 1,

  /**
   * Pass the lowest `num_time_series` ranking inputs.
   *
   * @generated from enum value: BOTTOM = 2;
   */
  BOTTOM = 2,
}

/**
 * Describes the enum google.monitoring.dashboard.v1.PickTimeSeriesFilter.Direction.
 */
export const PickTimeSeriesFilter_DirectionSchema: GenEnum<PickTimeSeriesFilter_Direction> = /*@__PURE__*/
  enumDesc(file_google_monitoring_dashboard_v1_common, 1, 1);

/**
 * A filter that ranks streams based on their statistical relation to other
 * streams in a request.
 * Note: This field is deprecated and completely ignored by the API.
 *
 * @generated from message google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter
 */
export type StatisticalTimeSeriesFilter = Message<"google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter"> & {
  /**
   * `rankingMethod` is applied to a set of time series, and then the produced
   * value for each individual time series is used to compare a given time
   * series to others.
   * These are methods that cannot be applied stream-by-stream, but rather
   * require the full context of a request to evaluate time series.
   *
   * @generated from field: google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.Method ranking_method = 1;
   */
  rankingMethod: StatisticalTimeSeriesFilter_Method;

  /**
   * How many time series to output.
   *
   * @generated from field: int32 num_time_series = 2;
   */
  numTimeSeries: number;
};

/**
 * Describes the message google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.
 * Use `create(StatisticalTimeSeriesFilterSchema)` to create a new message.
 */
export const StatisticalTimeSeriesFilterSchema: GenMessage<StatisticalTimeSeriesFilter> = /*@__PURE__*/
  messageDesc(file_google_monitoring_dashboard_v1_common, 2);

/**
 * The filter methods that can be applied to a stream.
 *
 * @generated from enum google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.Method
 */
export enum StatisticalTimeSeriesFilter_Method {
  /**
   * Not allowed in well-formed requests.
   *
   * @generated from enum value: METHOD_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Compute the outlier score of each stream.
   *
   * @generated from enum value: METHOD_CLUSTER_OUTLIER = 1;
   */
  CLUSTER_OUTLIER = 1,
}

/**
 * Describes the enum google.monitoring.dashboard.v1.StatisticalTimeSeriesFilter.Method.
 */
export const StatisticalTimeSeriesFilter_MethodSchema: GenEnum<StatisticalTimeSeriesFilter_Method> = /*@__PURE__*/
  enumDesc(file_google_monitoring_dashboard_v1_common, 2, 0);

