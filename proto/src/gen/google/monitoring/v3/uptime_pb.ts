// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/uptime.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import type { MonitoredResource } from "../../api/monitored_resource_pb";
import { file_google_api_monitored_resource } from "../../api/monitored_resource_pb";
import { file_google_api_resource } from "../../api/resource_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/monitoring/v3/uptime.proto.
 */
export const file_google_monitoring_v3_uptime: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvbW9uaXRvcmluZy92My91cHRpbWUucHJvdG8SFGdvb2dsZS5tb25pdG9yaW5nLnYzIuYBCg9JbnRlcm5hbENoZWNrZXISDAoEbmFtZRgBIAEoCRIUCgxkaXNwbGF5X25hbWUYAiABKAkSDwoHbmV0d29yaxgDIAEoCRIQCghnY3Bfem9uZRgEIAEoCRIXCg9wZWVyX3Byb2plY3RfaWQYBiABKAkSOgoFc3RhdGUYByABKA4yKy5nb29nbGUubW9uaXRvcmluZy52My5JbnRlcm5hbENoZWNrZXIuU3RhdGUiMwoFU3RhdGUSDwoLVU5TUEVDSUZJRUQQABIMCghDUkVBVElORxABEgsKB1JVTk5JTkcQAjoCGAEimwIKFlN5bnRoZXRpY01vbml0b3JUYXJnZXQSXwoRY2xvdWRfZnVuY3Rpb25fdjIYASABKAsyQi5nb29nbGUubW9uaXRvcmluZy52My5TeW50aGV0aWNNb25pdG9yVGFyZ2V0LkNsb3VkRnVuY3Rpb25WMlRhcmdldEgAGpUBChVDbG91ZEZ1bmN0aW9uVjJUYXJnZXQSPAoEbmFtZRgBIAEoCUIu4EEC+kEoCiZjbG91ZGZ1bmN0aW9ucy5nb29nbGVhcGlzLmNvbS9GdW5jdGlvbhI+ChJjbG91ZF9ydW5fcmV2aXNpb24YAiABKAsyHS5nb29nbGUuYXBpLk1vbml0b3JlZFJlc291cmNlQgPgQQNCCAoGdGFyZ2V0ItYeChFVcHRpbWVDaGVja0NvbmZpZxIRCgRuYW1lGAEgASgJQgPgQQgSFAoMZGlzcGxheV9uYW1lGAIgASgJEjsKEm1vbml0b3JlZF9yZXNvdXJjZRgDIAEoCzIdLmdvb2dsZS5hcGkuTW9uaXRvcmVkUmVzb3VyY2VIABJPCg5yZXNvdXJjZV9ncm91cBgEIAEoCzI1Lmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLlJlc291cmNlR3JvdXBIABJJChFzeW50aGV0aWNfbW9uaXRvchgVIAEoCzIsLmdvb2dsZS5tb25pdG9yaW5nLnYzLlN5bnRoZXRpY01vbml0b3JUYXJnZXRIABJHCgpodHRwX2NoZWNrGAUgASgLMjEuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuSHR0cENoZWNrSAESRQoJdGNwX2NoZWNrGAYgASgLMjAuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuVGNwQ2hlY2tIARIpCgZwZXJpb2QYByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SKgoHdGltZW91dBgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJQChBjb250ZW50X21hdGNoZXJzGAkgAygLMjYuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuQ29udGVudE1hdGNoZXISSQoMY2hlY2tlcl90eXBlGBEgASgOMjMuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuQ2hlY2tlclR5cGUSQQoQc2VsZWN0ZWRfcmVnaW9ucxgKIAMoDjInLmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNrUmVnaW9uEhcKC2lzX2ludGVybmFsGA8gASgIQgIYARJEChFpbnRlcm5hbF9jaGVja2VycxgOIAMoCzIlLmdvb2dsZS5tb25pdG9yaW5nLnYzLkludGVybmFsQ2hlY2tlckICGAESTAoLdXNlcl9sYWJlbHMYFCADKAsyNy5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5Vc2VyTGFiZWxzRW50cnkaYQoNUmVzb3VyY2VHcm91cBIQCghncm91cF9pZBgBIAEoCRI+Cg1yZXNvdXJjZV90eXBlGAIgASgOMicuZ29vZ2xlLm1vbml0b3JpbmcudjMuR3JvdXBSZXNvdXJjZVR5cGUaIQoKUGluZ0NvbmZpZxITCgtwaW5nc19jb3VudBgBIAEoBRryDAoJSHR0cENoZWNrElcKDnJlcXVlc3RfbWV0aG9kGAggASgOMj8uZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuSHR0cENoZWNrLlJlcXVlc3RNZXRob2QSDwoHdXNlX3NzbBgBIAEoCBIMCgRwYXRoGAIgASgJEgwKBHBvcnQYAyABKAUSWAoJYXV0aF9pbmZvGAQgASgLMkUuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuSHR0cENoZWNrLkJhc2ljQXV0aGVudGljYXRpb24SFAoMbWFza19oZWFkZXJzGAUgASgIEk8KB2hlYWRlcnMYBiADKAsyPi5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5IdHRwQ2hlY2suSGVhZGVyc0VudHJ5ElMKDGNvbnRlbnRfdHlwZRgJIAEoDjI9Lmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLkh0dHBDaGVjay5Db250ZW50VHlwZRIbChNjdXN0b21fY29udGVudF90eXBlGA0gASgJEhQKDHZhbGlkYXRlX3NzbBgHIAEoCBIMCgRib2R5GAogASgMEmwKHmFjY2VwdGVkX3Jlc3BvbnNlX3N0YXR1c19jb2RlcxgLIAMoCzJELmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLkh0dHBDaGVjay5SZXNwb25zZVN0YXR1c0NvZGUSRwoLcGluZ19jb25maWcYDCABKAsyMi5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5QaW5nQ29uZmlnEnQKHHNlcnZpY2VfYWdlbnRfYXV0aGVudGljYXRpb24YDiABKAsyTC5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5IdHRwQ2hlY2suU2VydmljZUFnZW50QXV0aGVudGljYXRpb25IABo5ChNCYXNpY0F1dGhlbnRpY2F0aW9uEhAKCHVzZXJuYW1lGAEgASgJEhAKCHBhc3N3b3JkGAIgASgJGtwCChJSZXNwb25zZVN0YXR1c0NvZGUSFgoMc3RhdHVzX3ZhbHVlGAEgASgFSAASaAoMc3RhdHVzX2NsYXNzGAIgASgOMlAuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuSHR0cENoZWNrLlJlc3BvbnNlU3RhdHVzQ29kZS5TdGF0dXNDbGFzc0gAIrQBCgtTdGF0dXNDbGFzcxIcChhTVEFUVVNfQ0xBU1NfVU5TUEVDSUZJRUQQABIUChBTVEFUVVNfQ0xBU1NfMVhYEGQSFQoQU1RBVFVTX0NMQVNTXzJYWBDIARIVChBTVEFUVVNfQ0xBU1NfM1hYEKwCEhUKEFNUQVRVU19DTEFTU180WFgQkAMSFQoQU1RBVFVTX0NMQVNTXzVYWBD0AxIVChBTVEFUVVNfQ0xBU1NfQU5ZEOgHQg0KC3N0YXR1c19jb2RlGvwBChpTZXJ2aWNlQWdlbnRBdXRoZW50aWNhdGlvbhJ5CgR0eXBlGAEgASgOMmsuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuSHR0cENoZWNrLlNlcnZpY2VBZ2VudEF1dGhlbnRpY2F0aW9uLlNlcnZpY2VBZ2VudEF1dGhlbnRpY2F0aW9uVHlwZSJjCh5TZXJ2aWNlQWdlbnRBdXRoZW50aWNhdGlvblR5cGUSMQotU0VSVklDRV9BR0VOVF9BVVRIRU5USUNBVElPTl9UWVBFX1VOU1BFQ0lGSUVEEAASDgoKT0lEQ19UT0tFThABGi4KDEhlYWRlcnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIjoKDVJlcXVlc3RNZXRob2QSFgoSTUVUSE9EX1VOU1BFQ0lGSUVEEAASBwoDR0VUEAESCAoEUE9TVBACIkcKC0NvbnRlbnRUeXBlEhQKEFRZUEVfVU5TUEVDSUZJRUQQABIPCgtVUkxfRU5DT0RFRBABEhEKDVVTRVJfUFJPVklERUQQAkINCgthdXRoX21ldGhvZBphCghUY3BDaGVjaxIMCgRwb3J0GAEgASgFEkcKC3BpbmdfY29uZmlnGAIgASgLMjIuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuUGluZ0NvbmZpZxrKBQoOQ29udGVudE1hdGNoZXISDwoHY29udGVudBgBIAEoCRJcCgdtYXRjaGVyGAIgASgOMksuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuQ29udGVudE1hdGNoZXIuQ29udGVudE1hdGNoZXJPcHRpb24SYwoRanNvbl9wYXRoX21hdGNoZXIYAyABKAsyRi5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5Db250ZW50TWF0Y2hlci5Kc29uUGF0aE1hdGNoZXJIABr9AQoPSnNvblBhdGhNYXRjaGVyEhEKCWpzb25fcGF0aBgBIAEoCRJyCgxqc29uX21hdGNoZXIYAiABKA4yXC5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5Db250ZW50TWF0Y2hlci5Kc29uUGF0aE1hdGNoZXIuSnNvblBhdGhNYXRjaGVyT3B0aW9uImMKFUpzb25QYXRoTWF0Y2hlck9wdGlvbhIoCiRKU09OX1BBVEhfTUFUQ0hFUl9PUFRJT05fVU5TUEVDSUZJRUQQABIPCgtFWEFDVF9NQVRDSBABEg8KC1JFR0VYX01BVENIEAIiyAEKFENvbnRlbnRNYXRjaGVyT3B0aW9uEiYKIkNPTlRFTlRfTUFUQ0hFUl9PUFRJT05fVU5TUEVDSUZJRUQQABITCg9DT05UQUlOU19TVFJJTkcQARIXChNOT1RfQ09OVEFJTlNfU1RSSU5HEAISEQoNTUFUQ0hFU19SRUdFWBADEhUKEU5PVF9NQVRDSEVTX1JFR0VYEAQSFQoRTUFUQ0hFU19KU09OX1BBVEgQBRIZChVOT1RfTUFUQ0hFU19KU09OX1BBVEgQBkIZChdhZGRpdGlvbmFsX21hdGNoZXJfaW5mbxoxCg9Vc2VyTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJVCgtDaGVja2VyVHlwZRIcChhDSEVDS0VSX1RZUEVfVU5TUEVDSUZJRUQQABIWChJTVEFUSUNfSVBfQ0hFQ0tFUlMQARIQCgxWUENfQ0hFQ0tFUlMQAzrzAepB7wEKK21vbml0b3JpbmcuZ29vZ2xlYXBpcy5jb20vVXB0aW1lQ2hlY2tDb25maWcSO3Byb2plY3RzL3twcm9qZWN0fS91cHRpbWVDaGVja0NvbmZpZ3Mve3VwdGltZV9jaGVja19jb25maWd9EkVvcmdhbml6YXRpb25zL3tvcmdhbml6YXRpb259L3VwdGltZUNoZWNrQ29uZmlncy97dXB0aW1lX2NoZWNrX2NvbmZpZ30SOWZvbGRlcnMve2ZvbGRlcn0vdXB0aW1lQ2hlY2tDb25maWdzL3t1cHRpbWVfY2hlY2tfY29uZmlnfRIBKkIKCghyZXNvdXJjZUIUChJjaGVja19yZXF1ZXN0X3R5cGUibgoNVXB0aW1lQ2hlY2tJcBI3CgZyZWdpb24YASABKA4yJy5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja1JlZ2lvbhIQCghsb2NhdGlvbhgCIAEoCRISCgppcF9hZGRyZXNzGAMgASgJKpUBChFVcHRpbWVDaGVja1JlZ2lvbhIWChJSRUdJT05fVU5TUEVDSUZJRUQQABIHCgNVU0EQARIKCgZFVVJPUEUQAhIRCg1TT1VUSF9BTUVSSUNBEAMSEAoMQVNJQV9QQUNJRklDEAQSDgoKVVNBX09SRUdPThAFEgwKCFVTQV9JT1dBEAYSEAoMVVNBX1ZJUkdJTklBEAcqWwoRR3JvdXBSZXNvdXJjZVR5cGUSHQoZUkVTT1VSQ0VfVFlQRV9VTlNQRUNJRklFRBAAEgwKCElOU1RBTkNFEAESGQoVQVdTX0VMQl9MT0FEX0JBTEFOQ0VSEAJCrwIKGGNvbS5nb29nbGUubW9uaXRvcmluZy52M0ILVXB0aW1lUHJvdG9QAVpBY2xvdWQuZ29vZ2xlLmNvbS9nby9tb25pdG9yaW5nL2FwaXYzL3YyL21vbml0b3JpbmdwYjttb25pdG9yaW5ncGKqAhpHb29nbGUuQ2xvdWQuTW9uaXRvcmluZy5WM8oCGkdvb2dsZVxDbG91ZFxNb25pdG9yaW5nXFYz6gIdR29vZ2xlOjpDbG91ZDo6TW9uaXRvcmluZzo6VjPqQWYKJmNsb3VkZnVuY3Rpb25zLmdvb2dsZWFwaXMuY29tL0Z1bmN0aW9uEjxwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3tsb2NhdGlvbn0vZnVuY3Rpb25zL3tmdW5jdGlvbn1iBnByb3RvMw", [file_google_api_field_behavior, file_google_api_monitored_resource, file_google_api_resource, file_google_protobuf_duration]);

/**
 * An internal checker allows Uptime checks to run on private/internal GCP
 * resources.
 *
 * @generated from message google.monitoring.v3.InternalChecker
 * @deprecated
 */
export type InternalChecker = Message<"google.monitoring.v3.InternalChecker"> & {
  /**
   * A unique resource name for this InternalChecker. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Cloud Monitoring Metrics Scope project for
   * the Uptime check config associated with the internal checker.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The checker's human-readable name. The display name
   * should be unique within a Cloud Monitoring Metrics Scope in order to make
   * it easier to identify; however, uniqueness is not enforced.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
   * internal resource lives (ex: "default").
   *
   * @generated from field: string network = 3;
   */
  network: string;

  /**
   * The GCP zone the Uptime check should egress from. Only respected for
   * internal Uptime checks, where internal_network is specified.
   *
   * @generated from field: string gcp_zone = 4;
   */
  gcpZone: string;

  /**
   * The GCP project ID where the internal checker lives. Not necessary
   * the same as the Metrics Scope project.
   *
   * @generated from field: string peer_project_id = 6;
   */
  peerProjectId: string;

  /**
   * The current operational state of the internal checker.
   *
   * @generated from field: google.monitoring.v3.InternalChecker.State state = 7;
   */
  state: InternalChecker_State;
};

/**
 * Describes the message google.monitoring.v3.InternalChecker.
 * Use `create(InternalCheckerSchema)` to create a new message.
 * @deprecated
 */
export const InternalCheckerSchema: GenMessage<InternalChecker> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 0);

/**
 * Operational states for an internal checker.
 *
 * @generated from enum google.monitoring.v3.InternalChecker.State
 * @deprecated
 */
export enum InternalChecker_State {
  /**
   * An internal checker should never be in the unspecified state.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The checker is being created, provisioned, and configured. A checker in
   * this state can be returned by `ListInternalCheckers` or
   * `GetInternalChecker`, as well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * The checker is running and available for use. A checker in this state
   * can be returned by `ListInternalCheckers` or `GetInternalChecker` as
   * well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   * If a checker is being torn down, it is neither visible nor usable, so
   * there is no "deleting" or "down" state.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,
}

/**
 * Describes the enum google.monitoring.v3.InternalChecker.State.
 * @deprecated
 */
export const InternalChecker_StateSchema: GenEnum<InternalChecker_State> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 0, 0);

/**
 * Describes a Synthetic Monitor to be invoked by Uptime.
 *
 * @generated from message google.monitoring.v3.SyntheticMonitorTarget
 */
export type SyntheticMonitorTarget = Message<"google.monitoring.v3.SyntheticMonitorTarget"> & {
  /**
   * Specifies a Synthetic Monitor's execution stack.
   *
   * @generated from oneof google.monitoring.v3.SyntheticMonitorTarget.target
   */
  target: {
    /**
     * Target a Synthetic Monitor GCFv2 instance.
     *
     * @generated from field: google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target cloud_function_v2 = 1;
     */
    value: SyntheticMonitorTarget_CloudFunctionV2Target;
    case: "cloudFunctionV2";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.SyntheticMonitorTarget.
 * Use `create(SyntheticMonitorTargetSchema)` to create a new message.
 */
export const SyntheticMonitorTargetSchema: GenMessage<SyntheticMonitorTarget> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 1);

/**
 * A Synthetic Monitor deployed to a Cloud Functions V2 instance.
 *
 * @generated from message google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target
 */
export type SyntheticMonitorTarget_CloudFunctionV2Target = Message<"google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target"> & {
  /**
   * Required. Fully qualified GCFv2 resource name
   * i.e. `projects/{project}/locations/{location}/functions/{function}`
   * Required.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The `cloud_run_revision` Monitored Resource associated with
   * the GCFv2. The Synthetic Monitor execution results (metrics, logs, and
   * spans) are reported against this Monitored Resource. This field is output
   * only.
   *
   * @generated from field: google.api.MonitoredResource cloud_run_revision = 2;
   */
  cloudRunRevision?: MonitoredResource;
};

/**
 * Describes the message google.monitoring.v3.SyntheticMonitorTarget.CloudFunctionV2Target.
 * Use `create(SyntheticMonitorTarget_CloudFunctionV2TargetSchema)` to create a new message.
 */
export const SyntheticMonitorTarget_CloudFunctionV2TargetSchema: GenMessage<SyntheticMonitorTarget_CloudFunctionV2Target> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 1, 0);

/**
 * This message configures which resources and services to monitor for
 * availability.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig
 */
export type UptimeCheckConfig = Message<"google.monitoring.v3.UptimeCheckConfig"> & {
  /**
   * Identifier. A unique resource name for this Uptime check configuration. The
   * format is:
   *
   *      projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
   * Uptime check.
   *
   * This field should be omitted when creating the Uptime check configuration;
   * on create, the resource name is assigned by the server and included in the
   * response.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A human-friendly name for the Uptime check configuration. The display name
   * should be unique within a Cloud Monitoring Workspace in order to make it
   * easier to identify; however, uniqueness is not enforced. Required.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * The resource the check is checking. Required.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.resource
   */
  resource: {
    /**
     * The [monitored
     * resource](https://cloud.google.com/monitoring/api/resources) associated
     * with the configuration.
     * The following monitored resource types are valid for this field:
     *   `uptime_url`,
     *   `gce_instance`,
     *   `gae_app`,
     *   `aws_ec2_instance`,
     *   `aws_elb_load_balancer`
     *   `k8s_service`
     *   `servicedirectory_service`
     *   `cloud_run_revision`
     *
     * @generated from field: google.api.MonitoredResource monitored_resource = 3;
     */
    value: MonitoredResource;
    case: "monitoredResource";
  } | {
    /**
     * The group resource associated with the configuration.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.ResourceGroup resource_group = 4;
     */
    value: UptimeCheckConfig_ResourceGroup;
    case: "resourceGroup";
  } | {
    /**
     * Specifies a Synthetic Monitor to invoke.
     *
     * @generated from field: google.monitoring.v3.SyntheticMonitorTarget synthetic_monitor = 21;
     */
    value: SyntheticMonitorTarget;
    case: "syntheticMonitor";
  } | { case: undefined; value?: undefined };

  /**
   * The type of Uptime check request.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.check_request_type
   */
  checkRequestType: {
    /**
     * Contains information needed to make an HTTP or HTTPS check.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck http_check = 5;
     */
    value: UptimeCheckConfig_HttpCheck;
    case: "httpCheck";
  } | {
    /**
     * Contains information needed to make a TCP check.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.TcpCheck tcp_check = 6;
     */
    value: UptimeCheckConfig_TcpCheck;
    case: "tcpCheck";
  } | { case: undefined; value?: undefined };

  /**
   * How often, in seconds, the Uptime check is performed.
   * Currently, the only supported values are `60s` (1 minute), `300s`
   * (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
   * defaults to `60s`.
   *
   * @generated from field: google.protobuf.Duration period = 7;
   */
  period?: Duration;

  /**
   * The maximum amount of time to wait for the request to complete (must be
   * between 1 and 60 seconds). Required.
   *
   * @generated from field: google.protobuf.Duration timeout = 8;
   */
  timeout?: Duration;

  /**
   * The content that is expected to appear in the data returned by the target
   * server against which the check is run.  Currently, only the first entry
   * in the `content_matchers` list is supported, and additional entries will
   * be ignored. This field is optional and should only be specified if a
   * content match is required as part of the/ Uptime check.
   *
   * @generated from field: repeated google.monitoring.v3.UptimeCheckConfig.ContentMatcher content_matchers = 9;
   */
  contentMatchers: UptimeCheckConfig_ContentMatcher[];

  /**
   * The type of checkers to use to execute the Uptime check.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.CheckerType checker_type = 17;
   */
  checkerType: UptimeCheckConfig_CheckerType;

  /**
   * The list of regions from which the check will be run.
   * Some regions contain one location, and others contain more than one.
   * If this field is specified, enough regions must be provided to include a
   * minimum of 3 locations.  Not specifying this field will result in Uptime
   * checks running from all available regions.
   *
   * @generated from field: repeated google.monitoring.v3.UptimeCheckRegion selected_regions = 10;
   */
  selectedRegions: UptimeCheckRegion[];

  /**
   * If this is `true`, then checks are made only from the 'internal_checkers'.
   * If it is `false`, then checks are made only from the 'selected_regions'.
   * It is an error to provide 'selected_regions' when is_internal is `true`,
   * or to provide 'internal_checkers' when is_internal is `false`.
   *
   * @generated from field: bool is_internal = 15 [deprecated = true];
   * @deprecated
   */
  isInternal: boolean;

  /**
   * The internal checkers that this check will egress from. If `is_internal` is
   * `true` and this list is empty, the check will egress from all the
   * InternalCheckers configured for the project that owns this
   * `UptimeCheckConfig`.
   *
   * @generated from field: repeated google.monitoring.v3.InternalChecker internal_checkers = 14 [deprecated = true];
   * @deprecated
   */
  internalCheckers: InternalChecker[];

  /**
   * User-supplied key/value data to be used for organizing and
   * identifying the `UptimeCheckConfig` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   *
   * @generated from field: map<string, string> user_labels = 20;
   */
  userLabels: { [key: string]: string };
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.
 * Use `create(UptimeCheckConfigSchema)` to create a new message.
 */
export const UptimeCheckConfigSchema: GenMessage<UptimeCheckConfig> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2);

/**
 * The resource submessage for group checks. It can be used instead of a
 * monitored resource, when multiple resources are being monitored.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.ResourceGroup
 */
export type UptimeCheckConfig_ResourceGroup = Message<"google.monitoring.v3.UptimeCheckConfig.ResourceGroup"> & {
  /**
   * The group of resources being monitored. Should be only the `[GROUP_ID]`,
   * and not the full-path
   * `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
   *
   * @generated from field: string group_id = 1;
   */
  groupId: string;

  /**
   * The resource type of the group members.
   *
   * @generated from field: google.monitoring.v3.GroupResourceType resource_type = 2;
   */
  resourceType: GroupResourceType;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.ResourceGroup.
 * Use `create(UptimeCheckConfig_ResourceGroupSchema)` to create a new message.
 */
export const UptimeCheckConfig_ResourceGroupSchema: GenMessage<UptimeCheckConfig_ResourceGroup> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 0);

/**
 * Information involved in sending ICMP pings alongside public HTTP/TCP
 * checks. For HTTP, the pings are performed for each part of the redirect
 * chain.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.PingConfig
 */
export type UptimeCheckConfig_PingConfig = Message<"google.monitoring.v3.UptimeCheckConfig.PingConfig"> & {
  /**
   * Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
   *
   * @generated from field: int32 pings_count = 1;
   */
  pingsCount: number;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.PingConfig.
 * Use `create(UptimeCheckConfig_PingConfigSchema)` to create a new message.
 */
export const UptimeCheckConfig_PingConfigSchema: GenMessage<UptimeCheckConfig_PingConfig> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 1);

/**
 * Information involved in an HTTP/HTTPS Uptime check request.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck
 */
export type UptimeCheckConfig_HttpCheck = Message<"google.monitoring.v3.UptimeCheckConfig.HttpCheck"> & {
  /**
   * The HTTP request method to use for the check. If set to
   * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;
   */
  requestMethod: UptimeCheckConfig_HttpCheck_RequestMethod;

  /**
   * If `true`, use HTTPS instead of HTTP to run the check.
   *
   * @generated from field: bool use_ssl = 1;
   */
  useSsl: boolean;

  /**
   * Optional (defaults to "/"). The path to the page against which to run
   * the check. Will be combined with the `host` (specified within the
   * `monitored_resource`) and `port` to construct the full URL. If the
   * provided path does not begin with "/", a "/" will be prepended
   * automatically.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
   * `use_ssl` is `true`). The TCP port on the HTTP server against which to
   * run the check. Will be combined with host (specified within the
   * `monitored_resource`) and `path` to construct the full URL.
   *
   * @generated from field: int32 port = 3;
   */
  port: number;

  /**
   * The authentication information. Optional when creating an HTTP check;
   * defaults to empty.
   * Do not set both `auth_method` and `auth_info`.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;
   */
  authInfo?: UptimeCheckConfig_HttpCheck_BasicAuthentication;

  /**
   * Boolean specifying whether to encrypt the header information.
   * Encryption should be specified for any headers related to authentication
   * that you do not wish to be seen when retrieving the configuration. The
   * server will be responsible for encrypting the headers.
   * On Get/List calls, if `mask_headers` is set to `true` then the headers
   * will be obscured with `******.`
   *
   * @generated from field: bool mask_headers = 5;
   */
  maskHeaders: boolean;

  /**
   * The list of headers to send as part of the Uptime check request.
   * If two headers have the same key and different values, they should
   * be entered as a single header, with the value being a comma-separated
   * list of all the desired values as described at
   * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
   * Entering two separate headers with the same key in a Create call will
   * cause the first to be overwritten by the second.
   * The maximum number of headers allowed is 100.
   *
   * @generated from field: map<string, string> headers = 6;
   */
  headers: { [key: string]: string };

  /**
   * The content type header to use for the check. The following
   * configurations result in errors:
   * 1. Content type is specified in both the `headers` field and the
   * `content_type` field.
   * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
   * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
   * 4. Request method is `POST` and a "Content-Type" header is provided via
   * `headers` field. The `content_type` field should be used instead.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;
   */
  contentType: UptimeCheckConfig_HttpCheck_ContentType;

  /**
   * A user provided content type header to use for the check. The invalid
   * configurations outlined in the `content_type` field apply to
   * `custom_content_type`, as well as the following:
   * 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set.
   * 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not
   * set.
   *
   * @generated from field: string custom_content_type = 13;
   */
  customContentType: string;

  /**
   * Boolean specifying whether to include SSL certificate validation as a
   * part of the Uptime check. Only applies to checks where
   * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
   * setting `validate_ssl` to `true` has no effect.
   *
   * @generated from field: bool validate_ssl = 7;
   */
  validateSsl: boolean;

  /**
   * The request body associated with the HTTP POST request. If `content_type`
   * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
   * provide a `Content-Length` header via the `headers` field or the API will
   * do so. If the `request_method` is `GET` and `body` is not empty, the API
   * will return an error. The maximum byte size is 1 megabyte.
   *
   * Note: If client libraries aren't used (which performs the conversion
   * automatically) base64 encode your `body` data since the field is of
   * `bytes` type.
   *
   * @generated from field: bytes body = 10;
   */
  body: Uint8Array;

  /**
   * If present, the check will only pass if the HTTP response status code is
   * in this set of status codes. If empty, the HTTP status code will only
   * pass if the HTTP status code is 200-299.
   *
   * @generated from field: repeated google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode accepted_response_status_codes = 11;
   */
  acceptedResponseStatusCodes: UptimeCheckConfig_HttpCheck_ResponseStatusCode[];

  /**
   * Contains information needed to add pings to an HTTP check.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.PingConfig ping_config = 12;
   */
  pingConfig?: UptimeCheckConfig_PingConfig;

  /**
   * This field is optional and should be set only by users interested in
   * an authenticated uptime check.
   * Do not set both `auth_method` and `auth_info`.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_method
   */
  authMethod: {
    /**
     * If specified, Uptime will generate and attach an OIDC JWT token for the
     * Monitoring service agent service account as an `Authorization` header
     * in the HTTP request when probing.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication service_agent_authentication = 14;
     */
    value: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication;
    case: "serviceAgentAuthentication";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.HttpCheck.
 * Use `create(UptimeCheckConfig_HttpCheckSchema)` to create a new message.
 */
export const UptimeCheckConfig_HttpCheckSchema: GenMessage<UptimeCheckConfig_HttpCheck> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 2);

/**
 * The authentication parameters to provide to the specified resource or
 * URL that requires a username and password. Currently, only
 * [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
 * supported in Uptime checks.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication
 */
export type UptimeCheckConfig_HttpCheck_BasicAuthentication = Message<"google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication"> & {
  /**
   * The username to use when authenticating with the HTTP server.
   *
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * The password to use when authenticating with the HTTP server.
   *
   * @generated from field: string password = 2;
   */
  password: string;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.
 * Use `create(UptimeCheckConfig_HttpCheck_BasicAuthenticationSchema)` to create a new message.
 */
export const UptimeCheckConfig_HttpCheck_BasicAuthenticationSchema: GenMessage<UptimeCheckConfig_HttpCheck_BasicAuthentication> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 2, 0);

/**
 * A status to accept. Either a status code class like "2xx", or an integer
 * status code like "200".
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode
 */
export type UptimeCheckConfig_HttpCheck_ResponseStatusCode = Message<"google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode"> & {
  /**
   * Either a specific value or a class of status codes.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.status_code
   */
  statusCode: {
    /**
     * A status code to accept.
     *
     * @generated from field: int32 status_value = 1;
     */
    value: number;
    case: "statusValue";
  } | {
    /**
     * A class of status codes to accept.
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.StatusClass status_class = 2;
     */
    value: UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass;
    case: "statusClass";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.
 * Use `create(UptimeCheckConfig_HttpCheck_ResponseStatusCodeSchema)` to create a new message.
 */
export const UptimeCheckConfig_HttpCheck_ResponseStatusCodeSchema: GenMessage<UptimeCheckConfig_HttpCheck_ResponseStatusCode> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 2, 1);

/**
 * An HTTP status code class.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.StatusClass
 */
export enum UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass {
  /**
   * Default value that matches no status codes.
   *
   * @generated from enum value: STATUS_CLASS_UNSPECIFIED = 0;
   */
  STATUS_CLASS_UNSPECIFIED = 0,

  /**
   * The class of status codes between 100 and 199.
   *
   * @generated from enum value: STATUS_CLASS_1XX = 100;
   */
  STATUS_CLASS_1XX = 100,

  /**
   * The class of status codes between 200 and 299.
   *
   * @generated from enum value: STATUS_CLASS_2XX = 200;
   */
  STATUS_CLASS_2XX = 200,

  /**
   * The class of status codes between 300 and 399.
   *
   * @generated from enum value: STATUS_CLASS_3XX = 300;
   */
  STATUS_CLASS_3XX = 300,

  /**
   * The class of status codes between 400 and 499.
   *
   * @generated from enum value: STATUS_CLASS_4XX = 400;
   */
  STATUS_CLASS_4XX = 400,

  /**
   * The class of status codes between 500 and 599.
   *
   * @generated from enum value: STATUS_CLASS_5XX = 500;
   */
  STATUS_CLASS_5XX = 500,

  /**
   * The class of all status codes.
   *
   * @generated from enum value: STATUS_CLASS_ANY = 1000;
   */
  STATUS_CLASS_ANY = 1000,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ResponseStatusCode.StatusClass.
 */
export const UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClassSchema: GenEnum<UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 2, 1, 0);

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * The OIDC token will be generated for the Monitoring service agent service
 * account.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication
 */
export type UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication = Message<"google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication"> & {
  /**
   * Type of authentication.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication.ServiceAgentAuthenticationType type = 1;
   */
  type: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication.
 * Use `create(UptimeCheckConfig_HttpCheck_ServiceAgentAuthenticationSchema)` to create a new message.
 */
export const UptimeCheckConfig_HttpCheck_ServiceAgentAuthenticationSchema: GenMessage<UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 2, 2);

/**
 * Type of authentication.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication.ServiceAgentAuthenticationType
 */
export enum UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType {
  /**
   * Default value, will result in OIDC Authentication.
   *
   * @generated from enum value: SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED = 0;
   */
  SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED = 0,

  /**
   * OIDC Authentication
   *
   * @generated from enum value: OIDC_TOKEN = 1;
   */
  OIDC_TOKEN = 1,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ServiceAgentAuthentication.ServiceAgentAuthenticationType.
 */
export const UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationTypeSchema: GenEnum<UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 2, 2, 0);

/**
 * The HTTP request method options.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod
 */
export enum UptimeCheckConfig_HttpCheck_RequestMethod {
  /**
   * No request method specified.
   *
   * @generated from enum value: METHOD_UNSPECIFIED = 0;
   */
  METHOD_UNSPECIFIED = 0,

  /**
   * GET request.
   *
   * @generated from enum value: GET = 1;
   */
  GET = 1,

  /**
   * POST request.
   *
   * @generated from enum value: POST = 2;
   */
  POST = 2,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod.
 */
export const UptimeCheckConfig_HttpCheck_RequestMethodSchema: GenEnum<UptimeCheckConfig_HttpCheck_RequestMethod> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 2, 0);

/**
 * Header options corresponding to the content type of a HTTP request body.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType
 */
export enum UptimeCheckConfig_HttpCheck_ContentType {
  /**
   * No content type specified.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
   * to `application/x-www-form-urlencoded` in the HTTP request.
   *
   * @generated from enum value: URL_ENCODED = 1;
   */
  URL_ENCODED = 1,

  /**
   * `body` is in `custom_content_type` form. Equivalent to setting the
   * `Content-Type` to the contents of `custom_content_type` in the HTTP
   * request.
   *
   * @generated from enum value: USER_PROVIDED = 2;
   */
  USER_PROVIDED = 2,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType.
 */
export const UptimeCheckConfig_HttpCheck_ContentTypeSchema: GenEnum<UptimeCheckConfig_HttpCheck_ContentType> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 2, 1);

/**
 * Information required for a TCP Uptime check request.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.TcpCheck
 */
export type UptimeCheckConfig_TcpCheck = Message<"google.monitoring.v3.UptimeCheckConfig.TcpCheck"> & {
  /**
   * The TCP port on the server against which to run the check. Will be
   * combined with host (specified within the `monitored_resource`) to
   * construct the full URL. Required.
   *
   * @generated from field: int32 port = 1;
   */
  port: number;

  /**
   * Contains information needed to add pings to a TCP check.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.PingConfig ping_config = 2;
   */
  pingConfig?: UptimeCheckConfig_PingConfig;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.TcpCheck.
 * Use `create(UptimeCheckConfig_TcpCheckSchema)` to create a new message.
 */
export const UptimeCheckConfig_TcpCheckSchema: GenMessage<UptimeCheckConfig_TcpCheck> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 3);

/**
 * Optional. Used to perform content matching. This allows matching based on
 * substrings and regular expressions, together with their negations. Only the
 * first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
 * 1&nbsp;MB of a TCP check's response) are examined for purposes of content
 * matching.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.ContentMatcher
 */
export type UptimeCheckConfig_ContentMatcher = Message<"google.monitoring.v3.UptimeCheckConfig.ContentMatcher"> & {
  /**
   * String, regex or JSON content to match. Maximum 1024 bytes. An empty
   * `content` string indicates no content matching is to be performed.
   *
   * @generated from field: string content = 1;
   */
  content: string;

  /**
   * The type of content matcher that will be applied to the server output,
   * compared to the `content` string when the check is run.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption matcher = 2;
   */
  matcher: UptimeCheckConfig_ContentMatcher_ContentMatcherOption;

  /**
   * Certain `ContentMatcherOption` types require additional information.
   * `MATCHES_JSON_PATH` or `NOT_MATCHES_JSON_PATH` require a
   * `JsonPathMatcher`; not used for other options.
   *
   * @generated from oneof google.monitoring.v3.UptimeCheckConfig.ContentMatcher.additional_matcher_info
   */
  additionalMatcherInfo: {
    /**
     * Matcher information for `MATCHES_JSON_PATH` and `NOT_MATCHES_JSON_PATH`
     *
     * @generated from field: google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher json_path_matcher = 3;
     */
    value: UptimeCheckConfig_ContentMatcher_JsonPathMatcher;
    case: "jsonPathMatcher";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.ContentMatcher.
 * Use `create(UptimeCheckConfig_ContentMatcherSchema)` to create a new message.
 */
export const UptimeCheckConfig_ContentMatcherSchema: GenMessage<UptimeCheckConfig_ContentMatcher> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 4);

/**
 * Information needed to perform a JSONPath content match.
 * Used for `ContentMatcherOption::MATCHES_JSON_PATH` and
 * `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
 *
 * @generated from message google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher
 */
export type UptimeCheckConfig_ContentMatcher_JsonPathMatcher = Message<"google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher"> & {
  /**
   * JSONPath within the response output pointing to the expected
   * `ContentMatcher::content` to match against.
   *
   * @generated from field: string json_path = 1;
   */
  jsonPath: string;

  /**
   * The type of JSONPath match that will be applied to the JSON output
   * (`ContentMatcher.content`)
   *
   * @generated from field: google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher.JsonPathMatcherOption json_matcher = 2;
   */
  jsonMatcher: UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher.
 * Use `create(UptimeCheckConfig_ContentMatcher_JsonPathMatcherSchema)` to create a new message.
 */
export const UptimeCheckConfig_ContentMatcher_JsonPathMatcherSchema: GenMessage<UptimeCheckConfig_ContentMatcher_JsonPathMatcher> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 2, 4, 0);

/**
 * Options to perform JSONPath content matching.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher.JsonPathMatcherOption
 */
export enum UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption {
  /**
   * No JSONPath matcher type specified (not valid).
   *
   * @generated from enum value: JSON_PATH_MATCHER_OPTION_UNSPECIFIED = 0;
   */
  JSON_PATH_MATCHER_OPTION_UNSPECIFIED = 0,

  /**
   * Selects 'exact string' matching. The match succeeds if the content at
   * the `json_path` within the output is exactly the same as the
   * `content` string.
   *
   * @generated from enum value: EXACT_MATCH = 1;
   */
  EXACT_MATCH = 1,

  /**
   * Selects regular-expression matching. The match succeeds if the
   * content at the `json_path` within the output matches the regular
   * expression specified in the `content` string.
   *
   * @generated from enum value: REGEX_MATCH = 2;
   */
  REGEX_MATCH = 2,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.ContentMatcher.JsonPathMatcher.JsonPathMatcherOption.
 */
export const UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOptionSchema: GenEnum<UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 4, 0, 0);

/**
 * Options to perform content matching.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption
 */
export enum UptimeCheckConfig_ContentMatcher_ContentMatcherOption {
  /**
   * No content matcher type specified (maintained for backward
   * compatibility, but deprecated for future use).
   * Treated as `CONTAINS_STRING`.
   *
   * @generated from enum value: CONTENT_MATCHER_OPTION_UNSPECIFIED = 0;
   */
  CONTENT_MATCHER_OPTION_UNSPECIFIED = 0,

  /**
   * Selects substring matching. The match succeeds if the output contains
   * the `content` string.  This is the default value for checks without
   * a `matcher` option, or where the value of `matcher` is
   * `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
   *
   * @generated from enum value: CONTAINS_STRING = 1;
   */
  CONTAINS_STRING = 1,

  /**
   * Selects negation of substring matching. The match succeeds if the
   * output does _NOT_ contain the `content` string.
   *
   * @generated from enum value: NOT_CONTAINS_STRING = 2;
   */
  NOT_CONTAINS_STRING = 2,

  /**
   * Selects regular-expression matching. The match succeeds if the output
   * matches the regular expression specified in the `content` string.
   * Regex matching is only supported for HTTP/HTTPS checks.
   *
   * @generated from enum value: MATCHES_REGEX = 3;
   */
  MATCHES_REGEX = 3,

  /**
   * Selects negation of regular-expression matching. The match succeeds if
   * the output does _NOT_ match the regular expression specified in the
   * `content` string. Regex matching is only supported for HTTP/HTTPS
   * checks.
   *
   * @generated from enum value: NOT_MATCHES_REGEX = 4;
   */
  NOT_MATCHES_REGEX = 4,

  /**
   * Selects JSONPath matching. See `JsonPathMatcher` for details on when
   * the match succeeds. JSONPath matching is only supported for HTTP/HTTPS
   * checks.
   *
   * @generated from enum value: MATCHES_JSON_PATH = 5;
   */
  MATCHES_JSON_PATH = 5,

  /**
   * Selects JSONPath matching. See `JsonPathMatcher` for details on when
   * the match succeeds. Succeeds when output does _NOT_ match as specified.
   * JSONPath is only supported for HTTP/HTTPS checks.
   *
   * @generated from enum value: NOT_MATCHES_JSON_PATH = 6;
   */
  NOT_MATCHES_JSON_PATH = 6,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption.
 */
export const UptimeCheckConfig_ContentMatcher_ContentMatcherOptionSchema: GenEnum<UptimeCheckConfig_ContentMatcher_ContentMatcherOption> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 4, 0);

/**
 * What kind of checkers are available to be used by the check.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckConfig.CheckerType
 */
export enum UptimeCheckConfig_CheckerType {
  /**
   * The default checker type. Currently converted to `STATIC_IP_CHECKERS`
   * on creation, the default conversion behavior may change in the future.
   *
   * @generated from enum value: CHECKER_TYPE_UNSPECIFIED = 0;
   */
  CHECKER_TYPE_UNSPECIFIED = 0,

  /**
   * `STATIC_IP_CHECKERS` are used for uptime checks that perform egress
   * across the public internet. `STATIC_IP_CHECKERS` use the static IP
   * addresses returned by `ListUptimeCheckIps`.
   *
   * @generated from enum value: STATIC_IP_CHECKERS = 1;
   */
  STATIC_IP_CHECKERS = 1,

  /**
   * `VPC_CHECKERS` are used for uptime checks that perform egress using
   * Service Directory and private network access. When using `VPC_CHECKERS`,
   * the monitored resource type must be `servicedirectory_service`.
   *
   * @generated from enum value: VPC_CHECKERS = 3;
   */
  VPC_CHECKERS = 3,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckConfig.CheckerType.
 */
export const UptimeCheckConfig_CheckerTypeSchema: GenEnum<UptimeCheckConfig_CheckerType> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 2, 0);

/**
 * Contains the region, location, and list of IP
 * addresses where checkers in the location run from.
 *
 * @generated from message google.monitoring.v3.UptimeCheckIp
 */
export type UptimeCheckIp = Message<"google.monitoring.v3.UptimeCheckIp"> & {
  /**
   * A broad region category in which the IP address is located.
   *
   * @generated from field: google.monitoring.v3.UptimeCheckRegion region = 1;
   */
  region: UptimeCheckRegion;

  /**
   * A more specific location within the region that typically encodes
   * a particular city/town/metro (and its containing state/province or country)
   * within the broader umbrella region category.
   *
   * @generated from field: string location = 2;
   */
  location: string;

  /**
   * The IP address from which the Uptime check originates. This is a fully
   * specified IP address (not an IP address range). Most IP addresses, as of
   * this publication, are in IPv4 format; however, one should not rely on the
   * IP addresses being in IPv4 format indefinitely, and should support
   * interpreting this field in either IPv4 or IPv6 format.
   *
   * @generated from field: string ip_address = 3;
   */
  ipAddress: string;
};

/**
 * Describes the message google.monitoring.v3.UptimeCheckIp.
 * Use `create(UptimeCheckIpSchema)` to create a new message.
 */
export const UptimeCheckIpSchema: GenMessage<UptimeCheckIp> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_uptime, 3);

/**
 * The regions from which an Uptime check can be run.
 *
 * @generated from enum google.monitoring.v3.UptimeCheckRegion
 */
export enum UptimeCheckRegion {
  /**
   * Default value if no region is specified. Will result in Uptime checks
   * running from all regions.
   *
   * @generated from enum value: REGION_UNSPECIFIED = 0;
   */
  REGION_UNSPECIFIED = 0,

  /**
   * Allows checks to run from locations within the United States of America.
   *
   * @generated from enum value: USA = 1;
   */
  USA = 1,

  /**
   * Allows checks to run from locations within the continent of Europe.
   *
   * @generated from enum value: EUROPE = 2;
   */
  EUROPE = 2,

  /**
   * Allows checks to run from locations within the continent of South
   * America.
   *
   * @generated from enum value: SOUTH_AMERICA = 3;
   */
  SOUTH_AMERICA = 3,

  /**
   * Allows checks to run from locations within the Asia Pacific area (ex:
   * Singapore).
   *
   * @generated from enum value: ASIA_PACIFIC = 4;
   */
  ASIA_PACIFIC = 4,

  /**
   * Allows checks to run from locations within the western United States of
   * America
   *
   * @generated from enum value: USA_OREGON = 5;
   */
  USA_OREGON = 5,

  /**
   * Allows checks to run from locations within the central United States of
   * America
   *
   * @generated from enum value: USA_IOWA = 6;
   */
  USA_IOWA = 6,

  /**
   * Allows checks to run from locations within the eastern United States of
   * America
   *
   * @generated from enum value: USA_VIRGINIA = 7;
   */
  USA_VIRGINIA = 7,
}

/**
 * Describes the enum google.monitoring.v3.UptimeCheckRegion.
 */
export const UptimeCheckRegionSchema: GenEnum<UptimeCheckRegion> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 0);

/**
 * The supported resource types that can be used as values of
 * `group_resource.resource_type`.
 * `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
 * The resource types `gae_app` and `uptime_url` are not valid here because
 * group checks on App Engine modules and URLs are not allowed.
 *
 * @generated from enum google.monitoring.v3.GroupResourceType
 */
export enum GroupResourceType {
  /**
   * Default value (not valid).
   *
   * @generated from enum value: RESOURCE_TYPE_UNSPECIFIED = 0;
   */
  RESOURCE_TYPE_UNSPECIFIED = 0,

  /**
   * A group of instances from Google Cloud Platform (GCP) or
   * Amazon Web Services (AWS).
   *
   * @generated from enum value: INSTANCE = 1;
   */
  INSTANCE = 1,

  /**
   * A group of Amazon ELB load balancers.
   *
   * @generated from enum value: AWS_ELB_LOAD_BALANCER = 2;
   */
  AWS_ELB_LOAD_BALANCER = 2,
}

/**
 * Describes the enum google.monitoring.v3.GroupResourceType.
 */
export const GroupResourceTypeSchema: GenEnum<GroupResourceType> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_uptime, 1);

