// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/metric.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { LabelDescriptor } from "../../api/label_pb";
import { file_google_api_label } from "../../api/label_pb";
import type { Metric, MetricDescriptor_MetricKind, MetricDescriptor_ValueType } from "../../api/metric_pb";
import { file_google_api_metric } from "../../api/metric_pb";
import type { MonitoredResource, MonitoredResourceMetadata } from "../../api/monitored_resource_pb";
import { file_google_api_monitored_resource } from "../../api/monitored_resource_pb";
import type { TimeInterval, TypedValue } from "./common_pb";
import { file_google_monitoring_v3_common } from "./common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/monitoring/v3/metric.proto.
 */
export const file_google_monitoring_v3_metric: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvbW9uaXRvcmluZy92My9tZXRyaWMucHJvdG8SFGdvb2dsZS5tb25pdG9yaW5nLnYzIm4KBVBvaW50EjQKCGludGVydmFsGAEgASgLMiIuZ29vZ2xlLm1vbml0b3JpbmcudjMuVGltZUludGVydmFsEi8KBXZhbHVlGAIgASgLMiAuZ29vZ2xlLm1vbml0b3JpbmcudjMuVHlwZWRWYWx1ZSLPAgoKVGltZVNlcmllcxIiCgZtZXRyaWMYASABKAsyEi5nb29nbGUuYXBpLk1ldHJpYxIvCghyZXNvdXJjZRgCIAEoCzIdLmdvb2dsZS5hcGkuTW9uaXRvcmVkUmVzb3VyY2USNwoIbWV0YWRhdGEYByABKAsyJS5nb29nbGUuYXBpLk1vbml0b3JlZFJlc291cmNlTWV0YWRhdGESPAoLbWV0cmljX2tpbmQYAyABKA4yJy5nb29nbGUuYXBpLk1ldHJpY0Rlc2NyaXB0b3IuTWV0cmljS2luZBI6Cgp2YWx1ZV90eXBlGAQgASgOMiYuZ29vZ2xlLmFwaS5NZXRyaWNEZXNjcmlwdG9yLlZhbHVlVHlwZRIrCgZwb2ludHMYBSADKAsyGy5nb29nbGUubW9uaXRvcmluZy52My5Qb2ludBIMCgR1bml0GAggASgJIs4CChRUaW1lU2VyaWVzRGVzY3JpcHRvchI2ChFsYWJlbF9kZXNjcmlwdG9ycxgBIAMoCzIbLmdvb2dsZS5hcGkuTGFiZWxEZXNjcmlwdG9yElUKEXBvaW50X2Rlc2NyaXB0b3JzGAUgAygLMjouZ29vZ2xlLm1vbml0b3JpbmcudjMuVGltZVNlcmllc0Rlc2NyaXB0b3IuVmFsdWVEZXNjcmlwdG9yGqYBCg9WYWx1ZURlc2NyaXB0b3ISCwoDa2V5GAEgASgJEjoKCnZhbHVlX3R5cGUYAiABKA4yJi5nb29nbGUuYXBpLk1ldHJpY0Rlc2NyaXB0b3IuVmFsdWVUeXBlEjwKC21ldHJpY19raW5kGAMgASgOMicuZ29vZ2xlLmFwaS5NZXRyaWNEZXNjcmlwdG9yLk1ldHJpY0tpbmQSDAoEdW5pdBgEIAEoCSKGAgoOVGltZVNlcmllc0RhdGESNgoMbGFiZWxfdmFsdWVzGAEgAygLMiAuZ29vZ2xlLm1vbml0b3JpbmcudjMuTGFiZWxWYWx1ZRJCCgpwb2ludF9kYXRhGAIgAygLMi4uZ29vZ2xlLm1vbml0b3JpbmcudjMuVGltZVNlcmllc0RhdGEuUG9pbnREYXRhGngKCVBvaW50RGF0YRIwCgZ2YWx1ZXMYASADKAsyIC5nb29nbGUubW9uaXRvcmluZy52My5UeXBlZFZhbHVlEjkKDXRpbWVfaW50ZXJ2YWwYAiABKAsyIi5nb29nbGUubW9uaXRvcmluZy52My5UaW1lSW50ZXJ2YWwiWgoKTGFiZWxWYWx1ZRIUCgpib29sX3ZhbHVlGAEgASgISAASFQoLaW50NjRfdmFsdWUYAiABKANIABIWCgxzdHJpbmdfdmFsdWUYAyABKAlIAEIHCgV2YWx1ZSJRCgpRdWVyeUVycm9yEjIKB2xvY2F0b3IYASABKAsyIS5nb29nbGUubW9uaXRvcmluZy52My5UZXh0TG9jYXRvchIPCgdtZXNzYWdlGAIgASgJIqACCgtUZXh0TG9jYXRvchIOCgZzb3VyY2UYASABKAkSQgoOc3RhcnRfcG9zaXRpb24YAiABKAsyKi5nb29nbGUubW9uaXRvcmluZy52My5UZXh0TG9jYXRvci5Qb3NpdGlvbhJACgxlbmRfcG9zaXRpb24YAyABKAsyKi5nb29nbGUubW9uaXRvcmluZy52My5UZXh0TG9jYXRvci5Qb3NpdGlvbhI5Cg5uZXN0ZWRfbG9jYXRvchgEIAEoCzIhLmdvb2dsZS5tb25pdG9yaW5nLnYzLlRleHRMb2NhdG9yEhYKDm5lc3RpbmdfcmVhc29uGAUgASgJGigKCFBvc2l0aW9uEgwKBGxpbmUYASABKAUSDgoGY29sdW1uGAIgASgFQsYBChhjb20uZ29vZ2xlLm1vbml0b3JpbmcudjNCC01ldHJpY1Byb3RvUAFaQWNsb3VkLmdvb2dsZS5jb20vZ28vbW9uaXRvcmluZy9hcGl2My92Mi9tb25pdG9yaW5ncGI7bW9uaXRvcmluZ3BiqgIaR29vZ2xlLkNsb3VkLk1vbml0b3JpbmcuVjPKAhpHb29nbGVcQ2xvdWRcTW9uaXRvcmluZ1xWM+oCHUdvb2dsZTo6Q2xvdWQ6Ok1vbml0b3Jpbmc6OlYzYgZwcm90bzM", [file_google_api_label, file_google_api_metric, file_google_api_monitored_resource, file_google_monitoring_v3_common]);

/**
 * A single data point in a time series.
 *
 * @generated from message google.monitoring.v3.Point
 */
export type Point = Message<"google.monitoring.v3.Point"> & {
  /**
   * The time interval to which the data point applies.  For `GAUGE` metrics,
   * the start time is optional, but if it is supplied, it must equal the
   * end time.  For `DELTA` metrics, the start
   * and end time should specify a non-zero interval, with subsequent points
   * specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
   * metrics, the start and end time should specify a non-zero interval, with
   * subsequent points specifying the same start time and increasing end times,
   * until an event resets the cumulative value to zero and sets a new start
   * time for the following points.
   *
   * @generated from field: google.monitoring.v3.TimeInterval interval = 1;
   */
  interval?: TimeInterval;

  /**
   * The value of the data point.
   *
   * @generated from field: google.monitoring.v3.TypedValue value = 2;
   */
  value?: TypedValue;
};

/**
 * Describes the message google.monitoring.v3.Point.
 * Use `create(PointSchema)` to create a new message.
 */
export const PointSchema: GenMessage<Point> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 0);

/**
 * A collection of data points that describes the time-varying values
 * of a metric. A time series is identified by a combination of a
 * fully-specified monitored resource and a fully-specified metric.
 * This type is used for both listing and creating time series.
 *
 * @generated from message google.monitoring.v3.TimeSeries
 */
export type TimeSeries = Message<"google.monitoring.v3.TimeSeries"> & {
  /**
   * The associated metric. A fully-specified metric used to identify the time
   * series.
   *
   * @generated from field: google.api.Metric metric = 1;
   */
  metric?: Metric;

  /**
   * The associated monitored resource.  Custom metrics can use only certain
   * monitored resource types in their time series data. For more information,
   * see [Monitored resources for custom
   * metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
   *
   * @generated from field: google.api.MonitoredResource resource = 2;
   */
  resource?: MonitoredResource;

  /**
   * Output only. The associated monitored resource metadata. When reading a
   * time series, this field will include metadata labels that are explicitly
   * named in the reduction. When creating a time series, this field is ignored.
   *
   * @generated from field: google.api.MonitoredResourceMetadata metadata = 7;
   */
  metadata?: MonitoredResourceMetadata;

  /**
   * The metric kind of the time series. When listing time series, this metric
   * kind might be different from the metric kind of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the metric kind of the associated metric. If the associated
   * metric's descriptor must be auto-created, then this field specifies the
   * metric kind of the new descriptor and must be either `GAUGE` (the default)
   * or `CUMULATIVE`.
   *
   * @generated from field: google.api.MetricDescriptor.MetricKind metric_kind = 3;
   */
  metricKind: MetricDescriptor_MetricKind;

  /**
   * The value type of the time series. When listing time series, this value
   * type might be different from the value type of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the type of the data in the `points` field.
   *
   * @generated from field: google.api.MetricDescriptor.ValueType value_type = 4;
   */
  valueType: MetricDescriptor_ValueType;

  /**
   * The data points of this time series. When listing time series, points are
   * returned in reverse time order.
   *
   * When creating a time series, this field must contain exactly one point and
   * the point's type must be the same as the value type of the associated
   * metric. If the associated metric's descriptor must be auto-created, then
   * the value type of the descriptor is determined by the point's type, which
   * must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
   *
   * @generated from field: repeated google.monitoring.v3.Point points = 5;
   */
  points: Point[];

  /**
   * The units in which the metric value is reported. It is only applicable
   * if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
   * defines the representation of the stored metric values.
   *
   * @generated from field: string unit = 8;
   */
  unit: string;
};

/**
 * Describes the message google.monitoring.v3.TimeSeries.
 * Use `create(TimeSeriesSchema)` to create a new message.
 */
export const TimeSeriesSchema: GenMessage<TimeSeries> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 1);

/**
 * A descriptor for the labels and points in a time series.
 *
 * @generated from message google.monitoring.v3.TimeSeriesDescriptor
 */
export type TimeSeriesDescriptor = Message<"google.monitoring.v3.TimeSeriesDescriptor"> & {
  /**
   * Descriptors for the labels.
   *
   * @generated from field: repeated google.api.LabelDescriptor label_descriptors = 1;
   */
  labelDescriptors: LabelDescriptor[];

  /**
   * Descriptors for the point data value columns.
   *
   * @generated from field: repeated google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor point_descriptors = 5;
   */
  pointDescriptors: TimeSeriesDescriptor_ValueDescriptor[];
};

/**
 * Describes the message google.monitoring.v3.TimeSeriesDescriptor.
 * Use `create(TimeSeriesDescriptorSchema)` to create a new message.
 */
export const TimeSeriesDescriptorSchema: GenMessage<TimeSeriesDescriptor> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 2);

/**
 * A descriptor for the value columns in a data point.
 *
 * @generated from message google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor
 */
export type TimeSeriesDescriptor_ValueDescriptor = Message<"google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor"> & {
  /**
   * The value key.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The value type.
   *
   * @generated from field: google.api.MetricDescriptor.ValueType value_type = 2;
   */
  valueType: MetricDescriptor_ValueType;

  /**
   * The value stream kind.
   *
   * @generated from field: google.api.MetricDescriptor.MetricKind metric_kind = 3;
   */
  metricKind: MetricDescriptor_MetricKind;

  /**
   * The unit in which `time_series` point values are reported. `unit`
   * follows the UCUM format for units as seen in
   * https://unitsofmeasure.org/ucum.html.
   * `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
   *
   * @generated from field: string unit = 4;
   */
  unit: string;
};

/**
 * Describes the message google.monitoring.v3.TimeSeriesDescriptor.ValueDescriptor.
 * Use `create(TimeSeriesDescriptor_ValueDescriptorSchema)` to create a new message.
 */
export const TimeSeriesDescriptor_ValueDescriptorSchema: GenMessage<TimeSeriesDescriptor_ValueDescriptor> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 2, 0);

/**
 * Represents the values of a time series associated with a
 * TimeSeriesDescriptor.
 *
 * @generated from message google.monitoring.v3.TimeSeriesData
 */
export type TimeSeriesData = Message<"google.monitoring.v3.TimeSeriesData"> & {
  /**
   * The values of the labels in the time series identifier, given in the same
   * order as the `label_descriptors` field of the TimeSeriesDescriptor
   * associated with this object. Each value must have a value of the type
   * given in the corresponding entry of `label_descriptors`.
   *
   * @generated from field: repeated google.monitoring.v3.LabelValue label_values = 1;
   */
  labelValues: LabelValue[];

  /**
   * The points in the time series.
   *
   * @generated from field: repeated google.monitoring.v3.TimeSeriesData.PointData point_data = 2;
   */
  pointData: TimeSeriesData_PointData[];
};

/**
 * Describes the message google.monitoring.v3.TimeSeriesData.
 * Use `create(TimeSeriesDataSchema)` to create a new message.
 */
export const TimeSeriesDataSchema: GenMessage<TimeSeriesData> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 3);

/**
 * A point's value columns and time interval. Each point has one or more
 * point values corresponding to the entries in `point_descriptors` field in
 * the TimeSeriesDescriptor associated with this object.
 *
 * @generated from message google.monitoring.v3.TimeSeriesData.PointData
 */
export type TimeSeriesData_PointData = Message<"google.monitoring.v3.TimeSeriesData.PointData"> & {
  /**
   * The values that make up the point.
   *
   * @generated from field: repeated google.monitoring.v3.TypedValue values = 1;
   */
  values: TypedValue[];

  /**
   * The time interval associated with the point.
   *
   * @generated from field: google.monitoring.v3.TimeInterval time_interval = 2;
   */
  timeInterval?: TimeInterval;
};

/**
 * Describes the message google.monitoring.v3.TimeSeriesData.PointData.
 * Use `create(TimeSeriesData_PointDataSchema)` to create a new message.
 */
export const TimeSeriesData_PointDataSchema: GenMessage<TimeSeriesData_PointData> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 3, 0);

/**
 * A label value.
 *
 * @generated from message google.monitoring.v3.LabelValue
 */
export type LabelValue = Message<"google.monitoring.v3.LabelValue"> & {
  /**
   * The label value can be a bool, int64, or string.
   *
   * @generated from oneof google.monitoring.v3.LabelValue.value
   */
  value: {
    /**
     * A bool label value.
     *
     * @generated from field: bool bool_value = 1;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * An int64 label value.
     *
     * @generated from field: int64 int64_value = 2;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * A string label value.
     *
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.LabelValue.
 * Use `create(LabelValueSchema)` to create a new message.
 */
export const LabelValueSchema: GenMessage<LabelValue> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 4);

/**
 * An error associated with a query in the time series query language format.
 *
 * @generated from message google.monitoring.v3.QueryError
 */
export type QueryError = Message<"google.monitoring.v3.QueryError"> & {
  /**
   * The location of the time series query language text that this error applies
   * to.
   *
   * @generated from field: google.monitoring.v3.TextLocator locator = 1;
   */
  locator?: TextLocator;

  /**
   * The error message.
   *
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message google.monitoring.v3.QueryError.
 * Use `create(QueryErrorSchema)` to create a new message.
 */
export const QueryErrorSchema: GenMessage<QueryError> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 5);

/**
 * A locator for text. Indicates a particular part of the text of a request or
 * of an object referenced in the request.
 *
 * For example, suppose the request field `text` contains:
 *
 *   text: "The quick brown fox jumps over the lazy dog."
 *
 * Then the locator:
 *
 *   source: "text"
 *   start_position {
 *     line: 1
 *     column: 17
 *   }
 *   end_position {
 *     line: 1
 *     column: 19
 *   }
 *
 * refers to the part of the text: "fox".
 *
 * @generated from message google.monitoring.v3.TextLocator
 */
export type TextLocator = Message<"google.monitoring.v3.TextLocator"> & {
  /**
   * The source of the text. The source may be a field in the request, in which
   * case its format is the format of the
   * google.rpc.BadRequest.FieldViolation.field field in
   * https://cloud.google.com/apis/design/errors#error_details. It may also be
   * be a source other than the request field (e.g. a macro definition
   * referenced in the text of the query), in which case this is the name of
   * the source (e.g. the macro name).
   *
   * @generated from field: string source = 1;
   */
  source: string;

  /**
   * The position of the first byte within the text.
   *
   * @generated from field: google.monitoring.v3.TextLocator.Position start_position = 2;
   */
  startPosition?: TextLocator_Position;

  /**
   * The position of the last byte within the text.
   *
   * @generated from field: google.monitoring.v3.TextLocator.Position end_position = 3;
   */
  endPosition?: TextLocator_Position;

  /**
   * If `source`, `start_position`, and `end_position` describe a call on
   * some object (e.g. a macro in the time series query language text) and a
   * location is to be designated in that object's text, `nested_locator`
   * identifies the location within that object.
   *
   * @generated from field: google.monitoring.v3.TextLocator nested_locator = 4;
   */
  nestedLocator?: TextLocator;

  /**
   * When `nested_locator` is set, this field gives the reason for the nesting.
   * Usually, the reason is a macro invocation. In that case, the macro name
   * (including the leading '@') signals the location of the macro call
   * in the text and a macro argument name (including the leading '$') signals
   * the location of the macro argument inside the macro body that got
   * substituted away.
   *
   * @generated from field: string nesting_reason = 5;
   */
  nestingReason: string;
};

/**
 * Describes the message google.monitoring.v3.TextLocator.
 * Use `create(TextLocatorSchema)` to create a new message.
 */
export const TextLocatorSchema: GenMessage<TextLocator> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 6);

/**
 * The position of a byte within the text.
 *
 * @generated from message google.monitoring.v3.TextLocator.Position
 */
export type TextLocator_Position = Message<"google.monitoring.v3.TextLocator.Position"> & {
  /**
   * The line, starting with 1, where the byte is positioned.
   *
   * @generated from field: int32 line = 1;
   */
  line: number;

  /**
   * The column within the line, starting with 1, where the byte is
   * positioned. This is a byte index even though the text is UTF-8.
   *
   * @generated from field: int32 column = 2;
   */
  column: number;
};

/**
 * Describes the message google.monitoring.v3.TextLocator.Position.
 * Use `create(TextLocator_PositionSchema)` to create a new message.
 */
export const TextLocator_PositionSchema: GenMessage<TextLocator_Position> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_metric, 6, 0);

