// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/alert.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import { file_google_api_resource } from "../../api/resource_pb";
import type { Aggregation, ComparisonType } from "./common_pb";
import { file_google_monitoring_v3_common } from "./common_pb";
import type { MutationRecord } from "./mutation_record_pb";
import { file_google_monitoring_v3_mutation_record } from "./mutation_record_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/monitoring/v3/alert.proto.
 */
export const file_google_monitoring_v3_alert: GenFile = /*@__PURE__*/
  fileDesc("CiBnb29nbGUvbW9uaXRvcmluZy92My9hbGVydC5wcm90bxIUZ29vZ2xlLm1vbml0b3JpbmcudjMijCQKC0FsZXJ0UG9saWN5EgwKBG5hbWUYASABKAkSFAoMZGlzcGxheV9uYW1lGAIgASgJEkYKDWRvY3VtZW50YXRpb24YDSABKAsyLy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Eb2N1bWVudGF0aW9uEkYKC3VzZXJfbGFiZWxzGBAgAygLMjEuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuVXNlckxhYmVsc0VudHJ5Ej8KCmNvbmRpdGlvbnMYDCADKAsyKy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24SSQoIY29tYmluZXIYBiABKA4yNy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb25Db21iaW5lclR5cGUSKwoHZW5hYmxlZBgRIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSJAoIdmFsaWRpdHkYEiABKAsyEi5nb29nbGUucnBjLlN0YXR1cxIdChVub3RpZmljYXRpb25fY2hhbm5lbHMYDiADKAkSPQoPY3JlYXRpb25fcmVjb3JkGAogASgLMiQuZ29vZ2xlLm1vbml0b3JpbmcudjMuTXV0YXRpb25SZWNvcmQSPQoPbXV0YXRpb25fcmVjb3JkGAsgASgLMiQuZ29vZ2xlLm1vbml0b3JpbmcudjMuTXV0YXRpb25SZWNvcmQSRwoOYWxlcnRfc3RyYXRlZ3kYFSABKAsyLy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5BbGVydFN0cmF0ZWd5EkEKCHNldmVyaXR5GBYgASgOMiouZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuU2V2ZXJpdHlCA+BBARq+AQoNRG9jdW1lbnRhdGlvbhIPCgdjb250ZW50GAEgASgJEhEKCW1pbWVfdHlwZRgCIAEoCRIUCgdzdWJqZWN0GAMgASgJQgPgQQESSAoFbGlua3MYBCADKAsyNC5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Eb2N1bWVudGF0aW9uLkxpbmtCA+BBARopCgRMaW5rEhQKDGRpc3BsYXlfbmFtZRgBIAEoCRILCgN1cmwYAiABKAka9xUKCUNvbmRpdGlvbhIMCgRuYW1lGAwgASgJEhQKDGRpc3BsYXlfbmFtZRgGIAEoCRJaChNjb25kaXRpb25fdGhyZXNob2xkGAEgASgLMjsuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuQ29uZGl0aW9uLk1ldHJpY1RocmVzaG9sZEgAElUKEGNvbmRpdGlvbl9hYnNlbnQYAiABKAsyOS5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uTWV0cmljQWJzZW5jZUgAElUKFWNvbmRpdGlvbl9tYXRjaGVkX2xvZxgUIAEoCzI0Lmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5Mb2dNYXRjaEgAEnsKI2NvbmRpdGlvbl9tb25pdG9yaW5nX3F1ZXJ5X2xhbmd1YWdlGBMgASgLMkwuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuQ29uZGl0aW9uLk1vbml0b3JpbmdRdWVyeUxhbmd1YWdlQ29uZGl0aW9uSAASewojY29uZGl0aW9uX3Byb21ldGhldXNfcXVlcnlfbGFuZ3VhZ2UYFSABKAsyTC5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uUHJvbWV0aGV1c1F1ZXJ5TGFuZ3VhZ2VDb25kaXRpb25IABo1CgdUcmlnZ2VyEg8KBWNvdW50GAEgASgFSAASEQoHcGVyY2VudBgCIAEoAUgAQgYKBHR5cGUangUKD01ldHJpY1RocmVzaG9sZBITCgZmaWx0ZXIYAiABKAlCA+BBAhI3CgxhZ2dyZWdhdGlvbnMYCCADKAsyIS5nb29nbGUubW9uaXRvcmluZy52My5BZ2dyZWdhdGlvbhIaChJkZW5vbWluYXRvcl9maWx0ZXIYCSABKAkSQwoYZGVub21pbmF0b3JfYWdncmVnYXRpb25zGAogAygLMiEuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWdncmVnYXRpb24SZQoQZm9yZWNhc3Rfb3B0aW9ucxgMIAEoCzJLLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5NZXRyaWNUaHJlc2hvbGQuRm9yZWNhc3RPcHRpb25zEjgKCmNvbXBhcmlzb24YBCABKA4yJC5nb29nbGUubW9uaXRvcmluZy52My5Db21wYXJpc29uVHlwZRIXCg90aHJlc2hvbGRfdmFsdWUYBSABKAESKwoIZHVyYXRpb24YBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRAoHdHJpZ2dlchgHIAEoCzIzLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5UcmlnZ2VyEmIKF2V2YWx1YXRpb25fbWlzc2luZ19kYXRhGAsgASgOMkEuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuQ29uZGl0aW9uLkV2YWx1YXRpb25NaXNzaW5nRGF0YRpLCg9Gb3JlY2FzdE9wdGlvbnMSOAoQZm9yZWNhc3RfaG9yaXpvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EECGtABCg1NZXRyaWNBYnNlbmNlEhMKBmZpbHRlchgBIAEoCUID4EECEjcKDGFnZ3JlZ2F0aW9ucxgFIAMoCzIhLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFnZ3JlZ2F0aW9uEisKCGR1cmF0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkQKB3RyaWdnZXIYAyABKAsyMy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uVHJpZ2dlchq8AQoITG9nTWF0Y2gSEwoGZmlsdGVyGAEgASgJQgPgQQISYwoQbGFiZWxfZXh0cmFjdG9ycxgCIAMoCzJJLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5Mb2dNYXRjaC5MYWJlbEV4dHJhY3RvcnNFbnRyeRo2ChRMYWJlbEV4dHJhY3RvcnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGogCCiBNb25pdG9yaW5nUXVlcnlMYW5ndWFnZUNvbmRpdGlvbhINCgVxdWVyeRgBIAEoCRIrCghkdXJhdGlvbhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJECgd0cmlnZ2VyGAMgASgLMjMuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWxlcnRQb2xpY3kuQ29uZGl0aW9uLlRyaWdnZXISYgoXZXZhbHVhdGlvbl9taXNzaW5nX2RhdGEYBCABKA4yQS5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5Db25kaXRpb24uRXZhbHVhdGlvbk1pc3NpbmdEYXRhGvUCCiBQcm9tZXRoZXVzUXVlcnlMYW5ndWFnZUNvbmRpdGlvbhISCgVxdWVyeRgBIAEoCUID4EECEjAKCGR1cmF0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgPgQQESOwoTZXZhbHVhdGlvbl9pbnRlcnZhbBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBEm0KBmxhYmVscxgEIAMoCzJYLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkNvbmRpdGlvbi5Qcm9tZXRoZXVzUXVlcnlMYW5ndWFnZUNvbmRpdGlvbi5MYWJlbHNFbnRyeUID4EEBEhcKCnJ1bGVfZ3JvdXAYBSABKAlCA+BBARIXCgphbGVydF9ydWxlGAYgASgJQgPgQQEaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKtAQoVRXZhbHVhdGlvbk1pc3NpbmdEYXRhEicKI0VWQUxVQVRJT05fTUlTU0lOR19EQVRBX1VOU1BFQ0lGSUVEEAASJAogRVZBTFVBVElPTl9NSVNTSU5HX0RBVEFfSU5BQ1RJVkUQARIiCh5FVkFMVUFUSU9OX01JU1NJTkdfREFUQV9BQ1RJVkUQAhIhCh1FVkFMVUFUSU9OX01JU1NJTkdfREFUQV9OT19PUBADOpcC6kGTAgoubW9uaXRvcmluZy5nb29nbGVhcGlzLmNvbS9BbGVydFBvbGljeUNvbmRpdGlvbhJGcHJvamVjdHMve3Byb2plY3R9L2FsZXJ0UG9saWNpZXMve2FsZXJ0X3BvbGljeX0vY29uZGl0aW9ucy97Y29uZGl0aW9ufRJQb3JnYW5pemF0aW9ucy97b3JnYW5pemF0aW9ufS9hbGVydFBvbGljaWVzL3thbGVydF9wb2xpY3l9L2NvbmRpdGlvbnMve2NvbmRpdGlvbn0SRGZvbGRlcnMve2ZvbGRlcn0vYWxlcnRQb2xpY2llcy97YWxlcnRfcG9saWN5fS9jb25kaXRpb25zL3tjb25kaXRpb259EgEqQgsKCWNvbmRpdGlvbhrXAwoNQWxlcnRTdHJhdGVneRJmChdub3RpZmljYXRpb25fcmF0ZV9saW1pdBgBIAEoCzJFLmdvb2dsZS5tb25pdG9yaW5nLnYzLkFsZXJ0UG9saWN5LkFsZXJ0U3RyYXRlZ3kuTm90aWZpY2F0aW9uUmF0ZUxpbWl0Ei0KCmF1dG9fY2xvc2UYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24Scgodbm90aWZpY2F0aW9uX2NoYW5uZWxfc3RyYXRlZ3kYBCADKAsySy5nb29nbGUubW9uaXRvcmluZy52My5BbGVydFBvbGljeS5BbGVydFN0cmF0ZWd5Lk5vdGlmaWNhdGlvbkNoYW5uZWxTdHJhdGVneRpCChVOb3RpZmljYXRpb25SYXRlTGltaXQSKQoGcGVyaW9kGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uGncKG05vdGlmaWNhdGlvbkNoYW5uZWxTdHJhdGVneRIiChpub3RpZmljYXRpb25fY2hhbm5lbF9uYW1lcxgBIAMoCRI0ChFyZW5vdGlmeV9pbnRlcnZhbBgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhoxCg9Vc2VyTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJhChVDb25kaXRpb25Db21iaW5lclR5cGUSFwoTQ09NQklORV9VTlNQRUNJRklFRBAAEgcKA0FORBABEgYKAk9SEAISHgoaQU5EX1dJVEhfTUFUQ0hJTkdfUkVTT1VSQ0UQAyJKCghTZXZlcml0eRIYChRTRVZFUklUWV9VTlNQRUNJRklFRBAAEgwKCENSSVRJQ0FMEAESCQoFRVJST1IQAhILCgdXQVJOSU5HEAM6yQHqQcUBCiVtb25pdG9yaW5nLmdvb2dsZWFwaXMuY29tL0FsZXJ0UG9saWN5Ei9wcm9qZWN0cy97cHJvamVjdH0vYWxlcnRQb2xpY2llcy97YWxlcnRfcG9saWN5fRI5b3JnYW5pemF0aW9ucy97b3JnYW5pemF0aW9ufS9hbGVydFBvbGljaWVzL3thbGVydF9wb2xpY3l9Ei1mb2xkZXJzL3tmb2xkZXJ9L2FsZXJ0UG9saWNpZXMve2FsZXJ0X3BvbGljeX0SASpCxQEKGGNvbS5nb29nbGUubW9uaXRvcmluZy52M0IKQWxlcnRQcm90b1ABWkFjbG91ZC5nb29nbGUuY29tL2dvL21vbml0b3JpbmcvYXBpdjMvdjIvbW9uaXRvcmluZ3BiO21vbml0b3JpbmdwYqoCGkdvb2dsZS5DbG91ZC5Nb25pdG9yaW5nLlYzygIaR29vZ2xlXENsb3VkXE1vbml0b3JpbmdcVjPqAh1Hb29nbGU6OkNsb3VkOjpNb25pdG9yaW5nOjpWM2IGcHJvdG8z", [file_google_api_field_behavior, file_google_api_resource, file_google_monitoring_v3_common, file_google_monitoring_v3_mutation_record, file_google_protobuf_duration, file_google_protobuf_wrappers, file_google_rpc_status]);

/**
 * A description of the conditions under which some aspect of your system is
 * considered to be "unhealthy" and the ways to notify people or services about
 * this state. For an overview of alert policies, see
 * [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
 *
 *
 * @generated from message google.monitoring.v3.AlertPolicy
 */
export type AlertPolicy = Message<"google.monitoring.v3.AlertPolicy"> & {
  /**
   * Required if the policy exists. The resource name for this policy. The
   * format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
   *
   * `[ALERT_POLICY_ID]` is assigned by Cloud Monitoring when the policy
   * is created. When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the alerting policy passed as
   * part of the request.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A short name or phrase used to identify the policy in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple policies in the same project. The name is
   * limited to 512 Unicode characters.
   *
   * The convention for the display_name of a PrometheusQueryLanguageCondition
   * is "{rule group name}/{alert name}", where the {rule group name} and
   * {alert name} should be taken from the corresponding Prometheus
   * configuration file. This convention is not enforced.
   * In any case the display_name is not a unique key of the AlertPolicy.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * Documentation that is included with notifications and incidents related to
   * this policy. Best practice is for the documentation to include information
   * to help responders understand, mitigate, escalate, and correct the
   * underlying problems detected by the alerting policy. Notification channels
   * that have limited capacity might not show this documentation.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Documentation documentation = 13;
   */
  documentation?: AlertPolicy_Documentation;

  /**
   * User-supplied key/value data to be used for organizing and
   * identifying the `AlertPolicy` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   *
   * Note that Prometheus {alert name} is a
   * [valid Prometheus label
   * names](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels),
   * whereas Prometheus {rule group} is an unrestricted UTF-8 string.
   * This means that they cannot be stored as-is in user labels, because
   * they may contain characters that are not allowed in user-label values.
   *
   * @generated from field: map<string, string> user_labels = 16;
   */
  userLabels: { [key: string]: string };

  /**
   * A list of conditions for the policy. The conditions are combined by AND or
   * OR according to the `combiner` field. If the combined conditions evaluate
   * to true, then an incident is created. A policy can have from one to six
   * conditions.
   * If `condition_time_series_query_language` is present, it must be the only
   * `condition`.
   * If `condition_monitoring_query_language` is present, it must be the only
   * `condition`.
   *
   * @generated from field: repeated google.monitoring.v3.AlertPolicy.Condition conditions = 12;
   */
  conditions: AlertPolicy_Condition[];

  /**
   * How to combine the results of multiple conditions to determine if an
   * incident should be opened.
   * If `condition_time_series_query_language` is present, this must be
   * `COMBINE_UNSPECIFIED`.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.ConditionCombinerType combiner = 6;
   */
  combiner: AlertPolicy_ConditionCombinerType;

  /**
   * Whether or not the policy is enabled. On write, the default interpretation
   * if unset is that the policy is enabled. On read, clients should not make
   * any assumption about the state if it has not been populated. The
   * field should always be populated on List and Get operations, unless
   * a field projection has been specified that strips it out.
   *
   * @generated from field: google.protobuf.BoolValue enabled = 17;
   */
  enabled?: boolean;

  /**
   * Read-only description of how the alert policy is invalid. This field is
   * only set when the alert policy is invalid. An invalid alert policy will not
   * generate incidents.
   *
   * @generated from field: google.rpc.Status validity = 18;
   */
  validity?: Status;

  /**
   * Identifies the notification channels to which notifications should be sent
   * when incidents are opened or closed or when new violations occur on
   * an already opened incident. Each element of this array corresponds to
   * the `name` field in each of the
   * [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
   * objects that are returned from the [`ListNotificationChannels`]
   * [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
   * method. The format of the entries in this field is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   *
   * @generated from field: repeated string notification_channels = 14;
   */
  notificationChannels: string[];

  /**
   * A read-only record of the creation of the alerting policy. If provided
   * in a call to create or update, this field will be ignored.
   *
   * @generated from field: google.monitoring.v3.MutationRecord creation_record = 10;
   */
  creationRecord?: MutationRecord;

  /**
   * A read-only record of the most recent change to the alerting policy. If
   * provided in a call to create or update, this field will be ignored.
   *
   * @generated from field: google.monitoring.v3.MutationRecord mutation_record = 11;
   */
  mutationRecord?: MutationRecord;

  /**
   * Control over how this alert policy's notification channels are notified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.AlertStrategy alert_strategy = 21;
   */
  alertStrategy?: AlertPolicy_AlertStrategy;

  /**
   * Optional. The severity of an alert policy indicates how important incidents
   * generated by that policy are. The severity level will be displayed on the
   * Incident detail page and in notifications.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Severity severity = 22;
   */
  severity: AlertPolicy_Severity;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.
 * Use `create(AlertPolicySchema)` to create a new message.
 */
export const AlertPolicySchema: GenMessage<AlertPolicy> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0);

/**
 * Documentation that is included in the notifications and incidents
 * pertaining to this policy.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Documentation
 */
export type AlertPolicy_Documentation = Message<"google.monitoring.v3.AlertPolicy.Documentation"> & {
  /**
   * The body of the documentation, interpreted according to `mime_type`.
   * The content may not exceed 8,192 Unicode characters and may not exceed
   * more than 10,240 bytes when encoded in UTF-8 format, whichever is
   * smaller. This text can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   *
   * @generated from field: string content = 1;
   */
  content: string;

  /**
   * The format of the `content` field. Presently, only the value
   * `"text/markdown"` is supported. See
   * [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
   *
   * @generated from field: string mime_type = 2;
   */
  mimeType: string;

  /**
   * Optional. The subject line of the notification. The subject line may not
   * exceed 10,240 bytes. In notifications generated by this policy, the
   * contents of the subject line after variable expansion will be truncated
   * to 255 bytes or shorter at the latest UTF-8 character boundary. The
   * 255-byte limit is recommended by [this
   * thread](https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit).
   * It is both the limit imposed by some third-party ticketing products and
   * it is common to define textual fields in databases as VARCHAR(255).
   *
   * The contents of the subject line can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   * If this field is missing or empty, a default subject line will be
   * generated.
   *
   * @generated from field: string subject = 3;
   */
  subject: string;

  /**
   * Optional. Links to content such as playbooks, repositories, and other
   * resources. This field can contain up to 3 entries.
   *
   * @generated from field: repeated google.monitoring.v3.AlertPolicy.Documentation.Link links = 4;
   */
  links: AlertPolicy_Documentation_Link[];
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Documentation.
 * Use `create(AlertPolicy_DocumentationSchema)` to create a new message.
 */
export const AlertPolicy_DocumentationSchema: GenMessage<AlertPolicy_Documentation> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 0);

/**
 * Links to content such as playbooks, repositories, and other resources.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Documentation.Link
 */
export type AlertPolicy_Documentation_Link = Message<"google.monitoring.v3.AlertPolicy.Documentation.Link"> & {
  /**
   * A short display name for the link. The display name must not be empty
   * or exceed 63 characters. Example: "playbook".
   *
   * @generated from field: string display_name = 1;
   */
  displayName: string;

  /**
   * The url of a webpage.
   * A url can be templatized by using variables
   * in the path or the query parameters. The total length of a URL should
   * not exceed 2083 characters before and after variable expansion.
   * Example: "https://my_domain.com/playbook?name=${resource.name}"
   *
   * @generated from field: string url = 2;
   */
  url: string;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Documentation.Link.
 * Use `create(AlertPolicy_Documentation_LinkSchema)` to create a new message.
 */
export const AlertPolicy_Documentation_LinkSchema: GenMessage<AlertPolicy_Documentation_Link> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 0, 0);

/**
 * A condition is a true/false test that determines when an alerting policy
 * should open an incident. If a condition evaluates to true, it signifies
 * that something is wrong.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition
 */
export type AlertPolicy_Condition = Message<"google.monitoring.v3.AlertPolicy.Condition"> & {
  /**
   * Required if the condition exists. The unique resource name for this
   * condition. Its format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
   *
   * `[CONDITION_ID]` is assigned by Cloud Monitoring when the
   * condition is created as part of a new or updated alerting policy.
   *
   * When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the conditions of the
   * requested alerting policy. Cloud Monitoring creates the
   * condition identifiers and includes them in the new policy.
   *
   * When calling the
   * [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
   * method to update a policy, including a condition `name` causes the
   * existing condition to be updated. Conditions without names are added to
   * the updated policy. Existing conditions are deleted if they are not
   * updated.
   *
   * Best practice is to preserve `[CONDITION_ID]` if you make only small
   * changes, such as those to condition thresholds, durations, or trigger
   * values.  Otherwise, treat the change as a new condition and let the
   * existing condition be deleted.
   *
   * @generated from field: string name = 12;
   */
  name: string;

  /**
   * A short name or phrase used to identify the condition in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple conditions in the same policy.
   *
   * @generated from field: string display_name = 6;
   */
  displayName: string;

  /**
   * Only one of the following condition types will be specified.
   *
   * @generated from oneof google.monitoring.v3.AlertPolicy.Condition.condition
   */
  condition: {
    /**
     * A condition that compares a time series against a threshold.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MetricThreshold condition_threshold = 1;
     */
    value: AlertPolicy_Condition_MetricThreshold;
    case: "conditionThreshold";
  } | {
    /**
     * A condition that checks that a time series continues to
     * receive new data points.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MetricAbsence condition_absent = 2;
     */
    value: AlertPolicy_Condition_MetricAbsence;
    case: "conditionAbsent";
  } | {
    /**
     * A condition that checks for log messages matching given constraints. If
     * set, no other conditions can be present.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.LogMatch condition_matched_log = 20;
     */
    value: AlertPolicy_Condition_LogMatch;
    case: "conditionMatchedLog";
  } | {
    /**
     * A condition that uses the Monitoring Query Language to define
     * alerts.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition condition_monitoring_query_language = 19;
     */
    value: AlertPolicy_Condition_MonitoringQueryLanguageCondition;
    case: "conditionMonitoringQueryLanguage";
  } | {
    /**
     * A condition that uses the Prometheus query language to define alerts.
     *
     * @generated from field: google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition condition_prometheus_query_language = 21;
     */
    value: AlertPolicy_Condition_PrometheusQueryLanguageCondition;
    case: "conditionPrometheusQueryLanguage";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.
 * Use `create(AlertPolicy_ConditionSchema)` to create a new message.
 */
export const AlertPolicy_ConditionSchema: GenMessage<AlertPolicy_Condition> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1);

/**
 * Specifies how many time series must fail a predicate to trigger a
 * condition. If not specified, then a `{count: 1}` trigger is used.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.Trigger
 */
export type AlertPolicy_Condition_Trigger = Message<"google.monitoring.v3.AlertPolicy.Condition.Trigger"> & {
  /**
   * A type of trigger.
   *
   * @generated from oneof google.monitoring.v3.AlertPolicy.Condition.Trigger.type
   */
  type: {
    /**
     * The absolute number of time series that must fail
     * the predicate for the condition to be triggered.
     *
     * @generated from field: int32 count = 1;
     */
    value: number;
    case: "count";
  } | {
    /**
     * The percentage of time series that must fail the
     * predicate for the condition to be triggered.
     *
     * @generated from field: double percent = 2;
     */
    value: number;
    case: "percent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.Trigger.
 * Use `create(AlertPolicy_Condition_TriggerSchema)` to create a new message.
 */
export const AlertPolicy_Condition_TriggerSchema: GenMessage<AlertPolicy_Condition_Trigger> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 0);

/**
 * A condition type that compares a collection of time series
 * against a threshold.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MetricThreshold
 */
export type AlertPolicy_Condition_MetricThreshold = Message<"google.monitoring.v3.AlertPolicy.Condition.MetricThreshold"> & {
  /**
   * Required. A
   * [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation aggregations = 8;
   */
  aggregations: Aggregation[];

  /**
   * A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies a time series that should be used as the denominator of a
   * ratio that will be compared with the threshold. If a
   * `denominator_filter` is specified, the time series specified by the
   * `filter` field will be used as the numerator.
   *
   * The filter must specify the metric type and optionally may contain
   * restrictions on resource type, resource labels, and metric labels.
   * This field may not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string denominator_filter = 9;
   */
  denominatorFilter: string;

  /**
   * Specifies the alignment of data points in individual time series
   * selected by `denominatorFilter` as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources).
   *
   * When computing ratios, the `aggregations` and
   * `denominator_aggregations` fields must use the same alignment period
   * and produce time series that have the same periodicity and labels.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation denominator_aggregations = 10;
   */
  denominatorAggregations: Aggregation[];

  /**
   * When this field is present, the `MetricThreshold` condition forecasts
   * whether the time series is predicted to violate the threshold within
   * the `forecast_horizon`. When this field is not set, the
   * `MetricThreshold` tests the current value of the timeseries against the
   * threshold.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions forecast_options = 12;
   */
  forecastOptions?: AlertPolicy_Condition_MetricThreshold_ForecastOptions;

  /**
   * The comparison to apply between the time series (indicated by `filter`
   * and `aggregation`) and the threshold (indicated by `threshold_value`).
   * The comparison is applied on each time series, with the time series
   * on the left-hand side and the threshold on the right-hand side.
   *
   * Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
   *
   * @generated from field: google.monitoring.v3.ComparisonType comparison = 4;
   */
  comparison: ComparisonType;

  /**
   * A value against which to compare the time series.
   *
   * @generated from field: double threshold_value = 5;
   */
  thresholdValue: number;

  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   *
   * @generated from field: google.protobuf.Duration duration = 6;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 7;
   */
  trigger?: AlertPolicy_Condition_Trigger;

  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving. To use this control, the value
   * of the `duration` field must be greater than or equal to 60 seconds.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData evaluation_missing_data = 11;
   */
  evaluationMissingData: AlertPolicy_Condition_EvaluationMissingData;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.
 * Use `create(AlertPolicy_Condition_MetricThresholdSchema)` to create a new message.
 */
export const AlertPolicy_Condition_MetricThresholdSchema: GenMessage<AlertPolicy_Condition_MetricThreshold> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 1);

/**
 * Options used when forecasting the time series and testing
 * the predicted value against the threshold.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions
 */
export type AlertPolicy_Condition_MetricThreshold_ForecastOptions = Message<"google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions"> & {
  /**
   * Required. The length of time into the future to forecast whether a
   * time series will violate the threshold. If the predicted value is
   * found to violate the threshold, and the violation is observed in all
   * forecasts made for the configured `duration`, then the time series is
   * considered to be failing.
   * The forecast horizon can range from 1 hour to 60 hours.
   *
   * @generated from field: google.protobuf.Duration forecast_horizon = 1;
   */
  forecastHorizon?: Duration;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions.
 * Use `create(AlertPolicy_Condition_MetricThreshold_ForecastOptionsSchema)` to create a new message.
 */
export const AlertPolicy_Condition_MetricThreshold_ForecastOptionsSchema: GenMessage<AlertPolicy_Condition_MetricThreshold_ForecastOptions> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 1, 0);

/**
 * A condition type that checks that monitored resources
 * are reporting data. The configuration defines a metric and
 * a set of monitored resources. The predicate is considered in violation
 * when a time series for the specified metric of a monitored
 * resource does not include any data in the specified `duration`.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MetricAbsence
 */
export type AlertPolicy_Condition_MetricAbsence = Message<"google.monitoring.v3.AlertPolicy.Condition.MetricAbsence"> & {
  /**
   * Required. A
   * [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   *
   * @generated from field: repeated google.monitoring.v3.Aggregation aggregations = 5;
   */
  aggregations: Aggregation[];

  /**
   * The amount of time that a time series must fail to report new
   * data to be considered failing. The minimum value of this field
   * is 120 seconds. Larger values that are a multiple of a
   * minute--for example, 240 or 300 seconds--are supported.
   * If an invalid value is given, an
   * error will be returned. The `Duration.nanos` field is
   * ignored.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 3;
   */
  trigger?: AlertPolicy_Condition_Trigger;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.MetricAbsence.
 * Use `create(AlertPolicy_Condition_MetricAbsenceSchema)` to create a new message.
 */
export const AlertPolicy_Condition_MetricAbsenceSchema: GenMessage<AlertPolicy_Condition_MetricAbsence> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 2);

/**
 * A condition type that checks whether a log message in the [scoping
 * project](https://cloud.google.com/monitoring/api/v3#project_name)
 * satisfies the given filter. Logs from other projects in the metrics
 * scope are not evaluated.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.LogMatch
 */
export type AlertPolicy_Condition_LogMatch = Message<"google.monitoring.v3.AlertPolicy.Condition.LogMatch"> & {
  /**
   * Required. A logs-based filter. See [Advanced Logs
   * Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
   * for how this filter should be constructed.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Optional. A map from a label key to an extractor expression, which is
   * used to extract the value for this label key. Each entry in this map is
   * a specification for how data should be extracted from log entries that
   * match `filter`. Each combination of extracted values is treated as a
   * separate rule for the purposes of triggering notifications. Label keys
   * and corresponding values can be used in notifications generated by this
   * condition.
   *
   * Please see [the documentation on logs-based metric
   * `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
   * for syntax and examples.
   *
   * @generated from field: map<string, string> label_extractors = 2;
   */
  labelExtractors: { [key: string]: string };
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.LogMatch.
 * Use `create(AlertPolicy_Condition_LogMatchSchema)` to create a new message.
 */
export const AlertPolicy_Condition_LogMatchSchema: GenMessage<AlertPolicy_Condition_LogMatch> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 3);

/**
 * A condition type that allows alert policies to be defined using
 * [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition
 */
export type AlertPolicy_Condition_MonitoringQueryLanguageCondition = Message<"google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition"> & {
  /**
   * [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
   * query that outputs a boolean stream.
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 3;
   */
  trigger?: AlertPolicy_Condition_Trigger;

  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData evaluation_missing_data = 4;
   */
  evaluationMissingData: AlertPolicy_Condition_EvaluationMissingData;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition.
 * Use `create(AlertPolicy_Condition_MonitoringQueryLanguageConditionSchema)` to create a new message.
 */
export const AlertPolicy_Condition_MonitoringQueryLanguageConditionSchema: GenMessage<AlertPolicy_Condition_MonitoringQueryLanguageCondition> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 4);

/**
 * A condition type that allows alert policies to be defined using
 * [Prometheus Query Language
 * (PromQL)](https://prometheus.io/docs/prometheus/latest/querying/basics/).
 *
 * The PrometheusQueryLanguageCondition message contains information
 * from a Prometheus alerting rule and its associated rule group.
 *
 * A Prometheus alerting rule is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/).
 * The semantics of a Prometheus alerting rule is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).
 *
 * A Prometheus rule group is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/).
 * The semantics of a Prometheus rule group is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).
 *
 * Because Cloud Alerting has no representation of a Prometheus rule
 * group resource, we must embed the information of the parent rule
 * group inside each of the conditions that refer to it. We must also
 * update the contents of all Prometheus alerts in case the information
 * of their rule group changes.
 *
 * The PrometheusQueryLanguageCondition protocol buffer combines the
 * information of the corresponding rule group and alerting rule.
 * The structure of the PrometheusQueryLanguageCondition protocol buffer
 * does NOT mimic the structure of the Prometheus rule group and alerting
 * rule YAML declarations. The PrometheusQueryLanguageCondition protocol
 * buffer may change in the future to support future rule group and/or
 * alerting rule features. There are no new such features at the present
 * time (2023-06-26).
 *
 * @generated from message google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition
 */
export type AlertPolicy_Condition_PrometheusQueryLanguageCondition = Message<"google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition"> & {
  /**
   * Required. The PromQL expression to evaluate. Every evaluation cycle
   * this expression is evaluated at the current time, and all resultant
   * time series become pending/firing alerts. This field must not be empty.
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * Optional. Alerts are considered firing once their PromQL expression was
   * evaluated to be "true" for this long.
   * Alerts whose PromQL expression was not evaluated to be "true" for
   * long enough are considered pending.
   * Must be a non-negative duration or missing.
   * This field is optional. Its default value is zero.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * Optional. How often this rule should be evaluated.
   * Must be a positive multiple of 30 seconds or missing.
   * This field is optional. Its default value is 30 seconds.
   * If this PrometheusQueryLanguageCondition was generated from a
   * Prometheus alerting rule, then this value should be taken from the
   * enclosing rule group.
   *
   * @generated from field: google.protobuf.Duration evaluation_interval = 3;
   */
  evaluationInterval?: Duration;

  /**
   * Optional. Labels to add to or overwrite in the PromQL query result.
   * Label names [must be
   * valid](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
   * Label values can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   * The only available variable names are the names of the labels in the
   * PromQL result, including "__name__" and "value". "labels" may be empty.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Optional. The rule group name of this alert in the corresponding
   * Prometheus configuration file.
   *
   * Some external tools may require this field to be populated correctly
   * in order to refer to the original Prometheus configuration file.
   * The rule group name and the alert name are necessary to update the
   * relevant AlertPolicies in case the definition of the rule group changes
   * in the future.
   *
   * This field is optional. If this field is not empty, then it must
   * contain a valid UTF-8 string.
   * This field may not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string rule_group = 5;
   */
  ruleGroup: string;

  /**
   * Optional. The alerting rule name of this alert in the corresponding
   * Prometheus configuration file.
   *
   * Some external tools may require this field to be populated correctly
   * in order to refer to the original Prometheus configuration file.
   * The rule group name and the alert name are necessary to update the
   * relevant AlertPolicies in case the definition of the rule group changes
   * in the future.
   *
   * This field is optional. If this field is not empty, then it must be a
   * [valid Prometheus label
   * name](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
   * This field may not exceed 2048 Unicode characters in length.
   *
   * @generated from field: string alert_rule = 6;
   */
  alertRule: string;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition.
 * Use `create(AlertPolicy_Condition_PrometheusQueryLanguageConditionSchema)` to create a new message.
 */
export const AlertPolicy_Condition_PrometheusQueryLanguageConditionSchema: GenMessage<AlertPolicy_Condition_PrometheusQueryLanguageCondition> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 1, 5);

/**
 * A condition control that determines how metric-threshold conditions
 * are evaluated when data stops arriving.
 * This control doesn't affect metric-absence policies.
 *
 * @generated from enum google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData
 */
export enum AlertPolicy_Condition_EvaluationMissingData {
  /**
   * An unspecified evaluation missing data option.  Equivalent to
   * EVALUATION_MISSING_DATA_NO_OP.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * If there is no data to evaluate the condition, then evaluate the
   * condition as false.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_INACTIVE = 1;
   */
  INACTIVE = 1,

  /**
   * If there is no data to evaluate the condition, then evaluate the
   * condition as true.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * Do not evaluate the condition to any value if there is no data.
   *
   * @generated from enum value: EVALUATION_MISSING_DATA_NO_OP = 3;
   */
  NO_OP = 3,
}

/**
 * Describes the enum google.monitoring.v3.AlertPolicy.Condition.EvaluationMissingData.
 */
export const AlertPolicy_Condition_EvaluationMissingDataSchema: GenEnum<AlertPolicy_Condition_EvaluationMissingData> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_alert, 0, 1, 0);

/**
 * Control over how the notification channels in `notification_channels`
 * are notified when this alert fires.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.AlertStrategy
 */
export type AlertPolicy_AlertStrategy = Message<"google.monitoring.v3.AlertPolicy.AlertStrategy"> & {
  /**
   * Required for alert policies with a `LogMatch` condition.
   *
   * This limit is not implemented for alert policies that are not log-based.
   *
   * @generated from field: google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit notification_rate_limit = 1;
   */
  notificationRateLimit?: AlertPolicy_AlertStrategy_NotificationRateLimit;

  /**
   * If an alert policy that was active has no data for this long, any open
   * incidents will close
   *
   * @generated from field: google.protobuf.Duration auto_close = 3;
   */
  autoClose?: Duration;

  /**
   * Control how notifications will be sent out, on a per-channel basis.
   *
   * @generated from field: repeated google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy notification_channel_strategy = 4;
   */
  notificationChannelStrategy: AlertPolicy_AlertStrategy_NotificationChannelStrategy[];
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.AlertStrategy.
 * Use `create(AlertPolicy_AlertStrategySchema)` to create a new message.
 */
export const AlertPolicy_AlertStrategySchema: GenMessage<AlertPolicy_AlertStrategy> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 2);

/**
 * Control over the rate of notifications sent to this alert policy's
 * notification channels.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit
 */
export type AlertPolicy_AlertStrategy_NotificationRateLimit = Message<"google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit"> & {
  /**
   * Not more than one notification per `period`.
   *
   * @generated from field: google.protobuf.Duration period = 1;
   */
  period?: Duration;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit.
 * Use `create(AlertPolicy_AlertStrategy_NotificationRateLimitSchema)` to create a new message.
 */
export const AlertPolicy_AlertStrategy_NotificationRateLimitSchema: GenMessage<AlertPolicy_AlertStrategy_NotificationRateLimit> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 2, 0);

/**
 * Control over how the notification channels in `notification_channels`
 * are notified when this alert fires, on a per-channel basis.
 *
 * @generated from message google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy
 */
export type AlertPolicy_AlertStrategy_NotificationChannelStrategy = Message<"google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy"> & {
  /**
   * The full REST resource name for the notification channels that these
   * settings apply to. Each of these correspond to the name field in one
   * of the NotificationChannel objects referenced in the
   * notification_channels field of this AlertPolicy.
   * The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   *
   * @generated from field: repeated string notification_channel_names = 1;
   */
  notificationChannelNames: string[];

  /**
   * The frequency at which to send reminder notifications for open
   * incidents.
   *
   * @generated from field: google.protobuf.Duration renotify_interval = 2;
   */
  renotifyInterval?: Duration;
};

/**
 * Describes the message google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy.
 * Use `create(AlertPolicy_AlertStrategy_NotificationChannelStrategySchema)` to create a new message.
 */
export const AlertPolicy_AlertStrategy_NotificationChannelStrategySchema: GenMessage<AlertPolicy_AlertStrategy_NotificationChannelStrategy> = /*@__PURE__*/
  messageDesc(file_google_monitoring_v3_alert, 0, 2, 1);

/**
 * Operators for combining conditions.
 *
 * @generated from enum google.monitoring.v3.AlertPolicy.ConditionCombinerType
 */
export enum AlertPolicy_ConditionCombinerType {
  /**
   * An unspecified combiner.
   *
   * @generated from enum value: COMBINE_UNSPECIFIED = 0;
   */
  COMBINE_UNSPECIFIED = 0,

  /**
   * Combine conditions using the logical `AND` operator. An
   * incident is created only if all the conditions are met
   * simultaneously. This combiner is satisfied if all conditions are
   * met, even if they are met on completely different resources.
   *
   * @generated from enum value: AND = 1;
   */
  AND = 1,

  /**
   * Combine conditions using the logical `OR` operator. An incident
   * is created if any of the listed conditions is met.
   *
   * @generated from enum value: OR = 2;
   */
  OR = 2,

  /**
   * Combine conditions using logical `AND` operator, but unlike the regular
   * `AND` option, an incident is created only if all conditions are met
   * simultaneously on at least one resource.
   *
   * @generated from enum value: AND_WITH_MATCHING_RESOURCE = 3;
   */
  AND_WITH_MATCHING_RESOURCE = 3,
}

/**
 * Describes the enum google.monitoring.v3.AlertPolicy.ConditionCombinerType.
 */
export const AlertPolicy_ConditionCombinerTypeSchema: GenEnum<AlertPolicy_ConditionCombinerType> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_alert, 0, 0);

/**
 * An enumeration of possible severity level for an Alert Policy.
 *
 * @generated from enum google.monitoring.v3.AlertPolicy.Severity
 */
export enum AlertPolicy_Severity {
  /**
   * No severity is specified. This is the default value.
   *
   * @generated from enum value: SEVERITY_UNSPECIFIED = 0;
   */
  SEVERITY_UNSPECIFIED = 0,

  /**
   * This is the highest severity level. Use this if the problem could
   * cause significant damage or downtime.
   *
   * @generated from enum value: CRITICAL = 1;
   */
  CRITICAL = 1,

  /**
   * This is the medium severity level. Use this if the problem could
   * cause minor damage or downtime.
   *
   * @generated from enum value: ERROR = 2;
   */
  ERROR = 2,

  /**
   * This is the lowest severity level. Use this if the problem is not causing
   * any damage or downtime, but could potentially lead to a problem in the
   * future.
   *
   * @generated from enum value: WARNING = 3;
   */
  WARNING = 3,
}

/**
 * Describes the enum google.monitoring.v3.AlertPolicy.Severity.
 */
export const AlertPolicy_SeveritySchema: GenEnum<AlertPolicy_Severity> = /*@__PURE__*/
  enumDesc(file_google_monitoring_v3_alert, 0, 1);

