// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/genomics/v1/variants.proto (package google.genomics.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import type { OperationSchema } from "../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../longrunning/operations_pb";
import type { EmptySchema, FieldMask, ListValue } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_struct } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/genomics/v1/variants.proto.
 */
export const file_google_genomics_v1_variants: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvZ2Vub21pY3MvdjEvdmFyaWFudHMucHJvdG8SEmdvb2dsZS5nZW5vbWljcy52MSKAAwoSVmFyaWFudFNldE1ldGFkYXRhEgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCRIKCgJpZBgEIAEoCRI5CgR0eXBlGAUgASgOMisuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnRTZXRNZXRhZGF0YS5UeXBlEg4KBm51bWJlchgIIAEoCRITCgtkZXNjcmlwdGlvbhgHIAEoCRI+CgRpbmZvGAMgAygLMjAuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnRTZXRNZXRhZGF0YS5JbmZvRW50cnkaRwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWU6AjgBIlkKBFR5cGUSFAoQVFlQRV9VTlNQRUNJRklFRBAAEgsKB0lOVEVHRVIQARIJCgVGTE9BVBACEggKBEZMQUcQAxINCglDSEFSQUNURVIQBBIKCgZTVFJJTkcQBSLhAQoKVmFyaWFudFNldBISCgpkYXRhc2V0X2lkGAEgASgJEgoKAmlkGAIgASgJEhgKEHJlZmVyZW5jZV9zZXRfaWQYBiABKAkSPAoQcmVmZXJlbmNlX2JvdW5kcxgFIAMoCzIiLmdvb2dsZS5nZW5vbWljcy52MS5SZWZlcmVuY2VCb3VuZBI4CghtZXRhZGF0YRgEIAMoCzImLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50U2V0TWV0YWRhdGESDAoEbmFtZRgHIAEoCRITCgtkZXNjcmlwdGlvbhgIIAEoCSKCAwoHVmFyaWFudBIWCg52YXJpYW50X3NldF9pZBgPIAEoCRIKCgJpZBgCIAEoCRINCgVuYW1lcxgDIAMoCRIPCgdjcmVhdGVkGAwgASgDEhYKDnJlZmVyZW5jZV9uYW1lGA4gASgJEg0KBXN0YXJ0GBAgASgDEgsKA2VuZBgNIAEoAxIXCg9yZWZlcmVuY2VfYmFzZXMYBiABKAkSFwoPYWx0ZXJuYXRlX2Jhc2VzGAcgAygJEg8KB3F1YWxpdHkYCCABKAESDgoGZmlsdGVyGAkgAygJEjMKBGluZm8YCiADKAsyJS5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudC5JbmZvRW50cnkSLgoFY2FsbHMYCyADKAsyHy5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudENhbGwaRwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWU6AjgBIvwBCgtWYXJpYW50Q2FsbBITCgtjYWxsX3NldF9pZBgIIAEoCRIVCg1jYWxsX3NldF9uYW1lGAkgASgJEhAKCGdlbm90eXBlGAcgAygFEhAKCHBoYXNlc2V0GAUgASgJEhsKE2dlbm90eXBlX2xpa2VsaWhvb2QYBiADKAESNwoEaW5mbxgCIAMoCzIpLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50Q2FsbC5JbmZvRW50cnkaRwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWU6AjgBIt4BCgdDYWxsU2V0EgoKAmlkGAEgASgJEgwKBG5hbWUYAiABKAkSEQoJc2FtcGxlX2lkGAcgASgJEhcKD3ZhcmlhbnRfc2V0X2lkcxgGIAMoCRIPCgdjcmVhdGVkGAUgASgDEjMKBGluZm8YBCADKAsyJS5nb29nbGUuZ2Vub21pY3MudjEuQ2FsbFNldC5JbmZvRW50cnkaRwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWU6AjgBIj0KDlJlZmVyZW5jZUJvdW5kEhYKDnJlZmVyZW5jZV9uYW1lGAEgASgJEhMKC3VwcGVyX2JvdW5kGAIgASgDIrQDChVJbXBvcnRWYXJpYW50c1JlcXVlc3QSFgoOdmFyaWFudF9zZXRfaWQYASABKAkSEwoLc291cmNlX3VyaXMYAiADKAkSQAoGZm9ybWF0GAMgASgOMjAuZ29vZ2xlLmdlbm9taWNzLnYxLkltcG9ydFZhcmlhbnRzUmVxdWVzdC5Gb3JtYXQSIQoZbm9ybWFsaXplX3JlZmVyZW5jZV9uYW1lcxgFIAEoCBJZChFpbmZvX21lcmdlX2NvbmZpZxgGIAMoCzI+Lmdvb2dsZS5nZW5vbWljcy52MS5JbXBvcnRWYXJpYW50c1JlcXVlc3QuSW5mb01lcmdlQ29uZmlnRW50cnkaXgoUSW5mb01lcmdlQ29uZmlnRW50cnkSCwoDa2V5GAEgASgJEjUKBXZhbHVlGAIgASgOMiYuZ29vZ2xlLmdlbm9taWNzLnYxLkluZm9NZXJnZU9wZXJhdGlvbjoCOAEiTgoGRm9ybWF0EhYKEkZPUk1BVF9VTlNQRUNJRklFRBAAEg4KCkZPUk1BVF9WQ0YQARIcChhGT1JNQVRfQ09NUExFVEVfR0VOT01JQ1MQAiIuChZJbXBvcnRWYXJpYW50c1Jlc3BvbnNlEhQKDGNhbGxfc2V0X2lkcxgBIAMoCSJOChdDcmVhdGVWYXJpYW50U2V0UmVxdWVzdBIzCgt2YXJpYW50X3NldBgBIAEoCzIeLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50U2V0IogCChdFeHBvcnRWYXJpYW50U2V0UmVxdWVzdBIWCg52YXJpYW50X3NldF9pZBgBIAEoCRIUCgxjYWxsX3NldF9pZHMYAiADKAkSEgoKcHJvamVjdF9pZBgDIAEoCRJCCgZmb3JtYXQYBCABKA4yMi5nb29nbGUuZ2Vub21pY3MudjEuRXhwb3J0VmFyaWFudFNldFJlcXVlc3QuRm9ybWF0EhgKEGJpZ3F1ZXJ5X2RhdGFzZXQYBSABKAkSFgoOYmlncXVlcnlfdGFibGUYBiABKAkiNQoGRm9ybWF0EhYKEkZPUk1BVF9VTlNQRUNJRklFRBAAEhMKD0ZPUk1BVF9CSUdRVUVSWRABIi4KFEdldFZhcmlhbnRTZXRSZXF1ZXN0EhYKDnZhcmlhbnRfc2V0X2lkGAEgASgJIlYKGFNlYXJjaFZhcmlhbnRTZXRzUmVxdWVzdBITCgtkYXRhc2V0X2lkcxgBIAMoCRISCgpwYWdlX3Rva2VuGAIgASgJEhEKCXBhZ2Vfc2l6ZRgDIAEoBSJqChlTZWFyY2hWYXJpYW50U2V0c1Jlc3BvbnNlEjQKDHZhcmlhbnRfc2V0cxgBIAMoCzIeLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50U2V0EhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSIxChdEZWxldGVWYXJpYW50U2V0UmVxdWVzdBIWCg52YXJpYW50X3NldF9pZBgBIAEoCSKXAQoXVXBkYXRlVmFyaWFudFNldFJlcXVlc3QSFgoOdmFyaWFudF9zZXRfaWQYASABKAkSMwoLdmFyaWFudF9zZXQYAiABKAsyHi5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudFNldBIvCgt1cGRhdGVfbWFzaxgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siygEKFVNlYXJjaFZhcmlhbnRzUmVxdWVzdBIXCg92YXJpYW50X3NldF9pZHMYASADKAkSFAoMdmFyaWFudF9uYW1lGAIgASgJEhQKDGNhbGxfc2V0X2lkcxgDIAMoCRIWCg5yZWZlcmVuY2VfbmFtZRgEIAEoCRINCgVzdGFydBgFIAEoAxILCgNlbmQYBiABKAMSEgoKcGFnZV90b2tlbhgHIAEoCRIRCglwYWdlX3NpemUYCCABKAUSEQoJbWF4X2NhbGxzGAkgASgFImAKFlNlYXJjaFZhcmlhbnRzUmVzcG9uc2USLQoIdmFyaWFudHMYASADKAsyGy5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudBIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkiRAoUQ3JlYXRlVmFyaWFudFJlcXVlc3QSLAoHdmFyaWFudBgBIAEoCzIbLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50IokBChRVcGRhdGVWYXJpYW50UmVxdWVzdBISCgp2YXJpYW50X2lkGAEgASgJEiwKB3ZhcmlhbnQYAiABKAsyGy5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudBIvCgt1cGRhdGVfbWFzaxgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siKgoURGVsZXRlVmFyaWFudFJlcXVlc3QSEgoKdmFyaWFudF9pZBgBIAEoCSInChFHZXRWYXJpYW50UmVxdWVzdBISCgp2YXJpYW50X2lkGAEgASgJIpcCChRNZXJnZVZhcmlhbnRzUmVxdWVzdBIWCg52YXJpYW50X3NldF9pZBgBIAEoCRItCgh2YXJpYW50cxgCIAMoCzIbLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50ElgKEWluZm9fbWVyZ2VfY29uZmlnGAMgAygLMj0uZ29vZ2xlLmdlbm9taWNzLnYxLk1lcmdlVmFyaWFudHNSZXF1ZXN0LkluZm9NZXJnZUNvbmZpZ0VudHJ5Gl4KFEluZm9NZXJnZUNvbmZpZ0VudHJ5EgsKA2tleRgBIAEoCRI1CgV2YWx1ZRgCIAEoDjImLmdvb2dsZS5nZW5vbWljcy52MS5JbmZvTWVyZ2VPcGVyYXRpb246AjgBImUKFVNlYXJjaENhbGxTZXRzUmVxdWVzdBIXCg92YXJpYW50X3NldF9pZHMYASADKAkSDAoEbmFtZRgCIAEoCRISCgpwYWdlX3Rva2VuGAMgASgJEhEKCXBhZ2Vfc2l6ZRgEIAEoBSJhChZTZWFyY2hDYWxsU2V0c1Jlc3BvbnNlEi4KCWNhbGxfc2V0cxgBIAMoCzIbLmdvb2dsZS5nZW5vbWljcy52MS5DYWxsU2V0EhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSJFChRDcmVhdGVDYWxsU2V0UmVxdWVzdBItCghjYWxsX3NldBgBIAEoCzIbLmdvb2dsZS5nZW5vbWljcy52MS5DYWxsU2V0IosBChRVcGRhdGVDYWxsU2V0UmVxdWVzdBITCgtjYWxsX3NldF9pZBgBIAEoCRItCghjYWxsX3NldBgCIAEoCzIbLmdvb2dsZS5nZW5vbWljcy52MS5DYWxsU2V0Ei8KC3VwZGF0ZV9tYXNrGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayIrChREZWxldGVDYWxsU2V0UmVxdWVzdBITCgtjYWxsX3NldF9pZBgBIAEoCSIoChFHZXRDYWxsU2V0UmVxdWVzdBITCgtjYWxsX3NldF9pZBgBIAEoCSKNAQoVU3RyZWFtVmFyaWFudHNSZXF1ZXN0EhIKCnByb2plY3RfaWQYASABKAkSFgoOdmFyaWFudF9zZXRfaWQYAiABKAkSFAoMY2FsbF9zZXRfaWRzGAMgAygJEhYKDnJlZmVyZW5jZV9uYW1lGAQgASgJEg0KBXN0YXJ0GAUgASgDEgsKA2VuZBgGIAEoAyJHChZTdHJlYW1WYXJpYW50c1Jlc3BvbnNlEi0KCHZhcmlhbnRzGAEgAygLMhsuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnQqXQoSSW5mb01lcmdlT3BlcmF0aW9uEiQKIElORk9fTUVSR0VfT1BFUkFUSU9OX1VOU1BFQ0lGSUVEEAASDgoKSUdOT1JFX05FVxABEhEKDU1PVkVfVE9fQ0FMTFMQAjKlAQoXU3RyZWFtaW5nVmFyaWFudFNlcnZpY2USiQEKDlN0cmVhbVZhcmlhbnRzEikuZ29vZ2xlLmdlbm9taWNzLnYxLlN0cmVhbVZhcmlhbnRzUmVxdWVzdBoqLmdvb2dsZS5nZW5vbWljcy52MS5TdHJlYW1WYXJpYW50c1Jlc3BvbnNlIh6C0+STAhg6ASoiEy92MS92YXJpYW50czpzdHJlYW0wATK9EgoQVmFyaWFudFNlcnZpY2VWMRJ6Cg5JbXBvcnRWYXJpYW50cxIpLmdvb2dsZS5nZW5vbWljcy52MS5JbXBvcnRWYXJpYW50c1JlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIh6C0+STAhg6ASoiEy92MS92YXJpYW50czppbXBvcnQShQEKEENyZWF0ZVZhcmlhbnRTZXQSKy5nb29nbGUuZ2Vub21pY3MudjEuQ3JlYXRlVmFyaWFudFNldFJlcXVlc3QaHi5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudFNldCIkgtPkkwIeOgt2YXJpYW50X3NldCIPL3YxL3ZhcmlhbnRzZXRzEpIBChBFeHBvcnRWYXJpYW50U2V0EisuZ29vZ2xlLmdlbm9taWNzLnYxLkV4cG9ydFZhcmlhbnRTZXRSZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiIygtPkkwIsOgEqIicvdjEvdmFyaWFudHNldHMve3ZhcmlhbnRfc2V0X2lkfTpleHBvcnQSgwEKDUdldFZhcmlhbnRTZXQSKC5nb29nbGUuZ2Vub21pY3MudjEuR2V0VmFyaWFudFNldFJlcXVlc3QaHi5nb29nbGUuZ2Vub21pY3MudjEuVmFyaWFudFNldCIogtPkkwIiEiAvdjEvdmFyaWFudHNldHMve3ZhcmlhbnRfc2V0X2lkfRKTAQoRU2VhcmNoVmFyaWFudFNldHMSLC5nb29nbGUuZ2Vub21pY3MudjEuU2VhcmNoVmFyaWFudFNldHNSZXF1ZXN0Gi0uZ29vZ2xlLmdlbm9taWNzLnYxLlNlYXJjaFZhcmlhbnRTZXRzUmVzcG9uc2UiIYLT5JMCGzoBKiIWL3YxL3ZhcmlhbnRzZXRzL3NlYXJjaBKBAQoQRGVsZXRlVmFyaWFudFNldBIrLmdvb2dsZS5nZW5vbWljcy52MS5EZWxldGVWYXJpYW50U2V0UmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIogtPkkwIiKiAvdjEvdmFyaWFudHNldHMve3ZhcmlhbnRfc2V0X2lkfRKWAQoQVXBkYXRlVmFyaWFudFNldBIrLmdvb2dsZS5nZW5vbWljcy52MS5VcGRhdGVWYXJpYW50U2V0UmVxdWVzdBoeLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50U2V0IjWC0+STAi86C3ZhcmlhbnRfc2V0MiAvdjEvdmFyaWFudHNldHMve3ZhcmlhbnRfc2V0X2lkfRKHAQoOU2VhcmNoVmFyaWFudHMSKS5nb29nbGUuZ2Vub21pY3MudjEuU2VhcmNoVmFyaWFudHNSZXF1ZXN0GiouZ29vZ2xlLmdlbm9taWNzLnYxLlNlYXJjaFZhcmlhbnRzUmVzcG9uc2UiHoLT5JMCGDoBKiITL3YxL3ZhcmlhbnRzL3NlYXJjaBJ1Cg1DcmVhdGVWYXJpYW50EiguZ29vZ2xlLmdlbm9taWNzLnYxLkNyZWF0ZVZhcmlhbnRSZXF1ZXN0GhsuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnQiHYLT5JMCFzoHdmFyaWFudCIML3YxL3ZhcmlhbnRzEoIBCg1VcGRhdGVWYXJpYW50EiguZ29vZ2xlLmdlbm9taWNzLnYxLlVwZGF0ZVZhcmlhbnRSZXF1ZXN0GhsuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnQiKoLT5JMCJDoHdmFyaWFudDIZL3YxL3ZhcmlhbnRzL3t2YXJpYW50X2lkfRJ0Cg1EZWxldGVWYXJpYW50EiguZ29vZ2xlLmdlbm9taWNzLnYxLkRlbGV0ZVZhcmlhbnRSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IiGC0+STAhsqGS92MS92YXJpYW50cy97dmFyaWFudF9pZH0ScwoKR2V0VmFyaWFudBIlLmdvb2dsZS5nZW5vbWljcy52MS5HZXRWYXJpYW50UmVxdWVzdBobLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50IiGC0+STAhsSGS92MS92YXJpYW50cy97dmFyaWFudF9pZH0ScAoNTWVyZ2VWYXJpYW50cxIoLmdvb2dsZS5nZW5vbWljcy52MS5NZXJnZVZhcmlhbnRzUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIdgtPkkwIXOgEqIhIvdjEvdmFyaWFudHM6bWVyZ2UShwEKDlNlYXJjaENhbGxTZXRzEikuZ29vZ2xlLmdlbm9taWNzLnYxLlNlYXJjaENhbGxTZXRzUmVxdWVzdBoqLmdvb2dsZS5nZW5vbWljcy52MS5TZWFyY2hDYWxsU2V0c1Jlc3BvbnNlIh6C0+STAhg6ASoiEy92MS9jYWxsc2V0cy9zZWFyY2gSdgoNQ3JlYXRlQ2FsbFNldBIoLmdvb2dsZS5nZW5vbWljcy52MS5DcmVhdGVDYWxsU2V0UmVxdWVzdBobLmdvb2dsZS5nZW5vbWljcy52MS5DYWxsU2V0Ih6C0+STAhg6CGNhbGxfc2V0IgwvdjEvY2FsbHNldHMShAEKDVVwZGF0ZUNhbGxTZXQSKC5nb29nbGUuZ2Vub21pY3MudjEuVXBkYXRlQ2FsbFNldFJlcXVlc3QaGy5nb29nbGUuZ2Vub21pY3MudjEuQ2FsbFNldCIsgtPkkwImOghjYWxsX3NldDIaL3YxL2NhbGxzZXRzL3tjYWxsX3NldF9pZH0SdQoNRGVsZXRlQ2FsbFNldBIoLmdvb2dsZS5nZW5vbWljcy52MS5EZWxldGVDYWxsU2V0UmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIigtPkkwIcKhovdjEvY2FsbHNldHMve2NhbGxfc2V0X2lkfRJ0CgpHZXRDYWxsU2V0EiUuZ29vZ2xlLmdlbm9taWNzLnYxLkdldENhbGxTZXRSZXF1ZXN0GhsuZ29vZ2xlLmdlbm9taWNzLnYxLkNhbGxTZXQiIoLT5JMCHBIaL3YxL2NhbGxzZXRzL3tjYWxsX3NldF9pZH1CaAoWY29tLmdvb2dsZS5nZW5vbWljcy52MUINVmFyaWFudHNQcm90b1ABWjpnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL2dlbm9taWNzL3YxO2dlbm9taWNz+AEBYgZwcm90bzM", [file_google_api_annotations, file_google_longrunning_operations, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_struct]);

/**
 * Metadata describes a single piece of variant call metadata.
 * These data include a top level key and either a single value string (value)
 * or a list of key-value pairs (info.)
 * Value and info are mutually exclusive.
 *
 * @generated from message google.genomics.v1.VariantSetMetadata
 */
export type VariantSetMetadata = Message<"google.genomics.v1.VariantSetMetadata"> & {
  /**
   * The top-level key.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The value field for simple metadata
   *
   * @generated from field: string value = 2;
   */
  value: string;

  /**
   * User-provided ID field, not enforced by this API.
   * Two or more pieces of structured metadata with identical
   * id and key fields are considered equivalent.
   *
   * @generated from field: string id = 4;
   */
  id: string;

  /**
   * The type of data. Possible types include: Integer, Float,
   * Flag, Character, and String.
   *
   * @generated from field: google.genomics.v1.VariantSetMetadata.Type type = 5;
   */
  type: VariantSetMetadata_Type;

  /**
   * The number of values that can be included in a field described by this
   * metadata.
   *
   * @generated from field: string number = 8;
   */
  number: string;

  /**
   * A textual description of this metadata.
   *
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * Remaining structured metadata key-value pairs. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 3;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.VariantSetMetadata.
 * Use `create(VariantSetMetadataSchema)` to create a new message.
 */
export const VariantSetMetadataSchema: GenMessage<VariantSetMetadata> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 0);

/**
 * @generated from enum google.genomics.v1.VariantSetMetadata.Type
 */
export enum VariantSetMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: INTEGER = 1;
   */
  INTEGER = 1,

  /**
   * @generated from enum value: FLOAT = 2;
   */
  FLOAT = 2,

  /**
   * @generated from enum value: FLAG = 3;
   */
  FLAG = 3,

  /**
   * @generated from enum value: CHARACTER = 4;
   */
  CHARACTER = 4,

  /**
   * @generated from enum value: STRING = 5;
   */
  STRING = 5,
}

/**
 * Describes the enum google.genomics.v1.VariantSetMetadata.Type.
 */
export const VariantSetMetadata_TypeSchema: GenEnum<VariantSetMetadata_Type> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_variants, 0, 0);

/**
 * A variant set is a collection of call sets and variants. It contains summary
 * statistics of those contents. A variant set belongs to a dataset.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * @generated from message google.genomics.v1.VariantSet
 */
export type VariantSet = Message<"google.genomics.v1.VariantSet"> & {
  /**
   * The dataset to which this variant set belongs.
   *
   * @generated from field: string dataset_id = 1;
   */
  datasetId: string;

  /**
   * The server-generated variant set ID, unique across all variant sets.
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * The reference set to which the variant set is mapped. The reference set
   * describes the alignment provenance of the variant set, while the
   * `referenceBounds` describe the shape of the actual variant data. The
   * reference set's reference names are a superset of those found in the
   * `referenceBounds`.
   *
   * For example, given a variant set that is mapped to the GRCh38 reference set
   * and contains a single variant on reference 'X', `referenceBounds` would
   * contain only an entry for 'X', while the associated reference set
   * enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
   *
   * @generated from field: string reference_set_id = 6;
   */
  referenceSetId: string;

  /**
   * A list of all references used by the variants in a variant set
   * with associated coordinate upper bounds for each one.
   *
   * @generated from field: repeated google.genomics.v1.ReferenceBound reference_bounds = 5;
   */
  referenceBounds: ReferenceBound[];

  /**
   * The metadata associated with this variant set.
   *
   * @generated from field: repeated google.genomics.v1.VariantSetMetadata metadata = 4;
   */
  metadata: VariantSetMetadata[];

  /**
   * User-specified, mutable name.
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * A textual description of this variant set.
   *
   * @generated from field: string description = 8;
   */
  description: string;
};

/**
 * Describes the message google.genomics.v1.VariantSet.
 * Use `create(VariantSetSchema)` to create a new message.
 */
export const VariantSetSchema: GenMessage<VariantSet> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 1);

/**
 * A variant represents a change in DNA sequence relative to a reference
 * sequence. For example, a variant could represent a SNP or an insertion.
 * Variants belong to a variant set.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * Each of the calls on a variant represent a determination of genotype with
 * respect to that variant. For example, a call might assign probability of 0.32
 * to the occurrence of a SNP named rs1234 in a sample named NA12345. A call
 * belongs to a call set, which contains related calls typically from one
 * sample.
 *
 * @generated from message google.genomics.v1.Variant
 */
export type Variant = Message<"google.genomics.v1.Variant"> & {
  /**
   * The ID of the variant set this variant belongs to.
   *
   * @generated from field: string variant_set_id = 15;
   */
  variantSetId: string;

  /**
   * The server-generated variant ID, unique across all variants.
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * Names for the variant, for example a RefSNP ID.
   *
   * @generated from field: repeated string names = 3;
   */
  names: string[];

  /**
   * The date this variant was created, in milliseconds from the epoch.
   *
   * @generated from field: int64 created = 12;
   */
  created: bigint;

  /**
   * The reference on which this variant occurs.
   * (such as `chr20` or `X`)
   *
   * @generated from field: string reference_name = 14;
   */
  referenceName: string;

  /**
   * The position at which this variant occurs (0-based).
   * This corresponds to the first base of the string of reference bases.
   *
   * @generated from field: int64 start = 16;
   */
  start: bigint;

  /**
   * The end position (0-based) of this variant. This corresponds to the first
   * base after the last base in the reference allele. So, the length of
   * the reference allele is (end - start). This is useful for variants
   * that don't explicitly give alternate bases, for example large deletions.
   *
   * @generated from field: int64 end = 13;
   */
  end: bigint;

  /**
   * The reference bases for this variant. They start at the given
   * position.
   *
   * @generated from field: string reference_bases = 6;
   */
  referenceBases: string;

  /**
   * The bases that appear instead of the reference bases.
   *
   * @generated from field: repeated string alternate_bases = 7;
   */
  alternateBases: string[];

  /**
   * A measure of how likely this variant is to be real.
   * A higher value is better.
   *
   * @generated from field: double quality = 8;
   */
  quality: number;

  /**
   * A list of filters (normally quality filters) this variant has failed.
   * `PASS` indicates this variant has passed all filters.
   *
   * @generated from field: repeated string filter = 9;
   */
  filter: string[];

  /**
   * A map of additional variant information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 10;
   */
  info: { [key: string]: ListValue };

  /**
   * The variant calls for this particular variant. Each one represents the
   * determination of genotype with respect to this variant.
   *
   * @generated from field: repeated google.genomics.v1.VariantCall calls = 11;
   */
  calls: VariantCall[];
};

/**
 * Describes the message google.genomics.v1.Variant.
 * Use `create(VariantSchema)` to create a new message.
 */
export const VariantSchema: GenMessage<Variant> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 2);

/**
 * A call represents the determination of genotype with respect to a particular
 * variant. It may include associated information such as quality and phasing.
 * For example, a call might assign a probability of 0.32 to the occurrence of
 * a SNP named rs1234 in a call set with the name NA12345.
 *
 * @generated from message google.genomics.v1.VariantCall
 */
export type VariantCall = Message<"google.genomics.v1.VariantCall"> & {
  /**
   * The ID of the call set this variant call belongs to.
   *
   * @generated from field: string call_set_id = 8;
   */
  callSetId: string;

  /**
   * The name of the call set this variant call belongs to.
   *
   * @generated from field: string call_set_name = 9;
   */
  callSetName: string;

  /**
   * The genotype of this variant call. Each value represents either the value
   * of the `referenceBases` field or a 1-based index into
   * `alternateBases`. If a variant had a `referenceBases`
   * value of `T` and an `alternateBases`
   * value of `["A", "C"]`, and the `genotype` was
   * `[2, 1]`, that would mean the call
   * represented the heterozygous value `CA` for this variant.
   * If the `genotype` was instead `[0, 1]`, the
   * represented value would be `TA`. Ordering of the
   * genotype values is important if the `phaseset` is present.
   * If a genotype is not called (that is, a `.` is present in the
   * GT string) -1 is returned.
   *
   * @generated from field: repeated int32 genotype = 7;
   */
  genotype: number[];

  /**
   * If this field is present, this variant call's genotype ordering implies
   * the phase of the bases and is consistent with any other variant calls in
   * the same reference sequence which have the same phaseset value.
   * When importing data from VCF, if the genotype data was phased but no
   * phase set was specified this field will be set to `*`.
   *
   * @generated from field: string phaseset = 5;
   */
  phaseset: string;

  /**
   * The genotype likelihoods for this variant call. Each array entry
   * represents how likely a specific genotype is for this call. The value
   * ordering is defined by the GL tag in the VCF spec.
   * If Phred-scaled genotype likelihood scores (PL) are available and
   * log10(P) genotype likelihood scores (GL) are not, PL scores are converted
   * to GL scores.  If both are available, PL scores are stored in `info`.
   *
   * @generated from field: repeated double genotype_likelihood = 6;
   */
  genotypeLikelihood: number[];

  /**
   * A map of additional variant call information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 2;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.VariantCall.
 * Use `create(VariantCallSchema)` to create a new message.
 */
export const VariantCallSchema: GenMessage<VariantCall> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 3);

/**
 * A call set is a collection of variant calls, typically for one sample. It
 * belongs to a variant set.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * @generated from message google.genomics.v1.CallSet
 */
export type CallSet = Message<"google.genomics.v1.CallSet"> & {
  /**
   * The server-generated call set ID, unique across all call sets.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The call set name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The sample ID this call set corresponds to.
   *
   * @generated from field: string sample_id = 7;
   */
  sampleId: string;

  /**
   * The IDs of the variant sets this call set belongs to. This field must
   * have exactly length one, as a call set belongs to a single variant set.
   * This field is repeated for compatibility with the
   * [GA4GH 0.5.1
   * API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
   *
   * @generated from field: repeated string variant_set_ids = 6;
   */
  variantSetIds: string[];

  /**
   * The date this call set was created in milliseconds from the epoch.
   *
   * @generated from field: int64 created = 5;
   */
  created: bigint;

  /**
   * A map of additional call set information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 4;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.CallSet.
 * Use `create(CallSetSchema)` to create a new message.
 */
export const CallSetSchema: GenMessage<CallSet> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 4);

/**
 * ReferenceBound records an upper bound for the starting coordinate of
 * variants in a particular reference.
 *
 * @generated from message google.genomics.v1.ReferenceBound
 */
export type ReferenceBound = Message<"google.genomics.v1.ReferenceBound"> & {
  /**
   * The name of the reference associated with this reference bound.
   *
   * @generated from field: string reference_name = 1;
   */
  referenceName: string;

  /**
   * An upper bound (inclusive) on the starting coordinate of any
   * variant in the reference sequence.
   *
   * @generated from field: int64 upper_bound = 2;
   */
  upperBound: bigint;
};

/**
 * Describes the message google.genomics.v1.ReferenceBound.
 * Use `create(ReferenceBoundSchema)` to create a new message.
 */
export const ReferenceBoundSchema: GenMessage<ReferenceBound> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 5);

/**
 * The variant data import request.
 *
 * @generated from message google.genomics.v1.ImportVariantsRequest
 */
export type ImportVariantsRequest = Message<"google.genomics.v1.ImportVariantsRequest"> & {
  /**
   * Required. The variant set to which variant data should be imported.
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;

  /**
   * A list of URIs referencing variant files in Google Cloud Storage. URIs can
   * include wildcards [as described
   * here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
   * Note that recursive wildcards ('**') are not supported.
   *
   * @generated from field: repeated string source_uris = 2;
   */
  sourceUris: string[];

  /**
   * The format of the variant data being imported. If unspecified, defaults to
   * to `VCF`.
   *
   * @generated from field: google.genomics.v1.ImportVariantsRequest.Format format = 3;
   */
  format: ImportVariantsRequest_Format;

  /**
   * Convert reference names to the canonical representation.
   * hg19 haploytypes (those reference names containing "_hap")
   * are not modified in any way.
   * All other reference names are modified according to the following rules:
   * The reference name is capitalized.
   * The "chr" prefix is dropped for all autosomes and sex chromsomes.
   * For example "chr17" becomes "17" and "chrX" becomes "X".
   * All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
   *
   * @generated from field: bool normalize_reference_names = 5;
   */
  normalizeReferenceNames: boolean;

  /**
   * A mapping between info field keys and the InfoMergeOperations to
   * be performed on them. This is plumbed down to the MergeVariantRequests
   * generated by the resulting import job.
   *
   * @generated from field: map<string, google.genomics.v1.InfoMergeOperation> info_merge_config = 6;
   */
  infoMergeConfig: { [key: string]: InfoMergeOperation };
};

/**
 * Describes the message google.genomics.v1.ImportVariantsRequest.
 * Use `create(ImportVariantsRequestSchema)` to create a new message.
 */
export const ImportVariantsRequestSchema: GenMessage<ImportVariantsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 6);

/**
 * @generated from enum google.genomics.v1.ImportVariantsRequest.Format
 */
export enum ImportVariantsRequest_Format {
  /**
   * @generated from enum value: FORMAT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * VCF (Variant Call Format). The VCF files may be gzip compressed. gVCF is
   * also supported.
   *
   * @generated from enum value: FORMAT_VCF = 1;
   */
  VCF = 1,

  /**
   * Complete Genomics masterVarBeta format. The masterVarBeta files may
   * be bzip2 compressed.
   *
   * @generated from enum value: FORMAT_COMPLETE_GENOMICS = 2;
   */
  COMPLETE_GENOMICS = 2,
}

/**
 * Describes the enum google.genomics.v1.ImportVariantsRequest.Format.
 */
export const ImportVariantsRequest_FormatSchema: GenEnum<ImportVariantsRequest_Format> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_variants, 6, 0);

/**
 * The variant data import response.
 *
 * @generated from message google.genomics.v1.ImportVariantsResponse
 */
export type ImportVariantsResponse = Message<"google.genomics.v1.ImportVariantsResponse"> & {
  /**
   * IDs of the call sets created during the import.
   *
   * @generated from field: repeated string call_set_ids = 1;
   */
  callSetIds: string[];
};

/**
 * Describes the message google.genomics.v1.ImportVariantsResponse.
 * Use `create(ImportVariantsResponseSchema)` to create a new message.
 */
export const ImportVariantsResponseSchema: GenMessage<ImportVariantsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 7);

/**
 * The CreateVariantSet request
 *
 * @generated from message google.genomics.v1.CreateVariantSetRequest
 */
export type CreateVariantSetRequest = Message<"google.genomics.v1.CreateVariantSetRequest"> & {
  /**
   * Required. The variant set to be created. Must have a valid `datasetId`.
   *
   * @generated from field: google.genomics.v1.VariantSet variant_set = 1;
   */
  variantSet?: VariantSet;
};

/**
 * Describes the message google.genomics.v1.CreateVariantSetRequest.
 * Use `create(CreateVariantSetRequestSchema)` to create a new message.
 */
export const CreateVariantSetRequestSchema: GenMessage<CreateVariantSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 8);

/**
 * The variant data export request.
 *
 * @generated from message google.genomics.v1.ExportVariantSetRequest
 */
export type ExportVariantSetRequest = Message<"google.genomics.v1.ExportVariantSetRequest"> & {
  /**
   * Required. The ID of the variant set that contains variant data which
   * should be exported. The caller must have READ access to this variant set.
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;

  /**
   * If provided, only variant call information from the specified call sets
   * will be exported. By default all variant calls are exported.
   *
   * @generated from field: repeated string call_set_ids = 2;
   */
  callSetIds: string[];

  /**
   * Required. The Google Cloud project ID that owns the destination
   * BigQuery dataset. The caller must have WRITE access to this project.  This
   * project will also own the resulting export job.
   *
   * @generated from field: string project_id = 3;
   */
  projectId: string;

  /**
   * The format for the exported data.
   *
   * @generated from field: google.genomics.v1.ExportVariantSetRequest.Format format = 4;
   */
  format: ExportVariantSetRequest_Format;

  /**
   * Required. The BigQuery dataset to export data to. This dataset must already
   * exist. Note that this is distinct from the Genomics concept of "dataset".
   *
   * @generated from field: string bigquery_dataset = 5;
   */
  bigqueryDataset: string;

  /**
   * Required. The BigQuery table to export data to.
   * If the table doesn't exist, it will be created. If it already exists, it
   * will be overwritten.
   *
   * @generated from field: string bigquery_table = 6;
   */
  bigqueryTable: string;
};

/**
 * Describes the message google.genomics.v1.ExportVariantSetRequest.
 * Use `create(ExportVariantSetRequestSchema)` to create a new message.
 */
export const ExportVariantSetRequestSchema: GenMessage<ExportVariantSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 9);

/**
 * @generated from enum google.genomics.v1.ExportVariantSetRequest.Format
 */
export enum ExportVariantSetRequest_Format {
  /**
   * @generated from enum value: FORMAT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Export the data to Google BigQuery.
   *
   * @generated from enum value: FORMAT_BIGQUERY = 1;
   */
  BIGQUERY = 1,
}

/**
 * Describes the enum google.genomics.v1.ExportVariantSetRequest.Format.
 */
export const ExportVariantSetRequest_FormatSchema: GenEnum<ExportVariantSetRequest_Format> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_variants, 9, 0);

/**
 * The variant set request.
 *
 * @generated from message google.genomics.v1.GetVariantSetRequest
 */
export type GetVariantSetRequest = Message<"google.genomics.v1.GetVariantSetRequest"> & {
  /**
   * Required. The ID of the variant set.
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;
};

/**
 * Describes the message google.genomics.v1.GetVariantSetRequest.
 * Use `create(GetVariantSetRequestSchema)` to create a new message.
 */
export const GetVariantSetRequestSchema: GenMessage<GetVariantSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 10);

/**
 * The search variant sets request.
 *
 * @generated from message google.genomics.v1.SearchVariantSetsRequest
 */
export type SearchVariantSetsRequest = Message<"google.genomics.v1.SearchVariantSetsRequest"> & {
  /**
   * Exactly one dataset ID must be provided here. Only variant sets which
   * belong to this dataset will be returned.
   *
   * @generated from field: repeated string dataset_ids = 1;
   */
  datasetIds: string[];

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;
};

/**
 * Describes the message google.genomics.v1.SearchVariantSetsRequest.
 * Use `create(SearchVariantSetsRequestSchema)` to create a new message.
 */
export const SearchVariantSetsRequestSchema: GenMessage<SearchVariantSetsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 11);

/**
 * The search variant sets response.
 *
 * @generated from message google.genomics.v1.SearchVariantSetsResponse
 */
export type SearchVariantSetsResponse = Message<"google.genomics.v1.SearchVariantSetsResponse"> & {
  /**
   * The variant sets belonging to the requested dataset.
   *
   * @generated from field: repeated google.genomics.v1.VariantSet variant_sets = 1;
   */
  variantSets: VariantSet[];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.genomics.v1.SearchVariantSetsResponse.
 * Use `create(SearchVariantSetsResponseSchema)` to create a new message.
 */
export const SearchVariantSetsResponseSchema: GenMessage<SearchVariantSetsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 12);

/**
 * The delete variant set request.
 *
 * @generated from message google.genomics.v1.DeleteVariantSetRequest
 */
export type DeleteVariantSetRequest = Message<"google.genomics.v1.DeleteVariantSetRequest"> & {
  /**
   * The ID of the variant set to be deleted.
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;
};

/**
 * Describes the message google.genomics.v1.DeleteVariantSetRequest.
 * Use `create(DeleteVariantSetRequestSchema)` to create a new message.
 */
export const DeleteVariantSetRequestSchema: GenMessage<DeleteVariantSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 13);

/**
 * @generated from message google.genomics.v1.UpdateVariantSetRequest
 */
export type UpdateVariantSetRequest = Message<"google.genomics.v1.UpdateVariantSetRequest"> & {
  /**
   * The ID of the variant to be updated (must already exist).
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;

  /**
   * The new variant data. Only the variant_set.metadata will be considered
   * for update.
   *
   * @generated from field: google.genomics.v1.VariantSet variant_set = 2;
   */
  variantSet?: VariantSet;

  /**
   * An optional mask specifying which fields to update. Supported fields:
   *
   * * [metadata][google.genomics.v1.VariantSet.metadata].
   * * [name][google.genomics.v1.VariantSet.name].
   * * [description][google.genomics.v1.VariantSet.description].
   *
   * Leaving `updateMask` unset is equivalent to specifying all mutable
   * fields.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.genomics.v1.UpdateVariantSetRequest.
 * Use `create(UpdateVariantSetRequestSchema)` to create a new message.
 */
export const UpdateVariantSetRequestSchema: GenMessage<UpdateVariantSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 14);

/**
 * The variant search request.
 *
 * @generated from message google.genomics.v1.SearchVariantsRequest
 */
export type SearchVariantsRequest = Message<"google.genomics.v1.SearchVariantsRequest"> & {
  /**
   * At most one variant set ID must be provided. Only variants from this
   * variant set will be returned. If omitted, a call set id must be included in
   * the request.
   *
   * @generated from field: repeated string variant_set_ids = 1;
   */
  variantSetIds: string[];

  /**
   * Only return variants which have exactly this name.
   *
   * @generated from field: string variant_name = 2;
   */
  variantName: string;

  /**
   * Only return variant calls which belong to call sets with these ids.
   * Leaving this blank returns all variant calls. If a variant has no
   * calls belonging to any of these call sets, it won't be returned at all.
   *
   * @generated from field: repeated string call_set_ids = 3;
   */
  callSetIds: string[];

  /**
   * Required. Only return variants in this reference sequence.
   *
   * @generated from field: string reference_name = 4;
   */
  referenceName: string;

  /**
   * The beginning of the window (0-based, inclusive) for which
   * overlapping variants should be returned. If unspecified, defaults to 0.
   *
   * @generated from field: int64 start = 5;
   */
  start: bigint;

  /**
   * The end of the window, 0-based exclusive. If unspecified or 0, defaults to
   * the length of the reference.
   *
   * @generated from field: int64 end = 6;
   */
  end: bigint;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 7;
   */
  pageToken: string;

  /**
   * The maximum number of variants to return in a single page. If unspecified,
   * defaults to 5000. The maximum value is 10000.
   *
   * @generated from field: int32 page_size = 8;
   */
  pageSize: number;

  /**
   * The maximum number of calls to return in a single page. Note that this
   * limit may be exceeded in the event that a matching variant contains more
   * calls than the requested maximum. If unspecified, defaults to 5000. The
   * maximum value is 10000.
   *
   * @generated from field: int32 max_calls = 9;
   */
  maxCalls: number;
};

/**
 * Describes the message google.genomics.v1.SearchVariantsRequest.
 * Use `create(SearchVariantsRequestSchema)` to create a new message.
 */
export const SearchVariantsRequestSchema: GenMessage<SearchVariantsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 15);

/**
 * The variant search response.
 *
 * @generated from message google.genomics.v1.SearchVariantsResponse
 */
export type SearchVariantsResponse = Message<"google.genomics.v1.SearchVariantsResponse"> & {
  /**
   * The list of matching Variants.
   *
   * @generated from field: repeated google.genomics.v1.Variant variants = 1;
   */
  variants: Variant[];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.genomics.v1.SearchVariantsResponse.
 * Use `create(SearchVariantsResponseSchema)` to create a new message.
 */
export const SearchVariantsResponseSchema: GenMessage<SearchVariantsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 16);

/**
 * @generated from message google.genomics.v1.CreateVariantRequest
 */
export type CreateVariantRequest = Message<"google.genomics.v1.CreateVariantRequest"> & {
  /**
   * The variant to be created.
   *
   * @generated from field: google.genomics.v1.Variant variant = 1;
   */
  variant?: Variant;
};

/**
 * Describes the message google.genomics.v1.CreateVariantRequest.
 * Use `create(CreateVariantRequestSchema)` to create a new message.
 */
export const CreateVariantRequestSchema: GenMessage<CreateVariantRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 17);

/**
 * @generated from message google.genomics.v1.UpdateVariantRequest
 */
export type UpdateVariantRequest = Message<"google.genomics.v1.UpdateVariantRequest"> & {
  /**
   * The ID of the variant to be updated.
   *
   * @generated from field: string variant_id = 1;
   */
  variantId: string;

  /**
   * The new variant data.
   *
   * @generated from field: google.genomics.v1.Variant variant = 2;
   */
  variant?: Variant;

  /**
   * An optional mask specifying which fields to update. At this time, mutable
   * fields are [names][google.genomics.v1.Variant.names] and
   * [info][google.genomics.v1.Variant.info]. Acceptable values are "names" and
   * "info". If unspecified, all mutable fields will be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.genomics.v1.UpdateVariantRequest.
 * Use `create(UpdateVariantRequestSchema)` to create a new message.
 */
export const UpdateVariantRequestSchema: GenMessage<UpdateVariantRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 18);

/**
 * @generated from message google.genomics.v1.DeleteVariantRequest
 */
export type DeleteVariantRequest = Message<"google.genomics.v1.DeleteVariantRequest"> & {
  /**
   * The ID of the variant to be deleted.
   *
   * @generated from field: string variant_id = 1;
   */
  variantId: string;
};

/**
 * Describes the message google.genomics.v1.DeleteVariantRequest.
 * Use `create(DeleteVariantRequestSchema)` to create a new message.
 */
export const DeleteVariantRequestSchema: GenMessage<DeleteVariantRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 19);

/**
 * @generated from message google.genomics.v1.GetVariantRequest
 */
export type GetVariantRequest = Message<"google.genomics.v1.GetVariantRequest"> & {
  /**
   * The ID of the variant.
   *
   * @generated from field: string variant_id = 1;
   */
  variantId: string;
};

/**
 * Describes the message google.genomics.v1.GetVariantRequest.
 * Use `create(GetVariantRequestSchema)` to create a new message.
 */
export const GetVariantRequestSchema: GenMessage<GetVariantRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 20);

/**
 * @generated from message google.genomics.v1.MergeVariantsRequest
 */
export type MergeVariantsRequest = Message<"google.genomics.v1.MergeVariantsRequest"> & {
  /**
   * The destination variant set.
   *
   * @generated from field: string variant_set_id = 1;
   */
  variantSetId: string;

  /**
   * The variants to be merged with existing variants.
   *
   * @generated from field: repeated google.genomics.v1.Variant variants = 2;
   */
  variants: Variant[];

  /**
   * A mapping between info field keys and the InfoMergeOperations to
   * be performed on them.
   *
   * @generated from field: map<string, google.genomics.v1.InfoMergeOperation> info_merge_config = 3;
   */
  infoMergeConfig: { [key: string]: InfoMergeOperation };
};

/**
 * Describes the message google.genomics.v1.MergeVariantsRequest.
 * Use `create(MergeVariantsRequestSchema)` to create a new message.
 */
export const MergeVariantsRequestSchema: GenMessage<MergeVariantsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 21);

/**
 * The call set search request.
 *
 * @generated from message google.genomics.v1.SearchCallSetsRequest
 */
export type SearchCallSetsRequest = Message<"google.genomics.v1.SearchCallSetsRequest"> & {
  /**
   * Restrict the query to call sets within the given variant sets. At least one
   * ID must be provided.
   *
   * @generated from field: repeated string variant_set_ids = 1;
   */
  variantSetIds: string[];

  /**
   * Only return call sets for which a substring of the name matches this
   * string.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize: number;
};

/**
 * Describes the message google.genomics.v1.SearchCallSetsRequest.
 * Use `create(SearchCallSetsRequestSchema)` to create a new message.
 */
export const SearchCallSetsRequestSchema: GenMessage<SearchCallSetsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 22);

/**
 * The call set search response.
 *
 * @generated from message google.genomics.v1.SearchCallSetsResponse
 */
export type SearchCallSetsResponse = Message<"google.genomics.v1.SearchCallSetsResponse"> & {
  /**
   * The list of matching call sets.
   *
   * @generated from field: repeated google.genomics.v1.CallSet call_sets = 1;
   */
  callSets: CallSet[];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.genomics.v1.SearchCallSetsResponse.
 * Use `create(SearchCallSetsResponseSchema)` to create a new message.
 */
export const SearchCallSetsResponseSchema: GenMessage<SearchCallSetsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 23);

/**
 * @generated from message google.genomics.v1.CreateCallSetRequest
 */
export type CreateCallSetRequest = Message<"google.genomics.v1.CreateCallSetRequest"> & {
  /**
   * The call set to be created.
   *
   * @generated from field: google.genomics.v1.CallSet call_set = 1;
   */
  callSet?: CallSet;
};

/**
 * Describes the message google.genomics.v1.CreateCallSetRequest.
 * Use `create(CreateCallSetRequestSchema)` to create a new message.
 */
export const CreateCallSetRequestSchema: GenMessage<CreateCallSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 24);

/**
 * @generated from message google.genomics.v1.UpdateCallSetRequest
 */
export type UpdateCallSetRequest = Message<"google.genomics.v1.UpdateCallSetRequest"> & {
  /**
   * The ID of the call set to be updated.
   *
   * @generated from field: string call_set_id = 1;
   */
  callSetId: string;

  /**
   * The new call set data.
   *
   * @generated from field: google.genomics.v1.CallSet call_set = 2;
   */
  callSet?: CallSet;

  /**
   * An optional mask specifying which fields to update. At this time, the only
   * mutable field is [name][google.genomics.v1.CallSet.name]. The only
   * acceptable value is "name". If unspecified, all mutable fields will be
   * updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.genomics.v1.UpdateCallSetRequest.
 * Use `create(UpdateCallSetRequestSchema)` to create a new message.
 */
export const UpdateCallSetRequestSchema: GenMessage<UpdateCallSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 25);

/**
 * @generated from message google.genomics.v1.DeleteCallSetRequest
 */
export type DeleteCallSetRequest = Message<"google.genomics.v1.DeleteCallSetRequest"> & {
  /**
   * The ID of the call set to be deleted.
   *
   * @generated from field: string call_set_id = 1;
   */
  callSetId: string;
};

/**
 * Describes the message google.genomics.v1.DeleteCallSetRequest.
 * Use `create(DeleteCallSetRequestSchema)` to create a new message.
 */
export const DeleteCallSetRequestSchema: GenMessage<DeleteCallSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 26);

/**
 * @generated from message google.genomics.v1.GetCallSetRequest
 */
export type GetCallSetRequest = Message<"google.genomics.v1.GetCallSetRequest"> & {
  /**
   * The ID of the call set.
   *
   * @generated from field: string call_set_id = 1;
   */
  callSetId: string;
};

/**
 * Describes the message google.genomics.v1.GetCallSetRequest.
 * Use `create(GetCallSetRequestSchema)` to create a new message.
 */
export const GetCallSetRequestSchema: GenMessage<GetCallSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 27);

/**
 * The stream variants request.
 *
 * @generated from message google.genomics.v1.StreamVariantsRequest
 */
export type StreamVariantsRequest = Message<"google.genomics.v1.StreamVariantsRequest"> & {
  /**
   * The Google Cloud project ID which will be billed
   * for this access. The caller must have WRITE access to this project.
   * Required.
   *
   * @generated from field: string project_id = 1;
   */
  projectId: string;

  /**
   * The variant set ID from which to stream variants.
   *
   * @generated from field: string variant_set_id = 2;
   */
  variantSetId: string;

  /**
   * Only return variant calls which belong to call sets with these IDs.
   * Leaving this blank returns all variant calls.
   *
   * @generated from field: repeated string call_set_ids = 3;
   */
  callSetIds: string[];

  /**
   * Required. Only return variants in this reference sequence.
   *
   * @generated from field: string reference_name = 4;
   */
  referenceName: string;

  /**
   * The beginning of the window (0-based, inclusive) for which
   * overlapping variants should be returned.
   *
   * @generated from field: int64 start = 5;
   */
  start: bigint;

  /**
   * The end of the window (0-based, exclusive) for which overlapping
   * variants should be returned.
   *
   * @generated from field: int64 end = 6;
   */
  end: bigint;
};

/**
 * Describes the message google.genomics.v1.StreamVariantsRequest.
 * Use `create(StreamVariantsRequestSchema)` to create a new message.
 */
export const StreamVariantsRequestSchema: GenMessage<StreamVariantsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 28);

/**
 * @generated from message google.genomics.v1.StreamVariantsResponse
 */
export type StreamVariantsResponse = Message<"google.genomics.v1.StreamVariantsResponse"> & {
  /**
   * @generated from field: repeated google.genomics.v1.Variant variants = 1;
   */
  variants: Variant[];
};

/**
 * Describes the message google.genomics.v1.StreamVariantsResponse.
 * Use `create(StreamVariantsResponseSchema)` to create a new message.
 */
export const StreamVariantsResponseSchema: GenMessage<StreamVariantsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_variants, 29);

/**
 * Operations to be performed during import on Variant info fields.
 * These operations are set for each info field in the info_merge_config
 * map of ImportVariantsRequest, which is plumbed down to the
 * MergeVariantRequests generated by the import job.
 *
 * @generated from enum google.genomics.v1.InfoMergeOperation
 */
export enum InfoMergeOperation {
  /**
   * @generated from enum value: INFO_MERGE_OPERATION_UNSPECIFIED = 0;
   */
  INFO_MERGE_OPERATION_UNSPECIFIED = 0,

  /**
   * By default, Variant info fields are persisted if the Variant doesn't
   * already exist in the variantset.  If the Variant is equivalent to a
   * Variant already in the variantset, the incoming Variant's info field
   * is ignored in favor of that of the already persisted Variant.
   *
   * @generated from enum value: IGNORE_NEW = 1;
   */
  IGNORE_NEW = 1,

  /**
   * This operation removes an info field from the incoming Variant
   * and persists this info field in each of the incoming Variant's Calls.
   *
   * @generated from enum value: MOVE_TO_CALLS = 2;
   */
  MOVE_TO_CALLS = 2,
}

/**
 * Describes the enum google.genomics.v1.InfoMergeOperation.
 */
export const InfoMergeOperationSchema: GenEnum<InfoMergeOperation> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_variants, 0);

/**
 * @generated from service google.genomics.v1.StreamingVariantService
 */
export const StreamingVariantService: GenService<{
  /**
   * Returns a stream of all the variants matching the search request, ordered
   * by reference name, position, and ID.
   *
   * @generated from rpc google.genomics.v1.StreamingVariantService.StreamVariants
   */
  streamVariants: {
    methodKind: "server_streaming";
    input: typeof StreamVariantsRequestSchema;
    output: typeof StreamVariantsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_genomics_v1_variants, 0);

/**
 * @generated from service google.genomics.v1.VariantServiceV1
 */
export const VariantServiceV1: GenService<{
  /**
   * Creates variant data by asynchronously importing the provided information.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The variants for import will be merged with any existing variant that
   * matches its reference sequence, start, end, reference bases, and
   * alternative bases. If no such variant exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant, and Variant info fields are merged
   * as specified in
   * [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
   * As a special case, for single-sample VCF files, QUAL and FILTER fields will
   * be moved to the call level; these are sometimes interpreted in a
   * call-specific context.
   * Imported VCF headers are appended to the metadata already in a variant set.
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.ImportVariants
   */
  importVariants: {
    methodKind: "unary";
    input: typeof ImportVariantsRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Creates a new variant set.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * The provided variant set must have a valid `datasetId` set - all other
   * fields are optional. Note that the `id` field will be ignored, as this is
   * assigned by the server.
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.CreateVariantSet
   */
  createVariantSet: {
    methodKind: "unary";
    input: typeof CreateVariantSetRequestSchema;
    output: typeof VariantSetSchema;
  },
  /**
   * Exports variant set data to an external destination.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.ExportVariantSet
   */
  exportVariantSet: {
    methodKind: "unary";
    input: typeof ExportVariantSetRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Gets a variant set by ID.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.GetVariantSet
   */
  getVariantSet: {
    methodKind: "unary";
    input: typeof GetVariantSetRequestSchema;
    output: typeof VariantSetSchema;
  },
  /**
   * Returns a list of all variant sets matching search criteria.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.SearchVariantSets
   */
  searchVariantSets: {
    methodKind: "unary";
    input: typeof SearchVariantSetsRequestSchema;
    output: typeof SearchVariantSetsResponseSchema;
  },
  /**
   * Deletes a variant set including all variants, call sets, and calls within.
   * This is not reversible.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.DeleteVariantSet
   */
  deleteVariantSet: {
    methodKind: "unary";
    input: typeof DeleteVariantSetRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Updates a variant set using patch semantics.
   *
   * For the definitions of variant sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.UpdateVariantSet
   */
  updateVariantSet: {
    methodKind: "unary";
    input: typeof UpdateVariantSetRequestSchema;
    output: typeof VariantSetSchema;
  },
  /**
   * Gets a list of variants matching the criteria.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.SearchVariants
   */
  searchVariants: {
    methodKind: "unary";
    input: typeof SearchVariantsRequestSchema;
    output: typeof SearchVariantsResponseSchema;
  },
  /**
   * Creates a new variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.CreateVariant
   */
  createVariant: {
    methodKind: "unary";
    input: typeof CreateVariantRequestSchema;
    output: typeof VariantSchema;
  },
  /**
   * Updates a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics. Returns the modified variant without
   * its calls.
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.UpdateVariant
   */
  updateVariant: {
    methodKind: "unary";
    input: typeof UpdateVariantRequestSchema;
    output: typeof VariantSchema;
  },
  /**
   * Deletes a variant.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.DeleteVariant
   */
  deleteVariant: {
    methodKind: "unary";
    input: typeof DeleteVariantRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets a variant by ID.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.GetVariant
   */
  getVariant: {
    methodKind: "unary";
    input: typeof GetVariantRequestSchema;
    output: typeof VariantSchema;
  },
  /**
   * Merges the given variants with existing variants.
   *
   * For the definitions of variants and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Each variant will be
   * merged with an existing variant that matches its reference sequence,
   * start, end, reference bases, and alternative bases. If no such variant
   * exists, a new one will be created.
   *
   * When variants are merged, the call information from the new variant
   * is added to the existing variant. Variant info fields are merged as
   * specified in the
   * [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
   * field of the MergeVariantsRequest.
   *
   * Please exercise caution when using this method!  It is easy to introduce
   * mistakes in existing variants and difficult to back out of them.  For
   * example,
   * suppose you were trying to merge a new variant with an existing one and
   * both
   * variants contain calls that belong to callsets with the same callset ID.
   *
   *     // Existing variant - irrelevant fields trimmed for clarity
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     0,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   *     // New variant with conflicting call information
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * The resulting merged variant would overwrite the existing calls with those
   * from the new variant:
   *
   *     {
   *         "variantSetId": "10473108253681171589",
   *         "referenceName": "1",
   *         "start": "10582",
   *         "referenceBases": "G",
   *         "alternateBases": [
   *             "A"
   *         ],
   *         "calls": [
   *             {
   *                 "callSetId": "10473108253681171589-0",
   *                 "callSetName": "CALLSET0",
   *                 "genotype": [
   *                     1,
   *                     1
   *                 ],
   *             }
   *         ]
   *     }
   *
   * This may be the desired outcome, but it is up to the user to determine if
   * if that is indeed the case.
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.MergeVariants
   */
  mergeVariants: {
    methodKind: "unary";
    input: typeof MergeVariantsRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets a list of call sets matching the criteria.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * Implements
   * [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.SearchCallSets
   */
  searchCallSets: {
    methodKind: "unary";
    input: typeof SearchCallSetsRequestSchema;
    output: typeof SearchCallSetsResponseSchema;
  },
  /**
   * Creates a new call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.CreateCallSet
   */
  createCallSet: {
    methodKind: "unary";
    input: typeof CreateCallSetRequestSchema;
    output: typeof CallSetSchema;
  },
  /**
   * Updates a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics.
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.UpdateCallSet
   */
  updateCallSet: {
    methodKind: "unary";
    input: typeof UpdateCallSetRequestSchema;
    output: typeof CallSetSchema;
  },
  /**
   * Deletes a call set.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.DeleteCallSet
   */
  deleteCallSet: {
    methodKind: "unary";
    input: typeof DeleteCallSetRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets a call set by ID.
   *
   * For the definitions of call sets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * @generated from rpc google.genomics.v1.VariantServiceV1.GetCallSet
   */
  getCallSet: {
    methodKind: "unary";
    input: typeof GetCallSetRequestSchema;
    output: typeof CallSetSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_genomics_v1_variants, 1);

