// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/genomics/v1/readalignment.proto (package google.genomics.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import type { CigarUnit } from "./cigar_pb";
import { file_google_genomics_v1_cigar } from "./cigar_pb";
import type { Position } from "./position_pb";
import { file_google_genomics_v1_position } from "./position_pb";
import type { ListValue } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_struct } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/genomics/v1/readalignment.proto.
 */
export const file_google_genomics_v1_readalignment: GenFile = /*@__PURE__*/
  fileDesc("CiZnb29nbGUvZ2Vub21pY3MvdjEvcmVhZGFsaWdubWVudC5wcm90bxISZ29vZ2xlLmdlbm9taWNzLnYxIogBCg9MaW5lYXJBbGlnbm1lbnQSLgoIcG9zaXRpb24YASABKAsyHC5nb29nbGUuZ2Vub21pY3MudjEuUG9zaXRpb24SFwoPbWFwcGluZ19xdWFsaXR5GAIgASgFEiwKBWNpZ2FyGAMgAygLMh0uZ29vZ2xlLmdlbm9taWNzLnYxLkNpZ2FyVW5pdCLZBAoEUmVhZBIKCgJpZBgBIAEoCRIVCg1yZWFkX2dyb3VwX2lkGAIgASgJEhkKEXJlYWRfZ3JvdXBfc2V0X2lkGAMgASgJEhUKDWZyYWdtZW50X25hbWUYBCABKAkSGAoQcHJvcGVyX3BsYWNlbWVudBgFIAEoCBIaChJkdXBsaWNhdGVfZnJhZ21lbnQYBiABKAgSFwoPZnJhZ21lbnRfbGVuZ3RoGAcgASgFEhMKC3JlYWRfbnVtYmVyGAggASgFEhQKDG51bWJlcl9yZWFkcxgJIAEoBRIkChxmYWlsZWRfdmVuZG9yX3F1YWxpdHlfY2hlY2tzGAogASgIEjYKCWFsaWdubWVudBgLIAEoCzIjLmdvb2dsZS5nZW5vbWljcy52MS5MaW5lYXJBbGlnbm1lbnQSGwoTc2Vjb25kYXJ5X2FsaWdubWVudBgMIAEoCBIfChdzdXBwbGVtZW50YXJ5X2FsaWdubWVudBgNIAEoCBIYChBhbGlnbmVkX3NlcXVlbmNlGA4gASgJEhcKD2FsaWduZWRfcXVhbGl0eRgPIAMoBRI4ChJuZXh0X21hdGVfcG9zaXRpb24YECABKAsyHC5nb29nbGUuZ2Vub21pY3MudjEuUG9zaXRpb24SMAoEaW5mbxgRIAMoCzIiLmdvb2dsZS5nZW5vbWljcy52MS5SZWFkLkluZm9FbnRyeRpHCglJbmZvRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZToCOAFCbQoWY29tLmdvb2dsZS5nZW5vbWljcy52MUISUmVhZEFsaWdubWVudFByb3RvUAFaOmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvZ2Vub21pY3MvdjE7Z2Vub21pY3P4AQFiBnByb3RvMw", [file_google_api_annotations, file_google_genomics_v1_cigar, file_google_genomics_v1_position, file_google_protobuf_struct]);

/**
 * A linear alignment can be represented by one CIGAR string. Describes the
 * mapped position and local alignment of the read to the reference.
 *
 * @generated from message google.genomics.v1.LinearAlignment
 */
export type LinearAlignment = Message<"google.genomics.v1.LinearAlignment"> & {
  /**
   * The position of this alignment.
   *
   * @generated from field: google.genomics.v1.Position position = 1;
   */
  position?: Position;

  /**
   * The mapping quality of this alignment. Represents how likely
   * the read maps to this position as opposed to other locations.
   *
   * Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to
   * the nearest integer.
   *
   * @generated from field: int32 mapping_quality = 2;
   */
  mappingQuality: number;

  /**
   * Represents the local alignment of this sequence (alignment matches, indels,
   * etc) against the reference.
   *
   * @generated from field: repeated google.genomics.v1.CigarUnit cigar = 3;
   */
  cigar: CigarUnit[];
};

/**
 * Describes the message google.genomics.v1.LinearAlignment.
 * Use `create(LinearAlignmentSchema)` to create a new message.
 */
export const LinearAlignmentSchema: GenMessage<LinearAlignment> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_readalignment, 0);

/**
 * A read alignment describes a linear alignment of a string of DNA to a
 * [reference sequence][google.genomics.v1.Reference], in addition to metadata
 * about the fragment (the molecule of DNA sequenced) and the read (the bases
 * which were read by the sequencer). A read is equivalent to a line in a SAM
 * file. A read belongs to exactly one read group and exactly one
 * [read group set][google.genomics.v1.ReadGroupSet].
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * ### Reverse-stranded reads
 *
 * Mapped reads (reads having a non-null `alignment`) can be aligned to either
 * the forward or the reverse strand of their associated reference. Strandedness
 * of a mapped read is encoded by `alignment.position.reverseStrand`.
 *
 * If we consider the reference to be a forward-stranded coordinate space of
 * `[0, reference.length)` with `0` as the left-most position and
 * `reference.length` as the right-most position, reads are always aligned left
 * to right. That is, `alignment.position.position` always refers to the
 * left-most reference coordinate and `alignment.cigar` describes the alignment
 * of this read to the reference from left to right. All per-base fields such as
 * `alignedSequence` and `alignedQuality` share this same left-to-right
 * orientation; this is true of reads which are aligned to either strand. For
 * reverse-stranded reads, this means that `alignedSequence` is the reverse
 * complement of the bases that were originally reported by the sequencing
 * machine.
 *
 * ### Generating a reference-aligned sequence string
 *
 * When interacting with mapped reads, it's often useful to produce a string
 * representing the local alignment of the read to reference. The following
 * pseudocode demonstrates one way of doing this:
 *
 *     out = ""
 *     offset = 0
 *     for c in read.alignment.cigar {
 *       switch c.operation {
 *       case "ALIGNMENT_MATCH", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH":
 *         out += read.alignedSequence[offset:offset+c.operationLength]
 *         offset += c.operationLength
 *         break
 *       case "CLIP_SOFT", "INSERT":
 *         offset += c.operationLength
 *         break
 *       case "PAD":
 *         out += repeat("*", c.operationLength)
 *         break
 *       case "DELETE":
 *         out += repeat("-", c.operationLength)
 *         break
 *       case "SKIP":
 *         out += repeat(" ", c.operationLength)
 *         break
 *       case "CLIP_HARD":
 *         break
 *       }
 *     }
 *     return out
 *
 * ### Converting to SAM's CIGAR string
 *
 * The following pseudocode generates a SAM CIGAR string from the
 * `cigar` field. Note that this is a lossy conversion
 * (`cigar.referenceSequence` is lost).
 *
 *     cigarMap = {
 *       "ALIGNMENT_MATCH": "M",
 *       "INSERT": "I",
 *       "DELETE": "D",
 *       "SKIP": "N",
 *       "CLIP_SOFT": "S",
 *       "CLIP_HARD": "H",
 *       "PAD": "P",
 *       "SEQUENCE_MATCH": "=",
 *       "SEQUENCE_MISMATCH": "X",
 *     }
 *     cigarStr = ""
 *     for c in read.alignment.cigar {
 *       cigarStr += c.operationLength + cigarMap[c.operation]
 *     }
 *     return cigarStr
 *
 * @generated from message google.genomics.v1.Read
 */
export type Read = Message<"google.genomics.v1.Read"> & {
  /**
   * The server-generated read ID, unique across all reads. This is different
   * from the `fragmentName`.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The ID of the read group this read belongs to. A read belongs to exactly
   * one read group. This is a server-generated ID which is distinct from SAM's
   * RG tag (for that value, see
   * [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
   *
   * @generated from field: string read_group_id = 2;
   */
  readGroupId: string;

  /**
   * The ID of the read group set this read belongs to. A read belongs to
   * exactly one read group set.
   *
   * @generated from field: string read_group_set_id = 3;
   */
  readGroupSetId: string;

  /**
   * The fragment name. Equivalent to QNAME (query template name) in SAM.
   *
   * @generated from field: string fragment_name = 4;
   */
  fragmentName: string;

  /**
   * The orientation and the distance between reads from the fragment are
   * consistent with the sequencing protocol (SAM flag 0x2).
   *
   * @generated from field: bool proper_placement = 5;
   */
  properPlacement: boolean;

  /**
   * The fragment is a PCR or optical duplicate (SAM flag 0x400).
   *
   * @generated from field: bool duplicate_fragment = 6;
   */
  duplicateFragment: boolean;

  /**
   * The observed length of the fragment, equivalent to TLEN in SAM.
   *
   * @generated from field: int32 fragment_length = 7;
   */
  fragmentLength: number;

  /**
   * The read number in sequencing. 0-based and less than numberReads. This
   * field replaces SAM flag 0x40 and 0x80.
   *
   * @generated from field: int32 read_number = 8;
   */
  readNumber: number;

  /**
   * The number of reads in the fragment (extension to SAM flag 0x1).
   *
   * @generated from field: int32 number_reads = 9;
   */
  numberReads: number;

  /**
   * Whether this read did not pass filters, such as platform or vendor quality
   * controls (SAM flag 0x200).
   *
   * @generated from field: bool failed_vendor_quality_checks = 10;
   */
  failedVendorQualityChecks: boolean;

  /**
   * The linear alignment for this alignment record. This field is null for
   * unmapped reads.
   *
   * @generated from field: google.genomics.v1.LinearAlignment alignment = 11;
   */
  alignment?: LinearAlignment;

  /**
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
   * A secondary alignment represents an alternative to the primary alignment
   * for this read. Aligners may return secondary alignments if a read can map
   * ambiguously to multiple coordinates in the genome. By convention, each read
   * has one and only one alignment where both `secondaryAlignment`
   * and `supplementaryAlignment` are false.
   *
   * @generated from field: bool secondary_alignment = 12;
   */
  secondaryAlignment: boolean;

  /**
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
   * Supplementary alignments are used in the representation of a chimeric
   * alignment. In a chimeric alignment, a read is split into multiple
   * linear alignments that map to different reference contigs. The first
   * linear alignment in the read will be designated as the representative
   * alignment; the remaining linear alignments will be designated as
   * supplementary alignments. These alignments may have different mapping
   * quality scores. In each linear alignment in a chimeric alignment, the read
   * will be hard clipped. The `alignedSequence` and
   * `alignedQuality` fields in the alignment record will only
   * represent the bases for its respective linear alignment.
   *
   * @generated from field: bool supplementary_alignment = 13;
   */
  supplementaryAlignment: boolean;

  /**
   * The bases of the read sequence contained in this alignment record,
   * **without CIGAR operations applied** (equivalent to SEQ in SAM).
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   *
   * @generated from field: string aligned_sequence = 14;
   */
  alignedSequence: string;

  /**
   * The quality of the read sequence contained in this alignment record
   * (equivalent to QUAL in SAM).
   * `alignedSequence` and `alignedQuality` may be shorter than the full read
   * sequence and quality. This will occur if the alignment is part of a
   * chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
   * for this read will begin/end with a hard clip operator that will indicate
   * the length of the excised sequence.
   *
   * @generated from field: repeated int32 aligned_quality = 15;
   */
  alignedQuality: number[];

  /**
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   *
   * @generated from field: google.genomics.v1.Position next_mate_position = 16;
   */
  nextMatePosition?: Position;

  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 17;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.Read.
 * Use `create(ReadSchema)` to create a new message.
 */
export const ReadSchema: GenMessage<Read> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_readalignment, 1);

