// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/genomics/v1/annotations.proto (package google.genomics.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import type { EmptySchema, FieldMask, ListValue } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_struct, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/genomics/v1/annotations.proto.
 */
export const file_google_genomics_v1_annotations: GenFile = /*@__PURE__*/
  fileDesc("CiRnb29nbGUvZ2Vub21pY3MvdjEvYW5ub3RhdGlvbnMucHJvdG8SEmdvb2dsZS5nZW5vbWljcy52MSKhAgoNQW5ub3RhdGlvblNldBIKCgJpZBgBIAEoCRISCgpkYXRhc2V0X2lkGAIgASgJEhgKEHJlZmVyZW5jZV9zZXRfaWQYAyABKAkSDAoEbmFtZRgEIAEoCRISCgpzb3VyY2VfdXJpGAUgASgJEjAKBHR5cGUYBiABKA4yIi5nb29nbGUuZ2Vub21pY3MudjEuQW5ub3RhdGlvblR5cGUSOQoEaW5mbxgRIAMoCzIrLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0LkluZm9FbnRyeRpHCglJbmZvRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZToCOAEizwMKCkFubm90YXRpb24SCgoCaWQYASABKAkSGQoRYW5ub3RhdGlvbl9zZXRfaWQYAiABKAkSDAoEbmFtZRgDIAEoCRIUCgxyZWZlcmVuY2VfaWQYBCABKAkSFgoOcmVmZXJlbmNlX25hbWUYBSABKAkSDQoFc3RhcnQYBiABKAMSCwoDZW5kGAcgASgDEhYKDnJldmVyc2Vfc3RyYW5kGAggASgIEjAKBHR5cGUYCSABKA4yIi5nb29nbGUuZ2Vub21pY3MudjEuQW5ub3RhdGlvblR5cGUSOAoHdmFyaWFudBgKIAEoCzIlLmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50QW5ub3RhdGlvbkgAEjQKCnRyYW5zY3JpcHQYCyABKAsyHi5nb29nbGUuZ2Vub21pY3MudjEuVHJhbnNjcmlwdEgAEjYKBGluZm8YDCADKAsyKC5nb29nbGUuZ2Vub21pY3MudjEuQW5ub3RhdGlvbi5JbmZvRW50cnkaRwoJSW5mb0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWU6AjgBQgcKBXZhbHVlIvwIChFWYXJpYW50QW5ub3RhdGlvbhI4CgR0eXBlGAEgASgOMiouZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnRBbm5vdGF0aW9uLlR5cGUSPAoGZWZmZWN0GAIgASgOMiwuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnRBbm5vdGF0aW9uLkVmZmVjdBIXCg9hbHRlcm5hdGVfYmFzZXMYAyABKAkSDwoHZ2VuZV9pZBgEIAEoCRIWCg50cmFuc2NyaXB0X2lkcxgFIAMoCRJLCgpjb25kaXRpb25zGAYgAygLMjcuZ29vZ2xlLmdlbm9taWNzLnYxLlZhcmlhbnRBbm5vdGF0aW9uLkNsaW5pY2FsQ29uZGl0aW9uElkKFWNsaW5pY2FsX3NpZ25pZmljYW5jZRgHIAEoDjI6Lmdvb2dsZS5nZW5vbWljcy52MS5WYXJpYW50QW5ub3RhdGlvbi5DbGluaWNhbFNpZ25pZmljYW5jZRp9ChFDbGluaWNhbENvbmRpdGlvbhINCgVuYW1lcxgBIAMoCRI0CgxleHRlcm5hbF9pZHMYAiADKAsyHi5nb29nbGUuZ2Vub21pY3MudjEuRXh0ZXJuYWxJZBISCgpjb25jZXB0X2lkGAMgASgJEg8KB29taW1faWQYBCABKAkifQoEVHlwZRIUChBUWVBFX1VOU1BFQ0lGSUVEEAASDgoKVFlQRV9PVEhFUhABEg0KCUlOU0VSVElPThACEgwKCERFTEVUSU9OEAMSEAoMU1VCU1RJVFVUSU9OEAQSBwoDU05QEAUSDgoKU1RSVUNUVVJBTBAGEgcKA0NOVhAHIsMBCgZFZmZlY3QSFgoSRUZGRUNUX1VOU1BFQ0lGSUVEEAASEAoMRUZGRUNUX09USEVSEAESDgoKRlJBTUVTSElGVBACEhoKFkZSQU1FX1BSRVNFUlZJTkdfSU5ERUwQAxISCg5TWU5PTllNT1VTX1NOUBAEEhUKEU5PTlNZTk9OWU1PVVNfU05QEAUSDQoJU1RPUF9HQUlOEAYSDQoJU1RPUF9MT1NTEAcSGgoWU1BMSUNFX1NJVEVfRElTUlVQVElPThAIIsACChRDbGluaWNhbFNpZ25pZmljYW5jZRIlCiFDTElOSUNBTF9TSUdOSUZJQ0FOQ0VfVU5TUEVDSUZJRUQQABIfChtDTElOSUNBTF9TSUdOSUZJQ0FOQ0VfT1RIRVIQARINCglVTkNFUlRBSU4QAhIKCgZCRU5JR04QAxIRCg1MSUtFTFlfQkVOSUdOEAQSFQoRTElLRUxZX1BBVEhPR0VOSUMQBRIOCgpQQVRIT0dFTklDEAYSEQoNRFJVR19SRVNQT05TRRAHEhYKEkhJU1RPQ09NUEFUSUJJTElUWRAIEhcKE0NPTkZFUlNfU0VOU0lUSVZJVFkQCRIPCgtSSVNLX0ZBQ1RPUhAKEg8KC0FTU09DSUFUSU9OEAsSDgoKUFJPVEVDVElWRRAMEhUKEU1VTFRJUExFX1JFUE9SVEVEEA0ilwIKClRyYW5zY3JpcHQSDwoHZ2VuZV9pZBgBIAEoCRIyCgVleG9ucxgCIAMoCzIjLmdvb2dsZS5nZW5vbWljcy52MS5UcmFuc2NyaXB0LkV4b24SRgoPY29kaW5nX3NlcXVlbmNlGAMgASgLMi0uZ29vZ2xlLmdlbm9taWNzLnYxLlRyYW5zY3JpcHQuQ29kaW5nU2VxdWVuY2UaTgoERXhvbhINCgVzdGFydBgBIAEoAxILCgNlbmQYAiABKAMSKgoFZnJhbWUYAyABKAsyGy5nb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZRosCg5Db2RpbmdTZXF1ZW5jZRINCgVzdGFydBgBIAEoAxILCgNlbmQYAiABKAMiLQoKRXh0ZXJuYWxJZBITCgtzb3VyY2VfbmFtZRgBIAEoCRIKCgJpZBgCIAEoCSJXChpDcmVhdGVBbm5vdGF0aW9uU2V0UmVxdWVzdBI5Cg5hbm5vdGF0aW9uX3NldBgBIAEoCzIhLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0IjQKF0dldEFubm90YXRpb25TZXRSZXF1ZXN0EhkKEWFubm90YXRpb25fc2V0X2lkGAEgASgJIqMBChpVcGRhdGVBbm5vdGF0aW9uU2V0UmVxdWVzdBIZChFhbm5vdGF0aW9uX3NldF9pZBgBIAEoCRI5Cg5hbm5vdGF0aW9uX3NldBgCIAEoCzIhLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0Ei8KC3VwZGF0ZV9tYXNrGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayI3ChpEZWxldGVBbm5vdGF0aW9uU2V0UmVxdWVzdBIZChFhbm5vdGF0aW9uX3NldF9pZBgBIAEoCSK0AQobU2VhcmNoQW5ub3RhdGlvblNldHNSZXF1ZXN0EhMKC2RhdGFzZXRfaWRzGAEgAygJEhgKEHJlZmVyZW5jZV9zZXRfaWQYAiABKAkSDAoEbmFtZRgDIAEoCRIxCgV0eXBlcxgEIAMoDjIiLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uVHlwZRISCgpwYWdlX3Rva2VuGAUgASgJEhEKCXBhZ2Vfc2l6ZRgGIAEoBSJzChxTZWFyY2hBbm5vdGF0aW9uU2V0c1Jlc3BvbnNlEjoKD2Fubm90YXRpb25fc2V0cxgBIAMoCzIhLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0EhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSJNChdDcmVhdGVBbm5vdGF0aW9uUmVxdWVzdBIyCgphbm5vdGF0aW9uGAEgASgLMh4uZ29vZ2xlLmdlbm9taWNzLnYxLkFubm90YXRpb24iaAodQmF0Y2hDcmVhdGVBbm5vdGF0aW9uc1JlcXVlc3QSMwoLYW5ub3RhdGlvbnMYASADKAsyHi5nb29nbGUuZ2Vub21pY3MudjEuQW5ub3RhdGlvbhISCgpyZXF1ZXN0X2lkGAIgASgJIswBCh5CYXRjaENyZWF0ZUFubm90YXRpb25zUmVzcG9uc2USSQoHZW50cmllcxgBIAMoCzI4Lmdvb2dsZS5nZW5vbWljcy52MS5CYXRjaENyZWF0ZUFubm90YXRpb25zUmVzcG9uc2UuRW50cnkaXwoFRW50cnkSIgoGc3RhdHVzGAEgASgLMhIuZ29vZ2xlLnJwYy5TdGF0dXMSMgoKYW5ub3RhdGlvbhgCIAEoCzIeLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uIi0KFEdldEFubm90YXRpb25SZXF1ZXN0EhUKDWFubm90YXRpb25faWQYASABKAkilQEKF1VwZGF0ZUFubm90YXRpb25SZXF1ZXN0EhUKDWFubm90YXRpb25faWQYASABKAkSMgoKYW5ub3RhdGlvbhgCIAEoCzIeLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uEi8KC3VwZGF0ZV9tYXNrGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayIwChdEZWxldGVBbm5vdGF0aW9uUmVxdWVzdBIVCg1hbm5vdGF0aW9uX2lkGAEgASgJIrgBChhTZWFyY2hBbm5vdGF0aW9uc1JlcXVlc3QSGgoSYW5ub3RhdGlvbl9zZXRfaWRzGAEgAygJEhYKDHJlZmVyZW5jZV9pZBgCIAEoCUgAEhgKDnJlZmVyZW5jZV9uYW1lGAMgASgJSAASDQoFc3RhcnQYBCABKAMSCwoDZW5kGAUgASgDEhIKCnBhZ2VfdG9rZW4YBiABKAkSEQoJcGFnZV9zaXplGAcgASgFQgsKCXJlZmVyZW5jZSJpChlTZWFyY2hBbm5vdGF0aW9uc1Jlc3BvbnNlEjMKC2Fubm90YXRpb25zGAEgAygLMh4uZ29vZ2xlLmdlbm9taWNzLnYxLkFubm90YXRpb24SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJKmUKDkFubm90YXRpb25UeXBlEh8KG0FOTk9UQVRJT05fVFlQRV9VTlNQRUNJRklFRBAAEgsKB0dFTkVSSUMQARILCgdWQVJJQU5UEAISCAoER0VORRADEg4KClRSQU5TQ1JJUFQQBDKEDQoTQW5ub3RhdGlvblNlcnZpY2VWMRKUAQoTQ3JlYXRlQW5ub3RhdGlvblNldBIuLmdvb2dsZS5nZW5vbWljcy52MS5DcmVhdGVBbm5vdGF0aW9uU2V0UmVxdWVzdBohLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0IiqC0+STAiQ6DmFubm90YXRpb25fc2V0IhIvdjEvYW5ub3RhdGlvbnNldHMSkgEKEEdldEFubm90YXRpb25TZXQSKy5nb29nbGUuZ2Vub21pY3MudjEuR2V0QW5ub3RhdGlvblNldFJlcXVlc3QaIS5nb29nbGUuZ2Vub21pY3MudjEuQW5ub3RhdGlvblNldCIugtPkkwIoEiYvdjEvYW5ub3RhdGlvbnNldHMve2Fubm90YXRpb25fc2V0X2lkfRKoAQoTVXBkYXRlQW5ub3RhdGlvblNldBIuLmdvb2dsZS5nZW5vbWljcy52MS5VcGRhdGVBbm5vdGF0aW9uU2V0UmVxdWVzdBohLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uU2V0Ij6C0+STAjg6DmFubm90YXRpb25fc2V0GiYvdjEvYW5ub3RhdGlvbnNldHMve2Fubm90YXRpb25fc2V0X2lkfRKNAQoTRGVsZXRlQW5ub3RhdGlvblNldBIuLmdvb2dsZS5nZW5vbWljcy52MS5EZWxldGVBbm5vdGF0aW9uU2V0UmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIugtPkkwIoKiYvdjEvYW5ub3RhdGlvbnNldHMve2Fubm90YXRpb25fc2V0X2lkfRKfAQoUU2VhcmNoQW5ub3RhdGlvblNldHMSLy5nb29nbGUuZ2Vub21pY3MudjEuU2VhcmNoQW5ub3RhdGlvblNldHNSZXF1ZXN0GjAuZ29vZ2xlLmdlbm9taWNzLnYxLlNlYXJjaEFubm90YXRpb25TZXRzUmVzcG9uc2UiJILT5JMCHjoBKiIZL3YxL2Fubm90YXRpb25zZXRzL3NlYXJjaBKEAQoQQ3JlYXRlQW5ub3RhdGlvbhIrLmdvb2dsZS5nZW5vbWljcy52MS5DcmVhdGVBbm5vdGF0aW9uUmVxdWVzdBoeLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uIiOC0+STAh06CmFubm90YXRpb24iDy92MS9hbm5vdGF0aW9ucxKnAQoWQmF0Y2hDcmVhdGVBbm5vdGF0aW9ucxIxLmdvb2dsZS5nZW5vbWljcy52MS5CYXRjaENyZWF0ZUFubm90YXRpb25zUmVxdWVzdBoyLmdvb2dsZS5nZW5vbWljcy52MS5CYXRjaENyZWF0ZUFubm90YXRpb25zUmVzcG9uc2UiJoLT5JMCIDoBKiIbL3YxL2Fubm90YXRpb25zOmJhdGNoQ3JlYXRlEoIBCg1HZXRBbm5vdGF0aW9uEiguZ29vZ2xlLmdlbm9taWNzLnYxLkdldEFubm90YXRpb25SZXF1ZXN0Gh4uZ29vZ2xlLmdlbm9taWNzLnYxLkFubm90YXRpb24iJ4LT5JMCIRIfL3YxL2Fubm90YXRpb25zL3thbm5vdGF0aW9uX2lkfRKUAQoQVXBkYXRlQW5ub3RhdGlvbhIrLmdvb2dsZS5nZW5vbWljcy52MS5VcGRhdGVBbm5vdGF0aW9uUmVxdWVzdBoeLmdvb2dsZS5nZW5vbWljcy52MS5Bbm5vdGF0aW9uIjOC0+STAi06CmFubm90YXRpb24aHy92MS9hbm5vdGF0aW9ucy97YW5ub3RhdGlvbl9pZH0SgAEKEERlbGV0ZUFubm90YXRpb24SKy5nb29nbGUuZ2Vub21pY3MudjEuRGVsZXRlQW5ub3RhdGlvblJlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiJ4LT5JMCISofL3YxL2Fubm90YXRpb25zL3thbm5vdGF0aW9uX2lkfRKTAQoRU2VhcmNoQW5ub3RhdGlvbnMSLC5nb29nbGUuZ2Vub21pY3MudjEuU2VhcmNoQW5ub3RhdGlvbnNSZXF1ZXN0Gi0uZ29vZ2xlLmdlbm9taWNzLnYxLlNlYXJjaEFubm90YXRpb25zUmVzcG9uc2UiIYLT5JMCGzoBKiIWL3YxL2Fubm90YXRpb25zL3NlYXJjaEJrChZjb20uZ29vZ2xlLmdlbm9taWNzLnYxQhBBbm5vdGF0aW9uc1Byb3RvUAFaOmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvZ2Vub21pY3MvdjE7Z2Vub21pY3P4AQFiBnByb3RvMw", [file_google_api_annotations, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_struct, file_google_protobuf_wrappers, file_google_rpc_status]);

/**
 * An annotation set is a logical grouping of annotations that share consistent
 * type information and provenance. Examples of annotation sets include 'all
 * genes from refseq', and 'all variant annotations from ClinVar'.
 *
 * @generated from message google.genomics.v1.AnnotationSet
 */
export type AnnotationSet = Message<"google.genomics.v1.AnnotationSet"> & {
  /**
   * The server-generated annotation set ID, unique across all annotation sets.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The dataset to which this annotation set belongs.
   *
   * @generated from field: string dataset_id = 2;
   */
  datasetId: string;

  /**
   * The ID of the reference set that defines the coordinate space for this
   * set's annotations.
   *
   * @generated from field: string reference_set_id = 3;
   */
  referenceSetId: string;

  /**
   * The display name for this annotation set.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * The source URI describing the file from which this annotation set was
   * generated, if any.
   *
   * @generated from field: string source_uri = 5;
   */
  sourceUri: string;

  /**
   * The type of annotations contained within this set.
   *
   * @generated from field: google.genomics.v1.AnnotationType type = 6;
   */
  type: AnnotationType;

  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 17;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.AnnotationSet.
 * Use `create(AnnotationSetSchema)` to create a new message.
 */
export const AnnotationSetSchema: GenMessage<AnnotationSet> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 0);

/**
 * An annotation describes a region of reference genome. The value of an
 * annotation may be one of several canonical types, supplemented by arbitrary
 * info tags. An annotation is not inherently associated with a specific
 * sample or individual (though a client could choose to use annotations in
 * this way). Example canonical annotation types are `GENE` and
 * `VARIANT`.
 *
 * @generated from message google.genomics.v1.Annotation
 */
export type Annotation = Message<"google.genomics.v1.Annotation"> & {
  /**
   * The server-generated annotation ID, unique across all annotations.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The annotation set to which this annotation belongs.
   *
   * @generated from field: string annotation_set_id = 2;
   */
  annotationSetId: string;

  /**
   * The display name of this annotation.
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The ID of the Google Genomics reference associated with this range.
   *
   * @generated from field: string reference_id = 4;
   */
  referenceId: string;

  /**
   * The display name corresponding to the reference specified by
   * `referenceId`, for example `chr1`, `1`, or `chrX`.
   *
   * @generated from field: string reference_name = 5;
   */
  referenceName: string;

  /**
   * The start position of the range on the reference, 0-based inclusive.
   *
   * @generated from field: int64 start = 6;
   */
  start: bigint;

  /**
   * The end position of the range on the reference, 0-based exclusive.
   *
   * @generated from field: int64 end = 7;
   */
  end: bigint;

  /**
   * Whether this range refers to the reverse strand, as opposed to the forward
   * strand. Note that regardless of this field, the start/end position of the
   * range always refer to the forward strand.
   *
   * @generated from field: bool reverse_strand = 8;
   */
  reverseStrand: boolean;

  /**
   * The data type for this annotation. Must match the containing annotation
   * set's type.
   *
   * @generated from field: google.genomics.v1.AnnotationType type = 9;
   */
  type: AnnotationType;

  /**
   * @generated from oneof google.genomics.v1.Annotation.value
   */
  value: {
    /**
     * A variant annotation, which describes the effect of a variant on the
     * genome, the coding sequence, and/or higher level consequences at the
     * organism level e.g. pathogenicity. This field is only set for annotations
     * of type `VARIANT`.
     *
     * @generated from field: google.genomics.v1.VariantAnnotation variant = 10;
     */
    value: VariantAnnotation;
    case: "variant";
  } | {
    /**
     * A transcript value represents the assertion that a particular region of
     * the reference genome may be transcribed as RNA. An alternative splicing
     * pattern would be represented as a separate transcript object. This field
     * is only set for annotations of type `TRANSCRIPT`.
     *
     * @generated from field: google.genomics.v1.Transcript transcript = 11;
     */
    value: Transcript;
    case: "transcript";
  } | { case: undefined; value?: undefined };

  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 12;
   */
  info: { [key: string]: ListValue };
};

/**
 * Describes the message google.genomics.v1.Annotation.
 * Use `create(AnnotationSchema)` to create a new message.
 */
export const AnnotationSchema: GenMessage<Annotation> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 1);

/**
 * @generated from message google.genomics.v1.VariantAnnotation
 */
export type VariantAnnotation = Message<"google.genomics.v1.VariantAnnotation"> & {
  /**
   * Type has been adapted from ClinVar's list of variant types.
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.Type type = 1;
   */
  type: VariantAnnotation_Type;

  /**
   * Effect of the variant on the coding sequence.
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.Effect effect = 2;
   */
  effect: VariantAnnotation_Effect;

  /**
   * The alternate allele for this variant. If multiple alternate alleles
   * exist at this location, create a separate variant for each one, as they
   * may represent distinct conditions.
   *
   * @generated from field: string alternate_bases = 3;
   */
  alternateBases: string;

  /**
   * Google annotation ID of the gene affected by this variant. This should
   * be provided when the variant is created.
   *
   * @generated from field: string gene_id = 4;
   */
  geneId: string;

  /**
   * Google annotation IDs of the transcripts affected by this variant. These
   * should be provided when the variant is created.
   *
   * @generated from field: repeated string transcript_ids = 5;
   */
  transcriptIds: string[];

  /**
   * The set of conditions associated with this variant.
   * A condition describes the way a variant influences human health.
   *
   * @generated from field: repeated google.genomics.v1.VariantAnnotation.ClinicalCondition conditions = 6;
   */
  conditions: VariantAnnotation_ClinicalCondition[];

  /**
   * Describes the clinical significance of a variant.
   * It is adapted from the ClinVar controlled vocabulary for clinical
   * significance described at:
   * http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.ClinicalSignificance clinical_significance = 7;
   */
  clinicalSignificance: VariantAnnotation_ClinicalSignificance;
};

/**
 * Describes the message google.genomics.v1.VariantAnnotation.
 * Use `create(VariantAnnotationSchema)` to create a new message.
 */
export const VariantAnnotationSchema: GenMessage<VariantAnnotation> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 2);

/**
 * @generated from message google.genomics.v1.VariantAnnotation.ClinicalCondition
 */
export type VariantAnnotation_ClinicalCondition = Message<"google.genomics.v1.VariantAnnotation.ClinicalCondition"> & {
  /**
   * A set of names for the condition.
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * The set of external IDs for this condition.
   *
   * @generated from field: repeated google.genomics.v1.ExternalId external_ids = 2;
   */
  externalIds: ExternalId[];

  /**
   * The MedGen concept id associated with this gene.
   * Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
   *
   * @generated from field: string concept_id = 3;
   */
  conceptId: string;

  /**
   * The OMIM id for this condition.
   * Search for these IDs at http://omim.org/
   *
   * @generated from field: string omim_id = 4;
   */
  omimId: string;
};

/**
 * Describes the message google.genomics.v1.VariantAnnotation.ClinicalCondition.
 * Use `create(VariantAnnotation_ClinicalConditionSchema)` to create a new message.
 */
export const VariantAnnotation_ClinicalConditionSchema: GenMessage<VariantAnnotation_ClinicalCondition> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 2, 0);

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.Type
 */
export enum VariantAnnotation_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * `TYPE_OTHER` should be used when no other Type will suffice.
   * Further explanation of the variant type may be included in the
   * [info][google.genomics.v1.Annotation.info] field.
   *
   * @generated from enum value: TYPE_OTHER = 1;
   */
  TYPE_OTHER = 1,

  /**
   * `INSERTION` indicates an insertion.
   *
   * @generated from enum value: INSERTION = 2;
   */
  INSERTION = 2,

  /**
   * `DELETION` indicates a deletion.
   *
   * @generated from enum value: DELETION = 3;
   */
  DELETION = 3,

  /**
   * `SUBSTITUTION` indicates a block substitution of
   * two or more nucleotides.
   *
   * @generated from enum value: SUBSTITUTION = 4;
   */
  SUBSTITUTION = 4,

  /**
   * `SNP` indicates a single nucleotide polymorphism.
   *
   * @generated from enum value: SNP = 5;
   */
  SNP = 5,

  /**
   * `STRUCTURAL` indicates a large structural variant,
   * including chromosomal fusions, inversions, etc.
   *
   * @generated from enum value: STRUCTURAL = 6;
   */
  STRUCTURAL = 6,

  /**
   * `CNV` indicates a variation in copy number.
   *
   * @generated from enum value: CNV = 7;
   */
  CNV = 7,
}

/**
 * Describes the enum google.genomics.v1.VariantAnnotation.Type.
 */
export const VariantAnnotation_TypeSchema: GenEnum<VariantAnnotation_Type> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_annotations, 2, 0);

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.Effect
 */
export enum VariantAnnotation_Effect {
  /**
   * @generated from enum value: EFFECT_UNSPECIFIED = 0;
   */
  EFFECT_UNSPECIFIED = 0,

  /**
   * `EFFECT_OTHER` should be used when no other Effect
   * will suffice.
   *
   * @generated from enum value: EFFECT_OTHER = 1;
   */
  EFFECT_OTHER = 1,

  /**
   * `FRAMESHIFT` indicates a mutation in which the insertion or
   * deletion of nucleotides resulted in a frameshift change.
   *
   * @generated from enum value: FRAMESHIFT = 2;
   */
  FRAMESHIFT = 2,

  /**
   * `FRAME_PRESERVING_INDEL` indicates a mutation in which a
   * multiple of three nucleotides has been inserted or deleted, resulting
   * in no change to the reading frame of the coding sequence.
   *
   * @generated from enum value: FRAME_PRESERVING_INDEL = 3;
   */
  FRAME_PRESERVING_INDEL = 3,

  /**
   * `SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
   * mutation that results in no amino acid change.
   *
   * @generated from enum value: SYNONYMOUS_SNP = 4;
   */
  SYNONYMOUS_SNP = 4,

  /**
   * `NONSYNONYMOUS_SNP` indicates a single nucleotide
   * polymorphism mutation that results in an amino acid change.
   *
   * @generated from enum value: NONSYNONYMOUS_SNP = 5;
   */
  NONSYNONYMOUS_SNP = 5,

  /**
   * `STOP_GAIN` indicates a mutation that leads to the creation
   * of a stop codon at the variant site. Frameshift mutations creating
   * downstream stop codons do not count as `STOP_GAIN`.
   *
   * @generated from enum value: STOP_GAIN = 6;
   */
  STOP_GAIN = 6,

  /**
   * `STOP_LOSS` indicates a mutation that eliminates a
   * stop codon at the variant site.
   *
   * @generated from enum value: STOP_LOSS = 7;
   */
  STOP_LOSS = 7,

  /**
   * `SPLICE_SITE_DISRUPTION` indicates that this variant is
   * found in a splice site for the associated transcript, and alters the
   * normal splicing pattern.
   *
   * @generated from enum value: SPLICE_SITE_DISRUPTION = 8;
   */
  SPLICE_SITE_DISRUPTION = 8,
}

/**
 * Describes the enum google.genomics.v1.VariantAnnotation.Effect.
 */
export const VariantAnnotation_EffectSchema: GenEnum<VariantAnnotation_Effect> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_annotations, 2, 1);

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.ClinicalSignificance
 */
export enum VariantAnnotation_ClinicalSignificance {
  /**
   * @generated from enum value: CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0;
   */
  CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0,

  /**
   * `OTHER` should be used when no other clinical significance
   * value will suffice.
   *
   * @generated from enum value: CLINICAL_SIGNIFICANCE_OTHER = 1;
   */
  CLINICAL_SIGNIFICANCE_OTHER = 1,

  /**
   * @generated from enum value: UNCERTAIN = 2;
   */
  UNCERTAIN = 2,

  /**
   * @generated from enum value: BENIGN = 3;
   */
  BENIGN = 3,

  /**
   * @generated from enum value: LIKELY_BENIGN = 4;
   */
  LIKELY_BENIGN = 4,

  /**
   * @generated from enum value: LIKELY_PATHOGENIC = 5;
   */
  LIKELY_PATHOGENIC = 5,

  /**
   * @generated from enum value: PATHOGENIC = 6;
   */
  PATHOGENIC = 6,

  /**
   * @generated from enum value: DRUG_RESPONSE = 7;
   */
  DRUG_RESPONSE = 7,

  /**
   * @generated from enum value: HISTOCOMPATIBILITY = 8;
   */
  HISTOCOMPATIBILITY = 8,

  /**
   * @generated from enum value: CONFERS_SENSITIVITY = 9;
   */
  CONFERS_SENSITIVITY = 9,

  /**
   * @generated from enum value: RISK_FACTOR = 10;
   */
  RISK_FACTOR = 10,

  /**
   * @generated from enum value: ASSOCIATION = 11;
   */
  ASSOCIATION = 11,

  /**
   * @generated from enum value: PROTECTIVE = 12;
   */
  PROTECTIVE = 12,

  /**
   * `MULTIPLE_REPORTED` should be used when multiple clinical
   * signficances are reported for a variant. The original clinical
   * significance values may be provided in the `info` field.
   *
   * @generated from enum value: MULTIPLE_REPORTED = 13;
   */
  MULTIPLE_REPORTED = 13,
}

/**
 * Describes the enum google.genomics.v1.VariantAnnotation.ClinicalSignificance.
 */
export const VariantAnnotation_ClinicalSignificanceSchema: GenEnum<VariantAnnotation_ClinicalSignificance> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_annotations, 2, 2);

/**
 * A transcript represents the assertion that a particular region of the
 * reference genome may be transcribed as RNA.
 *
 * @generated from message google.genomics.v1.Transcript
 */
export type Transcript = Message<"google.genomics.v1.Transcript"> & {
  /**
   * The annotation ID of the gene from which this transcript is transcribed.
   *
   * @generated from field: string gene_id = 1;
   */
  geneId: string;

  /**
   * The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
   * this transcript. This field should be unset for genomes where transcript
   * splicing does not occur, for example prokaryotes.
   *
   * Introns are regions of the transcript that are not included in the
   * spliced RNA product. Though not explicitly modeled here, intron ranges can
   * be deduced; all regions of this transcript that are not exons are introns.
   *
   * Exonic sequences do not necessarily code for a translational product
   * (amino acids). Only the regions of exons bounded by the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
   * to coding DNA sequence.
   *
   * Exons are ordered by start position and may not overlap.
   *
   * @generated from field: repeated google.genomics.v1.Transcript.Exon exons = 2;
   */
  exons: Transcript_Exon[];

  /**
   * The range of the coding sequence for this transcript, if any. To determine
   * the exact ranges of coding sequence, intersect this range with those of the
   * [exons][google.genomics.v1.Transcript.exons], if any. If there are any
   * [exons][google.genomics.v1.Transcript.exons], the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
   * and end within them.
   *
   * Note that in some cases, the reference genome will not exactly match the
   * observed mRNA transcript e.g. due to variance in the source genome from
   * reference. In these cases,
   * [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
   * match the expected reference reading frame and coding exon reference bases
   * cannot necessarily be concatenated to produce the original transcript mRNA.
   *
   * @generated from field: google.genomics.v1.Transcript.CodingSequence coding_sequence = 3;
   */
  codingSequence?: Transcript_CodingSequence;
};

/**
 * Describes the message google.genomics.v1.Transcript.
 * Use `create(TranscriptSchema)` to create a new message.
 */
export const TranscriptSchema: GenMessage<Transcript> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 3);

/**
 * @generated from message google.genomics.v1.Transcript.Exon
 */
export type Transcript_Exon = Message<"google.genomics.v1.Transcript.Exon"> & {
  /**
   * The start position of the exon on this annotation's reference sequence,
   * 0-based inclusive. Note that this is relative to the reference start, and
   * **not** the containing annotation start.
   *
   * @generated from field: int64 start = 1;
   */
  start: bigint;

  /**
   * The end position of the exon on this annotation's reference sequence,
   * 0-based exclusive. Note that this is relative to the reference start, and
   * *not* the containing annotation start.
   *
   * @generated from field: int64 end = 2;
   */
  end: bigint;

  /**
   * The frame of this exon. Contains a value of 0, 1, or 2, which indicates
   * the offset of the first coding base of the exon within the reading frame
   * of the coding DNA sequence, if any. This field is dependent on the
   * strandedness of this annotation (see
   * [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
   * For forward stranded annotations, this offset is relative to the
   * [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
   * strand annotations, this offset is relative to the
   * [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.
   *
   * Unset if this exon does not intersect the coding sequence. Upon creation
   * of a transcript, the frame must be populated for all or none of the
   * coding exons.
   *
   * @generated from field: google.protobuf.Int32Value frame = 3;
   */
  frame?: number;
};

/**
 * Describes the message google.genomics.v1.Transcript.Exon.
 * Use `create(Transcript_ExonSchema)` to create a new message.
 */
export const Transcript_ExonSchema: GenMessage<Transcript_Exon> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 3, 0);

/**
 * @generated from message google.genomics.v1.Transcript.CodingSequence
 */
export type Transcript_CodingSequence = Message<"google.genomics.v1.Transcript.CodingSequence"> & {
  /**
   * The start of the coding sequence on this annotation's reference sequence,
   * 0-based inclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   *
   * @generated from field: int64 start = 1;
   */
  start: bigint;

  /**
   * The end of the coding sequence on this annotation's reference sequence,
   * 0-based exclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   *
   * @generated from field: int64 end = 2;
   */
  end: bigint;
};

/**
 * Describes the message google.genomics.v1.Transcript.CodingSequence.
 * Use `create(Transcript_CodingSequenceSchema)` to create a new message.
 */
export const Transcript_CodingSequenceSchema: GenMessage<Transcript_CodingSequence> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 3, 1);

/**
 * @generated from message google.genomics.v1.ExternalId
 */
export type ExternalId = Message<"google.genomics.v1.ExternalId"> & {
  /**
   * The name of the source of this data.
   *
   * @generated from field: string source_name = 1;
   */
  sourceName: string;

  /**
   * The id used by the source of this data.
   *
   * @generated from field: string id = 2;
   */
  id: string;
};

/**
 * Describes the message google.genomics.v1.ExternalId.
 * Use `create(ExternalIdSchema)` to create a new message.
 */
export const ExternalIdSchema: GenMessage<ExternalId> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 4);

/**
 * @generated from message google.genomics.v1.CreateAnnotationSetRequest
 */
export type CreateAnnotationSetRequest = Message<"google.genomics.v1.CreateAnnotationSetRequest"> & {
  /**
   * The annotation set to create.
   *
   * @generated from field: google.genomics.v1.AnnotationSet annotation_set = 1;
   */
  annotationSet?: AnnotationSet;
};

/**
 * Describes the message google.genomics.v1.CreateAnnotationSetRequest.
 * Use `create(CreateAnnotationSetRequestSchema)` to create a new message.
 */
export const CreateAnnotationSetRequestSchema: GenMessage<CreateAnnotationSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 5);

/**
 * @generated from message google.genomics.v1.GetAnnotationSetRequest
 */
export type GetAnnotationSetRequest = Message<"google.genomics.v1.GetAnnotationSetRequest"> & {
  /**
   * The ID of the annotation set to be retrieved.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId: string;
};

/**
 * Describes the message google.genomics.v1.GetAnnotationSetRequest.
 * Use `create(GetAnnotationSetRequestSchema)` to create a new message.
 */
export const GetAnnotationSetRequestSchema: GenMessage<GetAnnotationSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 6);

/**
 * @generated from message google.genomics.v1.UpdateAnnotationSetRequest
 */
export type UpdateAnnotationSetRequest = Message<"google.genomics.v1.UpdateAnnotationSetRequest"> & {
  /**
   * The ID of the annotation set to be updated.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId: string;

  /**
   * The new annotation set.
   *
   * @generated from field: google.genomics.v1.AnnotationSet annotation_set = 2;
   */
  annotationSet?: AnnotationSet;

  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.AnnotationSet.name],
   * [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
   * [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
   * mutable fields will be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.genomics.v1.UpdateAnnotationSetRequest.
 * Use `create(UpdateAnnotationSetRequestSchema)` to create a new message.
 */
export const UpdateAnnotationSetRequestSchema: GenMessage<UpdateAnnotationSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 7);

/**
 * @generated from message google.genomics.v1.DeleteAnnotationSetRequest
 */
export type DeleteAnnotationSetRequest = Message<"google.genomics.v1.DeleteAnnotationSetRequest"> & {
  /**
   * The ID of the annotation set to be deleted.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId: string;
};

/**
 * Describes the message google.genomics.v1.DeleteAnnotationSetRequest.
 * Use `create(DeleteAnnotationSetRequestSchema)` to create a new message.
 */
export const DeleteAnnotationSetRequestSchema: GenMessage<DeleteAnnotationSetRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 8);

/**
 * @generated from message google.genomics.v1.SearchAnnotationSetsRequest
 */
export type SearchAnnotationSetsRequest = Message<"google.genomics.v1.SearchAnnotationSetsRequest"> & {
  /**
   * Required. The dataset IDs to search within. Caller must have `READ` access
   * to these datasets.
   *
   * @generated from field: repeated string dataset_ids = 1;
   */
  datasetIds: string[];

  /**
   * If specified, only annotation sets associated with the given reference set
   * are returned.
   *
   * @generated from field: string reference_set_id = 2;
   */
  referenceSetId: string;

  /**
   * Only return annotations sets for which a substring of the name matches this
   * string (case insensitive).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * If specified, only annotation sets that have any of these types are
   * returned.
   *
   * @generated from field: repeated google.genomics.v1.AnnotationType types = 4;
   */
  types: AnnotationType[];

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 5;
   */
  pageToken: string;

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 128. The maximum value is 1024.
   *
   * @generated from field: int32 page_size = 6;
   */
  pageSize: number;
};

/**
 * Describes the message google.genomics.v1.SearchAnnotationSetsRequest.
 * Use `create(SearchAnnotationSetsRequestSchema)` to create a new message.
 */
export const SearchAnnotationSetsRequestSchema: GenMessage<SearchAnnotationSetsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 9);

/**
 * @generated from message google.genomics.v1.SearchAnnotationSetsResponse
 */
export type SearchAnnotationSetsResponse = Message<"google.genomics.v1.SearchAnnotationSetsResponse"> & {
  /**
   * The matching annotation sets.
   *
   * @generated from field: repeated google.genomics.v1.AnnotationSet annotation_sets = 1;
   */
  annotationSets: AnnotationSet[];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.genomics.v1.SearchAnnotationSetsResponse.
 * Use `create(SearchAnnotationSetsResponseSchema)` to create a new message.
 */
export const SearchAnnotationSetsResponseSchema: GenMessage<SearchAnnotationSetsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 10);

/**
 * @generated from message google.genomics.v1.CreateAnnotationRequest
 */
export type CreateAnnotationRequest = Message<"google.genomics.v1.CreateAnnotationRequest"> & {
  /**
   * The annotation to be created.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 1;
   */
  annotation?: Annotation;
};

/**
 * Describes the message google.genomics.v1.CreateAnnotationRequest.
 * Use `create(CreateAnnotationRequestSchema)` to create a new message.
 */
export const CreateAnnotationRequestSchema: GenMessage<CreateAnnotationRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 11);

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsRequest
 */
export type BatchCreateAnnotationsRequest = Message<"google.genomics.v1.BatchCreateAnnotationsRequest"> & {
  /**
   * The annotations to be created. At most 4096 can be specified in a single
   * request.
   *
   * @generated from field: repeated google.genomics.v1.Annotation annotations = 1;
   */
  annotations: Annotation[];

  /**
   * A unique request ID which enables the server to detect duplicated requests.
   * If provided, duplicated requests will result in the same response; if not
   * provided, duplicated requests may result in duplicated data. For a given
   * annotation set, callers should not reuse `request_id`s when writing
   * different batches of annotations - behavior in this case is undefined.
   * A common approach is to use a UUID. For batch jobs where worker crashes are
   * a possibility, consider using some unique variant of a worker or run ID.
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;
};

/**
 * Describes the message google.genomics.v1.BatchCreateAnnotationsRequest.
 * Use `create(BatchCreateAnnotationsRequestSchema)` to create a new message.
 */
export const BatchCreateAnnotationsRequestSchema: GenMessage<BatchCreateAnnotationsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 12);

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsResponse
 */
export type BatchCreateAnnotationsResponse = Message<"google.genomics.v1.BatchCreateAnnotationsResponse"> & {
  /**
   * The resulting per-annotation entries, ordered consistently with the
   * original request.
   *
   * @generated from field: repeated google.genomics.v1.BatchCreateAnnotationsResponse.Entry entries = 1;
   */
  entries: BatchCreateAnnotationsResponse_Entry[];
};

/**
 * Describes the message google.genomics.v1.BatchCreateAnnotationsResponse.
 * Use `create(BatchCreateAnnotationsResponseSchema)` to create a new message.
 */
export const BatchCreateAnnotationsResponseSchema: GenMessage<BatchCreateAnnotationsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 13);

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsResponse.Entry
 */
export type BatchCreateAnnotationsResponse_Entry = Message<"google.genomics.v1.BatchCreateAnnotationsResponse.Entry"> & {
  /**
   * The creation status.
   *
   * @generated from field: google.rpc.Status status = 1;
   */
  status?: Status;

  /**
   * The created annotation, if creation was successful.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 2;
   */
  annotation?: Annotation;
};

/**
 * Describes the message google.genomics.v1.BatchCreateAnnotationsResponse.Entry.
 * Use `create(BatchCreateAnnotationsResponse_EntrySchema)` to create a new message.
 */
export const BatchCreateAnnotationsResponse_EntrySchema: GenMessage<BatchCreateAnnotationsResponse_Entry> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 13, 0);

/**
 * @generated from message google.genomics.v1.GetAnnotationRequest
 */
export type GetAnnotationRequest = Message<"google.genomics.v1.GetAnnotationRequest"> & {
  /**
   * The ID of the annotation to be retrieved.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId: string;
};

/**
 * Describes the message google.genomics.v1.GetAnnotationRequest.
 * Use `create(GetAnnotationRequestSchema)` to create a new message.
 */
export const GetAnnotationRequestSchema: GenMessage<GetAnnotationRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 14);

/**
 * @generated from message google.genomics.v1.UpdateAnnotationRequest
 */
export type UpdateAnnotationRequest = Message<"google.genomics.v1.UpdateAnnotationRequest"> & {
  /**
   * The ID of the annotation to be updated.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId: string;

  /**
   * The new annotation.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 2;
   */
  annotation?: Annotation;

  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.Annotation.name],
   * [variant][google.genomics.v1.Annotation.variant],
   * [transcript][google.genomics.v1.Annotation.transcript], and
   * [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
   * fields will be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.genomics.v1.UpdateAnnotationRequest.
 * Use `create(UpdateAnnotationRequestSchema)` to create a new message.
 */
export const UpdateAnnotationRequestSchema: GenMessage<UpdateAnnotationRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 15);

/**
 * @generated from message google.genomics.v1.DeleteAnnotationRequest
 */
export type DeleteAnnotationRequest = Message<"google.genomics.v1.DeleteAnnotationRequest"> & {
  /**
   * The ID of the annotation to be deleted.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId: string;
};

/**
 * Describes the message google.genomics.v1.DeleteAnnotationRequest.
 * Use `create(DeleteAnnotationRequestSchema)` to create a new message.
 */
export const DeleteAnnotationRequestSchema: GenMessage<DeleteAnnotationRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 16);

/**
 * @generated from message google.genomics.v1.SearchAnnotationsRequest
 */
export type SearchAnnotationsRequest = Message<"google.genomics.v1.SearchAnnotationsRequest"> & {
  /**
   * Required. The annotation sets to search within. The caller must have
   * `READ` access to these annotation sets.
   * All queried annotation sets must have the same type.
   *
   * @generated from field: repeated string annotation_set_ids = 1;
   */
  annotationSetIds: string[];

  /**
   * Required. `reference_id` or `reference_name` must be set.
   *
   * @generated from oneof google.genomics.v1.SearchAnnotationsRequest.reference
   */
  reference: {
    /**
     * The ID of the reference to query.
     *
     * @generated from field: string reference_id = 2;
     */
    value: string;
    case: "referenceId";
  } | {
    /**
     * The name of the reference to query, within the reference set associated
     * with this query.
     *
     * @generated from field: string reference_name = 3;
     */
    value: string;
    case: "referenceName";
  } | { case: undefined; value?: undefined };

  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified,
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified. Defaults to 0.
   *
   * @generated from field: int64 start = 4;
   */
  start: bigint;

  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified, Defaults to the length of the reference.
   *
   * @generated from field: int64 end = 5;
   */
  end: bigint;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 6;
   */
  pageToken: string;

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 256. The maximum value is 2048.
   *
   * @generated from field: int32 page_size = 7;
   */
  pageSize: number;
};

/**
 * Describes the message google.genomics.v1.SearchAnnotationsRequest.
 * Use `create(SearchAnnotationsRequestSchema)` to create a new message.
 */
export const SearchAnnotationsRequestSchema: GenMessage<SearchAnnotationsRequest> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 17);

/**
 * @generated from message google.genomics.v1.SearchAnnotationsResponse
 */
export type SearchAnnotationsResponse = Message<"google.genomics.v1.SearchAnnotationsResponse"> & {
  /**
   * The matching annotations.
   *
   * @generated from field: repeated google.genomics.v1.Annotation annotations = 1;
   */
  annotations: Annotation[];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.genomics.v1.SearchAnnotationsResponse.
 * Use `create(SearchAnnotationsResponseSchema)` to create a new message.
 */
export const SearchAnnotationsResponseSchema: GenMessage<SearchAnnotationsResponse> = /*@__PURE__*/
  messageDesc(file_google_genomics_v1_annotations, 18);

/**
 * When an [Annotation][google.genomics.v1.Annotation] or
 * [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
 * not specified it will be set to `GENERIC`.
 *
 * @generated from enum google.genomics.v1.AnnotationType
 */
export enum AnnotationType {
  /**
   * @generated from enum value: ANNOTATION_TYPE_UNSPECIFIED = 0;
   */
  ANNOTATION_TYPE_UNSPECIFIED = 0,

  /**
   * A `GENERIC` annotation type should be used when no other annotation
   * type will suffice. This represents an untyped annotation of the reference
   * genome.
   *
   * @generated from enum value: GENERIC = 1;
   */
  GENERIC = 1,

  /**
   * A `VARIANT` annotation type.
   *
   * @generated from enum value: VARIANT = 2;
   */
  VARIANT = 2,

  /**
   * A `GENE` annotation type represents the existence of a gene at the
   * associated reference coordinates. The start coordinate is typically the
   * gene's transcription start site and the end is typically the end of the
   * gene's last exon.
   *
   * @generated from enum value: GENE = 3;
   */
  GENE = 3,

  /**
   * A `TRANSCRIPT` annotation type represents the assertion that a
   * particular region of the reference genome may be transcribed as RNA.
   *
   * @generated from enum value: TRANSCRIPT = 4;
   */
  TRANSCRIPT = 4,
}

/**
 * Describes the enum google.genomics.v1.AnnotationType.
 */
export const AnnotationTypeSchema: GenEnum<AnnotationType> = /*@__PURE__*/
  enumDesc(file_google_genomics_v1_annotations, 0);

/**
 * This service provides storage and positional retrieval of genomic
 * reference annotations, including variant annotations.
 *
 * @generated from service google.genomics.v1.AnnotationServiceV1
 */
export const AnnotationServiceV1: GenService<{
  /**
   * Creates a new annotation set. Caller must have WRITE permission for the
   * associated dataset.
   *
   * The following fields are required:
   *
   *   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
   *   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field).
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.CreateAnnotationSet
   */
  createAnnotationSet: {
    methodKind: "unary";
    input: typeof CreateAnnotationSetRequestSchema;
    output: typeof AnnotationSetSchema;
  },
  /**
   * Gets an annotation set. Caller must have READ permission for
   * the associated dataset.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.GetAnnotationSet
   */
  getAnnotationSet: {
    methodKind: "unary";
    input: typeof GetAnnotationSetRequestSchema;
    output: typeof AnnotationSetSchema;
  },
  /**
   * Updates an annotation set. The update must respect all mutability
   * restrictions and other invariants described on the annotation set resource.
   * Caller must have WRITE permission for the associated dataset.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.UpdateAnnotationSet
   */
  updateAnnotationSet: {
    methodKind: "unary";
    input: typeof UpdateAnnotationSetRequestSchema;
    output: typeof AnnotationSetSchema;
  },
  /**
   * Deletes an annotation set. Caller must have WRITE permission
   * for the associated annotation set.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.DeleteAnnotationSet
   */
  deleteAnnotationSet: {
    methodKind: "unary";
    input: typeof DeleteAnnotationSetRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Searches for annotation sets that match the given criteria. Annotation sets
   * are returned in an unspecified order. This order is consistent, such that
   * two queries for the same content (regardless of page size) yield annotation
   * sets in the same order across their respective streams of paginated
   * responses. Caller must have READ permission for the queried datasets.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.SearchAnnotationSets
   */
  searchAnnotationSets: {
    methodKind: "unary";
    input: typeof SearchAnnotationSetsRequestSchema;
    output: typeof SearchAnnotationSetsResponseSchema;
  },
  /**
   * Creates a new annotation. Caller must have WRITE permission
   * for the associated annotation set.
   *
   * The following fields are required:
   *
   * * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
   * * [referenceName][google.genomics.v1.Annotation.reference_name] or
   *   [referenceId][google.genomics.v1.Annotation.reference_id]
   *
   * ### Transcripts
   *
   * For annotations of type TRANSCRIPT, the following fields of
   * [transcript][google.genomics.v1.Annotation.transcript] must be provided:
   *
   * * [exons.start][google.genomics.v1.Transcript.Exon.start]
   * * [exons.end][google.genomics.v1.Transcript.Exon.end]
   *
   * All other fields may be optionally specified, unless documented as being
   * server-generated (for example, the `id` field). The annotated
   * range must be no longer than 100Mbp (mega base pairs). See the
   * [Annotation resource][google.genomics.v1.Annotation]
   * for additional restrictions on each field.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.CreateAnnotation
   */
  createAnnotation: {
    methodKind: "unary";
    input: typeof CreateAnnotationRequestSchema;
    output: typeof AnnotationSchema;
  },
  /**
   * Creates one or more new annotations atomically. All annotations must
   * belong to the same annotation set. Caller must have WRITE
   * permission for this annotation set. For optimal performance, batch
   * positionally adjacent annotations together.
   *
   * If the request has a systemic issue, such as an attempt to write to
   * an inaccessible annotation set, the entire RPC will fail accordingly. For
   * lesser data issues, when possible an error will be isolated to the
   * corresponding batch entry in the response; the remaining well formed
   * annotations will be created normally.
   *
   * For details on the requirements for each individual annotation resource,
   * see
   * [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.BatchCreateAnnotations
   */
  batchCreateAnnotations: {
    methodKind: "unary";
    input: typeof BatchCreateAnnotationsRequestSchema;
    output: typeof BatchCreateAnnotationsResponseSchema;
  },
  /**
   * Gets an annotation. Caller must have READ permission
   * for the associated annotation set.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.GetAnnotation
   */
  getAnnotation: {
    methodKind: "unary";
    input: typeof GetAnnotationRequestSchema;
    output: typeof AnnotationSchema;
  },
  /**
   * Updates an annotation. Caller must have
   * WRITE permission for the associated dataset.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.UpdateAnnotation
   */
  updateAnnotation: {
    methodKind: "unary";
    input: typeof UpdateAnnotationRequestSchema;
    output: typeof AnnotationSchema;
  },
  /**
   * Deletes an annotation. Caller must have WRITE permission for
   * the associated annotation set.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.DeleteAnnotation
   */
  deleteAnnotation: {
    methodKind: "unary";
    input: typeof DeleteAnnotationRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Searches for annotations that match the given criteria. Results are
   * ordered by genomic coordinate (by reference sequence, then position).
   * Annotations with equivalent genomic coordinates are returned in an
   * unspecified order. This order is consistent, such that two queries for the
   * same content (regardless of page size) yield annotations in the same order
   * across their respective streams of paginated responses. Caller must have
   * READ permission for the queried annotation sets.
   *
   * @generated from rpc google.genomics.v1.AnnotationServiceV1.SearchAnnotations
   */
  searchAnnotations: {
    methodKind: "unary";
    input: typeof SearchAnnotationsRequestSchema;
    output: typeof SearchAnnotationsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_genomics_v1_annotations, 0);

