// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/spanner/v1/type.proto (package google.spanner.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/spanner/v1/type.proto.
 */
export const file_google_spanner_v1_type: GenFile = /*@__PURE__*/
  fileDesc("Chxnb29nbGUvc3Bhbm5lci92MS90eXBlLnByb3RvEhFnb29nbGUuc3Bhbm5lci52MSL3AQoEVHlwZRIuCgRjb2RlGAEgASgOMhsuZ29vZ2xlLnNwYW5uZXIudjEuVHlwZUNvZGVCA+BBAhIzChJhcnJheV9lbGVtZW50X3R5cGUYAiABKAsyFy5nb29nbGUuc3Bhbm5lci52MS5UeXBlEjIKC3N0cnVjdF90eXBlGAMgASgLMh0uZ29vZ2xlLnNwYW5uZXIudjEuU3RydWN0VHlwZRI+Cg90eXBlX2Fubm90YXRpb24YBCABKA4yJS5nb29nbGUuc3Bhbm5lci52MS5UeXBlQW5ub3RhdGlvbkNvZGUSFgoOcHJvdG9fdHlwZV9mcW4YBSABKAkifwoKU3RydWN0VHlwZRIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUuc3Bhbm5lci52MS5TdHJ1Y3RUeXBlLkZpZWxkGjwKBUZpZWxkEgwKBG5hbWUYASABKAkSJQoEdHlwZRgCIAEoCzIXLmdvb2dsZS5zcGFubmVyLnYxLlR5cGUqxwEKCFR5cGVDb2RlEhkKFVRZUEVfQ09ERV9VTlNQRUNJRklFRBAAEggKBEJPT0wQARIJCgVJTlQ2NBACEgsKB0ZMT0FUNjQQAxILCgdGTE9BVDMyEA8SDQoJVElNRVNUQU1QEAQSCAoEREFURRAFEgoKBlNUUklORxAGEgkKBUJZVEVTEAcSCQoFQVJSQVkQCBIKCgZTVFJVQ1QQCRILCgdOVU1FUklDEAoSCAoESlNPThALEgkKBVBST1RPEA0SCAoERU5VTRAOKmQKElR5cGVBbm5vdGF0aW9uQ29kZRIkCiBUWVBFX0FOTk9UQVRJT05fQ09ERV9VTlNQRUNJRklFRBAAEg4KClBHX05VTUVSSUMQAhIMCghQR19KU09OQhADEgoKBlBHX09JRBAEQqwBChVjb20uZ29vZ2xlLnNwYW5uZXIudjFCCVR5cGVQcm90b1ABWjVjbG91ZC5nb29nbGUuY29tL2dvL3NwYW5uZXIvYXBpdjEvc3Bhbm5lcnBiO3NwYW5uZXJwYqoCF0dvb2dsZS5DbG91ZC5TcGFubmVyLlYxygIXR29vZ2xlXENsb3VkXFNwYW5uZXJcVjHqAhpHb29nbGU6OkNsb3VkOjpTcGFubmVyOjpWMWIGcHJvdG8z", [file_google_api_field_behavior]);

/**
 * `Type` indicates the type of a Cloud Spanner value, as might be stored in a
 * table cell or returned from an SQL query.
 *
 * @generated from message google.spanner.v1.Type
 */
export type Type = Message<"google.spanner.v1.Type"> & {
  /**
   * Required. The [TypeCode][google.spanner.v1.TypeCode] for this type.
   *
   * @generated from field: google.spanner.v1.TypeCode code = 1;
   */
  code: TypeCode;

  /**
   * If [code][google.spanner.v1.Type.code] == [ARRAY][google.spanner.v1.TypeCode.ARRAY], then `array_element_type`
   * is the type of the array elements.
   *
   * @generated from field: google.spanner.v1.Type array_element_type = 2;
   */
  arrayElementType?: Type;

  /**
   * If [code][google.spanner.v1.Type.code] == [STRUCT][google.spanner.v1.TypeCode.STRUCT], then `struct_type`
   * provides type information for the struct's fields.
   *
   * @generated from field: google.spanner.v1.StructType struct_type = 3;
   */
  structType?: StructType;

  /**
   * The [TypeAnnotationCode][google.spanner.v1.TypeAnnotationCode] that disambiguates SQL type that Spanner will
   * use to represent values of this type during query processing. This is
   * necessary for some type codes because a single [TypeCode][google.spanner.v1.TypeCode] can be mapped
   * to different SQL types depending on the SQL dialect. [type_annotation][google.spanner.v1.Type.type_annotation]
   * typically is not needed to process the content of a value (it doesn't
   * affect serialization) and clients can ignore it on the read path.
   *
   * @generated from field: google.spanner.v1.TypeAnnotationCode type_annotation = 4;
   */
  typeAnnotation: TypeAnnotationCode;

  /**
   * If [code][google.spanner.v1.Type.code] ==
   * [PROTO][google.spanner.v1.TypeCode.PROTO] or
   * [code][google.spanner.v1.Type.code] ==
   * [ENUM][google.spanner.v1.TypeCode.ENUM], then `proto_type_fqn` is the fully
   * qualified name of the proto type representing the proto/enum definition.
   *
   * @generated from field: string proto_type_fqn = 5;
   */
  protoTypeFqn: string;
};

/**
 * Describes the message google.spanner.v1.Type.
 * Use `create(TypeSchema)` to create a new message.
 */
export const TypeSchema: GenMessage<Type> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_type, 0);

/**
 * `StructType` defines the fields of a [STRUCT][google.spanner.v1.TypeCode.STRUCT] type.
 *
 * @generated from message google.spanner.v1.StructType
 */
export type StructType = Message<"google.spanner.v1.StructType"> & {
  /**
   * The list of fields that make up this struct. Order is
   * significant, because values of this struct type are represented as
   * lists, where the order of field values matches the order of
   * fields in the [StructType][google.spanner.v1.StructType]. In turn, the order of fields
   * matches the order of columns in a read request, or the order of
   * fields in the `SELECT` clause of a query.
   *
   * @generated from field: repeated google.spanner.v1.StructType.Field fields = 1;
   */
  fields: StructType_Field[];
};

/**
 * Describes the message google.spanner.v1.StructType.
 * Use `create(StructTypeSchema)` to create a new message.
 */
export const StructTypeSchema: GenMessage<StructType> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_type, 1);

/**
 * Message representing a single field of a struct.
 *
 * @generated from message google.spanner.v1.StructType.Field
 */
export type StructType_Field = Message<"google.spanner.v1.StructType.Field"> & {
  /**
   * The name of the field. For reads, this is the column name. For
   * SQL queries, it is the column alias (e.g., `"Word"` in the
   * query `"SELECT 'hello' AS Word"`), or the column name (e.g.,
   * `"ColName"` in the query `"SELECT ColName FROM Table"`). Some
   * columns might have an empty name (e.g., `"SELECT
   * UPPER(ColName)"`). Note that a query result can contain
   * multiple fields with the same name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The type of the field.
   *
   * @generated from field: google.spanner.v1.Type type = 2;
   */
  type?: Type;
};

/**
 * Describes the message google.spanner.v1.StructType.Field.
 * Use `create(StructType_FieldSchema)` to create a new message.
 */
export const StructType_FieldSchema: GenMessage<StructType_Field> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_type, 1, 0);

/**
 * `TypeCode` is used as part of [Type][google.spanner.v1.Type] to
 * indicate the type of a Cloud Spanner value.
 *
 * Each legal value of a type can be encoded to or decoded from a JSON
 * value, using the encodings described below. All Cloud Spanner values can
 * be `null`, regardless of type; `null`s are always encoded as a JSON
 * `null`.
 *
 * @generated from enum google.spanner.v1.TypeCode
 */
export enum TypeCode {
  /**
   * Not specified.
   *
   * @generated from enum value: TYPE_CODE_UNSPECIFIED = 0;
   */
  TYPE_CODE_UNSPECIFIED = 0,

  /**
   * Encoded as JSON `true` or `false`.
   *
   * @generated from enum value: BOOL = 1;
   */
  BOOL = 1,

  /**
   * Encoded as `string`, in decimal format.
   *
   * @generated from enum value: INT64 = 2;
   */
  INT64 = 2,

  /**
   * Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
   * `"-Infinity"`.
   *
   * @generated from enum value: FLOAT64 = 3;
   */
  FLOAT64 = 3,

  /**
   * Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
   * `"-Infinity"`.
   *
   * @generated from enum value: FLOAT32 = 15;
   */
  FLOAT32 = 15,

  /**
   * Encoded as `string` in RFC 3339 timestamp format. The time zone
   * must be present, and must be `"Z"`.
   *
   * If the schema has the column option
   * `allow_commit_timestamp=true`, the placeholder string
   * `"spanner.commit_timestamp()"` can be used to instruct the system
   * to insert the commit timestamp associated with the transaction
   * commit.
   *
   * @generated from enum value: TIMESTAMP = 4;
   */
  TIMESTAMP = 4,

  /**
   * Encoded as `string` in RFC 3339 date format.
   *
   * @generated from enum value: DATE = 5;
   */
  DATE = 5,

  /**
   * Encoded as `string`.
   *
   * @generated from enum value: STRING = 6;
   */
  STRING = 6,

  /**
   * Encoded as a base64-encoded `string`, as described in RFC 4648,
   * section 4.
   *
   * @generated from enum value: BYTES = 7;
   */
  BYTES = 7,

  /**
   * Encoded as `list`, where the list elements are represented
   * according to
   * [array_element_type][google.spanner.v1.Type.array_element_type].
   *
   * @generated from enum value: ARRAY = 8;
   */
  ARRAY = 8,

  /**
   * Encoded as `list`, where list element `i` is represented according
   * to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
   *
   * @generated from enum value: STRUCT = 9;
   */
  STRUCT = 9,

  /**
   * Encoded as `string`, in decimal format or scientific notation format.
   * <br>Decimal format:
   * <br>`[+-]Digits[.[Digits]]` or
   * <br>`[+-][Digits].Digits`
   *
   * Scientific notation:
   * <br>`[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
   * <br>`[+-][Digits].Digits[ExponentIndicator[+-]Digits]`
   * <br>(ExponentIndicator is `"e"` or `"E"`)
   *
   * @generated from enum value: NUMERIC = 10;
   */
  NUMERIC = 10,

  /**
   * Encoded as a JSON-formatted `string` as described in RFC 7159. The
   * following rules are applied when parsing JSON input:
   *
   * - Whitespace characters are not preserved.
   * - If a JSON object has duplicate keys, only the first key is preserved.
   * - Members of a JSON object are not guaranteed to have their order
   *   preserved.
   * - JSON array elements will have their order preserved.
   *
   * @generated from enum value: JSON = 11;
   */
  JSON = 11,

  /**
   * Encoded as a base64-encoded `string`, as described in RFC 4648,
   * section 4.
   *
   * @generated from enum value: PROTO = 13;
   */
  PROTO = 13,

  /**
   * Encoded as `string`, in decimal format.
   *
   * @generated from enum value: ENUM = 14;
   */
  ENUM = 14,
}

/**
 * Describes the enum google.spanner.v1.TypeCode.
 */
export const TypeCodeSchema: GenEnum<TypeCode> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_type, 0);

/**
 * `TypeAnnotationCode` is used as a part of [Type][google.spanner.v1.Type] to
 * disambiguate SQL types that should be used for a given Cloud Spanner value.
 * Disambiguation is needed because the same Cloud Spanner type can be mapped to
 * different SQL types depending on SQL dialect. TypeAnnotationCode doesn't
 * affect the way value is serialized.
 *
 * @generated from enum google.spanner.v1.TypeAnnotationCode
 */
export enum TypeAnnotationCode {
  /**
   * Not specified.
   *
   * @generated from enum value: TYPE_ANNOTATION_CODE_UNSPECIFIED = 0;
   */
  TYPE_ANNOTATION_CODE_UNSPECIFIED = 0,

  /**
   * PostgreSQL compatible NUMERIC type. This annotation needs to be applied to
   * [Type][google.spanner.v1.Type] instances having [NUMERIC][google.spanner.v1.TypeCode.NUMERIC]
   * type code to specify that values of this type should be treated as
   * PostgreSQL NUMERIC values. Currently this annotation is always needed for
   * [NUMERIC][google.spanner.v1.TypeCode.NUMERIC] when a client interacts with PostgreSQL-enabled
   * Spanner databases.
   *
   * @generated from enum value: PG_NUMERIC = 2;
   */
  PG_NUMERIC = 2,

  /**
   * PostgreSQL compatible JSONB type. This annotation needs to be applied to
   * [Type][google.spanner.v1.Type] instances having [JSON][google.spanner.v1.TypeCode.JSON]
   * type code to specify that values of this type should be treated as
   * PostgreSQL JSONB values. Currently this annotation is always needed for
   * [JSON][google.spanner.v1.TypeCode.JSON] when a client interacts with PostgreSQL-enabled
   * Spanner databases.
   *
   * @generated from enum value: PG_JSONB = 3;
   */
  PG_JSONB = 3,

  /**
   * PostgreSQL compatible OID type. This annotation can be used by a client
   * interacting with PostgreSQL-enabled Spanner database to specify that a
   * value should be treated using the semantics of the OID type.
   *
   * @generated from enum value: PG_OID = 4;
   */
  PG_OID = 4,
}

/**
 * Describes the enum google.spanner.v1.TypeAnnotationCode.
 */
export const TypeAnnotationCodeSchema: GenEnum<TypeAnnotationCode> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_type, 1);

