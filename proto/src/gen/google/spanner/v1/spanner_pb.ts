// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/spanner/v1/spanner.proto (package google.spanner.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { CommitResponseSchema } from "./commit_response_pb";
import { file_google_spanner_v1_commit_response } from "./commit_response_pb";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import { file_google_api_resource } from "../../api/resource_pb";
import type { Duration, EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../rpc/status_pb";
import { file_google_rpc_status } from "../../rpc/status_pb";
import type { KeySet } from "./keys_pb";
import { file_google_spanner_v1_keys } from "./keys_pb";
import type { Mutation } from "./mutation_pb";
import { file_google_spanner_v1_mutation } from "./mutation_pb";
import type { PartialResultSetSchema, ResultSet, ResultSetSchema } from "./result_set_pb";
import { file_google_spanner_v1_result_set } from "./result_set_pb";
import type { Transaction, TransactionOptions, TransactionSchema, TransactionSelector } from "./transaction_pb";
import { file_google_spanner_v1_transaction } from "./transaction_pb";
import type { Type } from "./type_pb";
import { file_google_spanner_v1_type } from "./type_pb";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/spanner/v1/spanner.proto.
 */
export const file_google_spanner_v1_spanner: GenFile = /*@__PURE__*/
  fileDesc("Ch9nb29nbGUvc3Bhbm5lci92MS9zcGFubmVyLnByb3RvEhFnb29nbGUuc3Bhbm5lci52MSKDAQoUQ3JlYXRlU2Vzc2lvblJlcXVlc3QSOQoIZGF0YWJhc2UYASABKAlCJ+BBAvpBIQofc3Bhbm5lci5nb29nbGVhcGlzLmNvbS9EYXRhYmFzZRIwCgdzZXNzaW9uGAIgASgLMhouZ29vZ2xlLnNwYW5uZXIudjEuU2Vzc2lvbkID4EECIqkBChpCYXRjaENyZWF0ZVNlc3Npb25zUmVxdWVzdBI5CghkYXRhYmFzZRgBIAEoCUIn4EEC+kEhCh9zcGFubmVyLmdvb2dsZWFwaXMuY29tL0RhdGFiYXNlEjQKEHNlc3Npb25fdGVtcGxhdGUYAiABKAsyGi5nb29nbGUuc3Bhbm5lci52MS5TZXNzaW9uEhoKDXNlc3Npb25fY291bnQYAyABKAVCA+BBAiJKChtCYXRjaENyZWF0ZVNlc3Npb25zUmVzcG9uc2USKwoHc2Vzc2lvbhgBIAMoCzIaLmdvb2dsZS5zcGFubmVyLnYxLlNlc3Npb24iowMKB1Nlc3Npb24SEQoEbmFtZRgBIAEoCUID4EEDEjYKBmxhYmVscxgCIAMoCzImLmdvb2dsZS5zcGFubmVyLnYxLlNlc3Npb24uTGFiZWxzRW50cnkSNAoLY3JlYXRlX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSQgoZYXBwcm94aW1hdGVfbGFzdF91c2VfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxIUCgxjcmVhdG9yX3JvbGUYBSABKAkSGAoLbXVsdGlwbGV4ZWQYBiABKAhCA+BBARotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBOnTqQXEKHnNwYW5uZXIuZ29vZ2xlYXBpcy5jb20vU2Vzc2lvbhJPcHJvamVjdHMve3Byb2plY3R9L2luc3RhbmNlcy97aW5zdGFuY2V9L2RhdGFiYXNlcy97ZGF0YWJhc2V9L3Nlc3Npb25zL3tzZXNzaW9ufSJJChFHZXRTZXNzaW9uUmVxdWVzdBI0CgRuYW1lGAEgASgJQibgQQL6QSAKHnNwYW5uZXIuZ29vZ2xlYXBpcy5jb20vU2Vzc2lvbiKHAQoTTGlzdFNlc3Npb25zUmVxdWVzdBI5CghkYXRhYmFzZRgBIAEoCUIn4EEC+kEhCh9zcGFubmVyLmdvb2dsZWFwaXMuY29tL0RhdGFiYXNlEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJEg4KBmZpbHRlchgEIAEoCSJdChRMaXN0U2Vzc2lvbnNSZXNwb25zZRIsCghzZXNzaW9ucxgBIAMoCzIaLmdvb2dsZS5zcGFubmVyLnYxLlNlc3Npb24SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIkwKFERlbGV0ZVNlc3Npb25SZXF1ZXN0EjQKBG5hbWUYASABKAlCJuBBAvpBIAoec3Bhbm5lci5nb29nbGVhcGlzLmNvbS9TZXNzaW9uItwBCg5SZXF1ZXN0T3B0aW9ucxI8Cghwcmlvcml0eRgBIAEoDjIqLmdvb2dsZS5zcGFubmVyLnYxLlJlcXVlc3RPcHRpb25zLlByaW9yaXR5EhMKC3JlcXVlc3RfdGFnGAIgASgJEhcKD3RyYW5zYWN0aW9uX3RhZxgDIAEoCSJeCghQcmlvcml0eRIYChRQUklPUklUWV9VTlNQRUNJRklFRBAAEhAKDFBSSU9SSVRZX0xPVxABEhMKD1BSSU9SSVRZX01FRElVTRACEhEKDVBSSU9SSVRZX0hJR0gQAyLqBAoTRGlyZWN0ZWRSZWFkT3B0aW9ucxJSChBpbmNsdWRlX3JlcGxpY2FzGAEgASgLMjYuZ29vZ2xlLnNwYW5uZXIudjEuRGlyZWN0ZWRSZWFkT3B0aW9ucy5JbmNsdWRlUmVwbGljYXNIABJSChBleGNsdWRlX3JlcGxpY2FzGAIgASgLMjYuZ29vZ2xlLnNwYW5uZXIudjEuRGlyZWN0ZWRSZWFkT3B0aW9ucy5FeGNsdWRlUmVwbGljYXNIABqtAQoQUmVwbGljYVNlbGVjdGlvbhIQCghsb2NhdGlvbhgBIAEoCRJKCgR0eXBlGAIgASgOMjwuZ29vZ2xlLnNwYW5uZXIudjEuRGlyZWN0ZWRSZWFkT3B0aW9ucy5SZXBsaWNhU2VsZWN0aW9uLlR5cGUiOwoEVHlwZRIUChBUWVBFX1VOU1BFQ0lGSUVEEAASDgoKUkVBRF9XUklURRABEg0KCVJFQURfT05MWRACGoYBCg9JbmNsdWRlUmVwbGljYXMSUwoScmVwbGljYV9zZWxlY3Rpb25zGAEgAygLMjcuZ29vZ2xlLnNwYW5uZXIudjEuRGlyZWN0ZWRSZWFkT3B0aW9ucy5SZXBsaWNhU2VsZWN0aW9uEh4KFmF1dG9fZmFpbG92ZXJfZGlzYWJsZWQYAiABKAgaZgoPRXhjbHVkZVJlcGxpY2FzElMKEnJlcGxpY2Ffc2VsZWN0aW9ucxgBIAMoCzI3Lmdvb2dsZS5zcGFubmVyLnYxLkRpcmVjdGVkUmVhZE9wdGlvbnMuUmVwbGljYVNlbGVjdGlvbkIKCghyZXBsaWNhcyLHBgoRRXhlY3V0ZVNxbFJlcXVlc3QSNwoHc2Vzc2lvbhgBIAEoCUIm4EEC+kEgCh5zcGFubmVyLmdvb2dsZWFwaXMuY29tL1Nlc3Npb24SOwoLdHJhbnNhY3Rpb24YAiABKAsyJi5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlvblNlbGVjdG9yEhAKA3NxbBgDIAEoCUID4EECEicKBnBhcmFtcxgEIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSSQoLcGFyYW1fdHlwZXMYBSADKAsyNC5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlU3FsUmVxdWVzdC5QYXJhbVR5cGVzRW50cnkSFAoMcmVzdW1lX3Rva2VuGAYgASgMEkIKCnF1ZXJ5X21vZGUYByABKA4yLi5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlU3FsUmVxdWVzdC5RdWVyeU1vZGUSFwoPcGFydGl0aW9uX3Rva2VuGAggASgMEg0KBXNlcW5vGAkgASgDEkgKDXF1ZXJ5X29wdGlvbnMYCiABKAsyMS5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlU3FsUmVxdWVzdC5RdWVyeU9wdGlvbnMSOgoPcmVxdWVzdF9vcHRpb25zGAsgASgLMiEuZ29vZ2xlLnNwYW5uZXIudjEuUmVxdWVzdE9wdGlvbnMSRQoVZGlyZWN0ZWRfcmVhZF9vcHRpb25zGA8gASgLMiYuZ29vZ2xlLnNwYW5uZXIudjEuRGlyZWN0ZWRSZWFkT3B0aW9ucxIaChJkYXRhX2Jvb3N0X2VuYWJsZWQYECABKAgaTwoMUXVlcnlPcHRpb25zEhkKEW9wdGltaXplcl92ZXJzaW9uGAEgASgJEiQKHG9wdGltaXplcl9zdGF0aXN0aWNzX3BhY2thZ2UYAiABKAkaSgoPUGFyYW1UeXBlc0VudHJ5EgsKA2tleRgBIAEoCRImCgV2YWx1ZRgCIAEoCzIXLmdvb2dsZS5zcGFubmVyLnYxLlR5cGU6AjgBIi4KCVF1ZXJ5TW9kZRIKCgZOT1JNQUwQABIICgRQTEFOEAESCwoHUFJPRklMRRACIqAEChZFeGVjdXRlQmF0Y2hEbWxSZXF1ZXN0EjcKB3Nlc3Npb24YASABKAlCJuBBAvpBIAoec3Bhbm5lci5nb29nbGVhcGlzLmNvbS9TZXNzaW9uEkAKC3RyYW5zYWN0aW9uGAIgASgLMiYuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25TZWxlY3RvckID4EECEkwKCnN0YXRlbWVudHMYAyADKAsyMy5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlQmF0Y2hEbWxSZXF1ZXN0LlN0YXRlbWVudEID4EECEhIKBXNlcW5vGAQgASgDQgPgQQISOgoPcmVxdWVzdF9vcHRpb25zGAUgASgLMiEuZ29vZ2xlLnNwYW5uZXIudjEuUmVxdWVzdE9wdGlvbnMa7AEKCVN0YXRlbWVudBIQCgNzcWwYASABKAlCA+BBAhInCgZwYXJhbXMYAiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0ElgKC3BhcmFtX3R5cGVzGAMgAygLMkMuZ29vZ2xlLnNwYW5uZXIudjEuRXhlY3V0ZUJhdGNoRG1sUmVxdWVzdC5TdGF0ZW1lbnQuUGFyYW1UeXBlc0VudHJ5GkoKD1BhcmFtVHlwZXNFbnRyeRILCgNrZXkYASABKAkSJgoFdmFsdWUYAiABKAsyFy5nb29nbGUuc3Bhbm5lci52MS5UeXBlOgI4ASJwChdFeGVjdXRlQmF0Y2hEbWxSZXNwb25zZRIxCgtyZXN1bHRfc2V0cxgBIAMoCzIcLmdvb2dsZS5zcGFubmVyLnYxLlJlc3VsdFNldBIiCgZzdGF0dXMYAiABKAsyEi5nb29nbGUucnBjLlN0YXR1cyJIChBQYXJ0aXRpb25PcHRpb25zEhwKFHBhcnRpdGlvbl9zaXplX2J5dGVzGAEgASgDEhYKDm1heF9wYXJ0aXRpb25zGAIgASgDIqMDChVQYXJ0aXRpb25RdWVyeVJlcXVlc3QSNwoHc2Vzc2lvbhgBIAEoCUIm4EEC+kEgCh5zcGFubmVyLmdvb2dsZWFwaXMuY29tL1Nlc3Npb24SOwoLdHJhbnNhY3Rpb24YAiABKAsyJi5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlvblNlbGVjdG9yEhAKA3NxbBgDIAEoCUID4EECEicKBnBhcmFtcxgEIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSTQoLcGFyYW1fdHlwZXMYBSADKAsyOC5nb29nbGUuc3Bhbm5lci52MS5QYXJ0aXRpb25RdWVyeVJlcXVlc3QuUGFyYW1UeXBlc0VudHJ5Ej4KEXBhcnRpdGlvbl9vcHRpb25zGAYgASgLMiMuZ29vZ2xlLnNwYW5uZXIudjEuUGFydGl0aW9uT3B0aW9ucxpKCg9QYXJhbVR5cGVzRW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgLMhcuZ29vZ2xlLnNwYW5uZXIudjEuVHlwZToCOAEisQIKFFBhcnRpdGlvblJlYWRSZXF1ZXN0EjcKB3Nlc3Npb24YASABKAlCJuBBAvpBIAoec3Bhbm5lci5nb29nbGVhcGlzLmNvbS9TZXNzaW9uEjsKC3RyYW5zYWN0aW9uGAIgASgLMiYuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25TZWxlY3RvchISCgV0YWJsZRgDIAEoCUID4EECEg0KBWluZGV4GAQgASgJEg8KB2NvbHVtbnMYBSADKAkSLwoHa2V5X3NldBgGIAEoCzIZLmdvb2dsZS5zcGFubmVyLnYxLktleVNldEID4EECEj4KEXBhcnRpdGlvbl9vcHRpb25zGAkgASgLMiMuZ29vZ2xlLnNwYW5uZXIudjEuUGFydGl0aW9uT3B0aW9ucyIkCglQYXJ0aXRpb24SFwoPcGFydGl0aW9uX3Rva2VuGAEgASgMInoKEVBhcnRpdGlvblJlc3BvbnNlEjAKCnBhcnRpdGlvbnMYASADKAsyHC5nb29nbGUuc3Bhbm5lci52MS5QYXJ0aXRpb24SMwoLdHJhbnNhY3Rpb24YAiABKAsyHi5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlvbiL2BQoLUmVhZFJlcXVlc3QSNwoHc2Vzc2lvbhgBIAEoCUIm4EEC+kEgCh5zcGFubmVyLmdvb2dsZWFwaXMuY29tL1Nlc3Npb24SOwoLdHJhbnNhY3Rpb24YAiABKAsyJi5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlvblNlbGVjdG9yEhIKBXRhYmxlGAMgASgJQgPgQQISDQoFaW5kZXgYBCABKAkSFAoHY29sdW1ucxgFIAMoCUID4EECEi8KB2tleV9zZXQYBiABKAsyGS5nb29nbGUuc3Bhbm5lci52MS5LZXlTZXRCA+BBAhINCgVsaW1pdBgIIAEoAxIUCgxyZXN1bWVfdG9rZW4YCSABKAwSFwoPcGFydGl0aW9uX3Rva2VuGAogASgMEjoKD3JlcXVlc3Rfb3B0aW9ucxgLIAEoCzIhLmdvb2dsZS5zcGFubmVyLnYxLlJlcXVlc3RPcHRpb25zEkUKFWRpcmVjdGVkX3JlYWRfb3B0aW9ucxgOIAEoCzImLmdvb2dsZS5zcGFubmVyLnYxLkRpcmVjdGVkUmVhZE9wdGlvbnMSGgoSZGF0YV9ib29zdF9lbmFibGVkGA8gASgIEj0KCG9yZGVyX2J5GBAgASgOMiYuZ29vZ2xlLnNwYW5uZXIudjEuUmVhZFJlcXVlc3QuT3JkZXJCeUID4EEBEj8KCWxvY2tfaGludBgRIAEoDjInLmdvb2dsZS5zcGFubmVyLnYxLlJlYWRSZXF1ZXN0LkxvY2tIaW50QgPgQQEiVAoHT3JkZXJCeRIYChRPUkRFUl9CWV9VTlNQRUNJRklFRBAAEhgKFE9SREVSX0JZX1BSSU1BUllfS0VZEAESFQoRT1JERVJfQllfTk9fT1JERVIQAiJUCghMb2NrSGludBIZChVMT0NLX0hJTlRfVU5TUEVDSUZJRUQQABIUChBMT0NLX0hJTlRfU0hBUkVEEAESFwoTTE9DS19ISU5UX0VYQ0xVU0lWRRACIssBChdCZWdpblRyYW5zYWN0aW9uUmVxdWVzdBI3CgdzZXNzaW9uGAEgASgJQibgQQL6QSAKHnNwYW5uZXIuZ29vZ2xlYXBpcy5jb20vU2Vzc2lvbhI7CgdvcHRpb25zGAIgASgLMiUuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zQgPgQQISOgoPcmVxdWVzdF9vcHRpb25zGAMgASgLMiEuZ29vZ2xlLnNwYW5uZXIudjEuUmVxdWVzdE9wdGlvbnMi/QIKDUNvbW1pdFJlcXVlc3QSNwoHc2Vzc2lvbhgBIAEoCUIm4EEC+kEgCh5zcGFubmVyLmdvb2dsZWFwaXMuY29tL1Nlc3Npb24SGAoOdHJhbnNhY3Rpb25faWQYAiABKAxIABJHChZzaW5nbGVfdXNlX3RyYW5zYWN0aW9uGAMgASgLMiUuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zSAASLgoJbXV0YXRpb25zGAQgAygLMhsuZ29vZ2xlLnNwYW5uZXIudjEuTXV0YXRpb24SGwoTcmV0dXJuX2NvbW1pdF9zdGF0cxgFIAEoCBI4ChBtYXhfY29tbWl0X2RlbGF5GAggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgPgQQESOgoPcmVxdWVzdF9vcHRpb25zGAYgASgLMiEuZ29vZ2xlLnNwYW5uZXIudjEuUmVxdWVzdE9wdGlvbnNCDQoLdHJhbnNhY3Rpb24iZwoPUm9sbGJhY2tSZXF1ZXN0EjcKB3Nlc3Npb24YASABKAlCJuBBAvpBIAoec3Bhbm5lci5nb29nbGVhcGlzLmNvbS9TZXNzaW9uEhsKDnRyYW5zYWN0aW9uX2lkGAIgASgMQgPgQQIizgIKEUJhdGNoV3JpdGVSZXF1ZXN0EjcKB3Nlc3Npb24YASABKAlCJuBBAvpBIAoec3Bhbm5lci5nb29nbGVhcGlzLmNvbS9TZXNzaW9uEjoKD3JlcXVlc3Rfb3B0aW9ucxgDIAEoCzIhLmdvb2dsZS5zcGFubmVyLnYxLlJlcXVlc3RPcHRpb25zElAKD211dGF0aW9uX2dyb3VwcxgEIAMoCzIyLmdvb2dsZS5zcGFubmVyLnYxLkJhdGNoV3JpdGVSZXF1ZXN0Lk11dGF0aW9uR3JvdXBCA+BBAhIsCh9leGNsdWRlX3R4bl9mcm9tX2NoYW5nZV9zdHJlYW1zGAUgASgIQgPgQQEaRAoNTXV0YXRpb25Hcm91cBIzCgltdXRhdGlvbnMYASADKAsyGy5nb29nbGUuc3Bhbm5lci52MS5NdXRhdGlvbkID4EECIn8KEkJhdGNoV3JpdGVSZXNwb25zZRIPCgdpbmRleGVzGAEgAygFEiIKBnN0YXR1cxgCIAEoCzISLmdvb2dsZS5ycGMuU3RhdHVzEjQKEGNvbW1pdF90aW1lc3RhbXAYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wMosYCgdTcGFubmVyEqYBCg1DcmVhdGVTZXNzaW9uEicuZ29vZ2xlLnNwYW5uZXIudjEuQ3JlYXRlU2Vzc2lvblJlcXVlc3QaGi5nb29nbGUuc3Bhbm5lci52MS5TZXNzaW9uIlDaQQhkYXRhYmFzZYLT5JMCPzoBKiI6L3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qfS9zZXNzaW9ucxLgAQoTQmF0Y2hDcmVhdGVTZXNzaW9ucxItLmdvb2dsZS5zcGFubmVyLnYxLkJhdGNoQ3JlYXRlU2Vzc2lvbnNSZXF1ZXN0Gi4uZ29vZ2xlLnNwYW5uZXIudjEuQmF0Y2hDcmVhdGVTZXNzaW9uc1Jlc3BvbnNlImraQRZkYXRhYmFzZSxzZXNzaW9uX2NvdW50gtPkkwJLOgEqIkYvdjEve2RhdGFiYXNlPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyp9L3Nlc3Npb25zOmJhdGNoQ3JlYXRlEpcBCgpHZXRTZXNzaW9uEiQuZ29vZ2xlLnNwYW5uZXIudjEuR2V0U2Vzc2lvblJlcXVlc3QaGi5nb29nbGUuc3Bhbm5lci52MS5TZXNzaW9uIkfaQQRuYW1lgtPkkwI6EjgvdjEve25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi9kYXRhYmFzZXMvKi9zZXNzaW9ucy8qfRKuAQoMTGlzdFNlc3Npb25zEiYuZ29vZ2xlLnNwYW5uZXIudjEuTGlzdFNlc3Npb25zUmVxdWVzdBonLmdvb2dsZS5zcGFubmVyLnYxLkxpc3RTZXNzaW9uc1Jlc3BvbnNlIk3aQQhkYXRhYmFzZYLT5JMCPBI6L3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qfS9zZXNzaW9ucxKZAQoNRGVsZXRlU2Vzc2lvbhInLmdvb2dsZS5zcGFubmVyLnYxLkRlbGV0ZVNlc3Npb25SZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IkfaQQRuYW1lgtPkkwI6KjgvdjEve25hbWU9cHJvamVjdHMvKi9pbnN0YW5jZXMvKi9kYXRhYmFzZXMvKi9zZXNzaW9ucy8qfRKjAQoKRXhlY3V0ZVNxbBIkLmdvb2dsZS5zcGFubmVyLnYxLkV4ZWN1dGVTcWxSZXF1ZXN0GhwuZ29vZ2xlLnNwYW5uZXIudjEuUmVzdWx0U2V0IlGC0+STAks6ASoiRi92MS97c2Vzc2lvbj1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qL3Nlc3Npb25zLyp9OmV4ZWN1dGVTcWwSvgEKE0V4ZWN1dGVTdHJlYW1pbmdTcWwSJC5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlU3FsUmVxdWVzdBojLmdvb2dsZS5zcGFubmVyLnYxLlBhcnRpYWxSZXN1bHRTZXQiWoLT5JMCVDoBKiJPL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06ZXhlY3V0ZVN0cmVhbWluZ1NxbDABEsABCg9FeGVjdXRlQmF0Y2hEbWwSKS5nb29nbGUuc3Bhbm5lci52MS5FeGVjdXRlQmF0Y2hEbWxSZXF1ZXN0GiouZ29vZ2xlLnNwYW5uZXIudjEuRXhlY3V0ZUJhdGNoRG1sUmVzcG9uc2UiVoLT5JMCUDoBKiJLL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06ZXhlY3V0ZUJhdGNoRG1sEpEBCgRSZWFkEh4uZ29vZ2xlLnNwYW5uZXIudjEuUmVhZFJlcXVlc3QaHC5nb29nbGUuc3Bhbm5lci52MS5SZXN1bHRTZXQiS4LT5JMCRToBKiJAL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06cmVhZBKsAQoNU3RyZWFtaW5nUmVhZBIeLmdvb2dsZS5zcGFubmVyLnYxLlJlYWRSZXF1ZXN0GiMuZ29vZ2xlLnNwYW5uZXIudjEuUGFydGlhbFJlc3VsdFNldCJUgtPkkwJOOgEqIkkvdjEve3Nlc3Npb249cHJvamVjdHMvKi9pbnN0YW5jZXMvKi9kYXRhYmFzZXMvKi9zZXNzaW9ucy8qfTpzdHJlYW1pbmdSZWFkMAESyQEKEEJlZ2luVHJhbnNhY3Rpb24SKi5nb29nbGUuc3Bhbm5lci52MS5CZWdpblRyYW5zYWN0aW9uUmVxdWVzdBoeLmdvb2dsZS5zcGFubmVyLnYxLlRyYW5zYWN0aW9uImnaQQ9zZXNzaW9uLG9wdGlvbnOC0+STAlE6ASoiTC92MS97c2Vzc2lvbj1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qL3Nlc3Npb25zLyp9OmJlZ2luVHJhbnNhY3Rpb24S6wEKBkNvbW1pdBIgLmdvb2dsZS5zcGFubmVyLnYxLkNvbW1pdFJlcXVlc3QaIS5nb29nbGUuc3Bhbm5lci52MS5Db21taXRSZXNwb25zZSKbAdpBIHNlc3Npb24sdHJhbnNhY3Rpb25faWQsbXV0YXRpb25z2kEoc2Vzc2lvbixzaW5nbGVfdXNlX3RyYW5zYWN0aW9uLG11dGF0aW9uc4LT5JMCRzoBKiJCL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06Y29tbWl0ErABCghSb2xsYmFjaxIiLmdvb2dsZS5zcGFubmVyLnYxLlJvbGxiYWNrUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSJo2kEWc2Vzc2lvbix0cmFuc2FjdGlvbl9pZILT5JMCSToBKiJEL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06cm9sbGJhY2sStwEKDlBhcnRpdGlvblF1ZXJ5EiguZ29vZ2xlLnNwYW5uZXIudjEuUGFydGl0aW9uUXVlcnlSZXF1ZXN0GiQuZ29vZ2xlLnNwYW5uZXIudjEuUGFydGl0aW9uUmVzcG9uc2UiVYLT5JMCTzoBKiJKL3YxL3tzZXNzaW9uPXByb2plY3RzLyovaW5zdGFuY2VzLyovZGF0YWJhc2VzLyovc2Vzc2lvbnMvKn06cGFydGl0aW9uUXVlcnkStAEKDVBhcnRpdGlvblJlYWQSJy5nb29nbGUuc3Bhbm5lci52MS5QYXJ0aXRpb25SZWFkUmVxdWVzdBokLmdvb2dsZS5zcGFubmVyLnYxLlBhcnRpdGlvblJlc3BvbnNlIlSC0+STAk46ASoiSS92MS97c2Vzc2lvbj1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qL3Nlc3Npb25zLyp9OnBhcnRpdGlvblJlYWQSyAEKCkJhdGNoV3JpdGUSJC5nb29nbGUuc3Bhbm5lci52MS5CYXRjaFdyaXRlUmVxdWVzdBolLmdvb2dsZS5zcGFubmVyLnYxLkJhdGNoV3JpdGVSZXNwb25zZSJr2kEXc2Vzc2lvbixtdXRhdGlvbl9ncm91cHOC0+STAks6ASoiRi92MS97c2Vzc2lvbj1wcm9qZWN0cy8qL2luc3RhbmNlcy8qL2RhdGFiYXNlcy8qL3Nlc3Npb25zLyp9OmJhdGNoV3JpdGUwARp3ykEWc3Bhbm5lci5nb29nbGVhcGlzLmNvbdJBW2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0saHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9zcGFubmVyLmRhdGFCkQIKFWNvbS5nb29nbGUuc3Bhbm5lci52MUIMU3Bhbm5lclByb3RvUAFaNWNsb3VkLmdvb2dsZS5jb20vZ28vc3Bhbm5lci9hcGl2MS9zcGFubmVycGI7c3Bhbm5lcnBiqgIXR29vZ2xlLkNsb3VkLlNwYW5uZXIuVjHKAhdHb29nbGVcQ2xvdWRcU3Bhbm5lclxWMeoCGkdvb2dsZTo6Q2xvdWQ6OlNwYW5uZXI6OlYx6kFfCh9zcGFubmVyLmdvb2dsZWFwaXMuY29tL0RhdGFiYXNlEjxwcm9qZWN0cy97cHJvamVjdH0vaW5zdGFuY2VzL3tpbnN0YW5jZX0vZGF0YWJhc2VzL3tkYXRhYmFzZX1QAGIGcHJvdG8z", [file_google_spanner_v1_commit_response, file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp, file_google_rpc_status, file_google_spanner_v1_keys, file_google_spanner_v1_mutation, file_google_spanner_v1_result_set, file_google_spanner_v1_transaction, file_google_spanner_v1_type]);

/**
 * The request for [CreateSession][google.spanner.v1.Spanner.CreateSession].
 *
 * @generated from message google.spanner.v1.CreateSessionRequest
 */
export type CreateSessionRequest = Message<"google.spanner.v1.CreateSessionRequest"> & {
  /**
   * Required. The database in which the new session is created.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * Required. The session to create.
   *
   * @generated from field: google.spanner.v1.Session session = 2;
   */
  session?: Session;
};

/**
 * Describes the message google.spanner.v1.CreateSessionRequest.
 * Use `create(CreateSessionRequestSchema)` to create a new message.
 */
export const CreateSessionRequestSchema: GenMessage<CreateSessionRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 0);

/**
 * The request for
 * [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
 *
 * @generated from message google.spanner.v1.BatchCreateSessionsRequest
 */
export type BatchCreateSessionsRequest = Message<"google.spanner.v1.BatchCreateSessionsRequest"> & {
  /**
   * Required. The database in which the new sessions are created.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * Parameters to be applied to each created session.
   *
   * @generated from field: google.spanner.v1.Session session_template = 2;
   */
  sessionTemplate?: Session;

  /**
   * Required. The number of sessions to be created in this batch call.
   * The API may return fewer than the requested number of sessions. If a
   * specific number of sessions are desired, the client can make additional
   * calls to BatchCreateSessions (adjusting
   * [session_count][google.spanner.v1.BatchCreateSessionsRequest.session_count]
   * as necessary).
   *
   * @generated from field: int32 session_count = 3;
   */
  sessionCount: number;
};

/**
 * Describes the message google.spanner.v1.BatchCreateSessionsRequest.
 * Use `create(BatchCreateSessionsRequestSchema)` to create a new message.
 */
export const BatchCreateSessionsRequestSchema: GenMessage<BatchCreateSessionsRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 1);

/**
 * The response for
 * [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
 *
 * @generated from message google.spanner.v1.BatchCreateSessionsResponse
 */
export type BatchCreateSessionsResponse = Message<"google.spanner.v1.BatchCreateSessionsResponse"> & {
  /**
   * The freshly created sessions.
   *
   * @generated from field: repeated google.spanner.v1.Session session = 1;
   */
  session: Session[];
};

/**
 * Describes the message google.spanner.v1.BatchCreateSessionsResponse.
 * Use `create(BatchCreateSessionsResponseSchema)` to create a new message.
 */
export const BatchCreateSessionsResponseSchema: GenMessage<BatchCreateSessionsResponse> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 2);

/**
 * A session in the Cloud Spanner API.
 *
 * @generated from message google.spanner.v1.Session
 */
export type Session = Message<"google.spanner.v1.Session"> & {
  /**
   * Output only. The name of the session. This is always system-assigned.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The labels for the session.
   *
   *  * Label keys must be between 1 and 63 characters long and must conform to
   *    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
   *  * Label values must be between 0 and 63 characters long and must conform
   *    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
   *  * No more than 64 labels can be associated with a given session.
   *
   * See https://goo.gl/xmQnxf for more information on and examples of labels.
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string };

  /**
   * Output only. The timestamp when the session is created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * Output only. The approximate timestamp when the session is last used. It is
   * typically earlier than the actual last use time.
   *
   * @generated from field: google.protobuf.Timestamp approximate_last_use_time = 4;
   */
  approximateLastUseTime?: Timestamp;

  /**
   * The database role which created this session.
   *
   * @generated from field: string creator_role = 5;
   */
  creatorRole: string;

  /**
   * Optional. If true, specifies a multiplexed session. A multiplexed session
   * may be used for multiple, concurrent read-only operations but can not be
   * used for read-write transactions, partitioned reads, or partitioned
   * queries. Multiplexed sessions can be created via
   * [CreateSession][google.spanner.v1.Spanner.CreateSession] but not via
   * [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
   * Multiplexed sessions may not be deleted nor listed.
   *
   * @generated from field: bool multiplexed = 6;
   */
  multiplexed: boolean;
};

/**
 * Describes the message google.spanner.v1.Session.
 * Use `create(SessionSchema)` to create a new message.
 */
export const SessionSchema: GenMessage<Session> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 3);

/**
 * The request for [GetSession][google.spanner.v1.Spanner.GetSession].
 *
 * @generated from message google.spanner.v1.GetSessionRequest
 */
export type GetSessionRequest = Message<"google.spanner.v1.GetSessionRequest"> & {
  /**
   * Required. The name of the session to retrieve.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.spanner.v1.GetSessionRequest.
 * Use `create(GetSessionRequestSchema)` to create a new message.
 */
export const GetSessionRequestSchema: GenMessage<GetSessionRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 4);

/**
 * The request for [ListSessions][google.spanner.v1.Spanner.ListSessions].
 *
 * @generated from message google.spanner.v1.ListSessionsRequest
 */
export type ListSessionsRequest = Message<"google.spanner.v1.ListSessionsRequest"> & {
  /**
   * Required. The database in which to list sessions.
   *
   * @generated from field: string database = 1;
   */
  database: string;

  /**
   * Number of sessions to be returned in the response. If 0 or less, defaults
   * to the server's maximum allowed page size.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.v1.ListSessionsResponse.next_page_token]
   * from a previous
   * [ListSessionsResponse][google.spanner.v1.ListSessionsResponse].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * An expression for filtering the results of the request. Filter rules are
   * case insensitive. The fields eligible for filtering are:
   *
   *   * `labels.key` where key is the name of a label
   *
   * Some examples of using filters are:
   *
   *   * `labels.env:*` --> The session has the label "env".
   *   * `labels.env:dev` --> The session has the label "env" and the value of
   *                        the label contains the string "dev".
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message google.spanner.v1.ListSessionsRequest.
 * Use `create(ListSessionsRequestSchema)` to create a new message.
 */
export const ListSessionsRequestSchema: GenMessage<ListSessionsRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 5);

/**
 * The response for [ListSessions][google.spanner.v1.Spanner.ListSessions].
 *
 * @generated from message google.spanner.v1.ListSessionsResponse
 */
export type ListSessionsResponse = Message<"google.spanner.v1.ListSessionsResponse"> & {
  /**
   * The list of requested sessions.
   *
   * @generated from field: repeated google.spanner.v1.Session sessions = 1;
   */
  sessions: Session[];

  /**
   * `next_page_token` can be sent in a subsequent
   * [ListSessions][google.spanner.v1.Spanner.ListSessions] call to fetch more
   * of the matching sessions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.spanner.v1.ListSessionsResponse.
 * Use `create(ListSessionsResponseSchema)` to create a new message.
 */
export const ListSessionsResponseSchema: GenMessage<ListSessionsResponse> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 6);

/**
 * The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession].
 *
 * @generated from message google.spanner.v1.DeleteSessionRequest
 */
export type DeleteSessionRequest = Message<"google.spanner.v1.DeleteSessionRequest"> & {
  /**
   * Required. The name of the session to delete.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.spanner.v1.DeleteSessionRequest.
 * Use `create(DeleteSessionRequestSchema)` to create a new message.
 */
export const DeleteSessionRequestSchema: GenMessage<DeleteSessionRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 7);

/**
 * Common request options for various APIs.
 *
 * @generated from message google.spanner.v1.RequestOptions
 */
export type RequestOptions = Message<"google.spanner.v1.RequestOptions"> & {
  /**
   * Priority for the request.
   *
   * @generated from field: google.spanner.v1.RequestOptions.Priority priority = 1;
   */
  priority: RequestOptions_Priority;

  /**
   * A per-request tag which can be applied to queries or reads, used for
   * statistics collection.
   * Both request_tag and transaction_tag can be specified for a read or query
   * that belongs to a transaction.
   * This field is ignored for requests where it's not applicable (e.g.
   * CommitRequest).
   * Legal characters for `request_tag` values are all printable characters
   * (ASCII 32 - 126) and the length of a request_tag is limited to 50
   * characters. Values that exceed this limit are truncated.
   * Any leading underscore (_) characters will be removed from the string.
   *
   * @generated from field: string request_tag = 2;
   */
  requestTag: string;

  /**
   * A tag used for statistics collection about this transaction.
   * Both request_tag and transaction_tag can be specified for a read or query
   * that belongs to a transaction.
   * The value of transaction_tag should be the same for all requests belonging
   * to the same transaction.
   * If this request doesn't belong to any transaction, transaction_tag will be
   * ignored.
   * Legal characters for `transaction_tag` values are all printable characters
   * (ASCII 32 - 126) and the length of a transaction_tag is limited to 50
   * characters. Values that exceed this limit are truncated.
   * Any leading underscore (_) characters will be removed from the string.
   *
   * @generated from field: string transaction_tag = 3;
   */
  transactionTag: string;
};

/**
 * Describes the message google.spanner.v1.RequestOptions.
 * Use `create(RequestOptionsSchema)` to create a new message.
 */
export const RequestOptionsSchema: GenMessage<RequestOptions> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 8);

/**
 * The relative priority for requests. Note that priority is not applicable
 * for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].
 *
 * The priority acts as a hint to the Cloud Spanner scheduler and does not
 * guarantee priority or order of execution. For example:
 *
 * * Some parts of a write operation always execute at `PRIORITY_HIGH`,
 *   regardless of the specified priority. This may cause you to see an
 *   increase in high priority workload even when executing a low priority
 *   request. This can also potentially cause a priority inversion where a
 *   lower priority request will be fulfilled ahead of a higher priority
 *   request.
 * * If a transaction contains multiple operations with different priorities,
 *   Cloud Spanner does not guarantee to process the higher priority
 *   operations first. There may be other constraints to satisfy, such as
 *   order of operations.
 *
 * @generated from enum google.spanner.v1.RequestOptions.Priority
 */
export enum RequestOptions_Priority {
  /**
   * `PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`.
   *
   * @generated from enum value: PRIORITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * This specifies that the request is low priority.
   *
   * @generated from enum value: PRIORITY_LOW = 1;
   */
  LOW = 1,

  /**
   * This specifies that the request is medium priority.
   *
   * @generated from enum value: PRIORITY_MEDIUM = 2;
   */
  MEDIUM = 2,

  /**
   * This specifies that the request is high priority.
   *
   * @generated from enum value: PRIORITY_HIGH = 3;
   */
  HIGH = 3,
}

/**
 * Describes the enum google.spanner.v1.RequestOptions.Priority.
 */
export const RequestOptions_PrioritySchema: GenEnum<RequestOptions_Priority> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_spanner, 8, 0);

/**
 * The DirectedReadOptions can be used to indicate which replicas or regions
 * should be used for non-transactional reads or queries.
 *
 * DirectedReadOptions may only be specified for a read-only transaction,
 * otherwise the API will return an `INVALID_ARGUMENT` error.
 *
 * @generated from message google.spanner.v1.DirectedReadOptions
 */
export type DirectedReadOptions = Message<"google.spanner.v1.DirectedReadOptions"> & {
  /**
   * Required. At most one of either include_replicas or exclude_replicas
   * should be present in the message.
   *
   * @generated from oneof google.spanner.v1.DirectedReadOptions.replicas
   */
  replicas: {
    /**
     * Include_replicas indicates the order of replicas (as they appear in
     * this list) to process the request. If auto_failover_disabled is set to
     * true and all replicas are exhausted without finding a healthy replica,
     * Spanner will wait for a replica in the list to become available, requests
     * may fail due to `DEADLINE_EXCEEDED` errors.
     *
     * @generated from field: google.spanner.v1.DirectedReadOptions.IncludeReplicas include_replicas = 1;
     */
    value: DirectedReadOptions_IncludeReplicas;
    case: "includeReplicas";
  } | {
    /**
     * Exclude_replicas indicates that specified replicas should be excluded
     * from serving requests. Spanner will not route requests to the replicas
     * in this list.
     *
     * @generated from field: google.spanner.v1.DirectedReadOptions.ExcludeReplicas exclude_replicas = 2;
     */
    value: DirectedReadOptions_ExcludeReplicas;
    case: "excludeReplicas";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.spanner.v1.DirectedReadOptions.
 * Use `create(DirectedReadOptionsSchema)` to create a new message.
 */
export const DirectedReadOptionsSchema: GenMessage<DirectedReadOptions> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 9);

/**
 * The directed read replica selector.
 * Callers must provide one or more of the following fields for replica
 * selection:
 *
 *   * `location` - The location must be one of the regions within the
 *      multi-region configuration of your database.
 *   * `type` - The type of the replica.
 *
 * Some examples of using replica_selectors are:
 *
 *   * `location:us-east1` --> The "us-east1" replica(s) of any available type
 *                             will be used to process the request.
 *   * `type:READ_ONLY`    --> The "READ_ONLY" type replica(s) in nearest
 *                             available location will be used to process the
 *                             request.
 *   * `location:us-east1 type:READ_ONLY` --> The "READ_ONLY" type replica(s)
 *                          in location "us-east1" will be used to process
 *                          the request.
 *
 * @generated from message google.spanner.v1.DirectedReadOptions.ReplicaSelection
 */
export type DirectedReadOptions_ReplicaSelection = Message<"google.spanner.v1.DirectedReadOptions.ReplicaSelection"> & {
  /**
   * The location or region of the serving requests, e.g. "us-east1".
   *
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * The type of replica.
   *
   * @generated from field: google.spanner.v1.DirectedReadOptions.ReplicaSelection.Type type = 2;
   */
  type: DirectedReadOptions_ReplicaSelection_Type;
};

/**
 * Describes the message google.spanner.v1.DirectedReadOptions.ReplicaSelection.
 * Use `create(DirectedReadOptions_ReplicaSelectionSchema)` to create a new message.
 */
export const DirectedReadOptions_ReplicaSelectionSchema: GenMessage<DirectedReadOptions_ReplicaSelection> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 9, 0);

/**
 * Indicates the type of replica.
 *
 * @generated from enum google.spanner.v1.DirectedReadOptions.ReplicaSelection.Type
 */
export enum DirectedReadOptions_ReplicaSelection_Type {
  /**
   * Not specified.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Read-write replicas support both reads and writes.
   *
   * @generated from enum value: READ_WRITE = 1;
   */
  READ_WRITE = 1,

  /**
   * Read-only replicas only support reads (not writes).
   *
   * @generated from enum value: READ_ONLY = 2;
   */
  READ_ONLY = 2,
}

/**
 * Describes the enum google.spanner.v1.DirectedReadOptions.ReplicaSelection.Type.
 */
export const DirectedReadOptions_ReplicaSelection_TypeSchema: GenEnum<DirectedReadOptions_ReplicaSelection_Type> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_spanner, 9, 0, 0);

/**
 * An IncludeReplicas contains a repeated set of ReplicaSelection which
 * indicates the order in which replicas should be considered.
 *
 * @generated from message google.spanner.v1.DirectedReadOptions.IncludeReplicas
 */
export type DirectedReadOptions_IncludeReplicas = Message<"google.spanner.v1.DirectedReadOptions.IncludeReplicas"> & {
  /**
   * The directed read replica selector.
   *
   * @generated from field: repeated google.spanner.v1.DirectedReadOptions.ReplicaSelection replica_selections = 1;
   */
  replicaSelections: DirectedReadOptions_ReplicaSelection[];

  /**
   * If true, Spanner will not route requests to a replica outside the
   * include_replicas list when all of the specified replicas are unavailable
   * or unhealthy. Default value is `false`.
   *
   * @generated from field: bool auto_failover_disabled = 2;
   */
  autoFailoverDisabled: boolean;
};

/**
 * Describes the message google.spanner.v1.DirectedReadOptions.IncludeReplicas.
 * Use `create(DirectedReadOptions_IncludeReplicasSchema)` to create a new message.
 */
export const DirectedReadOptions_IncludeReplicasSchema: GenMessage<DirectedReadOptions_IncludeReplicas> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 9, 1);

/**
 * An ExcludeReplicas contains a repeated set of ReplicaSelection that should
 * be excluded from serving requests.
 *
 * @generated from message google.spanner.v1.DirectedReadOptions.ExcludeReplicas
 */
export type DirectedReadOptions_ExcludeReplicas = Message<"google.spanner.v1.DirectedReadOptions.ExcludeReplicas"> & {
  /**
   * The directed read replica selector.
   *
   * @generated from field: repeated google.spanner.v1.DirectedReadOptions.ReplicaSelection replica_selections = 1;
   */
  replicaSelections: DirectedReadOptions_ReplicaSelection[];
};

/**
 * Describes the message google.spanner.v1.DirectedReadOptions.ExcludeReplicas.
 * Use `create(DirectedReadOptions_ExcludeReplicasSchema)` to create a new message.
 */
export const DirectedReadOptions_ExcludeReplicasSchema: GenMessage<DirectedReadOptions_ExcludeReplicas> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 9, 2);

/**
 * The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
 * [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].
 *
 * @generated from message google.spanner.v1.ExecuteSqlRequest
 */
export type ExecuteSqlRequest = Message<"google.spanner.v1.ExecuteSqlRequest"> & {
  /**
   * Required. The session in which the SQL query should be performed.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * The transaction to use.
   *
   * For queries, if none is provided, the default is a temporary read-only
   * transaction with strong concurrency.
   *
   * Standard DML statements require a read-write transaction. To protect
   * against replays, single-use transactions are not supported.  The caller
   * must either supply an existing transaction ID or begin a new transaction.
   *
   * Partitioned DML requires an existing Partitioned DML transaction ID.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The SQL string.
   *
   * @generated from field: string sql = 3;
   */
  sql: string;

  /**
   * Parameter names and values that bind to placeholders in the SQL string.
   *
   * A parameter placeholder consists of the `@` character followed by the
   * parameter name (for example, `@firstName`). Parameter names must conform
   * to the naming requirements of identifiers as specified at
   * https://cloud.google.com/spanner/docs/lexical#identifiers.
   *
   * Parameters can appear anywhere that a literal value is expected.  The same
   * parameter name can be used more than once, for example:
   *
   * `"WHERE id > @msg_id AND id < @msg_id + 100"`
   *
   * It is an error to execute a SQL statement with unbound parameters.
   *
   * @generated from field: google.protobuf.Struct params = 4;
   */
  params?: JsonObject;

  /**
   * It is not always possible for Cloud Spanner to infer the right SQL type
   * from a JSON value.  For example, values of type `BYTES` and values
   * of type `STRING` both appear in
   * [params][google.spanner.v1.ExecuteSqlRequest.params] as JSON strings.
   *
   * In these cases, `param_types` can be used to specify the exact
   * SQL type for some or all of the SQL statement parameters. See the
   * definition of [Type][google.spanner.v1.Type] for more information
   * about SQL types.
   *
   * @generated from field: map<string, google.spanner.v1.Type> param_types = 5;
   */
  paramTypes: { [key: string]: Type };

  /**
   * If this request is resuming a previously interrupted SQL statement
   * execution, `resume_token` should be copied from the last
   * [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the
   * interruption. Doing this enables the new SQL statement execution to resume
   * where the last one left off. The rest of the request parameters must
   * exactly match the request that yielded this token.
   *
   * @generated from field: bytes resume_token = 6;
   */
  resumeToken: Uint8Array;

  /**
   * Used to control the amount of debugging information returned in
   * [ResultSetStats][google.spanner.v1.ResultSetStats]. If
   * [partition_token][google.spanner.v1.ExecuteSqlRequest.partition_token] is
   * set, [query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode] can only
   * be set to
   * [QueryMode.NORMAL][google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL].
   *
   * @generated from field: google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
   */
  queryMode: ExecuteSqlRequest_QueryMode;

  /**
   * If present, results will be restricted to the specified partition
   * previously created using PartitionQuery().  There must be an exact
   * match for the values of fields common to this message and the
   * PartitionQueryRequest message used to create this partition_token.
   *
   * @generated from field: bytes partition_token = 8;
   */
  partitionToken: Uint8Array;

  /**
   * A per-transaction sequence number used to identify this request. This field
   * makes each request idempotent such that if the request is received multiple
   * times, at most one will succeed.
   *
   * The sequence number must be monotonically increasing within the
   * transaction. If a request arrives for the first time with an out-of-order
   * sequence number, the transaction may be aborted. Replays of previously
   * handled requests will yield the same response as the first execution.
   *
   * Required for DML statements. Ignored for queries.
   *
   * @generated from field: int64 seqno = 9;
   */
  seqno: bigint;

  /**
   * Query optimizer configuration to use for the given query.
   *
   * @generated from field: google.spanner.v1.ExecuteSqlRequest.QueryOptions query_options = 10;
   */
  queryOptions?: ExecuteSqlRequest_QueryOptions;

  /**
   * Common options for this request.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 11;
   */
  requestOptions?: RequestOptions;

  /**
   * Directed read options for this request.
   *
   * @generated from field: google.spanner.v1.DirectedReadOptions directed_read_options = 15;
   */
  directedReadOptions?: DirectedReadOptions;

  /**
   * If this is for a partitioned query and this field is set to `true`, the
   * request is executed with Spanner Data Boost independent compute resources.
   *
   * If the field is set to `true` but the request does not set
   * `partition_token`, the API returns an `INVALID_ARGUMENT` error.
   *
   * @generated from field: bool data_boost_enabled = 16;
   */
  dataBoostEnabled: boolean;
};

/**
 * Describes the message google.spanner.v1.ExecuteSqlRequest.
 * Use `create(ExecuteSqlRequestSchema)` to create a new message.
 */
export const ExecuteSqlRequestSchema: GenMessage<ExecuteSqlRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 10);

/**
 * Query optimizer configuration.
 *
 * @generated from message google.spanner.v1.ExecuteSqlRequest.QueryOptions
 */
export type ExecuteSqlRequest_QueryOptions = Message<"google.spanner.v1.ExecuteSqlRequest.QueryOptions"> & {
  /**
   * An option to control the selection of optimizer version.
   *
   * This parameter allows individual queries to pick different query
   * optimizer versions.
   *
   * Specifying `latest` as a value instructs Cloud Spanner to use the
   * latest supported query optimizer version. If not specified, Cloud Spanner
   * uses the optimizer version set at the database level options. Any other
   * positive integer (from the list of supported optimizer versions)
   * overrides the default optimizer version for query execution.
   *
   * The list of supported optimizer versions can be queried from
   * SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS.
   *
   * Executing a SQL statement with an invalid optimizer version fails with
   * an `INVALID_ARGUMENT` error.
   *
   * See
   * https://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer
   * for more information on managing the query optimizer.
   *
   * The `optimizer_version` statement hint has precedence over this setting.
   *
   * @generated from field: string optimizer_version = 1;
   */
  optimizerVersion: string;

  /**
   * An option to control the selection of optimizer statistics package.
   *
   * This parameter allows individual queries to use a different query
   * optimizer statistics package.
   *
   * Specifying `latest` as a value instructs Cloud Spanner to use the latest
   * generated statistics package. If not specified, Cloud Spanner uses
   * the statistics package set at the database level options, or the latest
   * package if the database option is not set.
   *
   * The statistics package requested by the query has to be exempt from
   * garbage collection. This can be achieved with the following DDL
   * statement:
   *
   * ```
   * ALTER STATISTICS <package_name> SET OPTIONS (allow_gc=false)
   * ```
   *
   * The list of available statistics packages can be queried from
   * `INFORMATION_SCHEMA.SPANNER_STATISTICS`.
   *
   * Executing a SQL statement with an invalid optimizer statistics package
   * or with a statistics package that allows garbage collection fails with
   * an `INVALID_ARGUMENT` error.
   *
   * @generated from field: string optimizer_statistics_package = 2;
   */
  optimizerStatisticsPackage: string;
};

/**
 * Describes the message google.spanner.v1.ExecuteSqlRequest.QueryOptions.
 * Use `create(ExecuteSqlRequest_QueryOptionsSchema)` to create a new message.
 */
export const ExecuteSqlRequest_QueryOptionsSchema: GenMessage<ExecuteSqlRequest_QueryOptions> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 10, 0);

/**
 * Mode in which the statement must be processed.
 *
 * @generated from enum google.spanner.v1.ExecuteSqlRequest.QueryMode
 */
export enum ExecuteSqlRequest_QueryMode {
  /**
   * The default mode. Only the statement results are returned.
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * This mode returns only the query plan, without any results or
   * execution statistics information.
   *
   * @generated from enum value: PLAN = 1;
   */
  PLAN = 1,

  /**
   * This mode returns both the query plan and the execution statistics along
   * with the results.
   *
   * @generated from enum value: PROFILE = 2;
   */
  PROFILE = 2,
}

/**
 * Describes the enum google.spanner.v1.ExecuteSqlRequest.QueryMode.
 */
export const ExecuteSqlRequest_QueryModeSchema: GenEnum<ExecuteSqlRequest_QueryMode> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_spanner, 10, 0);

/**
 * The request for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml].
 *
 * @generated from message google.spanner.v1.ExecuteBatchDmlRequest
 */
export type ExecuteBatchDmlRequest = Message<"google.spanner.v1.ExecuteBatchDmlRequest"> & {
  /**
   * Required. The session in which the DML statements should be performed.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Required. The transaction to use. Must be a read-write transaction.
   *
   * To protect against replays, single-use transactions are not supported. The
   * caller must either supply an existing transaction ID or begin a new
   * transaction.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The list of statements to execute in this batch. Statements are
   * executed serially, such that the effects of statement `i` are visible to
   * statement `i+1`. Each statement must be a DML statement. Execution stops at
   * the first failed statement; the remaining statements are not executed.
   *
   * Callers must provide at least one statement.
   *
   * @generated from field: repeated google.spanner.v1.ExecuteBatchDmlRequest.Statement statements = 3;
   */
  statements: ExecuteBatchDmlRequest_Statement[];

  /**
   * Required. A per-transaction sequence number used to identify this request.
   * This field makes each request idempotent such that if the request is
   * received multiple times, at most one will succeed.
   *
   * The sequence number must be monotonically increasing within the
   * transaction. If a request arrives for the first time with an out-of-order
   * sequence number, the transaction may be aborted. Replays of previously
   * handled requests will yield the same response as the first execution.
   *
   * @generated from field: int64 seqno = 4;
   */
  seqno: bigint;

  /**
   * Common options for this request.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 5;
   */
  requestOptions?: RequestOptions;
};

/**
 * Describes the message google.spanner.v1.ExecuteBatchDmlRequest.
 * Use `create(ExecuteBatchDmlRequestSchema)` to create a new message.
 */
export const ExecuteBatchDmlRequestSchema: GenMessage<ExecuteBatchDmlRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 11);

/**
 * A single DML statement.
 *
 * @generated from message google.spanner.v1.ExecuteBatchDmlRequest.Statement
 */
export type ExecuteBatchDmlRequest_Statement = Message<"google.spanner.v1.ExecuteBatchDmlRequest.Statement"> & {
  /**
   * Required. The DML string.
   *
   * @generated from field: string sql = 1;
   */
  sql: string;

  /**
   * Parameter names and values that bind to placeholders in the DML string.
   *
   * A parameter placeholder consists of the `@` character followed by the
   * parameter name (for example, `@firstName`). Parameter names can contain
   * letters, numbers, and underscores.
   *
   * Parameters can appear anywhere that a literal value is expected.  The
   * same parameter name can be used more than once, for example:
   *
   * `"WHERE id > @msg_id AND id < @msg_id + 100"`
   *
   * It is an error to execute a SQL statement with unbound parameters.
   *
   * @generated from field: google.protobuf.Struct params = 2;
   */
  params?: JsonObject;

  /**
   * It is not always possible for Cloud Spanner to infer the right SQL type
   * from a JSON value.  For example, values of type `BYTES` and values
   * of type `STRING` both appear in
   * [params][google.spanner.v1.ExecuteBatchDmlRequest.Statement.params] as
   * JSON strings.
   *
   * In these cases, `param_types` can be used to specify the exact
   * SQL type for some or all of the SQL statement parameters. See the
   * definition of [Type][google.spanner.v1.Type] for more information
   * about SQL types.
   *
   * @generated from field: map<string, google.spanner.v1.Type> param_types = 3;
   */
  paramTypes: { [key: string]: Type };
};

/**
 * Describes the message google.spanner.v1.ExecuteBatchDmlRequest.Statement.
 * Use `create(ExecuteBatchDmlRequest_StatementSchema)` to create a new message.
 */
export const ExecuteBatchDmlRequest_StatementSchema: GenMessage<ExecuteBatchDmlRequest_Statement> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 11, 0);

/**
 * The response for
 * [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml]. Contains a list
 * of [ResultSet][google.spanner.v1.ResultSet] messages, one for each DML
 * statement that has successfully executed, in the same order as the statements
 * in the request. If a statement fails, the status in the response body
 * identifies the cause of the failure.
 *
 * To check for DML statements that failed, use the following approach:
 *
 * 1. Check the status in the response message. The
 * [google.rpc.Code][google.rpc.Code] enum
 *    value `OK` indicates that all statements were executed successfully.
 * 2. If the status was not `OK`, check the number of result sets in the
 *    response. If the response contains `N`
 *    [ResultSet][google.spanner.v1.ResultSet] messages, then statement `N+1` in
 *    the request failed.
 *
 * Example 1:
 *
 * * Request: 5 DML statements, all executed successfully.
 * * Response: 5 [ResultSet][google.spanner.v1.ResultSet] messages, with the
 * status `OK`.
 *
 * Example 2:
 *
 * * Request: 5 DML statements. The third statement has a syntax error.
 * * Response: 2 [ResultSet][google.spanner.v1.ResultSet] messages, and a syntax
 * error (`INVALID_ARGUMENT`)
 *   status. The number of [ResultSet][google.spanner.v1.ResultSet] messages
 *   indicates that the third statement failed, and the fourth and fifth
 *   statements were not executed.
 *
 * @generated from message google.spanner.v1.ExecuteBatchDmlResponse
 */
export type ExecuteBatchDmlResponse = Message<"google.spanner.v1.ExecuteBatchDmlResponse"> & {
  /**
   * One [ResultSet][google.spanner.v1.ResultSet] for each statement in the
   * request that ran successfully, in the same order as the statements in the
   * request. Each [ResultSet][google.spanner.v1.ResultSet] does not contain any
   * rows. The [ResultSetStats][google.spanner.v1.ResultSetStats] in each
   * [ResultSet][google.spanner.v1.ResultSet] contain the number of rows
   * modified by the statement.
   *
   * Only the first [ResultSet][google.spanner.v1.ResultSet] in the response
   * contains valid [ResultSetMetadata][google.spanner.v1.ResultSetMetadata].
   *
   * @generated from field: repeated google.spanner.v1.ResultSet result_sets = 1;
   */
  resultSets: ResultSet[];

  /**
   * If all DML statements are executed successfully, the status is `OK`.
   * Otherwise, the error status of the first failed statement.
   *
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;
};

/**
 * Describes the message google.spanner.v1.ExecuteBatchDmlResponse.
 * Use `create(ExecuteBatchDmlResponseSchema)` to create a new message.
 */
export const ExecuteBatchDmlResponseSchema: GenMessage<ExecuteBatchDmlResponse> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 12);

/**
 * Options for a PartitionQueryRequest and
 * PartitionReadRequest.
 *
 * @generated from message google.spanner.v1.PartitionOptions
 */
export type PartitionOptions = Message<"google.spanner.v1.PartitionOptions"> & {
  /**
   * **Note:** This hint is currently ignored by PartitionQuery and
   * PartitionRead requests.
   *
   * The desired data size for each partition generated.  The default for this
   * option is currently 1 GiB.  This is only a hint. The actual size of each
   * partition may be smaller or larger than this size request.
   *
   * @generated from field: int64 partition_size_bytes = 1;
   */
  partitionSizeBytes: bigint;

  /**
   * **Note:** This hint is currently ignored by PartitionQuery and
   * PartitionRead requests.
   *
   * The desired maximum number of partitions to return.  For example, this may
   * be set to the number of workers available.  The default for this option
   * is currently 10,000. The maximum value is currently 200,000.  This is only
   * a hint.  The actual number of partitions returned may be smaller or larger
   * than this maximum count request.
   *
   * @generated from field: int64 max_partitions = 2;
   */
  maxPartitions: bigint;
};

/**
 * Describes the message google.spanner.v1.PartitionOptions.
 * Use `create(PartitionOptionsSchema)` to create a new message.
 */
export const PartitionOptionsSchema: GenMessage<PartitionOptions> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 13);

/**
 * The request for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
 *
 * @generated from message google.spanner.v1.PartitionQueryRequest
 */
export type PartitionQueryRequest = Message<"google.spanner.v1.PartitionQueryRequest"> & {
  /**
   * Required. The session used to create the partitions.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Read only snapshot transactions are supported, read/write and single use
   * transactions are not.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The query request to generate partitions for. The request will
   * fail if the query is not root partitionable. For a query to be root
   * partitionable, it needs to satisfy a few conditions. For example, if the
   * query execution plan contains a distributed union operator, then it must be
   * the first operator in the plan. For more information about other
   * conditions, see [Read data in
   * parallel](https://cloud.google.com/spanner/docs/reads#read_data_in_parallel).
   *
   * The query request must not contain DML commands, such as INSERT, UPDATE, or
   * DELETE. Use
   * [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] with a
   * PartitionedDml transaction for large, partition-friendly DML operations.
   *
   * @generated from field: string sql = 3;
   */
  sql: string;

  /**
   * Parameter names and values that bind to placeholders in the SQL string.
   *
   * A parameter placeholder consists of the `@` character followed by the
   * parameter name (for example, `@firstName`). Parameter names can contain
   * letters, numbers, and underscores.
   *
   * Parameters can appear anywhere that a literal value is expected.  The same
   * parameter name can be used more than once, for example:
   *
   * `"WHERE id > @msg_id AND id < @msg_id + 100"`
   *
   * It is an error to execute a SQL statement with unbound parameters.
   *
   * @generated from field: google.protobuf.Struct params = 4;
   */
  params?: JsonObject;

  /**
   * It is not always possible for Cloud Spanner to infer the right SQL type
   * from a JSON value.  For example, values of type `BYTES` and values
   * of type `STRING` both appear in
   * [params][google.spanner.v1.PartitionQueryRequest.params] as JSON strings.
   *
   * In these cases, `param_types` can be used to specify the exact
   * SQL type for some or all of the SQL query parameters. See the
   * definition of [Type][google.spanner.v1.Type] for more information
   * about SQL types.
   *
   * @generated from field: map<string, google.spanner.v1.Type> param_types = 5;
   */
  paramTypes: { [key: string]: Type };

  /**
   * Additional options that affect how many partitions are created.
   *
   * @generated from field: google.spanner.v1.PartitionOptions partition_options = 6;
   */
  partitionOptions?: PartitionOptions;
};

/**
 * Describes the message google.spanner.v1.PartitionQueryRequest.
 * Use `create(PartitionQueryRequestSchema)` to create a new message.
 */
export const PartitionQueryRequestSchema: GenMessage<PartitionQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 14);

/**
 * The request for [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
 *
 * @generated from message google.spanner.v1.PartitionReadRequest
 */
export type PartitionReadRequest = Message<"google.spanner.v1.PartitionReadRequest"> & {
  /**
   * Required. The session used to create the partitions.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Read only snapshot transactions are supported, read/write and single use
   * transactions are not.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The name of the table in the database to be read.
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * If non-empty, the name of an index on
   * [table][google.spanner.v1.PartitionReadRequest.table]. This index is used
   * instead of the table primary key when interpreting
   * [key_set][google.spanner.v1.PartitionReadRequest.key_set] and sorting
   * result rows. See [key_set][google.spanner.v1.PartitionReadRequest.key_set]
   * for further information.
   *
   * @generated from field: string index = 4;
   */
  index: string;

  /**
   * The columns of [table][google.spanner.v1.PartitionReadRequest.table] to be
   * returned for each row matching this request.
   *
   * @generated from field: repeated string columns = 5;
   */
  columns: string[];

  /**
   * Required. `key_set` identifies the rows to be yielded. `key_set` names the
   * primary keys of the rows in
   * [table][google.spanner.v1.PartitionReadRequest.table] to be yielded, unless
   * [index][google.spanner.v1.PartitionReadRequest.index] is present. If
   * [index][google.spanner.v1.PartitionReadRequest.index] is present, then
   * [key_set][google.spanner.v1.PartitionReadRequest.key_set] instead names
   * index keys in [index][google.spanner.v1.PartitionReadRequest.index].
   *
   * It is not an error for the `key_set` to name rows that do not
   * exist in the database. Read yields nothing for nonexistent rows.
   *
   * @generated from field: google.spanner.v1.KeySet key_set = 6;
   */
  keySet?: KeySet;

  /**
   * Additional options that affect how many partitions are created.
   *
   * @generated from field: google.spanner.v1.PartitionOptions partition_options = 9;
   */
  partitionOptions?: PartitionOptions;
};

/**
 * Describes the message google.spanner.v1.PartitionReadRequest.
 * Use `create(PartitionReadRequestSchema)` to create a new message.
 */
export const PartitionReadRequestSchema: GenMessage<PartitionReadRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 15);

/**
 * Information returned for each partition returned in a
 * PartitionResponse.
 *
 * @generated from message google.spanner.v1.Partition
 */
export type Partition = Message<"google.spanner.v1.Partition"> & {
  /**
   * This token can be passed to Read, StreamingRead, ExecuteSql, or
   * ExecuteStreamingSql requests to restrict the results to those identified by
   * this partition token.
   *
   * @generated from field: bytes partition_token = 1;
   */
  partitionToken: Uint8Array;
};

/**
 * Describes the message google.spanner.v1.Partition.
 * Use `create(PartitionSchema)` to create a new message.
 */
export const PartitionSchema: GenMessage<Partition> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 16);

/**
 * The response for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
 * or [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
 *
 * @generated from message google.spanner.v1.PartitionResponse
 */
export type PartitionResponse = Message<"google.spanner.v1.PartitionResponse"> & {
  /**
   * Partitions created by this request.
   *
   * @generated from field: repeated google.spanner.v1.Partition partitions = 1;
   */
  partitions: Partition[];

  /**
   * Transaction created by this request.
   *
   * @generated from field: google.spanner.v1.Transaction transaction = 2;
   */
  transaction?: Transaction;
};

/**
 * Describes the message google.spanner.v1.PartitionResponse.
 * Use `create(PartitionResponseSchema)` to create a new message.
 */
export const PartitionResponseSchema: GenMessage<PartitionResponse> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 17);

/**
 * The request for [Read][google.spanner.v1.Spanner.Read] and
 * [StreamingRead][google.spanner.v1.Spanner.StreamingRead].
 *
 * @generated from message google.spanner.v1.ReadRequest
 */
export type ReadRequest = Message<"google.spanner.v1.ReadRequest"> & {
  /**
   * Required. The session in which the read should be performed.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * The transaction to use. If none is provided, the default is a
   * temporary read-only transaction with strong concurrency.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The name of the table in the database to be read.
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * If non-empty, the name of an index on
   * [table][google.spanner.v1.ReadRequest.table]. This index is used instead of
   * the table primary key when interpreting
   * [key_set][google.spanner.v1.ReadRequest.key_set] and sorting result rows.
   * See [key_set][google.spanner.v1.ReadRequest.key_set] for further
   * information.
   *
   * @generated from field: string index = 4;
   */
  index: string;

  /**
   * Required. The columns of [table][google.spanner.v1.ReadRequest.table] to be
   * returned for each row matching this request.
   *
   * @generated from field: repeated string columns = 5;
   */
  columns: string[];

  /**
   * Required. `key_set` identifies the rows to be yielded. `key_set` names the
   * primary keys of the rows in [table][google.spanner.v1.ReadRequest.table] to
   * be yielded, unless [index][google.spanner.v1.ReadRequest.index] is present.
   * If [index][google.spanner.v1.ReadRequest.index] is present, then
   * [key_set][google.spanner.v1.ReadRequest.key_set] instead names index keys
   * in [index][google.spanner.v1.ReadRequest.index].
   *
   * If the [partition_token][google.spanner.v1.ReadRequest.partition_token]
   * field is empty, rows are yielded in table primary key order (if
   * [index][google.spanner.v1.ReadRequest.index] is empty) or index key order
   * (if [index][google.spanner.v1.ReadRequest.index] is non-empty).  If the
   * [partition_token][google.spanner.v1.ReadRequest.partition_token] field is
   * not empty, rows will be yielded in an unspecified order.
   *
   * It is not an error for the `key_set` to name rows that do not
   * exist in the database. Read yields nothing for nonexistent rows.
   *
   * @generated from field: google.spanner.v1.KeySet key_set = 6;
   */
  keySet?: KeySet;

  /**
   * If greater than zero, only the first `limit` rows are yielded. If `limit`
   * is zero, the default is no limit. A limit cannot be specified if
   * `partition_token` is set.
   *
   * @generated from field: int64 limit = 8;
   */
  limit: bigint;

  /**
   * If this request is resuming a previously interrupted read,
   * `resume_token` should be copied from the last
   * [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the
   * interruption. Doing this enables the new read to resume where the last read
   * left off. The rest of the request parameters must exactly match the request
   * that yielded this token.
   *
   * @generated from field: bytes resume_token = 9;
   */
  resumeToken: Uint8Array;

  /**
   * If present, results will be restricted to the specified partition
   * previously created using PartitionRead().    There must be an exact
   * match for the values of fields common to this message and the
   * PartitionReadRequest message used to create this partition_token.
   *
   * @generated from field: bytes partition_token = 10;
   */
  partitionToken: Uint8Array;

  /**
   * Common options for this request.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 11;
   */
  requestOptions?: RequestOptions;

  /**
   * Directed read options for this request.
   *
   * @generated from field: google.spanner.v1.DirectedReadOptions directed_read_options = 14;
   */
  directedReadOptions?: DirectedReadOptions;

  /**
   * If this is for a partitioned read and this field is set to `true`, the
   * request is executed with Spanner Data Boost independent compute resources.
   *
   * If the field is set to `true` but the request does not set
   * `partition_token`, the API returns an `INVALID_ARGUMENT` error.
   *
   * @generated from field: bool data_boost_enabled = 15;
   */
  dataBoostEnabled: boolean;

  /**
   * Optional. Order for the returned rows.
   *
   * By default, Spanner will return result rows in primary key order except for
   * PartitionRead requests. For applications that do not require rows to be
   * returned in primary key (`ORDER_BY_PRIMARY_KEY`) order, setting
   * `ORDER_BY_NO_ORDER` option allows Spanner to optimize row retrieval,
   * resulting in lower latencies in certain cases (e.g. bulk point lookups).
   *
   * @generated from field: google.spanner.v1.ReadRequest.OrderBy order_by = 16;
   */
  orderBy: ReadRequest_OrderBy;

  /**
   * Optional. Lock Hint for the request, it can only be used with read-write
   * transactions.
   *
   * @generated from field: google.spanner.v1.ReadRequest.LockHint lock_hint = 17;
   */
  lockHint: ReadRequest_LockHint;
};

/**
 * Describes the message google.spanner.v1.ReadRequest.
 * Use `create(ReadRequestSchema)` to create a new message.
 */
export const ReadRequestSchema: GenMessage<ReadRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 18);

/**
 * An option to control the order in which rows are returned from a read.
 *
 * @generated from enum google.spanner.v1.ReadRequest.OrderBy
 */
export enum ReadRequest_OrderBy {
  /**
   * Default value.
   *
   * ORDER_BY_UNSPECIFIED is equivalent to ORDER_BY_PRIMARY_KEY.
   *
   * @generated from enum value: ORDER_BY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Read rows are returned in primary key order.
   *
   * In the event that this option is used in conjunction with the
   * `partition_token` field, the API will return an `INVALID_ARGUMENT` error.
   *
   * @generated from enum value: ORDER_BY_PRIMARY_KEY = 1;
   */
  PRIMARY_KEY = 1,

  /**
   * Read rows are returned in any order.
   *
   * @generated from enum value: ORDER_BY_NO_ORDER = 2;
   */
  NO_ORDER = 2,
}

/**
 * Describes the enum google.spanner.v1.ReadRequest.OrderBy.
 */
export const ReadRequest_OrderBySchema: GenEnum<ReadRequest_OrderBy> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_spanner, 18, 0);

/**
 * A lock hint mechanism for reads done within a transaction.
 *
 * @generated from enum google.spanner.v1.ReadRequest.LockHint
 */
export enum ReadRequest_LockHint {
  /**
   * Default value.
   *
   * LOCK_HINT_UNSPECIFIED is equivalent to LOCK_HINT_SHARED.
   *
   * @generated from enum value: LOCK_HINT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Acquire shared locks.
   *
   * By default when you perform a read as part of a read-write transaction,
   * Spanner acquires shared read locks, which allows other reads to still
   * access the data until your transaction is ready to commit. When your
   * transaction is committing and writes are being applied, the transaction
   * attempts to upgrade to an exclusive lock for any data you are writing.
   * For more information about locks, see [Lock
   * modes](https://cloud.google.com/spanner/docs/introspection/lock-statistics#explain-lock-modes).
   *
   * @generated from enum value: LOCK_HINT_SHARED = 1;
   */
  SHARED = 1,

  /**
   * Acquire exclusive locks.
   *
   * Requesting exclusive locks is beneficial if you observe high write
   * contention, which means you notice that multiple transactions are
   * concurrently trying to read and write to the same data, resulting in a
   * large number of aborts. This problem occurs when two transactions
   * initially acquire shared locks and then both try to upgrade to exclusive
   * locks at the same time. In this situation both transactions are waiting
   * for the other to give up their lock, resulting in a deadlocked situation.
   * Spanner is able to detect this occurring and force one of the
   * transactions to abort. However, this is a slow and expensive operation
   * and results in lower performance. In this case it makes sense to acquire
   * exclusive locks at the start of the transaction because then when
   * multiple transactions try to act on the same data, they automatically get
   * serialized. Each transaction waits its turn to acquire the lock and
   * avoids getting into deadlock situations.
   *
   * Because the exclusive lock hint is just a hint, it should not be
   * considered equivalent to a mutex. In other words, you should not use
   * Spanner exclusive locks as a mutual exclusion mechanism for the execution
   * of code outside of Spanner.
   *
   * **Note:** Request exclusive locks judiciously because they block others
   * from reading that data for the entire transaction, rather than just when
   * the writes are being performed. Unless you observe high write contention,
   * you should use the default of shared read locks so you don't prematurely
   * block other clients from reading the data that you're writing to.
   *
   * @generated from enum value: LOCK_HINT_EXCLUSIVE = 2;
   */
  EXCLUSIVE = 2,
}

/**
 * Describes the enum google.spanner.v1.ReadRequest.LockHint.
 */
export const ReadRequest_LockHintSchema: GenEnum<ReadRequest_LockHint> = /*@__PURE__*/
  enumDesc(file_google_spanner_v1_spanner, 18, 1);

/**
 * The request for
 * [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].
 *
 * @generated from message google.spanner.v1.BeginTransactionRequest
 */
export type BeginTransactionRequest = Message<"google.spanner.v1.BeginTransactionRequest"> & {
  /**
   * Required. The session in which the transaction runs.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Required. Options for the new transaction.
   *
   * @generated from field: google.spanner.v1.TransactionOptions options = 2;
   */
  options?: TransactionOptions;

  /**
   * Common options for this request.
   * Priority is ignored for this request. Setting the priority in this
   * request_options struct will not do anything. To set the priority for a
   * transaction, set it on the reads and writes that are part of this
   * transaction instead.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 3;
   */
  requestOptions?: RequestOptions;
};

/**
 * Describes the message google.spanner.v1.BeginTransactionRequest.
 * Use `create(BeginTransactionRequestSchema)` to create a new message.
 */
export const BeginTransactionRequestSchema: GenMessage<BeginTransactionRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 19);

/**
 * The request for [Commit][google.spanner.v1.Spanner.Commit].
 *
 * @generated from message google.spanner.v1.CommitRequest
 */
export type CommitRequest = Message<"google.spanner.v1.CommitRequest"> & {
  /**
   * Required. The session in which the transaction to be committed is running.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Required. The transaction in which to commit.
   *
   * @generated from oneof google.spanner.v1.CommitRequest.transaction
   */
  transaction: {
    /**
     * Commit a previously-started transaction.
     *
     * @generated from field: bytes transaction_id = 2;
     */
    value: Uint8Array;
    case: "transactionId";
  } | {
    /**
     * Execute mutations in a temporary transaction. Note that unlike
     * commit of a previously-started transaction, commit with a
     * temporary transaction is non-idempotent. That is, if the
     * `CommitRequest` is sent to Cloud Spanner more than once (for
     * instance, due to retries in the application, or in the
     * transport library), it is possible that the mutations are
     * executed more than once. If this is undesirable, use
     * [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction] and
     * [Commit][google.spanner.v1.Spanner.Commit] instead.
     *
     * @generated from field: google.spanner.v1.TransactionOptions single_use_transaction = 3;
     */
    value: TransactionOptions;
    case: "singleUseTransaction";
  } | { case: undefined; value?: undefined };

  /**
   * The mutations to be executed when this transaction commits. All
   * mutations are applied atomically, in the order they appear in
   * this list.
   *
   * @generated from field: repeated google.spanner.v1.Mutation mutations = 4;
   */
  mutations: Mutation[];

  /**
   * If `true`, then statistics related to the transaction will be included in
   * the [CommitResponse][google.spanner.v1.CommitResponse.commit_stats].
   * Default value is `false`.
   *
   * @generated from field: bool return_commit_stats = 5;
   */
  returnCommitStats: boolean;

  /**
   * Optional. The amount of latency this request is willing to incur in order
   * to improve throughput. If this field is not set, Spanner assumes requests
   * are relatively latency sensitive and automatically determines an
   * appropriate delay time. You can specify a batching delay value between 0
   * and 500 ms.
   *
   * @generated from field: google.protobuf.Duration max_commit_delay = 8;
   */
  maxCommitDelay?: Duration;

  /**
   * Common options for this request.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 6;
   */
  requestOptions?: RequestOptions;
};

/**
 * Describes the message google.spanner.v1.CommitRequest.
 * Use `create(CommitRequestSchema)` to create a new message.
 */
export const CommitRequestSchema: GenMessage<CommitRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 20);

/**
 * The request for [Rollback][google.spanner.v1.Spanner.Rollback].
 *
 * @generated from message google.spanner.v1.RollbackRequest
 */
export type RollbackRequest = Message<"google.spanner.v1.RollbackRequest"> & {
  /**
   * Required. The session in which the transaction to roll back is running.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Required. The transaction to roll back.
   *
   * @generated from field: bytes transaction_id = 2;
   */
  transactionId: Uint8Array;
};

/**
 * Describes the message google.spanner.v1.RollbackRequest.
 * Use `create(RollbackRequestSchema)` to create a new message.
 */
export const RollbackRequestSchema: GenMessage<RollbackRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 21);

/**
 * The request for [BatchWrite][google.spanner.v1.Spanner.BatchWrite].
 *
 * @generated from message google.spanner.v1.BatchWriteRequest
 */
export type BatchWriteRequest = Message<"google.spanner.v1.BatchWriteRequest"> & {
  /**
   * Required. The session in which the batch request is to be run.
   *
   * @generated from field: string session = 1;
   */
  session: string;

  /**
   * Common options for this request.
   *
   * @generated from field: google.spanner.v1.RequestOptions request_options = 3;
   */
  requestOptions?: RequestOptions;

  /**
   * Required. The groups of mutations to be applied.
   *
   * @generated from field: repeated google.spanner.v1.BatchWriteRequest.MutationGroup mutation_groups = 4;
   */
  mutationGroups: BatchWriteRequest_MutationGroup[];

  /**
   * Optional. When `exclude_txn_from_change_streams` is set to `true`:
   *  * Mutations from all transactions in this batch write operation will not
   *  be recorded in change streams with DDL option `allow_txn_exclusion=true`
   *  that are tracking columns modified by these transactions.
   *  * Mutations from all transactions in this batch write operation will be
   *  recorded in change streams with DDL option `allow_txn_exclusion=false or
   *  not set` that are tracking columns modified by these transactions.
   *
   * When `exclude_txn_from_change_streams` is set to `false` or not set,
   * mutations from all transactions in this batch write operation will be
   * recorded in all change streams that are tracking columns modified by these
   * transactions.
   *
   * @generated from field: bool exclude_txn_from_change_streams = 5;
   */
  excludeTxnFromChangeStreams: boolean;
};

/**
 * Describes the message google.spanner.v1.BatchWriteRequest.
 * Use `create(BatchWriteRequestSchema)` to create a new message.
 */
export const BatchWriteRequestSchema: GenMessage<BatchWriteRequest> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 22);

/**
 * A group of mutations to be committed together. Related mutations should be
 * placed in a group. For example, two mutations inserting rows with the same
 * primary key prefix in both parent and child tables are related.
 *
 * @generated from message google.spanner.v1.BatchWriteRequest.MutationGroup
 */
export type BatchWriteRequest_MutationGroup = Message<"google.spanner.v1.BatchWriteRequest.MutationGroup"> & {
  /**
   * Required. The mutations in this group.
   *
   * @generated from field: repeated google.spanner.v1.Mutation mutations = 1;
   */
  mutations: Mutation[];
};

/**
 * Describes the message google.spanner.v1.BatchWriteRequest.MutationGroup.
 * Use `create(BatchWriteRequest_MutationGroupSchema)` to create a new message.
 */
export const BatchWriteRequest_MutationGroupSchema: GenMessage<BatchWriteRequest_MutationGroup> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 22, 0);

/**
 * The result of applying a batch of mutations.
 *
 * @generated from message google.spanner.v1.BatchWriteResponse
 */
export type BatchWriteResponse = Message<"google.spanner.v1.BatchWriteResponse"> & {
  /**
   * The mutation groups applied in this batch. The values index into the
   * `mutation_groups` field in the corresponding `BatchWriteRequest`.
   *
   * @generated from field: repeated int32 indexes = 1;
   */
  indexes: number[];

  /**
   * An `OK` status indicates success. Any other status indicates a failure.
   *
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;

  /**
   * The commit timestamp of the transaction that applied this batch.
   * Present if `status` is `OK`, absent otherwise.
   *
   * @generated from field: google.protobuf.Timestamp commit_timestamp = 3;
   */
  commitTimestamp?: Timestamp;
};

/**
 * Describes the message google.spanner.v1.BatchWriteResponse.
 * Use `create(BatchWriteResponseSchema)` to create a new message.
 */
export const BatchWriteResponseSchema: GenMessage<BatchWriteResponse> = /*@__PURE__*/
  messageDesc(file_google_spanner_v1_spanner, 23);

/**
 * Cloud Spanner API
 *
 * The Cloud Spanner API can be used to manage sessions and execute
 * transactions on data stored in Cloud Spanner databases.
 *
 * @generated from service google.spanner.v1.Spanner
 */
export const Spanner: GenService<{
  /**
   * Creates a new session. A session can be used to perform
   * transactions that read and/or modify data in a Cloud Spanner database.
   * Sessions are meant to be reused for many consecutive
   * transactions.
   *
   * Sessions can only execute one transaction at a time. To execute
   * multiple concurrent read-write/write-only transactions, create
   * multiple sessions. Note that standalone reads and queries use a
   * transaction internally, and count toward the one transaction
   * limit.
   *
   * Active sessions use additional server resources, so it is a good idea to
   * delete idle and unneeded sessions.
   * Aside from explicit deletes, Cloud Spanner may delete sessions for which no
   * operations are sent for more than an hour. If a session is deleted,
   * requests to it return `NOT_FOUND`.
   *
   * Idle sessions can be kept alive by sending a trivial SQL query
   * periodically, e.g., `"SELECT 1"`.
   *
   * @generated from rpc google.spanner.v1.Spanner.CreateSession
   */
  createSession: {
    methodKind: "unary";
    input: typeof CreateSessionRequestSchema;
    output: typeof SessionSchema;
  },
  /**
   * Creates multiple new sessions.
   *
   * This API can be used to initialize a session cache on the clients.
   * See https://goo.gl/TgSFN2 for best practices on session cache management.
   *
   * @generated from rpc google.spanner.v1.Spanner.BatchCreateSessions
   */
  batchCreateSessions: {
    methodKind: "unary";
    input: typeof BatchCreateSessionsRequestSchema;
    output: typeof BatchCreateSessionsResponseSchema;
  },
  /**
   * Gets a session. Returns `NOT_FOUND` if the session does not exist.
   * This is mainly useful for determining whether a session is still
   * alive.
   *
   * @generated from rpc google.spanner.v1.Spanner.GetSession
   */
  getSession: {
    methodKind: "unary";
    input: typeof GetSessionRequestSchema;
    output: typeof SessionSchema;
  },
  /**
   * Lists all sessions in a given database.
   *
   * @generated from rpc google.spanner.v1.Spanner.ListSessions
   */
  listSessions: {
    methodKind: "unary";
    input: typeof ListSessionsRequestSchema;
    output: typeof ListSessionsResponseSchema;
  },
  /**
   * Ends a session, releasing server resources associated with it. This will
   * asynchronously trigger cancellation of any operations that are running with
   * this session.
   *
   * @generated from rpc google.spanner.v1.Spanner.DeleteSession
   */
  deleteSession: {
    methodKind: "unary";
    input: typeof DeleteSessionRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Executes an SQL statement, returning all results in a single reply. This
   * method cannot be used to return a result set larger than 10 MiB;
   * if the query yields more data than that, the query fails with
   * a `FAILED_PRECONDITION` error.
   *
   * Operations inside read-write transactions might return `ABORTED`. If
   * this occurs, the application should restart the transaction from
   * the beginning. See [Transaction][google.spanner.v1.Transaction] for more
   * details.
   *
   * Larger result sets can be fetched in streaming fashion by calling
   * [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql]
   * instead.
   *
   * @generated from rpc google.spanner.v1.Spanner.ExecuteSql
   */
  executeSql: {
    methodKind: "unary";
    input: typeof ExecuteSqlRequestSchema;
    output: typeof ResultSetSchema;
  },
  /**
   * Like [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], except returns the
   * result set as a stream. Unlike
   * [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], there is no limit on
   * the size of the returned result set. However, no individual row in the
   * result set can exceed 100 MiB, and no column value can exceed 10 MiB.
   *
   * @generated from rpc google.spanner.v1.Spanner.ExecuteStreamingSql
   */
  executeStreamingSql: {
    methodKind: "server_streaming";
    input: typeof ExecuteSqlRequestSchema;
    output: typeof PartialResultSetSchema;
  },
  /**
   * Executes a batch of SQL DML statements. This method allows many statements
   * to be run with lower latency than submitting them sequentially with
   * [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].
   *
   * Statements are executed in sequential order. A request can succeed even if
   * a statement fails. The
   * [ExecuteBatchDmlResponse.status][google.spanner.v1.ExecuteBatchDmlResponse.status]
   * field in the response provides information about the statement that failed.
   * Clients must inspect this field to determine whether an error occurred.
   *
   * Execution stops after the first failed statement; the remaining statements
   * are not executed.
   *
   * @generated from rpc google.spanner.v1.Spanner.ExecuteBatchDml
   */
  executeBatchDml: {
    methodKind: "unary";
    input: typeof ExecuteBatchDmlRequestSchema;
    output: typeof ExecuteBatchDmlResponseSchema;
  },
  /**
   * Reads rows from the database using key lookups and scans, as a
   * simple key/value style alternative to
   * [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].  This method cannot be
   * used to return a result set larger than 10 MiB; if the read matches more
   * data than that, the read fails with a `FAILED_PRECONDITION`
   * error.
   *
   * Reads inside read-write transactions might return `ABORTED`. If
   * this occurs, the application should restart the transaction from
   * the beginning. See [Transaction][google.spanner.v1.Transaction] for more
   * details.
   *
   * Larger result sets can be yielded in streaming fashion by calling
   * [StreamingRead][google.spanner.v1.Spanner.StreamingRead] instead.
   *
   * @generated from rpc google.spanner.v1.Spanner.Read
   */
  read: {
    methodKind: "unary";
    input: typeof ReadRequestSchema;
    output: typeof ResultSetSchema;
  },
  /**
   * Like [Read][google.spanner.v1.Spanner.Read], except returns the result set
   * as a stream. Unlike [Read][google.spanner.v1.Spanner.Read], there is no
   * limit on the size of the returned result set. However, no individual row in
   * the result set can exceed 100 MiB, and no column value can exceed
   * 10 MiB.
   *
   * @generated from rpc google.spanner.v1.Spanner.StreamingRead
   */
  streamingRead: {
    methodKind: "server_streaming";
    input: typeof ReadRequestSchema;
    output: typeof PartialResultSetSchema;
  },
  /**
   * Begins a new transaction. This step can often be skipped:
   * [Read][google.spanner.v1.Spanner.Read],
   * [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
   * [Commit][google.spanner.v1.Spanner.Commit] can begin a new transaction as a
   * side-effect.
   *
   * @generated from rpc google.spanner.v1.Spanner.BeginTransaction
   */
  beginTransaction: {
    methodKind: "unary";
    input: typeof BeginTransactionRequestSchema;
    output: typeof TransactionSchema;
  },
  /**
   * Commits a transaction. The request includes the mutations to be
   * applied to rows in the database.
   *
   * `Commit` might return an `ABORTED` error. This can occur at any time;
   * commonly, the cause is conflicts with concurrent
   * transactions. However, it can also happen for a variety of other
   * reasons. If `Commit` returns `ABORTED`, the caller should re-attempt
   * the transaction from the beginning, re-using the same session.
   *
   * On very rare occasions, `Commit` might return `UNKNOWN`. This can happen,
   * for example, if the client job experiences a 1+ hour networking failure.
   * At that point, Cloud Spanner has lost track of the transaction outcome and
   * we recommend that you perform another read from the database to see the
   * state of things as they are now.
   *
   * @generated from rpc google.spanner.v1.Spanner.Commit
   */
  commit: {
    methodKind: "unary";
    input: typeof CommitRequestSchema;
    output: typeof CommitResponseSchema;
  },
  /**
   * Rolls back a transaction, releasing any locks it holds. It is a good
   * idea to call this for any transaction that includes one or more
   * [Read][google.spanner.v1.Spanner.Read] or
   * [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] requests and ultimately
   * decides not to commit.
   *
   * `Rollback` returns `OK` if it successfully aborts the transaction, the
   * transaction was already aborted, or the transaction is not
   * found. `Rollback` never returns `ABORTED`.
   *
   * @generated from rpc google.spanner.v1.Spanner.Rollback
   */
  rollback: {
    methodKind: "unary";
    input: typeof RollbackRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Creates a set of partition tokens that can be used to execute a query
   * operation in parallel.  Each of the returned partition tokens can be used
   * by [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] to
   * specify a subset of the query result to read.  The same session and
   * read-only transaction must be used by the PartitionQueryRequest used to
   * create the partition tokens and the ExecuteSqlRequests that use the
   * partition tokens.
   *
   * Partition tokens become invalid when the session used to create them
   * is deleted, is idle for too long, begins a new transaction, or becomes too
   * old.  When any of these happen, it is not possible to resume the query, and
   * the whole operation must be restarted from the beginning.
   *
   * @generated from rpc google.spanner.v1.Spanner.PartitionQuery
   */
  partitionQuery: {
    methodKind: "unary";
    input: typeof PartitionQueryRequestSchema;
    output: typeof PartitionResponseSchema;
  },
  /**
   * Creates a set of partition tokens that can be used to execute a read
   * operation in parallel.  Each of the returned partition tokens can be used
   * by [StreamingRead][google.spanner.v1.Spanner.StreamingRead] to specify a
   * subset of the read result to read.  The same session and read-only
   * transaction must be used by the PartitionReadRequest used to create the
   * partition tokens and the ReadRequests that use the partition tokens.  There
   * are no ordering guarantees on rows returned among the returned partition
   * tokens, or even within each individual StreamingRead call issued with a
   * partition_token.
   *
   * Partition tokens become invalid when the session used to create them
   * is deleted, is idle for too long, begins a new transaction, or becomes too
   * old.  When any of these happen, it is not possible to resume the read, and
   * the whole operation must be restarted from the beginning.
   *
   * @generated from rpc google.spanner.v1.Spanner.PartitionRead
   */
  partitionRead: {
    methodKind: "unary";
    input: typeof PartitionReadRequestSchema;
    output: typeof PartitionResponseSchema;
  },
  /**
   * Batches the supplied mutation groups in a collection of efficient
   * transactions. All mutations in a group are committed atomically. However,
   * mutations across groups can be committed non-atomically in an unspecified
   * order and thus, they must be independent of each other. Partial failure is
   * possible, i.e., some groups may have been committed successfully, while
   * some may have failed. The results of individual batches are streamed into
   * the response as the batches are applied.
   *
   * BatchWrite requests are not replay protected, meaning that each mutation
   * group may be applied more than once. Replays of non-idempotent mutations
   * may have undesirable effects. For example, replays of an insert mutation
   * may produce an already exists error or if you use generated or commit
   * timestamp-based keys, it may result in additional rows being added to the
   * mutation's table. We recommend structuring your mutation groups to be
   * idempotent to avoid this issue.
   *
   * @generated from rpc google.spanner.v1.Spanner.BatchWrite
   */
  batchWrite: {
    methodKind: "server_streaming";
    input: typeof BatchWriteRequestSchema;
    output: typeof BatchWriteResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_spanner_v1_spanner, 0);

