// Copyright 2018 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/devtools/containeranalysis/v1beta1/attestation/attestation.proto (package grafeas.v1beta1.attestation, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Signature } from "../common/common_pb";
import { file_google_devtools_containeranalysis_v1beta1_common_common } from "../common/common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/devtools/containeranalysis/v1beta1/attestation/attestation.proto.
 */
export const file_google_devtools_containeranalysis_v1beta1_attestation_attestation: GenFile = /*@__PURE__*/
  fileDesc("Ckdnb29nbGUvZGV2dG9vbHMvY29udGFpbmVyYW5hbHlzaXMvdjFiZXRhMS9hdHRlc3RhdGlvbi9hdHRlc3RhdGlvbi5wcm90bxIbZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uIuQBChRQZ3BTaWduZWRBdHRlc3RhdGlvbhIRCglzaWduYXR1cmUYASABKAkSUwoMY29udGVudF90eXBlGAMgASgOMj0uZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uLlBncFNpZ25lZEF0dGVzdGF0aW9uLkNvbnRlbnRUeXBlEhQKCnBncF9rZXlfaWQYAiABKAlIACJECgtDb250ZW50VHlwZRIcChhDT05URU5UX1RZUEVfVU5TUEVDSUZJRUQQABIXChNTSU1QTEVfU0lHTklOR19KU09OEAFCCAoGa2V5X2lkIoUCChhHZW5lcmljU2lnbmVkQXR0ZXN0YXRpb24SVwoMY29udGVudF90eXBlGAEgASgOMkEuZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uLkdlbmVyaWNTaWduZWRBdHRlc3RhdGlvbi5Db250ZW50VHlwZRIaChJzZXJpYWxpemVkX3BheWxvYWQYAiABKAwSLgoKc2lnbmF0dXJlcxgDIAMoCzIaLmdyYWZlYXMudjFiZXRhMS5TaWduYXR1cmUiRAoLQ29udGVudFR5cGUSHAoYQ09OVEVOVF9UWVBFX1VOU1BFQ0lGSUVEEAASFwoTU0lNUExFX1NJR05JTkdfSlNPThABImsKCUF1dGhvcml0eRI5CgRoaW50GAEgASgLMisuZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uLkF1dGhvcml0eS5IaW50GiMKBEhpbnQSGwoTaHVtYW5fcmVhZGFibGVfbmFtZRgBIAEoCSJICgdEZXRhaWxzEj0KC2F0dGVzdGF0aW9uGAEgASgLMiguZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uLkF0dGVzdGF0aW9uIswBCgtBdHRlc3RhdGlvbhJTChZwZ3Bfc2lnbmVkX2F0dGVzdGF0aW9uGAEgASgLMjEuZ3JhZmVhcy52MWJldGExLmF0dGVzdGF0aW9uLlBncFNpZ25lZEF0dGVzdGF0aW9uSAASWwoaZ2VuZXJpY19zaWduZWRfYXR0ZXN0YXRpb24YAiABKAsyNS5ncmFmZWFzLnYxYmV0YTEuYXR0ZXN0YXRpb24uR2VuZXJpY1NpZ25lZEF0dGVzdGF0aW9uSABCCwoJc2lnbmF0dXJlQoIBCh5pby5ncmFmZWFzLnYxYmV0YTEuYXR0ZXN0YXRpb25QAVpYY2xvdWQuZ29vZ2xlLmNvbS9nby9jb250YWluZXJhbmFseXNpcy9hcGl2MWJldGExL2NvbnRhaW5lcmFuYWx5c2lzcGI7Y29udGFpbmVyYW5hbHlzaXNwYqICA0dSQWIGcHJvdG8z", [file_google_devtools_containeranalysis_v1beta1_common_common]);

/**
 * An attestation wrapper with a PGP-compatible signature. This message only
 * supports `ATTACHED` signatures, where the payload that is signed is included
 * alongside the signature itself in the same file.
 *
 * @generated from message grafeas.v1beta1.attestation.PgpSignedAttestation
 */
export type PgpSignedAttestation = Message<"grafeas.v1beta1.attestation.PgpSignedAttestation"> & {
  /**
   * Required. The raw content of the signature, as output by GNU Privacy Guard
   * (GPG) or equivalent. Since this message only supports attached signatures,
   * the payload that was signed must be attached. While the signature format
   * supported is dependent on the verification implementation, currently only
   * ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
   * `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
   * --output=signature.gpg payload.json` will create the signature content
   * expected in this field in `signature.gpg` for the `payload.json`
   * attestation payload.
   *
   * @generated from field: string signature = 1;
   */
  signature: string;

  /**
   * Type (for example schema) of the attestation payload that was signed.
   * The verifier must ensure that the provided type is one that the verifier
   * supports, and that the attestation payload is a valid instantiation of that
   * type (for example by validating a JSON schema).
   *
   * @generated from field: grafeas.v1beta1.attestation.PgpSignedAttestation.ContentType content_type = 3;
   */
  contentType: PgpSignedAttestation_ContentType;

  /**
   * This field is used by verifiers to select the public key used to validate
   * the signature. Note that the policy of the verifier ultimately determines
   * which public keys verify a signature based on the context of the
   * verification. There is no guarantee validation will succeed if the
   * verifier has no key matching this ID, even if it has a key under a
   * different ID that would verify the signature. Note that this ID should also
   * be present in the signature content above, but that is not expected to be
   * used by the verifier.
   *
   * @generated from oneof grafeas.v1beta1.attestation.PgpSignedAttestation.key_id
   */
  keyId: {
    /**
     * The cryptographic fingerprint of the key used to generate the signature,
     * as output by, e.g. `gpg --list-keys`. This should be the version 4, full
     * 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
     * https://tools.ietf.org/html/rfc4880#section-12.2 for details.
     * Implementations may choose to acknowledge "LONG", "SHORT", or other
     * abbreviated key IDs, but only the full fingerprint is guaranteed to work.
     * In gpg, the full fingerprint can be retrieved from the `fpr` field
     * returned when calling --list-keys with --with-colons.  For example:
     * ```
     * gpg --with-colons --with-fingerprint --force-v4-certs \
     *     --list-keys attester@example.com
     * tru::1:1513631572:0:3:1:5
     * pub:...<SNIP>...
     * fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
     * ```
     * Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
     *
     * @generated from field: string pgp_key_id = 2;
     */
    value: string;
    case: "pgpKeyId";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message grafeas.v1beta1.attestation.PgpSignedAttestation.
 * Use `create(PgpSignedAttestationSchema)` to create a new message.
 */
export const PgpSignedAttestationSchema: GenMessage<PgpSignedAttestation> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 0);

/**
 * Type (for example schema) of the attestation payload that was signed.
 *
 * @generated from enum grafeas.v1beta1.attestation.PgpSignedAttestation.ContentType
 */
export enum PgpSignedAttestation_ContentType {
  /**
   * `ContentType` is not set.
   *
   * @generated from enum value: CONTENT_TYPE_UNSPECIFIED = 0;
   */
  CONTENT_TYPE_UNSPECIFIED = 0,

  /**
   * Atomic format attestation signature. See
   * https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
   * The payload extracted from `signature` is a JSON blob conforming to the
   * linked schema.
   *
   * @generated from enum value: SIMPLE_SIGNING_JSON = 1;
   */
  SIMPLE_SIGNING_JSON = 1,
}

/**
 * Describes the enum grafeas.v1beta1.attestation.PgpSignedAttestation.ContentType.
 */
export const PgpSignedAttestation_ContentTypeSchema: GenEnum<PgpSignedAttestation_ContentType> = /*@__PURE__*/
  enumDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 0, 0);

/**
 * An attestation wrapper that uses the Grafeas `Signature` message.
 * This attestation must define the `serialized_payload` that the `signatures`
 * verify and any metadata necessary to interpret that plaintext.  The
 * signatures should always be over the `serialized_payload` bytestring.
 *
 * @generated from message grafeas.v1beta1.attestation.GenericSignedAttestation
 */
export type GenericSignedAttestation = Message<"grafeas.v1beta1.attestation.GenericSignedAttestation"> & {
  /**
   * Type (for example schema) of the attestation payload that was signed.
   * The verifier must ensure that the provided type is one that the verifier
   * supports, and that the attestation payload is a valid instantiation of that
   * type (for example by validating a JSON schema).
   *
   * @generated from field: grafeas.v1beta1.attestation.GenericSignedAttestation.ContentType content_type = 1;
   */
  contentType: GenericSignedAttestation_ContentType;

  /**
   * The serialized payload that is verified by one or more `signatures`.
   * The encoding and semantic meaning of this payload must match what is set in
   * `content_type`.
   *
   * @generated from field: bytes serialized_payload = 2;
   */
  serializedPayload: Uint8Array;

  /**
   * One or more signatures over `serialized_payload`.  Verifier implementations
   * should consider this attestation message verified if at least one
   * `signature` verifies `serialized_payload`.  See `Signature` in common.proto
   * for more details on signature structure and verification.
   *
   * @generated from field: repeated grafeas.v1beta1.Signature signatures = 3;
   */
  signatures: Signature[];
};

/**
 * Describes the message grafeas.v1beta1.attestation.GenericSignedAttestation.
 * Use `create(GenericSignedAttestationSchema)` to create a new message.
 */
export const GenericSignedAttestationSchema: GenMessage<GenericSignedAttestation> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 1);

/**
 * Type of the attestation plaintext that was signed.
 *
 * @generated from enum grafeas.v1beta1.attestation.GenericSignedAttestation.ContentType
 */
export enum GenericSignedAttestation_ContentType {
  /**
   * `ContentType` is not set.
   *
   * @generated from enum value: CONTENT_TYPE_UNSPECIFIED = 0;
   */
  CONTENT_TYPE_UNSPECIFIED = 0,

  /**
   * Atomic format attestation signature. See
   * https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
   * The payload extracted in `plaintext` is a JSON blob conforming to the
   * linked schema.
   *
   * @generated from enum value: SIMPLE_SIGNING_JSON = 1;
   */
  SIMPLE_SIGNING_JSON = 1,
}

/**
 * Describes the enum grafeas.v1beta1.attestation.GenericSignedAttestation.ContentType.
 */
export const GenericSignedAttestation_ContentTypeSchema: GenEnum<GenericSignedAttestation_ContentType> = /*@__PURE__*/
  enumDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 1, 0);

/**
 * Note kind that represents a logical attestation "role" or "authority". For
 * example, an organization might have one `Authority` for "QA" and one for
 * "build". This note is intended to act strictly as a grouping mechanism for
 * the attached occurrences (Attestations). This grouping mechanism also
 * provides a security boundary, since IAM ACLs gate the ability for a principle
 * to attach an occurrence to a given note. It also provides a single point of
 * lookup to find all attached attestation occurrences, even if they don't all
 * live in the same project.
 *
 * @generated from message grafeas.v1beta1.attestation.Authority
 */
export type Authority = Message<"grafeas.v1beta1.attestation.Authority"> & {
  /**
   * Hint hints at the purpose of the attestation authority.
   *
   * @generated from field: grafeas.v1beta1.attestation.Authority.Hint hint = 1;
   */
  hint?: Authority_Hint;
};

/**
 * Describes the message grafeas.v1beta1.attestation.Authority.
 * Use `create(AuthoritySchema)` to create a new message.
 */
export const AuthoritySchema: GenMessage<Authority> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 2);

/**
 * This submessage provides human-readable hints about the purpose of the
 * authority. Because the name of a note acts as its resource reference, it is
 * important to disambiguate the canonical name of the Note (which might be a
 * UUID for security purposes) from "readable" names more suitable for debug
 * output. Note that these hints should not be used to look up authorities in
 * security sensitive contexts, such as when looking up attestations to
 * verify.
 *
 * @generated from message grafeas.v1beta1.attestation.Authority.Hint
 */
export type Authority_Hint = Message<"grafeas.v1beta1.attestation.Authority.Hint"> & {
  /**
   * Required. The human readable name of this attestation authority, for
   * example "qa".
   *
   * @generated from field: string human_readable_name = 1;
   */
  humanReadableName: string;
};

/**
 * Describes the message grafeas.v1beta1.attestation.Authority.Hint.
 * Use `create(Authority_HintSchema)` to create a new message.
 */
export const Authority_HintSchema: GenMessage<Authority_Hint> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 2, 0);

/**
 * Details of an attestation occurrence.
 *
 * @generated from message grafeas.v1beta1.attestation.Details
 */
export type Details = Message<"grafeas.v1beta1.attestation.Details"> & {
  /**
   * Required. Attestation for the resource.
   *
   * @generated from field: grafeas.v1beta1.attestation.Attestation attestation = 1;
   */
  attestation?: Attestation;
};

/**
 * Describes the message grafeas.v1beta1.attestation.Details.
 * Use `create(DetailsSchema)` to create a new message.
 */
export const DetailsSchema: GenMessage<Details> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 3);

/**
 * Occurrence that represents a single "attestation". The authenticity of an
 * attestation can be verified using the attached signature. If the verifier
 * trusts the public key of the signer, then verifying the signature is
 * sufficient to establish trust. In this circumstance, the authority to which
 * this attestation is attached is primarily useful for look-up (how to find
 * this attestation if you already know the authority and artifact to be
 * verified) and intent (which authority was this attestation intended to sign
 * for).
 *
 * @generated from message grafeas.v1beta1.attestation.Attestation
 */
export type Attestation = Message<"grafeas.v1beta1.attestation.Attestation"> & {
  /**
   * Required. The signature, generally over the `resource_url`, that verifies
   * this attestation. The semantics of the signature veracity are ultimately
   * determined by the verification engine.
   *
   * @generated from oneof grafeas.v1beta1.attestation.Attestation.signature
   */
  signature: {
    /**
     * A PGP signed attestation.
     *
     * @generated from field: grafeas.v1beta1.attestation.PgpSignedAttestation pgp_signed_attestation = 1;
     */
    value: PgpSignedAttestation;
    case: "pgpSignedAttestation";
  } | {
    /**
     * @generated from field: grafeas.v1beta1.attestation.GenericSignedAttestation generic_signed_attestation = 2;
     */
    value: GenericSignedAttestation;
    case: "genericSignedAttestation";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message grafeas.v1beta1.attestation.Attestation.
 * Use `create(AttestationSchema)` to create a new message.
 */
export const AttestationSchema: GenMessage<Attestation> = /*@__PURE__*/
  messageDesc(file_google_devtools_containeranalysis_v1beta1_attestation_attestation, 4);

