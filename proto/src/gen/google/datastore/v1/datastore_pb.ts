// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/datastore/v1/datastore.proto (package google.datastore.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import { file_google_api_routing } from "../../api/routing_pb";
import type { AggregationResultBatch } from "./aggregation_result_pb";
import { file_google_datastore_v1_aggregation_result } from "./aggregation_result_pb";
import type { Entity, Key, PartitionId } from "./entity_pb";
import { file_google_datastore_v1_entity } from "./entity_pb";
import type { AggregationQuery, EntityResult, GqlQuery, Query, QueryResultBatch } from "./query_pb";
import { file_google_datastore_v1_query } from "./query_pb";
import type { ExplainMetrics, ExplainOptions } from "./query_profile_pb";
import { file_google_datastore_v1_query_profile } from "./query_profile_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/datastore/v1/datastore.proto.
 */
export const file_google_datastore_v1_datastore: GenFile = /*@__PURE__*/
  fileDesc("CiNnb29nbGUvZGF0YXN0b3JlL3YxL2RhdGFzdG9yZS5wcm90bxITZ29vZ2xlLmRhdGFzdG9yZS52MSLcAQoNTG9va3VwUmVxdWVzdBIXCgpwcm9qZWN0X2lkGAggASgJQgPgQQISEwoLZGF0YWJhc2VfaWQYCSABKAkSNgoMcmVhZF9vcHRpb25zGAEgASgLMiAuZ29vZ2xlLmRhdGFzdG9yZS52MS5SZWFkT3B0aW9ucxIrCgRrZXlzGAMgAygLMhguZ29vZ2xlLmRhdGFzdG9yZS52MS5LZXlCA+BBAhI4Cg1wcm9wZXJ0eV9tYXNrGAUgASgLMiEuZ29vZ2xlLmRhdGFzdG9yZS52MS5Qcm9wZXJ0eU1hc2si5gEKDkxvb2t1cFJlc3BvbnNlEjAKBWZvdW5kGAEgAygLMiEuZ29vZ2xlLmRhdGFzdG9yZS52MS5FbnRpdHlSZXN1bHQSMgoHbWlzc2luZxgCIAMoCzIhLmdvb2dsZS5kYXRhc3RvcmUudjEuRW50aXR5UmVzdWx0EioKCGRlZmVycmVkGAMgAygLMhguZ29vZ2xlLmRhdGFzdG9yZS52MS5LZXkSEwoLdHJhbnNhY3Rpb24YBSABKAwSLQoJcmVhZF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCKbAwoPUnVuUXVlcnlSZXF1ZXN0EhcKCnByb2plY3RfaWQYCCABKAlCA+BBAhITCgtkYXRhYmFzZV9pZBgJIAEoCRI2CgxwYXJ0aXRpb25faWQYAiABKAsyIC5nb29nbGUuZGF0YXN0b3JlLnYxLlBhcnRpdGlvbklkEjYKDHJlYWRfb3B0aW9ucxgBIAEoCzIgLmdvb2dsZS5kYXRhc3RvcmUudjEuUmVhZE9wdGlvbnMSKwoFcXVlcnkYAyABKAsyGi5nb29nbGUuZGF0YXN0b3JlLnYxLlF1ZXJ5SAASMgoJZ3FsX3F1ZXJ5GAcgASgLMh0uZ29vZ2xlLmRhdGFzdG9yZS52MS5HcWxRdWVyeUgAEjgKDXByb3BlcnR5X21hc2sYCiABKAsyIS5nb29nbGUuZGF0YXN0b3JlLnYxLlByb3BlcnR5TWFzaxJBCg9leHBsYWluX29wdGlvbnMYDCABKAsyIy5nb29nbGUuZGF0YXN0b3JlLnYxLkV4cGxhaW5PcHRpb25zQgPgQQFCDAoKcXVlcnlfdHlwZSLGAQoQUnVuUXVlcnlSZXNwb25zZRI0CgViYXRjaBgBIAEoCzIlLmdvb2dsZS5kYXRhc3RvcmUudjEuUXVlcnlSZXN1bHRCYXRjaBIpCgVxdWVyeRgCIAEoCzIaLmdvb2dsZS5kYXRhc3RvcmUudjEuUXVlcnkSEwoLdHJhbnNhY3Rpb24YBSABKAwSPAoPZXhwbGFpbl9tZXRyaWNzGAkgASgLMiMuZ29vZ2xlLmRhdGFzdG9yZS52MS5FeHBsYWluTWV0cmljcyKDAwoaUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QSFwoKcHJvamVjdF9pZBgIIAEoCUID4EECEhMKC2RhdGFiYXNlX2lkGAkgASgJEjYKDHBhcnRpdGlvbl9pZBgCIAEoCzIgLmdvb2dsZS5kYXRhc3RvcmUudjEuUGFydGl0aW9uSWQSNgoMcmVhZF9vcHRpb25zGAEgASgLMiAuZ29vZ2xlLmRhdGFzdG9yZS52MS5SZWFkT3B0aW9ucxJCChFhZ2dyZWdhdGlvbl9xdWVyeRgDIAEoCzIlLmdvb2dsZS5kYXRhc3RvcmUudjEuQWdncmVnYXRpb25RdWVyeUgAEjIKCWdxbF9xdWVyeRgHIAEoCzIdLmdvb2dsZS5kYXRhc3RvcmUudjEuR3FsUXVlcnlIABJBCg9leHBsYWluX29wdGlvbnMYCyABKAsyIy5nb29nbGUuZGF0YXN0b3JlLnYxLkV4cGxhaW5PcHRpb25zQgPgQQFCDAoKcXVlcnlfdHlwZSLiAQobUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlEjoKBWJhdGNoGAEgASgLMisuZ29vZ2xlLmRhdGFzdG9yZS52MS5BZ2dyZWdhdGlvblJlc3VsdEJhdGNoEjQKBXF1ZXJ5GAIgASgLMiUuZ29vZ2xlLmRhdGFzdG9yZS52MS5BZ2dyZWdhdGlvblF1ZXJ5EhMKC3RyYW5zYWN0aW9uGAUgASgMEjwKD2V4cGxhaW5fbWV0cmljcxgJIAEoCzIjLmdvb2dsZS5kYXRhc3RvcmUudjEuRXhwbGFpbk1ldHJpY3MijQEKF0JlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0EhcKCnByb2plY3RfaWQYCCABKAlCA+BBAhITCgtkYXRhYmFzZV9pZBgJIAEoCRJEChN0cmFuc2FjdGlvbl9vcHRpb25zGAogASgLMicuZ29vZ2xlLmRhdGFzdG9yZS52MS5UcmFuc2FjdGlvbk9wdGlvbnMiLwoYQmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlEhMKC3RyYW5zYWN0aW9uGAEgASgMIlkKD1JvbGxiYWNrUmVxdWVzdBIXCgpwcm9qZWN0X2lkGAggASgJQgPgQQISEwoLZGF0YWJhc2VfaWQYCSABKAkSGAoLdHJhbnNhY3Rpb24YASABKAxCA+BBAiISChBSb2xsYmFja1Jlc3BvbnNlIugCCg1Db21taXRSZXF1ZXN0EhcKCnByb2plY3RfaWQYCCABKAlCA+BBAhITCgtkYXRhYmFzZV9pZBgJIAEoCRI1CgRtb2RlGAUgASgOMicuZ29vZ2xlLmRhdGFzdG9yZS52MS5Db21taXRSZXF1ZXN0Lk1vZGUSFQoLdHJhbnNhY3Rpb24YASABKAxIABJJChZzaW5nbGVfdXNlX3RyYW5zYWN0aW9uGAogASgLMicuZ29vZ2xlLmRhdGFzdG9yZS52MS5UcmFuc2FjdGlvbk9wdGlvbnNIABIwCgltdXRhdGlvbnMYBiADKAsyHS5nb29nbGUuZGF0YXN0b3JlLnYxLk11dGF0aW9uIkYKBE1vZGUSFAoQTU9ERV9VTlNQRUNJRklFRBAAEhEKDVRSQU5TQUNUSU9OQUwQARIVChFOT05fVFJBTlNBQ1RJT05BTBACQhYKFHRyYW5zYWN0aW9uX3NlbGVjdG9yIpcBCg5Db21taXRSZXNwb25zZRI9ChBtdXRhdGlvbl9yZXN1bHRzGAMgAygLMiMuZ29vZ2xlLmRhdGFzdG9yZS52MS5NdXRhdGlvblJlc3VsdBIVCg1pbmRleF91cGRhdGVzGAQgASgFEi8KC2NvbW1pdF90aW1lGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJvChJBbGxvY2F0ZUlkc1JlcXVlc3QSFwoKcHJvamVjdF9pZBgIIAEoCUID4EECEhMKC2RhdGFiYXNlX2lkGAkgASgJEisKBGtleXMYASADKAsyGC5nb29nbGUuZGF0YXN0b3JlLnYxLktleUID4EECIj0KE0FsbG9jYXRlSWRzUmVzcG9uc2USJgoEa2V5cxgBIAMoCzIYLmdvb2dsZS5kYXRhc3RvcmUudjEuS2V5Im4KEVJlc2VydmVJZHNSZXF1ZXN0EhcKCnByb2plY3RfaWQYCCABKAlCA+BBAhITCgtkYXRhYmFzZV9pZBgJIAEoCRIrCgRrZXlzGAEgAygLMhguZ29vZ2xlLmRhdGFzdG9yZS52MS5LZXlCA+BBAiIUChJSZXNlcnZlSWRzUmVzcG9uc2Ui9AIKCE11dGF0aW9uEi0KBmluc2VydBgEIAEoCzIbLmdvb2dsZS5kYXRhc3RvcmUudjEuRW50aXR5SAASLQoGdXBkYXRlGAUgASgLMhsuZ29vZ2xlLmRhdGFzdG9yZS52MS5FbnRpdHlIABItCgZ1cHNlcnQYBiABKAsyGy5nb29nbGUuZGF0YXN0b3JlLnYxLkVudGl0eUgAEioKBmRlbGV0ZRgHIAEoCzIYLmdvb2dsZS5kYXRhc3RvcmUudjEuS2V5SAASFgoMYmFzZV92ZXJzaW9uGAggASgDSAESMQoLdXBkYXRlX3RpbWUYCyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAESOAoNcHJvcGVydHlfbWFzaxgJIAEoCzIhLmdvb2dsZS5kYXRhc3RvcmUudjEuUHJvcGVydHlNYXNrQgsKCW9wZXJhdGlvbkIdChtjb25mbGljdF9kZXRlY3Rpb25fc3RyYXRlZ3kixQEKDk11dGF0aW9uUmVzdWx0EiUKA2tleRgDIAEoCzIYLmdvb2dsZS5kYXRhc3RvcmUudjEuS2V5Eg8KB3ZlcnNpb24YBCABKAMSLwoLY3JlYXRlX3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi8KC3VwZGF0ZV90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIZChFjb25mbGljdF9kZXRlY3RlZBgFIAEoCCIdCgxQcm9wZXJ0eU1hc2sSDQoFcGF0aHMYASADKAkiygIKC1JlYWRPcHRpb25zEkwKEHJlYWRfY29uc2lzdGVuY3kYASABKA4yMC5nb29nbGUuZGF0YXN0b3JlLnYxLlJlYWRPcHRpb25zLlJlYWRDb25zaXN0ZW5jeUgAEhUKC3RyYW5zYWN0aW9uGAIgASgMSAASQgoPbmV3X3RyYW5zYWN0aW9uGAMgASgLMicuZ29vZ2xlLmRhdGFzdG9yZS52MS5UcmFuc2FjdGlvbk9wdGlvbnNIABIvCglyZWFkX3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAAiTQoPUmVhZENvbnNpc3RlbmN5EiAKHFJFQURfQ09OU0lTVEVOQ1lfVU5TUEVDSUZJRUQQABIKCgZTVFJPTkcQARIMCghFVkVOVFVBTBACQhIKEGNvbnNpc3RlbmN5X3R5cGUikgIKElRyYW5zYWN0aW9uT3B0aW9ucxJHCgpyZWFkX3dyaXRlGAEgASgLMjEuZ29vZ2xlLmRhdGFzdG9yZS52MS5UcmFuc2FjdGlvbk9wdGlvbnMuUmVhZFdyaXRlSAASRQoJcmVhZF9vbmx5GAIgASgLMjAuZ29vZ2xlLmRhdGFzdG9yZS52MS5UcmFuc2FjdGlvbk9wdGlvbnMuUmVhZE9ubHlIABopCglSZWFkV3JpdGUSHAoUcHJldmlvdXNfdHJhbnNhY3Rpb24YASABKAwaOQoIUmVhZE9ubHkSLQoJcmVhZF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIGCgRtb2RlMuENCglEYXRhc3RvcmUSwAEKBkxvb2t1cBIiLmdvb2dsZS5kYXRhc3RvcmUudjEuTG9va3VwUmVxdWVzdBojLmdvb2dsZS5kYXRhc3RvcmUudjEuTG9va3VwUmVzcG9uc2UibdpBHHByb2plY3RfaWQscmVhZF9vcHRpb25zLGtleXOC0+STAiU6ASoiIC92MS9wcm9qZWN0cy97cHJvamVjdF9pZH06bG9va3VwitPkkwIdEgwKCnByb2plY3RfaWQSDQoLZGF0YWJhc2VfaWQSqQEKCFJ1blF1ZXJ5EiQuZ29vZ2xlLmRhdGFzdG9yZS52MS5SdW5RdWVyeVJlcXVlc3QaJS5nb29nbGUuZGF0YXN0b3JlLnYxLlJ1blF1ZXJ5UmVzcG9uc2UiUILT5JMCJzoBKiIiL3YxL3Byb2plY3RzL3twcm9qZWN0X2lkfTpydW5RdWVyeYrT5JMCHRIMCgpwcm9qZWN0X2lkEg0KC2RhdGFiYXNlX2lkEtUBChNSdW5BZ2dyZWdhdGlvblF1ZXJ5Ei8uZ29vZ2xlLmRhdGFzdG9yZS52MS5SdW5BZ2dyZWdhdGlvblF1ZXJ5UmVxdWVzdBowLmdvb2dsZS5kYXRhc3RvcmUudjEuUnVuQWdncmVnYXRpb25RdWVyeVJlc3BvbnNlIluC0+STAjI6ASoiLS92MS9wcm9qZWN0cy97cHJvamVjdF9pZH06cnVuQWdncmVnYXRpb25RdWVyeYrT5JMCHRIMCgpwcm9qZWN0X2lkEg0KC2RhdGFiYXNlX2lkEtYBChBCZWdpblRyYW5zYWN0aW9uEiwuZ29vZ2xlLmRhdGFzdG9yZS52MS5CZWdpblRyYW5zYWN0aW9uUmVxdWVzdBotLmdvb2dsZS5kYXRhc3RvcmUudjEuQmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlImXaQQpwcm9qZWN0X2lkgtPkkwIvOgEqIiovdjEvcHJvamVjdHMve3Byb2plY3RfaWR9OmJlZ2luVHJhbnNhY3Rpb26K0+STAh0SDAoKcHJvamVjdF9pZBINCgtkYXRhYmFzZV9pZBLmAQoGQ29tbWl0EiIuZ29vZ2xlLmRhdGFzdG9yZS52MS5Db21taXRSZXF1ZXN0GiMuZ29vZ2xlLmRhdGFzdG9yZS52MS5Db21taXRSZXNwb25zZSKSAdpBJXByb2plY3RfaWQsbW9kZSx0cmFuc2FjdGlvbixtdXRhdGlvbnPaQRlwcm9qZWN0X2lkLG1vZGUsbXV0YXRpb25zgtPkkwIlOgEqIiAvdjEvcHJvamVjdHMve3Byb2plY3RfaWR9OmNvbW1pdIrT5JMCHRIMCgpwcm9qZWN0X2lkEg0KC2RhdGFiYXNlX2lkEsIBCghSb2xsYmFjaxIkLmdvb2dsZS5kYXRhc3RvcmUudjEuUm9sbGJhY2tSZXF1ZXN0GiUuZ29vZ2xlLmRhdGFzdG9yZS52MS5Sb2xsYmFja1Jlc3BvbnNlImnaQRZwcm9qZWN0X2lkLHRyYW5zYWN0aW9ugtPkkwInOgEqIiIvdjEvcHJvamVjdHMve3Byb2plY3RfaWR9OnJvbGxiYWNritPkkwIdEgwKCnByb2plY3RfaWQSDQoLZGF0YWJhc2VfaWQSxwEKC0FsbG9jYXRlSWRzEicuZ29vZ2xlLmRhdGFzdG9yZS52MS5BbGxvY2F0ZUlkc1JlcXVlc3QaKC5nb29nbGUuZGF0YXN0b3JlLnYxLkFsbG9jYXRlSWRzUmVzcG9uc2UiZdpBD3Byb2plY3RfaWQsa2V5c4LT5JMCKjoBKiIlL3YxL3Byb2plY3RzL3twcm9qZWN0X2lkfTphbGxvY2F0ZUlkc4rT5JMCHRIMCgpwcm9qZWN0X2lkEg0KC2RhdGFiYXNlX2lkEsMBCgpSZXNlcnZlSWRzEiYuZ29vZ2xlLmRhdGFzdG9yZS52MS5SZXNlcnZlSWRzUmVxdWVzdBonLmdvb2dsZS5kYXRhc3RvcmUudjEuUmVzZXJ2ZUlkc1Jlc3BvbnNlImTaQQ9wcm9qZWN0X2lkLGtleXOC0+STAik6ASoiJC92MS9wcm9qZWN0cy97cHJvamVjdF9pZH06cmVzZXJ2ZUlkc4rT5JMCHRIMCgpwcm9qZWN0X2lkEg0KC2RhdGFiYXNlX2lkGnbKQRhkYXRhc3RvcmUuZ29vZ2xlYXBpcy5jb23SQVhodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlQr8BChdjb20uZ29vZ2xlLmRhdGFzdG9yZS52MUIORGF0YXN0b3JlUHJvdG9QAVo7Y2xvdWQuZ29vZ2xlLmNvbS9nby9kYXRhc3RvcmUvYXBpdjEvZGF0YXN0b3JlcGI7ZGF0YXN0b3JlcGKqAhlHb29nbGUuQ2xvdWQuRGF0YXN0b3JlLlYxygIZR29vZ2xlXENsb3VkXERhdGFzdG9yZVxWMeoCHEdvb2dsZTo6Q2xvdWQ6OkRhdGFzdG9yZTo6VjFiBnByb3RvMw", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_routing, file_google_datastore_v1_aggregation_result, file_google_datastore_v1_entity, file_google_datastore_v1_query, file_google_datastore_v1_query_profile, file_google_protobuf_timestamp]);

/**
 * The request for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
 *
 * @generated from message google.datastore.v1.LookupRequest
 */
export type LookupRequest = Message<"google.datastore.v1.LookupRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * The options for this lookup request.
   *
   * @generated from field: google.datastore.v1.ReadOptions read_options = 1;
   */
  readOptions?: ReadOptions;

  /**
   * Required. Keys of entities to look up.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 3;
   */
  keys: Key[];

  /**
   * The properties to return. Defaults to returning all properties.
   *
   * If this field is set and an entity has a property not referenced in the
   * mask, it will be absent from [LookupResponse.found.entity.properties][].
   *
   * The entity's key is always returned.
   *
   * @generated from field: google.datastore.v1.PropertyMask property_mask = 5;
   */
  propertyMask?: PropertyMask;
};

/**
 * Describes the message google.datastore.v1.LookupRequest.
 * Use `create(LookupRequestSchema)` to create a new message.
 */
export const LookupRequestSchema: GenMessage<LookupRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 0);

/**
 * The response for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
 *
 * @generated from message google.datastore.v1.LookupResponse
 */
export type LookupResponse = Message<"google.datastore.v1.LookupResponse"> & {
  /**
   * Entities found as `ResultType.FULL` entities. The order of results in this
   * field is undefined and has no relation to the order of the keys in the
   * input.
   *
   * @generated from field: repeated google.datastore.v1.EntityResult found = 1;
   */
  found: EntityResult[];

  /**
   * Entities not found as `ResultType.KEY_ONLY` entities. The order of results
   * in this field is undefined and has no relation to the order of the keys
   * in the input.
   *
   * @generated from field: repeated google.datastore.v1.EntityResult missing = 2;
   */
  missing: EntityResult[];

  /**
   * A list of keys that were not looked up due to resource constraints. The
   * order of results in this field is undefined and has no relation to the
   * order of the keys in the input.
   *
   * @generated from field: repeated google.datastore.v1.Key deferred = 3;
   */
  deferred: Key[];

  /**
   * The identifier of the transaction that was started as part of this Lookup
   * request.
   *
   * Set only when
   * [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
   * was set in
   * [LookupRequest.read_options][google.datastore.v1.LookupRequest.read_options].
   *
   * @generated from field: bytes transaction = 5;
   */
  transaction: Uint8Array;

  /**
   * The time at which these entities were read or found missing.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 7;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.datastore.v1.LookupResponse.
 * Use `create(LookupResponseSchema)` to create a new message.
 */
export const LookupResponseSchema: GenMessage<LookupResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 1);

/**
 * The request for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
 *
 * @generated from message google.datastore.v1.RunQueryRequest
 */
export type RunQueryRequest = Message<"google.datastore.v1.RunQueryRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Entities are partitioned into subsets, identified by a partition ID.
   * Queries are scoped to a single partition.
   * This partition ID is normalized with the standard default context
   * partition ID.
   *
   * @generated from field: google.datastore.v1.PartitionId partition_id = 2;
   */
  partitionId?: PartitionId;

  /**
   * The options for this query.
   *
   * @generated from field: google.datastore.v1.ReadOptions read_options = 1;
   */
  readOptions?: ReadOptions;

  /**
   * The type of query.
   *
   * @generated from oneof google.datastore.v1.RunQueryRequest.query_type
   */
  queryType: {
    /**
     * The query to run.
     *
     * @generated from field: google.datastore.v1.Query query = 3;
     */
    value: Query;
    case: "query";
  } | {
    /**
     * The GQL query to run. This query must be a non-aggregation query.
     *
     * @generated from field: google.datastore.v1.GqlQuery gql_query = 7;
     */
    value: GqlQuery;
    case: "gqlQuery";
  } | { case: undefined; value?: undefined };

  /**
   * The properties to return.
   * This field must not be set for a projection query.
   *
   * See
   * [LookupRequest.property_mask][google.datastore.v1.LookupRequest.property_mask].
   *
   * @generated from field: google.datastore.v1.PropertyMask property_mask = 10;
   */
  propertyMask?: PropertyMask;

  /**
   * Optional. Explain options for the query. If set, additional query
   * statistics will be returned. If not, only query results will be returned.
   *
   * @generated from field: google.datastore.v1.ExplainOptions explain_options = 12;
   */
  explainOptions?: ExplainOptions;
};

/**
 * Describes the message google.datastore.v1.RunQueryRequest.
 * Use `create(RunQueryRequestSchema)` to create a new message.
 */
export const RunQueryRequestSchema: GenMessage<RunQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 2);

/**
 * The response for
 * [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
 *
 * @generated from message google.datastore.v1.RunQueryResponse
 */
export type RunQueryResponse = Message<"google.datastore.v1.RunQueryResponse"> & {
  /**
   * A batch of query results (always present).
   *
   * @generated from field: google.datastore.v1.QueryResultBatch batch = 1;
   */
  batch?: QueryResultBatch;

  /**
   * The parsed form of the `GqlQuery` from the request, if it was set.
   *
   * @generated from field: google.datastore.v1.Query query = 2;
   */
  query?: Query;

  /**
   * The identifier of the transaction that was started as part of this
   * RunQuery request.
   *
   * Set only when
   * [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
   * was set in
   * [RunQueryRequest.read_options][google.datastore.v1.RunQueryRequest.read_options].
   *
   * @generated from field: bytes transaction = 5;
   */
  transaction: Uint8Array;

  /**
   * Query explain metrics. This is only present when the
   * [RunQueryRequest.explain_options][google.datastore.v1.RunQueryRequest.explain_options]
   * is provided, and it is sent only once with the last response in the stream.
   *
   * @generated from field: google.datastore.v1.ExplainMetrics explain_metrics = 9;
   */
  explainMetrics?: ExplainMetrics;
};

/**
 * Describes the message google.datastore.v1.RunQueryResponse.
 * Use `create(RunQueryResponseSchema)` to create a new message.
 */
export const RunQueryResponseSchema: GenMessage<RunQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 3);

/**
 * The request for
 * [Datastore.RunAggregationQuery][google.datastore.v1.Datastore.RunAggregationQuery].
 *
 * @generated from message google.datastore.v1.RunAggregationQueryRequest
 */
export type RunAggregationQueryRequest = Message<"google.datastore.v1.RunAggregationQueryRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Entities are partitioned into subsets, identified by a partition ID.
   * Queries are scoped to a single partition.
   * This partition ID is normalized with the standard default context
   * partition ID.
   *
   * @generated from field: google.datastore.v1.PartitionId partition_id = 2;
   */
  partitionId?: PartitionId;

  /**
   * The options for this query.
   *
   * @generated from field: google.datastore.v1.ReadOptions read_options = 1;
   */
  readOptions?: ReadOptions;

  /**
   * The type of query.
   *
   * @generated from oneof google.datastore.v1.RunAggregationQueryRequest.query_type
   */
  queryType: {
    /**
     * The query to run.
     *
     * @generated from field: google.datastore.v1.AggregationQuery aggregation_query = 3;
     */
    value: AggregationQuery;
    case: "aggregationQuery";
  } | {
    /**
     * The GQL query to run. This query must be an aggregation query.
     *
     * @generated from field: google.datastore.v1.GqlQuery gql_query = 7;
     */
    value: GqlQuery;
    case: "gqlQuery";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. Explain options for the query. If set, additional query
   * statistics will be returned. If not, only query results will be returned.
   *
   * @generated from field: google.datastore.v1.ExplainOptions explain_options = 11;
   */
  explainOptions?: ExplainOptions;
};

/**
 * Describes the message google.datastore.v1.RunAggregationQueryRequest.
 * Use `create(RunAggregationQueryRequestSchema)` to create a new message.
 */
export const RunAggregationQueryRequestSchema: GenMessage<RunAggregationQueryRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 4);

/**
 * The response for
 * [Datastore.RunAggregationQuery][google.datastore.v1.Datastore.RunAggregationQuery].
 *
 * @generated from message google.datastore.v1.RunAggregationQueryResponse
 */
export type RunAggregationQueryResponse = Message<"google.datastore.v1.RunAggregationQueryResponse"> & {
  /**
   * A batch of aggregation results. Always present.
   *
   * @generated from field: google.datastore.v1.AggregationResultBatch batch = 1;
   */
  batch?: AggregationResultBatch;

  /**
   * The parsed form of the `GqlQuery` from the request, if it was set.
   *
   * @generated from field: google.datastore.v1.AggregationQuery query = 2;
   */
  query?: AggregationQuery;

  /**
   * The identifier of the transaction that was started as part of this
   * RunAggregationQuery request.
   *
   * Set only when
   * [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
   * was set in
   * [RunAggregationQueryRequest.read_options][google.datastore.v1.RunAggregationQueryRequest.read_options].
   *
   * @generated from field: bytes transaction = 5;
   */
  transaction: Uint8Array;

  /**
   * Query explain metrics. This is only present when the
   * [RunAggregationQueryRequest.explain_options][google.datastore.v1.RunAggregationQueryRequest.explain_options]
   * is provided, and it is sent only once with the last response in the stream.
   *
   * @generated from field: google.datastore.v1.ExplainMetrics explain_metrics = 9;
   */
  explainMetrics?: ExplainMetrics;
};

/**
 * Describes the message google.datastore.v1.RunAggregationQueryResponse.
 * Use `create(RunAggregationQueryResponseSchema)` to create a new message.
 */
export const RunAggregationQueryResponseSchema: GenMessage<RunAggregationQueryResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 5);

/**
 * The request for
 * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
 *
 * @generated from message google.datastore.v1.BeginTransactionRequest
 */
export type BeginTransactionRequest = Message<"google.datastore.v1.BeginTransactionRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Options for a new transaction.
   *
   * @generated from field: google.datastore.v1.TransactionOptions transaction_options = 10;
   */
  transactionOptions?: TransactionOptions;
};

/**
 * Describes the message google.datastore.v1.BeginTransactionRequest.
 * Use `create(BeginTransactionRequestSchema)` to create a new message.
 */
export const BeginTransactionRequestSchema: GenMessage<BeginTransactionRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 6);

/**
 * The response for
 * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
 *
 * @generated from message google.datastore.v1.BeginTransactionResponse
 */
export type BeginTransactionResponse = Message<"google.datastore.v1.BeginTransactionResponse"> & {
  /**
   * The transaction identifier (always present).
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.datastore.v1.BeginTransactionResponse.
 * Use `create(BeginTransactionResponseSchema)` to create a new message.
 */
export const BeginTransactionResponseSchema: GenMessage<BeginTransactionResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 7);

/**
 * The request for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
 *
 * @generated from message google.datastore.v1.RollbackRequest
 */
export type RollbackRequest = Message<"google.datastore.v1.RollbackRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Required. The transaction identifier, returned by a call to
   * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction: Uint8Array;
};

/**
 * Describes the message google.datastore.v1.RollbackRequest.
 * Use `create(RollbackRequestSchema)` to create a new message.
 */
export const RollbackRequestSchema: GenMessage<RollbackRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 8);

/**
 * The response for
 * [Datastore.Rollback][google.datastore.v1.Datastore.Rollback]. (an empty
 * message).
 *
 * @generated from message google.datastore.v1.RollbackResponse
 */
export type RollbackResponse = Message<"google.datastore.v1.RollbackResponse"> & {
};

/**
 * Describes the message google.datastore.v1.RollbackResponse.
 * Use `create(RollbackResponseSchema)` to create a new message.
 */
export const RollbackResponseSchema: GenMessage<RollbackResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 9);

/**
 * The request for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
 *
 * @generated from message google.datastore.v1.CommitRequest
 */
export type CommitRequest = Message<"google.datastore.v1.CommitRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * The type of commit to perform. Defaults to `TRANSACTIONAL`.
   *
   * @generated from field: google.datastore.v1.CommitRequest.Mode mode = 5;
   */
  mode: CommitRequest_Mode;

  /**
   * Must be set when mode is `TRANSACTIONAL`.
   *
   * @generated from oneof google.datastore.v1.CommitRequest.transaction_selector
   */
  transactionSelector: {
    /**
     * The identifier of the transaction associated with the commit. A
     * transaction identifier is returned by a call to
     * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
     *
     * @generated from field: bytes transaction = 1;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Options for beginning a new transaction for this request.
     * The transaction is committed when the request completes. If specified,
     * [TransactionOptions.mode][google.datastore.v1.TransactionOptions] must be
     * [TransactionOptions.ReadWrite][google.datastore.v1.TransactionOptions.ReadWrite].
     *
     * @generated from field: google.datastore.v1.TransactionOptions single_use_transaction = 10;
     */
    value: TransactionOptions;
    case: "singleUseTransaction";
  } | { case: undefined; value?: undefined };

  /**
   * The mutations to perform.
   *
   * When mode is `TRANSACTIONAL`, mutations affecting a single entity are
   * applied in order. The following sequences of mutations affecting a single
   * entity are not permitted in a single `Commit` request:
   *
   * - `insert` followed by `insert`
   * - `update` followed by `insert`
   * - `upsert` followed by `insert`
   * - `delete` followed by `update`
   *
   * When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
   * entity.
   *
   * @generated from field: repeated google.datastore.v1.Mutation mutations = 6;
   */
  mutations: Mutation[];
};

/**
 * Describes the message google.datastore.v1.CommitRequest.
 * Use `create(CommitRequestSchema)` to create a new message.
 */
export const CommitRequestSchema: GenMessage<CommitRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 10);

/**
 * The modes available for commits.
 *
 * @generated from enum google.datastore.v1.CommitRequest.Mode
 */
export enum CommitRequest_Mode {
  /**
   * Unspecified. This value must not be used.
   *
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  MODE_UNSPECIFIED = 0,

  /**
   * Transactional: The mutations are either all applied, or none are applied.
   * Learn about transactions
   * [here](https://cloud.google.com/datastore/docs/concepts/transactions).
   *
   * @generated from enum value: TRANSACTIONAL = 1;
   */
  TRANSACTIONAL = 1,

  /**
   * Non-transactional: The mutations may not apply as all or none.
   *
   * @generated from enum value: NON_TRANSACTIONAL = 2;
   */
  NON_TRANSACTIONAL = 2,
}

/**
 * Describes the enum google.datastore.v1.CommitRequest.Mode.
 */
export const CommitRequest_ModeSchema: GenEnum<CommitRequest_Mode> = /*@__PURE__*/
  enumDesc(file_google_datastore_v1_datastore, 10, 0);

/**
 * The response for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
 *
 * @generated from message google.datastore.v1.CommitResponse
 */
export type CommitResponse = Message<"google.datastore.v1.CommitResponse"> & {
  /**
   * The result of performing the mutations.
   * The i-th mutation result corresponds to the i-th mutation in the request.
   *
   * @generated from field: repeated google.datastore.v1.MutationResult mutation_results = 3;
   */
  mutationResults: MutationResult[];

  /**
   * The number of index entries updated during the commit, or zero if none were
   * updated.
   *
   * @generated from field: int32 index_updates = 4;
   */
  indexUpdates: number;

  /**
   * The transaction commit timestamp. Not set for non-transactional commits.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 8;
   */
  commitTime?: Timestamp;
};

/**
 * Describes the message google.datastore.v1.CommitResponse.
 * Use `create(CommitResponseSchema)` to create a new message.
 */
export const CommitResponseSchema: GenMessage<CommitResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 11);

/**
 * The request for
 * [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
 *
 * @generated from message google.datastore.v1.AllocateIdsRequest
 */
export type AllocateIdsRequest = Message<"google.datastore.v1.AllocateIdsRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Required. A list of keys with incomplete key paths for which to allocate
   * IDs. No key may be reserved/read-only.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[];
};

/**
 * Describes the message google.datastore.v1.AllocateIdsRequest.
 * Use `create(AllocateIdsRequestSchema)` to create a new message.
 */
export const AllocateIdsRequestSchema: GenMessage<AllocateIdsRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 12);

/**
 * The response for
 * [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
 *
 * @generated from message google.datastore.v1.AllocateIdsResponse
 */
export type AllocateIdsResponse = Message<"google.datastore.v1.AllocateIdsResponse"> & {
  /**
   * The keys specified in the request (in the same order), each with
   * its key path completed with a newly allocated ID.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[];
};

/**
 * Describes the message google.datastore.v1.AllocateIdsResponse.
 * Use `create(AllocateIdsResponseSchema)` to create a new message.
 */
export const AllocateIdsResponseSchema: GenMessage<AllocateIdsResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 13);

/**
 * The request for
 * [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
 *
 * @generated from message google.datastore.v1.ReserveIdsRequest
 */
export type ReserveIdsRequest = Message<"google.datastore.v1.ReserveIdsRequest"> & {
  /**
   * Required. The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId: string;

  /**
   * The ID of the database against which to make the request.
   *
   * '(default)' is not allowed; please use empty string '' to refer the default
   * database.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId: string;

  /**
   * Required. A list of keys with complete key paths whose numeric IDs should
   * not be auto-allocated.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[];
};

/**
 * Describes the message google.datastore.v1.ReserveIdsRequest.
 * Use `create(ReserveIdsRequestSchema)` to create a new message.
 */
export const ReserveIdsRequestSchema: GenMessage<ReserveIdsRequest> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 14);

/**
 * The response for
 * [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
 *
 * @generated from message google.datastore.v1.ReserveIdsResponse
 */
export type ReserveIdsResponse = Message<"google.datastore.v1.ReserveIdsResponse"> & {
};

/**
 * Describes the message google.datastore.v1.ReserveIdsResponse.
 * Use `create(ReserveIdsResponseSchema)` to create a new message.
 */
export const ReserveIdsResponseSchema: GenMessage<ReserveIdsResponse> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 15);

/**
 * A mutation to apply to an entity.
 *
 * @generated from message google.datastore.v1.Mutation
 */
export type Mutation = Message<"google.datastore.v1.Mutation"> & {
  /**
   * The mutation operation.
   *
   * For `insert`, `update`, and `upsert`:
   * - The entity's key must not be reserved/read-only.
   * - No property in the entity may have a reserved name,
   *   not even a property in an entity in a value.
   * - No value in the entity may have meaning 18,
   *   not even a value in an entity in another value.
   *
   * @generated from oneof google.datastore.v1.Mutation.operation
   */
  operation: {
    /**
     * The entity to insert. The entity must not already exist.
     * The entity key's final path element may be incomplete.
     *
     * @generated from field: google.datastore.v1.Entity insert = 4;
     */
    value: Entity;
    case: "insert";
  } | {
    /**
     * The entity to update. The entity must already exist.
     * Must have a complete key path.
     *
     * @generated from field: google.datastore.v1.Entity update = 5;
     */
    value: Entity;
    case: "update";
  } | {
    /**
     * The entity to upsert. The entity may or may not already exist.
     * The entity key's final path element may be incomplete.
     *
     * @generated from field: google.datastore.v1.Entity upsert = 6;
     */
    value: Entity;
    case: "upsert";
  } | {
    /**
     * The key of the entity to delete. The entity may or may not already exist.
     * Must have a complete key path and must not be reserved/read-only.
     *
     * @generated from field: google.datastore.v1.Key delete = 7;
     */
    value: Key;
    case: "delete";
  } | { case: undefined; value?: undefined };

  /**
   * When set, the server will detect whether or not this mutation conflicts
   * with the current version of the entity on the server. Conflicting mutations
   * are not applied, and are marked as such in MutationResult.
   *
   * @generated from oneof google.datastore.v1.Mutation.conflict_detection_strategy
   */
  conflictDetectionStrategy: {
    /**
     * The version of the entity that this mutation is being applied
     * to. If this does not match the current version on the server, the
     * mutation conflicts.
     *
     * @generated from field: int64 base_version = 8;
     */
    value: bigint;
    case: "baseVersion";
  } | {
    /**
     * The update time of the entity that this mutation is being applied
     * to. If this does not match the current update time on the server, the
     * mutation conflicts.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 11;
     */
    value: Timestamp;
    case: "updateTime";
  } | { case: undefined; value?: undefined };

  /**
   * The properties to write in this mutation.
   * None of the properties in the mask may have a reserved name, except for
   * `__key__`.
   * This field is ignored for `delete`.
   *
   * If the entity already exists, only properties referenced in the mask are
   * updated, others are left untouched.
   * Properties referenced in the mask but not in the entity are deleted.
   *
   * @generated from field: google.datastore.v1.PropertyMask property_mask = 9;
   */
  propertyMask?: PropertyMask;
};

/**
 * Describes the message google.datastore.v1.Mutation.
 * Use `create(MutationSchema)` to create a new message.
 */
export const MutationSchema: GenMessage<Mutation> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 16);

/**
 * The result of applying a mutation.
 *
 * @generated from message google.datastore.v1.MutationResult
 */
export type MutationResult = Message<"google.datastore.v1.MutationResult"> & {
  /**
   * The automatically allocated key.
   * Set only when the mutation allocated a key.
   *
   * @generated from field: google.datastore.v1.Key key = 3;
   */
  key?: Key;

  /**
   * The version of the entity on the server after processing the mutation. If
   * the mutation doesn't change anything on the server, then the version will
   * be the version of the current entity or, if no entity is present, a version
   * that is strictly greater than the version of any previous entity and less
   * than the version of any possible future entity.
   *
   * @generated from field: int64 version = 4;
   */
  version: bigint;

  /**
   * The create time of the entity. This field will not be set after a 'delete'.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 7;
   */
  createTime?: Timestamp;

  /**
   * The update time of the entity on the server after processing the mutation.
   * If the mutation doesn't change anything on the server, then the timestamp
   * will be the update timestamp of the current entity. This field will not be
   * set after a 'delete'.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 6;
   */
  updateTime?: Timestamp;

  /**
   * Whether a conflict was detected for this mutation. Always false when a
   * conflict detection strategy field is not set in the mutation.
   *
   * @generated from field: bool conflict_detected = 5;
   */
  conflictDetected: boolean;
};

/**
 * Describes the message google.datastore.v1.MutationResult.
 * Use `create(MutationResultSchema)` to create a new message.
 */
export const MutationResultSchema: GenMessage<MutationResult> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 17);

/**
 * The set of arbitrarily nested property paths used to restrict an operation to
 * only a subset of properties in an entity.
 *
 * @generated from message google.datastore.v1.PropertyMask
 */
export type PropertyMask = Message<"google.datastore.v1.PropertyMask"> & {
  /**
   * The paths to the properties covered by this mask.
   *
   * A path is a list of property names separated by dots (`.`), for example
   * `foo.bar` means the property `bar` inside the entity property `foo` inside
   * the entity associated with this path.
   *
   * If a property name contains a dot `.` or a backslash `\`, then that
   * name must be escaped.
   *
   * A path must not be empty, and may not reference a value inside an
   * [array value][google.datastore.v1.Value.array_value].
   *
   * @generated from field: repeated string paths = 1;
   */
  paths: string[];
};

/**
 * Describes the message google.datastore.v1.PropertyMask.
 * Use `create(PropertyMaskSchema)` to create a new message.
 */
export const PropertyMaskSchema: GenMessage<PropertyMask> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 18);

/**
 * The options shared by read requests.
 *
 * @generated from message google.datastore.v1.ReadOptions
 */
export type ReadOptions = Message<"google.datastore.v1.ReadOptions"> & {
  /**
   * For Cloud Datastore, if read_consistency is not specified, then lookups and
   * ancestor queries default to `read_consistency`=`STRONG`, global queries
   * default to `read_consistency`=`EVENTUAL`.
   *
   * For Cloud Firestore in Datastore mode, if read_consistency is not specified
   * then lookups and all queries default to `read_consistency`=`STRONG`.
   *
   * Explicitly setting `read_consistency`=`EVENTUAL` will result in eventually
   * consistent lookups & queries in both Cloud Datastore & Cloud Firestore in
   * Datastore mode.
   *
   * @generated from oneof google.datastore.v1.ReadOptions.consistency_type
   */
  consistencyType: {
    /**
     * The non-transactional read consistency to use.
     *
     * @generated from field: google.datastore.v1.ReadOptions.ReadConsistency read_consistency = 1;
     */
    value: ReadOptions_ReadConsistency;
    case: "readConsistency";
  } | {
    /**
     * The identifier of the transaction in which to read. A
     * transaction identifier is returned by a call to
     * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
     *
     * @generated from field: bytes transaction = 2;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Options for beginning a new transaction for this request.
     *
     * The new transaction identifier will be returned in the corresponding
     * response as either
     * [LookupResponse.transaction][google.datastore.v1.LookupResponse.transaction]
     * or
     * [RunQueryResponse.transaction][google.datastore.v1.RunQueryResponse.transaction].
     *
     * @generated from field: google.datastore.v1.TransactionOptions new_transaction = 3;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads entities as they were at the given time. This value is only
     * supported for Cloud Firestore in Datastore mode.
     *
     * This must be a microsecond precision timestamp within the past one hour,
     * or if Point-in-Time Recovery is enabled, can additionally be a whole
     * minute timestamp within the past 7 days.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 4;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.datastore.v1.ReadOptions.
 * Use `create(ReadOptionsSchema)` to create a new message.
 */
export const ReadOptionsSchema: GenMessage<ReadOptions> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 19);

/**
 * The possible values for read consistencies.
 *
 * @generated from enum google.datastore.v1.ReadOptions.ReadConsistency
 */
export enum ReadOptions_ReadConsistency {
  /**
   * Unspecified. This value must not be used.
   *
   * @generated from enum value: READ_CONSISTENCY_UNSPECIFIED = 0;
   */
  READ_CONSISTENCY_UNSPECIFIED = 0,

  /**
   * Strong consistency.
   *
   * @generated from enum value: STRONG = 1;
   */
  STRONG = 1,

  /**
   * Eventual consistency.
   *
   * @generated from enum value: EVENTUAL = 2;
   */
  EVENTUAL = 2,
}

/**
 * Describes the enum google.datastore.v1.ReadOptions.ReadConsistency.
 */
export const ReadOptions_ReadConsistencySchema: GenEnum<ReadOptions_ReadConsistency> = /*@__PURE__*/
  enumDesc(file_google_datastore_v1_datastore, 19, 0);

/**
 * Options for beginning a new transaction.
 *
 * Transactions can be created explicitly with calls to
 * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction]
 * or implicitly by setting
 * [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction]
 * in read requests.
 *
 * @generated from message google.datastore.v1.TransactionOptions
 */
export type TransactionOptions = Message<"google.datastore.v1.TransactionOptions"> & {
  /**
   * The `mode` of the transaction, indicating whether write operations are
   * supported.
   *
   * @generated from oneof google.datastore.v1.TransactionOptions.mode
   */
  mode: {
    /**
     * The transaction should allow both reads and writes.
     *
     * @generated from field: google.datastore.v1.TransactionOptions.ReadWrite read_write = 1;
     */
    value: TransactionOptions_ReadWrite;
    case: "readWrite";
  } | {
    /**
     * The transaction should only allow reads.
     *
     * @generated from field: google.datastore.v1.TransactionOptions.ReadOnly read_only = 2;
     */
    value: TransactionOptions_ReadOnly;
    case: "readOnly";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.datastore.v1.TransactionOptions.
 * Use `create(TransactionOptionsSchema)` to create a new message.
 */
export const TransactionOptionsSchema: GenMessage<TransactionOptions> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 20);

/**
 * Options specific to read / write transactions.
 *
 * @generated from message google.datastore.v1.TransactionOptions.ReadWrite
 */
export type TransactionOptions_ReadWrite = Message<"google.datastore.v1.TransactionOptions.ReadWrite"> & {
  /**
   * The transaction identifier of the transaction being retried.
   *
   * @generated from field: bytes previous_transaction = 1;
   */
  previousTransaction: Uint8Array;
};

/**
 * Describes the message google.datastore.v1.TransactionOptions.ReadWrite.
 * Use `create(TransactionOptions_ReadWriteSchema)` to create a new message.
 */
export const TransactionOptions_ReadWriteSchema: GenMessage<TransactionOptions_ReadWrite> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 20, 0);

/**
 * Options specific to read-only transactions.
 *
 * @generated from message google.datastore.v1.TransactionOptions.ReadOnly
 */
export type TransactionOptions_ReadOnly = Message<"google.datastore.v1.TransactionOptions.ReadOnly"> & {
  /**
   * Reads entities at the given time.
   *
   * This must be a microsecond precision timestamp within the past one hour,
   * or if Point-in-Time Recovery is enabled, can additionally be a whole
   * minute timestamp within the past 7 days.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 1;
   */
  readTime?: Timestamp;
};

/**
 * Describes the message google.datastore.v1.TransactionOptions.ReadOnly.
 * Use `create(TransactionOptions_ReadOnlySchema)` to create a new message.
 */
export const TransactionOptions_ReadOnlySchema: GenMessage<TransactionOptions_ReadOnly> = /*@__PURE__*/
  messageDesc(file_google_datastore_v1_datastore, 20, 1);

/**
 * Each RPC normalizes the partition IDs of the keys in its input entities,
 * and always returns entities with keys with normalized partition IDs.
 * This applies to all keys and entities, including those in values, except keys
 * with both an empty path and an empty or unset partition ID. Normalization of
 * input keys sets the project ID (if not already set) to the project ID from
 * the request.
 *
 *
 * @generated from service google.datastore.v1.Datastore
 */
export const Datastore: GenService<{
  /**
   * Looks up entities by key.
   *
   * @generated from rpc google.datastore.v1.Datastore.Lookup
   */
  lookup: {
    methodKind: "unary";
    input: typeof LookupRequestSchema;
    output: typeof LookupResponseSchema;
  },
  /**
   * Queries for entities.
   *
   * @generated from rpc google.datastore.v1.Datastore.RunQuery
   */
  runQuery: {
    methodKind: "unary";
    input: typeof RunQueryRequestSchema;
    output: typeof RunQueryResponseSchema;
  },
  /**
   * Runs an aggregation query.
   *
   * @generated from rpc google.datastore.v1.Datastore.RunAggregationQuery
   */
  runAggregationQuery: {
    methodKind: "unary";
    input: typeof RunAggregationQueryRequestSchema;
    output: typeof RunAggregationQueryResponseSchema;
  },
  /**
   * Begins a new transaction.
   *
   * @generated from rpc google.datastore.v1.Datastore.BeginTransaction
   */
  beginTransaction: {
    methodKind: "unary";
    input: typeof BeginTransactionRequestSchema;
    output: typeof BeginTransactionResponseSchema;
  },
  /**
   * Commits a transaction, optionally creating, deleting or modifying some
   * entities.
   *
   * @generated from rpc google.datastore.v1.Datastore.Commit
   */
  commit: {
    methodKind: "unary";
    input: typeof CommitRequestSchema;
    output: typeof CommitResponseSchema;
  },
  /**
   * Rolls back a transaction.
   *
   * @generated from rpc google.datastore.v1.Datastore.Rollback
   */
  rollback: {
    methodKind: "unary";
    input: typeof RollbackRequestSchema;
    output: typeof RollbackResponseSchema;
  },
  /**
   * Allocates IDs for the given keys, which is useful for referencing an entity
   * before it is inserted.
   *
   * @generated from rpc google.datastore.v1.Datastore.AllocateIds
   */
  allocateIds: {
    methodKind: "unary";
    input: typeof AllocateIdsRequestSchema;
    output: typeof AllocateIdsResponseSchema;
  },
  /**
   * Prevents the supplied keys' IDs from being auto-allocated by Cloud
   * Datastore.
   *
   * @generated from rpc google.datastore.v1.Datastore.ReserveIds
   */
  reserveIds: {
    methodKind: "unary";
    input: typeof ReserveIdsRequestSchema;
    output: typeof ReserveIdsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_datastore_v1_datastore, 0);

