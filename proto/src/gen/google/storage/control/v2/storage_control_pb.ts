// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/storage/control/v2/storage_control.proto (package google.storage.control.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_field_info } from "../../../api/field_info_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import { file_google_api_routing } from "../../../api/routing_pb";
import type { OperationSchema } from "../../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../../longrunning/operations_pb";
import type { EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/storage/control/v2/storage_control.proto.
 */
export const file_google_storage_control_v2_storage_control: GenFile = /*@__PURE__*/
  fileDesc("Ci9nb29nbGUvc3RvcmFnZS9jb250cm9sL3YyL3N0b3JhZ2VfY29udHJvbC5wcm90bxIZZ29vZ2xlLnN0b3JhZ2UuY29udHJvbC52MiIrChFQZW5kaW5nUmVuYW1lSW5mbxIWCglvcGVyYXRpb24YASABKAlCA+BBAyLiAgoGRm9sZGVyEhEKBG5hbWUYASABKAlCA+BBCBIbCg5tZXRhZ2VuZXJhdGlvbhgDIAEoA0ID4EEDEjQKC2NyZWF0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjQKC3VwZGF0ZV90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEk4KE3BlbmRpbmdfcmVuYW1lX2luZm8YByABKAsyLC5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLlBlbmRpbmdSZW5hbWVJbmZvQgPgQQM6bOpBaQodc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9Gb2xkZXISN3Byb2plY3RzL3twcm9qZWN0fS9idWNrZXRzL3tidWNrZXR9L2ZvbGRlcnMve2ZvbGRlcj0qKn0qB2ZvbGRlcnMyBmZvbGRlciL0AQoQR2V0Rm9sZGVyUmVxdWVzdBIzCgRuYW1lGAYgASgJQiXgQQL6QR8KHXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vRm9sZGVyEiQKF2lmX21ldGFnZW5lcmF0aW9uX21hdGNoGAMgASgDSACIAQESKAobaWZfbWV0YWdlbmVyYXRpb25fbm90X21hdGNoGAQgASgDSAGIAQESHwoKcmVxdWVzdF9pZBgFIAEoCUIL4EEB4ozP1wgCCAFCGgoYX2lmX21ldGFnZW5lcmF0aW9uX21hdGNoQh4KHF9pZl9tZXRhZ2VuZXJhdGlvbl9ub3RfbWF0Y2gi1QEKE0NyZWF0ZUZvbGRlclJlcXVlc3QSNQoGcGFyZW50GAEgASgJQiXgQQL6QR8SHXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vRm9sZGVyEjYKBmZvbGRlchgCIAEoCzIhLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuRm9sZGVyQgPgQQISFgoJZm9sZGVyX2lkGAMgASgJQgPgQQISFgoJcmVjdXJzaXZlGAQgASgIQgPgQQESHwoKcmVxdWVzdF9pZBgFIAEoCUIL4EEB4ozP1wgCCAEi9wEKE0RlbGV0ZUZvbGRlclJlcXVlc3QSMwoEbmFtZRgGIAEoCUIl4EEC+kEfCh1zdG9yYWdlLmdvb2dsZWFwaXMuY29tL0ZvbGRlchIkChdpZl9tZXRhZ2VuZXJhdGlvbl9tYXRjaBgDIAEoA0gAiAEBEigKG2lmX21ldGFnZW5lcmF0aW9uX25vdF9tYXRjaBgEIAEoA0gBiAEBEh8KCnJlcXVlc3RfaWQYBSABKAlCC+BBAeKMz9cIAggBQhoKGF9pZl9tZXRhZ2VuZXJhdGlvbl9tYXRjaEIeChxfaWZfbWV0YWdlbmVyYXRpb25fbm90X21hdGNoIowCChJMaXN0Rm9sZGVyc1JlcXVlc3QSNQoGcGFyZW50GAEgASgJQiXgQQL6QR8SHXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vRm9sZGVyEhYKCXBhZ2Vfc2l6ZRgCIAEoBUID4EEBEhcKCnBhZ2VfdG9rZW4YAyABKAlCA+BBARITCgZwcmVmaXgYBCABKAlCA+BBARIWCglkZWxpbWl0ZXIYCCABKAlCA+BBARIgChNsZXhpY29ncmFwaGljX3N0YXJ0GAYgASgJQgPgQQESHgoRbGV4aWNvZ3JhcGhpY19lbmQYByABKAlCA+BBARIfCgpyZXF1ZXN0X2lkGAkgASgJQgvgQQHijM/XCAIIASJiChNMaXN0Rm9sZGVyc1Jlc3BvbnNlEjIKB2ZvbGRlcnMYASADKAsyIS5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkZvbGRlchIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkimwIKE1JlbmFtZUZvbGRlclJlcXVlc3QSMwoEbmFtZRgHIAEoCUIl4EEC+kEfCh1zdG9yYWdlLmdvb2dsZWFwaXMuY29tL0ZvbGRlchIiChVkZXN0aW5hdGlvbl9mb2xkZXJfaWQYCCABKAlCA+BBAhIkChdpZl9tZXRhZ2VuZXJhdGlvbl9tYXRjaBgEIAEoA0gAiAEBEigKG2lmX21ldGFnZW5lcmF0aW9uX25vdF9tYXRjaBgFIAEoA0gBiAEBEh8KCnJlcXVlc3RfaWQYBiABKAlCC+BBAeKMz9cIAggBQhoKGF9pZl9tZXRhZ2VuZXJhdGlvbl9tYXRjaEIeChxfaWZfbWV0YWdlbmVyYXRpb25fbm90X21hdGNoIpoCCiJDb21tb25Mb25nUnVubmluZ09wZXJhdGlvbk1ldGFkYXRhEjQKC2NyZWF0ZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjEKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjQKC3VwZGF0ZV90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEhEKBHR5cGUYBCABKAlCA+BBAxIjChZyZXF1ZXN0ZWRfY2FuY2VsbGF0aW9uGAUgASgIQgPgQQMSHQoQcHJvZ3Jlc3NfcGVyY2VudBgGIAEoBUID4EEDIqcBChRSZW5hbWVGb2xkZXJNZXRhZGF0YRJWCg9jb21tb25fbWV0YWRhdGEYASABKAsyPS5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkNvbW1vbkxvbmdSdW5uaW5nT3BlcmF0aW9uTWV0YWRhdGESGAoQc291cmNlX2ZvbGRlcl9pZBgCIAEoCRIdChVkZXN0aW5hdGlvbl9mb2xkZXJfaWQYAyABKAki2QMKDVN0b3JhZ2VMYXlvdXQSEQoEbmFtZRgBIAEoCUID4EEDEhUKCGxvY2F0aW9uGAIgASgJQgPgQQMSGgoNbG9jYXRpb25fdHlwZRgDIAEoCUID4EEDEmQKF2N1c3RvbV9wbGFjZW1lbnRfY29uZmlnGAQgASgLMj4uZ29vZ2xlLnN0b3JhZ2UuY29udHJvbC52Mi5TdG9yYWdlTGF5b3V0LkN1c3RvbVBsYWNlbWVudENvbmZpZ0ID4EEDEmMKFmhpZXJhcmNoaWNhbF9uYW1lc3BhY2UYBSABKAsyPi5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLlN0b3JhZ2VMYXlvdXQuSGllcmFyY2hpY2FsTmFtZXNwYWNlQgPgQQMaLwoVQ3VzdG9tUGxhY2VtZW50Q29uZmlnEhYKDmRhdGFfbG9jYXRpb25zGAEgAygJGigKFUhpZXJhcmNoaWNhbE5hbWVzcGFjZRIPCgdlbmFibGVkGAEgASgIOlzqQVkKJHN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vU3RvcmFnZUxheW91dBIxcHJvamVjdHMve3Byb2plY3R9L2J1Y2tldHMve2J1Y2tldH0vc3RvcmFnZUxheW91dCKGAQoXR2V0U3RvcmFnZUxheW91dFJlcXVlc3QSOgoEbmFtZRgBIAEoCUIs4EEC+kEmCiRzdG9yYWdlLmdvb2dsZWFwaXMuY29tL1N0b3JhZ2VMYXlvdXQSDgoGcHJlZml4GAIgASgJEh8KCnJlcXVlc3RfaWQYAyABKAlCC+BBAeKMz9cIAggBIr8CCg1NYW5hZ2VkRm9sZGVyEhEKBG5hbWUYASABKAlCA+BBCBIbCg5tZXRhZ2VuZXJhdGlvbhgDIAEoA0ID4EEDEjQKC2NyZWF0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjQKC3VwZGF0ZV90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDOpEB6kGNAQokc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9NYW5hZ2VkRm9sZGVyEkZwcm9qZWN0cy97cHJvamVjdH0vYnVja2V0cy97YnVja2V0fS9tYW5hZ2VkRm9sZGVycy97bWFuYWdlZF9mb2xkZXI9Kip9Kg5tYW5hZ2VkRm9sZGVyczINbWFuYWdlZEZvbGRlciKCAgoXR2V0TWFuYWdlZEZvbGRlclJlcXVlc3QSOgoEbmFtZRgGIAEoCUIs4EEC+kEmCiRzdG9yYWdlLmdvb2dsZWFwaXMuY29tL01hbmFnZWRGb2xkZXISJAoXaWZfbWV0YWdlbmVyYXRpb25fbWF0Y2gYAyABKANIAIgBARIoChtpZl9tZXRhZ2VuZXJhdGlvbl9ub3RfbWF0Y2gYBCABKANIAYgBARIfCgpyZXF1ZXN0X2lkGAUgASgJQgvgQQHijM/XCAIIAUIaChhfaWZfbWV0YWdlbmVyYXRpb25fbWF0Y2hCHgocX2lmX21ldGFnZW5lcmF0aW9uX25vdF9tYXRjaCLiAQoaQ3JlYXRlTWFuYWdlZEZvbGRlclJlcXVlc3QSPAoGcGFyZW50GAEgASgJQizgQQL6QSYSJHN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vTWFuYWdlZEZvbGRlchJFCg5tYW5hZ2VkX2ZvbGRlchgCIAEoCzIoLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuTWFuYWdlZEZvbGRlckID4EECEh4KEW1hbmFnZWRfZm9sZGVyX2lkGAMgASgJQgPgQQISHwoKcmVxdWVzdF9pZBgEIAEoCUIL4EEB4ozP1wgCCAEingIKGkRlbGV0ZU1hbmFnZWRGb2xkZXJSZXF1ZXN0EjoKBG5hbWUYByABKAlCLOBBAvpBJgokc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9NYW5hZ2VkRm9sZGVyEiQKF2lmX21ldGFnZW5lcmF0aW9uX21hdGNoGAMgASgDSACIAQESKAobaWZfbWV0YWdlbmVyYXRpb25fbm90X21hdGNoGAQgASgDSAGIAQESFwoPYWxsb3dfbm9uX2VtcHR5GAUgASgIEh8KCnJlcXVlc3RfaWQYBiABKAlCC+BBAeKMz9cIAggBQhoKGF9pZl9tZXRhZ2VuZXJhdGlvbl9tYXRjaEIeChxfaWZfbWV0YWdlbmVyYXRpb25fbm90X21hdGNoIsABChlMaXN0TWFuYWdlZEZvbGRlcnNSZXF1ZXN0EjwKBnBhcmVudBgBIAEoCUIs4EEC+kEmEiRzdG9yYWdlLmdvb2dsZWFwaXMuY29tL01hbmFnZWRGb2xkZXISFgoJcGFnZV9zaXplGAIgASgFQgPgQQESFwoKcGFnZV90b2tlbhgDIAEoCUID4EEBEhMKBnByZWZpeBgEIAEoCUID4EEBEh8KCnJlcXVlc3RfaWQYBSABKAlCC+BBAeKMz9cIAggBIngKGkxpc3RNYW5hZ2VkRm9sZGVyc1Jlc3BvbnNlEkEKD21hbmFnZWRfZm9sZGVycxgBIAMoCzIoLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuTWFuYWdlZEZvbGRlchIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkyzQ8KDlN0b3JhZ2VDb250cm9sEpoBCgxDcmVhdGVGb2xkZXISLi5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkNyZWF0ZUZvbGRlclJlcXVlc3QaIS5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkZvbGRlciI32kEXcGFyZW50LGZvbGRlcixmb2xkZXJfaWSK0+STAhcSFQoGcGFyZW50Egt7YnVja2V0PSoqfRKPAQoMRGVsZXRlRm9sZGVyEi4uZ29vZ2xlLnN0b3JhZ2UuY29udHJvbC52Mi5EZWxldGVGb2xkZXJSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IjfaQQRuYW1litPkkwIqEigKBG5hbWUSIHtidWNrZXQ9cHJvamVjdHMvKi9idWNrZXRzLyp9LyoqEpQBCglHZXRGb2xkZXISKy5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkdldEZvbGRlclJlcXVlc3QaIS5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkZvbGRlciI32kEEbmFtZYrT5JMCKhIoCgRuYW1lEiB7YnVja2V0PXByb2plY3RzLyovYnVja2V0cy8qfS8qKhKUAQoLTGlzdEZvbGRlcnMSLS5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLkxpc3RGb2xkZXJzUmVxdWVzdBouLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuTGlzdEZvbGRlcnNSZXNwb25zZSIm2kEGcGFyZW50itPkkwIXEhUKBnBhcmVudBILe2J1Y2tldD0qKn0SzQEKDFJlbmFtZUZvbGRlchIuLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuUmVuYW1lRm9sZGVyUmVxdWVzdBodLmdvb2dsZS5sb25ncnVubmluZy5PcGVyYXRpb24ibspBHgoGRm9sZGVyEhRSZW5hbWVGb2xkZXJNZXRhZGF0YdpBGm5hbWUsZGVzdGluYXRpb25fZm9sZGVyX2lkitPkkwIqEigKBG5hbWUSIHtidWNrZXQ9cHJvamVjdHMvKi9idWNrZXRzLyp9LyoqEqkBChBHZXRTdG9yYWdlTGF5b3V0EjIuZ29vZ2xlLnN0b3JhZ2UuY29udHJvbC52Mi5HZXRTdG9yYWdlTGF5b3V0UmVxdWVzdBooLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuU3RvcmFnZUxheW91dCI32kEEbmFtZYrT5JMCKhIoCgRuYW1lEiB7YnVja2V0PXByb2plY3RzLyovYnVja2V0cy8qfS8qKhK/AQoTQ3JlYXRlTWFuYWdlZEZvbGRlchI1Lmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuQ3JlYXRlTWFuYWdlZEZvbGRlclJlcXVlc3QaKC5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLk1hbmFnZWRGb2xkZXIiR9pBJ3BhcmVudCxtYW5hZ2VkX2ZvbGRlcixtYW5hZ2VkX2ZvbGRlcl9pZIrT5JMCFxIVCgZwYXJlbnQSC3tidWNrZXQ9Kip9Ep0BChNEZWxldGVNYW5hZ2VkRm9sZGVyEjUuZ29vZ2xlLnN0b3JhZ2UuY29udHJvbC52Mi5EZWxldGVNYW5hZ2VkRm9sZGVyUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSI32kEEbmFtZYrT5JMCKhIoCgRuYW1lEiB7YnVja2V0PXByb2plY3RzLyovYnVja2V0cy8qfS8qKhKpAQoQR2V0TWFuYWdlZEZvbGRlchIyLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuR2V0TWFuYWdlZEZvbGRlclJlcXVlc3QaKC5nb29nbGUuc3RvcmFnZS5jb250cm9sLnYyLk1hbmFnZWRGb2xkZXIiN9pBBG5hbWWK0+STAioSKAoEbmFtZRIge2J1Y2tldD1wcm9qZWN0cy8qL2J1Y2tldHMvKn0vKioSqQEKEkxpc3RNYW5hZ2VkRm9sZGVycxI0Lmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuTGlzdE1hbmFnZWRGb2xkZXJzUmVxdWVzdBo1Lmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjIuTGlzdE1hbmFnZWRGb2xkZXJzUmVzcG9uc2UiJtpBBnBhcmVudIrT5JMCFxIVCgZwYXJlbnQSC3tidWNrZXQ9Kip9GqcCykEWc3RvcmFnZS5nb29nbGVhcGlzLmNvbdJBigJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0ucmVhZC1vbmx5LGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGV2c3RvcmFnZS5mdWxsX2NvbnRyb2wsaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kZXZzdG9yYWdlLnJlYWRfb25seSxodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RldnN0b3JhZ2UucmVhZF93cml0ZUKmAgodY29tLmdvb2dsZS5zdG9yYWdlLmNvbnRyb2wudjJCE1N0b3JhZ2VDb250cm9sUHJvdG9QAVo9Y2xvdWQuZ29vZ2xlLmNvbS9nby9zdG9yYWdlL2NvbnRyb2wvYXBpdjIvY29udHJvbHBiO2NvbnRyb2xwYqoCH0dvb2dsZS5DbG91ZC5TdG9yYWdlLkNvbnRyb2wuVjLKAh9Hb29nbGVcQ2xvdWRcU3RvcmFnZVxDb250cm9sXFYy6gIjR29vZ2xlOjpDbG91ZDo6U3RvcmFnZTo6Q29udHJvbDo6VjLqQUQKHXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vQnVja2V0EiNwcm9qZWN0cy97cHJvamVjdH0vYnVja2V0cy97YnVja2V0fWIGcHJvdG8z", [file_google_api_client, file_google_api_field_behavior, file_google_api_field_info, file_google_api_resource, file_google_api_routing, file_google_longrunning_operations, file_google_protobuf_empty, file_google_protobuf_timestamp]);

/**
 * Contains information about a pending rename operation.
 *
 * @generated from message google.storage.control.v2.PendingRenameInfo
 */
export type PendingRenameInfo = Message<"google.storage.control.v2.PendingRenameInfo"> & {
  /**
   * Output only. The name of the rename operation.
   *
   * @generated from field: string operation = 1;
   */
  operation: string;
};

/**
 * Describes the message google.storage.control.v2.PendingRenameInfo.
 * Use `create(PendingRenameInfoSchema)` to create a new message.
 */
export const PendingRenameInfoSchema: GenMessage<PendingRenameInfo> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 0);

/**
 * A folder resource. This resource can only exist in a hierarchical namespace
 * enabled bucket.
 *
 * @generated from message google.storage.control.v2.Folder
 */
export type Folder = Message<"google.storage.control.v2.Folder"> & {
  /**
   * Identifier. The name of this folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The version of the metadata for this folder. Used for
   * preconditions and for detecting changes in metadata.
   *
   * @generated from field: int64 metageneration = 3;
   */
  metageneration: bigint;

  /**
   * Output only. The creation time of the folder.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * Output only. The modification time of the folder.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime?: Timestamp;

  /**
   * Output only. Only present if the folder is part of an ongoing RenameFolder
   * operation. Contains information which can be used to query the operation
   * status. The presence of this field also indicates all write operations are
   * blocked for this folder, including folder, managed folder, and object
   * operations.
   *
   * @generated from field: google.storage.control.v2.PendingRenameInfo pending_rename_info = 7;
   */
  pendingRenameInfo?: PendingRenameInfo;
};

/**
 * Describes the message google.storage.control.v2.Folder.
 * Use `create(FolderSchema)` to create a new message.
 */
export const FolderSchema: GenMessage<Folder> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 1);

/**
 * Request message for GetFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 *
 * @generated from message google.storage.control.v2.GetFolderRequest
 */
export type GetFolderRequest = Message<"google.storage.control.v2.GetFolderRequest"> & {
  /**
   * Required. Name of the folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration matches the given value.
   *
   * @generated from field: optional int64 if_metageneration_match = 3;
   */
  ifMetagenerationMatch?: bigint;

  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration does not match the given value.
   *
   * @generated from field: optional int64 if_metageneration_not_match = 4;
   */
  ifMetagenerationNotMatch?: bigint;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.GetFolderRequest.
 * Use `create(GetFolderRequestSchema)` to create a new message.
 */
export const GetFolderRequestSchema: GenMessage<GetFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 2);

/**
 * Request message for CreateFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 *
 * @generated from message google.storage.control.v2.CreateFolderRequest
 */
export type CreateFolderRequest = Message<"google.storage.control.v2.CreateFolderRequest"> & {
  /**
   * Required. Name of the bucket in which the folder will reside. The bucket
   * must be a hierarchical namespace enabled bucket.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. Properties of the new folder being created.
   * The bucket and name of the folder are specified in the parent and folder_id
   * fields, respectively. Populating those fields in `folder` will result in an
   * error.
   *
   * @generated from field: google.storage.control.v2.Folder folder = 2;
   */
  folder?: Folder;

  /**
   * Required. The full name of a folder, including all its parent folders.
   * Folders use single '/' characters as a delimiter.
   * The folder_id must end with a slash.
   * For example, the folder_id of "books/biographies/" would create a new
   * "biographies/" folder under the "books/" folder.
   *
   * @generated from field: string folder_id = 3;
   */
  folderId: string;

  /**
   * Optional. If true, parent folder doesn't have to be present and all missing
   * ancestor folders will be created atomically.
   *
   * @generated from field: bool recursive = 4;
   */
  recursive: boolean;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.CreateFolderRequest.
 * Use `create(CreateFolderRequestSchema)` to create a new message.
 */
export const CreateFolderRequestSchema: GenMessage<CreateFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 3);

/**
 * Request message for DeleteFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 *
 * @generated from message google.storage.control.v2.DeleteFolderRequest
 */
export type DeleteFolderRequest = Message<"google.storage.control.v2.DeleteFolderRequest"> & {
  /**
   * Required. Name of the folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration matches the given value.
   *
   * @generated from field: optional int64 if_metageneration_match = 3;
   */
  ifMetagenerationMatch?: bigint;

  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration does not match the given value.
   *
   * @generated from field: optional int64 if_metageneration_not_match = 4;
   */
  ifMetagenerationNotMatch?: bigint;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.DeleteFolderRequest.
 * Use `create(DeleteFolderRequestSchema)` to create a new message.
 */
export const DeleteFolderRequestSchema: GenMessage<DeleteFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 4);

/**
 * Request message for ListFolders. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 *
 * @generated from message google.storage.control.v2.ListFoldersRequest
 */
export type ListFoldersRequest = Message<"google.storage.control.v2.ListFoldersRequest"> & {
  /**
   * Required. Name of the bucket in which to look for folders. The bucket must
   * be a hierarchical namespace enabled bucket.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Maximum number of folders to return in a single response. The
   * service will use this parameter or 1,000 items, whichever is smaller.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. A previously-returned page token representing part of the larger
   * set of results to view.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Optional. Filter results to folders whose names begin with this prefix.
   * If set, the value must either be an empty string or end with a '/'.
   *
   * @generated from field: string prefix = 4;
   */
  prefix: string;

  /**
   * Optional. If set, returns results in a directory-like mode. The results
   * will only include folders that either exactly match the above prefix, or
   * are one level below the prefix. The only supported value is '/'.
   *
   * @generated from field: string delimiter = 8;
   */
  delimiter: string;

  /**
   * Optional. Filter results to folders whose names are lexicographically equal
   * to or after lexicographic_start. If lexicographic_end is also set, the
   * folders listed have names between lexicographic_start (inclusive) and
   * lexicographic_end (exclusive).
   *
   * @generated from field: string lexicographic_start = 6;
   */
  lexicographicStart: string;

  /**
   * Optional. Filter results to folders whose names are lexicographically
   * before lexicographic_end. If lexicographic_start is also set, the folders
   * listed have names between lexicographic_start (inclusive) and
   * lexicographic_end (exclusive).
   *
   * @generated from field: string lexicographic_end = 7;
   */
  lexicographicEnd: string;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 9;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.ListFoldersRequest.
 * Use `create(ListFoldersRequestSchema)` to create a new message.
 */
export const ListFoldersRequestSchema: GenMessage<ListFoldersRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 5);

/**
 * Response message for ListFolders.
 *
 * @generated from message google.storage.control.v2.ListFoldersResponse
 */
export type ListFoldersResponse = Message<"google.storage.control.v2.ListFoldersResponse"> & {
  /**
   * The list of child folders
   *
   * @generated from field: repeated google.storage.control.v2.Folder folders = 1;
   */
  folders: Folder[];

  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.storage.control.v2.ListFoldersResponse.
 * Use `create(ListFoldersResponseSchema)` to create a new message.
 */
export const ListFoldersResponseSchema: GenMessage<ListFoldersResponse> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 6);

/**
 * Request message for RenameFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 *
 * @generated from message google.storage.control.v2.RenameFolderRequest
 */
export type RenameFolderRequest = Message<"google.storage.control.v2.RenameFolderRequest"> & {
  /**
   * Required. Name of the source folder being renamed.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * Required. The destination folder ID, e.g. `foo/bar/`.
   *
   * @generated from field: string destination_folder_id = 8;
   */
  destinationFolderId: string;

  /**
   * Makes the operation only succeed conditional on whether the source
   * folder's current metageneration matches the given value.
   *
   * @generated from field: optional int64 if_metageneration_match = 4;
   */
  ifMetagenerationMatch?: bigint;

  /**
   * Makes the operation only succeed conditional on whether the source
   * folder's current metageneration does not match the given value.
   *
   * @generated from field: optional int64 if_metageneration_not_match = 5;
   */
  ifMetagenerationNotMatch?: bigint;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted. This request is only
   * idempotent if a `request_id` is provided.
   *
   * @generated from field: string request_id = 6;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.RenameFolderRequest.
 * Use `create(RenameFolderRequestSchema)` to create a new message.
 */
export const RenameFolderRequestSchema: GenMessage<RenameFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 7);

/**
 * The message contains metadata that is common to all Storage Control
 * long-running operations, present in its `google.longrunning.Operation`
 * messages, and accessible via `metadata.common_metadata`.
 *
 * @generated from message google.storage.control.v2.CommonLongRunningOperationMetadata
 */
export type CommonLongRunningOperationMetadata = Message<"google.storage.control.v2.CommonLongRunningOperationMetadata"> & {
  /**
   * Output only. The time the operation was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 1;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time the operation finished running.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Output only. The time the operation was last modified.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;

  /**
   * Output only. The type of operation invoked.
   *
   * @generated from field: string type = 4;
   */
  type: string;

  /**
   * Output only. Identifies whether the user has requested cancellation.
   *
   * @generated from field: bool requested_cancellation = 5;
   */
  requestedCancellation: boolean;

  /**
   * Output only. The estimated progress of the operation in percentage [0,
   * 100]. The value -1 means the progress is unknown.
   *
   * @generated from field: int32 progress_percent = 6;
   */
  progressPercent: number;
};

/**
 * Describes the message google.storage.control.v2.CommonLongRunningOperationMetadata.
 * Use `create(CommonLongRunningOperationMetadataSchema)` to create a new message.
 */
export const CommonLongRunningOperationMetadataSchema: GenMessage<CommonLongRunningOperationMetadata> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 8);

/**
 * Message returned in the metadata field of the Operation resource for
 * RenameFolder operations.
 *
 * @generated from message google.storage.control.v2.RenameFolderMetadata
 */
export type RenameFolderMetadata = Message<"google.storage.control.v2.RenameFolderMetadata"> & {
  /**
   * Generic metadata for the long running operation.
   *
   * @generated from field: google.storage.control.v2.CommonLongRunningOperationMetadata common_metadata = 1;
   */
  commonMetadata?: CommonLongRunningOperationMetadata;

  /**
   * The path of the source folder.
   *
   * @generated from field: string source_folder_id = 2;
   */
  sourceFolderId: string;

  /**
   * The path of the destination folder.
   *
   * @generated from field: string destination_folder_id = 3;
   */
  destinationFolderId: string;
};

/**
 * Describes the message google.storage.control.v2.RenameFolderMetadata.
 * Use `create(RenameFolderMetadataSchema)` to create a new message.
 */
export const RenameFolderMetadataSchema: GenMessage<RenameFolderMetadata> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 9);

/**
 * The storage layout configuration of a bucket.
 *
 * @generated from message google.storage.control.v2.StorageLayout
 */
export type StorageLayout = Message<"google.storage.control.v2.StorageLayout"> & {
  /**
   * Output only. The name of the StorageLayout resource.
   * Format: `projects/{project}/buckets/{bucket}/storageLayout`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The location of the bucket.
   *
   * @generated from field: string location = 2;
   */
  location: string;

  /**
   * Output only. The location type of the bucket (region, dual-region,
   * multi-region, etc).
   *
   * @generated from field: string location_type = 3;
   */
  locationType: string;

  /**
   * Output only. The data placement configuration for custom dual region. If
   * there is no configuration, this is not a custom dual region bucket.
   *
   * @generated from field: google.storage.control.v2.StorageLayout.CustomPlacementConfig custom_placement_config = 4;
   */
  customPlacementConfig?: StorageLayout_CustomPlacementConfig;

  /**
   * Output only. The bucket's hierarchical namespace configuration. If there is
   * no configuration, the hierarchical namespace is disabled.
   *
   * @generated from field: google.storage.control.v2.StorageLayout.HierarchicalNamespace hierarchical_namespace = 5;
   */
  hierarchicalNamespace?: StorageLayout_HierarchicalNamespace;
};

/**
 * Describes the message google.storage.control.v2.StorageLayout.
 * Use `create(StorageLayoutSchema)` to create a new message.
 */
export const StorageLayoutSchema: GenMessage<StorageLayout> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 10);

/**
 * Configuration for Custom Dual Regions.  It should specify precisely two
 * eligible regions within the same Multiregion. More information on regions
 * may be found [https://cloud.google.com/storage/docs/locations][here].
 *
 * @generated from message google.storage.control.v2.StorageLayout.CustomPlacementConfig
 */
export type StorageLayout_CustomPlacementConfig = Message<"google.storage.control.v2.StorageLayout.CustomPlacementConfig"> & {
  /**
   * List of locations to use for data placement.
   *
   * @generated from field: repeated string data_locations = 1;
   */
  dataLocations: string[];
};

/**
 * Describes the message google.storage.control.v2.StorageLayout.CustomPlacementConfig.
 * Use `create(StorageLayout_CustomPlacementConfigSchema)` to create a new message.
 */
export const StorageLayout_CustomPlacementConfigSchema: GenMessage<StorageLayout_CustomPlacementConfig> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 10, 0);

/**
 * Configuration for a bucket's hierarchical namespace feature.
 *
 * @generated from message google.storage.control.v2.StorageLayout.HierarchicalNamespace
 */
export type StorageLayout_HierarchicalNamespace = Message<"google.storage.control.v2.StorageLayout.HierarchicalNamespace"> & {
  /**
   * Enables the hierarchical namespace feature.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message google.storage.control.v2.StorageLayout.HierarchicalNamespace.
 * Use `create(StorageLayout_HierarchicalNamespaceSchema)` to create a new message.
 */
export const StorageLayout_HierarchicalNamespaceSchema: GenMessage<StorageLayout_HierarchicalNamespace> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 10, 1);

/**
 * Request message for GetStorageLayout.
 *
 * @generated from message google.storage.control.v2.GetStorageLayoutRequest
 */
export type GetStorageLayoutRequest = Message<"google.storage.control.v2.GetStorageLayoutRequest"> & {
  /**
   * Required. The name of the StorageLayout resource.
   * Format: `projects/{project}/buckets/{bucket}/storageLayout`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An optional prefix used for permission check. It is useful when the caller
   * only has limited permissions under a specific prefix.
   *
   * @generated from field: string prefix = 2;
   */
  prefix: string;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.GetStorageLayoutRequest.
 * Use `create(GetStorageLayoutRequestSchema)` to create a new message.
 */
export const GetStorageLayoutRequestSchema: GenMessage<GetStorageLayoutRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 11);

/**
 * A managed folder.
 *
 * @generated from message google.storage.control.v2.ManagedFolder
 */
export type ManagedFolder = Message<"google.storage.control.v2.ManagedFolder"> & {
  /**
   * Identifier. The name of this managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The metadata version of this managed folder. It increases
   * whenever the metadata is updated. Used for preconditions and for detecting
   * changes in metadata. Managed folders don't have a generation number.
   *
   * @generated from field: int64 metageneration = 3;
   */
  metageneration: bigint;

  /**
   * Output only. The creation time of the managed folder.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * Output only. The modification time of the managed folder.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime?: Timestamp;
};

/**
 * Describes the message google.storage.control.v2.ManagedFolder.
 * Use `create(ManagedFolderSchema)` to create a new message.
 */
export const ManagedFolderSchema: GenMessage<ManagedFolder> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 12);

/**
 * Request message for GetManagedFolder.
 *
 * @generated from message google.storage.control.v2.GetManagedFolderRequest
 */
export type GetManagedFolderRequest = Message<"google.storage.control.v2.GetManagedFolderRequest"> & {
  /**
   * Required. Name of the managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   *
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration matching the value here specified.
   *
   * @generated from field: optional int64 if_metageneration_match = 3;
   */
  ifMetagenerationMatch?: bigint;

  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration NOT matching the value here specified.
   *
   * @generated from field: optional int64 if_metageneration_not_match = 4;
   */
  ifMetagenerationNotMatch?: bigint;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.GetManagedFolderRequest.
 * Use `create(GetManagedFolderRequestSchema)` to create a new message.
 */
export const GetManagedFolderRequestSchema: GenMessage<GetManagedFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 13);

/**
 * Request message for CreateManagedFolder.
 *
 * @generated from message google.storage.control.v2.CreateManagedFolderRequest
 */
export type CreateManagedFolderRequest = Message<"google.storage.control.v2.CreateManagedFolderRequest"> & {
  /**
   * Required. Name of the bucket this managed folder belongs to.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. Properties of the managed folder being created.
   * The bucket and managed folder names are specified in the `parent` and
   * `managed_folder_id` fields. Populating these fields in `managed_folder`
   * will result in an error.
   *
   * @generated from field: google.storage.control.v2.ManagedFolder managed_folder = 2;
   */
  managedFolder?: ManagedFolder;

  /**
   * Required. The name of the managed folder. It uses a single `/` as delimiter
   * and leading and trailing `/` are allowed.
   *
   * @generated from field: string managed_folder_id = 3;
   */
  managedFolderId: string;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.CreateManagedFolderRequest.
 * Use `create(CreateManagedFolderRequestSchema)` to create a new message.
 */
export const CreateManagedFolderRequestSchema: GenMessage<CreateManagedFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 14);

/**
 * DeleteManagedFolder RPC request message.
 *
 * @generated from message google.storage.control.v2.DeleteManagedFolderRequest
 */
export type DeleteManagedFolderRequest = Message<"google.storage.control.v2.DeleteManagedFolderRequest"> & {
  /**
   * Required. Name of the managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration matching the value here specified.
   *
   * @generated from field: optional int64 if_metageneration_match = 3;
   */
  ifMetagenerationMatch?: bigint;

  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration NOT matching the value here specified.
   *
   * @generated from field: optional int64 if_metageneration_not_match = 4;
   */
  ifMetagenerationNotMatch?: bigint;

  /**
   * Allows deletion of a managed folder even if it is not empty.
   * A managed folder is empty if it manages no child managed folders or
   * objects. Caller must have permission for
   * storage.managedFolders.setIamPolicy.
   *
   * @generated from field: bool allow_non_empty = 5;
   */
  allowNonEmpty: boolean;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 6;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.DeleteManagedFolderRequest.
 * Use `create(DeleteManagedFolderRequestSchema)` to create a new message.
 */
export const DeleteManagedFolderRequestSchema: GenMessage<DeleteManagedFolderRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 15);

/**
 * Request message for ListManagedFolders.
 *
 * @generated from message google.storage.control.v2.ListManagedFoldersRequest
 */
export type ListManagedFoldersRequest = Message<"google.storage.control.v2.ListManagedFoldersRequest"> & {
  /**
   * Required. Name of the bucket this managed folder belongs to.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Maximum number of managed folders to return in a single response.
   * The service will use this parameter or 1,000 items, whichever is smaller.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. A previously-returned page token representing part of the larger
   * set of results to view.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Optional. Filter results to match managed folders with name starting with
   * this prefix.
   *
   * @generated from field: string prefix = 4;
   */
  prefix: string;

  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message google.storage.control.v2.ListManagedFoldersRequest.
 * Use `create(ListManagedFoldersRequestSchema)` to create a new message.
 */
export const ListManagedFoldersRequestSchema: GenMessage<ListManagedFoldersRequest> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 16);

/**
 * Response message for ListManagedFolders.
 *
 * @generated from message google.storage.control.v2.ListManagedFoldersResponse
 */
export type ListManagedFoldersResponse = Message<"google.storage.control.v2.ListManagedFoldersResponse"> & {
  /**
   * The list of matching managed folders
   *
   * @generated from field: repeated google.storage.control.v2.ManagedFolder managed_folders = 1;
   */
  managedFolders: ManagedFolder[];

  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.storage.control.v2.ListManagedFoldersResponse.
 * Use `create(ListManagedFoldersResponseSchema)` to create a new message.
 */
export const ListManagedFoldersResponseSchema: GenMessage<ListManagedFoldersResponse> = /*@__PURE__*/
  messageDesc(file_google_storage_control_v2_storage_control, 17);

/**
 * StorageControl service includes selected control plane operations.
 *
 * @generated from service google.storage.control.v2.StorageControl
 */
export const StorageControl: GenService<{
  /**
   * Creates a new folder. This operation is only applicable to a hierarchical
   * namespace enabled bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.CreateFolder
   */
  createFolder: {
    methodKind: "unary";
    input: typeof CreateFolderRequestSchema;
    output: typeof FolderSchema;
  },
  /**
   * Permanently deletes an empty folder. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.DeleteFolder
   */
  deleteFolder: {
    methodKind: "unary";
    input: typeof DeleteFolderRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Returns metadata for the specified folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.GetFolder
   */
  getFolder: {
    methodKind: "unary";
    input: typeof GetFolderRequestSchema;
    output: typeof FolderSchema;
  },
  /**
   * Retrieves a list of folders. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.ListFolders
   */
  listFolders: {
    methodKind: "unary";
    input: typeof ListFoldersRequestSchema;
    output: typeof ListFoldersResponseSchema;
  },
  /**
   * Renames a source folder to a destination folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket. During a rename, the
   * source and destination folders are locked until the long running operation
   * completes.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.RenameFolder
   */
  renameFolder: {
    methodKind: "unary";
    input: typeof RenameFolderRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Returns the storage layout configuration for a given bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.GetStorageLayout
   */
  getStorageLayout: {
    methodKind: "unary";
    input: typeof GetStorageLayoutRequestSchema;
    output: typeof StorageLayoutSchema;
  },
  /**
   * Creates a new managed folder.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.CreateManagedFolder
   */
  createManagedFolder: {
    methodKind: "unary";
    input: typeof CreateManagedFolderRequestSchema;
    output: typeof ManagedFolderSchema;
  },
  /**
   * Permanently deletes an empty managed folder.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.DeleteManagedFolder
   */
  deleteManagedFolder: {
    methodKind: "unary";
    input: typeof DeleteManagedFolderRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Returns metadata for the specified managed folder.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.GetManagedFolder
   */
  getManagedFolder: {
    methodKind: "unary";
    input: typeof GetManagedFolderRequestSchema;
    output: typeof ManagedFolderSchema;
  },
  /**
   * Retrieves a list of managed folders for a given bucket.
   *
   * @generated from rpc google.storage.control.v2.StorageControl.ListManagedFolders
   */
  listManagedFolders: {
    methodKind: "unary";
    input: typeof ListManagedFoldersRequestSchema;
    output: typeof ListManagedFoldersResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_storage_control_v2_storage_control, 0);

