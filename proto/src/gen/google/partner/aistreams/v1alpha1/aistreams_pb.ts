// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/partner/aistreams/v1alpha1/aistreams.proto (package google.partner.aistreams.v1alpha1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { OperationSchema } from "../../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../../longrunning/operations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/partner/aistreams/v1alpha1/aistreams.proto.
 */
export const file_google_partner_aistreams_v1alpha1_aistreams: GenFile = /*@__PURE__*/
  fileDesc("CjFnb29nbGUvcGFydG5lci9haXN0cmVhbXMvdjFhbHBoYTEvYWlzdHJlYW1zLnByb3RvEiFnb29nbGUucGFydG5lci5haXN0cmVhbXMudjFhbHBoYTEilgMKB0NsdXN0ZXISDAoEbmFtZRgBIAEoCRI0CgtjcmVhdGVfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxI0Cgt1cGRhdGVfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxJGCgZsYWJlbHMYBCADKAsyNi5nb29nbGUucGFydG5lci5haXN0cmVhbXMudjFhbHBoYTEuQ2x1c3Rlci5MYWJlbHNFbnRyeRIYCgtjZXJ0aWZpY2F0ZRgFIAEoCUID4EEDEh0KEHNlcnZpY2VfZW5kcG9pbnQYBiABKAlCA+BBAxotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBOmHqQV4KIGFpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9DbHVzdGVyEjpwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3tsb2NhdGlvbn0vY2x1c3RlcnMve2NsdXN0ZXJ9IpkBChNMaXN0Q2x1c3RlcnNSZXF1ZXN0EjkKBnBhcmVudBgBIAEoCUIp4EEC+kEjCiFsb2NhdGlvbnMuZ29vZ2xlYXBpcy5jb20vTG9jYXRpb24SEQoJcGFnZV9zaXplGAIgASgFEhIKCnBhZ2VfdG9rZW4YAyABKAkSDgoGZmlsdGVyGAQgASgJEhAKCG9yZGVyX2J5GAUgASgJIoIBChRMaXN0Q2x1c3RlcnNSZXNwb25zZRI8CghjbHVzdGVycxgBIAMoCzIqLmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5DbHVzdGVyEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCRITCgt1bnJlYWNoYWJsZRgDIAMoCSJLChFHZXRDbHVzdGVyUmVxdWVzdBI2CgRuYW1lGAEgASgJQijgQQL6QSIKIGFpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9DbHVzdGVyIsUBChRDcmVhdGVDbHVzdGVyUmVxdWVzdBI5CgZwYXJlbnQYASABKAlCKeBBAvpBIwohbG9jYXRpb25zLmdvb2dsZWFwaXMuY29tL0xvY2F0aW9uEhcKCmNsdXN0ZXJfaWQYAiABKAlCA+BBAhJACgdjbHVzdGVyGAMgASgLMiouZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkNsdXN0ZXJCA+BBAhIXCgpyZXF1ZXN0X2lkGAQgASgJQgPgQQEipwEKFFVwZGF0ZUNsdXN0ZXJSZXF1ZXN0EjQKC3VwZGF0ZV9tYXNrGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFza0ID4EECEkAKB2NsdXN0ZXIYAiABKAsyKi5nb29nbGUucGFydG5lci5haXN0cmVhbXMudjFhbHBoYTEuQ2x1c3RlckID4EECEhcKCnJlcXVlc3RfaWQYAyABKAlCA+BBASJnChREZWxldGVDbHVzdGVyUmVxdWVzdBI2CgRuYW1lGAEgASgJQijgQQL6QSIKIGFpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9DbHVzdGVyEhcKCnJlcXVlc3RfaWQYAiABKAlCA+BBASLrAgoGU3RyZWFtEgwKBG5hbWUYASABKAkSNAoLY3JlYXRlX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSNAoLdXBkYXRlX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSRQoGbGFiZWxzGAQgAygLMjUuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLlN0cmVhbS5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBOnHqQW4KH2Fpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9TdHJlYW0SS3Byb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9jbHVzdGVycy97Y2x1c3Rlcn0vc3RyZWFtcy97c3RyZWFtfSKXAQoSTGlzdFN0cmVhbXNSZXF1ZXN0EjgKBnBhcmVudBgBIAEoCUIo4EEC+kEiCiBhaXN0cmVhbXMuZ29vZ2xlYXBpcy5jb20vQ2x1c3RlchIRCglwYWdlX3NpemUYAiABKAUSEgoKcGFnZV90b2tlbhgDIAEoCRIOCgZmaWx0ZXIYBCABKAkSEAoIb3JkZXJfYnkYBSABKAkifwoTTGlzdFN0cmVhbXNSZXNwb25zZRI6CgdzdHJlYW1zGAEgAygLMikuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLlN0cmVhbRIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkSEwoLdW5yZWFjaGFibGUYAyADKAkiSQoQR2V0U3RyZWFtUmVxdWVzdBI1CgRuYW1lGAEgASgJQifgQQL6QSEKH2Fpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9TdHJlYW0iwAEKE0NyZWF0ZVN0cmVhbVJlcXVlc3QSOAoGcGFyZW50GAEgASgJQijgQQL6QSIKIGFpc3RyZWFtcy5nb29nbGVhcGlzLmNvbS9DbHVzdGVyEhYKCXN0cmVhbV9pZBgCIAEoCUID4EECEj4KBnN0cmVhbRgDIAEoCzIpLmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5TdHJlYW1CA+BBAhIXCgpyZXF1ZXN0X2lkGAQgASgJQgPgQQEipAEKE1VwZGF0ZVN0cmVhbVJlcXVlc3QSNAoLdXBkYXRlX21hc2sYASABKAsyGi5nb29nbGUucHJvdG9idWYuRmllbGRNYXNrQgPgQQISPgoGc3RyZWFtGAIgASgLMikuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLlN0cmVhbUID4EECEhcKCnJlcXVlc3RfaWQYAyABKAlCA+BBASJlChNEZWxldGVTdHJlYW1SZXF1ZXN0EjUKBG5hbWUYASABKAlCJ+BBAvpBIQofYWlzdHJlYW1zLmdvb2dsZWFwaXMuY29tL1N0cmVhbRIXCgpyZXF1ZXN0X2lkGAIgASgJQgPgQQEigAIKEU9wZXJhdGlvbk1ldGFkYXRhEjQKC2NyZWF0ZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjEKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEhMKBnRhcmdldBgDIAEoCUID4EEDEhEKBHZlcmIYBCABKAlCA+BBAxIbCg5zdGF0dXNfbWVzc2FnZRgFIAEoCUID4EEDEiMKFnJlcXVlc3RlZF9jYW5jZWxsYXRpb24YBiABKAhCA+BBAxIYCgthcGlfdmVyc2lvbhgHIAEoCUID4EEDMtARCglBSVN0cmVhbXMSxAEKDExpc3RDbHVzdGVycxI2Lmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5MaXN0Q2x1c3RlcnNSZXF1ZXN0GjcuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkxpc3RDbHVzdGVyc1Jlc3BvbnNlIkPaQQZwYXJlbnSC0+STAjQSMi92MWFscGhhMS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyp9L2NsdXN0ZXJzErEBCgpHZXRDbHVzdGVyEjQuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkdldENsdXN0ZXJSZXF1ZXN0GiouZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkNsdXN0ZXIiQdpBBG5hbWWC0+STAjQSMi92MWFscGhhMS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2NsdXN0ZXJzLyp9EucBCg1DcmVhdGVDbHVzdGVyEjcuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiJ+ykEcCgdDbHVzdGVyEhFPcGVyYXRpb25NZXRhZGF0YdpBGXBhcmVudCxjbHVzdGVyLGNsdXN0ZXJfaWSC0+STAj06B2NsdXN0ZXIiMi92MWFscGhhMS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyp9L2NsdXN0ZXJzEuoBCg1VcGRhdGVDbHVzdGVyEjcuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLlVwZGF0ZUNsdXN0ZXJSZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiKAAcpBHAoHQ2x1c3RlchIRT3BlcmF0aW9uTWV0YWRhdGHaQRNjbHVzdGVyLHVwZGF0ZV9tYXNrgtPkkwJFOgdjbHVzdGVyMjovdjFhbHBoYTEve2NsdXN0ZXIubmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2NsdXN0ZXJzLyp9EtcBCg1EZWxldGVDbHVzdGVyEjcuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkRlbGV0ZUNsdXN0ZXJSZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiJuykEqChVnb29nbGUucHJvdG9idWYuRW1wdHkSEU9wZXJhdGlvbk1ldGFkYXRh2kEEbmFtZYLT5JMCNCoyL3YxYWxwaGExL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0SywEKC0xpc3RTdHJlYW1zEjUuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkxpc3RTdHJlYW1zUmVxdWVzdBo2Lmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5MaXN0U3RyZWFtc1Jlc3BvbnNlIk3aQQZwYXJlbnSC0+STAj4SPC92MWFscGhhMS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0vc3RyZWFtcxK4AQoJR2V0U3RyZWFtEjMuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLkdldFN0cmVhbVJlcXVlc3QaKS5nb29nbGUucGFydG5lci5haXN0cmVhbXMudjFhbHBoYTEuU3RyZWFtIkvaQQRuYW1lgtPkkwI+EjwvdjFhbHBoYTEve25hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9jbHVzdGVycy8qL3N0cmVhbXMvKn0S7AEKDENyZWF0ZVN0cmVhbRI2Lmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5DcmVhdGVTdHJlYW1SZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiKEAcpBGwoGU3RyZWFtEhFPcGVyYXRpb25NZXRhZGF0YdpBF3BhcmVudCxzdHJlYW0sc3RyZWFtX2lkgtPkkwJGOgZzdHJlYW0iPC92MWFscGhhMS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0vc3RyZWFtcxLuAQoMVXBkYXRlU3RyZWFtEjYuZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExLlVwZGF0ZVN0cmVhbVJlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIoYBykEbCgZTdHJlYW0SEU9wZXJhdGlvbk1ldGFkYXRh2kESc3RyZWFtLHVwZGF0ZV9tYXNrgtPkkwJNOgZzdHJlYW0yQy92MWFscGhhMS97c3RyZWFtLm5hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9jbHVzdGVycy8qL3N0cmVhbXMvKn0S3wEKDERlbGV0ZVN0cmVhbRI2Lmdvb2dsZS5wYXJ0bmVyLmFpc3RyZWFtcy52MWFscGhhMS5EZWxldGVTdHJlYW1SZXF1ZXN0Gh0uZ29vZ2xlLmxvbmdydW5uaW5nLk9wZXJhdGlvbiJ4ykEqChVnb29nbGUucHJvdG9idWYuRW1wdHkSEU9wZXJhdGlvbk1ldGFkYXRh2kEEbmFtZYLT5JMCPio8L3YxYWxwaGExL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKi9zdHJlYW1zLyp9GkzKQRhhaXN0cmVhbXMuZ29vZ2xlYXBpcy5jb23SQS5odHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtQrIBCiVjb20uZ29vZ2xlLnBhcnRuZXIuYWlzdHJlYW1zLnYxYWxwaGExQg5BSVN0cmVhbXNQcm90b1ABWkpnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3BhcnRuZXIvYWlzdHJlYW1zL3YxYWxwaGExO2Fpc3RyZWFtc/gBAcoCJ0dvb2dsZVxDbG91ZFxQYXJ0bmVyXEFpc3RyZWFtc1xWMWFscGhhMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_longrunning_operations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Cluster resource.
 *
 * @generated from message google.partner.aistreams.v1alpha1.Cluster
 */
export type Cluster = Message<"google.partner.aistreams.v1alpha1.Cluster"> & {
  /**
   * The name of the cluster. The format of cluster is:
   * projects/<projectid>/locations/<locationid>/clusters/<clusterid>.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The time at which this cluster was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time at which this cluster was updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;

  /**
   * Labels with user-defined metadata.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Output only. The certificate for creating the secure connection between the
   * client and the AI Streams data plane.
   *
   * @generated from field: string certificate = 5;
   */
  certificate: string;

  /**
   * Output only. The endpoint of the data plane cluster.
   *
   * @generated from field: string service_endpoint = 6;
   */
  serviceEndpoint: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 0);

/**
 * Request message for 'ListClusters'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.ListClustersRequest
 */
export type ListClustersRequest = Message<"google.partner.aistreams.v1alpha1.ListClustersRequest"> & {
  /**
   * Required. The parent that owns the collection of Clusters.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Maximum number of Clusters to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Page token received from a previous `ListClusters` call. Provide this to
   * retrieve the subsequent page. When paginating, all other parameters
   * provided to `ListClusters` must match the call that provided the page
   * token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter request.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Order by fields for the result.
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 1);

/**
 * Response message from 'ListClusters'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.ListClustersResponse
 */
export type ListClustersResponse = Message<"google.partner.aistreams.v1alpha1.ListClustersResponse"> & {
  /**
   * List of clusters.
   *
   * @generated from field: repeated google.partner.aistreams.v1alpha1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Locations that could not be reached.
   *
   * @generated from field: repeated string unreachable = 3;
   */
  unreachable: string[];
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 2);

/**
 * Request message for 'GetCluster'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.GetClusterRequest
 */
export type GetClusterRequest = Message<"google.partner.aistreams.v1alpha1.GetClusterRequest"> & {
  /**
   * Required. The name of the Cluster resource to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 3);

/**
 * Request message for 'CreateCluster'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"google.partner.aistreams.v1alpha1.CreateClusterRequest"> & {
  /**
   * Required. The parent that owns the collection of Clusters.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The cluster identifier.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Required. The cluster resource to create.
   *
   * @generated from field: google.partner.aistreams.v1alpha1.Cluster cluster = 3;
   */
  cluster?: Cluster;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 4);

/**
 * Request message for 'UpdateCluster'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"google.partner.aistreams.v1alpha1.UpdateClusterRequest"> & {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Cluster resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 1;
   */
  updateMask?: FieldMask;

  /**
   * Required. The Cluster resource to update.
   *
   * @generated from field: google.partner.aistreams.v1alpha1.Cluster cluster = 2;
   */
  cluster?: Cluster;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 5);

/**
 * Request message for 'DeleteCluster'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"google.partner.aistreams.v1alpha1.DeleteClusterRequest"> & {
  /**
   * Required. The name of cluster to delete.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 6);

/**
 * Stream resource.
 *
 * @generated from message google.partner.aistreams.v1alpha1.Stream
 */
export type Stream = Message<"google.partner.aistreams.v1alpha1.Stream"> & {
  /**
   * The name of the stream. The format for the full name is:
   * projects/<projectid>/location/<locationid>/clusters/<clusterid>/streams/<streamid>.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The time at which this Stream was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time at which this Stream was updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;

  /**
   * The labels of the stream.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.Stream.
 * Use `create(StreamSchema)` to create a new message.
 */
export const StreamSchema: GenMessage<Stream> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 7);

/**
 * Request message for 'ListStreams'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.ListStreamsRequest
 */
export type ListStreamsRequest = Message<"google.partner.aistreams.v1alpha1.ListStreamsRequest"> & {
  /**
   * Required. The parent that owns the collection of the Streams.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Maximum number of Streams to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Page token received from a previous `ListStreams` call. Provide this to
   * retrieve the subsequent page. When paginating, all other parameters
   * provided to `ListClusters` must match the call that provided the page
   * token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter request.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Order by fields for the result.
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.ListStreamsRequest.
 * Use `create(ListStreamsRequestSchema)` to create a new message.
 */
export const ListStreamsRequestSchema: GenMessage<ListStreamsRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 8);

/**
 * Response message from 'ListStreams'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.ListStreamsResponse
 */
export type ListStreamsResponse = Message<"google.partner.aistreams.v1alpha1.ListStreamsResponse"> & {
  /**
   * List of the streams.
   *
   * @generated from field: repeated google.partner.aistreams.v1alpha1.Stream streams = 1;
   */
  streams: Stream[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Locations that could not be reached.
   *
   * @generated from field: repeated string unreachable = 3;
   */
  unreachable: string[];
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.ListStreamsResponse.
 * Use `create(ListStreamsResponseSchema)` to create a new message.
 */
export const ListStreamsResponseSchema: GenMessage<ListStreamsResponse> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 9);

/**
 * Request message for 'GetStream'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.GetStreamRequest
 */
export type GetStreamRequest = Message<"google.partner.aistreams.v1alpha1.GetStreamRequest"> & {
  /**
   * Required. The name of the stream.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.GetStreamRequest.
 * Use `create(GetStreamRequestSchema)` to create a new message.
 */
export const GetStreamRequestSchema: GenMessage<GetStreamRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 10);

/**
 * Request message for 'CreateStream'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.CreateStreamRequest
 */
export type CreateStreamRequest = Message<"google.partner.aistreams.v1alpha1.CreateStreamRequest"> & {
  /**
   * Required. The parent that owns the collection of streams.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The stream identifier.
   *
   * @generated from field: string stream_id = 2;
   */
  streamId: string;

  /**
   * Required. The stream to create.
   *
   * @generated from field: google.partner.aistreams.v1alpha1.Stream stream = 3;
   */
  stream?: Stream;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.CreateStreamRequest.
 * Use `create(CreateStreamRequestSchema)` to create a new message.
 */
export const CreateStreamRequestSchema: GenMessage<CreateStreamRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 11);

/**
 * Request message for 'UpdateStream'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.UpdateStreamRequest
 */
export type UpdateStreamRequest = Message<"google.partner.aistreams.v1alpha1.UpdateStreamRequest"> & {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Stream resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 1;
   */
  updateMask?: FieldMask;

  /**
   * Required. The stream resource to update.
   *
   * @generated from field: google.partner.aistreams.v1alpha1.Stream stream = 2;
   */
  stream?: Stream;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.UpdateStreamRequest.
 * Use `create(UpdateStreamRequestSchema)` to create a new message.
 */
export const UpdateStreamRequestSchema: GenMessage<UpdateStreamRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 12);

/**
 * Request message for 'DeleteStream'.
 *
 * @generated from message google.partner.aistreams.v1alpha1.DeleteStreamRequest
 */
export type DeleteStreamRequest = Message<"google.partner.aistreams.v1alpha1.DeleteStreamRequest"> & {
  /**
   * Required. The name of the stream.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.DeleteStreamRequest.
 * Use `create(DeleteStreamRequestSchema)` to create a new message.
 */
export const DeleteStreamRequestSchema: GenMessage<DeleteStreamRequest> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 13);

/**
 * Represents the metadata of the long-running operation.
 *
 * @generated from message google.partner.aistreams.v1alpha1.OperationMetadata
 */
export type OperationMetadata = Message<"google.partner.aistreams.v1alpha1.OperationMetadata"> & {
  /**
   * Output only. The time the operation was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 1;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time the operation finished running.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Output only. Server-defined resource path for the target of the operation.
   *
   * @generated from field: string target = 3;
   */
  target: string;

  /**
   * Output only. Name of the verb executed by the operation.
   *
   * @generated from field: string verb = 4;
   */
  verb: string;

  /**
   * Output only. Human-readable status of the operation, if any.
   *
   * @generated from field: string status_message = 5;
   */
  statusMessage: string;

  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   *
   * @generated from field: bool requested_cancellation = 6;
   */
  requestedCancellation: boolean;

  /**
   * Output only. API version used to start the operation.
   *
   * @generated from field: string api_version = 7;
   */
  apiVersion: string;
};

/**
 * Describes the message google.partner.aistreams.v1alpha1.OperationMetadata.
 * Use `create(OperationMetadataSchema)` to create a new message.
 */
export const OperationMetadataSchema: GenMessage<OperationMetadata> = /*@__PURE__*/
  messageDesc(file_google_partner_aistreams_v1alpha1_aistreams, 14);

/**
 * AIStreams service.
 *
 * @generated from service google.partner.aistreams.v1alpha1.AIStreams
 */
export const AIStreams: GenService<{
  /**
   * Lists Clusters in a given project and location.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * Gets details of a single Cluster.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof ClusterSchema;
  },
  /**
   * Creates a new Cluster in a given project and location.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Updates the parameters of a single Cluster.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Deletes a single Cluster.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Lists Streams in a given project, location and cluster.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.ListStreams
   */
  listStreams: {
    methodKind: "unary";
    input: typeof ListStreamsRequestSchema;
    output: typeof ListStreamsResponseSchema;
  },
  /**
   * Gets details of a single Stream.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.GetStream
   */
  getStream: {
    methodKind: "unary";
    input: typeof GetStreamRequestSchema;
    output: typeof StreamSchema;
  },
  /**
   * Creates a new Stream in a given project and location.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.CreateStream
   */
  createStream: {
    methodKind: "unary";
    input: typeof CreateStreamRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Updates the parameters of a single Stream.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.UpdateStream
   */
  updateStream: {
    methodKind: "unary";
    input: typeof UpdateStreamRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Deletes a single Stream.
   *
   * @generated from rpc google.partner.aistreams.v1alpha1.AIStreams.DeleteStream
   */
  deleteStream: {
    methodKind: "unary";
    input: typeof DeleteStreamRequestSchema;
    output: typeof OperationSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_partner_aistreams_v1alpha1_aistreams, 0);

