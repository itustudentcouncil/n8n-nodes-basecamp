// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/privacy/dlp/v2/storage.proto (package google.privacy.dlp.v2, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/privacy/dlp/v2/storage.proto.
 */
export const file_google_privacy_dlp_v2_storage: GenFile = /*@__PURE__*/
  fileDesc("CiNnb29nbGUvcHJpdmFjeS9kbHAvdjIvc3RvcmFnZS5wcm90bxIVZ29vZ2xlLnByaXZhY3kuZGxwLnYyIm0KCEluZm9UeXBlEgwKBG5hbWUYASABKAkSDwoHdmVyc2lvbhgCIAEoCRJCChFzZW5zaXRpdml0eV9zY29yZRgDIAEoCzInLmdvb2dsZS5wcml2YWN5LmRscC52Mi5TZW5zaXRpdml0eVNjb3JlIvsBChBTZW5zaXRpdml0eVNjb3JlEkwKBXNjb3JlGAEgASgOMj0uZ29vZ2xlLnByaXZhY3kuZGxwLnYyLlNlbnNpdGl2aXR5U2NvcmUuU2Vuc2l0aXZpdHlTY29yZUxldmVsIpgBChVTZW5zaXRpdml0eVNjb3JlTGV2ZWwSIQodU0VOU0lUSVZJVFlfU0NPUkVfVU5TUEVDSUZJRUQQABITCg9TRU5TSVRJVklUWV9MT1cQChIXChNTRU5TSVRJVklUWV9VTktOT1dOEAwSGAoUU0VOU0lUSVZJVFlfTU9ERVJBVEUQFBIUChBTRU5TSVRJVklUWV9ISUdIEB4iSwoKU3RvcmVkVHlwZRIMCgRuYW1lGAEgASgJEi8KC2NyZWF0ZV90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCKMDAoOQ3VzdG9tSW5mb1R5cGUSMgoJaW5mb190eXBlGAEgASgLMh8uZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkluZm9UeXBlEjUKCmxpa2VsaWhvb2QYBiABKA4yIS5nb29nbGUucHJpdmFjeS5kbHAudjIuTGlrZWxpaG9vZBJGCgpkaWN0aW9uYXJ5GAIgASgLMjAuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkN1c3RvbUluZm9UeXBlLkRpY3Rpb25hcnlIABI8CgVyZWdleBgDIAEoCzIrLmdvb2dsZS5wcml2YWN5LmRscC52Mi5DdXN0b21JbmZvVHlwZS5SZWdleEgAEk0KDnN1cnJvZ2F0ZV90eXBlGAQgASgLMjMuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkN1c3RvbUluZm9UeXBlLlN1cnJvZ2F0ZVR5cGVIABI4CgtzdG9yZWRfdHlwZRgFIAEoCzIhLmdvb2dsZS5wcml2YWN5LmRscC52Mi5TdG9yZWRUeXBlSAASTAoPZGV0ZWN0aW9uX3J1bGVzGAcgAygLMjMuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkN1c3RvbUluZm9UeXBlLkRldGVjdGlvblJ1bGUSSwoOZXhjbHVzaW9uX3R5cGUYCCABKA4yMy5nb29nbGUucHJpdmFjeS5kbHAudjIuQ3VzdG9tSW5mb1R5cGUuRXhjbHVzaW9uVHlwZRJCChFzZW5zaXRpdml0eV9zY29yZRgJIAEoCzInLmdvb2dsZS5wcml2YWN5LmRscC52Mi5TZW5zaXRpdml0eVNjb3JlGsgBCgpEaWN0aW9uYXJ5Ek4KCXdvcmRfbGlzdBgBIAEoCzI5Lmdvb2dsZS5wcml2YWN5LmRscC52Mi5DdXN0b21JbmZvVHlwZS5EaWN0aW9uYXJ5LldvcmRMaXN0SAASRQoSY2xvdWRfc3RvcmFnZV9wYXRoGAMgASgLMicuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkNsb3VkU3RvcmFnZVBhdGhIABoZCghXb3JkTGlzdBINCgV3b3JkcxgBIAMoCUIICgZzb3VyY2UaLwoFUmVnZXgSDwoHcGF0dGVybhgBIAEoCRIVCg1ncm91cF9pbmRleGVzGAIgAygFGg8KDVN1cnJvZ2F0ZVR5cGUavgQKDURldGVjdGlvblJ1bGUSVwoMaG90d29yZF9ydWxlGAEgASgLMj8uZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkN1c3RvbUluZm9UeXBlLkRldGVjdGlvblJ1bGUuSG90d29yZFJ1bGVIABo4CglQcm94aW1pdHkSFQoNd2luZG93X2JlZm9yZRgBIAEoBRIUCgx3aW5kb3dfYWZ0ZXIYAiABKAUaggEKFExpa2VsaWhvb2RBZGp1c3RtZW50Ej0KEGZpeGVkX2xpa2VsaWhvb2QYASABKA4yIS5nb29nbGUucHJpdmFjeS5kbHAudjIuTGlrZWxpaG9vZEgAEh0KE3JlbGF0aXZlX2xpa2VsaWhvb2QYAiABKAVIAEIMCgphZGp1c3RtZW50GowCCgtIb3R3b3JkUnVsZRJCCg1ob3R3b3JkX3JlZ2V4GAEgASgLMisuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkN1c3RvbUluZm9UeXBlLlJlZ2V4ElAKCXByb3hpbWl0eRgCIAEoCzI9Lmdvb2dsZS5wcml2YWN5LmRscC52Mi5DdXN0b21JbmZvVHlwZS5EZXRlY3Rpb25SdWxlLlByb3hpbWl0eRJnChVsaWtlbGlob29kX2FkanVzdG1lbnQYAyABKAsySC5nb29nbGUucHJpdmFjeS5kbHAudjIuQ3VzdG9tSW5mb1R5cGUuRGV0ZWN0aW9uUnVsZS5MaWtlbGlob29kQWRqdXN0bWVudEIGCgR0eXBlIksKDUV4Y2x1c2lvblR5cGUSHgoaRVhDTFVTSU9OX1RZUEVfVU5TUEVDSUZJRUQQABIaChZFWENMVVNJT05fVFlQRV9FWENMVURFEAFCBgoEdHlwZSIXCgdGaWVsZElkEgwKBG5hbWUYASABKAkiNwoLUGFydGl0aW9uSWQSEgoKcHJvamVjdF9pZBgCIAEoCRIUCgxuYW1lc3BhY2VfaWQYBCABKAkiHgoOS2luZEV4cHJlc3Npb24SDAoEbmFtZRgBIAEoCSKBAQoQRGF0YXN0b3JlT3B0aW9ucxI4CgxwYXJ0aXRpb25faWQYASABKAsyIi5nb29nbGUucHJpdmFjeS5kbHAudjIuUGFydGl0aW9uSWQSMwoEa2luZBgCIAEoCzIlLmdvb2dsZS5wcml2YWN5LmRscC52Mi5LaW5kRXhwcmVzc2lvbiJdChhDbG91ZFN0b3JhZ2VSZWdleEZpbGVTZXQSEwoLYnVja2V0X25hbWUYASABKAkSFQoNaW5jbHVkZV9yZWdleBgCIAMoCRIVCg1leGNsdWRlX3JlZ2V4GAMgAygJIuwDChNDbG91ZFN0b3JhZ2VPcHRpb25zEkQKCGZpbGVfc2V0GAEgASgLMjIuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkNsb3VkU3RvcmFnZU9wdGlvbnMuRmlsZVNldBIcChRieXRlc19saW1pdF9wZXJfZmlsZRgEIAEoAxIkChxieXRlc19saW1pdF9wZXJfZmlsZV9wZXJjZW50GAggASgFEjMKCmZpbGVfdHlwZXMYBSADKA4yHy5nb29nbGUucHJpdmFjeS5kbHAudjIuRmlsZVR5cGUSTgoNc2FtcGxlX21ldGhvZBgGIAEoDjI3Lmdvb2dsZS5wcml2YWN5LmRscC52Mi5DbG91ZFN0b3JhZ2VPcHRpb25zLlNhbXBsZU1ldGhvZBIbChNmaWxlc19saW1pdF9wZXJjZW50GAcgASgFGl8KB0ZpbGVTZXQSCwoDdXJsGAEgASgJEkcKDnJlZ2V4X2ZpbGVfc2V0GAIgASgLMi8uZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkNsb3VkU3RvcmFnZVJlZ2V4RmlsZVNldCJICgxTYW1wbGVNZXRob2QSHQoZU0FNUExFX01FVEhPRF9VTlNQRUNJRklFRBAAEgcKA1RPUBABEhAKDFJBTkRPTV9TVEFSVBACIiIKE0Nsb3VkU3RvcmFnZUZpbGVTZXQSCwoDdXJsGAEgASgJIiAKEENsb3VkU3RvcmFnZVBhdGgSDAoEcGF0aBgBIAEoCSLEAwoPQmlnUXVlcnlPcHRpb25zEj0KD3RhYmxlX3JlZmVyZW5jZRgBIAEoCzIkLmdvb2dsZS5wcml2YWN5LmRscC52Mi5CaWdRdWVyeVRhYmxlEjoKEmlkZW50aWZ5aW5nX2ZpZWxkcxgCIAMoCzIeLmdvb2dsZS5wcml2YWN5LmRscC52Mi5GaWVsZElkEhIKCnJvd3NfbGltaXQYAyABKAMSGgoScm93c19saW1pdF9wZXJjZW50GAYgASgFEkoKDXNhbXBsZV9tZXRob2QYBCABKA4yMy5nb29nbGUucHJpdmFjeS5kbHAudjIuQmlnUXVlcnlPcHRpb25zLlNhbXBsZU1ldGhvZBI3Cg9leGNsdWRlZF9maWVsZHMYBSADKAsyHi5nb29nbGUucHJpdmFjeS5kbHAudjIuRmllbGRJZBI3Cg9pbmNsdWRlZF9maWVsZHMYByADKAsyHi5nb29nbGUucHJpdmFjeS5kbHAudjIuRmllbGRJZCJICgxTYW1wbGVNZXRob2QSHQoZU0FNUExFX01FVEhPRF9VTlNQRUNJRklFRBAAEgcKA1RPUBABEhAKDFJBTkRPTV9TVEFSVBACItoECg1TdG9yYWdlQ29uZmlnEkQKEWRhdGFzdG9yZV9vcHRpb25zGAIgASgLMicuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkRhdGFzdG9yZU9wdGlvbnNIABJLChVjbG91ZF9zdG9yYWdlX29wdGlvbnMYAyABKAsyKi5nb29nbGUucHJpdmFjeS5kbHAudjIuQ2xvdWRTdG9yYWdlT3B0aW9uc0gAEkMKEWJpZ19xdWVyeV9vcHRpb25zGAQgASgLMiYuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkJpZ1F1ZXJ5T3B0aW9uc0gAEj4KDmh5YnJpZF9vcHRpb25zGAkgASgLMiQuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkh5YnJpZE9wdGlvbnNIABJMCg90aW1lc3Bhbl9jb25maWcYBiABKAsyMy5nb29nbGUucHJpdmFjeS5kbHAudjIuU3RvcmFnZUNvbmZpZy5UaW1lc3BhbkNvbmZpZxraAQoOVGltZXNwYW5Db25maWcSLgoKc3RhcnRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLAoIZW5kX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjcKD3RpbWVzdGFtcF9maWVsZBgDIAEoCzIeLmdvb2dsZS5wcml2YWN5LmRscC52Mi5GaWVsZElkEjEKKWVuYWJsZV9hdXRvX3BvcHVsYXRpb25fb2ZfdGltZXNwYW5fY29uZmlnGAQgASgIQgYKBHR5cGUi9gEKDUh5YnJpZE9wdGlvbnMSEwoLZGVzY3JpcHRpb24YASABKAkSIwobcmVxdWlyZWRfZmluZGluZ19sYWJlbF9rZXlzGAIgAygJEkAKBmxhYmVscxgDIAMoCzIwLmdvb2dsZS5wcml2YWN5LmRscC52Mi5IeWJyaWRPcHRpb25zLkxhYmVsc0VudHJ5EjoKDXRhYmxlX29wdGlvbnMYBCABKAsyIy5nb29nbGUucHJpdmFjeS5kbHAudjIuVGFibGVPcHRpb25zGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiYAoLQmlnUXVlcnlLZXkSPQoPdGFibGVfcmVmZXJlbmNlGAEgASgLMiQuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkJpZ1F1ZXJ5VGFibGUSEgoKcm93X251bWJlchgCIAEoAyI+CgxEYXRhc3RvcmVLZXkSLgoKZW50aXR5X2tleRgBIAEoCzIaLmdvb2dsZS5wcml2YWN5LmRscC52Mi5LZXkiuwEKA0tleRI4CgxwYXJ0aXRpb25faWQYASABKAsyIi5nb29nbGUucHJpdmFjeS5kbHAudjIuUGFydGl0aW9uSWQSNAoEcGF0aBgCIAMoCzImLmdvb2dsZS5wcml2YWN5LmRscC52Mi5LZXkuUGF0aEVsZW1lbnQaRAoLUGF0aEVsZW1lbnQSDAoEa2luZBgBIAEoCRIMCgJpZBgCIAEoA0gAEg4KBG5hbWUYAyABKAlIAEIJCgdpZF90eXBlIqEBCglSZWNvcmRLZXkSPAoNZGF0YXN0b3JlX2tleRgCIAEoCzIjLmdvb2dsZS5wcml2YWN5LmRscC52Mi5EYXRhc3RvcmVLZXlIABI7Cg1iaWdfcXVlcnlfa2V5GAMgASgLMiIuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkJpZ1F1ZXJ5S2V5SAASEQoJaWRfdmFsdWVzGAUgAygJQgYKBHR5cGUiSQoNQmlnUXVlcnlUYWJsZRISCgpwcm9qZWN0X2lkGAEgASgJEhIKCmRhdGFzZXRfaWQYAiABKAkSEAoIdGFibGVfaWQYAyABKAkiNgoOVGFibGVSZWZlcmVuY2USEgoKZGF0YXNldF9pZBgBIAEoCRIQCgh0YWJsZV9pZBgCIAEoCSJzCg1CaWdRdWVyeUZpZWxkEjMKBXRhYmxlGAEgASgLMiQuZ29vZ2xlLnByaXZhY3kuZGxwLnYyLkJpZ1F1ZXJ5VGFibGUSLQoFZmllbGQYAiABKAsyHi5nb29nbGUucHJpdmFjeS5kbHAudjIuRmllbGRJZCI5CghFbnRpdHlJZBItCgVmaWVsZBgBIAEoCzIeLmdvb2dsZS5wcml2YWN5LmRscC52Mi5GaWVsZElkIkoKDFRhYmxlT3B0aW9ucxI6ChJpZGVudGlmeWluZ19maWVsZHMYASADKAsyHi5nb29nbGUucHJpdmFjeS5kbHAudjIuRmllbGRJZCp0CgpMaWtlbGlob29kEhoKFkxJS0VMSUhPT0RfVU5TUEVDSUZJRUQQABIRCg1WRVJZX1VOTElLRUxZEAESDAoIVU5MSUtFTFkQAhIMCghQT1NTSUJMRRADEgoKBkxJS0VMWRAEEg8KC1ZFUllfTElLRUxZEAUqmgEKCEZpbGVUeXBlEhkKFUZJTEVfVFlQRV9VTlNQRUNJRklFRBAAEg8KC0JJTkFSWV9GSUxFEAESDQoJVEVYVF9GSUxFEAISCQoFSU1BR0UQAxIICgRXT1JEEAUSBwoDUERGEAYSCAoEQVZSTxAHEgcKA0NTVhAIEgcKA1RTVhAJEg4KClBPV0VSUE9JTlQQCxIJCgVFWENFTBAMQpkBChljb20uZ29vZ2xlLnByaXZhY3kuZGxwLnYyQgpEbHBTdG9yYWdlUAFaKWNsb3VkLmdvb2dsZS5jb20vZ28vZGxwL2FwaXYyL2RscHBiO2RscHBiqgITR29vZ2xlLkNsb3VkLkRscC5WMsoCE0dvb2dsZVxDbG91ZFxEbHBcVjLqAhZHb29nbGU6OkNsb3VkOjpEbHA6OlYyYgZwcm90bzM", [file_google_api_resource, file_google_protobuf_timestamp]);

/**
 * Type of information detected by the API.
 *
 * @generated from message google.privacy.dlp.v2.InfoType
 */
export type InfoType = Message<"google.privacy.dlp.v2.InfoType"> & {
  /**
   * Name of the information type. Either a name of your choosing when
   * creating a CustomInfoType, or one of the names listed
   * at
   * https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference
   * when specifying a built-in type.  When sending Cloud DLP results to Data
   * Catalog, infoType names should conform to the pattern
   * `[A-Za-z0-9$_-]{1,64}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional version name for this InfoType.
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * Optional custom sensitivity for this InfoType.
   * This only applies to data profiling.
   *
   * @generated from field: google.privacy.dlp.v2.SensitivityScore sensitivity_score = 3;
   */
  sensitivityScore?: SensitivityScore;
};

/**
 * Describes the message google.privacy.dlp.v2.InfoType.
 * Use `create(InfoTypeSchema)` to create a new message.
 */
export const InfoTypeSchema: GenMessage<InfoType> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 0);

/**
 * Score is calculated from of all elements in the data profile.
 * A higher level means the data is more sensitive.
 *
 * @generated from message google.privacy.dlp.v2.SensitivityScore
 */
export type SensitivityScore = Message<"google.privacy.dlp.v2.SensitivityScore"> & {
  /**
   * The sensitivity score applied to the resource.
   *
   * @generated from field: google.privacy.dlp.v2.SensitivityScore.SensitivityScoreLevel score = 1;
   */
  score: SensitivityScore_SensitivityScoreLevel;
};

/**
 * Describes the message google.privacy.dlp.v2.SensitivityScore.
 * Use `create(SensitivityScoreSchema)` to create a new message.
 */
export const SensitivityScoreSchema: GenMessage<SensitivityScore> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 1);

/**
 * Various sensitivity score levels for resources.
 *
 * @generated from enum google.privacy.dlp.v2.SensitivityScore.SensitivityScoreLevel
 */
export enum SensitivityScore_SensitivityScoreLevel {
  /**
   * Unused.
   *
   * @generated from enum value: SENSITIVITY_SCORE_UNSPECIFIED = 0;
   */
  SENSITIVITY_SCORE_UNSPECIFIED = 0,

  /**
   * No sensitive information detected. The resource isn't publicly
   * accessible.
   *
   * @generated from enum value: SENSITIVITY_LOW = 10;
   */
  SENSITIVITY_LOW = 10,

  /**
   * Unable to determine sensitivity.
   *
   * @generated from enum value: SENSITIVITY_UNKNOWN = 12;
   */
  SENSITIVITY_UNKNOWN = 12,

  /**
   * Medium risk. Contains personally identifiable information (PII),
   * potentially sensitive data, or fields with free-text data that are at a
   * higher risk of having intermittent sensitive data. Consider limiting
   * access.
   *
   * @generated from enum value: SENSITIVITY_MODERATE = 20;
   */
  SENSITIVITY_MODERATE = 20,

  /**
   * High risk. Sensitive personally identifiable information (SPII) can be
   * present. Exfiltration of data can lead to user data loss.
   * Re-identification of users might be possible. Consider limiting usage and
   * or removing SPII.
   *
   * @generated from enum value: SENSITIVITY_HIGH = 30;
   */
  SENSITIVITY_HIGH = 30,
}

/**
 * Describes the enum google.privacy.dlp.v2.SensitivityScore.SensitivityScoreLevel.
 */
export const SensitivityScore_SensitivityScoreLevelSchema: GenEnum<SensitivityScore_SensitivityScoreLevel> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 1, 0);

/**
 * A reference to a StoredInfoType to use with scanning.
 *
 * @generated from message google.privacy.dlp.v2.StoredType
 */
export type StoredType = Message<"google.privacy.dlp.v2.StoredType"> & {
  /**
   * Resource name of the requested `StoredInfoType`, for example
   * `organizations/433245324/storedInfoTypes/432452342` or
   * `projects/project-id/storedInfoTypes/432452342`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Timestamp indicating when the version of the `StoredInfoType` used for
   * inspection was created. Output-only field, populated by the system.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;
};

/**
 * Describes the message google.privacy.dlp.v2.StoredType.
 * Use `create(StoredTypeSchema)` to create a new message.
 */
export const StoredTypeSchema: GenMessage<StoredType> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 2);

/**
 * Custom information type provided by the user. Used to find domain-specific
 * sensitive information configurable to the data in question.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType
 */
export type CustomInfoType = Message<"google.privacy.dlp.v2.CustomInfoType"> & {
  /**
   * CustomInfoType can either be a new infoType, or an extension of built-in
   * infoType, when the name matches one of existing infoTypes and that infoType
   * is specified in `InspectContent.info_types` field. Specifying the latter
   * adds findings to the one detected by the system. If built-in info type is
   * not specified in `InspectContent.info_types` list then the name is treated
   * as a custom info type.
   *
   * @generated from field: google.privacy.dlp.v2.InfoType info_type = 1;
   */
  infoType?: InfoType;

  /**
   * Likelihood to return for this CustomInfoType. This base value can be
   * altered by a detection rule if the finding meets the criteria specified by
   * the rule. Defaults to `VERY_LIKELY` if not specified.
   *
   * @generated from field: google.privacy.dlp.v2.Likelihood likelihood = 6;
   */
  likelihood: Likelihood;

  /**
   * Type of custom detector.
   *
   * @generated from oneof google.privacy.dlp.v2.CustomInfoType.type
   */
  type: {
    /**
     * A list of phrases to detect as a CustomInfoType.
     *
     * @generated from field: google.privacy.dlp.v2.CustomInfoType.Dictionary dictionary = 2;
     */
    value: CustomInfoType_Dictionary;
    case: "dictionary";
  } | {
    /**
     * Regular expression based CustomInfoType.
     *
     * @generated from field: google.privacy.dlp.v2.CustomInfoType.Regex regex = 3;
     */
    value: CustomInfoType_Regex;
    case: "regex";
  } | {
    /**
     * Message for detecting output from deidentification transformations that
     * support reversing.
     *
     * @generated from field: google.privacy.dlp.v2.CustomInfoType.SurrogateType surrogate_type = 4;
     */
    value: CustomInfoType_SurrogateType;
    case: "surrogateType";
  } | {
    /**
     * Load an existing `StoredInfoType` resource for use in
     * `InspectDataSource`. Not currently supported in `InspectContent`.
     *
     * @generated from field: google.privacy.dlp.v2.StoredType stored_type = 5;
     */
    value: StoredType;
    case: "storedType";
  } | { case: undefined; value?: undefined };

  /**
   * Set of detection rules to apply to all findings of this CustomInfoType.
   * Rules are applied in order that they are specified. Not supported for the
   * `surrogate_type` CustomInfoType.
   *
   * @generated from field: repeated google.privacy.dlp.v2.CustomInfoType.DetectionRule detection_rules = 7;
   */
  detectionRules: CustomInfoType_DetectionRule[];

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
   * to be returned. It still can be used for rules matching.
   *
   * @generated from field: google.privacy.dlp.v2.CustomInfoType.ExclusionType exclusion_type = 8;
   */
  exclusionType: CustomInfoType_ExclusionType;

  /**
   * Sensitivity for this CustomInfoType. If this CustomInfoType extends an
   * existing InfoType, the sensitivity here will take precedence over that of
   * the original InfoType. If unset for a CustomInfoType, it will default to
   * HIGH.
   * This only applies to data profiling.
   *
   * @generated from field: google.privacy.dlp.v2.SensitivityScore sensitivity_score = 9;
   */
  sensitivityScore?: SensitivityScore;
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.
 * Use `create(CustomInfoTypeSchema)` to create a new message.
 */
export const CustomInfoTypeSchema: GenMessage<CustomInfoType> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3);

/**
 * Custom information type based on a dictionary of words or phrases. This can
 * be used to match sensitive information specific to the data, such as a list
 * of employee IDs or job titles.
 *
 * Dictionary words are case-insensitive and all characters other than letters
 * and digits in the unicode [Basic Multilingual
 * Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
 * will be replaced with whitespace when scanning for matches, so the
 * dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
 * "Sam, Johnson", and "Sam (Johnson)". Additionally, the characters
 * surrounding any match must be of a different type than the adjacent
 * characters within the word, so letters must be next to non-letters and
 * digits next to non-digits. For example, the dictionary word "jen" will
 * match the first three letters of the text "jen123" but will return no
 * matches for "jennifer".
 *
 * Dictionary words containing a large number of characters that are not
 * letters or digits may result in unexpected findings because such characters
 * are treated as whitespace. The
 * [limits](https://cloud.google.com/sensitive-data-protection/limits) page
 * contains details about the size limits of dictionaries. For dictionaries
 * that do not fit within these constraints, consider using
 * `LargeCustomDictionaryConfig` in the `StoredInfoType` API.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.Dictionary
 */
export type CustomInfoType_Dictionary = Message<"google.privacy.dlp.v2.CustomInfoType.Dictionary"> & {
  /**
   * The potential places the data can be read from.
   *
   * @generated from oneof google.privacy.dlp.v2.CustomInfoType.Dictionary.source
   */
  source: {
    /**
     * List of words or phrases to search for.
     *
     * @generated from field: google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList word_list = 1;
     */
    value: CustomInfoType_Dictionary_WordList;
    case: "wordList";
  } | {
    /**
     * Newline-delimited file of words in Cloud Storage. Only a single file
     * is accepted.
     *
     * @generated from field: google.privacy.dlp.v2.CloudStoragePath cloud_storage_path = 3;
     */
    value: CloudStoragePath;
    case: "cloudStoragePath";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.Dictionary.
 * Use `create(CustomInfoType_DictionarySchema)` to create a new message.
 */
export const CustomInfoType_DictionarySchema: GenMessage<CustomInfoType_Dictionary> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 0);

/**
 * Message defining a list of words or phrases to search for in the data.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList
 */
export type CustomInfoType_Dictionary_WordList = Message<"google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList"> & {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain
   * at least one phrase and every phrase must contain at least 2 characters
   * that are letters or digits. [required]
   *
   * @generated from field: repeated string words = 1;
   */
  words: string[];
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.Dictionary.WordList.
 * Use `create(CustomInfoType_Dictionary_WordListSchema)` to create a new message.
 */
export const CustomInfoType_Dictionary_WordListSchema: GenMessage<CustomInfoType_Dictionary_WordList> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 0, 0);

/**
 * Message defining a custom regular expression.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.Regex
 */
export type CustomInfoType_Regex = Message<"google.privacy.dlp.v2.CustomInfoType.Regex"> & {
  /**
   * Pattern defining the regular expression. Its syntax
   * (https://github.com/google/re2/wiki/Syntax) can be found under the
   * google/re2 repository on GitHub.
   *
   * @generated from field: string pattern = 1;
   */
  pattern: string;

  /**
   * The index of the submatch to extract as findings. When not
   * specified, the entire match is returned. No more than 3 may be included.
   *
   * @generated from field: repeated int32 group_indexes = 2;
   */
  groupIndexes: number[];
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.Regex.
 * Use `create(CustomInfoType_RegexSchema)` to create a new message.
 */
export const CustomInfoType_RegexSchema: GenMessage<CustomInfoType_Regex> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 1);

/**
 * Message for detecting output from deidentification transformations
 * such as
 * [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/sensitive-data-protection/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
 * These types of transformations are
 * those that perform pseudonymization, thereby producing a "surrogate" as
 * output. This should be used in conjunction with a field on the
 * transformation such as `surrogate_info_type`. This CustomInfoType does
 * not support the use of `detection_rules`.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.SurrogateType
 */
export type CustomInfoType_SurrogateType = Message<"google.privacy.dlp.v2.CustomInfoType.SurrogateType"> & {
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.SurrogateType.
 * Use `create(CustomInfoType_SurrogateTypeSchema)` to create a new message.
 */
export const CustomInfoType_SurrogateTypeSchema: GenMessage<CustomInfoType_SurrogateType> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 2);

/**
 * Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
 * `CustomInfoType` to alter behavior under certain circumstances, depending
 * on the specific details of the rule. Not supported for the `surrogate_type`
 * custom infoType.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.DetectionRule
 */
export type CustomInfoType_DetectionRule = Message<"google.privacy.dlp.v2.CustomInfoType.DetectionRule"> & {
  /**
   * Type of hotword rule.
   *
   * @generated from oneof google.privacy.dlp.v2.CustomInfoType.DetectionRule.type
   */
  type: {
    /**
     * Hotword-based detection rule.
     *
     * @generated from field: google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule hotword_rule = 1;
     */
    value: CustomInfoType_DetectionRule_HotwordRule;
    case: "hotwordRule";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.DetectionRule.
 * Use `create(CustomInfoType_DetectionRuleSchema)` to create a new message.
 */
export const CustomInfoType_DetectionRuleSchema: GenMessage<CustomInfoType_DetectionRule> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 3);

/**
 * Message for specifying a window around a finding to apply a detection
 * rule.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity
 */
export type CustomInfoType_DetectionRule_Proximity = Message<"google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity"> & {
  /**
   * Number of characters before the finding to consider. For tabular data,
   * if you want to modify the likelihood of an entire column of findngs,
   * set this to 1. For more information, see
   * [Hotword example: Set the match likelihood of a table column]
   * (https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values).
   *
   * @generated from field: int32 window_before = 1;
   */
  windowBefore: number;

  /**
   * Number of characters after the finding to consider.
   *
   * @generated from field: int32 window_after = 2;
   */
  windowAfter: number;
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity.
 * Use `create(CustomInfoType_DetectionRule_ProximitySchema)` to create a new message.
 */
export const CustomInfoType_DetectionRule_ProximitySchema: GenMessage<CustomInfoType_DetectionRule_Proximity> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 3, 0);

/**
 * Message for specifying an adjustment to the likelihood of a finding as
 * part of a detection rule.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment
 */
export type CustomInfoType_DetectionRule_LikelihoodAdjustment = Message<"google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment"> & {
  /**
   * How the likelihood will be modified.
   *
   * @generated from oneof google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.adjustment
   */
  adjustment: {
    /**
     * Set the likelihood of a finding to a fixed value.
     *
     * @generated from field: google.privacy.dlp.v2.Likelihood fixed_likelihood = 1;
     */
    value: Likelihood;
    case: "fixedLikelihood";
  } | {
    /**
     * Increase or decrease the likelihood by the specified number of
     * levels. For example, if a finding would be `POSSIBLE` without the
     * detection rule and `relative_likelihood` is 1, then it is upgraded to
     * `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
     * Likelihood may never drop below `VERY_UNLIKELY` or exceed
     * `VERY_LIKELY`, so applying an adjustment of 1 followed by an
     * adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
     * a final likelihood of `LIKELY`.
     *
     * @generated from field: int32 relative_likelihood = 2;
     */
    value: number;
    case: "relativeLikelihood";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment.
 * Use `create(CustomInfoType_DetectionRule_LikelihoodAdjustmentSchema)` to create a new message.
 */
export const CustomInfoType_DetectionRule_LikelihoodAdjustmentSchema: GenMessage<CustomInfoType_DetectionRule_LikelihoodAdjustment> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 3, 1);

/**
 * The rule that adjusts the likelihood of findings within a certain
 * proximity of hotwords.
 *
 * @generated from message google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule
 */
export type CustomInfoType_DetectionRule_HotwordRule = Message<"google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule"> & {
  /**
   * Regular expression pattern defining what qualifies as a hotword.
   *
   * @generated from field: google.privacy.dlp.v2.CustomInfoType.Regex hotword_regex = 1;
   */
  hotwordRegex?: CustomInfoType_Regex;

  /**
   * Range of characters within which the entire hotword must reside.
   * The total length of the window cannot exceed 1000 characters.
   * The finding itself will be included in the window, so that hotwords can
   * be used to match substrings of the finding itself. Suppose you
   * want Cloud DLP to promote the likelihood of the phone number
   * regex "\(\d{3}\) \d{3}-\d{4}" if the area code is known to be the
   * area code of a company's office. In this case, use the hotword regex
   * "\(xxx\)", where "xxx" is the area code in question.
   *
   * For tabular data, if you want to modify the likelihood of an entire
   * column of findngs, see
   * [Hotword example: Set the match likelihood of a table column]
   * (https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes-likelihood#match-column-values).
   *
   * @generated from field: google.privacy.dlp.v2.CustomInfoType.DetectionRule.Proximity proximity = 2;
   */
  proximity?: CustomInfoType_DetectionRule_Proximity;

  /**
   * Likelihood adjustment to apply to all matching findings.
   *
   * @generated from field: google.privacy.dlp.v2.CustomInfoType.DetectionRule.LikelihoodAdjustment likelihood_adjustment = 3;
   */
  likelihoodAdjustment?: CustomInfoType_DetectionRule_LikelihoodAdjustment;
};

/**
 * Describes the message google.privacy.dlp.v2.CustomInfoType.DetectionRule.HotwordRule.
 * Use `create(CustomInfoType_DetectionRule_HotwordRuleSchema)` to create a new message.
 */
export const CustomInfoType_DetectionRule_HotwordRuleSchema: GenMessage<CustomInfoType_DetectionRule_HotwordRule> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 3, 3, 2);

/**
 * Type of exclusion rule.
 *
 * @generated from enum google.privacy.dlp.v2.CustomInfoType.ExclusionType
 */
export enum CustomInfoType_ExclusionType {
  /**
   * A finding of this custom info type will not be excluded from results.
   *
   * @generated from enum value: EXCLUSION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A finding of this custom info type will be excluded from final results,
   * but can still affect rule execution.
   *
   * @generated from enum value: EXCLUSION_TYPE_EXCLUDE = 1;
   */
  EXCLUDE = 1,
}

/**
 * Describes the enum google.privacy.dlp.v2.CustomInfoType.ExclusionType.
 */
export const CustomInfoType_ExclusionTypeSchema: GenEnum<CustomInfoType_ExclusionType> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 3, 0);

/**
 * General identifier of a data field in a storage service.
 *
 * @generated from message google.privacy.dlp.v2.FieldId
 */
export type FieldId = Message<"google.privacy.dlp.v2.FieldId"> & {
  /**
   * Name describing the field.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.privacy.dlp.v2.FieldId.
 * Use `create(FieldIdSchema)` to create a new message.
 */
export const FieldIdSchema: GenMessage<FieldId> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 4);

/**
 * Datastore partition ID.
 * A partition ID identifies a grouping of entities. The grouping is always
 * by project and namespace, however the namespace ID may be empty.
 *
 * A partition ID contains several dimensions:
 * project ID and namespace ID.
 *
 * @generated from message google.privacy.dlp.v2.PartitionId
 */
export type PartitionId = Message<"google.privacy.dlp.v2.PartitionId"> & {
  /**
   * The ID of the project to which the entities belong.
   *
   * @generated from field: string project_id = 2;
   */
  projectId: string;

  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @generated from field: string namespace_id = 4;
   */
  namespaceId: string;
};

/**
 * Describes the message google.privacy.dlp.v2.PartitionId.
 * Use `create(PartitionIdSchema)` to create a new message.
 */
export const PartitionIdSchema: GenMessage<PartitionId> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 5);

/**
 * A representation of a Datastore kind.
 *
 * @generated from message google.privacy.dlp.v2.KindExpression
 */
export type KindExpression = Message<"google.privacy.dlp.v2.KindExpression"> & {
  /**
   * The name of the kind.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.privacy.dlp.v2.KindExpression.
 * Use `create(KindExpressionSchema)` to create a new message.
 */
export const KindExpressionSchema: GenMessage<KindExpression> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 6);

/**
 * Options defining a data set within Google Cloud Datastore.
 *
 * @generated from message google.privacy.dlp.v2.DatastoreOptions
 */
export type DatastoreOptions = Message<"google.privacy.dlp.v2.DatastoreOptions"> & {
  /**
   * A partition ID identifies a grouping of entities. The grouping is always
   * by project and namespace, however the namespace ID may be empty.
   *
   * @generated from field: google.privacy.dlp.v2.PartitionId partition_id = 1;
   */
  partitionId?: PartitionId;

  /**
   * The kind to process.
   *
   * @generated from field: google.privacy.dlp.v2.KindExpression kind = 2;
   */
  kind?: KindExpression;
};

/**
 * Describes the message google.privacy.dlp.v2.DatastoreOptions.
 * Use `create(DatastoreOptionsSchema)` to create a new message.
 */
export const DatastoreOptionsSchema: GenMessage<DatastoreOptions> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 7);

/**
 * Message representing a set of files in a Cloud Storage bucket. Regular
 * expressions are used to allow fine-grained control over which files in the
 * bucket to include.
 *
 * Included files are those that match at least one item in `include_regex` and
 * do not match any items in `exclude_regex`. Note that a file that matches
 * items from both lists will _not_ be included. For a match to occur, the
 * entire file path (i.e., everything in the url after the bucket name) must
 * match the regular expression.
 *
 * For example, given the input `{bucket_name: "mybucket", include_regex:
 * ["directory1/.*"], exclude_regex:
 * ["directory1/excluded.*"]}`:
 *
 * * `gs://mybucket/directory1/myfile` will be included
 * * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
 * across `/`)
 * * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
 * full path doesn't match any items in `include_regex`)
 * * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
 * matches an item in `exclude_regex`)
 *
 * If `include_regex` is left empty, it will match all files by default
 * (this is equivalent to setting `include_regex: [".*"]`).
 *
 * Some other common use cases:
 *
 * * `{bucket_name: "mybucket", exclude_regex: [".*\.pdf"]}` will include all
 * files in `mybucket` except for .pdf files
 * * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
 * include all files directly under `gs://mybucket/directory/`, without matching
 * across `/`
 *
 * @generated from message google.privacy.dlp.v2.CloudStorageRegexFileSet
 */
export type CloudStorageRegexFileSet = Message<"google.privacy.dlp.v2.CloudStorageRegexFileSet"> & {
  /**
   * The name of a Cloud Storage bucket. Required.
   *
   * @generated from field: string bucket_name = 1;
   */
  bucketName: string;

  /**
   * A list of regular expressions matching file paths to include. All files in
   * the bucket that match at least one of these regular expressions will be
   * included in the set of files, except for those that also match an item in
   * `exclude_regex`. Leaving this field empty will match all files by default
   * (this is equivalent to including `.*` in the list).
   *
   * Regular expressions use RE2
   * [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
   * under the google/re2 repository on GitHub.
   *
   * @generated from field: repeated string include_regex = 2;
   */
  includeRegex: string[];

  /**
   * A list of regular expressions matching file paths to exclude. All files in
   * the bucket that match at least one of these regular expressions will be
   * excluded from the scan.
   *
   * Regular expressions use RE2
   * [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
   * under the google/re2 repository on GitHub.
   *
   * @generated from field: repeated string exclude_regex = 3;
   */
  excludeRegex: string[];
};

/**
 * Describes the message google.privacy.dlp.v2.CloudStorageRegexFileSet.
 * Use `create(CloudStorageRegexFileSetSchema)` to create a new message.
 */
export const CloudStorageRegexFileSetSchema: GenMessage<CloudStorageRegexFileSet> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 8);

/**
 * Options defining a file or a set of files within a Cloud Storage
 * bucket.
 *
 * @generated from message google.privacy.dlp.v2.CloudStorageOptions
 */
export type CloudStorageOptions = Message<"google.privacy.dlp.v2.CloudStorageOptions"> & {
  /**
   * The set of one or more files to scan.
   *
   * @generated from field: google.privacy.dlp.v2.CloudStorageOptions.FileSet file_set = 1;
   */
  fileSet?: CloudStorageOptions_FileSet;

  /**
   * Max number of bytes to scan from a file. If a scanned file's size is bigger
   * than this value then the rest of the bytes are omitted. Only one of
   * `bytes_limit_per_file` and `bytes_limit_per_file_percent` can be specified.
   * This field can't be set if de-identification is requested. For certain file
   * types, setting this field has no effect. For more information, see [Limits
   * on bytes scanned per
   * file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
   *
   * @generated from field: int64 bytes_limit_per_file = 4;
   */
  bytesLimitPerFile: bigint;

  /**
   * Max percentage of bytes to scan from a file. The rest are omitted. The
   * number of bytes scanned is rounded down. Must be between 0 and 100,
   * inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
   * bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
   * This field can't be set if de-identification is requested. For certain file
   * types, setting this field has no effect. For more information, see [Limits
   * on bytes scanned per
   * file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).
   *
   * @generated from field: int32 bytes_limit_per_file_percent = 8;
   */
  bytesLimitPerFilePercent: number;

  /**
   * List of file type groups to include in the scan.
   * If empty, all files are scanned and available data format processors
   * are applied. In addition, the binary content of the selected files
   * is always scanned as well.
   * Images are scanned only as binary if the specified region
   * does not support image inspection and no file_types were specified.
   * Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
   *
   * @generated from field: repeated google.privacy.dlp.v2.FileType file_types = 5;
   */
  fileTypes: FileType[];

  /**
   * How to sample the data.
   *
   * @generated from field: google.privacy.dlp.v2.CloudStorageOptions.SampleMethod sample_method = 6;
   */
  sampleMethod: CloudStorageOptions_SampleMethod;

  /**
   * Limits the number of files to scan to this percentage of the input FileSet.
   * Number of files scanned is rounded down. Must be between 0 and 100,
   * inclusively. Both 0 and 100 means no limit. Defaults to 0.
   *
   * @generated from field: int32 files_limit_percent = 7;
   */
  filesLimitPercent: number;
};

/**
 * Describes the message google.privacy.dlp.v2.CloudStorageOptions.
 * Use `create(CloudStorageOptionsSchema)` to create a new message.
 */
export const CloudStorageOptionsSchema: GenMessage<CloudStorageOptions> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 9);

/**
 * Set of files to scan.
 *
 * @generated from message google.privacy.dlp.v2.CloudStorageOptions.FileSet
 */
export type CloudStorageOptions_FileSet = Message<"google.privacy.dlp.v2.CloudStorageOptions.FileSet"> & {
  /**
   * The Cloud Storage url of the file(s) to scan, in the format
   * `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
   *
   * If the url ends in a trailing slash, the bucket or directory represented
   * by the url will be scanned non-recursively (content in sub-directories
   * will not be scanned). This means that `gs://mybucket/` is equivalent to
   * `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
   * `gs://mybucket/directory/*`.
   *
   * Exactly one of `url` or `regex_file_set` must be set.
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The regex-filtered set of files to scan. Exactly one of `url` or
   * `regex_file_set` must be set.
   *
   * @generated from field: google.privacy.dlp.v2.CloudStorageRegexFileSet regex_file_set = 2;
   */
  regexFileSet?: CloudStorageRegexFileSet;
};

/**
 * Describes the message google.privacy.dlp.v2.CloudStorageOptions.FileSet.
 * Use `create(CloudStorageOptions_FileSetSchema)` to create a new message.
 */
export const CloudStorageOptions_FileSetSchema: GenMessage<CloudStorageOptions_FileSet> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 9, 0);

/**
 * How to sample bytes if not all bytes are scanned. Meaningful only when used
 * in conjunction with bytes_limit_per_file. If not specified, scanning would
 * start from the top.
 *
 * @generated from enum google.privacy.dlp.v2.CloudStorageOptions.SampleMethod
 */
export enum CloudStorageOptions_SampleMethod {
  /**
   * No sampling.
   *
   * @generated from enum value: SAMPLE_METHOD_UNSPECIFIED = 0;
   */
  SAMPLE_METHOD_UNSPECIFIED = 0,

  /**
   * Scan from the top (default).
   *
   * @generated from enum value: TOP = 1;
   */
  TOP = 1,

  /**
   * For each file larger than bytes_limit_per_file, randomly pick the offset
   * to start scanning. The scanned bytes are contiguous.
   *
   * @generated from enum value: RANDOM_START = 2;
   */
  RANDOM_START = 2,
}

/**
 * Describes the enum google.privacy.dlp.v2.CloudStorageOptions.SampleMethod.
 */
export const CloudStorageOptions_SampleMethodSchema: GenEnum<CloudStorageOptions_SampleMethod> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 9, 0);

/**
 * Message representing a set of files in Cloud Storage.
 *
 * @generated from message google.privacy.dlp.v2.CloudStorageFileSet
 */
export type CloudStorageFileSet = Message<"google.privacy.dlp.v2.CloudStorageFileSet"> & {
  /**
   * The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
   * path is allowed.
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message google.privacy.dlp.v2.CloudStorageFileSet.
 * Use `create(CloudStorageFileSetSchema)` to create a new message.
 */
export const CloudStorageFileSetSchema: GenMessage<CloudStorageFileSet> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 10);

/**
 * Message representing a single file or path in Cloud Storage.
 *
 * @generated from message google.privacy.dlp.v2.CloudStoragePath
 */
export type CloudStoragePath = Message<"google.privacy.dlp.v2.CloudStoragePath"> & {
  /**
   * A URL representing a file or path (no wildcards) in Cloud Storage.
   * Example: `gs://[BUCKET_NAME]/dictionary.txt`
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message google.privacy.dlp.v2.CloudStoragePath.
 * Use `create(CloudStoragePathSchema)` to create a new message.
 */
export const CloudStoragePathSchema: GenMessage<CloudStoragePath> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 11);

/**
 * Options defining BigQuery table and row identifiers.
 *
 * @generated from message google.privacy.dlp.v2.BigQueryOptions
 */
export type BigQueryOptions = Message<"google.privacy.dlp.v2.BigQueryOptions"> & {
  /**
   * Complete BigQuery table reference.
   *
   * @generated from field: google.privacy.dlp.v2.BigQueryTable table_reference = 1;
   */
  tableReference?: BigQueryTable;

  /**
   * Table fields that may uniquely identify a row within the table. When
   * `actions.saveFindings.outputConfig.table` is specified, the values of
   * columns specified here are available in the output table under
   * `location.content_locations.record_location.record_key.id_values`. Nested
   * fields such as `person.birthdate.year` are allowed.
   *
   * @generated from field: repeated google.privacy.dlp.v2.FieldId identifying_fields = 2;
   */
  identifyingFields: FieldId[];

  /**
   * Max number of rows to scan. If the table has more rows than this value, the
   * rest of the rows are omitted. If not set, or if set to 0, all rows will be
   * scanned. Only one of rows_limit and rows_limit_percent can be specified.
   * Cannot be used in conjunction with TimespanConfig.
   *
   * @generated from field: int64 rows_limit = 3;
   */
  rowsLimit: bigint;

  /**
   * Max percentage of rows to scan. The rest are omitted. The number of rows
   * scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
   * 100 means no limit. Defaults to 0. Only one of rows_limit and
   * rows_limit_percent can be specified. Cannot be used in conjunction with
   * TimespanConfig.
   *
   * Caution: A [known
   * issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-sampling)
   * is causing the `rowsLimitPercent` field to behave unexpectedly. We
   * recommend using `rowsLimit` instead.
   *
   * @generated from field: int32 rows_limit_percent = 6;
   */
  rowsLimitPercent: number;

  /**
   * How to sample the data.
   *
   * @generated from field: google.privacy.dlp.v2.BigQueryOptions.SampleMethod sample_method = 4;
   */
  sampleMethod: BigQueryOptions_SampleMethod;

  /**
   * References to fields excluded from scanning. This allows you to skip
   * inspection of entire columns which you know have no findings.
   * When inspecting a table, we recommend that you inspect all columns.
   * Otherwise, findings might be affected because hints from excluded columns
   * will not be used.
   *
   * @generated from field: repeated google.privacy.dlp.v2.FieldId excluded_fields = 5;
   */
  excludedFields: FieldId[];

  /**
   * Limit scanning only to these fields.
   * When inspecting a table, we recommend that you inspect all columns.
   * Otherwise, findings might be affected because hints from excluded columns
   * will not be used.
   *
   * @generated from field: repeated google.privacy.dlp.v2.FieldId included_fields = 7;
   */
  includedFields: FieldId[];
};

/**
 * Describes the message google.privacy.dlp.v2.BigQueryOptions.
 * Use `create(BigQueryOptionsSchema)` to create a new message.
 */
export const BigQueryOptionsSchema: GenMessage<BigQueryOptions> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 12);

/**
 * How to sample rows if not all rows are scanned. Meaningful only when used
 * in conjunction with either rows_limit or rows_limit_percent. If not
 * specified, rows are scanned in the order BigQuery reads them.
 *
 * @generated from enum google.privacy.dlp.v2.BigQueryOptions.SampleMethod
 */
export enum BigQueryOptions_SampleMethod {
  /**
   * No sampling.
   *
   * @generated from enum value: SAMPLE_METHOD_UNSPECIFIED = 0;
   */
  SAMPLE_METHOD_UNSPECIFIED = 0,

  /**
   * Scan groups of rows in the order BigQuery provides (default). Multiple
   * groups of rows may be scanned in parallel, so results may not appear in
   * the same order the rows are read.
   *
   * @generated from enum value: TOP = 1;
   */
  TOP = 1,

  /**
   * Randomly pick groups of rows to scan.
   *
   * @generated from enum value: RANDOM_START = 2;
   */
  RANDOM_START = 2,
}

/**
 * Describes the enum google.privacy.dlp.v2.BigQueryOptions.SampleMethod.
 */
export const BigQueryOptions_SampleMethodSchema: GenEnum<BigQueryOptions_SampleMethod> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 12, 0);

/**
 * Shared message indicating Cloud storage type.
 *
 * @generated from message google.privacy.dlp.v2.StorageConfig
 */
export type StorageConfig = Message<"google.privacy.dlp.v2.StorageConfig"> & {
  /**
   * Type of storage system to inspect.
   *
   * @generated from oneof google.privacy.dlp.v2.StorageConfig.type
   */
  type: {
    /**
     * Google Cloud Datastore options.
     *
     * @generated from field: google.privacy.dlp.v2.DatastoreOptions datastore_options = 2;
     */
    value: DatastoreOptions;
    case: "datastoreOptions";
  } | {
    /**
     * Cloud Storage options.
     *
     * @generated from field: google.privacy.dlp.v2.CloudStorageOptions cloud_storage_options = 3;
     */
    value: CloudStorageOptions;
    case: "cloudStorageOptions";
  } | {
    /**
     * BigQuery options.
     *
     * @generated from field: google.privacy.dlp.v2.BigQueryOptions big_query_options = 4;
     */
    value: BigQueryOptions;
    case: "bigQueryOptions";
  } | {
    /**
     * Hybrid inspection options.
     *
     * @generated from field: google.privacy.dlp.v2.HybridOptions hybrid_options = 9;
     */
    value: HybridOptions;
    case: "hybridOptions";
  } | { case: undefined; value?: undefined };

  /**
   * Configuration of the timespan of the items to include in scanning.
   *
   * @generated from field: google.privacy.dlp.v2.StorageConfig.TimespanConfig timespan_config = 6;
   */
  timespanConfig?: StorageConfig_TimespanConfig;
};

/**
 * Describes the message google.privacy.dlp.v2.StorageConfig.
 * Use `create(StorageConfigSchema)` to create a new message.
 */
export const StorageConfigSchema: GenMessage<StorageConfig> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 13);

/**
 * Configuration of the timespan of the items to include in scanning.
 * Currently only supported when inspecting Cloud Storage and BigQuery.
 *
 * @generated from message google.privacy.dlp.v2.StorageConfig.TimespanConfig
 */
export type StorageConfig_TimespanConfig = Message<"google.privacy.dlp.v2.StorageConfig.TimespanConfig"> & {
  /**
   * Exclude files, tables, or rows older than this value.
   * If not set, no lower time limit is applied.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * Exclude files, tables, or rows newer than this value.
   * If not set, no upper time limit is applied.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Specification of the field containing the timestamp of scanned items.
   * Used for data sources like Datastore and BigQuery.
   *
   * **For BigQuery**
   *
   * If this value is not specified and the table was modified between the
   * given start and end times, the entire table will be scanned. If this
   * value is specified, then rows are filtered based on the given start and
   * end times. Rows with a `NULL` value in the provided BigQuery column are
   * skipped.
   * Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
   * `TIMESTAMP`, and `DATETIME`.
   *
   * If your BigQuery table is [partitioned at ingestion
   * time](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time),
   * you can use any of the following pseudo-columns as your timestamp field.
   * When used with Cloud DLP, these pseudo-column names are case sensitive.
   *
   * - `_PARTITIONTIME`
   * - `_PARTITIONDATE`
   * - `_PARTITION_LOAD_TIME`
   *
   * **For Datastore**
   *
   * If this value is specified, then entities are filtered based on the given
   * start and end times. If an entity does not contain the provided timestamp
   * property or contains empty or invalid values, then it is included.
   * Valid data types of the provided timestamp property are: `TIMESTAMP`.
   *
   * See the
   * [known
   * issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-timespan)
   * related to this operation.
   *
   * @generated from field: google.privacy.dlp.v2.FieldId timestamp_field = 3;
   */
  timestampField?: FieldId;

  /**
   * When the job is started by a JobTrigger we will automatically figure out
   * a valid start_time to avoid scanning files that have not been modified
   * since the last time the JobTrigger executed. This will be based on the
   * time of the execution of the last run of the JobTrigger or the timespan
   * end_time used in the last run of the JobTrigger.
   *
   * **For BigQuery**
   *
   * Inspect jobs triggered by automatic population will scan data that is at
   * least three hours old when the job starts. This is because streaming
   * buffer rows are not read during inspection and reading up to the current
   * timestamp will result in skipped rows.
   *
   * See the [known
   * issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#recently-streamed-data)
   * related to this operation.
   *
   * @generated from field: bool enable_auto_population_of_timespan_config = 4;
   */
  enableAutoPopulationOfTimespanConfig: boolean;
};

/**
 * Describes the message google.privacy.dlp.v2.StorageConfig.TimespanConfig.
 * Use `create(StorageConfig_TimespanConfigSchema)` to create a new message.
 */
export const StorageConfig_TimespanConfigSchema: GenMessage<StorageConfig_TimespanConfig> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 13, 0);

/**
 * Configuration to control jobs where the content being inspected is outside
 * of Google Cloud Platform.
 *
 * @generated from message google.privacy.dlp.v2.HybridOptions
 */
export type HybridOptions = Message<"google.privacy.dlp.v2.HybridOptions"> & {
  /**
   * A short description of where the data is coming from. Will be stored once
   * in the job. 256 max length.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * These are labels that each inspection request must include within their
   * 'finding_labels' map. Request may contain others, but any missing one of
   * these will be rejected.
   *
   * Label keys must be between 1 and 63 characters long and must conform
   * to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
   *
   * No more than 10 keys can be required.
   *
   * @generated from field: repeated string required_finding_label_keys = 2;
   */
  requiredFindingLabelKeys: string[];

  /**
   * To organize findings, these labels will be added to each finding.
   *
   * Label keys must be between 1 and 63 characters long and must conform
   * to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
   *
   * Label values must be between 0 and 63 characters long and must conform
   * to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
   *
   * No more than 10 labels can be associated with a given finding.
   *
   * Examples:
   *
   * * `"environment" : "production"`
   * * `"pipeline" : "etl"`
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };

  /**
   * If the container is a table, additional information to make findings
   * meaningful such as the columns that are primary keys.
   *
   * @generated from field: google.privacy.dlp.v2.TableOptions table_options = 4;
   */
  tableOptions?: TableOptions;
};

/**
 * Describes the message google.privacy.dlp.v2.HybridOptions.
 * Use `create(HybridOptionsSchema)` to create a new message.
 */
export const HybridOptionsSchema: GenMessage<HybridOptions> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 14);

/**
 * Row key for identifying a record in BigQuery table.
 *
 * @generated from message google.privacy.dlp.v2.BigQueryKey
 */
export type BigQueryKey = Message<"google.privacy.dlp.v2.BigQueryKey"> & {
  /**
   * Complete BigQuery table reference.
   *
   * @generated from field: google.privacy.dlp.v2.BigQueryTable table_reference = 1;
   */
  tableReference?: BigQueryTable;

  /**
   * Row number inferred at the time the table was scanned. This value is
   * nondeterministic, cannot be queried, and may be null for inspection
   * jobs. To locate findings within a table, specify
   * `inspect_job.storage_config.big_query_options.identifying_fields` in
   * `CreateDlpJobRequest`.
   *
   * @generated from field: int64 row_number = 2;
   */
  rowNumber: bigint;
};

/**
 * Describes the message google.privacy.dlp.v2.BigQueryKey.
 * Use `create(BigQueryKeySchema)` to create a new message.
 */
export const BigQueryKeySchema: GenMessage<BigQueryKey> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 15);

/**
 * Record key for a finding in Cloud Datastore.
 *
 * @generated from message google.privacy.dlp.v2.DatastoreKey
 */
export type DatastoreKey = Message<"google.privacy.dlp.v2.DatastoreKey"> & {
  /**
   * Datastore entity key.
   *
   * @generated from field: google.privacy.dlp.v2.Key entity_key = 1;
   */
  entityKey?: Key;
};

/**
 * Describes the message google.privacy.dlp.v2.DatastoreKey.
 * Use `create(DatastoreKeySchema)` to create a new message.
 */
export const DatastoreKeySchema: GenMessage<DatastoreKey> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 16);

/**
 * A unique identifier for a Datastore entity.
 * If a key's partition ID or any of its path kinds or names are
 * reserved/read-only, the key is reserved/read-only.
 * A reserved/read-only key is forbidden in certain documented contexts.
 *
 * @generated from message google.privacy.dlp.v2.Key
 */
export type Key = Message<"google.privacy.dlp.v2.Key"> & {
  /**
   * Entities are partitioned into subsets, currently identified by a project
   * ID and namespace ID.
   * Queries are scoped to a single partition.
   *
   * @generated from field: google.privacy.dlp.v2.PartitionId partition_id = 1;
   */
  partitionId?: PartitionId;

  /**
   * The entity path.
   * An entity path consists of one or more elements composed of a kind and a
   * string or numerical identifier, which identify entities. The first
   * element identifies a _root entity_, the second element identifies
   * a _child_ of the root entity, the third element identifies a child of the
   * second entity, and so forth. The entities identified by all prefixes of
   * the path are called the element's _ancestors_.
   *
   * A path can never be empty, and a path can have at most 100 elements.
   *
   * @generated from field: repeated google.privacy.dlp.v2.Key.PathElement path = 2;
   */
  path: Key_PathElement[];
};

/**
 * Describes the message google.privacy.dlp.v2.Key.
 * Use `create(KeySchema)` to create a new message.
 */
export const KeySchema: GenMessage<Key> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 17);

/**
 * A (kind, ID/name) pair used to construct a key path.
 *
 * If either name or ID is set, the element is complete.
 * If neither is set, the element is incomplete.
 *
 * @generated from message google.privacy.dlp.v2.Key.PathElement
 */
export type Key_PathElement = Message<"google.privacy.dlp.v2.Key.PathElement"> & {
  /**
   * The kind of the entity.
   * A kind matching regex `__.*__` is reserved/read-only.
   * A kind must not contain more than 1500 bytes when UTF-8 encoded.
   * Cannot be `""`.
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * The type of ID.
   *
   * @generated from oneof google.privacy.dlp.v2.Key.PathElement.id_type
   */
  idType: {
    /**
     * The auto-allocated ID of the entity.
     * Never equal to zero. Values less than zero are discouraged and may not
     * be supported in the future.
     *
     * @generated from field: int64 id = 2;
     */
    value: bigint;
    case: "id";
  } | {
    /**
     * The name of the entity.
     * A name matching regex `__.*__` is reserved/read-only.
     * A name must not be more than 1500 bytes when UTF-8 encoded.
     * Cannot be `""`.
     *
     * @generated from field: string name = 3;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.privacy.dlp.v2.Key.PathElement.
 * Use `create(Key_PathElementSchema)` to create a new message.
 */
export const Key_PathElementSchema: GenMessage<Key_PathElement> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 17, 0);

/**
 * Message for a unique key indicating a record that contains a finding.
 *
 * @generated from message google.privacy.dlp.v2.RecordKey
 */
export type RecordKey = Message<"google.privacy.dlp.v2.RecordKey"> & {
  /**
   * Type of key
   *
   * @generated from oneof google.privacy.dlp.v2.RecordKey.type
   */
  type: {
    /**
     * BigQuery key
     *
     * @generated from field: google.privacy.dlp.v2.DatastoreKey datastore_key = 2;
     */
    value: DatastoreKey;
    case: "datastoreKey";
  } | {
    /**
     * Datastore key
     *
     * @generated from field: google.privacy.dlp.v2.BigQueryKey big_query_key = 3;
     */
    value: BigQueryKey;
    case: "bigQueryKey";
  } | { case: undefined; value?: undefined };

  /**
   * Values of identifying columns in the given row. Order of values matches
   * the order of `identifying_fields` specified in the scanning request.
   *
   * @generated from field: repeated string id_values = 5;
   */
  idValues: string[];
};

/**
 * Describes the message google.privacy.dlp.v2.RecordKey.
 * Use `create(RecordKeySchema)` to create a new message.
 */
export const RecordKeySchema: GenMessage<RecordKey> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 18);

/**
 * Message defining the location of a BigQuery table. A table is uniquely
 * identified  by its project_id, dataset_id, and table_name. Within a query
 * a table is often referenced with a string in the format of:
 * `<project_id>:<dataset_id>.<table_id>` or
 * `<project_id>.<dataset_id>.<table_id>`.
 *
 * @generated from message google.privacy.dlp.v2.BigQueryTable
 */
export type BigQueryTable = Message<"google.privacy.dlp.v2.BigQueryTable"> & {
  /**
   * The Google Cloud Platform project ID of the project containing the table.
   * If omitted, project ID is inferred from the API call.
   *
   * @generated from field: string project_id = 1;
   */
  projectId: string;

  /**
   * Dataset ID of the table.
   *
   * @generated from field: string dataset_id = 2;
   */
  datasetId: string;

  /**
   * Name of the table.
   *
   * @generated from field: string table_id = 3;
   */
  tableId: string;
};

/**
 * Describes the message google.privacy.dlp.v2.BigQueryTable.
 * Use `create(BigQueryTableSchema)` to create a new message.
 */
export const BigQueryTableSchema: GenMessage<BigQueryTable> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 19);

/**
 * Message defining the location of a BigQuery table with the projectId inferred
 * from the parent project.
 *
 * @generated from message google.privacy.dlp.v2.TableReference
 */
export type TableReference = Message<"google.privacy.dlp.v2.TableReference"> & {
  /**
   * Dataset ID of the table.
   *
   * @generated from field: string dataset_id = 1;
   */
  datasetId: string;

  /**
   * Name of the table.
   *
   * @generated from field: string table_id = 2;
   */
  tableId: string;
};

/**
 * Describes the message google.privacy.dlp.v2.TableReference.
 * Use `create(TableReferenceSchema)` to create a new message.
 */
export const TableReferenceSchema: GenMessage<TableReference> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 20);

/**
 * Message defining a field of a BigQuery table.
 *
 * @generated from message google.privacy.dlp.v2.BigQueryField
 */
export type BigQueryField = Message<"google.privacy.dlp.v2.BigQueryField"> & {
  /**
   * Source table of the field.
   *
   * @generated from field: google.privacy.dlp.v2.BigQueryTable table = 1;
   */
  table?: BigQueryTable;

  /**
   * Designated field in the BigQuery table.
   *
   * @generated from field: google.privacy.dlp.v2.FieldId field = 2;
   */
  field?: FieldId;
};

/**
 * Describes the message google.privacy.dlp.v2.BigQueryField.
 * Use `create(BigQueryFieldSchema)` to create a new message.
 */
export const BigQueryFieldSchema: GenMessage<BigQueryField> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 21);

/**
 * An entity in a dataset is a field or set of fields that correspond to a
 * single person. For example, in medical records the `EntityId` might be a
 * patient identifier, or for financial records it might be an account
 * identifier. This message is used when generalizations or analysis must take
 * into account that multiple rows correspond to the same entity.
 *
 * @generated from message google.privacy.dlp.v2.EntityId
 */
export type EntityId = Message<"google.privacy.dlp.v2.EntityId"> & {
  /**
   * Composite key indicating which field contains the entity identifier.
   *
   * @generated from field: google.privacy.dlp.v2.FieldId field = 1;
   */
  field?: FieldId;
};

/**
 * Describes the message google.privacy.dlp.v2.EntityId.
 * Use `create(EntityIdSchema)` to create a new message.
 */
export const EntityIdSchema: GenMessage<EntityId> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 22);

/**
 * Instructions regarding the table content being inspected.
 *
 * @generated from message google.privacy.dlp.v2.TableOptions
 */
export type TableOptions = Message<"google.privacy.dlp.v2.TableOptions"> & {
  /**
   * The columns that are the primary keys for table objects included in
   * ContentItem. A copy of this cell's value will stored alongside alongside
   * each finding so that the finding can be traced to the specific row it came
   * from. No more than 3 may be provided.
   *
   * @generated from field: repeated google.privacy.dlp.v2.FieldId identifying_fields = 1;
   */
  identifyingFields: FieldId[];
};

/**
 * Describes the message google.privacy.dlp.v2.TableOptions.
 * Use `create(TableOptionsSchema)` to create a new message.
 */
export const TableOptionsSchema: GenMessage<TableOptions> = /*@__PURE__*/
  messageDesc(file_google_privacy_dlp_v2_storage, 23);

/**
 * Coarse-grained confidence level of how well a particular finding
 * satisfies the criteria to match a particular infoType.
 *
 * Likelihood is calculated based on the number of signals a
 * finding has that implies that the finding matches the infoType. For
 * example, a string that has an '@' and a '.com' is more likely to be a
 * match for an email address than a string that only has an '@'.
 *
 * In general, the highest likelihood level has the strongest signals that
 * indicate a match. That is, a finding with a high likelihood has a low chance
 * of being a false positive.
 *
 * For more information about each likelihood level
 * and how likelihood works, see [Match
 * likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).
 *
 * @generated from enum google.privacy.dlp.v2.Likelihood
 */
export enum Likelihood {
  /**
   * Default value; same as POSSIBLE.
   *
   * @generated from enum value: LIKELIHOOD_UNSPECIFIED = 0;
   */
  LIKELIHOOD_UNSPECIFIED = 0,

  /**
   * Highest chance of a false positive.
   *
   * @generated from enum value: VERY_UNLIKELY = 1;
   */
  VERY_UNLIKELY = 1,

  /**
   * High chance of a false positive.
   *
   * @generated from enum value: UNLIKELY = 2;
   */
  UNLIKELY = 2,

  /**
   * Some matching signals. The default value.
   *
   * @generated from enum value: POSSIBLE = 3;
   */
  POSSIBLE = 3,

  /**
   * Low chance of a false positive.
   *
   * @generated from enum value: LIKELY = 4;
   */
  LIKELY = 4,

  /**
   * Confidence level is high. Lowest chance of a false positive.
   *
   * @generated from enum value: VERY_LIKELY = 5;
   */
  VERY_LIKELY = 5,
}

/**
 * Describes the enum google.privacy.dlp.v2.Likelihood.
 */
export const LikelihoodSchema: GenEnum<Likelihood> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 0);

/**
 * Definitions of file type groups to scan. New types will be added to this
 * list.
 *
 * @generated from enum google.privacy.dlp.v2.FileType
 */
export enum FileType {
  /**
   * Includes all files.
   *
   * @generated from enum value: FILE_TYPE_UNSPECIFIED = 0;
   */
  FILE_TYPE_UNSPECIFIED = 0,

  /**
   * Includes all file extensions not covered by another entry. Binary
   * scanning attempts to convert the content of the file to utf_8 to scan
   * the file.
   * If you wish to avoid this fall back, specify one or more of the other
   * file types in your storage scan.
   *
   * @generated from enum value: BINARY_FILE = 1;
   */
  BINARY_FILE = 1,

  /**
   * Included file extensions:
   *   asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
   *   dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
   *   mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
   *   properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
   *   shtml, shtm, xhtml, lhs, ics, ini, java, js, json, jsonl, kix, kml,
   *   ocaml, md, txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd,
   *   yml, yaml.
   *
   * @generated from enum value: TEXT_FILE = 2;
   */
  TEXT_FILE = 2,

  /**
   * Included file extensions:
   *   bmp, gif, jpg, jpeg, jpe, png. Setting
   * [bytes_limit_per_file][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
   * or
   * [bytes_limit_per_file_percent][google.privacy.dlp.v2.CloudStorageOptions.bytes_limit_per_file]
   * has no effect on image files. Image inspection is restricted to the
   * `global`, `us`, `asia`, and `europe` regions.
   *
   * @generated from enum value: IMAGE = 3;
   */
  IMAGE = 3,

  /**
   * Microsoft Word files larger than 30 MB will be scanned as binary files.
   * Included file extensions:
   *   docx, dotx, docm, dotm. Setting `bytes_limit_per_file` or
   *   `bytes_limit_per_file_percent` has no effect on Word files.
   *
   * @generated from enum value: WORD = 5;
   */
  WORD = 5,

  /**
   * PDF files larger than 30 MB will be scanned as binary files.
   * Included file extensions:
   *   pdf. Setting `bytes_limit_per_file` or `bytes_limit_per_file_percent`
   * has no effect on PDF files.
   *
   * @generated from enum value: PDF = 6;
   */
  PDF = 6,

  /**
   * Included file extensions:
   *   avro
   *
   * @generated from enum value: AVRO = 7;
   */
  AVRO = 7,

  /**
   * Included file extensions:
   *   csv
   *
   * @generated from enum value: CSV = 8;
   */
  CSV = 8,

  /**
   * Included file extensions:
   *   tsv
   *
   * @generated from enum value: TSV = 9;
   */
  TSV = 9,

  /**
   * Microsoft PowerPoint files larger than 30 MB will be scanned as binary
   * files. Included file extensions:
   *   pptx, pptm, potx, potm, pot. Setting `bytes_limit_per_file` or
   *   `bytes_limit_per_file_percent` has no effect on PowerPoint files.
   *
   * @generated from enum value: POWERPOINT = 11;
   */
  POWERPOINT = 11,

  /**
   * Microsoft Excel files larger than 30 MB will be scanned as binary files.
   * Included file extensions:
   *   xlsx, xlsm, xltx, xltm. Setting `bytes_limit_per_file` or
   *   `bytes_limit_per_file_percent` has no effect on Excel files.
   *
   * @generated from enum value: EXCEL = 12;
   */
  EXCEL = 12,
}

/**
 * Describes the enum google.privacy.dlp.v2.FileType.
 */
export const FileTypeSchema: GenEnum<FileType> = /*@__PURE__*/
  enumDesc(file_google_privacy_dlp_v2_storage, 1);

