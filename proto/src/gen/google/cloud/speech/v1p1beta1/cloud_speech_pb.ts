// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/speech/v1p1beta1/cloud_speech.proto (package google.cloud.speech.v1p1beta1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { SpeechAdaptation, TranscriptNormalization } from "./resource_pb";
import { file_google_cloud_speech_v1p1beta1_resource } from "./resource_pb";
import type { OperationSchema } from "../../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../../longrunning/operations_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../../rpc/status_pb";
import { file_google_rpc_status } from "../../../rpc/status_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/speech/v1p1beta1/cloud_speech.proto.
 */
export const file_google_cloud_speech_v1p1beta1_cloud_speech: GenFile = /*@__PURE__*/
  fileDesc("CjBnb29nbGUvY2xvdWQvc3BlZWNoL3YxcDFiZXRhMS9jbG91ZF9zcGVlY2gucHJvdG8SHWdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExIp4BChBSZWNvZ25pemVSZXF1ZXN0EkUKBmNvbmZpZxgBIAEoCzIwLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlJlY29nbml0aW9uQ29uZmlnQgPgQQISQwoFYXVkaW8YAiABKAsyLy5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5SZWNvZ25pdGlvbkF1ZGlvQgPgQQIi/AEKG0xvbmdSdW5uaW5nUmVjb2duaXplUmVxdWVzdBJFCgZjb25maWcYASABKAsyMC5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5SZWNvZ25pdGlvbkNvbmZpZ0ID4EECEkMKBWF1ZGlvGAIgASgLMi8uZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXRpb25BdWRpb0ID4EECElEKDW91dHB1dF9jb25maWcYBCABKAsyNS5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5UcmFuc2NyaXB0T3V0cHV0Q29uZmlnQgPgQQEiOgoWVHJhbnNjcmlwdE91dHB1dENvbmZpZxIRCgdnY3NfdXJpGAEgASgJSABCDQoLb3V0cHV0X3R5cGUioAEKGVN0cmVhbWluZ1JlY29nbml6ZVJlcXVlc3QSVQoQc3RyZWFtaW5nX2NvbmZpZxgBIAEoCzI5Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlN0cmVhbWluZ1JlY29nbml0aW9uQ29uZmlnSAASFwoNYXVkaW9fY29udGVudBgCIAEoDEgAQhMKEXN0cmVhbWluZ19yZXF1ZXN0IrUDChpTdHJlYW1pbmdSZWNvZ25pdGlvbkNvbmZpZxJFCgZjb25maWcYASABKAsyMC5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5SZWNvZ25pdGlvbkNvbmZpZ0ID4EECEhgKEHNpbmdsZV91dHRlcmFuY2UYAiABKAgSFwoPaW50ZXJpbV9yZXN1bHRzGAMgASgIEiQKHGVuYWJsZV92b2ljZV9hY3Rpdml0eV9ldmVudHMYBSABKAgSbgoWdm9pY2VfYWN0aXZpdHlfdGltZW91dBgGIAEoCzJOLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlN0cmVhbWluZ1JlY29nbml0aW9uQ29uZmlnLlZvaWNlQWN0aXZpdHlUaW1lb3V0GoYBChRWb2ljZUFjdGl2aXR5VGltZW91dBI3ChRzcGVlY2hfc3RhcnRfdGltZW91dBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI1ChJzcGVlY2hfZW5kX3RpbWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24ivgkKEVJlY29nbml0aW9uQ29uZmlnElAKCGVuY29kaW5nGAEgASgOMj4uZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXRpb25Db25maWcuQXVkaW9FbmNvZGluZxIZChFzYW1wbGVfcmF0ZV9oZXJ0ehgCIAEoBRIbChNhdWRpb19jaGFubmVsX2NvdW50GAcgASgFEi8KJ2VuYWJsZV9zZXBhcmF0ZV9yZWNvZ25pdGlvbl9wZXJfY2hhbm5lbBgMIAEoCBIaCg1sYW5ndWFnZV9jb2RlGAMgASgJQgPgQQISIgoaYWx0ZXJuYXRpdmVfbGFuZ3VhZ2VfY29kZXMYEiADKAkSGAoQbWF4X2FsdGVybmF0aXZlcxgEIAEoBRIYChBwcm9mYW5pdHlfZmlsdGVyGAUgASgIEkMKCmFkYXB0YXRpb24YFCABKAsyLy5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5TcGVlY2hBZGFwdGF0aW9uElgKGHRyYW5zY3JpcHRfbm9ybWFsaXphdGlvbhgYIAEoCzI2Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlRyYW5zY3JpcHROb3JtYWxpemF0aW9uEkUKD3NwZWVjaF9jb250ZXh0cxgGIAMoCzIsLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlNwZWVjaENvbnRleHQSIAoYZW5hYmxlX3dvcmRfdGltZV9vZmZzZXRzGAggASgIEh4KFmVuYWJsZV93b3JkX2NvbmZpZGVuY2UYDyABKAgSJAocZW5hYmxlX2F1dG9tYXRpY19wdW5jdHVhdGlvbhgLIAEoCBI9ChllbmFibGVfc3Bva2VuX3B1bmN0dWF0aW9uGBYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRI4ChRlbmFibGVfc3Bva2VuX2Vtb2ppcxgXIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSJgoaZW5hYmxlX3NwZWFrZXJfZGlhcml6YXRpb24YECABKAhCAhgBEiUKGWRpYXJpemF0aW9uX3NwZWFrZXJfY291bnQYESABKAVCAhgBElMKEmRpYXJpemF0aW9uX2NvbmZpZxgTIAEoCzI3Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlNwZWFrZXJEaWFyaXphdGlvbkNvbmZpZxJECghtZXRhZGF0YRgJIAEoCzIyLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlJlY29nbml0aW9uTWV0YWRhdGESDQoFbW9kZWwYDSABKAkSFAoMdXNlX2VuaGFuY2VkGA4gASgIIqMBCg1BdWRpb0VuY29kaW5nEhgKFEVOQ09ESU5HX1VOU1BFQ0lGSUVEEAASDAoITElORUFSMTYQARIICgRGTEFDEAISCQoFTVVMQVcQAxIHCgNBTVIQBBIKCgZBTVJfV0IQBRIMCghPR0dfT1BVUxAGEhoKFlNQRUVYX1dJVEhfSEVBREVSX0JZVEUQBxIHCgNNUDMQCBINCglXRUJNX09QVVMQCSKQAQoYU3BlYWtlckRpYXJpemF0aW9uQ29uZmlnEiIKGmVuYWJsZV9zcGVha2VyX2RpYXJpemF0aW9uGAEgASgIEhkKEW1pbl9zcGVha2VyX2NvdW50GAIgASgFEhkKEW1heF9zcGVha2VyX2NvdW50GAMgASgFEhoKC3NwZWFrZXJfdGFnGAUgASgFQgUYAeBBAyLbCAoTUmVjb2duaXRpb25NZXRhZGF0YRJcChBpbnRlcmFjdGlvbl90eXBlGAEgASgOMkIuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXRpb25NZXRhZGF0YS5JbnRlcmFjdGlvblR5cGUSJAocaW5kdXN0cnlfbmFpY3NfY29kZV9vZl9hdWRpbxgDIAEoDRJiChNtaWNyb3Bob25lX2Rpc3RhbmNlGAQgASgOMkUuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXRpb25NZXRhZGF0YS5NaWNyb3Bob25lRGlzdGFuY2USYQoTb3JpZ2luYWxfbWVkaWFfdHlwZRgFIAEoDjJELmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlJlY29nbml0aW9uTWV0YWRhdGEuT3JpZ2luYWxNZWRpYVR5cGUSZQoVcmVjb3JkaW5nX2RldmljZV90eXBlGAYgASgOMkYuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXRpb25NZXRhZGF0YS5SZWNvcmRpbmdEZXZpY2VUeXBlEh0KFXJlY29yZGluZ19kZXZpY2VfbmFtZRgHIAEoCRIaChJvcmlnaW5hbF9taW1lX3R5cGUYCCABKAkSGQoNb2JmdXNjYXRlZF9pZBgJIAEoA0ICGAESEwoLYXVkaW9fdG9waWMYCiABKAkixQEKD0ludGVyYWN0aW9uVHlwZRIgChxJTlRFUkFDVElPTl9UWVBFX1VOU1BFQ0lGSUVEEAASDgoKRElTQ1VTU0lPThABEhAKDFBSRVNFTlRBVElPThACEg4KClBIT05FX0NBTEwQAxINCglWT0lDRU1BSUwQBBIbChdQUk9GRVNTSU9OQUxMWV9QUk9EVUNFRBAFEhAKDFZPSUNFX1NFQVJDSBAGEhEKDVZPSUNFX0NPTU1BTkQQBxINCglESUNUQVRJT04QCCJkChJNaWNyb3Bob25lRGlzdGFuY2USIwofTUlDUk9QSE9ORV9ESVNUQU5DRV9VTlNQRUNJRklFRBAAEg0KCU5FQVJGSUVMRBABEgwKCE1JREZJRUxEEAISDAoIRkFSRklFTEQQAyJOChFPcmlnaW5hbE1lZGlhVHlwZRIjCh9PUklHSU5BTF9NRURJQV9UWVBFX1VOU1BFQ0lGSUVEEAASCQoFQVVESU8QARIJCgVWSURFTxACIqQBChNSZWNvcmRpbmdEZXZpY2VUeXBlEiUKIVJFQ09SRElOR19ERVZJQ0VfVFlQRV9VTlNQRUNJRklFRBAAEg4KClNNQVJUUEhPTkUQARIGCgJQQxACEg4KClBIT05FX0xJTkUQAxILCgdWRUhJQ0xFEAQSGAoUT1RIRVJfT1VURE9PUl9ERVZJQ0UQBRIXChNPVEhFUl9JTkRPT1JfREVWSUNFEAY6AhgBIi8KDVNwZWVjaENvbnRleHQSDwoHcGhyYXNlcxgBIAMoCRINCgVib29zdBgEIAEoAiJEChBSZWNvZ25pdGlvbkF1ZGlvEhEKB2NvbnRlbnQYASABKAxIABINCgN1cmkYAiABKAlIAEIOCgxhdWRpb19zb3VyY2Ui+wEKEVJlY29nbml6ZVJlc3BvbnNlEkcKB3Jlc3VsdHMYAiADKAsyNi5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5TcGVlY2hSZWNvZ25pdGlvblJlc3VsdBI0ChF0b3RhbF9iaWxsZWRfdGltZRgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJTChZzcGVlY2hfYWRhcHRhdGlvbl9pbmZvGAcgASgLMjMuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuU3BlZWNoQWRhcHRhdGlvbkluZm8SEgoKcmVxdWVzdF9pZBgIIAEoAyL+AgocTG9uZ1J1bm5pbmdSZWNvZ25pemVSZXNwb25zZRJHCgdyZXN1bHRzGAIgAygLMjYuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuU3BlZWNoUmVjb2duaXRpb25SZXN1bHQSNAoRdG90YWxfYmlsbGVkX3RpbWUYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24STAoNb3V0cHV0X2NvbmZpZxgGIAEoCzI1Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlRyYW5zY3JpcHRPdXRwdXRDb25maWcSKAoMb3V0cHV0X2Vycm9yGAcgASgLMhIuZ29vZ2xlLnJwYy5TdGF0dXMSUwoWc3BlZWNoX2FkYXB0YXRpb25faW5mbxgIIAEoCzIzLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlNwZWVjaEFkYXB0YXRpb25JbmZvEhIKCnJlcXVlc3RfaWQYCSABKAMigwIKHExvbmdSdW5uaW5nUmVjb2duaXplTWV0YWRhdGESGAoQcHJvZ3Jlc3NfcGVyY2VudBgBIAEoBRIuCgpzdGFydF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI0ChBsYXN0X3VwZGF0ZV90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIQCgN1cmkYBCABKAlCA+BBAxJRCg1vdXRwdXRfY29uZmlnGAUgASgLMjUuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuVHJhbnNjcmlwdE91dHB1dENvbmZpZ0ID4EEDIuYEChpTdHJlYW1pbmdSZWNvZ25pemVSZXNwb25zZRIhCgVlcnJvchgBIAEoCzISLmdvb2dsZS5ycGMuU3RhdHVzEkoKB3Jlc3VsdHMYAiADKAsyOS5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5TdHJlYW1pbmdSZWNvZ25pdGlvblJlc3VsdBJkChFzcGVlY2hfZXZlbnRfdHlwZRgEIAEoDjJJLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlN0cmVhbWluZ1JlY29nbml6ZVJlc3BvbnNlLlNwZWVjaEV2ZW50VHlwZRI0ChFzcGVlY2hfZXZlbnRfdGltZRgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI0ChF0b3RhbF9iaWxsZWRfdGltZRgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJTChZzcGVlY2hfYWRhcHRhdGlvbl9pbmZvGAkgASgLMjMuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuU3BlZWNoQWRhcHRhdGlvbkluZm8SEgoKcmVxdWVzdF9pZBgKIAEoAyKdAQoPU3BlZWNoRXZlbnRUeXBlEhwKGFNQRUVDSF9FVkVOVF9VTlNQRUNJRklFRBAAEhsKF0VORF9PRl9TSU5HTEVfVVRURVJBTkNFEAESGQoVU1BFRUNIX0FDVElWSVRZX0JFR0lOEAISFwoTU1BFRUNIX0FDVElWSVRZX0VORBADEhsKF1NQRUVDSF9BQ1RJVklUWV9USU1FT1VUEAQi+QEKGlN0cmVhbWluZ1JlY29nbml0aW9uUmVzdWx0ElEKDGFsdGVybmF0aXZlcxgBIAMoCzI7Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlNwZWVjaFJlY29nbml0aW9uQWx0ZXJuYXRpdmUSEAoIaXNfZmluYWwYAiABKAgSEQoJc3RhYmlsaXR5GAMgASgCEjIKD3Jlc3VsdF9lbmRfdGltZRgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhITCgtjaGFubmVsX3RhZxgFIAEoBRIaCg1sYW5ndWFnZV9jb2RlGAYgASgJQgPgQQMi0QEKF1NwZWVjaFJlY29nbml0aW9uUmVzdWx0ElEKDGFsdGVybmF0aXZlcxgBIAMoCzI7Lmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlNwZWVjaFJlY29nbml0aW9uQWx0ZXJuYXRpdmUSEwoLY2hhbm5lbF90YWcYAiABKAUSMgoPcmVzdWx0X2VuZF90aW1lGAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhoKDWxhbmd1YWdlX2NvZGUYBSABKAlCA+BBAyJ+ChxTcGVlY2hSZWNvZ25pdGlvbkFsdGVybmF0aXZlEhIKCnRyYW5zY3JpcHQYASABKAkSEgoKY29uZmlkZW5jZRgCIAEoAhI2CgV3b3JkcxgDIAMoCzInLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLldvcmRJbmZvIqIBCghXb3JkSW5mbxItCgpzdGFydF90aW1lGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEisKCGVuZF90aW1lGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEgwKBHdvcmQYAyABKAkSEgoKY29uZmlkZW5jZRgEIAEoAhIYCgtzcGVha2VyX3RhZxgFIAEoBUID4EEDIksKFFNwZWVjaEFkYXB0YXRpb25JbmZvEhoKEmFkYXB0YXRpb25fdGltZW91dBgBIAEoCBIXCg90aW1lb3V0X21lc3NhZ2UYBCABKAkyggUKBlNwZWVjaBKlAQoJUmVjb2duaXplEi8uZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuUmVjb2duaXplUmVxdWVzdBowLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExLlJlY29nbml6ZVJlc3BvbnNlIjXaQQxjb25maWcsYXVkaW+C0+STAiA6ASoiGy92MXAxYmV0YTEvc3BlZWNoOnJlY29nbml6ZRLyAQoUTG9uZ1J1bm5pbmdSZWNvZ25pemUSOi5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5Mb25nUnVubmluZ1JlY29nbml6ZVJlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIn/KQTwKHExvbmdSdW5uaW5nUmVjb2duaXplUmVzcG9uc2USHExvbmdSdW5uaW5nUmVjb2duaXplTWV0YWRhdGHaQQxjb25maWcsYXVkaW+C0+STAis6ASoiJi92MXAxYmV0YTEvc3BlZWNoOmxvbmdydW5uaW5ncmVjb2duaXplEo8BChJTdHJlYW1pbmdSZWNvZ25pemUSOC5nb29nbGUuY2xvdWQuc3BlZWNoLnYxcDFiZXRhMS5TdHJlYW1pbmdSZWNvZ25pemVSZXF1ZXN0GjkuZ29vZ2xlLmNsb3VkLnNwZWVjaC52MXAxYmV0YTEuU3RyZWFtaW5nUmVjb2duaXplUmVzcG9uc2UiACgBMAEaScpBFXNwZWVjaC5nb29nbGVhcGlzLmNvbdJBLmh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1CdgohY29tLmdvb2dsZS5jbG91ZC5zcGVlY2gudjFwMWJldGExQgtTcGVlY2hQcm90b1ABWjljbG91ZC5nb29nbGUuY29tL2dvL3NwZWVjaC9hcGl2MXAxYmV0YTEvc3BlZWNocGI7c3BlZWNocGL4AQGiAgNHQ1NiBnByb3RvMw", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_cloud_speech_v1p1beta1_resource, file_google_longrunning_operations, file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers, file_google_rpc_status]);

/**
 * The top-level message sent by the client for the `Recognize` method.
 *
 * @generated from message google.cloud.speech.v1p1beta1.RecognizeRequest
 */
export type RecognizeRequest = Message<"google.cloud.speech.v1p1beta1.RecognizeRequest"> & {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * Required. The audio data to be recognized.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionAudio audio = 2;
   */
  audio?: RecognitionAudio;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.RecognizeRequest.
 * Use `create(RecognizeRequestSchema)` to create a new message.
 */
export const RecognizeRequestSchema: GenMessage<RecognizeRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 0);

/**
 * The top-level message sent by the client for the `LongRunningRecognize`
 * method.
 *
 * @generated from message google.cloud.speech.v1p1beta1.LongRunningRecognizeRequest
 */
export type LongRunningRecognizeRequest = Message<"google.cloud.speech.v1p1beta1.LongRunningRecognizeRequest"> & {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * Required. The audio data to be recognized.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionAudio audio = 2;
   */
  audio?: RecognitionAudio;

  /**
   * Optional. Specifies an optional destination for the recognition results.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.TranscriptOutputConfig output_config = 4;
   */
  outputConfig?: TranscriptOutputConfig;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.LongRunningRecognizeRequest.
 * Use `create(LongRunningRecognizeRequestSchema)` to create a new message.
 */
export const LongRunningRecognizeRequestSchema: GenMessage<LongRunningRecognizeRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 1);

/**
 * Specifies an optional destination for the recognition results.
 *
 * @generated from message google.cloud.speech.v1p1beta1.TranscriptOutputConfig
 */
export type TranscriptOutputConfig = Message<"google.cloud.speech.v1p1beta1.TranscriptOutputConfig"> & {
  /**
   * @generated from oneof google.cloud.speech.v1p1beta1.TranscriptOutputConfig.output_type
   */
  outputType: {
    /**
     * Specifies a Cloud Storage URI for the recognition results. Must be
     * specified in the format: `gs://bucket_name/object_name`, and the bucket
     * must already exist.
     *
     * @generated from field: string gcs_uri = 1;
     */
    value: string;
    case: "gcsUri";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.TranscriptOutputConfig.
 * Use `create(TranscriptOutputConfigSchema)` to create a new message.
 */
export const TranscriptOutputConfigSchema: GenMessage<TranscriptOutputConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 2);

/**
 * The top-level message sent by the client for the `StreamingRecognize` method.
 * Multiple `StreamingRecognizeRequest` messages are sent. The first message
 * must contain a `streaming_config` message and must not contain
 * `audio_content`. All subsequent messages must contain `audio_content` and
 * must not contain a `streaming_config` message.
 *
 * @generated from message google.cloud.speech.v1p1beta1.StreamingRecognizeRequest
 */
export type StreamingRecognizeRequest = Message<"google.cloud.speech.v1p1beta1.StreamingRecognizeRequest"> & {
  /**
   * The streaming request, which is either a streaming config or audio content.
   *
   * @generated from oneof google.cloud.speech.v1p1beta1.StreamingRecognizeRequest.streaming_request
   */
  streamingRequest: {
    /**
     * Provides information to the recognizer that specifies how to process the
     * request. The first `StreamingRecognizeRequest` message must contain a
     * `streaming_config`  message.
     *
     * @generated from field: google.cloud.speech.v1p1beta1.StreamingRecognitionConfig streaming_config = 1;
     */
    value: StreamingRecognitionConfig;
    case: "streamingConfig";
  } | {
    /**
     * The audio data to be recognized. Sequential chunks of audio data are sent
     * in sequential `StreamingRecognizeRequest` messages. The first
     * `StreamingRecognizeRequest` message must not contain `audio_content` data
     * and all subsequent `StreamingRecognizeRequest` messages must contain
     * `audio_content` data. The audio bytes must be encoded as specified in
     * `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
     * pure binary representation (not base64). See
     * [content limits](https://cloud.google.com/speech-to-text/quotas#content).
     *
     * @generated from field: bytes audio_content = 2;
     */
    value: Uint8Array;
    case: "audioContent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.StreamingRecognizeRequest.
 * Use `create(StreamingRecognizeRequestSchema)` to create a new message.
 */
export const StreamingRecognizeRequestSchema: GenMessage<StreamingRecognizeRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 3);

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 *
 * @generated from message google.cloud.speech.v1p1beta1.StreamingRecognitionConfig
 */
export type StreamingRecognitionConfig = Message<"google.cloud.speech.v1p1beta1.StreamingRecognitionConfig"> & {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * If `false` or omitted, the recognizer will perform continuous
   * recognition (continuing to wait for and process audio even if the user
   * pauses speaking) until the client closes the input stream (gRPC API) or
   * until the maximum time limit has been reached. May return multiple
   * `StreamingRecognitionResult`s with the `is_final` flag set to `true`.
   *
   * If `true`, the recognizer will detect a single spoken utterance. When it
   * detects that the user has paused or stopped speaking, it will return an
   * `END_OF_SINGLE_UTTERANCE` event and cease recognition. It will return no
   * more than one `StreamingRecognitionResult` with the `is_final` flag set to
   * `true`.
   *
   * The `single_utterance` field can only be used with specified models,
   * otherwise an error is thrown. The `model` field in [`RecognitionConfig`][]
   * must be set to:
   *
   * * `command_and_search`
   * * `phone_call` AND additional field `useEnhanced`=`true`
   * * The `model` field is left undefined. In this case the API auto-selects
   *   a model based on any other parameters that you set in
   *   `RecognitionConfig`.
   *
   * @generated from field: bool single_utterance = 2;
   */
  singleUtterance: boolean;

  /**
   * If `true`, interim results (tentative hypotheses) may be
   * returned as they become available (these interim results are indicated with
   * the `is_final=false` flag).
   * If `false` or omitted, only `is_final=true` result(s) are returned.
   *
   * @generated from field: bool interim_results = 3;
   */
  interimResults: boolean;

  /**
   * If `true`, responses with voice activity speech events will be returned as
   * they are detected.
   *
   * @generated from field: bool enable_voice_activity_events = 5;
   */
  enableVoiceActivityEvents: boolean;

  /**
   * If set, the server will automatically close the stream after the specified
   * duration has elapsed after the last VOICE_ACTIVITY speech event has been
   * sent. The field `voice_activity_events` must also be set to true.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.StreamingRecognitionConfig.VoiceActivityTimeout voice_activity_timeout = 6;
   */
  voiceActivityTimeout?: StreamingRecognitionConfig_VoiceActivityTimeout;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.StreamingRecognitionConfig.
 * Use `create(StreamingRecognitionConfigSchema)` to create a new message.
 */
export const StreamingRecognitionConfigSchema: GenMessage<StreamingRecognitionConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 4);

/**
 * Events that a timeout can be set on for voice activity.
 *
 * @generated from message google.cloud.speech.v1p1beta1.StreamingRecognitionConfig.VoiceActivityTimeout
 */
export type StreamingRecognitionConfig_VoiceActivityTimeout = Message<"google.cloud.speech.v1p1beta1.StreamingRecognitionConfig.VoiceActivityTimeout"> & {
  /**
   * Duration to timeout the stream if no speech begins.
   *
   * @generated from field: google.protobuf.Duration speech_start_timeout = 1;
   */
  speechStartTimeout?: Duration;

  /**
   * Duration to timeout the stream after speech ends.
   *
   * @generated from field: google.protobuf.Duration speech_end_timeout = 2;
   */
  speechEndTimeout?: Duration;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.StreamingRecognitionConfig.VoiceActivityTimeout.
 * Use `create(StreamingRecognitionConfig_VoiceActivityTimeoutSchema)` to create a new message.
 */
export const StreamingRecognitionConfig_VoiceActivityTimeoutSchema: GenMessage<StreamingRecognitionConfig_VoiceActivityTimeout> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 4, 0);

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 *
 * @generated from message google.cloud.speech.v1p1beta1.RecognitionConfig
 */
export type RecognitionConfig = Message<"google.cloud.speech.v1p1beta1.RecognitionConfig"> & {
  /**
   * Encoding of audio data sent in all `RecognitionAudio` messages.
   * This field is optional for `FLAC` and `WAV` audio files and required
   * for all other audio formats. For details, see
   * [AudioEncoding][google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding].
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding encoding = 1;
   */
  encoding: RecognitionConfig_AudioEncoding;

  /**
   * Sample rate in Hertz of the audio data sent in all
   * `RecognitionAudio` messages. Valid values are: 8000-48000.
   * 16000 is optimal. For best results, set the sampling rate of the audio
   * source to 16000 Hz. If that's not possible, use the native sample rate of
   * the audio source (instead of re-sampling).
   * This field is optional for FLAC and WAV audio files, but is
   * required for all other audio formats. For details, see
   * [AudioEncoding][google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding].
   *
   * @generated from field: int32 sample_rate_hertz = 2;
   */
  sampleRateHertz: number;

  /**
   * The number of channels in the input audio data.
   * ONLY set this for MULTI-CHANNEL recognition.
   * Valid values for LINEAR16, OGG_OPUS and FLAC are `1`-`8`.
   * Valid value for MULAW, AMR, AMR_WB and SPEEX_WITH_HEADER_BYTE is only `1`.
   * If `0` or omitted, defaults to one channel (mono).
   * Note: We only recognize the first channel by default.
   * To perform independent recognition on each channel set
   * `enable_separate_recognition_per_channel` to 'true'.
   *
   * @generated from field: int32 audio_channel_count = 7;
   */
  audioChannelCount: number;

  /**
   * This needs to be set to `true` explicitly and `audio_channel_count` > 1
   * to get each channel recognized separately. The recognition result will
   * contain a `channel_tag` field to state which channel that result belongs
   * to. If this is not true, we will only recognize the first channel. The
   * request is billed cumulatively for all channels recognized:
   * `audio_channel_count` multiplied by the length of the audio.
   *
   * @generated from field: bool enable_separate_recognition_per_channel = 12;
   */
  enableSeparateRecognitionPerChannel: boolean;

  /**
   * Required. The language of the supplied audio as a
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
   * Example: "en-US".
   * See [Language
   * Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
   * of the currently supported language codes.
   *
   * @generated from field: string language_code = 3;
   */
  languageCode: string;

  /**
   * A list of up to 3 additional
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags,
   * listing possible alternative languages of the supplied audio.
   * See [Language
   * Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
   * of the currently supported language codes. If alternative languages are
   * listed, recognition result will contain recognition in the most likely
   * language detected including the main language_code. The recognition result
   * will include the language tag of the language detected in the audio. Note:
   * This feature is only supported for Voice Command and Voice Search use cases
   * and performance may vary for other use cases (e.g., phone call
   * transcription).
   *
   * @generated from field: repeated string alternative_language_codes = 18;
   */
  alternativeLanguageCodes: string[];

  /**
   * Maximum number of recognition hypotheses to be returned.
   * Specifically, the maximum number of `SpeechRecognitionAlternative` messages
   * within each `SpeechRecognitionResult`.
   * The server may return fewer than `max_alternatives`.
   * Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
   * one. If omitted, will return a maximum of one.
   *
   * @generated from field: int32 max_alternatives = 4;
   */
  maxAlternatives: number;

  /**
   * If set to `true`, the server will attempt to filter out
   * profanities, replacing all but the initial character in each filtered word
   * with asterisks, e.g. "f***". If set to `false` or omitted, profanities
   * won't be filtered out.
   *
   * @generated from field: bool profanity_filter = 5;
   */
  profanityFilter: boolean;

  /**
   * Speech adaptation configuration improves the accuracy of speech
   * recognition. For more information, see the [speech
   * adaptation](https://cloud.google.com/speech-to-text/docs/adaptation)
   * documentation.
   * When speech adaptation is set it supersedes the `speech_contexts` field.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.SpeechAdaptation adaptation = 20;
   */
  adaptation?: SpeechAdaptation;

  /**
   * Use transcription normalization to automatically replace parts of the
   * transcript with phrases of your choosing. For StreamingRecognize, this
   * normalization only applies to stable partial transcripts (stability > 0.8)
   * and final transcripts.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.TranscriptNormalization transcript_normalization = 24;
   */
  transcriptNormalization?: TranscriptNormalization;

  /**
   * Array of [SpeechContext][google.cloud.speech.v1p1beta1.SpeechContext].
   * A means to provide context to assist the speech recognition. For more
   * information, see
   * [speech
   * adaptation](https://cloud.google.com/speech-to-text/docs/adaptation).
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.SpeechContext speech_contexts = 6;
   */
  speechContexts: SpeechContext[];

  /**
   * If `true`, the top result includes a list of words and
   * the start and end time offsets (timestamps) for those words. If
   * `false`, no word-level time offset information is returned. The default is
   * `false`.
   *
   * @generated from field: bool enable_word_time_offsets = 8;
   */
  enableWordTimeOffsets: boolean;

  /**
   * If `true`, the top result includes a list of words and the
   * confidence for those words. If `false`, no word-level confidence
   * information is returned. The default is `false`.
   *
   * @generated from field: bool enable_word_confidence = 15;
   */
  enableWordConfidence: boolean;

  /**
   * If 'true', adds punctuation to recognition result hypotheses.
   * This feature is only available in select languages. Setting this for
   * requests in other languages has no effect at all.
   * The default 'false' value does not add punctuation to result hypotheses.
   *
   * @generated from field: bool enable_automatic_punctuation = 11;
   */
  enableAutomaticPunctuation: boolean;

  /**
   * The spoken punctuation behavior for the call
   * If not set, uses default behavior based on model of choice
   * e.g. command_and_search will enable spoken punctuation by default
   * If 'true', replaces spoken punctuation with the corresponding symbols in
   * the request. For example, "how are you question mark" becomes "how are
   * you?". See https://cloud.google.com/speech-to-text/docs/spoken-punctuation
   * for support. If 'false', spoken punctuation is not replaced.
   *
   * @generated from field: google.protobuf.BoolValue enable_spoken_punctuation = 22;
   */
  enableSpokenPunctuation?: boolean;

  /**
   * The spoken emoji behavior for the call
   * If not set, uses default behavior based on model of choice
   * If 'true', adds spoken emoji formatting for the request. This will replace
   * spoken emojis with the corresponding Unicode symbols in the final
   * transcript. If 'false', spoken emojis are not replaced.
   *
   * @generated from field: google.protobuf.BoolValue enable_spoken_emojis = 23;
   */
  enableSpokenEmojis?: boolean;

  /**
   * If 'true', enables speaker detection for each recognized word in
   * the top alternative of the recognition result using a speaker_tag provided
   * in the WordInfo.
   * Note: Use diarization_config instead.
   *
   * @generated from field: bool enable_speaker_diarization = 16 [deprecated = true];
   * @deprecated
   */
  enableSpeakerDiarization: boolean;

  /**
   * If set, specifies the estimated number of speakers in the conversation.
   * Defaults to '2'. Ignored unless enable_speaker_diarization is set to true.
   * Note: Use diarization_config instead.
   *
   * @generated from field: int32 diarization_speaker_count = 17 [deprecated = true];
   * @deprecated
   */
  diarizationSpeakerCount: number;

  /**
   * Config to enable speaker diarization and set additional
   * parameters to make diarization better suited for your application.
   * Note: When this is enabled, we send all the words from the beginning of the
   * audio for the top alternative in every consecutive STREAMING responses.
   * This is done in order to improve our speaker tags as our models learn to
   * identify the speakers in the conversation over time.
   * For non-streaming requests, the diarization results will be provided only
   * in the top alternative of the FINAL SpeechRecognitionResult.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.SpeakerDiarizationConfig diarization_config = 19;
   */
  diarizationConfig?: SpeakerDiarizationConfig;

  /**
   * Metadata regarding this request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionMetadata metadata = 9;
   */
  metadata?: RecognitionMetadata;

  /**
   * Which model to select for the given request. Select the model
   * best suited to your domain to get best results. If a model is not
   * explicitly specified, then we auto-select a model based on the parameters
   * in the RecognitionConfig.
   * <table>
   *   <tr>
   *     <td><b>Model</b></td>
   *     <td><b>Description</b></td>
   *   </tr>
   *   <tr>
   *     <td><code>latest_long</code></td>
   *     <td>Best for long form content like media or conversation.</td>
   *   </tr>
   *   <tr>
   *     <td><code>latest_short</code></td>
   *     <td>Best for short form content like commands or single shot directed
   *     speech.</td>
   *   </tr>
   *   <tr>
   *     <td><code>command_and_search</code></td>
   *     <td>Best for short queries such as voice commands or voice search.</td>
   *   </tr>
   *   <tr>
   *     <td><code>phone_call</code></td>
   *     <td>Best for audio that originated from a phone call (typically
   *     recorded at an 8khz sampling rate).</td>
   *   </tr>
   *   <tr>
   *     <td><code>video</code></td>
   *     <td>Best for audio that originated from video or includes multiple
   *         speakers. Ideally the audio is recorded at a 16khz or greater
   *         sampling rate. This is a premium model that costs more than the
   *         standard rate.</td>
   *   </tr>
   *   <tr>
   *     <td><code>default</code></td>
   *     <td>Best for audio that is not one of the specific audio models.
   *         For example, long-form audio. Ideally the audio is high-fidelity,
   *         recorded at a 16khz or greater sampling rate.</td>
   *   </tr>
   *   <tr>
   *     <td><code>medical_conversation</code></td>
   *     <td>Best for audio that originated from a conversation between a
   *         medical provider and patient.</td>
   *   </tr>
   *   <tr>
   *     <td><code>medical_dictation</code></td>
   *     <td>Best for audio that originated from dictation notes by a medical
   *         provider.</td>
   *   </tr>
   * </table>
   *
   * @generated from field: string model = 13;
   */
  model: string;

  /**
   * Set to true to use an enhanced model for speech recognition.
   * If `use_enhanced` is set to true and the `model` field is not set, then
   * an appropriate enhanced model is chosen if an enhanced model exists for
   * the audio.
   *
   * If `use_enhanced` is true and an enhanced version of the specified model
   * does not exist, then the speech is recognized using the standard version
   * of the specified model.
   *
   * @generated from field: bool use_enhanced = 14;
   */
  useEnhanced: boolean;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.RecognitionConfig.
 * Use `create(RecognitionConfigSchema)` to create a new message.
 */
export const RecognitionConfigSchema: GenMessage<RecognitionConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 5);

/**
 * The encoding of the audio data sent in the request.
 *
 * All encodings support only 1 channel (mono) audio, unless the
 * `audio_channel_count` and `enable_separate_recognition_per_channel` fields
 * are set.
 *
 * For best results, the audio source should be captured and transmitted using
 * a lossless encoding (`FLAC` or `LINEAR16`). The accuracy of the speech
 * recognition can be reduced if lossy codecs are used to capture or transmit
 * audio, particularly if background noise is present. Lossy codecs include
 * `MULAW`, `AMR`, `AMR_WB`, `OGG_OPUS`, `SPEEX_WITH_HEADER_BYTE`, `MP3`,
 * and `WEBM_OPUS`.
 *
 * The `FLAC` and `WAV` audio file formats include a header that describes the
 * included audio content. You can request recognition for `WAV` files that
 * contain either `LINEAR16` or `MULAW` encoded audio.
 * If you send `FLAC` or `WAV` audio file format in
 * your request, you do not need to specify an `AudioEncoding`; the audio
 * encoding format is determined from the file header. If you specify
 * an `AudioEncoding` when you send  send `FLAC` or `WAV` audio, the
 * encoding configuration must match the encoding described in the audio
 * header; otherwise the request returns an
 * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error
 * code.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding
 */
export enum RecognitionConfig_AudioEncoding {
  /**
   * Not specified.
   *
   * @generated from enum value: ENCODING_UNSPECIFIED = 0;
   */
  ENCODING_UNSPECIFIED = 0,

  /**
   * Uncompressed 16-bit signed little-endian samples (Linear PCM).
   *
   * @generated from enum value: LINEAR16 = 1;
   */
  LINEAR16 = 1,

  /**
   * `FLAC` (Free Lossless Audio
   * Codec) is the recommended encoding because it is
   * lossless--therefore recognition is not compromised--and
   * requires only about half the bandwidth of `LINEAR16`. `FLAC` stream
   * encoding supports 16-bit and 24-bit samples, however, not all fields in
   * `STREAMINFO` are supported.
   *
   * @generated from enum value: FLAC = 2;
   */
  FLAC = 2,

  /**
   * 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
   *
   * @generated from enum value: MULAW = 3;
   */
  MULAW = 3,

  /**
   * Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
   *
   * @generated from enum value: AMR = 4;
   */
  AMR = 4,

  /**
   * Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
   *
   * @generated from enum value: AMR_WB = 5;
   */
  AMR_WB = 5,

  /**
   * Opus encoded audio frames in Ogg container
   * ([OggOpus](https://wiki.xiph.org/OggOpus)).
   * `sample_rate_hertz` must be one of 8000, 12000, 16000, 24000, or 48000.
   *
   * @generated from enum value: OGG_OPUS = 6;
   */
  OGG_OPUS = 6,

  /**
   * Although the use of lossy encodings is not recommended, if a very low
   * bitrate encoding is required, `OGG_OPUS` is highly preferred over
   * Speex encoding. The [Speex](https://speex.org/)  encoding supported by
   * Cloud Speech API has a header byte in each block, as in MIME type
   * `audio/x-speex-with-header-byte`.
   * It is a variant of the RTP Speex encoding defined in
   * [RFC 5574](https://tools.ietf.org/html/rfc5574).
   * The stream is a sequence of blocks, one block per RTP packet. Each block
   * starts with a byte containing the length of the block, in bytes, followed
   * by one or more frames of Speex data, padded to an integral number of
   * bytes (octets) as specified in RFC 5574. In other words, each RTP header
   * is replaced with a single byte containing the block length. Only Speex
   * wideband is supported. `sample_rate_hertz` must be 16000.
   *
   * @generated from enum value: SPEEX_WITH_HEADER_BYTE = 7;
   */
  SPEEX_WITH_HEADER_BYTE = 7,

  /**
   * MP3 audio. MP3 encoding is a Beta feature and only available in
   * v1p1beta1. Support all standard MP3 bitrates (which range from 32-320
   * kbps). When using this encoding, `sample_rate_hertz` has to match the
   * sample rate of the file being used.
   *
   * @generated from enum value: MP3 = 8;
   */
  MP3 = 8,

  /**
   * Opus encoded audio frames in WebM container
   * ([OggOpus](https://wiki.xiph.org/OggOpus)). `sample_rate_hertz` must be
   * one of 8000, 12000, 16000, 24000, or 48000.
   *
   * @generated from enum value: WEBM_OPUS = 9;
   */
  WEBM_OPUS = 9,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding.
 */
export const RecognitionConfig_AudioEncodingSchema: GenEnum<RecognitionConfig_AudioEncoding> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 5, 0);

/**
 * Config to enable speaker diarization.
 *
 * @generated from message google.cloud.speech.v1p1beta1.SpeakerDiarizationConfig
 */
export type SpeakerDiarizationConfig = Message<"google.cloud.speech.v1p1beta1.SpeakerDiarizationConfig"> & {
  /**
   * If 'true', enables speaker detection for each recognized word in
   * the top alternative of the recognition result using a speaker_tag provided
   * in the WordInfo.
   *
   * @generated from field: bool enable_speaker_diarization = 1;
   */
  enableSpeakerDiarization: boolean;

  /**
   * Minimum number of speakers in the conversation. This range gives you more
   * flexibility by allowing the system to automatically determine the correct
   * number of speakers. If not set, the default value is 2.
   *
   * @generated from field: int32 min_speaker_count = 2;
   */
  minSpeakerCount: number;

  /**
   * Maximum number of speakers in the conversation. This range gives you more
   * flexibility by allowing the system to automatically determine the correct
   * number of speakers. If not set, the default value is 6.
   *
   * @generated from field: int32 max_speaker_count = 3;
   */
  maxSpeakerCount: number;

  /**
   * Output only. Unused.
   *
   * @generated from field: int32 speaker_tag = 5 [deprecated = true];
   * @deprecated
   */
  speakerTag: number;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.SpeakerDiarizationConfig.
 * Use `create(SpeakerDiarizationConfigSchema)` to create a new message.
 */
export const SpeakerDiarizationConfigSchema: GenMessage<SpeakerDiarizationConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 6);

/**
 * Description of audio data to be recognized.
 *
 * @generated from message google.cloud.speech.v1p1beta1.RecognitionMetadata
 * @deprecated
 */
export type RecognitionMetadata = Message<"google.cloud.speech.v1p1beta1.RecognitionMetadata"> & {
  /**
   * The use case most closely describing the audio content to be recognized.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionMetadata.InteractionType interaction_type = 1;
   */
  interactionType: RecognitionMetadata_InteractionType;

  /**
   * The industry vertical to which this speech recognition request most
   * closely applies. This is most indicative of the topics contained
   * in the audio.  Use the 6-digit NAICS code to identify the industry
   * vertical - see https://www.naics.com/search/.
   *
   * @generated from field: uint32 industry_naics_code_of_audio = 3;
   */
  industryNaicsCodeOfAudio: number;

  /**
   * The audio type that most closely describes the audio being recognized.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionMetadata.MicrophoneDistance microphone_distance = 4;
   */
  microphoneDistance: RecognitionMetadata_MicrophoneDistance;

  /**
   * The original media the speech was recorded on.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionMetadata.OriginalMediaType original_media_type = 5;
   */
  originalMediaType: RecognitionMetadata_OriginalMediaType;

  /**
   * The type of device the speech was recorded with.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.RecognitionMetadata.RecordingDeviceType recording_device_type = 6;
   */
  recordingDeviceType: RecognitionMetadata_RecordingDeviceType;

  /**
   * The device used to make the recording.  Examples 'Nexus 5X' or
   * 'Polycom SoundStation IP 6000' or 'POTS' or 'VoIP' or
   * 'Cardioid Microphone'.
   *
   * @generated from field: string recording_device_name = 7;
   */
  recordingDeviceName: string;

  /**
   * Mime type of the original audio file.  For example `audio/m4a`,
   * `audio/x-alaw-basic`, `audio/mp3`, `audio/3gpp`.
   * A list of possible audio mime types is maintained at
   * http://www.iana.org/assignments/media-types/media-types.xhtml#audio
   *
   * @generated from field: string original_mime_type = 8;
   */
  originalMimeType: string;

  /**
   * Obfuscated (privacy-protected) ID of the user, to identify number of
   * unique users using the service.
   *
   * @generated from field: int64 obfuscated_id = 9 [deprecated = true];
   * @deprecated
   */
  obfuscatedId: bigint;

  /**
   * Description of the content. Eg. "Recordings of federal supreme court
   * hearings from 2012".
   *
   * @generated from field: string audio_topic = 10;
   */
  audioTopic: string;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.RecognitionMetadata.
 * Use `create(RecognitionMetadataSchema)` to create a new message.
 * @deprecated
 */
export const RecognitionMetadataSchema: GenMessage<RecognitionMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 7);

/**
 * Use case categories that the audio recognition request can be described
 * by.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.RecognitionMetadata.InteractionType
 * @deprecated
 */
export enum RecognitionMetadata_InteractionType {
  /**
   * Use case is either unknown or is something other than one of the other
   * values below.
   *
   * @generated from enum value: INTERACTION_TYPE_UNSPECIFIED = 0;
   */
  INTERACTION_TYPE_UNSPECIFIED = 0,

  /**
   * Multiple people in a conversation or discussion. For example in a
   * meeting with two or more people actively participating. Typically
   * all the primary people speaking would be in the same room (if not,
   * see PHONE_CALL)
   *
   * @generated from enum value: DISCUSSION = 1;
   */
  DISCUSSION = 1,

  /**
   * One or more persons lecturing or presenting to others, mostly
   * uninterrupted.
   *
   * @generated from enum value: PRESENTATION = 2;
   */
  PRESENTATION = 2,

  /**
   * A phone-call or video-conference in which two or more people, who are
   * not in the same room, are actively participating.
   *
   * @generated from enum value: PHONE_CALL = 3;
   */
  PHONE_CALL = 3,

  /**
   * A recorded message intended for another person to listen to.
   *
   * @generated from enum value: VOICEMAIL = 4;
   */
  VOICEMAIL = 4,

  /**
   * Professionally produced audio (eg. TV Show, Podcast).
   *
   * @generated from enum value: PROFESSIONALLY_PRODUCED = 5;
   */
  PROFESSIONALLY_PRODUCED = 5,

  /**
   * Transcribe spoken questions and queries into text.
   *
   * @generated from enum value: VOICE_SEARCH = 6;
   */
  VOICE_SEARCH = 6,

  /**
   * Transcribe voice commands, such as for controlling a device.
   *
   * @generated from enum value: VOICE_COMMAND = 7;
   */
  VOICE_COMMAND = 7,

  /**
   * Transcribe speech to text to create a written document, such as a
   * text-message, email or report.
   *
   * @generated from enum value: DICTATION = 8;
   */
  DICTATION = 8,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.RecognitionMetadata.InteractionType.
 * @deprecated
 */
export const RecognitionMetadata_InteractionTypeSchema: GenEnum<RecognitionMetadata_InteractionType> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 7, 0);

/**
 * Enumerates the types of capture settings describing an audio file.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.RecognitionMetadata.MicrophoneDistance
 * @deprecated
 */
export enum RecognitionMetadata_MicrophoneDistance {
  /**
   * Audio type is not known.
   *
   * @generated from enum value: MICROPHONE_DISTANCE_UNSPECIFIED = 0;
   */
  MICROPHONE_DISTANCE_UNSPECIFIED = 0,

  /**
   * The audio was captured from a closely placed microphone. Eg. phone,
   * dictaphone, or handheld microphone. Generally if there speaker is within
   * 1 meter of the microphone.
   *
   * @generated from enum value: NEARFIELD = 1;
   */
  NEARFIELD = 1,

  /**
   * The speaker if within 3 meters of the microphone.
   *
   * @generated from enum value: MIDFIELD = 2;
   */
  MIDFIELD = 2,

  /**
   * The speaker is more than 3 meters away from the microphone.
   *
   * @generated from enum value: FARFIELD = 3;
   */
  FARFIELD = 3,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.RecognitionMetadata.MicrophoneDistance.
 * @deprecated
 */
export const RecognitionMetadata_MicrophoneDistanceSchema: GenEnum<RecognitionMetadata_MicrophoneDistance> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 7, 1);

/**
 * The original media the speech was recorded on.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.RecognitionMetadata.OriginalMediaType
 * @deprecated
 */
export enum RecognitionMetadata_OriginalMediaType {
  /**
   * Unknown original media type.
   *
   * @generated from enum value: ORIGINAL_MEDIA_TYPE_UNSPECIFIED = 0;
   */
  ORIGINAL_MEDIA_TYPE_UNSPECIFIED = 0,

  /**
   * The speech data is an audio recording.
   *
   * @generated from enum value: AUDIO = 1;
   */
  AUDIO = 1,

  /**
   * The speech data originally recorded on a video.
   *
   * @generated from enum value: VIDEO = 2;
   */
  VIDEO = 2,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.RecognitionMetadata.OriginalMediaType.
 * @deprecated
 */
export const RecognitionMetadata_OriginalMediaTypeSchema: GenEnum<RecognitionMetadata_OriginalMediaType> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 7, 2);

/**
 * The type of device the speech was recorded with.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.RecognitionMetadata.RecordingDeviceType
 * @deprecated
 */
export enum RecognitionMetadata_RecordingDeviceType {
  /**
   * The recording device is unknown.
   *
   * @generated from enum value: RECORDING_DEVICE_TYPE_UNSPECIFIED = 0;
   */
  RECORDING_DEVICE_TYPE_UNSPECIFIED = 0,

  /**
   * Speech was recorded on a smartphone.
   *
   * @generated from enum value: SMARTPHONE = 1;
   */
  SMARTPHONE = 1,

  /**
   * Speech was recorded using a personal computer or tablet.
   *
   * @generated from enum value: PC = 2;
   */
  PC = 2,

  /**
   * Speech was recorded over a phone line.
   *
   * @generated from enum value: PHONE_LINE = 3;
   */
  PHONE_LINE = 3,

  /**
   * Speech was recorded in a vehicle.
   *
   * @generated from enum value: VEHICLE = 4;
   */
  VEHICLE = 4,

  /**
   * Speech was recorded outdoors.
   *
   * @generated from enum value: OTHER_OUTDOOR_DEVICE = 5;
   */
  OTHER_OUTDOOR_DEVICE = 5,

  /**
   * Speech was recorded indoors.
   *
   * @generated from enum value: OTHER_INDOOR_DEVICE = 6;
   */
  OTHER_INDOOR_DEVICE = 6,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.RecognitionMetadata.RecordingDeviceType.
 * @deprecated
 */
export const RecognitionMetadata_RecordingDeviceTypeSchema: GenEnum<RecognitionMetadata_RecordingDeviceType> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 7, 3);

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 *
 * @generated from message google.cloud.speech.v1p1beta1.SpeechContext
 */
export type SpeechContext = Message<"google.cloud.speech.v1p1beta1.SpeechContext"> & {
  /**
   * A list of strings containing words and phrases "hints" so that
   * the speech recognition is more likely to recognize them. This can be used
   * to improve the accuracy for specific words and phrases, for example, if
   * specific commands are typically spoken by the user. This can also be used
   * to add additional words to the vocabulary of the recognizer. See
   * [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
   *
   * List items can also be set to classes for groups of words that represent
   * common concepts that occur in natural language. For example, rather than
   * providing phrase hints for every month of the year, using the $MONTH class
   * improves the likelihood of correctly transcribing audio that includes
   * months.
   *
   * @generated from field: repeated string phrases = 1;
   */
  phrases: string[];

  /**
   * Hint Boost. Positive value will increase the probability that a specific
   * phrase will be recognized over other similar sounding phrases. The higher
   * the boost, the higher the chance of false positive recognition as well.
   * Negative boost values would correspond to anti-biasing. Anti-biasing is not
   * enabled, so negative boost will simply be ignored. Though `boost` can
   * accept a wide range of positive values, most use cases are best served with
   * values between 0 and 20. We recommend using a binary search approach to
   * finding the optimal value for your use case.
   *
   * @generated from field: float boost = 4;
   */
  boost: number;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.SpeechContext.
 * Use `create(SpeechContextSchema)` to create a new message.
 */
export const SpeechContextSchema: GenMessage<SpeechContext> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 8);

/**
 * Contains audio data in the encoding specified in the `RecognitionConfig`.
 * Either `content` or `uri` must be supplied. Supplying both or neither
 * returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
 * See [content limits](https://cloud.google.com/speech-to-text/quotas#content).
 *
 * @generated from message google.cloud.speech.v1p1beta1.RecognitionAudio
 */
export type RecognitionAudio = Message<"google.cloud.speech.v1p1beta1.RecognitionAudio"> & {
  /**
   * The audio source, which is either inline content or a Google Cloud
   * Storage uri.
   *
   * @generated from oneof google.cloud.speech.v1p1beta1.RecognitionAudio.audio_source
   */
  audioSource: {
    /**
     * The audio data bytes encoded as specified in
     * `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
     * pure binary representation, whereas JSON representations use base64.
     *
     * @generated from field: bytes content = 1;
     */
    value: Uint8Array;
    case: "content";
  } | {
    /**
     * URI that points to a file that contains audio data bytes as specified in
     * `RecognitionConfig`. The file must not be compressed (for example, gzip).
     * Currently, only Google Cloud Storage URIs are
     * supported, which must be specified in the following format:
     * `gs://bucket_name/object_name` (other URI formats return
     * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]).
     * For more information, see [Request
     * URIs](https://cloud.google.com/storage/docs/reference-uris).
     *
     * @generated from field: string uri = 2;
     */
    value: string;
    case: "uri";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.RecognitionAudio.
 * Use `create(RecognitionAudioSchema)` to create a new message.
 */
export const RecognitionAudioSchema: GenMessage<RecognitionAudio> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 9);

/**
 * The only message returned to the client by the `Recognize` method. It
 * contains the result as zero or more sequential `SpeechRecognitionResult`
 * messages.
 *
 * @generated from message google.cloud.speech.v1p1beta1.RecognizeResponse
 */
export type RecognizeResponse = Message<"google.cloud.speech.v1p1beta1.RecognizeResponse"> & {
  /**
   * Sequential list of transcription results corresponding to
   * sequential portions of audio.
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.SpeechRecognitionResult results = 2;
   */
  results: SpeechRecognitionResult[];

  /**
   * When available, billed audio seconds for the corresponding request.
   *
   * @generated from field: google.protobuf.Duration total_billed_time = 3;
   */
  totalBilledTime?: Duration;

  /**
   * Provides information on adaptation behavior in response
   *
   * @generated from field: google.cloud.speech.v1p1beta1.SpeechAdaptationInfo speech_adaptation_info = 7;
   */
  speechAdaptationInfo?: SpeechAdaptationInfo;

  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   *
   * @generated from field: int64 request_id = 8;
   */
  requestId: bigint;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.RecognizeResponse.
 * Use `create(RecognizeResponseSchema)` to create a new message.
 */
export const RecognizeResponseSchema: GenMessage<RecognizeResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 10);

/**
 * The only message returned to the client by the `LongRunningRecognize` method.
 * It contains the result as zero or more sequential `SpeechRecognitionResult`
 * messages. It is included in the `result.response` field of the `Operation`
 * returned by the `GetOperation` call of the `google::longrunning::Operations`
 * service.
 *
 * @generated from message google.cloud.speech.v1p1beta1.LongRunningRecognizeResponse
 */
export type LongRunningRecognizeResponse = Message<"google.cloud.speech.v1p1beta1.LongRunningRecognizeResponse"> & {
  /**
   * Sequential list of transcription results corresponding to
   * sequential portions of audio.
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.SpeechRecognitionResult results = 2;
   */
  results: SpeechRecognitionResult[];

  /**
   * When available, billed audio seconds for the corresponding request.
   *
   * @generated from field: google.protobuf.Duration total_billed_time = 3;
   */
  totalBilledTime?: Duration;

  /**
   * Original output config if present in the request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.TranscriptOutputConfig output_config = 6;
   */
  outputConfig?: TranscriptOutputConfig;

  /**
   * If the transcript output fails this field contains the relevant error.
   *
   * @generated from field: google.rpc.Status output_error = 7;
   */
  outputError?: Status;

  /**
   * Provides information on speech adaptation behavior in response
   *
   * @generated from field: google.cloud.speech.v1p1beta1.SpeechAdaptationInfo speech_adaptation_info = 8;
   */
  speechAdaptationInfo?: SpeechAdaptationInfo;

  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   *
   * @generated from field: int64 request_id = 9;
   */
  requestId: bigint;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.LongRunningRecognizeResponse.
 * Use `create(LongRunningRecognizeResponseSchema)` to create a new message.
 */
export const LongRunningRecognizeResponseSchema: GenMessage<LongRunningRecognizeResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 11);

/**
 * Describes the progress of a long-running `LongRunningRecognize` call. It is
 * included in the `metadata` field of the `Operation` returned by the
 * `GetOperation` call of the `google::longrunning::Operations` service.
 *
 * @generated from message google.cloud.speech.v1p1beta1.LongRunningRecognizeMetadata
 */
export type LongRunningRecognizeMetadata = Message<"google.cloud.speech.v1p1beta1.LongRunningRecognizeMetadata"> & {
  /**
   * Approximate percentage of audio processed thus far. Guaranteed to be 100
   * when the audio is fully processed and the results are available.
   *
   * @generated from field: int32 progress_percent = 1;
   */
  progressPercent: number;

  /**
   * Time when the request was received.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * Time of the most recent processing update.
   *
   * @generated from field: google.protobuf.Timestamp last_update_time = 3;
   */
  lastUpdateTime?: Timestamp;

  /**
   * Output only. The URI of the audio file being transcribed. Empty if the
   * audio was sent as byte content.
   *
   * @generated from field: string uri = 4;
   */
  uri: string;

  /**
   * Output only. A copy of the TranscriptOutputConfig if it was set in the
   * request.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.TranscriptOutputConfig output_config = 5;
   */
  outputConfig?: TranscriptOutputConfig;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.LongRunningRecognizeMetadata.
 * Use `create(LongRunningRecognizeMetadataSchema)` to create a new message.
 */
export const LongRunningRecognizeMetadataSchema: GenMessage<LongRunningRecognizeMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 12);

/**
 * `StreamingRecognizeResponse` is the only message returned to the client by
 * `StreamingRecognize`. A series of zero or more `StreamingRecognizeResponse`
 * messages are streamed back to the client. If there is no recognizable
 * audio, and `single_utterance` is set to false, then no messages are streamed
 * back to the client.
 *
 * Here's an example of a series of `StreamingRecognizeResponse`s that might be
 * returned while processing audio:
 *
 * 1. results { alternatives { transcript: "tube" } stability: 0.01 }
 *
 * 2. results { alternatives { transcript: "to be a" } stability: 0.01 }
 *
 * 3. results { alternatives { transcript: "to be" } stability: 0.9 }
 *    results { alternatives { transcript: " or not to be" } stability: 0.01 }
 *
 * 4. results { alternatives { transcript: "to be or not to be"
 *                             confidence: 0.92 }
 *              alternatives { transcript: "to bee or not to bee" }
 *              is_final: true }
 *
 * 5. results { alternatives { transcript: " that's" } stability: 0.01 }
 *
 * 6. results { alternatives { transcript: " that is" } stability: 0.9 }
 *    results { alternatives { transcript: " the question" } stability: 0.01 }
 *
 * 7. results { alternatives { transcript: " that is the question"
 *                             confidence: 0.98 }
 *              alternatives { transcript: " that was the question" }
 *              is_final: true }
 *
 * Notes:
 *
 * - Only two of the above responses #4 and #7 contain final results; they are
 *   indicated by `is_final: true`. Concatenating these together generates the
 *   full transcript: "to be or not to be that is the question".
 *
 * - The others contain interim `results`. #3 and #6 contain two interim
 *   `results`: the first portion has a high stability and is less likely to
 *   change; the second portion has a low stability and is very likely to
 *   change. A UI designer might choose to show only high stability `results`.
 *
 * - The specific `stability` and `confidence` values shown above are only for
 *   illustrative purposes. Actual values may vary.
 *
 * - In each response, only one of these fields will be set:
 *     `error`,
 *     `speech_event_type`, or
 *     one or more (repeated) `results`.
 *
 * @generated from message google.cloud.speech.v1p1beta1.StreamingRecognizeResponse
 */
export type StreamingRecognizeResponse = Message<"google.cloud.speech.v1p1beta1.StreamingRecognizeResponse"> & {
  /**
   * If set, returns a [google.rpc.Status][google.rpc.Status] message that
   * specifies the error for the operation.
   *
   * @generated from field: google.rpc.Status error = 1;
   */
  error?: Status;

  /**
   * This repeated list contains zero or more results that
   * correspond to consecutive portions of the audio currently being processed.
   * It contains zero or one `is_final=true` result (the newly settled portion),
   * followed by zero or more `is_final=false` results (the interim results).
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.StreamingRecognitionResult results = 2;
   */
  results: StreamingRecognitionResult[];

  /**
   * Indicates the type of speech event.
   *
   * @generated from field: google.cloud.speech.v1p1beta1.StreamingRecognizeResponse.SpeechEventType speech_event_type = 4;
   */
  speechEventType: StreamingRecognizeResponse_SpeechEventType;

  /**
   * Time offset between the beginning of the audio and event emission.
   *
   * @generated from field: google.protobuf.Duration speech_event_time = 8;
   */
  speechEventTime?: Duration;

  /**
   * When available, billed audio seconds for the stream.
   * Set only if this is the last response in the stream.
   *
   * @generated from field: google.protobuf.Duration total_billed_time = 5;
   */
  totalBilledTime?: Duration;

  /**
   * Provides information on adaptation behavior in response
   *
   * @generated from field: google.cloud.speech.v1p1beta1.SpeechAdaptationInfo speech_adaptation_info = 9;
   */
  speechAdaptationInfo?: SpeechAdaptationInfo;

  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   *
   * @generated from field: int64 request_id = 10;
   */
  requestId: bigint;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.StreamingRecognizeResponse.
 * Use `create(StreamingRecognizeResponseSchema)` to create a new message.
 */
export const StreamingRecognizeResponseSchema: GenMessage<StreamingRecognizeResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 13);

/**
 * Indicates the type of speech event.
 *
 * @generated from enum google.cloud.speech.v1p1beta1.StreamingRecognizeResponse.SpeechEventType
 */
export enum StreamingRecognizeResponse_SpeechEventType {
  /**
   * No speech event specified.
   *
   * @generated from enum value: SPEECH_EVENT_UNSPECIFIED = 0;
   */
  SPEECH_EVENT_UNSPECIFIED = 0,

  /**
   * This event indicates that the server has detected the end of the user's
   * speech utterance and expects no additional speech. Therefore, the server
   * will not process additional audio (although it may subsequently return
   * additional results). The client should stop sending additional audio
   * data, half-close the gRPC connection, and wait for any additional results
   * until the server closes the gRPC connection. This event is only sent if
   * `single_utterance` was set to `true`, and is not used otherwise.
   *
   * @generated from enum value: END_OF_SINGLE_UTTERANCE = 1;
   */
  END_OF_SINGLE_UTTERANCE = 1,

  /**
   * This event indicates that the server has detected the beginning of human
   * voice activity in the stream. This event can be returned multiple times
   * if speech starts and stops repeatedly throughout the stream. This event
   * is only sent if `voice_activity_events` is set to true.
   *
   * @generated from enum value: SPEECH_ACTIVITY_BEGIN = 2;
   */
  SPEECH_ACTIVITY_BEGIN = 2,

  /**
   * This event indicates that the server has detected the end of human voice
   * activity in the stream. This event can be returned multiple times if
   * speech starts and stops repeatedly throughout the stream. This event is
   * only sent if `voice_activity_events` is set to true.
   *
   * @generated from enum value: SPEECH_ACTIVITY_END = 3;
   */
  SPEECH_ACTIVITY_END = 3,

  /**
   * This event indicates that the user-set timeout for speech activity begin
   * or end has exceeded. Upon receiving this event, the client is expected to
   * send a half close. Further audio will not be processed.
   *
   * @generated from enum value: SPEECH_ACTIVITY_TIMEOUT = 4;
   */
  SPEECH_ACTIVITY_TIMEOUT = 4,
}

/**
 * Describes the enum google.cloud.speech.v1p1beta1.StreamingRecognizeResponse.SpeechEventType.
 */
export const StreamingRecognizeResponse_SpeechEventTypeSchema: GenEnum<StreamingRecognizeResponse_SpeechEventType> = /*@__PURE__*/
  enumDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 13, 0);

/**
 * A streaming speech recognition result corresponding to a portion of the audio
 * that is currently being processed.
 *
 * @generated from message google.cloud.speech.v1p1beta1.StreamingRecognitionResult
 */
export type StreamingRecognitionResult = Message<"google.cloud.speech.v1p1beta1.StreamingRecognitionResult"> & {
  /**
   * May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   * These alternatives are ordered in terms of accuracy, with the top (first)
   * alternative being the most probable, as ranked by the recognizer.
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative alternatives = 1;
   */
  alternatives: SpeechRecognitionAlternative[];

  /**
   * If `false`, this `StreamingRecognitionResult` represents an
   * interim result that may change. If `true`, this is the final time the
   * speech service will return this particular `StreamingRecognitionResult`,
   * the recognizer will not return any further hypotheses for this portion of
   * the transcript and corresponding audio.
   *
   * @generated from field: bool is_final = 2;
   */
  isFinal: boolean;

  /**
   * An estimate of the likelihood that the recognizer will not
   * change its guess about this interim result. Values range from 0.0
   * (completely unstable) to 1.0 (completely stable).
   * This field is only provided for interim results (`is_final=false`).
   * The default of 0.0 is a sentinel value indicating `stability` was not set.
   *
   * @generated from field: float stability = 3;
   */
  stability: number;

  /**
   * Time offset of the end of this result relative to the
   * beginning of the audio.
   *
   * @generated from field: google.protobuf.Duration result_end_time = 4;
   */
  resultEndTime?: Duration;

  /**
   * For multi-channel audio, this is the channel number corresponding to the
   * recognized result for the audio from that channel.
   * For audio_channel_count = N, its output values can range from '1' to 'N'.
   *
   * @generated from field: int32 channel_tag = 5;
   */
  channelTag: number;

  /**
   * Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag of the language in this result. This language code was
   * detected to have the most likelihood of being spoken in the audio.
   *
   * @generated from field: string language_code = 6;
   */
  languageCode: string;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.StreamingRecognitionResult.
 * Use `create(StreamingRecognitionResultSchema)` to create a new message.
 */
export const StreamingRecognitionResultSchema: GenMessage<StreamingRecognitionResult> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 14);

/**
 * A speech recognition result corresponding to a portion of the audio.
 *
 * @generated from message google.cloud.speech.v1p1beta1.SpeechRecognitionResult
 */
export type SpeechRecognitionResult = Message<"google.cloud.speech.v1p1beta1.SpeechRecognitionResult"> & {
  /**
   * May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   * These alternatives are ordered in terms of accuracy, with the top (first)
   * alternative being the most probable, as ranked by the recognizer.
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative alternatives = 1;
   */
  alternatives: SpeechRecognitionAlternative[];

  /**
   * For multi-channel audio, this is the channel number corresponding to the
   * recognized result for the audio from that channel.
   * For audio_channel_count = N, its output values can range from '1' to 'N'.
   *
   * @generated from field: int32 channel_tag = 2;
   */
  channelTag: number;

  /**
   * Time offset of the end of this result relative to the
   * beginning of the audio.
   *
   * @generated from field: google.protobuf.Duration result_end_time = 4;
   */
  resultEndTime?: Duration;

  /**
   * Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag of the language in this result. This language code was
   * detected to have the most likelihood of being spoken in the audio.
   *
   * @generated from field: string language_code = 5;
   */
  languageCode: string;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.SpeechRecognitionResult.
 * Use `create(SpeechRecognitionResultSchema)` to create a new message.
 */
export const SpeechRecognitionResultSchema: GenMessage<SpeechRecognitionResult> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 15);

/**
 * Alternative hypotheses (a.k.a. n-best list).
 *
 * @generated from message google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative
 */
export type SpeechRecognitionAlternative = Message<"google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative"> & {
  /**
   * Transcript text representing the words that the user spoke.
   * In languages that use spaces to separate words, the transcript might have a
   * leading space if it isn't the first result. You can concatenate each result
   * to obtain the full transcript without using a separator.
   *
   * @generated from field: string transcript = 1;
   */
  transcript: string;

  /**
   * The confidence estimate between 0.0 and 1.0. A higher number
   * indicates an estimated greater likelihood that the recognized words are
   * correct. This field is set only for the top alternative of a non-streaming
   * result or, of a streaming result where `is_final=true`.
   * This field is not guaranteed to be accurate and users should not rely on it
   * to be always provided.
   * The default of 0.0 is a sentinel value indicating `confidence` was not set.
   *
   * @generated from field: float confidence = 2;
   */
  confidence: number;

  /**
   * A list of word-specific information for each recognized word.
   * Note: When `enable_speaker_diarization` is true, you will see all the words
   * from the beginning of the audio.
   *
   * @generated from field: repeated google.cloud.speech.v1p1beta1.WordInfo words = 3;
   */
  words: WordInfo[];
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative.
 * Use `create(SpeechRecognitionAlternativeSchema)` to create a new message.
 */
export const SpeechRecognitionAlternativeSchema: GenMessage<SpeechRecognitionAlternative> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 16);

/**
 * Word-specific information for recognized words.
 *
 * @generated from message google.cloud.speech.v1p1beta1.WordInfo
 */
export type WordInfo = Message<"google.cloud.speech.v1p1beta1.WordInfo"> & {
  /**
   * Time offset relative to the beginning of the audio,
   * and corresponding to the start of the spoken word.
   * This field is only set if `enable_word_time_offsets=true` and only
   * in the top hypothesis.
   * This is an experimental feature and the accuracy of the time offset can
   * vary.
   *
   * @generated from field: google.protobuf.Duration start_time = 1;
   */
  startTime?: Duration;

  /**
   * Time offset relative to the beginning of the audio,
   * and corresponding to the end of the spoken word.
   * This field is only set if `enable_word_time_offsets=true` and only
   * in the top hypothesis.
   * This is an experimental feature and the accuracy of the time offset can
   * vary.
   *
   * @generated from field: google.protobuf.Duration end_time = 2;
   */
  endTime?: Duration;

  /**
   * The word corresponding to this set of information.
   *
   * @generated from field: string word = 3;
   */
  word: string;

  /**
   * The confidence estimate between 0.0 and 1.0. A higher number
   * indicates an estimated greater likelihood that the recognized words are
   * correct. This field is set only for the top alternative of a non-streaming
   * result or, of a streaming result where `is_final=true`.
   * This field is not guaranteed to be accurate and users should not rely on it
   * to be always provided.
   * The default of 0.0 is a sentinel value indicating `confidence` was not set.
   *
   * @generated from field: float confidence = 4;
   */
  confidence: number;

  /**
   * Output only. A distinct integer value is assigned for every speaker within
   * the audio. This field specifies which one of those speakers was detected to
   * have spoken this word. Value ranges from '1' to diarization_speaker_count.
   * speaker_tag is set if enable_speaker_diarization = 'true' and only in the
   * top alternative.
   *
   * @generated from field: int32 speaker_tag = 5;
   */
  speakerTag: number;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.WordInfo.
 * Use `create(WordInfoSchema)` to create a new message.
 */
export const WordInfoSchema: GenMessage<WordInfo> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 17);

/**
 * Information on speech adaptation use in results
 *
 * @generated from message google.cloud.speech.v1p1beta1.SpeechAdaptationInfo
 */
export type SpeechAdaptationInfo = Message<"google.cloud.speech.v1p1beta1.SpeechAdaptationInfo"> & {
  /**
   * Whether there was a timeout when applying speech adaptation. If true,
   * adaptation had no effect in the response transcript.
   *
   * @generated from field: bool adaptation_timeout = 1;
   */
  adaptationTimeout: boolean;

  /**
   * If set, returns a message specifying which part of the speech adaptation
   * request timed out.
   *
   * @generated from field: string timeout_message = 4;
   */
  timeoutMessage: string;
};

/**
 * Describes the message google.cloud.speech.v1p1beta1.SpeechAdaptationInfo.
 * Use `create(SpeechAdaptationInfoSchema)` to create a new message.
 */
export const SpeechAdaptationInfoSchema: GenMessage<SpeechAdaptationInfo> = /*@__PURE__*/
  messageDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 18);

/**
 * Service that implements Google Cloud Speech API.
 *
 * @generated from service google.cloud.speech.v1p1beta1.Speech
 */
export const Speech: GenService<{
  /**
   * Performs synchronous speech recognition: receive results after all audio
   * has been sent and processed.
   *
   * @generated from rpc google.cloud.speech.v1p1beta1.Speech.Recognize
   */
  recognize: {
    methodKind: "unary";
    input: typeof RecognizeRequestSchema;
    output: typeof RecognizeResponseSchema;
  },
  /**
   * Performs asynchronous speech recognition: receive results via the
   * google.longrunning.Operations interface. Returns either an
   * `Operation.error` or an `Operation.response` which contains
   * a `LongRunningRecognizeResponse` message.
   * For more information on asynchronous speech recognition, see the
   * [how-to](https://cloud.google.com/speech-to-text/docs/async-recognize).
   *
   * @generated from rpc google.cloud.speech.v1p1beta1.Speech.LongRunningRecognize
   */
  longRunningRecognize: {
    methodKind: "unary";
    input: typeof LongRunningRecognizeRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Performs bidirectional streaming speech recognition: receive results while
   * sending audio. This method is only available via the gRPC API (not REST).
   *
   * @generated from rpc google.cloud.speech.v1p1beta1.Speech.StreamingRecognize
   */
  streamingRecognize: {
    methodKind: "bidi_streaming";
    input: typeof StreamingRecognizeRequestSchema;
    output: typeof StreamingRecognizeResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_cloud_speech_v1p1beta1_cloud_speech, 0);

