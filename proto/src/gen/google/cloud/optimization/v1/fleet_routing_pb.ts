// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/optimization/v1/fleet_routing.proto (package google.cloud.optimization.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import type { InputConfig, OutputConfig } from "./async_model_pb";
import { file_google_cloud_optimization_v1_async_model } from "./async_model_pb";
import type { OperationSchema } from "../../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../../longrunning/operations_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { LatLng } from "../../../type/latlng_pb";
import { file_google_type_latlng } from "../../../type/latlng_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/optimization/v1/fleet_routing.proto.
 */
export const file_google_cloud_optimization_v1_fleet_routing: GenFile = /*@__PURE__*/
  fileDesc("CjBnb29nbGUvY2xvdWQvb3B0aW1pemF0aW9uL3YxL2ZsZWV0X3JvdXRpbmcucHJvdG8SHGdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEipAkKFE9wdGltaXplVG91cnNSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECEioKB3RpbWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOgoFbW9kZWwYAyABKAsyKy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50TW9kZWwSVAoMc29sdmluZ19tb2RlGAQgASgOMj4uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5PcHRpbWl6ZVRvdXJzUmVxdWVzdC5Tb2x2aW5nTW9kZRJSCgtzZWFyY2hfbW9kZRgGIAEoDjI9Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuT3B0aW1pemVUb3Vyc1JlcXVlc3QuU2VhcmNoTW9kZRJTCh5pbmplY3RlZF9maXJzdF9zb2x1dGlvbl9yb3V0ZXMYByADKAsyKy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUSXgocaW5qZWN0ZWRfc29sdXRpb25fY29uc3RyYWludBgIIAEoCzI4Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuSW5qZWN0ZWRTb2x1dGlvbkNvbnN0cmFpbnQSSwoWcmVmcmVzaF9kZXRhaWxzX3JvdXRlcxgJIAMoCzIrLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZRIxCilpbnRlcnByZXRfaW5qZWN0ZWRfc29sdXRpb25zX3VzaW5nX2xhYmVscxgKIAEoCBIdChVjb25zaWRlcl9yb2FkX3RyYWZmaWMYCyABKAgSGgoScG9wdWxhdGVfcG9seWxpbmVzGAwgASgIEiUKHXBvcHVsYXRlX3RyYW5zaXRpb25fcG9seWxpbmVzGA0gASgIEjYKLmFsbG93X2xhcmdlX2RlYWRsaW5lX2Rlc3BpdGVfaW50ZXJydXB0aW9uX3Jpc2sYDiABKAgSHgoWdXNlX2dlb2Rlc2ljX2Rpc3RhbmNlcxgPIAEoCBInChpnZW9kZXNpY19tZXRlcnNfcGVyX3NlY29uZBgQIAEoAUgAiAEBEiIKFW1heF92YWxpZGF0aW9uX2Vycm9ycxgFIAEoBUgBiAEBEg0KBWxhYmVsGBEgASgJEioKHnBvcHVsYXRlX3RyYXZlbF9zdGVwX3BvbHlsaW5lcxgUIAEoCEICGAEiWQoLU29sdmluZ01vZGUSEQoNREVGQVVMVF9TT0xWRRAAEhEKDVZBTElEQVRFX09OTFkQARIkCiBERVRFQ1RfU09NRV9JTkZFQVNJQkxFX1NISVBNRU5UUxACIloKClNlYXJjaE1vZGUSGwoXU0VBUkNIX01PREVfVU5TUEVDSUZJRUQQABIPCgtSRVRVUk5fRkFTVBABEh4KGkNPTlNVTUVfQUxMX0FWQUlMQUJMRV9USU1FEAJCHQobX2dlb2Rlc2ljX21ldGVyc19wZXJfc2Vjb25kQhgKFl9tYXhfdmFsaWRhdGlvbl9lcnJvcnMirgYKFU9wdGltaXplVG91cnNSZXNwb25zZRI7CgZyb3V0ZXMYASADKAsyKy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUSFQoNcmVxdWVzdF9sYWJlbBgDIAEoCRJIChFza2lwcGVkX3NoaXBtZW50cxgEIAMoCzItLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2tpcHBlZFNoaXBtZW50ElUKEXZhbGlkYXRpb25fZXJyb3JzGAUgAygLMjouZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5PcHRpbWl6ZVRvdXJzVmFsaWRhdGlvbkVycm9yEkwKB21ldHJpY3MYBiABKAsyOy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91cnNSZXNwb25zZS5NZXRyaWNzEhYKCnRvdGFsX2Nvc3QYAiABKAFCAhgBGrkDCgdNZXRyaWNzElEKGGFnZ3JlZ2F0ZWRfcm91dGVfbWV0cmljcxgBIAEoCzIvLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuQWdncmVnYXRlZE1ldHJpY3MSKAogc2tpcHBlZF9tYW5kYXRvcnlfc2hpcG1lbnRfY291bnQYAiABKAUSGgoSdXNlZF92ZWhpY2xlX2NvdW50GAMgASgFEj8KG2VhcmxpZXN0X3ZlaGljbGVfc3RhcnRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASOwoXbGF0ZXN0X3ZlaGljbGVfZW5kX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wElUKBWNvc3RzGAogAygLMkYuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5PcHRpbWl6ZVRvdXJzUmVzcG9uc2UuTWV0cmljcy5Db3N0c0VudHJ5EhIKCnRvdGFsX2Nvc3QYBiABKAEaLAoKQ29zdHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAE6AjgBIusCChlCYXRjaE9wdGltaXplVG91cnNSZXF1ZXN0EhMKBnBhcmVudBgBIAEoCUID4EECEmQKDW1vZGVsX2NvbmZpZ3MYAiADKAsySC5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkJhdGNoT3B0aW1pemVUb3Vyc1JlcXVlc3QuQXN5bmNNb2RlbENvbmZpZ0ID4EECGtIBChBBc3luY01vZGVsQ29uZmlnEhQKDGRpc3BsYXlfbmFtZRgBIAEoCRJECgxpbnB1dF9jb25maWcYAiABKAsyKS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLklucHV0Q29uZmlnQgPgQQISRgoNb3V0cHV0X2NvbmZpZxgDIAEoCzIqLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuT3V0cHV0Q29uZmlnQgPgQQISGgoSZW5hYmxlX2NoZWNrcG9pbnRzGAQgASgIIhwKGkJhdGNoT3B0aW1pemVUb3Vyc1Jlc3BvbnNlIpoPCg1TaGlwbWVudE1vZGVsEjkKCXNoaXBtZW50cxgBIAMoCzImLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnQSNwoIdmVoaWNsZXMYAiADKAsyJS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlZlaGljbGUSIAoTbWF4X2FjdGl2ZV92ZWhpY2xlcxgEIAEoBUgAiAEBEjUKEWdsb2JhbF9zdGFydF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIzCg9nbG9iYWxfZW5kX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiUKHWdsb2JhbF9kdXJhdGlvbl9jb3N0X3Blcl9ob3VyGAcgASgBEmYKGmR1cmF0aW9uX2Rpc3RhbmNlX21hdHJpY2VzGAggAygLMkIuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudE1vZGVsLkR1cmF0aW9uRGlzdGFuY2VNYXRyaXgSKQohZHVyYXRpb25fZGlzdGFuY2VfbWF0cml4X3NyY190YWdzGAkgAygJEikKIWR1cmF0aW9uX2Rpc3RhbmNlX21hdHJpeF9kc3RfdGFncxgKIAMoCRJRChV0cmFuc2l0aW9uX2F0dHJpYnV0ZXMYCyADKAsyMi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlRyYW5zaXRpb25BdHRyaWJ1dGVzEmIKH3NoaXBtZW50X3R5cGVfaW5jb21wYXRpYmlsaXRpZXMYDCADKAsyOS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50VHlwZUluY29tcGF0aWJpbGl0eRJZChpzaGlwbWVudF90eXBlX3JlcXVpcmVtZW50cxgNIAMoCzI1Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRUeXBlUmVxdWlyZW1lbnQSVAoQcHJlY2VkZW5jZV9ydWxlcxgOIAMoCzI6Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRNb2RlbC5QcmVjZWRlbmNlUnVsZRJOCgticmVha19ydWxlcxgPIAMoCzI1Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRNb2RlbC5CcmVha1J1bGVCAhgBGs4BChZEdXJhdGlvbkRpc3RhbmNlTWF0cml4ElQKBHJvd3MYASADKAsyRi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50TW9kZWwuRHVyYXRpb25EaXN0YW5jZU1hdHJpeC5Sb3cSGQoRdmVoaWNsZV9zdGFydF90YWcYAiABKAkaQwoDUm93EiwKCWR1cmF0aW9ucxgBIAMoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIOCgZtZXRlcnMYAiADKAEa0QEKDlByZWNlZGVuY2VSdWxlEhgKC2ZpcnN0X2luZGV4GAEgASgFSACIAQESGQoRZmlyc3RfaXNfZGVsaXZlcnkYAyABKAgSGQoMc2Vjb25kX2luZGV4GAIgASgFSAGIAQESGgoSc2Vjb25kX2lzX2RlbGl2ZXJ5GAQgASgIEjIKD29mZnNldF9kdXJhdGlvbhgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIOCgxfZmlyc3RfaW5kZXhCDwoNX3NlY29uZF9pbmRleBqsBAoJQnJlYWtSdWxlEloKDmJyZWFrX3JlcXVlc3RzGAEgAygLMkIuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudE1vZGVsLkJyZWFrUnVsZS5CcmVha1JlcXVlc3QSaAoVZnJlcXVlbmN5X2NvbnN0cmFpbnRzGAIgAygLMkkuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudE1vZGVsLkJyZWFrUnVsZS5GcmVxdWVuY3lDb25zdHJhaW50Gr4BCgxCcmVha1JlcXVlc3QSPAoTZWFybGllc3Rfc3RhcnRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAhI6ChFsYXRlc3Rfc3RhcnRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAhI0CgxtaW5fZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAhqTAQoTRnJlcXVlbmN5Q29uc3RyYWludBI6ChJtaW5fYnJlYWtfZHVyYXRpb24YASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAhJAChhtYXhfaW50ZXJfYnJlYWtfZHVyYXRpb24YAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAjoCGAFCFgoUX21heF9hY3RpdmVfdmVoaWNsZXMigAwKCFNoaXBtZW50EkQKB3BpY2t1cHMYASADKAsyMy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50LlZpc2l0UmVxdWVzdBJHCgpkZWxpdmVyaWVzGAIgAygLMjMuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudC5WaXNpdFJlcXVlc3QSTQoMbG9hZF9kZW1hbmRzGA4gAygLMjcuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudC5Mb2FkRGVtYW5kc0VudHJ5EhkKDHBlbmFsdHlfY29zdBgEIAEoAUgAiAEBEh8KF2FsbG93ZWRfdmVoaWNsZV9pbmRpY2VzGAUgAygFEhkKEWNvc3RzX3Blcl92ZWhpY2xlGAYgAygBEiEKGWNvc3RzX3Blcl92ZWhpY2xlX2luZGljZXMYByADKAUSNQoocGlja3VwX3RvX2RlbGl2ZXJ5X3JlbGF0aXZlX2RldG91cl9saW1pdBgIIAEoAUgBiAEBEksKKHBpY2t1cF90b19kZWxpdmVyeV9hYnNvbHV0ZV9kZXRvdXJfbGltaXQYCSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SQAodcGlja3VwX3RvX2RlbGl2ZXJ5X3RpbWVfbGltaXQYCiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SFQoNc2hpcG1lbnRfdHlwZRgLIAEoCRINCgVsYWJlbBgMIAEoCRIOCgZpZ25vcmUYDSABKAgSQwoHZGVtYW5kcxgDIAMoCzIuLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuQ2FwYWNpdHlRdWFudGl0eUICGAEaowUKDFZpc2l0UmVxdWVzdBItChBhcnJpdmFsX2xvY2F0aW9uGAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nEkAKEGFycml2YWxfd2F5cG9pbnQYAiABKAsyJi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLldheXBvaW50Ei8KEmRlcGFydHVyZV9sb2NhdGlvbhgDIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxJCChJkZXBhcnR1cmVfd2F5cG9pbnQYBCABKAsyJi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLldheXBvaW50EgwKBHRhZ3MYBSADKAkSPgoMdGltZV93aW5kb3dzGAYgAygLMiguZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5UaW1lV2luZG93EisKCGR1cmF0aW9uGAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEgwKBGNvc3QYCCABKAESWgoMbG9hZF9kZW1hbmRzGAwgAygLMkQuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudC5WaXNpdFJlcXVlc3QuTG9hZERlbWFuZHNFbnRyeRITCgt2aXNpdF90eXBlcxgKIAMoCRINCgVsYWJlbBgLIAEoCRJDCgdkZW1hbmRzGAkgAygLMi4uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5DYXBhY2l0eVF1YW50aXR5QgIYARpfChBMb2FkRGVtYW5kc0VudHJ5EgsKA2tleRgBIAEoCRI6CgV2YWx1ZRgCIAEoCzIrLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnQuTG9hZDoCOAEaFgoETG9hZBIOCgZhbW91bnQYAiABKAMaXwoQTG9hZERlbWFuZHNFbnRyeRILCgNrZXkYASABKAkSOgoFdmFsdWUYAiABKAsyKy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50LkxvYWQ6AjgBQg8KDV9wZW5hbHR5X2Nvc3RCKwopX3BpY2t1cF90b19kZWxpdmVyeV9yZWxhdGl2ZV9kZXRvdXJfbGltaXQiogIKG1NoaXBtZW50VHlwZUluY29tcGF0aWJpbGl0eRINCgV0eXBlcxgBIAMoCRJrChRpbmNvbXBhdGliaWxpdHlfbW9kZRgCIAEoDjJNLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRUeXBlSW5jb21wYXRpYmlsaXR5LkluY29tcGF0aWJpbGl0eU1vZGUihgEKE0luY29tcGF0aWJpbGl0eU1vZGUSJAogSU5DT01QQVRJQklMSVRZX01PREVfVU5TUEVDSUZJRUQQABIhCh1OT1RfUEVSRk9STUVEX0JZX1NBTUVfVkVISUNMRRABEiYKIk5PVF9JTl9TQU1FX1ZFSElDTEVfU0lNVUxUQU5FT1VTTFkQAiLoAgoXU2hpcG1lbnRUeXBlUmVxdWlyZW1lbnQSKwojcmVxdWlyZWRfc2hpcG1lbnRfdHlwZV9hbHRlcm5hdGl2ZXMYASADKAkSIAoYZGVwZW5kZW50X3NoaXBtZW50X3R5cGVzGAIgAygJEl8KEHJlcXVpcmVtZW50X21vZGUYAyABKA4yRS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50VHlwZVJlcXVpcmVtZW50LlJlcXVpcmVtZW50TW9kZSKcAQoPUmVxdWlyZW1lbnRNb2RlEiAKHFJFUVVJUkVNRU5UX01PREVfVU5TUEVDSUZJRUQQABIdChlQRVJGT1JNRURfQllfU0FNRV9WRUhJQ0xFEAESIgoeSU5fU0FNRV9WRUhJQ0xFX0FUX1BJQ0tVUF9USU1FEAISJAogSU5fU0FNRV9WRUhJQ0xFX0FUX0RFTElWRVJZX1RJTUUQAyJvCg5Sb3V0ZU1vZGlmaWVycxITCgthdm9pZF90b2xscxgCIAEoCBIWCg5hdm9pZF9oaWdod2F5cxgDIAEoCBIVCg1hdm9pZF9mZXJyaWVzGAQgASgIEhkKDGF2b2lkX2luZG9vchgFIAEoCEID4EEBIpoVCgdWZWhpY2xlEkUKC3RyYXZlbF9tb2RlGAEgASgOMjAuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5WZWhpY2xlLlRyYXZlbE1vZGUSSgoPcm91dGVfbW9kaWZpZXJzGAIgASgLMiwuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5Sb3V0ZU1vZGlmaWVyc0ID4EEBEisKDnN0YXJ0X2xvY2F0aW9uGAMgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nEj4KDnN0YXJ0X3dheXBvaW50GAQgASgLMiYuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5XYXlwb2ludBIpCgxlbmRfbG9jYXRpb24YBSABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcSPAoMZW5kX3dheXBvaW50GAYgASgLMiYuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5XYXlwb2ludBISCgpzdGFydF90YWdzGAcgAygJEhAKCGVuZF90YWdzGAggAygJEkQKEnN0YXJ0X3RpbWVfd2luZG93cxgJIAMoCzIoLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuVGltZVdpbmRvdxJCChBlbmRfdGltZV93aW5kb3dzGAogAygLMiguZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5UaW1lV2luZG93EiUKGHRyYXZlbF9kdXJhdGlvbl9tdWx0aXBsZRgLIAEoAUgAiAEBEk8KEHVubG9hZGluZ19wb2xpY3kYDCABKA4yNS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlZlaGljbGUuVW5sb2FkaW5nUG9saWN5EkoKC2xvYWRfbGltaXRzGB4gAygLMjUuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5WZWhpY2xlLkxvYWRMaW1pdHNFbnRyeRIVCg1jb3N0X3Blcl9ob3VyGBAgASgBEh4KFmNvc3RfcGVyX3RyYXZlbGVkX2hvdXIYESABKAESGgoSY29zdF9wZXJfa2lsb21ldGVyGBIgASgBEhIKCmZpeGVkX2Nvc3QYEyABKAESHgoWdXNlZF9pZl9yb3V0ZV9pc19lbXB0eRgUIAEoCBJRChRyb3V0ZV9kdXJhdGlvbl9saW1pdBgVIAEoCzIzLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuVmVoaWNsZS5EdXJhdGlvbkxpbWl0ElIKFXRyYXZlbF9kdXJhdGlvbl9saW1pdBgWIAEoCzIzLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuVmVoaWNsZS5EdXJhdGlvbkxpbWl0EkkKFHJvdXRlX2Rpc3RhbmNlX2xpbWl0GBcgASgLMisuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5EaXN0YW5jZUxpbWl0EnYKI2V4dHJhX3Zpc2l0X2R1cmF0aW9uX2Zvcl92aXNpdF90eXBlGBggAygLMkkuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5WZWhpY2xlLkV4dHJhVmlzaXREdXJhdGlvbkZvclZpc2l0VHlwZUVudHJ5EjsKCmJyZWFrX3J1bGUYGSABKAsyJy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkJyZWFrUnVsZRINCgVsYWJlbBgbIAEoCRIOCgZpZ25vcmUYHCABKAgSHgoSYnJlYWtfcnVsZV9pbmRpY2VzGB0gAygFQgIYARJGCgpjYXBhY2l0aWVzGA0gAygLMi4uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5DYXBhY2l0eVF1YW50aXR5QgIYARJYChRzdGFydF9sb2FkX2ludGVydmFscxgOIAMoCzI2Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuQ2FwYWNpdHlRdWFudGl0eUludGVydmFsQgIYARJWChJlbmRfbG9hZF9pbnRlcnZhbHMYDyADKAsyNi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkNhcGFjaXR5UXVhbnRpdHlJbnRlcnZhbEICGAEaywIKCUxvYWRMaW1pdBIVCghtYXhfbG9hZBgBIAEoA0gAiAEBEhUKDXNvZnRfbWF4X2xvYWQYAiABKAMSJAocY29zdF9wZXJfdW5pdF9hYm92ZV9zb2Z0X21heBgDIAEoARJVChNzdGFydF9sb2FkX2ludGVydmFsGAQgASgLMjguZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5WZWhpY2xlLkxvYWRMaW1pdC5JbnRlcnZhbBJTChFlbmRfbG9hZF9pbnRlcnZhbBgFIAEoCzI4Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuVmVoaWNsZS5Mb2FkTGltaXQuSW50ZXJ2YWwaMQoISW50ZXJ2YWwSCwoDbWluGAEgASgDEhAKA21heBgCIAEoA0gAiAEBQgYKBF9tYXhCCwoJX21heF9sb2FkGvACCg1EdXJhdGlvbkxpbWl0Ei8KDG1heF9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI0ChFzb2Z0X21heF9kdXJhdGlvbhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIpChxjb3N0X3Blcl9ob3VyX2FmdGVyX3NvZnRfbWF4GAMgASgBSACIAQESPgobcXVhZHJhdGljX3NvZnRfbWF4X2R1cmF0aW9uGAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjoKLWNvc3RfcGVyX3NxdWFyZV9ob3VyX2FmdGVyX3F1YWRyYXRpY19zb2Z0X21heBgFIAEoAUgBiAEBQh8KHV9jb3N0X3Blcl9ob3VyX2FmdGVyX3NvZnRfbWF4QjAKLl9jb3N0X3Blcl9zcXVhcmVfaG91cl9hZnRlcl9xdWFkcmF0aWNfc29mdF9tYXgaYgoPTG9hZExpbWl0c0VudHJ5EgsKA2tleRgBIAEoCRI+CgV2YWx1ZRgCIAEoCzIvLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuVmVoaWNsZS5Mb2FkTGltaXQ6AjgBGmAKI0V4dHJhVmlzaXREdXJhdGlvbkZvclZpc2l0VHlwZUVudHJ5EgsKA2tleRgBIAEoCRIoCgV2YWx1ZRgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbjoCOAEiQwoKVHJhdmVsTW9kZRIbChdUUkFWRUxfTU9ERV9VTlNQRUNJRklFRBAAEgsKB0RSSVZJTkcQARILCgdXQUxLSU5HEAIiYgoPVW5sb2FkaW5nUG9saWN5EiAKHFVOTE9BRElOR19QT0xJQ1lfVU5TUEVDSUZJRUQQABIVChFMQVNUX0lOX0ZJUlNUX09VVBABEhYKEkZJUlNUX0lOX0ZJUlNUX09VVBACQhsKGV90cmF2ZWxfZHVyYXRpb25fbXVsdGlwbGUihAMKClRpbWVXaW5kb3cSLgoKc3RhcnRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLAoIZW5kX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjMKD3NvZnRfc3RhcnRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMQoNc29mdF9lbmRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMQokY29zdF9wZXJfaG91cl9iZWZvcmVfc29mdF9zdGFydF90aW1lGAUgASgBSACIAQESLgohY29zdF9wZXJfaG91cl9hZnRlcl9zb2Z0X2VuZF90aW1lGAYgASgBSAGIAQFCJwolX2Nvc3RfcGVyX2hvdXJfYmVmb3JlX3NvZnRfc3RhcnRfdGltZUIkCiJfY29zdF9wZXJfaG91cl9hZnRlcl9zb2Z0X2VuZF90aW1lIjMKEENhcGFjaXR5UXVhbnRpdHkSDAoEdHlwZRgBIAEoCRINCgV2YWx1ZRgCIAEoAzoCGAEieAoYQ2FwYWNpdHlRdWFudGl0eUludGVydmFsEgwKBHR5cGUYASABKAkSFgoJbWluX3ZhbHVlGAIgASgDSACIAQESFgoJbWF4X3ZhbHVlGAMgASgDSAGIAQE6AhgBQgwKCl9taW5fdmFsdWVCDAoKX21heF92YWx1ZSKVAgoNRGlzdGFuY2VMaW1pdBIXCgptYXhfbWV0ZXJzGAEgASgDSACIAQESHAoPc29mdF9tYXhfbWV0ZXJzGAIgASgDSAGIAQESLgohY29zdF9wZXJfa2lsb21ldGVyX2JlbG93X3NvZnRfbWF4GAQgASgBSAKIAQESLgohY29zdF9wZXJfa2lsb21ldGVyX2Fib3ZlX3NvZnRfbWF4GAMgASgBSAOIAQFCDQoLX21heF9tZXRlcnNCEgoQX3NvZnRfbWF4X21ldGVyc0IkCiJfY29zdF9wZXJfa2lsb21ldGVyX2JlbG93X3NvZnRfbWF4QiQKIl9jb3N0X3Blcl9raWxvbWV0ZXJfYWJvdmVfc29mdF9tYXgihQIKFFRyYW5zaXRpb25BdHRyaWJ1dGVzEg8KB3NyY190YWcYASABKAkSGAoQZXhjbHVkZWRfc3JjX3RhZxgCIAEoCRIPCgdkc3RfdGFnGAMgASgJEhgKEGV4Y2x1ZGVkX2RzdF90YWcYBCABKAkSDAoEY29zdBgFIAEoARIaChJjb3N0X3Blcl9raWxvbWV0ZXIYBiABKAESQwoOZGlzdGFuY2VfbGltaXQYByABKAsyKy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkRpc3RhbmNlTGltaXQSKAoFZGVsYXkYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24igQEKCFdheXBvaW50EjoKCGxvY2F0aW9uGAEgASgLMiYuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5Mb2NhdGlvbkgAEhIKCHBsYWNlX2lkGAIgASgJSAASFAoMc2lkZV9vZl9yb2FkGAMgASgIQg8KDWxvY2F0aW9uX3R5cGUiUgoITG9jYXRpb24SJAoHbGF0X2xuZxgBIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxIUCgdoZWFkaW5nGAIgASgFSACIAQFCCgoIX2hlYWRpbmcijAQKCUJyZWFrUnVsZRJMCg5icmVha19yZXF1ZXN0cxgBIAMoCzI0Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuQnJlYWtSdWxlLkJyZWFrUmVxdWVzdBJaChVmcmVxdWVuY3lfY29uc3RyYWludHMYAiADKAsyOy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkJyZWFrUnVsZS5GcmVxdWVuY3lDb25zdHJhaW50Gr4BCgxCcmVha1JlcXVlc3QSPAoTZWFybGllc3Rfc3RhcnRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAhI6ChFsYXRlc3Rfc3RhcnRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAhI0CgxtaW5fZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAhqTAQoTRnJlcXVlbmN5Q29uc3RyYWludBI6ChJtaW5fYnJlYWtfZHVyYXRpb24YASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAhJAChhtYXhfaW50ZXJfYnJlYWtfZHVyYXRpb24YAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAiLDFgoNU2hpcG1lbnRSb3V0ZRIVCg12ZWhpY2xlX2luZGV4GAEgASgFEhUKDXZlaGljbGVfbGFiZWwYAiABKAkSNgoSdmVoaWNsZV9zdGFydF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI0ChB2ZWhpY2xlX2VuZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJBCgZ2aXNpdHMYByADKAsyMS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuVmlzaXQSSwoLdHJhbnNpdGlvbnMYCCADKAsyNi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuVHJhbnNpdGlvbhIjChtoYXNfdHJhZmZpY19pbmZlYXNpYmlsaXRpZXMYCSABKAgSUwoOcm91dGVfcG9seWxpbmUYCiABKAsyOy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuRW5jb2RlZFBvbHlsaW5lEkEKBmJyZWFrcxgLIAMoCzIxLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5CcmVhaxJACgdtZXRyaWNzGAwgASgLMi8uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5BZ2dyZWdhdGVkTWV0cmljcxJQCgtyb3V0ZV9jb3N0cxgRIAMoCzI7Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5Sb3V0ZUNvc3RzRW50cnkSGAoQcm91dGVfdG90YWxfY29zdBgSIAEoARJFCgllbmRfbG9hZHMYDSADKAsyLi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkNhcGFjaXR5UXVhbnRpdHlCAhgBElAKDHRyYXZlbF9zdGVwcxgOIAMoCzI2Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5UcmF2ZWxTdGVwQgIYARI1Cg52ZWhpY2xlX2RldG91chgPIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkICGAESVwoYZGVsYXlfYmVmb3JlX3ZlaGljbGVfZW5kGBAgASgLMjEuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudFJvdXRlLkRlbGF5QgIYARpoCgVEZWxheRIuCgpzdGFydF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIrCghkdXJhdGlvbhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbjoCGAEa9QQKBVZpc2l0EhYKDnNoaXBtZW50X2luZGV4GAEgASgFEhEKCWlzX3BpY2t1cBgCIAEoCBIbChN2aXNpdF9yZXF1ZXN0X2luZGV4GAMgASgFEi4KCnN0YXJ0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wElgKDGxvYWRfZGVtYW5kcxgLIAMoCzJCLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5WaXNpdC5Mb2FkRGVtYW5kc0VudHJ5EikKBmRldG91chgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIWCg5zaGlwbWVudF9sYWJlbBgHIAEoCRITCgt2aXNpdF9sYWJlbBgIIAEoCRJJCg1hcnJpdmFsX2xvYWRzGAkgAygLMi4uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5DYXBhY2l0eVF1YW50aXR5QgIYARJRChJkZWxheV9iZWZvcmVfc3RhcnQYCiABKAsyMS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuRGVsYXlCAhgBEkMKB2RlbWFuZHMYBSADKAsyLi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkNhcGFjaXR5UXVhbnRpdHlCAhgBGl8KEExvYWREZW1hbmRzRW50cnkSCwoDa2V5GAEgASgJEjoKBXZhbHVlGAIgASgLMisuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudC5Mb2FkOgI4ARrkBQoKVHJhbnNpdGlvbhIyCg90cmF2ZWxfZHVyYXRpb24YASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SHgoWdHJhdmVsX2Rpc3RhbmNlX21ldGVycxgCIAEoARIgChh0cmFmZmljX2luZm9fdW5hdmFpbGFibGUYAyABKAgSMQoOZGVsYXlfZHVyYXRpb24YBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoOYnJlYWtfZHVyYXRpb24YBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMAoNd2FpdF9kdXJhdGlvbhgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIxCg50b3RhbF9kdXJhdGlvbhgHIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIuCgpzdGFydF90aW1lGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJTCg5yb3V0ZV9wb2x5bGluZRgJIAEoCzI7Lmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5FbmNvZGVkUG9seWxpbmUSXwoNdmVoaWNsZV9sb2FkcxgLIAMoCzJILmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5UcmFuc2l0aW9uLlZlaGljbGVMb2Fkc0VudHJ5EkEKBWxvYWRzGAogAygLMi4uZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5DYXBhY2l0eVF1YW50aXR5QgIYARpsChFWZWhpY2xlTG9hZHNFbnRyeRILCgNrZXkYASABKAkSRgoFdmFsdWUYAiABKAsyNy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuVmVoaWNsZUxvYWQ6AjgBGh0KC1ZlaGljbGVMb2FkEg4KBmFtb3VudBgBIAEoAxohCg9FbmNvZGVkUG9seWxpbmUSDgoGcG9pbnRzGAEgASgJGmQKBUJyZWFrEi4KCnN0YXJ0X3RpbWUYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEisKCGR1cmF0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uGs0BCgpUcmF2ZWxTdGVwEisKCGR1cmF0aW9uGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhcKD2Rpc3RhbmNlX21ldGVycxgCIAEoARIgChh0cmFmZmljX2luZm9fdW5hdmFpbGFibGUYAyABKAgSUwoOcm91dGVfcG9seWxpbmUYBCABKAsyOy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUuRW5jb2RlZFBvbHlsaW5lOgIYARoxCg9Sb3V0ZUNvc3RzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgBOgI4ASL+BAoPU2tpcHBlZFNoaXBtZW50Eg0KBWluZGV4GAEgASgFEg0KBWxhYmVsGAIgASgJEkUKB3JlYXNvbnMYAyADKAsyNC5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLlNraXBwZWRTaGlwbWVudC5SZWFzb24ahQQKBlJlYXNvbhJHCgRjb2RlGAEgASgOMjkuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5Ta2lwcGVkU2hpcG1lbnQuUmVhc29uLkNvZGUSIgoVZXhhbXBsZV92ZWhpY2xlX2luZGV4GAIgASgFSACIAQESJgoeZXhhbXBsZV9leGNlZWRlZF9jYXBhY2l0eV90eXBlGAMgASgJIssCCgRDb2RlEhQKEENPREVfVU5TUEVDSUZJRUQQABIOCgpOT19WRUhJQ0xFEAESIwofREVNQU5EX0VYQ0VFRFNfVkVISUNMRV9DQVBBQ0lUWRACEjUKMUNBTk5PVF9CRV9QRVJGT1JNRURfV0lUSElOX1ZFSElDTEVfRElTVEFOQ0VfTElNSVQQAxI1CjFDQU5OT1RfQkVfUEVSRk9STUVEX1dJVEhJTl9WRUhJQ0xFX0RVUkFUSU9OX0xJTUlUEAQSPAo4Q0FOTk9UX0JFX1BFUkZPUk1FRF9XSVRISU5fVkVISUNMRV9UUkFWRUxfRFVSQVRJT05fTElNSVQQBRIzCi9DQU5OT1RfQkVfUEVSRk9STUVEX1dJVEhJTl9WRUhJQ0xFX1RJTUVfV0lORE9XUxAGEhcKE1ZFSElDTEVfTk9UX0FMTE9XRUQQB0IYChZfZXhhbXBsZV92ZWhpY2xlX2luZGV4ItgFChFBZ2dyZWdhdGVkTWV0cmljcxIgChhwZXJmb3JtZWRfc2hpcG1lbnRfY291bnQYASABKAUSMgoPdHJhdmVsX2R1cmF0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjAKDXdhaXRfZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoOZGVsYXlfZHVyYXRpb24YBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoOYnJlYWtfZHVyYXRpb24YBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoOdmlzaXRfZHVyYXRpb24YBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMQoOdG90YWxfZHVyYXRpb24YByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SHgoWdHJhdmVsX2Rpc3RhbmNlX21ldGVycxgIIAEoARJQCgltYXhfbG9hZHMYCSADKAsyPS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkFnZ3JlZ2F0ZWRNZXRyaWNzLk1heExvYWRzRW50cnkSTQoFY29zdHMYCiADKAsyOi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkFnZ3JlZ2F0ZWRNZXRyaWNzLkNvc3RzRW50cnlCAhgBEhYKCnRvdGFsX2Nvc3QYCyABKAFCAhgBGmgKDU1heExvYWRzRW50cnkSCwoDa2V5GAEgASgJEkYKBXZhbHVlGAIgASgLMjcuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5TaGlwbWVudFJvdXRlLlZlaGljbGVMb2FkOgI4ARosCgpDb3N0c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoAToCOAEinwYKGkluamVjdGVkU29sdXRpb25Db25zdHJhaW50EjsKBnJvdXRlcxgBIAMoCzIrLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZRJIChFza2lwcGVkX3NoaXBtZW50cxgCIAMoCzItLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuU2tpcHBlZFNoaXBtZW50Em0KFmNvbnN0cmFpbnRfcmVsYXhhdGlvbnMYAyADKAsyTS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkluamVjdGVkU29sdXRpb25Db25zdHJhaW50LkNvbnN0cmFpbnRSZWxheGF0aW9uGooEChRDb25zdHJhaW50UmVsYXhhdGlvbhJtCgtyZWxheGF0aW9ucxgBIAMoCzJYLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuSW5qZWN0ZWRTb2x1dGlvbkNvbnN0cmFpbnQuQ29uc3RyYWludFJlbGF4YXRpb24uUmVsYXhhdGlvbhIXCg92ZWhpY2xlX2luZGljZXMYAiADKAUa6QIKClJlbGF4YXRpb24SbQoFbGV2ZWwYASABKA4yXi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkluamVjdGVkU29sdXRpb25Db25zdHJhaW50LkNvbnN0cmFpbnRSZWxheGF0aW9uLlJlbGF4YXRpb24uTGV2ZWwSMgoOdGhyZXNob2xkX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEh0KFXRocmVzaG9sZF92aXNpdF9jb3VudBgDIAEoBSKYAQoFTGV2ZWwSFQoRTEVWRUxfVU5TUEVDSUZJRUQQABIlCiFSRUxBWF9WSVNJVF9USU1FU19BRlRFUl9USFJFU0hPTEQQARIyCi5SRUxBWF9WSVNJVF9USU1FU19BTkRfU0VRVUVOQ0VfQUZURVJfVEhSRVNIT0xEEAISHQoZUkVMQVhfQUxMX0FGVEVSX1RIUkVTSE9MRBADIv0CChxPcHRpbWl6ZVRvdXJzVmFsaWRhdGlvbkVycm9yEgwKBGNvZGUYASABKAUSFAoMZGlzcGxheV9uYW1lGAIgASgJElkKBmZpZWxkcxgDIAMoCzJJLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjEuT3B0aW1pemVUb3Vyc1ZhbGlkYXRpb25FcnJvci5GaWVsZFJlZmVyZW5jZRIVCg1lcnJvcl9tZXNzYWdlGAQgASgJEhgKEG9mZmVuZGluZ192YWx1ZXMYBSABKAkarAEKDkZpZWxkUmVmZXJlbmNlEgwKBG5hbWUYASABKAkSDwoFaW5kZXgYAiABKAVIABINCgNrZXkYBCABKAlIABJcCglzdWJfZmllbGQYAyABKAsySS5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91cnNWYWxpZGF0aW9uRXJyb3IuRmllbGRSZWZlcmVuY2VCDgoMaW5kZXhfb3Jfa2V5MuAECgxGbGVldFJvdXRpbmcS4gEKDU9wdGltaXplVG91cnMSMi5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91cnNSZXF1ZXN0GjMuZ29vZ2xlLmNsb3VkLm9wdGltaXphdGlvbi52MS5PcHRpbWl6ZVRvdXJzUmVzcG9uc2UiaILT5JMCYjoBKloqOgEqIiUvdjEve3BhcmVudD1wcm9qZWN0cy8qfTpvcHRpbWl6ZVRvdXJzIjEvdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qfTpvcHRpbWl6ZVRvdXJzEpQCChJCYXRjaE9wdGltaXplVG91cnMSNy5nb29nbGUuY2xvdWQub3B0aW1pemF0aW9uLnYxLkJhdGNoT3B0aW1pemVUb3Vyc1JlcXVlc3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIqUBykEwChpCYXRjaE9wdGltaXplVG91cnNSZXNwb25zZRISQXN5bmNNb2RlbE1ldGFkYXRhgtPkkwJsOgEqWi86ASoiKi92MS97cGFyZW50PXByb2plY3RzLyp9OmJhdGNoT3B0aW1pemVUb3VycyI2L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9sb2NhdGlvbnMvKn06YmF0Y2hPcHRpbWl6ZVRvdXJzGlTKQSBjbG91ZG9wdGltaXphdGlvbi5nb29nbGVhcGlzLmNvbdJBLmh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1CfQogY29tLmdvb2dsZS5jbG91ZC5vcHRpbWl6YXRpb24udjFCEUZsZWV0Um91dGluZ1Byb3RvUAFaRGNsb3VkLmdvb2dsZS5jb20vZ28vb3B0aW1pemF0aW9uL2FwaXYxL29wdGltaXphdGlvbnBiO29wdGltaXphdGlvbnBiYgZwcm90bzM", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_cloud_optimization_v1_async_model, file_google_longrunning_operations, file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_type_latlng]);

/**
 * Request to be given to a tour optimization solver which defines the
 * shipment model to solve as well as optimization parameters.
 *
 * @generated from message google.cloud.optimization.v1.OptimizeToursRequest
 */
export type OptimizeToursRequest = Message<"google.cloud.optimization.v1.OptimizeToursRequest"> & {
  /**
   * Required. Target project and location to make a call.
   *
   * Format: `projects/{project-id}/locations/{location-id}`.
   *
   * If no location is specified, a region will be chosen automatically.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * If this timeout is set, the server returns a response before the timeout
   * period has elapsed or the server deadline for synchronous requests is
   * reached, whichever is sooner.
   *
   * For asynchronous requests, the server will generate a solution (if
   * possible) before the timeout has elapsed.
   *
   * @generated from field: google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;

  /**
   * Shipment model to solve.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentModel model = 3;
   */
  model?: ShipmentModel;

  /**
   * By default, the solving mode is `DEFAULT_SOLVE` (0).
   *
   * @generated from field: google.cloud.optimization.v1.OptimizeToursRequest.SolvingMode solving_mode = 4;
   */
  solvingMode: OptimizeToursRequest_SolvingMode;

  /**
   * Search mode used to solve the request.
   *
   * @generated from field: google.cloud.optimization.v1.OptimizeToursRequest.SearchMode search_mode = 6;
   */
  searchMode: OptimizeToursRequest_SearchMode;

  /**
   * Guide the optimization algorithm in finding a first solution that is
   * similar to a previous solution.
   *
   * The model is constrained when the first solution is built.
   * Any shipments not performed on a route are implicitly skipped in the first
   * solution, but they may be performed in successive solutions.
   *
   * The solution must satisfy some basic validity assumptions:
   *
   *   * for all routes, `vehicle_index` must be in range and not be duplicated.
   *   * for all visits, `shipment_index` and `visit_request_index` must be
   *     in range.
   *   * a shipment may only be referenced on one route.
   *   * the pickup of a pickup-delivery shipment must be performed before
   *     the delivery.
   *   * no more than one pickup alternative or delivery alternative of
   *     a shipment may be performed.
   *   * for all routes, times are increasing (i.e., `vehicle_start_time
   *     <= visits[0].start_time <= visits[1].start_time ...
   *     <= vehicle_end_time`).
   *   * a shipment may only be performed on a vehicle that is allowed. A
   *     vehicle is allowed if
   *     [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices]
   *     is empty or its `vehicle_index` is included in
   *     [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices].
   *
   * If the injected solution is not feasible, a validation error is not
   * necessarily returned and an error indicating infeasibility may be returned
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute injected_first_solution_routes = 7;
   */
  injectedFirstSolutionRoutes: ShipmentRoute[];

  /**
   * Constrain the optimization algorithm to find a final solution that is
   * similar to a previous solution. For example, this may be used to freeze
   * portions of routes which have already been completed or which are to be
   * completed but must not be modified.
   *
   * If the injected solution is not feasible, a validation error is not
   * necessarily returned and an error indicating infeasibility may be returned
   * instead.
   *
   * @generated from field: google.cloud.optimization.v1.InjectedSolutionConstraint injected_solution_constraint = 8;
   */
  injectedSolutionConstraint?: InjectedSolutionConstraint;

  /**
   * If non-empty, the given routes will be refreshed, without modifying their
   * underlying sequence of visits or travel times: only other details will be
   * updated. This does not solve the model.
   *
   * As of 2020/11, this only populates the polylines of non-empty routes and
   * requires that `populate_polylines` is true.
   *
   * The `route_polyline` fields of the passed-in routes may be inconsistent
   * with route `transitions`.
   *
   * This field must not be used together with `injected_first_solution_routes`
   * or `injected_solution_constraint`.
   *
   * `Shipment.ignore` and `Vehicle.ignore` have no effect on the behavior.
   * Polylines are still populated between all visits in all non-empty routes
   * regardless of whether the related shipments or vehicles are ignored.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute refresh_details_routes = 9;
   */
  refreshDetailsRoutes: ShipmentRoute[];

  /**
   * If true:
   *
   *   * uses
   *   [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label]
   *   instead of `vehicle_index` to
   *     match routes in an injected solution with vehicles in the request;
   *     reuses the mapping of original
   *     [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index]
   *     to new
   *     [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index]
   *     to update
   *     [ConstraintRelaxation.vehicle_indices][google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.vehicle_indices]
   *     if non-empty, but the mapping must be unambiguous (i.e., multiple
   *     `ShipmentRoute`s must not share the same original `vehicle_index`).
   *   * uses
   *   [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label]
   *   instead of `shipment_index`
   *     to match visits in an injected solution with shipments in the request;
   *   * uses
   *   [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label]
   *   instead of
   *   [SkippedShipment.index][google.cloud.optimization.v1.SkippedShipment.index]
   *   to
   *     match skipped shipments in the injected solution with request
   *     shipments.
   *
   * This interpretation applies to the `injected_first_solution_routes`,
   * `injected_solution_constraint`, and `refresh_details_routes` fields.
   * It can be used when shipment or vehicle indices in the request have
   * changed since the solution was created, perhaps because shipments or
   * vehicles have been removed from or added to the request.
   *
   * If true, labels in the following categories must appear at most once in
   * their category:
   *
   *   * [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] in the
   *   request;
   *   * [Shipment.label][google.cloud.optimization.v1.Shipment.label] in the
   *   request;
   *   * [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label] in the injected solution;
   *   * [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label] and [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label] in
   *     the injected solution (except pickup/delivery visit pairs, whose
   *     `shipment_label` must appear twice).
   *
   * If a `vehicle_label` in the injected solution does not correspond to a
   * request vehicle, the corresponding route is removed from the solution
   * along with its visits. If a `shipment_label` in the injected solution does
   * not correspond to a request shipment, the corresponding visit is removed
   * from the solution. If a
   * [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label]
   * in the injected solution does not correspond to a request shipment, the
   * `SkippedShipment` is removed from the solution.
   *
   * Removing route visits or entire routes from an injected solution may
   * have an effect on the implied constraints, which may lead to change in
   * solution, validation errors, or infeasibility.
   *
   * NOTE: The caller must ensure that each
   * [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] (resp.
   * [Shipment.label][google.cloud.optimization.v1.Shipment.label]) uniquely
   * identifies a vehicle (resp. shipment) entity used across the two relevant
   * requests: the past request that produced the `OptimizeToursResponse` used
   * in the injected solution and the current request that includes the injected
   * solution. The uniqueness checks described above are not enough to guarantee
   * this requirement.
   *
   * @generated from field: bool interpret_injected_solutions_using_labels = 10;
   */
  interpretInjectedSolutionsUsingLabels: boolean;

  /**
   * Consider traffic estimation in calculating `ShipmentRoute` fields
   * [Transition.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration],
   * [Visit.start_time][google.cloud.optimization.v1.ShipmentRoute.Visit.start_time],
   * and `vehicle_end_time`; in setting the
   * [ShipmentRoute.has_traffic_infeasibilities][google.cloud.optimization.v1.ShipmentRoute.has_traffic_infeasibilities]
   * field, and in calculating the
   * [OptimizeToursResponse.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.total_cost]
   * field.
   *
   * @generated from field: bool consider_road_traffic = 11;
   */
  considerRoadTraffic: boolean;

  /**
   * If true, polylines will be populated in response `ShipmentRoute`s.
   *
   * @generated from field: bool populate_polylines = 12;
   */
  populatePolylines: boolean;

  /**
   * If true, polylines will be populated in response
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions].
   * Note that in this case, the polylines will also be populated in the
   * deprecated `travel_steps`.
   *
   * @generated from field: bool populate_transition_polylines = 13;
   */
  populateTransitionPolylines: boolean;

  /**
   * If this is set, then the request can have a deadline
   * (see https://grpc.io/blog/deadlines) of up to 60 minutes.
   * Otherwise, the maximum deadline is only 30 minutes.
   * Note that long-lived requests have a significantly larger (but still small)
   * risk of interruption.
   *
   * @generated from field: bool allow_large_deadline_despite_interruption_risk = 14;
   */
  allowLargeDeadlineDespiteInterruptionRisk: boolean;

  /**
   * If true, travel distances will be computed using geodesic distances instead
   * of Google Maps distances, and travel times will be computed using geodesic
   * distances with a speed defined by `geodesic_meters_per_second`.
   *
   * @generated from field: bool use_geodesic_distances = 15;
   */
  useGeodesicDistances: boolean;

  /**
   * When `use_geodesic_distances` is true, this field must be set and defines
   * the speed applied to compute travel times. Its value must be at least 1.0
   * meters/seconds.
   *
   * @generated from field: optional double geodesic_meters_per_second = 16;
   */
  geodesicMetersPerSecond?: number;

  /**
   * Truncates the number of validation errors returned. These errors are
   * typically attached to an INVALID_ARGUMENT error payload as a BadRequest
   * error detail (https://cloud.google.com/apis/design/errors#error_details),
   * unless solving_mode=VALIDATE_ONLY: see the
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * field.
   * This defaults to 100 and is capped at 10,000.
   *
   * @generated from field: optional int32 max_validation_errors = 5;
   */
  maxValidationErrors?: number;

  /**
   * Label that may be used to identify this request, reported back in the
   * [OptimizeToursResponse.request_label][google.cloud.optimization.v1.OptimizeToursResponse.request_label].
   *
   * @generated from field: string label = 17;
   */
  label: string;

  /**
   * Deprecated: Use
   * [OptimizeToursRequest.populate_transition_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines]
   * instead. If true, polylines will be populated in response
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions].
   * Note that in this case, the polylines will also be populated in the
   * deprecated `travel_steps`.
   *
   * @generated from field: bool populate_travel_step_polylines = 20 [deprecated = true];
   * @deprecated
   */
  populateTravelStepPolylines: boolean;
};

/**
 * Describes the message google.cloud.optimization.v1.OptimizeToursRequest.
 * Use `create(OptimizeToursRequestSchema)` to create a new message.
 */
export const OptimizeToursRequestSchema: GenMessage<OptimizeToursRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 0);

/**
 * Defines how the solver should handle the request. In all modes but
 * `VALIDATE_ONLY`, if the request is invalid, you will receive an
 * `INVALID_REQUEST` error. See
 * [max_validation_errors][google.cloud.optimization.v1.OptimizeToursRequest.max_validation_errors]
 * to cap the number of errors returned.
 *
 * @generated from enum google.cloud.optimization.v1.OptimizeToursRequest.SolvingMode
 */
export enum OptimizeToursRequest_SolvingMode {
  /**
   * Solve the model.
   *
   * @generated from enum value: DEFAULT_SOLVE = 0;
   */
  DEFAULT_SOLVE = 0,

  /**
   * Only validates the model without solving it: populates as many
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * as possible.
   *
   * @generated from enum value: VALIDATE_ONLY = 1;
   */
  VALIDATE_ONLY = 1,

  /**
   * Only populates
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * or
   * [OptimizeToursResponse.skipped_shipments][google.cloud.optimization.v1.OptimizeToursResponse.skipped_shipments],
   * and doesn't actually solve the rest of the request (`status` and `routes`
   * are unset in the response).
   * If infeasibilities in `injected_solution_constraint` routes are detected
   * they are populated in the
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * field and
   * [OptimizeToursResponse.skipped_shipments][google.cloud.optimization.v1.OptimizeToursResponse.skipped_shipments]
   * is left empty.
   *
   * *IMPORTANT*: not all infeasible shipments are returned here, but only the
   * ones that are detected as infeasible during preprocessing.
   *
   * @generated from enum value: DETECT_SOME_INFEASIBLE_SHIPMENTS = 2;
   */
  DETECT_SOME_INFEASIBLE_SHIPMENTS = 2,
}

/**
 * Describes the enum google.cloud.optimization.v1.OptimizeToursRequest.SolvingMode.
 */
export const OptimizeToursRequest_SolvingModeSchema: GenEnum<OptimizeToursRequest_SolvingMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 0, 0);

/**
 * Mode defining the behavior of the search, trading off latency versus
 * solution quality. In all modes, the global request deadline is enforced.
 *
 * @generated from enum google.cloud.optimization.v1.OptimizeToursRequest.SearchMode
 */
export enum OptimizeToursRequest_SearchMode {
  /**
   * Unspecified search mode, equivalent to `RETURN_FAST`.
   *
   * @generated from enum value: SEARCH_MODE_UNSPECIFIED = 0;
   */
  SEARCH_MODE_UNSPECIFIED = 0,

  /**
   * Stop the search after finding the first good solution.
   *
   * @generated from enum value: RETURN_FAST = 1;
   */
  RETURN_FAST = 1,

  /**
   * Spend all the available time to search for better solutions.
   *
   * @generated from enum value: CONSUME_ALL_AVAILABLE_TIME = 2;
   */
  CONSUME_ALL_AVAILABLE_TIME = 2,
}

/**
 * Describes the enum google.cloud.optimization.v1.OptimizeToursRequest.SearchMode.
 */
export const OptimizeToursRequest_SearchModeSchema: GenEnum<OptimizeToursRequest_SearchMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 0, 1);

/**
 * Response after solving a tour optimization problem containing the routes
 * followed by each vehicle, the shipments which have been skipped and the
 * overall cost of the solution.
 *
 * @generated from message google.cloud.optimization.v1.OptimizeToursResponse
 */
export type OptimizeToursResponse = Message<"google.cloud.optimization.v1.OptimizeToursResponse"> & {
  /**
   * Routes computed for each vehicle; the i-th route corresponds to the i-th
   * vehicle in the model.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute routes = 1;
   */
  routes: ShipmentRoute[];

  /**
   * Copy of the
   * [OptimizeToursRequest.label][google.cloud.optimization.v1.OptimizeToursRequest.label],
   * if a label was specified in the request.
   *
   * @generated from field: string request_label = 3;
   */
  requestLabel: string;

  /**
   * The list of all shipments skipped.
   *
   * @generated from field: repeated google.cloud.optimization.v1.SkippedShipment skipped_shipments = 4;
   */
  skippedShipments: SkippedShipment[];

  /**
   * List of all the validation errors that we were able to detect
   * independently. See the "MULTIPLE ERRORS" explanation for the
   * [OptimizeToursValidationError][google.cloud.optimization.v1.OptimizeToursValidationError]
   * message.
   *
   * @generated from field: repeated google.cloud.optimization.v1.OptimizeToursValidationError validation_errors = 5;
   */
  validationErrors: OptimizeToursValidationError[];

  /**
   * Duration, distance and usage metrics for this solution.
   *
   * @generated from field: google.cloud.optimization.v1.OptimizeToursResponse.Metrics metrics = 6;
   */
  metrics?: OptimizeToursResponse_Metrics;

  /**
   * Deprecated: Use
   * [Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost]
   * instead. Total cost of the solution. This takes into account all costs:
   * costs per per hour and travel hour, fixed vehicle costs, unperformed
   * shipment penalty costs, global duration cost, etc.
   *
   * @generated from field: double total_cost = 2 [deprecated = true];
   * @deprecated
   */
  totalCost: number;
};

/**
 * Describes the message google.cloud.optimization.v1.OptimizeToursResponse.
 * Use `create(OptimizeToursResponseSchema)` to create a new message.
 */
export const OptimizeToursResponseSchema: GenMessage<OptimizeToursResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 1);

/**
 * Overall metrics, aggregated over all routes.
 *
 * @generated from message google.cloud.optimization.v1.OptimizeToursResponse.Metrics
 */
export type OptimizeToursResponse_Metrics = Message<"google.cloud.optimization.v1.OptimizeToursResponse.Metrics"> & {
  /**
   * Aggregated over the routes. Each metric is the sum (or max, for loads)
   * over all
   * [ShipmentRoute.metrics][google.cloud.optimization.v1.ShipmentRoute.metrics]
   * fields of the same name.
   *
   * @generated from field: google.cloud.optimization.v1.AggregatedMetrics aggregated_route_metrics = 1;
   */
  aggregatedRouteMetrics?: AggregatedMetrics;

  /**
   * Number of mandatory shipments skipped.
   *
   * @generated from field: int32 skipped_mandatory_shipment_count = 2;
   */
  skippedMandatoryShipmentCount: number;

  /**
   * Number of vehicles used. Note: if a vehicle route is empty and
   * [Vehicle.used_if_route_is_empty][google.cloud.optimization.v1.Vehicle.used_if_route_is_empty]
   * is true, the vehicle is considered used.
   *
   * @generated from field: int32 used_vehicle_count = 3;
   */
  usedVehicleCount: number;

  /**
   * The earliest start time for a used vehicle, computed as the minimum over
   * all used vehicles of
   * [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time].
   *
   * @generated from field: google.protobuf.Timestamp earliest_vehicle_start_time = 4;
   */
  earliestVehicleStartTime?: Timestamp;

  /**
   * The latest end time for a used vehicle, computed as the maximum over all
   * used vehicles of
   * [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time].
   *
   * @generated from field: google.protobuf.Timestamp latest_vehicle_end_time = 5;
   */
  latestVehicleEndTime?: Timestamp;

  /**
   * Cost of the solution, broken down by cost-related request fields.
   * The keys are proto paths, relative to the input OptimizeToursRequest,
   * e.g. "model.shipments.pickups.cost", and the values are the total cost
   * generated by the corresponding cost field, aggregated over the whole
   * solution. In other words, costs["model.shipments.pickups.cost"] is the
   * sum of all pickup costs over the solution. All costs defined in the model
   * are reported in detail here with the exception of costs related to
   * TransitionAttributes that are only reported in an aggregated way as of
   * 2022/01.
   *
   * @generated from field: map<string, double> costs = 10;
   */
  costs: { [key: string]: number };

  /**
   * Total cost of the solution. The sum of all values in the costs map.
   *
   * @generated from field: double total_cost = 6;
   */
  totalCost: number;
};

/**
 * Describes the message google.cloud.optimization.v1.OptimizeToursResponse.Metrics.
 * Use `create(OptimizeToursResponse_MetricsSchema)` to create a new message.
 */
export const OptimizeToursResponse_MetricsSchema: GenMessage<OptimizeToursResponse_Metrics> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 1, 0);

/**
 * Request to batch optimize tours as an asynchronous operation.
 * Each input file should contain one `OptimizeToursRequest`, and each output
 * file will contain one `OptimizeToursResponse`. The request contains
 * information to read/write and parse the files. All the input and output files
 * should be under the same project.
 *
 * @generated from message google.cloud.optimization.v1.BatchOptimizeToursRequest
 */
export type BatchOptimizeToursRequest = Message<"google.cloud.optimization.v1.BatchOptimizeToursRequest"> & {
  /**
   * Required. Target project and location to make a call.
   *
   * Format: `projects/{project-id}/locations/{location-id}`.
   *
   * If no location is specified, a region will be chosen automatically.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. Input/Output information each purchase model, such as file paths
   * and data formats.
   *
   * @generated from field: repeated google.cloud.optimization.v1.BatchOptimizeToursRequest.AsyncModelConfig model_configs = 2;
   */
  modelConfigs: BatchOptimizeToursRequest_AsyncModelConfig[];
};

/**
 * Describes the message google.cloud.optimization.v1.BatchOptimizeToursRequest.
 * Use `create(BatchOptimizeToursRequestSchema)` to create a new message.
 */
export const BatchOptimizeToursRequestSchema: GenMessage<BatchOptimizeToursRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 2);

/**
 * Information for solving one optimization model asynchronously.
 *
 * @generated from message google.cloud.optimization.v1.BatchOptimizeToursRequest.AsyncModelConfig
 */
export type BatchOptimizeToursRequest_AsyncModelConfig = Message<"google.cloud.optimization.v1.BatchOptimizeToursRequest.AsyncModelConfig"> & {
  /**
   * User defined model name, can be used as alias by users to keep track of
   * models.
   *
   * @generated from field: string display_name = 1;
   */
  displayName: string;

  /**
   * Required. Information about the input model.
   *
   * @generated from field: google.cloud.optimization.v1.InputConfig input_config = 2;
   */
  inputConfig?: InputConfig;

  /**
   * Required. The desired output location information.
   *
   * @generated from field: google.cloud.optimization.v1.OutputConfig output_config = 3;
   */
  outputConfig?: OutputConfig;

  /**
   * If this is set, the model will be solved in the checkpoint mode. In this
   * mode, the input model can have a deadline longer than 30 mins without the
   * risk of interruption. The model will be solved in multiple short-running
   * stages. Each stage generates an intermediate checkpoint
   * and stores it in the user's Cloud Storage buckets. The checkpoint
   * mode should be preferred over
   * allow_large_deadline_despite_interruption_risk since it prevents the risk
   * of interruption.
   *
   * @generated from field: bool enable_checkpoints = 4;
   */
  enableCheckpoints: boolean;
};

/**
 * Describes the message google.cloud.optimization.v1.BatchOptimizeToursRequest.AsyncModelConfig.
 * Use `create(BatchOptimizeToursRequest_AsyncModelConfigSchema)` to create a new message.
 */
export const BatchOptimizeToursRequest_AsyncModelConfigSchema: GenMessage<BatchOptimizeToursRequest_AsyncModelConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 2, 0);

/**
 * Response to a `BatchOptimizeToursRequest`. This is returned in
 * the LRO Operation after the operation is complete.
 *
 * @generated from message google.cloud.optimization.v1.BatchOptimizeToursResponse
 */
export type BatchOptimizeToursResponse = Message<"google.cloud.optimization.v1.BatchOptimizeToursResponse"> & {
};

/**
 * Describes the message google.cloud.optimization.v1.BatchOptimizeToursResponse.
 * Use `create(BatchOptimizeToursResponseSchema)` to create a new message.
 */
export const BatchOptimizeToursResponseSchema: GenMessage<BatchOptimizeToursResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 3);

/**
 * A shipment model contains a set of shipments which must be performed by a
 * set of vehicles, while minimizing the overall cost, which is the sum of:
 *
 * * the cost of routing the vehicles (sum of cost per total time, cost per
 *   travel time, and fixed cost over all vehicles).
 * * the unperformed shipment penalties.
 * * the cost of the global duration of the shipments
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel
 */
export type ShipmentModel = Message<"google.cloud.optimization.v1.ShipmentModel"> & {
  /**
   * Set of shipments which must be performed in the model.
   *
   * @generated from field: repeated google.cloud.optimization.v1.Shipment shipments = 1;
   */
  shipments: Shipment[];

  /**
   * Set of vehicles which can be used to perform visits.
   *
   * @generated from field: repeated google.cloud.optimization.v1.Vehicle vehicles = 2;
   */
  vehicles: Vehicle[];

  /**
   * Constrains the maximum number of active vehicles. A vehicle is active if
   * its route performs at least one shipment. This can be used to limit the
   * number of routes in the case where there are fewer drivers than
   * vehicles and that the fleet of vehicles is heterogeneous. The optimization
   * will then select the best subset of vehicles to use.
   * Must be strictly positive.
   *
   * @generated from field: optional int32 max_active_vehicles = 4;
   */
  maxActiveVehicles?: number;

  /**
   * Global start and end time of the model: no times outside of this range
   * can be considered valid.
   *
   * The model's time span must be less than a year, i.e. the `global_end_time`
   * and the `global_start_time` must be within 31536000 seconds of each other.
   *
   * When using `cost_per_*hour` fields, you might want to set this window to a
   * smaller interval to increase performance (eg. if you model a single day,
   * you should set the global time limits to that day).
   * If unset, 00:00:00 UTC, January 1, 1970 (i.e. seconds: 0, nanos: 0) is used
   * as default.
   *
   * @generated from field: google.protobuf.Timestamp global_start_time = 5;
   */
  globalStartTime?: Timestamp;

  /**
   * If unset, 00:00:00 UTC, January 1, 1971 (i.e. seconds: 31536000, nanos: 0)
   * is used as default.
   *
   * @generated from field: google.protobuf.Timestamp global_end_time = 6;
   */
  globalEndTime?: Timestamp;

  /**
   * The "global duration" of the overall plan is the difference between the
   * earliest effective start time and the latest effective end time of
   * all vehicles. Users can assign a cost per hour to that quantity to try
   * and optimize for earliest job completion, for example. This cost must be in
   * the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   *
   * @generated from field: double global_duration_cost_per_hour = 7;
   */
  globalDurationCostPerHour: number;

  /**
   * Specifies duration and distance matrices used in the model. If this field
   * is empty, Google Maps or geodesic distances will be used instead, depending
   * on the value of the `use_geodesic_distances` field. If it is not empty,
   * `use_geodesic_distances` cannot be true and neither
   * `duration_distance_matrix_src_tags` nor `duration_distance_matrix_dst_tags`
   * can be empty.
   *
   * Usage examples:
   *
   * * There are two locations: locA and locB.
   * * 1 vehicle starting its route at locA and ending it at locA.
   * * 1 pickup visit request at locB.
   *
   * ```
   * model {
   *   vehicles { start_tags: "locA"  end_tags: "locA" }
   *   shipments { pickups { tags: "locB" } }
   *   duration_distance_matrix_src_tags: "locA"
   *   duration_distance_matrix_src_tags: "locB"
   *   duration_distance_matrix_dst_tags: "locA"
   *   duration_distance_matrix_dst_tags: "locB"
   *   duration_distance_matrices {
   *     rows {  # from: locA
   *       durations { seconds: 0 }   meters: 0    # to: locA
   *       durations { seconds: 100 } meters: 1000 # to: locB
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 102 } meters: 990 # to: locA
   *       durations { seconds: 0 }   meters: 0   # to: locB
   *     }
   *   }
   * }
   * ```
   *
   *
   * * There are three locations: locA, locB and locC.
   * * 1 vehicle starting its route at locA and ending it at locB, using
   *   matrix "fast".
   * * 1 vehicle starting its route at locB and ending it at locB, using
   *   matrix "slow".
   * * 1 vehicle starting its route at locB and ending it at locB, using
   *   matrix "fast".
   * * 1 pickup visit request at locC.
   *
   * ```
   * model {
   *   vehicles { start_tags: "locA" end_tags: "locB" start_tags: "fast" }
   *   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "slow" }
   *   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "fast" }
   *   shipments { pickups { tags: "locC" } }
   *   duration_distance_matrix_src_tags: "locA"
   *   duration_distance_matrix_src_tags: "locB"
   *   duration_distance_matrix_src_tags: "locC"
   *   duration_distance_matrix_dst_tags: "locB"
   *   duration_distance_matrix_dst_tags: "locC"
   *   duration_distance_matrices {
   *     vehicle_start_tag: "fast"
   *     rows {  # from: locA
   *       durations { seconds: 1000 } meters: 2000 # to: locB
   *       durations { seconds: 600 }  meters: 1000 # to: locC
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 0 }   meters: 0    # to: locB
   *       durations { seconds: 700 } meters: 1200 # to: locC
   *     }
   *     rows {  # from: locC
   *       durations { seconds: 702 } meters: 1190 # to: locB
   *       durations { seconds: 0 }   meters: 0    # to: locC
   *     }
   *   }
   *   duration_distance_matrices {
   *     vehicle_start_tag: "slow"
   *     rows {  # from: locA
   *       durations { seconds: 1800 } meters: 2001 # to: locB
   *       durations { seconds: 900 }  meters: 1002 # to: locC
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 0 }    meters: 0    # to: locB
   *       durations { seconds: 1000 } meters: 1202 # to: locC
   *     }
   *     rows {  # from: locC
   *       durations { seconds: 1001 } meters: 1195 # to: locB
   *       durations { seconds: 0 }    meters: 0    # to: locC
   *     }
   *   }
   * }
   * ```
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix duration_distance_matrices = 8;
   */
  durationDistanceMatrices: ShipmentModel_DurationDistanceMatrix[];

  /**
   * Tags defining the sources of the duration and distance matrices;
   * `duration_distance_matrices(i).rows(j)` defines durations and distances
   * from visits with tag `duration_distance_matrix_src_tags(j)` to other visits
   * in matrix i.
   *
   * Tags correspond to
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags].
   * A given `VisitRequest` or `Vehicle` must match exactly one tag in this
   * field. Note that a `Vehicle`'s source, destination and matrix tags may be
   * the same; similarly a `VisitRequest`'s source and destination tags may be
   * the same. All tags must be different and cannot be empty strings. If this
   * field is not empty, then `duration_distance_matrices` must not be empty.
   *
   * @generated from field: repeated string duration_distance_matrix_src_tags = 9;
   */
  durationDistanceMatrixSrcTags: string[];

  /**
   * Tags defining the destinations of the duration and distance matrices;
   * `duration_distance_matrices(i).rows(j).durations(k)` (resp.
   * `duration_distance_matrices(i).rows(j).meters(k))` defines the duration
   * (resp. the distance) of the travel from visits with tag
   * `duration_distance_matrix_src_tags(j)` to visits with tag
   * `duration_distance_matrix_dst_tags(k)` in matrix i.
   *
   * Tags correspond to
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags].
   * A given `VisitRequest` or `Vehicle` must match exactly one tag in this
   * field. Note that a `Vehicle`'s source, destination and matrix tags may be
   * the same; similarly a `VisitRequest`'s source and destination tags may be
   * the same. All tags must be different and cannot be empty strings. If this
   * field is not empty, then `duration_distance_matrices` must not be empty.
   *
   * @generated from field: repeated string duration_distance_matrix_dst_tags = 10;
   */
  durationDistanceMatrixDstTags: string[];

  /**
   * Transition attributes added to the model.
   *
   * @generated from field: repeated google.cloud.optimization.v1.TransitionAttributes transition_attributes = 11;
   */
  transitionAttributes: TransitionAttributes[];

  /**
   * Sets of incompatible shipment_types (see `ShipmentTypeIncompatibility`).
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentTypeIncompatibility shipment_type_incompatibilities = 12;
   */
  shipmentTypeIncompatibilities: ShipmentTypeIncompatibility[];

  /**
   * Sets of `shipment_type` requirements (see `ShipmentTypeRequirement`).
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentTypeRequirement shipment_type_requirements = 13;
   */
  shipmentTypeRequirements: ShipmentTypeRequirement[];

  /**
   * Set of precedence rules which must be enforced in the model.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.PrecedenceRule precedence_rules = 14;
   */
  precedenceRules: ShipmentModel_PrecedenceRule[];

  /**
   * Deprecated: No longer used.
   * Set of break rules used in the model.
   * Each vehicle specifies the `BreakRule` that applies to it via the
   * [Vehicle.break_rule_indices][google.cloud.optimization.v1.Vehicle.break_rule_indices]
   * field (which must be a singleton).
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.BreakRule break_rules = 15 [deprecated = true];
   * @deprecated
   */
  breakRules: ShipmentModel_BreakRule[];
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.
 * Use `create(ShipmentModelSchema)` to create a new message.
 */
export const ShipmentModelSchema: GenMessage<ShipmentModel> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4);

/**
 * Specifies a duration and distance matrix from visit and vehicle start
 * locations to visit and vehicle end locations.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix
 */
export type ShipmentModel_DurationDistanceMatrix = Message<"google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix"> & {
  /**
   * Specifies the rows of the duration and distance matrix. It must have as
   * many elements as
   * [ShipmentModel.duration_distance_matrix_src_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_src_tags].
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix.Row rows = 1;
   */
  rows: ShipmentModel_DurationDistanceMatrix_Row[];

  /**
   * Tag defining to which vehicles this duration and distance matrix applies.
   * If empty, this applies to all vehicles, and there can only be a single
   * matrix.
   *
   * Each vehicle start must match exactly one matrix, i.e. exactly one of
   * their `start_tags` field must match the `vehicle_start_tag` of a matrix
   * (and of that matrix only).
   *
   * All matrices must have a different `vehicle_start_tag`.
   *
   * @generated from field: string vehicle_start_tag = 2;
   */
  vehicleStartTag: string;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix.
 * Use `create(ShipmentModel_DurationDistanceMatrixSchema)` to create a new message.
 */
export const ShipmentModel_DurationDistanceMatrixSchema: GenMessage<ShipmentModel_DurationDistanceMatrix> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 0);

/**
 * Specifies a row of the duration and distance matrix.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix.Row
 */
export type ShipmentModel_DurationDistanceMatrix_Row = Message<"google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix.Row"> & {
  /**
   * Duration values for a given row. It must have as many elements as
   * [ShipmentModel.duration_distance_matrix_dst_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_dst_tags].
   *
   * @generated from field: repeated google.protobuf.Duration durations = 1;
   */
  durations: Duration[];

  /**
   * Distance values for a given row. If no costs or constraints refer to
   * distances in the model, this can be left empty; otherwise it must have
   * as many elements as `durations`.
   *
   * @generated from field: repeated double meters = 2;
   */
  meters: number[];
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.DurationDistanceMatrix.Row.
 * Use `create(ShipmentModel_DurationDistanceMatrix_RowSchema)` to create a new message.
 */
export const ShipmentModel_DurationDistanceMatrix_RowSchema: GenMessage<ShipmentModel_DurationDistanceMatrix_Row> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 0, 0);

/**
 * A precedence rule between two events (each event is the pickup or the
 * delivery of a shipment): the "second" event has to start at least
 * `offset_duration` after "first" has started.
 *
 * Several precedences can refer to the same (or related) events, e.g.,
 * "pickup of B happens after delivery of A" and "pickup of C happens after
 * pickup of B".
 *
 * Furthermore, precedences only apply when both shipments are performed and
 * are otherwise ignored.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.PrecedenceRule
 */
export type ShipmentModel_PrecedenceRule = Message<"google.cloud.optimization.v1.ShipmentModel.PrecedenceRule"> & {
  /**
   * Shipment index of the "first" event. This field must be specified.
   *
   * @generated from field: optional int32 first_index = 1;
   */
  firstIndex?: number;

  /**
   * Indicates if the "first" event is a delivery.
   *
   * @generated from field: bool first_is_delivery = 3;
   */
  firstIsDelivery: boolean;

  /**
   * Shipment index of the "second" event. This field must be specified.
   *
   * @generated from field: optional int32 second_index = 2;
   */
  secondIndex?: number;

  /**
   * Indicates if the "second" event is a delivery.
   *
   * @generated from field: bool second_is_delivery = 4;
   */
  secondIsDelivery: boolean;

  /**
   * The offset between the "first" and "second" event. It can be negative.
   *
   * @generated from field: google.protobuf.Duration offset_duration = 5;
   */
  offsetDuration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.PrecedenceRule.
 * Use `create(ShipmentModel_PrecedenceRuleSchema)` to create a new message.
 */
export const ShipmentModel_PrecedenceRuleSchema: GenMessage<ShipmentModel_PrecedenceRule> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 1);

/**
 * Deprecated: Use top level
 * [BreakRule][google.cloud.optimization.v1.ShipmentModel.BreakRule] instead.
 * Rules to generate time breaks for a vehicle (e.g. lunch
 * breaks). A break is a contiguous period of time during which the vehicle
 * remains idle at its current position and cannot perform any visit. A break
 * may occur:
 *
 * * during the travel between two visits (which includes the time right
 *   before or right after a visit, but not in the middle of a visit), in
 *   which case it extends the corresponding transit time between the visits
 * * before the vehicle start (the vehicle may not start in the middle of
 *   a break), in which case it does not affect the vehicle start time.
 * * after the vehicle end (ditto, with the vehicle end time).
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.BreakRule
 * @deprecated
 */
export type ShipmentModel_BreakRule = Message<"google.cloud.optimization.v1.ShipmentModel.BreakRule"> & {
  /**
   * Sequence of breaks. See the `BreakRequest` message.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.BreakRule.BreakRequest break_requests = 1;
   */
  breakRequests: ShipmentModel_BreakRule_BreakRequest[];

  /**
   * Several `FrequencyConstraint` may apply. They must all be satisfied by
   * the `BreakRequest`s of this `BreakRule`. See `FrequencyConstraint`.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentModel.BreakRule.FrequencyConstraint frequency_constraints = 2;
   */
  frequencyConstraints: ShipmentModel_BreakRule_FrequencyConstraint[];
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.BreakRule.
 * Use `create(ShipmentModel_BreakRuleSchema)` to create a new message.
 * @deprecated
 */
export const ShipmentModel_BreakRuleSchema: GenMessage<ShipmentModel_BreakRule> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 2);

/**
 * The sequence of breaks (i.e. their number and order) that apply to each
 * vehicle must be known beforehand. The repeated `BreakRequest`s define
 * that sequence, in the order in which they must occur. Their time windows
 * (`earliest_start_time` / `latest_start_time`) may overlap, but they must
 * be compatible with the order (this is checked).
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.BreakRule.BreakRequest
 * @deprecated
 */
export type ShipmentModel_BreakRule_BreakRequest = Message<"google.cloud.optimization.v1.ShipmentModel.BreakRule.BreakRequest"> & {
  /**
   * Required. Lower bound (inclusive) on the start of the break.
   *
   * @generated from field: google.protobuf.Timestamp earliest_start_time = 1;
   */
  earliestStartTime?: Timestamp;

  /**
   * Required. Upper bound (inclusive) on the start of the break.
   *
   * @generated from field: google.protobuf.Timestamp latest_start_time = 2;
   */
  latestStartTime?: Timestamp;

  /**
   * Required. Minimum duration of the break. Must be positive.
   *
   * @generated from field: google.protobuf.Duration min_duration = 3;
   */
  minDuration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.BreakRule.BreakRequest.
 * Use `create(ShipmentModel_BreakRule_BreakRequestSchema)` to create a new message.
 * @deprecated
 */
export const ShipmentModel_BreakRule_BreakRequestSchema: GenMessage<ShipmentModel_BreakRule_BreakRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 2, 0);

/**
 * One may further constrain the frequency and duration of the breaks
 * specified above, by enforcing a minimum break frequency, such as
 * "There must be a break of at least 1 hour every 12 hours". Assuming that
 * this can be interpreted as "Within any sliding time window of 12h, there
 * must be at least one break of at least one hour", that example would
 * translate to the following `FrequencyConstraint`:
 * ```
 * {
 *    min_break_duration { seconds: 3600 }         # 1 hour.
 *    max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).
 * }
 * ```
 *
 * The timing and duration of the breaks in the solution will respect all
 * such constraints, in addition to the time windows and minimum durations
 * already specified in the `BreakRequest`.
 *
 * A `FrequencyConstraint` may in practice apply to non-consecutive breaks.
 * For example, the following schedule honors the "1h every 12h" example:
 * ```
 *   04:00 vehicle start
 *    .. performing travel and visits ..
 *   09:00 1 hour break
 *   10:00 end of the break
 *    .. performing travel and visits ..
 *   12:00 20-min lunch break
 *   12:20 end of the break
 *    .. performing travel and visits ..
 *   21:00 1 hour break
 *   22:00 end of the break
 *    .. performing travel and visits ..
 *   23:59 vehicle end
 * ```
 *
 * @generated from message google.cloud.optimization.v1.ShipmentModel.BreakRule.FrequencyConstraint
 * @deprecated
 */
export type ShipmentModel_BreakRule_FrequencyConstraint = Message<"google.cloud.optimization.v1.ShipmentModel.BreakRule.FrequencyConstraint"> & {
  /**
   * Required. Minimum break duration for this constraint. Nonnegative.
   * See description of `FrequencyConstraint`.
   *
   * @generated from field: google.protobuf.Duration min_break_duration = 1;
   */
  minBreakDuration?: Duration;

  /**
   * Required. Maximum allowed span of any interval of time in the route
   * that does not include at least partially a break of `duration >=
   * min_break_duration`. Must be positive.
   *
   * @generated from field: google.protobuf.Duration max_inter_break_duration = 2;
   */
  maxInterBreakDuration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentModel.BreakRule.FrequencyConstraint.
 * Use `create(ShipmentModel_BreakRule_FrequencyConstraintSchema)` to create a new message.
 * @deprecated
 */
export const ShipmentModel_BreakRule_FrequencyConstraintSchema: GenMessage<ShipmentModel_BreakRule_FrequencyConstraint> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 4, 2, 1);

/**
 * The shipment of a single item, from one of its pickups to one of its
 * deliveries. For the shipment to be considered as performed, a unique vehicle
 * must visit one of its pickup locations (and decrease its spare capacities
 * accordingly), then visit one of its delivery locations later on (and
 * therefore re-increase its spare capacities accordingly).
 *
 * @generated from message google.cloud.optimization.v1.Shipment
 */
export type Shipment = Message<"google.cloud.optimization.v1.Shipment"> & {
  /**
   * Set of pickup alternatives associated to the shipment. If not specified,
   * the vehicle only needs to visit a location corresponding to the deliveries.
   *
   * @generated from field: repeated google.cloud.optimization.v1.Shipment.VisitRequest pickups = 1;
   */
  pickups: Shipment_VisitRequest[];

  /**
   * Set of delivery alternatives associated to the shipment. If not specified,
   * the vehicle only needs to visit a location corresponding to the pickups.
   *
   * @generated from field: repeated google.cloud.optimization.v1.Shipment.VisitRequest deliveries = 2;
   */
  deliveries: Shipment_VisitRequest[];

  /**
   * Load demands of the shipment (for example weight, volume, number of
   * pallets etc). The keys in the map should be identifiers describing the type
   * of the corresponding load, ideally also including the units.
   * For example: "weight_kg", "volume_gallons", "pallet_count", etc.
   * If a given key does not appear in the map, the corresponding load is
   * considered as null.
   *
   * @generated from field: map<string, google.cloud.optimization.v1.Shipment.Load> load_demands = 14;
   */
  loadDemands: { [key: string]: Shipment_Load };

  /**
   * If the shipment is not completed, this penalty is added to the overall
   * cost of the routes. A shipment is considered completed if one of its pickup
   * and delivery alternatives is visited. The cost may be expressed in the
   * same unit used for all other cost-related fields in the model and must be
   * positive.
   *
   * *IMPORTANT*: If this penalty is not specified, it is considered infinite,
   * i.e. the shipment must be completed.
   *
   * @generated from field: optional double penalty_cost = 4;
   */
  penaltyCost?: number;

  /**
   * The set of vehicles that may perform this shipment. If empty, all vehicles
   * may perform it. Vehicles are given by their index in the `ShipmentModel`'s
   * `vehicles` list.
   *
   * @generated from field: repeated int32 allowed_vehicle_indices = 5;
   */
  allowedVehicleIndices: number[];

  /**
   * Specifies the cost that is incurred when this shipment is delivered by each
   * vehicle. If specified, it must have EITHER:
   *
   *   * the same number of elements as `costs_per_vehicle_indices`.
   *     `costs_per_vehicle[i]` corresponds to vehicle
   *     `costs_per_vehicle_indices[i]` of the model.
   *   * the same number of elements as there are vehicles in the model. The
   *     i-th element corresponds to vehicle #i of the model.
   *
   * These costs must be in the same unit as `penalty_cost` and must not be
   * negative. Leave this field empty, if there are no such costs.
   *
   * @generated from field: repeated double costs_per_vehicle = 6;
   */
  costsPerVehicle: number[];

  /**
   * Indices of the vehicles to which `costs_per_vehicle` applies. If non-empty,
   * it must have the same number of elements as `costs_per_vehicle`. A vehicle
   * index may not be specified more than once. If a vehicle is excluded from
   * `costs_per_vehicle_indices`, its cost is zero.
   *
   * @generated from field: repeated int32 costs_per_vehicle_indices = 7;
   */
  costsPerVehicleIndices: number[];

  /**
   * Specifies the maximum relative detour time compared to the shortest path
   * from pickup to delivery. If specified, it must be nonnegative, and the
   * shipment must contain at least a pickup and a delivery.
   *
   * For example, let t be the shortest time taken to go from the selected
   * pickup alternative directly to the selected delivery alternative. Then
   * setting `pickup_to_delivery_relative_detour_limit` enforces:
   *
   * ```
   * start_time(delivery) - start_time(pickup) <=
   * std::ceil(t * (1.0 + pickup_to_delivery_relative_detour_limit))
   * ```
   *
   * If both relative and absolute limits are specified on the same shipment,
   * the more constraining limit is used for each possible pickup/delivery pair.
   * As of 2017/10, detours are only supported when travel durations do not
   * depend on vehicles.
   *
   * @generated from field: optional double pickup_to_delivery_relative_detour_limit = 8;
   */
  pickupToDeliveryRelativeDetourLimit?: number;

  /**
   * Specifies the maximum absolute detour time compared to the shortest path
   * from pickup to delivery. If specified, it must be nonnegative, and the
   * shipment must contain at least a pickup and a delivery.
   *
   * For example, let t be the shortest time taken to go from the selected
   * pickup alternative directly to the selected delivery alternative. Then
   * setting `pickup_to_delivery_absolute_detour_limit` enforces:
   *
   * ```
   * start_time(delivery) - start_time(pickup) <=
   * t + pickup_to_delivery_absolute_detour_limit
   * ```
   *
   * If both relative and absolute limits are specified on the same shipment,
   * the more constraining limit is used for each possible pickup/delivery pair.
   * As of 2017/10, detours are only supported when travel durations do not
   * depend on vehicles.
   *
   * @generated from field: google.protobuf.Duration pickup_to_delivery_absolute_detour_limit = 9;
   */
  pickupToDeliveryAbsoluteDetourLimit?: Duration;

  /**
   * Specifies the maximum duration from start of pickup to start of delivery of
   * a shipment. If specified, it must be nonnegative, and the shipment must
   * contain at least a pickup and a delivery. This does not depend on which
   * alternatives are selected for pickup and delivery, nor on vehicle speed.
   * This can be specified alongside maximum detour constraints: the solution
   * will respect both specifications.
   *
   * @generated from field: google.protobuf.Duration pickup_to_delivery_time_limit = 10;
   */
  pickupToDeliveryTimeLimit?: Duration;

  /**
   * Non-empty string specifying a "type" for this shipment.
   * This feature can be used to define incompatibilities or requirements
   * between `shipment_types` (see `shipment_type_incompatibilities` and
   * `shipment_type_requirements` in `ShipmentModel`).
   *
   * Differs from `visit_types` which is specified for a single visit: All
   * pickup/deliveries belonging to the same shipment share the same
   * `shipment_type`.
   *
   * @generated from field: string shipment_type = 11;
   */
  shipmentType: string;

  /**
   * Specifies a label for this shipment. This label is reported in the response
   * in the `shipment_label` of the corresponding
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit].
   *
   * @generated from field: string label = 12;
   */
  label: string;

  /**
   * If true, skip this shipment, but don't apply a `penalty_cost`.
   *
   * Ignoring a shipment results in a validation error when there are any
   * `shipment_type_requirements` in the model.
   *
   * Ignoring a shipment that is performed in `injected_first_solution_routes`
   * or `injected_solution_constraint` is permitted; the solver removes the
   * related pickup/delivery visits from the performing route.
   * `precedence_rules` that reference ignored shipments will also be ignored.
   *
   * @generated from field: bool ignore = 13;
   */
  ignore: boolean;

  /**
   * Deprecated: Use
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity demands = 3 [deprecated = true];
   * @deprecated
   */
  demands: CapacityQuantity[];
};

/**
 * Describes the message google.cloud.optimization.v1.Shipment.
 * Use `create(ShipmentSchema)` to create a new message.
 */
export const ShipmentSchema: GenMessage<Shipment> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 5);

/**
 * Request for a visit which can be done by a vehicle: it has a geo-location
 * (or two, see below), opening and closing times represented by time windows,
 * and a service duration time (time spent by the vehicle once it has arrived
 * to pickup or drop off goods).
 *
 * @generated from message google.cloud.optimization.v1.Shipment.VisitRequest
 */
export type Shipment_VisitRequest = Message<"google.cloud.optimization.v1.Shipment.VisitRequest"> & {
  /**
   * The geo-location where the vehicle arrives when performing this
   * `VisitRequest`. If the shipment model has duration distance matrices,
   * `arrival_location` must not be specified.
   *
   * @generated from field: google.type.LatLng arrival_location = 1;
   */
  arrivalLocation?: LatLng;

  /**
   * The waypoint where the vehicle arrives when performing this
   * `VisitRequest`. If the shipment model has duration distance matrices,
   * `arrival_waypoint` must not be specified.
   *
   * @generated from field: google.cloud.optimization.v1.Waypoint arrival_waypoint = 2;
   */
  arrivalWaypoint?: Waypoint;

  /**
   * The geo-location where the vehicle departs after completing this
   * `VisitRequest`. Can be omitted if it is the same as `arrival_location`.
   * If the shipment model has duration distance matrices,
   * `departure_location` must not be specified.
   *
   * @generated from field: google.type.LatLng departure_location = 3;
   */
  departureLocation?: LatLng;

  /**
   * The waypoint where the vehicle departs after completing this
   * `VisitRequest`. Can be omitted if it is the same as `arrival_waypoint`.
   * If the shipment model has duration distance matrices,
   * `departure_waypoint` must not be specified.
   *
   * @generated from field: google.cloud.optimization.v1.Waypoint departure_waypoint = 4;
   */
  departureWaypoint?: Waypoint;

  /**
   * Specifies tags attached to the visit request.
   * Empty or duplicate strings are not allowed.
   *
   * @generated from field: repeated string tags = 5;
   */
  tags: string[];

  /**
   * Time windows which constrain the arrival time at a visit.
   * Note that a vehicle may depart outside of the arrival time window, i.e.
   * arrival time + duration do not need to be inside a time window. This can
   * result in waiting time if the vehicle arrives before
   * [TimeWindow.start_time][google.cloud.optimization.v1.TimeWindow.start_time].
   *
   * The absence of `TimeWindow` means that the vehicle can perform this visit
   * at any time.
   *
   * Time windows must be disjoint, i.e. no time window must overlap with or
   * be adjacent to another, and they must be in increasing order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only
   * be set if there is a single time window.
   *
   * @generated from field: repeated google.cloud.optimization.v1.TimeWindow time_windows = 6;
   */
  timeWindows: TimeWindow[];

  /**
   * Duration of the visit, i.e. time spent by the vehicle between arrival
   * and departure (to be added to the possible waiting time; see
   * `time_windows`).
   *
   * @generated from field: google.protobuf.Duration duration = 7;
   */
  duration?: Duration;

  /**
   * Cost to service this visit request on a vehicle route. This can be used
   * to pay different costs for each alternative pickup or delivery of a
   * shipment. This cost must be in the same unit as `Shipment.penalty_cost`
   * and must not be negative.
   *
   * @generated from field: double cost = 8;
   */
  cost: number;

  /**
   * Load demands of this visit request. This is just like
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * field, except that it only applies to this
   * [VisitRequest][google.cloud.optimization.v1.Shipment.VisitRequest]
   * instead of the whole [Shipment][google.cloud.optimization.v1.Shipment].
   * The demands listed here are added to the demands listed in
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands].
   *
   * @generated from field: map<string, google.cloud.optimization.v1.Shipment.Load> load_demands = 12;
   */
  loadDemands: { [key: string]: Shipment_Load };

  /**
   * Specifies the types of the visit. This may be used to allocate additional
   * time required for a vehicle to complete this visit (see
   * [Vehicle.extra_visit_duration_for_visit_type][google.cloud.optimization.v1.Vehicle.extra_visit_duration_for_visit_type]).
   *
   * A type can only appear once.
   *
   * @generated from field: repeated string visit_types = 10;
   */
  visitTypes: string[];

  /**
   * Specifies a label for this `VisitRequest`. This label is reported in the
   * response as `visit_label` in the corresponding
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit].
   *
   * @generated from field: string label = 11;
   */
  label: string;

  /**
   * Deprecated: Use
   * [VisitRequest.load_demands][google.cloud.optimization.v1.Shipment.VisitRequest.load_demands]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity demands = 9 [deprecated = true];
   * @deprecated
   */
  demands: CapacityQuantity[];
};

/**
 * Describes the message google.cloud.optimization.v1.Shipment.VisitRequest.
 * Use `create(Shipment_VisitRequestSchema)` to create a new message.
 */
export const Shipment_VisitRequestSchema: GenMessage<Shipment_VisitRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 5, 0);

/**
 * When performing a visit, a predefined amount may be added to the vehicle
 * load if it's a pickup, or subtracted if it's a delivery. This message
 * defines such amount. See
 * [load_demands][google.cloud.optimization.v1.Shipment.load_demands].
 *
 * @generated from message google.cloud.optimization.v1.Shipment.Load
 */
export type Shipment_Load = Message<"google.cloud.optimization.v1.Shipment.Load"> & {
  /**
   * The amount by which the load of the vehicle performing the corresponding
   * visit will vary. Since it is an integer, users are advised to choose an
   * appropriate unit to avoid loss of precision. Must be  0.
   *
   * @generated from field: int64 amount = 2;
   */
  amount: bigint;
};

/**
 * Describes the message google.cloud.optimization.v1.Shipment.Load.
 * Use `create(Shipment_LoadSchema)` to create a new message.
 */
export const Shipment_LoadSchema: GenMessage<Shipment_Load> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 5, 1);

/**
 * Specifies incompatibilties between shipments depending on their
 * shipment_type. The appearance of incompatible shipments on the same route is
 * restricted based on the incompatibility mode.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentTypeIncompatibility
 */
export type ShipmentTypeIncompatibility = Message<"google.cloud.optimization.v1.ShipmentTypeIncompatibility"> & {
  /**
   * List of incompatible types. Two shipments having different `shipment_types`
   * among those listed are "incompatible".
   *
   * @generated from field: repeated string types = 1;
   */
  types: string[];

  /**
   * Mode applied to the incompatibility.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentTypeIncompatibility.IncompatibilityMode incompatibility_mode = 2;
   */
  incompatibilityMode: ShipmentTypeIncompatibility_IncompatibilityMode;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentTypeIncompatibility.
 * Use `create(ShipmentTypeIncompatibilitySchema)` to create a new message.
 */
export const ShipmentTypeIncompatibilitySchema: GenMessage<ShipmentTypeIncompatibility> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 6);

/**
 * Modes defining how the appearance of incompatible shipments are restricted
 * on the same route.
 *
 * @generated from enum google.cloud.optimization.v1.ShipmentTypeIncompatibility.IncompatibilityMode
 */
export enum ShipmentTypeIncompatibility_IncompatibilityMode {
  /**
   * Unspecified incompatibility mode. This value should never be used.
   *
   * @generated from enum value: INCOMPATIBILITY_MODE_UNSPECIFIED = 0;
   */
  INCOMPATIBILITY_MODE_UNSPECIFIED = 0,

  /**
   * In this mode, two shipments with incompatible types can never share the
   * same vehicle.
   *
   * @generated from enum value: NOT_PERFORMED_BY_SAME_VEHICLE = 1;
   */
  NOT_PERFORMED_BY_SAME_VEHICLE = 1,

  /**
   * For two shipments with incompatible types with the
   * `NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY` incompatibility mode:
   *
   * * If both are pickups only (no deliveries) or deliveries only (no
   *   pickups), they cannot share the same vehicle at all.
   * * If one of the shipments has a delivery and the other a pickup, the two
   *   shipments can share the same vehicle iff the former shipment is
   *   delivered before the latter is picked up.
   *
   * @generated from enum value: NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY = 2;
   */
  NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY = 2,
}

/**
 * Describes the enum google.cloud.optimization.v1.ShipmentTypeIncompatibility.IncompatibilityMode.
 */
export const ShipmentTypeIncompatibility_IncompatibilityModeSchema: GenEnum<ShipmentTypeIncompatibility_IncompatibilityMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 6, 0);

/**
 * Specifies requirements between shipments based on their shipment_type.
 * The specifics of the requirement are defined by the requirement mode.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentTypeRequirement
 */
export type ShipmentTypeRequirement = Message<"google.cloud.optimization.v1.ShipmentTypeRequirement"> & {
  /**
   * List of alternative shipment types required by the
   * `dependent_shipment_types`.
   *
   * @generated from field: repeated string required_shipment_type_alternatives = 1;
   */
  requiredShipmentTypeAlternatives: string[];

  /**
   * All shipments with a type in the `dependent_shipment_types` field require
   * at least one shipment of type `required_shipment_type_alternatives` to be
   * visited on the same route.
   *
   * NOTE: Chains of requirements such that a `shipment_type` depends on itself
   * are not allowed.
   *
   * @generated from field: repeated string dependent_shipment_types = 2;
   */
  dependentShipmentTypes: string[];

  /**
   * Mode applied to the requirement.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentTypeRequirement.RequirementMode requirement_mode = 3;
   */
  requirementMode: ShipmentTypeRequirement_RequirementMode;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentTypeRequirement.
 * Use `create(ShipmentTypeRequirementSchema)` to create a new message.
 */
export const ShipmentTypeRequirementSchema: GenMessage<ShipmentTypeRequirement> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 7);

/**
 * Modes defining the appearance of dependent shipments on a route.
 *
 * @generated from enum google.cloud.optimization.v1.ShipmentTypeRequirement.RequirementMode
 */
export enum ShipmentTypeRequirement_RequirementMode {
  /**
   * Unspecified requirement mode. This value should never be used.
   *
   * @generated from enum value: REQUIREMENT_MODE_UNSPECIFIED = 0;
   */
  REQUIREMENT_MODE_UNSPECIFIED = 0,

  /**
   * In this mode, all "dependent" shipments must share the same vehicle as at
   * least one of their "required" shipments.
   *
   * @generated from enum value: PERFORMED_BY_SAME_VEHICLE = 1;
   */
  PERFORMED_BY_SAME_VEHICLE = 1,

  /**
   * With the `IN_SAME_VEHICLE_AT_PICKUP_TIME` mode, all "dependent"
   * shipments need to have at least one "required" shipment on their vehicle
   * at the time of their pickup.
   *
   * A "dependent" shipment pickup must therefore have either:
   *
   * * A delivery-only "required" shipment delivered on the route after, or
   * * A "required" shipment picked up on the route before it, and if the
   *   "required" shipment has a delivery, this delivery must be performed
   *   after the "dependent" shipment's pickup.
   *
   * @generated from enum value: IN_SAME_VEHICLE_AT_PICKUP_TIME = 2;
   */
  IN_SAME_VEHICLE_AT_PICKUP_TIME = 2,

  /**
   * Same as before, except the "dependent" shipments need to have a
   * "required" shipment on their vehicle at the time of their *delivery*.
   *
   * @generated from enum value: IN_SAME_VEHICLE_AT_DELIVERY_TIME = 3;
   */
  IN_SAME_VEHICLE_AT_DELIVERY_TIME = 3,
}

/**
 * Describes the enum google.cloud.optimization.v1.ShipmentTypeRequirement.RequirementMode.
 */
export const ShipmentTypeRequirement_RequirementModeSchema: GenEnum<ShipmentTypeRequirement_RequirementMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 7, 0);

/**
 * Encapsulates a set of optional conditions to satisfy when calculating
 * vehicle routes. This is similar to `RouteModifiers` in the Google Maps
 * Platform API; see:
 * https://developers.google.com/maps/documentation/routes/reference/rest/v2/RouteModifiers.
 *
 * @generated from message google.cloud.optimization.v1.RouteModifiers
 */
export type RouteModifiers = Message<"google.cloud.optimization.v1.RouteModifiers"> & {
  /**
   * Specifies whether to avoid toll roads where reasonable. Preference will be
   * given to routes not containing toll roads. Applies only to motorized travel
   * modes.
   *
   * @generated from field: bool avoid_tolls = 2;
   */
  avoidTolls: boolean;

  /**
   * Specifies whether to avoid highways where reasonable. Preference will be
   * given to routes not containing highways. Applies only to motorized travel
   * modes.
   *
   * @generated from field: bool avoid_highways = 3;
   */
  avoidHighways: boolean;

  /**
   * Specifies whether to avoid ferries where reasonable. Preference will be
   * given to routes not containing travel by ferries. Applies only to motorized
   * travel modes.
   *
   * @generated from field: bool avoid_ferries = 4;
   */
  avoidFerries: boolean;

  /**
   * Optional. Specifies whether to avoid navigating indoors where reasonable.
   * Preference will be given to routes not containing indoor navigation.
   * Applies only to the `WALKING` travel mode.
   *
   * @generated from field: bool avoid_indoor = 5;
   */
  avoidIndoor: boolean;
};

/**
 * Describes the message google.cloud.optimization.v1.RouteModifiers.
 * Use `create(RouteModifiersSchema)` to create a new message.
 */
export const RouteModifiersSchema: GenMessage<RouteModifiers> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 8);

/**
 * Models a vehicle in a shipment problem. Solving a shipment problem will
 * build a route starting from `start_location` and ending at `end_location`
 * for this vehicle. A route is a sequence of visits (see `ShipmentRoute`).
 *
 * @generated from message google.cloud.optimization.v1.Vehicle
 */
export type Vehicle = Message<"google.cloud.optimization.v1.Vehicle"> & {
  /**
   * The travel mode which affects the roads usable by the vehicle and its
   * speed. See also `travel_duration_multiple`.
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.TravelMode travel_mode = 1;
   */
  travelMode: Vehicle_TravelMode;

  /**
   * Optional. A set of conditions to satisfy that affect the way routes are
   * calculated for the given vehicle.
   *
   * @generated from field: google.cloud.optimization.v1.RouteModifiers route_modifiers = 2;
   */
  routeModifiers?: RouteModifiers;

  /**
   * Geographic location where the vehicle starts before picking up any
   * shipments. If not specified, the vehicle starts at its first pickup.
   * If the shipment model has duration and distance matrices, `start_location`
   * must not be specified.
   *
   * @generated from field: google.type.LatLng start_location = 3;
   */
  startLocation?: LatLng;

  /**
   * Waypoint representing a geographic location where the vehicle starts before
   * picking up any shipments. If neither `start_waypoint` nor `start_location`
   * is specified, the vehicle starts at its first pickup.
   * If the shipment model has duration and distance matrices, `start_waypoint`
   * must not be specified.
   *
   * @generated from field: google.cloud.optimization.v1.Waypoint start_waypoint = 4;
   */
  startWaypoint?: Waypoint;

  /**
   * Geographic location where the vehicle ends after it has completed its last
   * `VisitRequest`. If not specified the vehicle's `ShipmentRoute` ends
   * immediately when it completes its last `VisitRequest`.
   * If the shipment model has duration and distance matrices, `end_location`
   * must not be specified.
   *
   * @generated from field: google.type.LatLng end_location = 5;
   */
  endLocation?: LatLng;

  /**
   * Waypoint representing a geographic location where the vehicle ends after
   * it has completed its last `VisitRequest`. If neither `end_waypoint` nor
   * `end_location` is specified, the vehicle's `ShipmentRoute` ends immediately
   * when it completes its last `VisitRequest`.
   * If the shipment model has duration and distance matrices, `end_waypoint`
   * must not be specified.
   *
   * @generated from field: google.cloud.optimization.v1.Waypoint end_waypoint = 6;
   */
  endWaypoint?: Waypoint;

  /**
   * Specifies tags attached to the start of the vehicle's route.
   *
   * Empty or duplicate strings are not allowed.
   *
   * @generated from field: repeated string start_tags = 7;
   */
  startTags: string[];

  /**
   * Specifies tags attached to the end of the vehicle's route.
   *
   * Empty or duplicate strings are not allowed.
   *
   * @generated from field: repeated string end_tags = 8;
   */
  endTags: string[];

  /**
   * Time windows during which the vehicle may depart its start location.
   * They must be within the global time limits (see
   * [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time]
   * fields). If unspecified, there is no limitation besides those global time
   * limits.
   *
   * Time windows belonging to the same repeated field must be disjoint, i.e. no
   * time window can overlap with or be adjacent to another, and they must be in
   * chronological order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
   * there is a single time window.
   *
   * @generated from field: repeated google.cloud.optimization.v1.TimeWindow start_time_windows = 9;
   */
  startTimeWindows: TimeWindow[];

  /**
   * Time windows during which the vehicle may arrive at its end location.
   * They must be within the global time limits (see
   * [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time]
   * fields). If unspecified, there is no limitation besides those global time
   * limits.
   *
   * Time windows belonging to the same repeated field must be disjoint, i.e. no
   * time window can overlap with or be adjacent to another, and they must be in
   * chronological order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
   * there is a single time window.
   *
   * @generated from field: repeated google.cloud.optimization.v1.TimeWindow end_time_windows = 10;
   */
  endTimeWindows: TimeWindow[];

  /**
   * Specifies a multiplicative factor that can be used to increase or decrease
   * travel times of this vehicle. For example, setting this to 2.0 means
   * that this vehicle is slower and has travel times that are twice what they
   * are for standard vehicles. This multiple does not affect visit durations.
   * It does affect cost if `cost_per_hour` or `cost_per_traveled_hour` are
   * specified. This must be in the range [0.001, 1000.0]. If unset, the vehicle
   * is standard, and this multiple is considered 1.0.
   *
   * WARNING: Travel times will be rounded to the nearest second after this
   * multiple is applied but before performing any numerical operations, thus,
   * a small multiple may result in a loss of precision.
   *
   * See also `extra_visit_duration_for_visit_type` below.
   *
   * @generated from field: optional double travel_duration_multiple = 11;
   */
  travelDurationMultiple?: number;

  /**
   * Unloading policy enforced on the vehicle.
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.UnloadingPolicy unloading_policy = 12;
   */
  unloadingPolicy: Vehicle_UnloadingPolicy;

  /**
   * Capacities of the vehicle (weight, volume, # of pallets for example).
   * The keys in the map are the identifiers of the type of load, consistent
   * with the keys of the
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * field. If a given key is absent from this map, the corresponding capacity
   * is considered to be limitless.
   *
   * @generated from field: map<string, google.cloud.optimization.v1.Vehicle.LoadLimit> load_limits = 30;
   */
  loadLimits: { [key: string]: Vehicle_LoadLimit };

  /**
   * Vehicle costs: all costs add up and must be in the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   *
   * Cost per hour of the vehicle route. This cost is applied to the total time
   * taken by the route, and includes travel time, waiting time, and visit time.
   * Using `cost_per_hour` instead of just `cost_per_traveled_hour` may result
   * in additional latency.
   *
   * @generated from field: double cost_per_hour = 16;
   */
  costPerHour: number;

  /**
   * Cost per traveled hour of the vehicle route. This cost is applied only to
   * travel time taken by the route (i.e., that reported in
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]),
   * and excludes waiting time and visit time.
   *
   * @generated from field: double cost_per_traveled_hour = 17;
   */
  costPerTraveledHour: number;

  /**
   * Cost per kilometer of the vehicle route. This cost is applied to the
   * distance reported in the
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * and does not apply to any distance implicitly traveled from the
   * `arrival_location` to the `departure_location` of a single `VisitRequest`.
   *
   * @generated from field: double cost_per_kilometer = 18;
   */
  costPerKilometer: number;

  /**
   * Fixed cost applied if this vehicle is used to handle a shipment.
   *
   * @generated from field: double fixed_cost = 19;
   */
  fixedCost: number;

  /**
   * This field only applies to vehicles when their route does not serve any
   * shipments. It indicates if the vehicle should be considered as used or not
   * in this case.
   *
   * If true, the vehicle goes from its start to its end location even if it
   * doesn't serve any shipments, and time and distance costs resulting from its
   * start --> end travel are taken into account.
   *
   * Otherwise, it doesn't travel from its start to its end location, and no
   * `break_rule` or delay (from `TransitionAttributes`) are scheduled for this
   * vehicle. In this case, the vehicle's `ShipmentRoute` doesn't contain any
   * information except for the vehicle index and label.
   *
   * @generated from field: bool used_if_route_is_empty = 20;
   */
  usedIfRouteIsEmpty: boolean;

  /**
   * Limit applied to the total duration of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route duration of a vehicle is the
   * difference between its `vehicle_end_time` and `vehicle_start_time`.
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.DurationLimit route_duration_limit = 21;
   */
  routeDurationLimit?: Vehicle_DurationLimit;

  /**
   * Limit applied to the travel duration of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route travel duration is the sum of all its
   * [transitions.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration].
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.DurationLimit travel_duration_limit = 22;
   */
  travelDurationLimit?: Vehicle_DurationLimit;

  /**
   * Limit applied to the total distance of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route distance is the sum of all its
   * [transitions.travel_distance_meters][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_distance_meters].
   *
   * @generated from field: google.cloud.optimization.v1.DistanceLimit route_distance_limit = 23;
   */
  routeDistanceLimit?: DistanceLimit;

  /**
   * Specifies a map from visit_types strings to durations. The duration is time
   * in addition to
   * [VisitRequest.duration][google.cloud.optimization.v1.Shipment.VisitRequest.duration]
   * to be taken at visits with the specified `visit_types`. This extra visit
   * duration adds cost if `cost_per_hour` is specified. Keys (i.e.
   * `visit_types`) cannot be empty strings.
   *
   * If a visit request has multiple types, a duration will be added for each
   * type in the map.
   *
   * @generated from field: map<string, google.protobuf.Duration> extra_visit_duration_for_visit_type = 24;
   */
  extraVisitDurationForVisitType: { [key: string]: Duration };

  /**
   * Describes the break schedule to be enforced on this vehicle.
   * If empty, no breaks will be scheduled for this vehicle.
   *
   * @generated from field: google.cloud.optimization.v1.BreakRule break_rule = 25;
   */
  breakRule?: BreakRule;

  /**
   * Specifies a label for this vehicle. This label is reported in the response
   * as the `vehicle_label` of the corresponding
   * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute].
   *
   * @generated from field: string label = 27;
   */
  label: string;

  /**
   * If true, `used_if_route_is_empty` must be false, and this vehicle will
   * remain unused.
   *
   * If a shipment is performed by an ignored vehicle in
   * `injected_first_solution_routes`, it is skipped in the first solution but
   * is free to be performed in the response.
   *
   * If a shipment is performed by an ignored vehicle in
   * `injected_solution_constraint` and any related pickup/delivery is
   * constrained to remain on the vehicle (i.e., not relaxed to level
   * `RELAX_ALL_AFTER_THRESHOLD`), it is skipped in the response.
   * If a shipment has a non-empty `allowed_vehicle_indices` field and all of
   * the allowed vehicles are ignored, it is skipped in the response.
   *
   * @generated from field: bool ignore = 28;
   */
  ignore: boolean;

  /**
   * Deprecated: No longer used.
   * Indices in the `break_rule` field in the source
   * [ShipmentModel][google.cloud.optimization.v1.ShipmentModel]. They
   * correspond to break rules enforced on the vehicle.
   *
   * As of 2018/03, at most one rule index per vehicle can be specified.
   *
   * @generated from field: repeated int32 break_rule_indices = 29 [deprecated = true];
   * @deprecated
   */
  breakRuleIndices: number[];

  /**
   * Deprecated: Use
   * [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity capacities = 13 [deprecated = true];
   * @deprecated
   */
  capacities: CapacityQuantity[];

  /**
   * Deprecated: Use
   * [Vehicle.LoadLimit.start_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.start_load_interval]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantityInterval start_load_intervals = 14 [deprecated = true];
   * @deprecated
   */
  startLoadIntervals: CapacityQuantityInterval[];

  /**
   * Deprecated: Use
   * [Vehicle.LoadLimit.end_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.end_load_interval]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantityInterval end_load_intervals = 15 [deprecated = true];
   * @deprecated
   */
  endLoadIntervals: CapacityQuantityInterval[];
};

/**
 * Describes the message google.cloud.optimization.v1.Vehicle.
 * Use `create(VehicleSchema)` to create a new message.
 */
export const VehicleSchema: GenMessage<Vehicle> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 9);

/**
 * Defines a load limit applying to a vehicle, e.g. "this truck may only
 * carry up to 3500 kg". See
 * [load_limits][google.cloud.optimization.v1.Vehicle.load_limits].
 *
 * @generated from message google.cloud.optimization.v1.Vehicle.LoadLimit
 */
export type Vehicle_LoadLimit = Message<"google.cloud.optimization.v1.Vehicle.LoadLimit"> & {
  /**
   * The maximum acceptable amount of load.
   *
   * @generated from field: optional int64 max_load = 1;
   */
  maxLoad?: bigint;

  /**
   * A soft limit of the load. See
   * [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max].
   *
   * @generated from field: int64 soft_max_load = 2;
   */
  softMaxLoad: bigint;

  /**
   * If the load ever exceeds
   * [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load]
   * along this vehicle's route, the following cost penalty applies (only once
   * per vehicle): (load -
   * [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load])
   * * [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max]. All costs
   * add up and must be in the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   *
   * @generated from field: double cost_per_unit_above_soft_max = 3;
   */
  costPerUnitAboveSoftMax: number;

  /**
   * The acceptable load interval of the vehicle at the start of the route.
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.LoadLimit.Interval start_load_interval = 4;
   */
  startLoadInterval?: Vehicle_LoadLimit_Interval;

  /**
   * The acceptable load interval of the vehicle at the end of the route.
   *
   * @generated from field: google.cloud.optimization.v1.Vehicle.LoadLimit.Interval end_load_interval = 5;
   */
  endLoadInterval?: Vehicle_LoadLimit_Interval;
};

/**
 * Describes the message google.cloud.optimization.v1.Vehicle.LoadLimit.
 * Use `create(Vehicle_LoadLimitSchema)` to create a new message.
 */
export const Vehicle_LoadLimitSchema: GenMessage<Vehicle_LoadLimit> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 9, 0);

/**
 * Interval of acceptable load amounts.
 *
 * @generated from message google.cloud.optimization.v1.Vehicle.LoadLimit.Interval
 */
export type Vehicle_LoadLimit_Interval = Message<"google.cloud.optimization.v1.Vehicle.LoadLimit.Interval"> & {
  /**
   * A minimum acceptable load. Must be  0.
   * If they're both specified,
   * [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must
   * be 
   * [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].
   *
   * @generated from field: int64 min = 1;
   */
  min: bigint;

  /**
   * A maximum acceptable load. Must be  0. If unspecified, the maximum
   * load is unrestricted by this message.
   * If they're both specified,
   * [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must
   * be 
   * [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].
   *
   * @generated from field: optional int64 max = 2;
   */
  max?: bigint;
};

/**
 * Describes the message google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.
 * Use `create(Vehicle_LoadLimit_IntervalSchema)` to create a new message.
 */
export const Vehicle_LoadLimit_IntervalSchema: GenMessage<Vehicle_LoadLimit_Interval> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 9, 0, 0);

/**
 * A limit defining a maximum duration of the route of a vehicle. It can be
 * either hard or soft.
 *
 * When a soft limit field is defined, both the soft max threshold and its
 * associated cost must be defined together.
 *
 * @generated from message google.cloud.optimization.v1.Vehicle.DurationLimit
 */
export type Vehicle_DurationLimit = Message<"google.cloud.optimization.v1.Vehicle.DurationLimit"> & {
  /**
   * A hard limit constraining the duration to be at most max_duration.
   *
   * @generated from field: google.protobuf.Duration max_duration = 1;
   */
  maxDuration?: Duration;

  /**
   * A soft limit not enforcing a maximum duration limit, but when violated
   * makes the route incur a cost. This cost adds up to other costs defined in
   * the model, with the same unit.
   *
   * If defined, `soft_max_duration` must be nonnegative. If max_duration is
   * also defined, `soft_max_duration` must be less than max_duration.
   *
   * @generated from field: google.protobuf.Duration soft_max_duration = 2;
   */
  softMaxDuration?: Duration;

  /**
   * Cost per hour incurred if the `soft_max_duration` threshold is violated.
   * The additional cost is 0 if the duration is under the threshold,
   * otherwise the cost depends on the duration as follows:
   * ```
   *   cost_per_hour_after_soft_max * (duration - soft_max_duration)
   * ```
   * The cost must be nonnegative.
   *
   * @generated from field: optional double cost_per_hour_after_soft_max = 3;
   */
  costPerHourAfterSoftMax?: number;

  /**
   * A soft limit not enforcing a maximum duration limit, but when violated
   * makes the route incur a cost, quadratic in the duration. This cost adds
   * up to other costs defined in the model, with the same unit.
   *
   * If defined, `quadratic_soft_max_duration` must be nonnegative. If
   * `max_duration` is also defined, `quadratic_soft_max_duration` must be
   * less than `max_duration`, and the difference must be no larger than one
   * day:
   *
   *    `max_duration - quadratic_soft_max_duration <= 86400 seconds`
   *
   * @generated from field: google.protobuf.Duration quadratic_soft_max_duration = 4;
   */
  quadraticSoftMaxDuration?: Duration;

  /**
   * Cost per square hour incurred if the
   * `quadratic_soft_max_duration` threshold is violated.
   *
   * The additional cost is 0 if the duration is under the threshold,
   * otherwise the cost depends on the duration as follows:
   *
   * ```
   *   cost_per_square_hour_after_quadratic_soft_max *
   *   (duration - quadratic_soft_max_duration)^2
   * ```
   *
   * The cost must be nonnegative.
   *
   * @generated from field: optional double cost_per_square_hour_after_quadratic_soft_max = 5;
   */
  costPerSquareHourAfterQuadraticSoftMax?: number;
};

/**
 * Describes the message google.cloud.optimization.v1.Vehicle.DurationLimit.
 * Use `create(Vehicle_DurationLimitSchema)` to create a new message.
 */
export const Vehicle_DurationLimitSchema: GenMessage<Vehicle_DurationLimit> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 9, 1);

/**
 * Travel modes which can be used by vehicles.
 *
 * These should be a subset of the Google Maps Platform Routes Preferred API
 * travel modes, see:
 * https://developers.google.com/maps/documentation/routes_preferred/reference/rest/Shared.Types/RouteTravelMode.
 *
 * @generated from enum google.cloud.optimization.v1.Vehicle.TravelMode
 */
export enum Vehicle_TravelMode {
  /**
   * Unspecified travel mode, equivalent to `DRIVING`.
   *
   * @generated from enum value: TRAVEL_MODE_UNSPECIFIED = 0;
   */
  TRAVEL_MODE_UNSPECIFIED = 0,

  /**
   * Travel mode corresponding to driving directions (car, ...).
   *
   * @generated from enum value: DRIVING = 1;
   */
  DRIVING = 1,

  /**
   * Travel mode corresponding to walking directions.
   *
   * @generated from enum value: WALKING = 2;
   */
  WALKING = 2,
}

/**
 * Describes the enum google.cloud.optimization.v1.Vehicle.TravelMode.
 */
export const Vehicle_TravelModeSchema: GenEnum<Vehicle_TravelMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 9, 0);

/**
 * Policy on how a vehicle can be unloaded. Applies only to shipments having
 * both a pickup and a delivery.
 *
 * Other shipments are free to occur anywhere on the route independent of
 * `unloading_policy`.
 *
 * @generated from enum google.cloud.optimization.v1.Vehicle.UnloadingPolicy
 */
export enum Vehicle_UnloadingPolicy {
  /**
   * Unspecified unloading policy; deliveries must just occur after their
   * corresponding pickups.
   *
   * @generated from enum value: UNLOADING_POLICY_UNSPECIFIED = 0;
   */
  UNLOADING_POLICY_UNSPECIFIED = 0,

  /**
   * Deliveries must occur in reverse order of pickups
   *
   * @generated from enum value: LAST_IN_FIRST_OUT = 1;
   */
  LAST_IN_FIRST_OUT = 1,

  /**
   * Deliveries must occur in the same order as pickups
   *
   * @generated from enum value: FIRST_IN_FIRST_OUT = 2;
   */
  FIRST_IN_FIRST_OUT = 2,
}

/**
 * Describes the enum google.cloud.optimization.v1.Vehicle.UnloadingPolicy.
 */
export const Vehicle_UnloadingPolicySchema: GenEnum<Vehicle_UnloadingPolicy> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 9, 1);

/**
 * Time windows constrain the time of an event, such as the arrival time at a
 * visit, or the start and end time of a vehicle.
 *
 * Hard time window bounds, `start_time` and `end_time`, enforce the earliest
 * and latest time of the event, such that `start_time <= event_time <=
 * end_time`. The soft time window lower bound, `soft_start_time`, expresses a
 * preference for the event to happen at or after `soft_start_time` by incurring
 * a cost proportional to how long before soft_start_time the event occurs. The
 * soft time window upper bound, `soft_end_time`, expresses a preference for the
 * event to happen at or before `soft_end_time` by incurring a cost proportional
 * to how long after `soft_end_time` the event occurs. `start_time`, `end_time`,
 * `soft_start_time` and `soft_end_time` should be within the global time limits
 * (see
 * [ShipmentModel.global_start_time][google.cloud.optimization.v1.ShipmentModel.global_start_time]
 * and
 * [ShipmentModel.global_end_time][google.cloud.optimization.v1.ShipmentModel.global_end_time])
 * and should respect:
 * ```
 *   0 <= `start_time` <= `soft_start_time` <= `end_time` and
 *   0 <= `start_time` <= `soft_end_time` <= `end_time`.
 * ```
 *
 * @generated from message google.cloud.optimization.v1.TimeWindow
 */
export type TimeWindow = Message<"google.cloud.optimization.v1.TimeWindow"> & {
  /**
   * The hard time window start time. If unspecified it will be set to
   * `ShipmentModel.global_start_time`.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * The hard time window end time. If unspecified it will be set to
   * `ShipmentModel.global_end_time`.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * The soft start time of the time window.
   *
   * @generated from field: google.protobuf.Timestamp soft_start_time = 3;
   */
  softStartTime?: Timestamp;

  /**
   * The soft end time of the time window.
   *
   * @generated from field: google.protobuf.Timestamp soft_end_time = 4;
   */
  softEndTime?: Timestamp;

  /**
   * A cost per hour added to other costs in the model if the event occurs
   * before soft_start_time, computed as:
   *
   * ```
   *    max(0, soft_start_time - t.seconds)
   *                           * cost_per_hour_before_soft_start_time / 3600,
   * t being the time of the event.
   * ```
   *
   * This cost must be positive, and the field can only be set if
   * soft_start_time has been set.
   *
   * @generated from field: optional double cost_per_hour_before_soft_start_time = 5;
   */
  costPerHourBeforeSoftStartTime?: number;

  /**
   * A cost per hour added to other costs in the model if the event occurs after
   * `soft_end_time`, computed as:
   *
   * ```
   *    max(0, t.seconds - soft_end_time.seconds)
   *                     * cost_per_hour_after_soft_end_time / 3600,
   * t being the time of the event.
   * ```
   *
   * This cost must be positive, and the field can only be set if
   * `soft_end_time` has been set.
   *
   * @generated from field: optional double cost_per_hour_after_soft_end_time = 6;
   */
  costPerHourAfterSoftEndTime?: number;
};

/**
 * Describes the message google.cloud.optimization.v1.TimeWindow.
 * Use `create(TimeWindowSchema)` to create a new message.
 */
export const TimeWindowSchema: GenMessage<TimeWindow> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 10);

/**
 * Deprecated: Use
 * [Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]
 * instead.
 *
 * @generated from message google.cloud.optimization.v1.CapacityQuantity
 * @deprecated
 */
export type CapacityQuantity = Message<"google.cloud.optimization.v1.CapacityQuantity"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: int64 value = 2;
   */
  value: bigint;
};

/**
 * Describes the message google.cloud.optimization.v1.CapacityQuantity.
 * Use `create(CapacityQuantitySchema)` to create a new message.
 * @deprecated
 */
export const CapacityQuantitySchema: GenMessage<CapacityQuantity> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 11);

/**
 * Deprecated: Use
 * [Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]
 * instead.
 *
 * @generated from message google.cloud.optimization.v1.CapacityQuantityInterval
 * @deprecated
 */
export type CapacityQuantityInterval = Message<"google.cloud.optimization.v1.CapacityQuantityInterval"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: optional int64 min_value = 2;
   */
  minValue?: bigint;

  /**
   * @generated from field: optional int64 max_value = 3;
   */
  maxValue?: bigint;
};

/**
 * Describes the message google.cloud.optimization.v1.CapacityQuantityInterval.
 * Use `create(CapacityQuantityIntervalSchema)` to create a new message.
 * @deprecated
 */
export const CapacityQuantityIntervalSchema: GenMessage<CapacityQuantityInterval> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 12);

/**
 * A limit defining a maximum distance which can be traveled. It can be either
 * hard or soft.
 *
 * If a soft limit is defined, both `soft_max_meters` and
 * `cost_per_kilometer_above_soft_max` must be defined and be nonnegative.
 *
 * @generated from message google.cloud.optimization.v1.DistanceLimit
 */
export type DistanceLimit = Message<"google.cloud.optimization.v1.DistanceLimit"> & {
  /**
   * A hard limit constraining the distance to be at most max_meters. The limit
   * must be nonnegative.
   *
   * @generated from field: optional int64 max_meters = 1;
   */
  maxMeters?: bigint;

  /**
   * A soft limit not enforcing a maximum distance limit, but when violated
   * results in a cost which adds up to other costs defined in the model,
   * with the same unit.
   *
   * If defined soft_max_meters must be less than max_meters and must be
   * nonnegative.
   *
   * @generated from field: optional int64 soft_max_meters = 2;
   */
  softMaxMeters?: bigint;

  /**
   * Cost per kilometer incurred, increasing up to `soft_max_meters`, with
   * formula:
   * ```
   *   min(distance_meters, soft_max_meters) / 1000.0 *
   *   cost_per_kilometer_below_soft_max.
   * ```
   * This cost is not supported in `route_distance_limit`.
   *
   * @generated from field: optional double cost_per_kilometer_below_soft_max = 4;
   */
  costPerKilometerBelowSoftMax?: number;

  /**
   * Cost per kilometer incurred if distance is above `soft_max_meters` limit.
   * The additional cost is 0 if the distance is under the limit, otherwise the
   * formula used to compute the cost is the following:
   * ```
   *   (distance_meters - soft_max_meters) / 1000.0 *
   *   cost_per_kilometer_above_soft_max.
   * ```
   * The cost must be nonnegative.
   *
   * @generated from field: optional double cost_per_kilometer_above_soft_max = 3;
   */
  costPerKilometerAboveSoftMax?: number;
};

/**
 * Describes the message google.cloud.optimization.v1.DistanceLimit.
 * Use `create(DistanceLimitSchema)` to create a new message.
 */
export const DistanceLimitSchema: GenMessage<DistanceLimit> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 13);

/**
 * Specifies attributes of transitions between two consecutive visits on a
 * route. Several `TransitionAttributes` may apply to the same transition: in
 * that case, all extra costs add up and the strictest constraint or limit
 * applies (following natural "AND" semantics).
 *
 * @generated from message google.cloud.optimization.v1.TransitionAttributes
 */
export type TransitionAttributes = Message<"google.cloud.optimization.v1.TransitionAttributes"> & {
  /**
   * Tags defining the set of (src->dst) transitions these attributes apply to.
   *
   * A source visit or vehicle start matches iff its
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags]
   * either contains `src_tag` or does not contain `excluded_src_tag` (depending
   * on which of these two fields is non-empty).
   *
   * @generated from field: string src_tag = 1;
   */
  srcTag: string;

  /**
   * See `src_tag`. Exactly one of `src_tag` and `excluded_src_tag` must be
   * non-empty.
   *
   * @generated from field: string excluded_src_tag = 2;
   */
  excludedSrcTag: string;

  /**
   * A destination visit or vehicle end matches iff its
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.end_tags][google.cloud.optimization.v1.Vehicle.end_tags] either
   * contains `dst_tag` or does not contain `excluded_dst_tag` (depending on
   * which of these two fields is non-empty).
   *
   * @generated from field: string dst_tag = 3;
   */
  dstTag: string;

  /**
   * See `dst_tag`. Exactly one of `dst_tag` and `excluded_dst_tag` must be
   * non-empty.
   *
   * @generated from field: string excluded_dst_tag = 4;
   */
  excludedDstTag: string;

  /**
   * Specifies a cost for performing this transition. This is in the same unit
   * as all other costs in the model and must not be negative. It is applied on
   * top of all other existing costs.
   *
   * @generated from field: double cost = 5;
   */
  cost: number;

  /**
   * Specifies a cost per kilometer applied to the distance traveled while
   * performing this transition. It adds up to any
   * [Vehicle.cost_per_kilometer][google.cloud.optimization.v1.Vehicle.cost_per_kilometer]
   * specified on vehicles.
   *
   * @generated from field: double cost_per_kilometer = 6;
   */
  costPerKilometer: number;

  /**
   * Specifies a limit on the distance traveled while performing this
   * transition.
   *
   * As of 2021/06, only soft limits are supported.
   *
   * @generated from field: google.cloud.optimization.v1.DistanceLimit distance_limit = 7;
   */
  distanceLimit?: DistanceLimit;

  /**
   * Specifies a delay incurred when performing this transition.
   *
   * This delay always occurs *after* finishing the source visit and *before*
   * starting the destination visit.
   *
   * @generated from field: google.protobuf.Duration delay = 8;
   */
  delay?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.TransitionAttributes.
 * Use `create(TransitionAttributesSchema)` to create a new message.
 */
export const TransitionAttributesSchema: GenMessage<TransitionAttributes> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 14);

/**
 * Encapsulates a waypoint. Waypoints mark arrival and departure locations of
 * VisitRequests, and start and end locations of Vehicles.
 *
 * @generated from message google.cloud.optimization.v1.Waypoint
 */
export type Waypoint = Message<"google.cloud.optimization.v1.Waypoint"> & {
  /**
   * Different ways to represent a location.
   *
   * @generated from oneof google.cloud.optimization.v1.Waypoint.location_type
   */
  locationType: {
    /**
     * A point specified using geographic coordinates, including an optional
     * heading.
     *
     * @generated from field: google.cloud.optimization.v1.Location location = 1;
     */
    value: Location;
    case: "location";
  } | {
    /**
     * The POI Place ID associated with the waypoint.
     *
     * @generated from field: string place_id = 2;
     */
    value: string;
    case: "placeId";
  } | { case: undefined; value?: undefined };

  /**
   * Indicates that the location of this waypoint is meant to have a preference
   * for the vehicle to stop at a particular side of road. When you set this
   * value, the route will pass through the location so that the vehicle can
   * stop at the side of road that the location is biased towards from the
   * center of the road. This option works only for the 'DRIVING' travel mode,
   * and when the 'location_type' is set to 'location'.
   *
   * @generated from field: bool side_of_road = 3;
   */
  sideOfRoad: boolean;
};

/**
 * Describes the message google.cloud.optimization.v1.Waypoint.
 * Use `create(WaypointSchema)` to create a new message.
 */
export const WaypointSchema: GenMessage<Waypoint> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 15);

/**
 * Encapsulates a location (a geographic point, and an optional heading).
 *
 * @generated from message google.cloud.optimization.v1.Location
 */
export type Location = Message<"google.cloud.optimization.v1.Location"> & {
  /**
   * The waypoint's geographic coordinates.
   *
   * @generated from field: google.type.LatLng lat_lng = 1;
   */
  latLng?: LatLng;

  /**
   * The compass heading associated with the direction of the flow of traffic.
   * This value is used to specify the side of the road to use for pickup and
   * drop-off. Heading values can be from 0 to 360, where 0 specifies a heading
   * of due North, 90 specifies a heading of due East, etc.
   *
   * @generated from field: optional int32 heading = 2;
   */
  heading?: number;
};

/**
 * Describes the message google.cloud.optimization.v1.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 16);

/**
 * Rules to generate time breaks for a vehicle (e.g. lunch breaks). A break
 * is a contiguous period of time during which the vehicle remains idle at its
 * current position and cannot perform any visit. A break may occur:
 *
 * * during the travel between two visits (which includes the time right
 *   before or right after a visit, but not in the middle of a visit), in
 *   which case it extends the corresponding transit time between the visits,
 * * or before the vehicle start (the vehicle may not start in the middle of
 *   a break), in which case it does not affect the vehicle start time.
 * * or after the vehicle end (ditto, with the vehicle end time).
 *
 * @generated from message google.cloud.optimization.v1.BreakRule
 */
export type BreakRule = Message<"google.cloud.optimization.v1.BreakRule"> & {
  /**
   * Sequence of breaks. See the `BreakRequest` message.
   *
   * @generated from field: repeated google.cloud.optimization.v1.BreakRule.BreakRequest break_requests = 1;
   */
  breakRequests: BreakRule_BreakRequest[];

  /**
   * Several `FrequencyConstraint` may apply. They must all be satisfied by
   * the `BreakRequest`s of this `BreakRule`. See `FrequencyConstraint`.
   *
   * @generated from field: repeated google.cloud.optimization.v1.BreakRule.FrequencyConstraint frequency_constraints = 2;
   */
  frequencyConstraints: BreakRule_FrequencyConstraint[];
};

/**
 * Describes the message google.cloud.optimization.v1.BreakRule.
 * Use `create(BreakRuleSchema)` to create a new message.
 */
export const BreakRuleSchema: GenMessage<BreakRule> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 17);

/**
 * The sequence of breaks (i.e. their number and order) that apply to each
 * vehicle must be known beforehand. The repeated `BreakRequest`s define
 * that sequence, in the order in which they must occur. Their time windows
 * (`earliest_start_time` / `latest_start_time`) may overlap, but they must
 * be compatible with the order (this is checked).
 *
 * @generated from message google.cloud.optimization.v1.BreakRule.BreakRequest
 */
export type BreakRule_BreakRequest = Message<"google.cloud.optimization.v1.BreakRule.BreakRequest"> & {
  /**
   * Required. Lower bound (inclusive) on the start of the break.
   *
   * @generated from field: google.protobuf.Timestamp earliest_start_time = 1;
   */
  earliestStartTime?: Timestamp;

  /**
   * Required. Upper bound (inclusive) on the start of the break.
   *
   * @generated from field: google.protobuf.Timestamp latest_start_time = 2;
   */
  latestStartTime?: Timestamp;

  /**
   * Required. Minimum duration of the break. Must be positive.
   *
   * @generated from field: google.protobuf.Duration min_duration = 3;
   */
  minDuration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.BreakRule.BreakRequest.
 * Use `create(BreakRule_BreakRequestSchema)` to create a new message.
 */
export const BreakRule_BreakRequestSchema: GenMessage<BreakRule_BreakRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 17, 0);

/**
 * One may further constrain the frequency and duration of the breaks
 * specified above, by enforcing a minimum break frequency, such as
 * "There must be a break of at least 1 hour every 12 hours". Assuming that
 * this can be interpreted as "Within any sliding time window of 12h, there
 * must be at least one break of at least one hour", that example would
 * translate to the following `FrequencyConstraint`:
 * ```
 * {
 *    min_break_duration { seconds: 3600 }         # 1 hour.
 *    max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).
 * }
 * ```
 *
 * The timing and duration of the breaks in the solution will respect all
 * such constraints, in addition to the time windows and minimum durations
 * already specified in the `BreakRequest`.
 *
 * A `FrequencyConstraint` may in practice apply to non-consecutive breaks.
 * For example, the following schedule honors the "1h every 12h" example:
 * ```
 *   04:00 vehicle start
 *    .. performing travel and visits ..
 *   09:00 1 hour break
 *   10:00 end of the break
 *    .. performing travel and visits ..
 *   12:00 20-min lunch break
 *   12:20 end of the break
 *    .. performing travel and visits ..
 *   21:00 1 hour break
 *   22:00 end of the break
 *    .. performing travel and visits ..
 *   23:59 vehicle end
 * ```
 *
 * @generated from message google.cloud.optimization.v1.BreakRule.FrequencyConstraint
 */
export type BreakRule_FrequencyConstraint = Message<"google.cloud.optimization.v1.BreakRule.FrequencyConstraint"> & {
  /**
   * Required. Minimum break duration for this constraint. Nonnegative.
   * See description of `FrequencyConstraint`.
   *
   * @generated from field: google.protobuf.Duration min_break_duration = 1;
   */
  minBreakDuration?: Duration;

  /**
   * Required. Maximum allowed span of any interval of time in the route that
   * does not include at least partially a break of `duration >=
   * min_break_duration`. Must be positive.
   *
   * @generated from field: google.protobuf.Duration max_inter_break_duration = 2;
   */
  maxInterBreakDuration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.BreakRule.FrequencyConstraint.
 * Use `create(BreakRule_FrequencyConstraintSchema)` to create a new message.
 */
export const BreakRule_FrequencyConstraintSchema: GenMessage<BreakRule_FrequencyConstraint> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 17, 1);

/**
 * A vehicle's route can be decomposed, along the time axis, like this (we
 * assume there are n visits):
 * ```
 *   |            |            |          |       |  T[2], |        |      |
 *   | Transition |  Visit #0  |          |       |  V[2], |        |      |
 *   |     #0     |    aka     |   T[1]   |  V[1] |  ...   | V[n-1] | T[n] |
 *   |  aka T[0]  |    V[0]    |          |       | V[n-2],|        |      |
 *   |            |            |          |       | T[n-1] |        |      |
 *   ^            ^            ^          ^       ^        ^        ^      ^
 * vehicle    V[0].start   V[0].end     V[1].   V[1].    V[n].    V[n]. vehicle
 *  start     (arrival)   (departure)   start   end      start    end     end
 * ```
 * Note that we make a difference between:
 *
 * * "punctual events", such as the vehicle start and end and each visit's start
 *   and end (aka arrival and departure). They happen at a given second.
 * * "time intervals", such as the visits themselves, and the transition between
 *   visits. Though time intervals can sometimes have zero duration, i.e. start
 *   and end at the same second, they often have a positive duration.
 *
 * Invariants:
 *
 * * If there are n visits, there are n+1 transitions.
 * * A visit is always surrounded by a transition before it (same index) and a
 *   transition after it (index + 1).
 * * The vehicle start is always followed by transition #0.
 * * The vehicle end is always preceded by transition #n.
 *
 * Zooming in, here is what happens during a `Transition` and a `Visit`:
 * ```
 * ---+-------------------------------------+-----------------------------+-->
 *    |           TRANSITION[i]             |           VISIT[i]          |
 *    |                                     |                             |
 *    |  * TRAVEL: the vehicle moves from   |      PERFORM the visit:     |
 *    |    VISIT[i-1].departure_location to |                             |
 *    |    VISIT[i].arrival_location, which |  * Spend some time:         |
 *    |    takes a given travel duration    |    the "visit duration".    |
 *    |    and distance                     |                             |
 *    |                                     |  * Load or unload           |
 *    |  * BREAKS: the driver may have      |    some quantities from the |
 *    |    breaks (e.g. lunch break).       |    vehicle: the "demand".   |
 *    |                                     |                             |
 *    |  * WAIT: the driver/vehicle does    |                             |
 *    |    nothing. This can happen for     |                             |
 *    |    many reasons, for example when   |                             |
 *    |    the vehicle reaches the next     |                             |
 *    |    event's destination before the   |                             |
 *    |    start of its time window         |                             |
 *    |                                     |                             |
 *    |  * DELAY: *right before* the next   |                             |
 *    |    arrival. E.g. the vehicle and/or |                             |
 *    |    driver spends time unloading.    |                             |
 *    |                                     |                             |
 * ---+-------------------------------------+-----------------------------+-->
 *    ^                                     ^                             ^
 * V[i-1].end                           V[i].start                    V[i].end
 * ```
 * Lastly, here is how the TRAVEL, BREAKS, DELAY and WAIT can be arranged
 * during a transition.
 *
 * * They don't overlap.
 * * The DELAY is unique and *must* be a contiguous period of time right
 *   before the next visit (or vehicle end). Thus, it suffice to know the
 *   delay duration to know its start and end time.
 * * The BREAKS are contiguous, non-overlapping periods of time. The
 *   response specifies the start time and duration of each break.
 * * TRAVEL and WAIT are "preemptable": they can be interrupted several times
 *   during this transition. Clients can assume that travel happens "as soon as
 *   possible" and that "wait" fills the remaining time.
 *
 * A (complex) example:
 * ```
 *                                TRANSITION[i]
 * --++-----+-----------------------------------------------------------++-->
 *   ||     |       |           |       |           |         |         ||
 *   ||  T  |   B   |     T     |       |     B     |         |    D    ||
 *   ||  r  |   r   |     r     |   W   |     r     |    W    |    e    ||
 *   ||  a  |   e   |     a     |   a   |     e     |    a    |    l    ||
 *   ||  v  |   a   |     v     |   i   |     a     |    i    |    a    ||
 *   ||  e  |   k   |     e     |   t   |     k     |    t    |    y    ||
 *   ||  l  |       |     l     |       |           |         |         ||
 *   ||     |       |           |       |           |         |         ||
 * --++-----------------------------------------------------------------++-->
 * ```
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute
 */
export type ShipmentRoute = Message<"google.cloud.optimization.v1.ShipmentRoute"> & {
  /**
   * Vehicle performing the route, identified by its index in the source
   * `ShipmentModel`.
   *
   * @generated from field: int32 vehicle_index = 1;
   */
  vehicleIndex: number;

  /**
   * Label of the vehicle performing this route, equal to
   * `ShipmentModel.vehicles(vehicle_index).label`, if specified.
   *
   * @generated from field: string vehicle_label = 2;
   */
  vehicleLabel: string;

  /**
   * Time at which the vehicle starts its route.
   *
   * @generated from field: google.protobuf.Timestamp vehicle_start_time = 5;
   */
  vehicleStartTime?: Timestamp;

  /**
   * Time at which the vehicle finishes its route.
   *
   * @generated from field: google.protobuf.Timestamp vehicle_end_time = 6;
   */
  vehicleEndTime?: Timestamp;

  /**
   * Ordered sequence of visits representing a route.
   * visits[i] is the i-th visit in the route.
   * If this field is empty, the vehicle is considered as unused.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute.Visit visits = 7;
   */
  visits: ShipmentRoute_Visit[];

  /**
   * Ordered list of transitions for the route.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute.Transition transitions = 8;
   */
  transitions: ShipmentRoute_Transition[];

  /**
   * When
   * [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * is set to true, this field indicates that inconsistencies in route timings
   * are predicted using traffic-based travel duration estimates. There may be
   * insufficient time to complete traffic-adjusted travel, delays, and breaks
   * between visits, before the first visit, or after the last visit, while
   * still satisfying the visit and vehicle time windows. For example,
   *
   * ```
   *   start_time(previous_visit) + duration(previous_visit) +
   *   travel_duration(previous_visit, next_visit) > start_time(next_visit)
   * ```
   *
   * Arrival at next_visit will likely happen later than its current
   * time window due the increased estimate of travel time
   * `travel_duration(previous_visit, next_visit)` due to traffic. Also, a break
   * may be forced to overlap with a visit due to an increase in travel time
   * estimates and visit or break time window restrictions.
   *
   * @generated from field: bool has_traffic_infeasibilities = 9;
   */
  hasTrafficInfeasibilities: boolean;

  /**
   * The encoded polyline representation of the route.
   * This field is only populated if
   * [OptimizeToursRequest.populate_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_polylines]
   * is set to true.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline route_polyline = 10;
   */
  routePolyline?: ShipmentRoute_EncodedPolyline;

  /**
   * Breaks scheduled for the vehicle performing this route.
   * The `breaks` sequence represents time intervals, each starting at the
   * corresponding `start_time` and lasting `duration` seconds.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute.Break breaks = 11;
   */
  breaks: ShipmentRoute_Break[];

  /**
   * Duration, distance and load metrics for this route. The fields of
   * [AggregatedMetrics][google.cloud.optimization.v1.AggregatedMetrics] are
   * summed over all
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * or
   * [ShipmentRoute.visits][google.cloud.optimization.v1.ShipmentRoute.visits],
   * depending on the context.
   *
   * @generated from field: google.cloud.optimization.v1.AggregatedMetrics metrics = 12;
   */
  metrics?: AggregatedMetrics;

  /**
   * Cost of the route, broken down by cost-related request fields.
   * The keys are proto paths, relative to the input OptimizeToursRequest, e.g.
   * "model.shipments.pickups.cost", and the values are the total cost
   * generated by the corresponding cost field, aggregated over the whole route.
   * In other words, costs["model.shipments.pickups.cost"] is the sum of all
   * pickup costs over the route. All costs defined in the model are reported in
   * detail here with the exception of costs related to TransitionAttributes
   * that are only reported in an aggregated way as of 2022/01.
   *
   * @generated from field: map<string, double> route_costs = 17;
   */
  routeCosts: { [key: string]: number };

  /**
   * Total cost of the route. The sum of all costs in the cost map.
   *
   * @generated from field: double route_total_cost = 18;
   */
  routeTotalCost: number;

  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead. Vehicle loads upon arrival at its end location, for each type
   * specified in
   * [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities],
   * `start_load_intervals`, `end_load_intervals` or demands. Exception: we omit
   * loads for quantity types unconstrained by intervals and that don't have any
   * non-zero demand on the route.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity end_loads = 13 [deprecated = true];
   * @deprecated
   */
  endLoads: CapacityQuantity[];

  /**
   * Deprecated: Use
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * instead. Ordered list of travel steps for the route.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute.TravelStep travel_steps = 14 [deprecated = true];
   * @deprecated
   */
  travelSteps: ShipmentRoute_TravelStep[];

  /**
   * Deprecated: No longer used.
   * This field will only be populated at the
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit]
   * level.
   *
   * This field is the extra detour time due to the shipments visited on the
   * route.
   *
   * It is equal to `vehicle_end_time` - `vehicle_start_time` - travel duration
   * from the vehicle's start_location to its `end_location`.
   *
   * @generated from field: google.protobuf.Duration vehicle_detour = 15 [deprecated = true];
   * @deprecated
   */
  vehicleDetour?: Duration;

  /**
   * Deprecated: Delay occurring before the vehicle end. See
   * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentRoute.Delay delay_before_vehicle_end = 16 [deprecated = true];
   * @deprecated
   */
  delayBeforeVehicleEnd?: ShipmentRoute_Delay;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.
 * Use `create(ShipmentRouteSchema)` to create a new message.
 */
export const ShipmentRouteSchema: GenMessage<ShipmentRoute> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18);

/**
 * Deprecated: Use
 * [ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration]
 * instead. Time interval spent on the route resulting from a
 * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.Delay
 * @deprecated
 */
export type ShipmentRoute_Delay = Message<"google.cloud.optimization.v1.ShipmentRoute.Delay"> & {
  /**
   * Start of the delay.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * Duration of the delay.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.Delay.
 * Use `create(ShipmentRoute_DelaySchema)` to create a new message.
 * @deprecated
 */
export const ShipmentRoute_DelaySchema: GenMessage<ShipmentRoute_Delay> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 0);

/**
 * A visit performed during a route. This visit corresponds to a pickup or a
 * delivery of a `Shipment`.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.Visit
 */
export type ShipmentRoute_Visit = Message<"google.cloud.optimization.v1.ShipmentRoute.Visit"> & {
  /**
   * Index of the `shipments` field in the source
   * [ShipmentModel][google.cloud.optimization.v1.ShipmentModel].
   *
   * @generated from field: int32 shipment_index = 1;
   */
  shipmentIndex: number;

  /**
   * If true the visit corresponds to a pickup of a `Shipment`. Otherwise, it
   * corresponds to a delivery.
   *
   * @generated from field: bool is_pickup = 2;
   */
  isPickup: boolean;

  /**
   * Index of `VisitRequest` in either the pickup or delivery field of the
   * `Shipment` (see `is_pickup`).
   *
   * @generated from field: int32 visit_request_index = 3;
   */
  visitRequestIndex: number;

  /**
   * Time at which the visit starts. Note that the vehicle may arrive earlier
   * than this at the visit location. Times are consistent with the
   * `ShipmentModel`.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * Total visit load demand as the sum of the shipment and the visit request
   * `load_demands`. The values are negative if the visit is a delivery.
   * Demands are reported for the same types as the
   * [Transition.loads][google.cloud.optimization.v1.ShipmentRoute.Transition]
   * (see this field).
   *
   * @generated from field: map<string, google.cloud.optimization.v1.Shipment.Load> load_demands = 11;
   */
  loadDemands: { [key: string]: Shipment_Load };

  /**
   * Extra detour time due to the shipments visited on the route before the
   * visit and to the potential waiting time induced by time windows.
   * If the visit is a delivery, the detour is computed from the corresponding
   * pickup visit and is equal to:
   * ```
   * start_time(delivery) - start_time(pickup)
   * - (duration(pickup) + travel duration from the pickup location
   * to the delivery location).
   * ```
   * Otherwise, it is computed from the vehicle `start_location` and is equal
   * to:
   * ```
   * start_time - vehicle_start_time - travel duration from
   * the vehicle's `start_location` to the visit.
   * ```
   *
   * @generated from field: google.protobuf.Duration detour = 6;
   */
  detour?: Duration;

  /**
   * Copy of the corresponding `Shipment.label`, if specified in the
   * `Shipment`.
   *
   * @generated from field: string shipment_label = 7;
   */
  shipmentLabel: string;

  /**
   * Copy of the corresponding
   * [VisitRequest.label][google.cloud.optimization.v1.Shipment.VisitRequest.label],
   * if specified in the `VisitRequest`.
   *
   * @generated from field: string visit_label = 8;
   */
  visitLabel: string;

  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead. Vehicle loads upon arrival at the visit location, for each type
   * specified in
   * [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities],
   * `start_load_intervals`, `end_load_intervals` or `demands`.
   *
   * Exception: we omit loads for quantity types unconstrained by intervals
   * and that don't have any non-zero demand on the route.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity arrival_loads = 9 [deprecated = true];
   * @deprecated
   */
  arrivalLoads: CapacityQuantity[];

  /**
   * Deprecated: Use
   * [ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration]
   * instead. Delay occurring before the visit starts.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentRoute.Delay delay_before_start = 10 [deprecated = true];
   * @deprecated
   */
  delayBeforeStart?: ShipmentRoute_Delay;

  /**
   * Deprecated: Use
   * [Visit.load_demands][google.cloud.optimization.v1.ShipmentRoute.Visit.load_demands]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity demands = 5 [deprecated = true];
   * @deprecated
   */
  demands: CapacityQuantity[];
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.Visit.
 * Use `create(ShipmentRoute_VisitSchema)` to create a new message.
 */
export const ShipmentRoute_VisitSchema: GenMessage<ShipmentRoute_Visit> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 1);

/**
 * Transition between two events on the route. See the description of
 * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute].
 *
 * If the vehicle does not have a `start_location` and/or `end_location`, the
 * corresponding travel metrics are 0.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.Transition
 */
export type ShipmentRoute_Transition = Message<"google.cloud.optimization.v1.ShipmentRoute.Transition"> & {
  /**
   * Travel duration during this transition.
   *
   * @generated from field: google.protobuf.Duration travel_duration = 1;
   */
  travelDuration?: Duration;

  /**
   * Distance traveled during the transition.
   *
   * @generated from field: double travel_distance_meters = 2;
   */
  travelDistanceMeters: number;

  /**
   * When traffic is requested via
   * [OptimizeToursRequest.consider_road_traffic]
   * [google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * and the traffic info couldn't be retrieved for a `Transition`, this
   * boolean is set to true. This may be temporary (rare hiccup in the
   * realtime traffic servers) or permanent (no data for this location).
   *
   * @generated from field: bool traffic_info_unavailable = 3;
   */
  trafficInfoUnavailable: boolean;

  /**
   * Sum of the delay durations applied to this transition. If any, the delay
   * starts exactly `delay_duration` seconds before the next event (visit or
   * vehicle end). See
   * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
   *
   * @generated from field: google.protobuf.Duration delay_duration = 4;
   */
  delayDuration?: Duration;

  /**
   * Sum of the duration of the breaks occurring during this transition, if
   * any. Details about each break's start time and duration are stored in
   * [ShipmentRoute.breaks][google.cloud.optimization.v1.ShipmentRoute.breaks].
   *
   * @generated from field: google.protobuf.Duration break_duration = 5;
   */
  breakDuration?: Duration;

  /**
   * Time spent waiting during this transition. Wait duration corresponds to
   * idle time and does not include break time. Also note that this wait time
   * may be split into several non-contiguous intervals.
   *
   * @generated from field: google.protobuf.Duration wait_duration = 6;
   */
  waitDuration?: Duration;

  /**
   * Total duration of the transition, provided for convenience. It is equal
   * to:
   *
   * * next visit `start_time` (or `vehicle_end_time` if this is the last
   * transition) - this transition's `start_time`;
   * * if `ShipmentRoute.has_traffic_infeasibilities` is false, the following
   * additionally holds: `total_duration = travel_duration + delay_duration
   * + break_duration + wait_duration`.
   *
   * @generated from field: google.protobuf.Duration total_duration = 7;
   */
  totalDuration?: Duration;

  /**
   * Start time of this transition.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 8;
   */
  startTime?: Timestamp;

  /**
   * The encoded polyline representation of the route followed during the
   * transition.
   * This field is only populated if [populate_transition_polylines]
   * [google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines]
   * is set to true.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline route_polyline = 9;
   */
  routePolyline?: ShipmentRoute_EncodedPolyline;

  /**
   * Vehicle loads during this transition, for each type that either appears
   * in this vehicle's
   * [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits],
   * or that have non-zero
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * on some shipment performed on this route.
   *
   * The loads during the first transition are the starting loads of the
   * vehicle route. Then, after each visit, the visit's `load_demands` are
   * either added or subtracted to get the next transition's loads, depending
   * on whether the visit was a pickup or a delivery.
   *
   * @generated from field: map<string, google.cloud.optimization.v1.ShipmentRoute.VehicleLoad> vehicle_loads = 11;
   */
  vehicleLoads: { [key: string]: ShipmentRoute_VehicleLoad };

  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead.
   *
   * @generated from field: repeated google.cloud.optimization.v1.CapacityQuantity loads = 10 [deprecated = true];
   * @deprecated
   */
  loads: CapacityQuantity[];
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.Transition.
 * Use `create(ShipmentRoute_TransitionSchema)` to create a new message.
 */
export const ShipmentRoute_TransitionSchema: GenMessage<ShipmentRoute_Transition> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 2);

/**
 * Reports the actual load of the vehicle at some point along the route,
 * for a given type (see
 * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]).
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.VehicleLoad
 */
export type ShipmentRoute_VehicleLoad = Message<"google.cloud.optimization.v1.ShipmentRoute.VehicleLoad"> & {
  /**
   * The amount of load on the vehicle, for the given type. The unit of load
   * is usually indicated by the type. See
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads].
   *
   * @generated from field: int64 amount = 1;
   */
  amount: bigint;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.VehicleLoad.
 * Use `create(ShipmentRoute_VehicleLoadSchema)` to create a new message.
 */
export const ShipmentRoute_VehicleLoadSchema: GenMessage<ShipmentRoute_VehicleLoad> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 3);

/**
 * The encoded representation of a polyline. More information on polyline
 * encoding can be found here:
 * https://developers.google.com/maps/documentation/utilities/polylinealgorithm
 * https://developers.google.com/maps/documentation/javascript/reference/geometry#encoding.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline
 */
export type ShipmentRoute_EncodedPolyline = Message<"google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline"> & {
  /**
   * String representing encoded points of the polyline.
   *
   * @generated from field: string points = 1;
   */
  points: string;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline.
 * Use `create(ShipmentRoute_EncodedPolylineSchema)` to create a new message.
 */
export const ShipmentRoute_EncodedPolylineSchema: GenMessage<ShipmentRoute_EncodedPolyline> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 4);

/**
 * Data representing the execution of a break.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.Break
 */
export type ShipmentRoute_Break = Message<"google.cloud.optimization.v1.ShipmentRoute.Break"> & {
  /**
   * Start time of a break.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * Duration of a break.
   *
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.Break.
 * Use `create(ShipmentRoute_BreakSchema)` to create a new message.
 */
export const ShipmentRoute_BreakSchema: GenMessage<ShipmentRoute_Break> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 5);

/**
 * Deprecated: Use
 * [ShipmentRoute.Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]
 * instead. Travel between each visit along the route: from the vehicle's
 * `start_location` to the first visit's `arrival_location`, then from the
 * first visit's `departure_location` to the second visit's
 * `arrival_location`, and so on until the vehicle's `end_location`. This
 * accounts only for the actual travel between visits, not counting the
 * waiting time, the time spent performing a visit, nor the distance covered
 * during a visit.
 *
 * Invariant: `travel_steps_size() == visits_size() + 1`.
 *
 * If the vehicle does not have a start_ and/or end_location, the
 * corresponding travel metrics are 0 and/or empty.
 *
 * @generated from message google.cloud.optimization.v1.ShipmentRoute.TravelStep
 * @deprecated
 */
export type ShipmentRoute_TravelStep = Message<"google.cloud.optimization.v1.ShipmentRoute.TravelStep"> & {
  /**
   * Duration of the travel step.
   *
   * @generated from field: google.protobuf.Duration duration = 1;
   */
  duration?: Duration;

  /**
   * Distance traveled during the step.
   *
   * @generated from field: double distance_meters = 2;
   */
  distanceMeters: number;

  /**
   * When traffic is requested via
   * [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * and the traffic info couldn't be retrieved for a TravelStep, this boolean
   * is set to true. This may be temporary (rare hiccup in the realtime
   * traffic servers) or permanent (no data for this location).
   *
   * @generated from field: bool traffic_info_unavailable = 3;
   */
  trafficInfoUnavailable: boolean;

  /**
   * The encoded polyline representation of the route followed during the
   * step.
   *
   * This field is only populated if
   * [OptimizeToursRequest.populate_travel_step_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_travel_step_polylines]
   * is set to true.
   *
   * @generated from field: google.cloud.optimization.v1.ShipmentRoute.EncodedPolyline route_polyline = 4;
   */
  routePolyline?: ShipmentRoute_EncodedPolyline;
};

/**
 * Describes the message google.cloud.optimization.v1.ShipmentRoute.TravelStep.
 * Use `create(ShipmentRoute_TravelStepSchema)` to create a new message.
 * @deprecated
 */
export const ShipmentRoute_TravelStepSchema: GenMessage<ShipmentRoute_TravelStep> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 18, 6);

/**
 * Specifies details of unperformed shipments in a solution. For trivial cases
 * and/or if we are able to identify the cause for skipping, we report the
 * reason here.
 *
 * @generated from message google.cloud.optimization.v1.SkippedShipment
 */
export type SkippedShipment = Message<"google.cloud.optimization.v1.SkippedShipment"> & {
  /**
   * The index corresponds to the index of the shipment in the source
   * `ShipmentModel`.
   *
   * @generated from field: int32 index = 1;
   */
  index: number;

  /**
   * Copy of the corresponding
   * [Shipment.label][google.cloud.optimization.v1.Shipment.label], if specified
   * in the `Shipment`.
   *
   * @generated from field: string label = 2;
   */
  label: string;

  /**
   * A list of reasons that explain why the shipment was skipped. See comment
   * above `Reason`.
   *
   * @generated from field: repeated google.cloud.optimization.v1.SkippedShipment.Reason reasons = 3;
   */
  reasons: SkippedShipment_Reason[];
};

/**
 * Describes the message google.cloud.optimization.v1.SkippedShipment.
 * Use `create(SkippedShipmentSchema)` to create a new message.
 */
export const SkippedShipmentSchema: GenMessage<SkippedShipment> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 19);

/**
 * If we can explain why the shipment was skipped, reasons will be listed
 * here. If the reason is not the same for all vehicles, `reason` will have
 * more than 1 element. A skipped shipment cannot have duplicate reasons,
 * i.e. where all fields are the same except for `example_vehicle_index`.
 * Example:
 * ```
 * reasons {
 *   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
 *   example_vehicle_index: 1
 *   example_exceeded_capacity_type: "Apples"
 * }
 * reasons {
 *   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
 *   example_vehicle_index: 3
 *   example_exceeded_capacity_type: "Pears"
 * }
 * reasons {
 *   code: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT
 *   example_vehicle_index: 1
 * }
 * ```
 * The skipped shipment is incompatible with all vehicles. The reasons may
 * be different for all vehicles but at least one vehicle's "Apples"
 * capacity would be exceeded (including vehicle 1), at least one vehicle's
 * "Pears" capacity would be exceeded (including vehicle 3) and at least one
 * vehicle's distance limit would be exceeded (including vehicle 1).
 *
 * @generated from message google.cloud.optimization.v1.SkippedShipment.Reason
 */
export type SkippedShipment_Reason = Message<"google.cloud.optimization.v1.SkippedShipment.Reason"> & {
  /**
   * Refer to the comments of Code.
   *
   * @generated from field: google.cloud.optimization.v1.SkippedShipment.Reason.Code code = 1;
   */
  code: SkippedShipment_Reason_Code;

  /**
   * If the reason is related to a shipment-vehicle incompatibility, this
   * field provides the index of one relevant vehicle.
   *
   * @generated from field: optional int32 example_vehicle_index = 2;
   */
  exampleVehicleIndex?: number;

  /**
   * If the reason code is `DEMAND_EXCEEDS_VEHICLE_CAPACITY`, documents one
   * capacity type that is exceeded.
   *
   * @generated from field: string example_exceeded_capacity_type = 3;
   */
  exampleExceededCapacityType: string;
};

/**
 * Describes the message google.cloud.optimization.v1.SkippedShipment.Reason.
 * Use `create(SkippedShipment_ReasonSchema)` to create a new message.
 */
export const SkippedShipment_ReasonSchema: GenMessage<SkippedShipment_Reason> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 19, 0);

/**
 * Code identifying the reason type. The order here is meaningless. In
 * particular, it gives no indication of whether a given reason will
 * appear before another in the solution, if both apply.
 *
 * @generated from enum google.cloud.optimization.v1.SkippedShipment.Reason.Code
 */
export enum SkippedShipment_Reason_Code {
  /**
   * This should never be used. If we are unable to understand why a
   * shipment was skipped, we simply return an empty set of reasons.
   *
   * @generated from enum value: CODE_UNSPECIFIED = 0;
   */
  CODE_UNSPECIFIED = 0,

  /**
   * There is no vehicle in the model making all shipments infeasible.
   *
   * @generated from enum value: NO_VEHICLE = 1;
   */
  NO_VEHICLE = 1,

  /**
   * The demand of the shipment exceeds a vehicle's capacity for some
   * capacity types, one of which is `example_exceeded_capacity_type`.
   *
   * @generated from enum value: DEMAND_EXCEEDS_VEHICLE_CAPACITY = 2;
   */
  DEMAND_EXCEEDS_VEHICLE_CAPACITY = 2,

  /**
   * The minimum distance necessary to perform this shipment, i.e. from
   * the vehicle's `start_location` to the shipment's pickup and/or delivery
   * locations and to the vehicle's end location exceeds the vehicle's
   * `route_distance_limit`.
   *
   * Note that for this computation we use the geodesic distances.
   *
   * @generated from enum value: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT = 3;
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT = 3,

  /**
   * The minimum time necessary to perform this shipment, including travel
   * time, wait time and service time exceeds the vehicle's
   * `route_duration_limit`.
   *
   * Note: travel time is computed in the best-case scenario, namely as
   * geodesic distance x 36 m/s (roughly 130 km/hour).
   *
   * @generated from enum value: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT = 4;
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT = 4,

  /**
   * Same as above but we only compare minimum travel time and the
   * vehicle's `travel_duration_limit`.
   *
   * @generated from enum value: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT = 5;
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT = 5,

  /**
   * The vehicle cannot perform this shipment in the best-case scenario
   * (see `CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT` for time
   * computation) if it starts at its earliest start time: the total time
   * would make the vehicle end after its latest end time.
   *
   * @generated from enum value: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS = 6;
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS = 6,

  /**
   * The `allowed_vehicle_indices` field of the shipment is not empty and
   * this vehicle does not belong to it.
   *
   * @generated from enum value: VEHICLE_NOT_ALLOWED = 7;
   */
  VEHICLE_NOT_ALLOWED = 7,
}

/**
 * Describes the enum google.cloud.optimization.v1.SkippedShipment.Reason.Code.
 */
export const SkippedShipment_Reason_CodeSchema: GenEnum<SkippedShipment_Reason_Code> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 19, 0, 0);

/**
 * Aggregated metrics for
 * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute] (resp. for
 * [OptimizeToursResponse][google.cloud.optimization.v1.OptimizeToursResponse]
 * over all [Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]
 * and/or [Visit][google.cloud.optimization.v1.ShipmentRoute.Visit] (resp. over
 * all [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute]) elements.
 *
 * @generated from message google.cloud.optimization.v1.AggregatedMetrics
 */
export type AggregatedMetrics = Message<"google.cloud.optimization.v1.AggregatedMetrics"> & {
  /**
   * Number of shipments performed. Note that a pickup and delivery pair only
   * counts once.
   *
   * @generated from field: int32 performed_shipment_count = 1;
   */
  performedShipmentCount: number;

  /**
   * Total travel duration for a route or a solution.
   *
   * @generated from field: google.protobuf.Duration travel_duration = 2;
   */
  travelDuration?: Duration;

  /**
   * Total wait duration for a route or a solution.
   *
   * @generated from field: google.protobuf.Duration wait_duration = 3;
   */
  waitDuration?: Duration;

  /**
   * Total delay duration for a route or a solution.
   *
   * @generated from field: google.protobuf.Duration delay_duration = 4;
   */
  delayDuration?: Duration;

  /**
   * Total break duration for a route or a solution.
   *
   * @generated from field: google.protobuf.Duration break_duration = 5;
   */
  breakDuration?: Duration;

  /**
   * Total visit duration for a route or a solution.
   *
   * @generated from field: google.protobuf.Duration visit_duration = 6;
   */
  visitDuration?: Duration;

  /**
   * The total duration should be equal to the sum of all durations above.
   * For routes, it also corresponds to:
   * [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time]
   * `-`
   * [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time]
   *
   * @generated from field: google.protobuf.Duration total_duration = 7;
   */
  totalDuration?: Duration;

  /**
   * Total travel distance for a route or a solution.
   *
   * @generated from field: double travel_distance_meters = 8;
   */
  travelDistanceMeters: number;

  /**
   * Maximum load achieved over the entire route (resp. solution), for each of
   * the quantities on this route (resp. solution), computed as the maximum over
   * all
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * (resp.
   * [ShipmentRoute.metrics.max_loads][google.cloud.optimization.v1.AggregatedMetrics.max_loads].
   *
   * @generated from field: map<string, google.cloud.optimization.v1.ShipmentRoute.VehicleLoad> max_loads = 9;
   */
  maxLoads: { [key: string]: ShipmentRoute_VehicleLoad };

  /**
   * Deprecated: Use
   * [ShipmentRoute.route_costs][google.cloud.optimization.v1.ShipmentRoute.route_costs]
   * and
   * [OptimizeToursResponse.Metrics.costs][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.costs]
   * instead.
   *
   * @generated from field: map<string, double> costs = 10 [deprecated = true];
   * @deprecated
   */
  costs: { [key: string]: number };

  /**
   * Deprecated: Use
   * [ShipmentRoute.route_total_cost][google.cloud.optimization.v1.ShipmentRoute.route_total_cost]
   * and
   * [OptimizeToursResponse.Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost]
   * instead.
   *
   * @generated from field: double total_cost = 11 [deprecated = true];
   * @deprecated
   */
  totalCost: number;
};

/**
 * Describes the message google.cloud.optimization.v1.AggregatedMetrics.
 * Use `create(AggregatedMetricsSchema)` to create a new message.
 */
export const AggregatedMetricsSchema: GenMessage<AggregatedMetrics> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 20);

/**
 * Solution injected in the request including information about which visits
 * must be constrained and how they must be constrained.
 *
 * @generated from message google.cloud.optimization.v1.InjectedSolutionConstraint
 */
export type InjectedSolutionConstraint = Message<"google.cloud.optimization.v1.InjectedSolutionConstraint"> & {
  /**
   * Routes of the solution to inject. Some routes may be omitted from the
   * original solution. The routes and skipped shipments must satisfy the basic
   * validity assumptions listed for `injected_first_solution_routes`.
   *
   * @generated from field: repeated google.cloud.optimization.v1.ShipmentRoute routes = 1;
   */
  routes: ShipmentRoute[];

  /**
   * Skipped shipments of the solution to inject. Some may be omitted from the
   * original solution. See the `routes` field.
   *
   * @generated from field: repeated google.cloud.optimization.v1.SkippedShipment skipped_shipments = 2;
   */
  skippedShipments: SkippedShipment[];

  /**
   * For zero or more groups of vehicles, specifies when and how much to relax
   * constraints. If this field is empty, all non-empty vehicle routes are
   * fully constrained.
   *
   * @generated from field: repeated google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation constraint_relaxations = 3;
   */
  constraintRelaxations: InjectedSolutionConstraint_ConstraintRelaxation[];
};

/**
 * Describes the message google.cloud.optimization.v1.InjectedSolutionConstraint.
 * Use `create(InjectedSolutionConstraintSchema)` to create a new message.
 */
export const InjectedSolutionConstraintSchema: GenMessage<InjectedSolutionConstraint> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 21);

/**
 * For a group of vehicles, specifies at what threshold(s) constraints on
 * visits will be relaxed and to which level. Shipments listed in
 * the `skipped_shipment` field are constrained to be skipped; i.e., they
 * cannot be performed.
 *
 * @generated from message google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation
 */
export type InjectedSolutionConstraint_ConstraintRelaxation = Message<"google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation"> & {
  /**
   * All the visit constraint relaxations that will apply to visits on
   * routes with vehicles in `vehicle_indices`.
   *
   * @generated from field: repeated google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation relaxations = 1;
   */
  relaxations: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation[];

  /**
   * Specifies the vehicle indices to which the visit constraint
   * `relaxations` apply. If empty, this is considered the default and the
   * `relaxations` apply to all vehicles that are not specified in other
   * `constraint_relaxations`. There can be at most one default, i.e., at
   * most one constraint relaxation field is allowed empty
   * `vehicle_indices`. A vehicle index can only be listed once, even within
   * several `constraint_relaxations`.
   *
   * A vehicle index is mapped the same as
   * [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index],
   * if `interpret_injected_solutions_using_labels` is true (see `fields`
   * comment).
   *
   * @generated from field: repeated int32 vehicle_indices = 2;
   */
  vehicleIndices: number[];
};

/**
 * Describes the message google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.
 * Use `create(InjectedSolutionConstraint_ConstraintRelaxationSchema)` to create a new message.
 */
export const InjectedSolutionConstraint_ConstraintRelaxationSchema: GenMessage<InjectedSolutionConstraint_ConstraintRelaxation> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 21, 0);

/**
 * If `relaxations` is empty, the start time and sequence of all visits
 * on `routes` are fully constrained and no new visits may be inserted or
 * added to those routes. Also, a vehicle's start and end time in
 * `routes` is fully constrained, unless the vehicle is empty (i.e., has no
 * visits and has `used_if_route_is_empty` set to false in the model).
 *
 * `relaxations(i).level` specifies the constraint relaxation level applied
 * to a visit #j that satisfies:
 *
 *   * `route.visits(j).start_time >= relaxations(i).threshold_time` AND
 *   * `j + 1 >= relaxations(i).threshold_visit_count`
 *
 * Similarly, the vehicle start is relaxed to `relaxations(i).level` if it
 * satisfies:
 *
 *   * `vehicle_start_time >= relaxations(i).threshold_time` AND
 *   * `relaxations(i).threshold_visit_count == 0`
 * and the vehicle end is relaxed to `relaxations(i).level` if it satisfies:
 *   * `vehicle_end_time >= relaxations(i).threshold_time` AND
 *   * `route.visits_size() + 1 >= relaxations(i).threshold_visit_count`
 *
 * To apply a relaxation level if a visit meets the `threshold_visit_count`
 * OR the `threshold_time` add two `relaxations` with the same `level`:
 * one with only `threshold_visit_count` set and the other with only
 * `threshold_time` set. If a visit satisfies the conditions of multiple
 * `relaxations`, the most relaxed level applies. As a result, from the
 * vehicle start through the route visits in order to the vehicle end, the
 * relaxation level becomes more relaxed: i.e., the relaxation level is
 * non-decreasing as the route progresses.
 *
 * The timing and sequence of route visits that do not satisfy the
 * threshold conditions of any `relaxations` are fully constrained
 * and no visits may be inserted into these sequences. Also, if a
 * vehicle start or end does not satisfy the conditions of any
 * relaxation the time is fixed, unless the vehicle is empty.
 *
 * @generated from message google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation
 */
export type InjectedSolutionConstraint_ConstraintRelaxation_Relaxation = Message<"google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation"> & {
  /**
   * The constraint relaxation level that applies when the conditions
   * at or after `threshold_time` AND at least `threshold_visit_count` are
   * satisfied.
   *
   * @generated from field: google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation.Level level = 1;
   */
  level: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level;

  /**
   * The time at or after which the relaxation `level` may be applied.
   *
   * @generated from field: google.protobuf.Timestamp threshold_time = 2;
   */
  thresholdTime?: Timestamp;

  /**
   * The number of visits at or after which the relaxation `level` may be
   * applied. If `threshold_visit_count` is 0 (or unset), the `level` may be
   * applied directly at the vehicle start.
   *
   * If it is `route.visits_size() + 1`, the `level` may only be applied to
   * the vehicle end. If it is more than `route.visits_size() + 1`,
   * `level` is not applied at all for that route.
   *
   * @generated from field: int32 threshold_visit_count = 3;
   */
  thresholdVisitCount: number;
};

/**
 * Describes the message google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation.
 * Use `create(InjectedSolutionConstraint_ConstraintRelaxation_RelaxationSchema)` to create a new message.
 */
export const InjectedSolutionConstraint_ConstraintRelaxation_RelaxationSchema: GenMessage<InjectedSolutionConstraint_ConstraintRelaxation_Relaxation> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 21, 0, 0);

/**
 * Expresses the different constraint relaxation levels, which are
 * applied for a visit and those that follow when it satisfies the
 * threshold conditions.
 *
 * The enumeration below is in order of increasing relaxation.
 *
 * @generated from enum google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation.Level
 */
export enum InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level {
  /**
   * Implicit default relaxation level: no constraints are relaxed,
   * i.e., all visits are fully constrained.
   *
   * This value must not be explicitly used in `level`.
   *
   * @generated from enum value: LEVEL_UNSPECIFIED = 0;
   */
  LEVEL_UNSPECIFIED = 0,

  /**
   * Visit start times and vehicle start/end times will be relaxed, but
   * each visit remains bound to the same vehicle and the visit sequence
   * must be observed: no visit can be inserted between them or before
   * them.
   *
   * @generated from enum value: RELAX_VISIT_TIMES_AFTER_THRESHOLD = 1;
   */
  RELAX_VISIT_TIMES_AFTER_THRESHOLD = 1,

  /**
   * Same as `RELAX_VISIT_TIMES_AFTER_THRESHOLD`, but the visit sequence
   * is also relaxed: visits can only be performed by this vehicle, but
   * can potentially become unperformed.
   *
   * @generated from enum value: RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD = 2;
   */
  RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD = 2,

  /**
   * Same as `RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD`, but the
   * vehicle is also relaxed: visits are completely free at or after the
   * threshold time and can potentially become unperformed.
   *
   * @generated from enum value: RELAX_ALL_AFTER_THRESHOLD = 3;
   */
  RELAX_ALL_AFTER_THRESHOLD = 3,
}

/**
 * Describes the enum google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation.Level.
 */
export const InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_LevelSchema: GenEnum<InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level> = /*@__PURE__*/
  enumDesc(file_google_cloud_optimization_v1_fleet_routing, 21, 0, 0, 0);

/**
 * Describes an error encountered when validating an `OptimizeToursRequest`.
 *
 * @generated from message google.cloud.optimization.v1.OptimizeToursValidationError
 */
export type OptimizeToursValidationError = Message<"google.cloud.optimization.v1.OptimizeToursValidationError"> & {
  /**
   * A validation error is defined by the pair (`code`, `display_name`) which
   * are always present.
   *
   * Other fields (below) provide more context about the error.
   *
   * *MULTIPLE ERRORS*:
   * When there are multiple errors, the validation process tries to output
   * several of them. Much like a compiler, this is an imperfect process. Some
   * validation errors will be "fatal", meaning that they stop the entire
   * validation process. This is the case for `display_name="UNSPECIFIED"`
   * errors, among others. Some may cause the validation process to skip other
   * errors.
   *
   * *STABILITY*:
   * `code` and `display_name` should be very stable. But new codes and
   * display names may appear over time, which may cause a given (invalid)
   * request to yield a different (`code`, `display_name`) pair because the new
   * error hid the old one (see "MULTIPLE ERRORS").
   *
   * *REFERENCE*: A list of all (code, name) pairs:
   *
   * * UNSPECIFIED = 0;
   * * VALIDATION_TIMEOUT_ERROR = 10; Validation couldn't be completed within
   * the deadline.
   *
   * * REQUEST_OPTIONS_ERROR = 12;
   *     * REQUEST_OPTIONS_INVALID_SOLVING_MODE = 1201;
   *     * REQUEST_OPTIONS_INVALID_MAX_VALIDATION_ERRORS = 1203;
   *     * REQUEST_OPTIONS_INVALID_GEODESIC_METERS_PER_SECOND = 1204;
   *     * REQUEST_OPTIONS_GEODESIC_METERS_PER_SECOND_TOO_SMALL = 1205;
   *     * REQUEST_OPTIONS_MISSING_GEODESIC_METERS_PER_SECOND = 1206;
   *     * REQUEST_OPTIONS_POPULATE_PATHFINDER_TRIPS_AND_GEODESIC_DISTANCE
   *       = 1207;
   *     * REQUEST_OPTIONS_COST_MODEL_OPTIONS_AND_GEODESIC_DISTANCE = 1208;
   *     * REQUEST_OPTIONS_TRAVEL_MODE_INCOMPATIBLE_WITH_TRAFFIC = 1211;
   *     * REQUEST_OPTIONS_MULTIPLE_TRAFFIC_FLAVORS = 1212;
   *     * REQUEST_OPTIONS_INVALID_TRAFFIC_FLAVOR = 1213;
   *     * REQUEST_OPTIONS_TRAFFIC_ENABLED_WITHOUT_GLOBAL_START_TIME = 1214;
   *     * REQUEST_OPTIONS_TRAFFIC_ENABLED_WITH_PRECEDENCES = 1215;
   *     * REQUEST_OPTIONS_TRAFFIC_PREFILL_MODE_INVALID = 1216;
   *     * REQUEST_OPTIONS_TRAFFIC_PREFILL_ENABLED_WITHOUT_TRAFFIC = 1217;
   * * INJECTED_SOLUTION_ERROR = 20;
   *     * INJECTED_SOLUTION_MISSING_LABEL = 2000;
   *     * INJECTED_SOLUTION_DUPLICATE_LABEL = 2001;
   *     * INJECTED_SOLUTION_AMBIGUOUS_INDEX = 2002;
   *     * INJECTED_SOLUTION_INFEASIBLE_AFTER_GETTING_TRAVEL_TIMES = 2003;
   *     * INJECTED_SOLUTION_TRANSITION_INCONSISTENT_WITH_ACTUAL_TRAVEL = 2004;
   *     * INJECTED_SOLUTION_CONCURRENT_SOLUTION_TYPES = 2005;
   *     * INJECTED_SOLUTION_MORE_THAN_ONE_PER_TYPE = 2006;
   *     * INJECTED_SOLUTION_REFRESH_WITHOUT_POPULATE = 2008;
   *     * INJECTED_SOLUTION_CONSTRAINED_ROUTE_PORTION_INFEASIBLE = 2010;
   * * SHIPMENT_MODEL_ERROR = 22;
   *     * SHIPMENT_MODEL_TOO_LARGE = 2200;
   *     * SHIPMENT_MODEL_TOO_MANY_CAPACITY_TYPES = 2201;
   *     * SHIPMENT_MODEL_GLOBAL_START_TIME_NEGATIVE_OR_NAN = 2202;
   *     * SHIPMENT_MODEL_GLOBAL_END_TIME_TOO_LARGE_OR_NAN = 2203;
   *     * SHIPMENT_MODEL_GLOBAL_START_TIME_AFTER_GLOBAL_END_TIME = 2204;
   *     * SHIPMENT_MODEL_GLOBAL_DURATION_TOO_LONG = 2205;
   *     * SHIPMENT_MODEL_MAX_ACTIVE_VEHICLES_NOT_POSITIVE = 2206;
   *     * SHIPMENT_MODEL_DURATION_MATRIX_TOO_LARGE = 2207;
   * * INDEX_ERROR = 24;
   * * TAG_ERROR = 26;
   * * TIME_WINDOW_ERROR = 28;
   *     * TIME_WINDOW_INVALID_START_TIME = 2800;
   *     * TIME_WINDOW_INVALID_END_TIME = 2801;
   *     * TIME_WINDOW_INVALID_SOFT_START_TIME = 2802;
   *     * TIME_WINDOW_INVALID_SOFT_END_TIME = 2803;
   *     * TIME_WINDOW_OUTSIDE_GLOBAL_TIME_WINDOW = 2804;
   *     * TIME_WINDOW_START_TIME_AFTER_END_TIME = 2805;
   *     * TIME_WINDOW_INVALID_COST_PER_HOUR_BEFORE_SOFT_START_TIME = 2806;
   *     * TIME_WINDOW_INVALID_COST_PER_HOUR_AFTER_SOFT_END_TIME = 2807;
   *     * TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_WITHOUT_SOFT_START_TIME
   *       = 2808;
   *     * TIME_WINDOW_COST_AFTER_SOFT_END_TIME_WITHOUT_SOFT_END_TIME = 2809;
   *     * TIME_WINDOW_SOFT_START_TIME_WITHOUT_COST_BEFORE_SOFT_START_TIME
   *       = 2810;
   *     * TIME_WINDOW_SOFT_END_TIME_WITHOUT_COST_AFTER_SOFT_END_TIME = 2811;
   *     * TIME_WINDOW_OVERLAPPING_ADJACENT_OR_EARLIER_THAN_PREVIOUS = 2812;
   *     * TIME_WINDOW_START_TIME_AFTER_SOFT_START_TIME = 2813;
   *     * TIME_WINDOW_SOFT_START_TIME_AFTER_END_TIME = 2814;
   *     * TIME_WINDOW_START_TIME_AFTER_SOFT_END_TIME = 2815;
   *     * TIME_WINDOW_SOFT_END_TIME_AFTER_END_TIME = 2816;
   *     * TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_SET_AND_MULTIPLE_WINDOWS
   *       = 2817;
   *     * TIME_WINDOW_COST_AFTER_SOFT_END_TIME_SET_AND_MULTIPLE_WINDOWS = 2818;
   *     * TRANSITION_ATTRIBUTES_ERROR = 30;
   *     * TRANSITION_ATTRIBUTES_INVALID_COST = 3000;
   *     * TRANSITION_ATTRIBUTES_INVALID_COST_PER_KILOMETER = 3001;
   *     * TRANSITION_ATTRIBUTES_DUPLICATE_TAG_PAIR = 3002;
   *     * TRANSITION_ATTRIBUTES_DISTANCE_LIMIT_MAX_METERS_UNSUPPORTED = 3003;
   *     * TRANSITION_ATTRIBUTES_UNSPECIFIED_SOURCE_TAGS = 3004;
   *     * TRANSITION_ATTRIBUTES_CONFLICTING_SOURCE_TAGS_FIELDS = 3005;
   *     * TRANSITION_ATTRIBUTES_UNSPECIFIED_DESTINATION_TAGS = 3006;
   *     * TRANSITION_ATTRIBUTES_CONFLICTING_DESTINATION_TAGS_FIELDS = 3007;
   *     * TRANSITION_ATTRIBUTES_DELAY_DURATION_NEGATIVE_OR_NAN = 3008;
   *     * TRANSITION_ATTRIBUTES_DELAY_DURATION_EXCEEDS_GLOBAL_DURATION = 3009;
   * * AMOUNT_ERROR = 31;
   *     * AMOUNT_NEGATIVE_VALUE = 3100;
   * * LOAD_LIMIT_ERROR = 33;
   *     * LOAD_LIMIT_INVALID_COST_ABOVE_SOFT_MAX = 3303;
   *     * LOAD_LIMIT_SOFT_MAX_WITHOUT_COST_ABOVE_SOFT_MAX = 3304;
   *     * LOAD_LIMIT_COST_ABOVE_SOFT_MAX_WITHOUT_SOFT_MAX = 3305;
   *     * LOAD_LIMIT_NEGATIVE_SOFT_MAX = 3306;
   *     * LOAD_LIMIT_MIXED_DEMAND_TYPE = 3307;
   *     * LOAD_LIMIT_MAX_LOAD_NEGATIVE_VALUE = 3308;
   *     * LOAD_LIMIT_SOFT_MAX_ABOVE_MAX = 3309;
   * * INTERVAL_ERROR = 34;
   *     * INTERVAL_MIN_EXCEEDS_MAX = 3401;
   *     * INTERVAL_NEGATIVE_MIN = 3402;
   *     * INTERVAL_NEGATIVE_MAX = 3403;
   *     * INTERVAL_MIN_EXCEEDS_CAPACITY = 3404;
   *     * INTERVAL_MAX_EXCEEDS_CAPACITY = 3405;
   * * DISTANCE_LIMIT_ERROR = 36;
   *     * DISTANCE_LIMIT_INVALID_COST_AFTER_SOFT_MAX = 3601;
   *     * DISTANCE_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3602;
   *     * DISTANCE_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3603;
   *     * DISTANCE_LIMIT_NEGATIVE_MAX = 3604;
   *     * DISTANCE_LIMIT_NEGATIVE_SOFT_MAX = 3605;
   *     * DISTANCE_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3606;
   * * DURATION_LIMIT_ERROR = 38;
   *     * DURATION_LIMIT_MAX_DURATION_NEGATIVE_OR_NAN = 3800;
   *     * DURATION_LIMIT_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3801;
   *     * DURATION_LIMIT_INVALID_COST_PER_HOUR_AFTER_SOFT_MAX = 3802;
   *     * DURATION_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3803;
   *     * DURATION_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3804;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3805;
   *     * DURATION_LIMIT_INVALID_COST_AFTER_QUADRATIC_SOFT_MAX = 3806;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_COST_PER_SQUARE_HOUR
   *       = 3807;
   *     * DURATION_LIMIT_COST_PER_SQUARE_HOUR_WITHOUT_QUADRATIC_SOFT_MAX
   *       = 3808;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_MAX = 3809;
   *     * DURATION_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3810;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_LARGER_THAN_MAX = 3811;
   *     * DURATION_LIMIT_DIFF_BETWEEN_MAX_AND_QUADRATIC_SOFT_MAX_TOO_LARGE
   *       = 3812;
   *     * DURATION_LIMIT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3813;
   *     * DURATION_LIMIT_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3814;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 3815;
   * * SHIPMENT_ERROR = 40;
   *     * SHIPMENT_PD_LIMIT_WITHOUT_PICKUP_AND_DELIVERY = 4014;
   *     * SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_NEGATIVE_OR_NAN = 4000;
   *     * SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 4001;
   *     * SHIPMENT_PD_RELATIVE_DETOUR_LIMIT_INVALID = 4015;
   *     * SHIPMENT_PD_DETOUR_LIMIT_AND_EXTRA_VISIT_DURATION = 4016;
   *     * SHIPMENT_PD_TIME_LIMIT_DURATION_NEGATIVE_OR_NAN = 4002;
   *     * SHIPMENT_PD_TIME_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4003;
   *     * SHIPMENT_EMPTY_SHIPMENT_TYPE = 4004;
   *     * SHIPMENT_NO_PICKUP_NO_DELIVERY = 4005;
   *     * SHIPMENT_INVALID_PENALTY_COST = 4006;
   *     * SHIPMENT_ALLOWED_VEHICLE_INDEX_OUT_OF_BOUNDS = 4007;
   *     * SHIPMENT_DUPLICATE_ALLOWED_VEHICLE_INDEX = 4008;
   *     * SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITHOUT_INDEX = 4009;
   *     * SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITH_INDEX = 4010;
   *     * SHIPMENT_INVALID_COST_FOR_VEHICLE = 4011;
   *     * SHIPMENT_COST_FOR_VEHICLE_INDEX_OUT_OF_BOUNDS = 4012;
   *     * SHIPMENT_DUPLICATE_COST_FOR_VEHICLE_INDEX = 4013;
   * * VEHICLE_ERROR = 42;
   *     * VEHICLE_EMPTY_REQUIRED_OPERATOR_TYPE = 4200;
   *     * VEHICLE_DUPLICATE_REQUIRED_OPERATOR_TYPE = 4201;
   *     * VEHICLE_NO_OPERATOR_WITH_REQUIRED_OPERATOR_TYPE = 4202;
   *     * VEHICLE_EMPTY_START_TAG = 4203;
   *     * VEHICLE_DUPLICATE_START_TAG = 4204;
   *     * VEHICLE_EMPTY_END_TAG = 4205;
   *     * VEHICLE_DUPLICATE_END_TAG = 4206;
   *     * VEHICLE_EXTRA_VISIT_DURATION_NEGATIVE_OR_NAN = 4207;
   *     * VEHICLE_EXTRA_VISIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4208;
   *     * VEHICLE_EXTRA_VISIT_DURATION_EMPTY_KEY = 4209;
   *     * VEHICLE_FIRST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4210;
   *     * VEHICLE_FIRST_SHIPMENT_IGNORED = 4211;
   *     * VEHICLE_FIRST_SHIPMENT_NOT_BOUND = 4212;
   *     * VEHICLE_LAST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4213;
   *     * VEHICLE_LAST_SHIPMENT_IGNORED = 4214;
   *     * VEHICLE_LAST_SHIPMENT_NOT_BOUND = 4215;
   *     * VEHICLE_IGNORED_WITH_USED_IF_ROUTE_IS_EMPTY = 4216;
   *     * VEHICLE_INVALID_COST_PER_KILOMETER = 4217;
   *     * VEHICLE_INVALID_COST_PER_HOUR = 4218;
   *     * VEHICLE_INVALID_COST_PER_TRAVELED_HOUR = 4219;
   *     * VEHICLE_INVALID_FIXED_COST = 4220;
   *     * VEHICLE_INVALID_TRAVEL_DURATION_MULTIPLE = 4221;
   *     * VEHICLE_TRAVEL_DURATION_MULTIPLE_WITH_SHIPMENT_PD_DETOUR_LIMITS
   *       = 4223;
   *     * VEHICLE_MATRIX_INDEX_WITH_SHIPMENT_PD_DETOUR_LIMITS = 4224;
   *     * VEHICLE_MINIMUM_DURATION_LONGER_THAN_DURATION_LIMIT = 4222;
   * * VISIT_REQUEST_ERROR = 44;
   *     * VISIT_REQUEST_EMPTY_TAG = 4400;
   *     * VISIT_REQUEST_DUPLICATE_TAG = 4401;
   *     * VISIT_REQUEST_DURATION_NEGATIVE_OR_NAN = 4404;
   *     * VISIT_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4405;
   * * PRECEDENCE_ERROR = 46;
   *     * PRECEDENCE_RULE_MISSING_FIRST_INDEX = 4600;
   *     * PRECEDENCE_RULE_MISSING_SECOND_INDEX = 4601;
   *     * PRECEDENCE_RULE_FIRST_INDEX_OUT_OF_BOUNDS = 4602;
   *     * PRECEDENCE_RULE_SECOND_INDEX_OUT_OF_BOUNDS = 4603;
   *     * PRECEDENCE_RULE_DUPLICATE_INDEX = 4604;
   *     * PRECEDENCE_RULE_INEXISTENT_FIRST_VISIT_REQUEST = 4605;
   *     * PRECEDENCE_RULE_INEXISTENT_SECOND_VISIT_REQUEST = 4606;
   * * BREAK_ERROR = 48;
   *     * BREAK_RULE_EMPTY = 4800;
   *     * BREAK_REQUEST_UNSPECIFIED_DURATION = 4801;
   *     * BREAK_REQUEST_UNSPECIFIED_EARLIEST_START_TIME = 4802;
   *     * BREAK_REQUEST_UNSPECIFIED_LATEST_START_TIME = 4803;
   *     * BREAK_REQUEST_DURATION_NEGATIVE_OR_NAN = 4804; = 4804;
   *     * BREAK_REQUEST_LATEST_START_TIME_BEFORE_EARLIEST_START_TIME = 4805;
   *     * BREAK_REQUEST_EARLIEST_START_TIME_BEFORE_GLOBAL_START_TIME = 4806;
   *     * BREAK_REQUEST_LATEST_END_TIME_AFTER_GLOBAL_END_TIME = 4807;
   *     * BREAK_REQUEST_NON_SCHEDULABLE = 4808;
   *     * BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_NEGATIVE_OR_NAN = 4809;
   *     * BREAK_FREQUENCY_MIN_BREAK_DURATION_NEGATIVE_OR_NAN = 4810;
   *     * BREAK_FREQUENCY_MIN_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION = 4811;
   *     * BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 4812;
   *     * BREAK_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4813;
   *     * BREAK_FREQUENCY_MISSING_MAX_INTER_BREAK_DURATION = 4814;
   *     * BREAK_FREQUENCY_MISSING_MIN_BREAK_DURATION = 4815;
   * * SHIPMENT_TYPE_INCOMPATIBILITY_ERROR = 50;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_EMPTY_TYPE = 5001;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_LESS_THAN_TWO_TYPES = 5002;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_DUPLICATE_TYPE = 5003;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_INVALID_INCOMPATIBILITY_MODE = 5004;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_TOO_MANY_INCOMPATIBILITIES = 5005;
   * * SHIPMENT_TYPE_REQUIREMENT_ERROR = 52;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE = 52001;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_DEPENDENT_TYPE = 52002;
   *     * SHIPMENT_TYPE_REQUIREMENT_INVALID_REQUIREMENT_MODE = 52003;
   *     * SHIPMENT_TYPE_REQUIREMENT_TOO_MANY_REQUIREMENTS = 52004;
   *     * SHIPMENT_TYPE_REQUIREMENT_EMPTY_REQUIRED_TYPE = 52005;
   *     * SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_REQUIRED_TYPE = 52006;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE_FOUND = 52007;
   *     * SHIPMENT_TYPE_REQUIREMENT_EMPTY_DEPENDENT_TYPE = 52008;
   *     * SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_DEPENDENT_TYPE = 52009;
   *     * SHIPMENT_TYPE_REQUIREMENT_SELF_DEPENDENT_TYPE = 52010;
   *     * SHIPMENT_TYPE_REQUIREMENT_GRAPH_HAS_CYCLES = 52011;
   * * VEHICLE_OPERATOR_ERROR = 54;
   *     * VEHICLE_OPERATOR_EMPTY_TYPE = 5400;
   *     * VEHICLE_OPERATOR_MULTIPLE_START_TIME_WINDOWS = 5401;
   *     * VEHICLE_OPERATOR_SOFT_START_TIME_WINDOW = 5402;
   *     * VEHICLE_OPERATOR_MULTIPLE_END_TIME_WINDOWS = 5403;
   *     * VEHICLE_OPERATOR_SOFT_END_TIME_WINDOW = 5404;
   * * DURATION_SECONDS_MATRIX_ERROR = 56;
   *     * DURATION_SECONDS_MATRIX_DURATION_NEGATIVE_OR_NAN = 5600;
   *     * DURATION_SECONDS_MATRIX_DURATION_EXCEEDS_GLOBAL_DURATION = 5601;
   *
   * @generated from field: int32 code = 1;
   */
  code: number;

  /**
   * The error display name.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * An error context may involve 0, 1 (most of the time) or more fields. For
   * example, referring to vehicle #4 and shipment #2's first pickup can be
   * done as follows:
   * ```
   * fields { name: "vehicles" index: 4}
   * fields { name: "shipments" index: 2 sub_field {name: "pickups" index: 0} }
   * ```
   * Note, however, that the cardinality of `fields` should not change for a
   * given error code.
   *
   * @generated from field: repeated google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference fields = 3;
   */
  fields: OptimizeToursValidationError_FieldReference[];

  /**
   * Human-readable string describing the error. There is a 1:1 mapping
   * between `code` and `error_message` (when code != "UNSPECIFIED").
   *
   * *STABILITY*: Not stable: the error message associated to a given `code` may
   * change (hopefully to clarify it) over time. Please rely on the
   * `display_name` and `code` instead.
   *
   * @generated from field: string error_message = 4;
   */
  errorMessage: string;

  /**
   * May contain the value(s) of the field(s). This is not always available. You
   * should absolutely not rely on it and use it only for manual model
   * debugging.
   *
   * @generated from field: string offending_values = 5;
   */
  offendingValues: string;
};

/**
 * Describes the message google.cloud.optimization.v1.OptimizeToursValidationError.
 * Use `create(OptimizeToursValidationErrorSchema)` to create a new message.
 */
export const OptimizeToursValidationErrorSchema: GenMessage<OptimizeToursValidationError> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 22);

/**
 * Specifies a context for the validation error. A `FieldReference` always
 * refers to a given field in this file and follows the same hierarchical
 * structure. For example, we may specify element #2 of `start_time_windows`
 * of vehicle #5 using:
 * ```
 * name: "vehicles" index: 5 sub_field { name: "end_time_windows" index: 2 }
 * ```
 * We however omit top-level entities such as `OptimizeToursRequest` or
 * `ShipmentModel` to avoid crowding the message.
 *
 * @generated from message google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference
 */
export type OptimizeToursValidationError_FieldReference = Message<"google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference"> & {
  /**
   * Name of the field, e.g., "vehicles".
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference.index_or_key
   */
  indexOrKey: {
    /**
     * Index of the field if repeated.
     *
     * @generated from field: int32 index = 2;
     */
    value: number;
    case: "index";
  } | {
    /**
     * Key if the field is a map.
     *
     * @generated from field: string key = 4;
     */
    value: string;
    case: "key";
  } | { case: undefined; value?: undefined };

  /**
   * Recursively nested sub-field, if needed.
   *
   * @generated from field: google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference sub_field = 3;
   */
  subField?: OptimizeToursValidationError_FieldReference;
};

/**
 * Describes the message google.cloud.optimization.v1.OptimizeToursValidationError.FieldReference.
 * Use `create(OptimizeToursValidationError_FieldReferenceSchema)` to create a new message.
 */
export const OptimizeToursValidationError_FieldReferenceSchema: GenMessage<OptimizeToursValidationError_FieldReference> = /*@__PURE__*/
  messageDesc(file_google_cloud_optimization_v1_fleet_routing, 22, 0);

/**
 * A service for optimizing vehicle tours.
 *
 * Validity of certain types of fields:
 *
 *   * `google.protobuf.Timestamp`
 *     * Times are in Unix time: seconds since 1970-01-01T00:00:00+00:00.
 *     * seconds must be in [0, 253402300799],
 *       i.e. in [1970-01-01T00:00:00+00:00, 9999-12-31T23:59:59+00:00].
 *     * nanos must be unset or set to 0.
 *   * `google.protobuf.Duration`
 *     * seconds must be in [0, 253402300799],
 *       i.e. in [1970-01-01T00:00:00+00:00, 9999-12-31T23:59:59+00:00].
 *     * nanos must be unset or set to 0.
 *   * `google.type.LatLng`
 *     * latitude must be in [-90.0, 90.0].
 *     * longitude must be in [-180.0, 180.0].
 *     * at least one of latitude and longitude must be non-zero.
 *
 * @generated from service google.cloud.optimization.v1.FleetRouting
 */
export const FleetRouting: GenService<{
  /**
   * Sends an `OptimizeToursRequest` containing a `ShipmentModel` and returns an
   * `OptimizeToursResponse` containing `ShipmentRoute`s, which are a set of
   * routes to be performed by vehicles minimizing the overall cost.
   *
   * A `ShipmentModel` model consists mainly of `Shipment`s that need to be
   * carried out and `Vehicle`s that can be used to transport the `Shipment`s.
   * The `ShipmentRoute`s assign `Shipment`s to `Vehicle`s. More specifically,
   * they assign a series of `Visit`s to each vehicle, where a `Visit`
   * corresponds to a `VisitRequest`, which is a pickup or delivery for a
   * `Shipment`.
   *
   * The goal is to provide an assignment of `ShipmentRoute`s to `Vehicle`s that
   * minimizes the total cost where cost has many components defined in the
   * `ShipmentModel`.
   *
   * @generated from rpc google.cloud.optimization.v1.FleetRouting.OptimizeTours
   */
  optimizeTours: {
    methodKind: "unary";
    input: typeof OptimizeToursRequestSchema;
    output: typeof OptimizeToursResponseSchema;
  },
  /**
   * Optimizes vehicle tours for one or more `OptimizeToursRequest`
   * messages as a batch.
   *
   * This method is a Long Running Operation (LRO). The inputs for optimization
   * (`OptimizeToursRequest` messages) and outputs (`OptimizeToursResponse`
   * messages) are read/written from/to Cloud Storage in user-specified
   * format. Like the `OptimizeTours` method, each `OptimizeToursRequest`
   * contains a `ShipmentModel` and returns an `OptimizeToursResponse`
   * containing `ShipmentRoute`s, which are a set of routes to be performed by
   * vehicles minimizing the overall cost.
   *
   * @generated from rpc google.cloud.optimization.v1.FleetRouting.BatchOptimizeTours
   */
  batchOptimizeTours: {
    methodKind: "unary";
    input: typeof BatchOptimizeToursRequestSchema;
    output: typeof OperationSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_cloud_optimization_v1_fleet_routing, 0);

