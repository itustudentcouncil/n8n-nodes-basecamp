// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/kms/v1/service.proto (package google.cloud.kms.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../api/annotations_pb";
import { file_google_api_client } from "../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { CryptoKey, CryptoKeySchema, CryptoKeyVersion, CryptoKeyVersion_CryptoKeyVersionAlgorithm, CryptoKeyVersion_CryptoKeyVersionView, CryptoKeyVersionSchema, ImportJob, ImportJobSchema, KeyRing, KeyRingSchema, ProtectionLevel, PublicKeySchema } from "./resources_pb";
import { file_google_cloud_kms_v1_resources } from "./resources_pb";
import type { FieldMask } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/kms/v1/service.proto.
 */
export const file_google_cloud_kms_v1_service: GenFile = /*@__PURE__*/
  fileDesc("CiFnb29nbGUvY2xvdWQva21zL3YxL3NlcnZpY2UucHJvdG8SE2dvb2dsZS5jbG91ZC5rbXMudjEirQEKE0xpc3RLZXlSaW5nc1JlcXVlc3QSOQoGcGFyZW50GAEgASgJQingQQL6QSMKIWxvY2F0aW9ucy5nb29nbGVhcGlzLmNvbS9Mb2NhdGlvbhIWCglwYWdlX3NpemUYAiABKAVCA+BBARIXCgpwYWdlX3Rva2VuGAMgASgJQgPgQQESEwoGZmlsdGVyGAQgASgJQgPgQQESFQoIb3JkZXJfYnkYBSABKAlCA+BBASL/AQoVTGlzdENyeXB0b0tleXNSZXF1ZXN0EjcKBnBhcmVudBgBIAEoCUIn4EEC+kEhCh9jbG91ZGttcy5nb29nbGVhcGlzLmNvbS9LZXlSaW5nEhYKCXBhZ2Vfc2l6ZRgCIAEoBUID4EEBEhcKCnBhZ2VfdG9rZW4YAyABKAlCA+BBARJQCgx2ZXJzaW9uX3ZpZXcYBCABKA4yOi5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleVZlcnNpb24uQ3J5cHRvS2V5VmVyc2lvblZpZXcSEwoGZmlsdGVyGAUgASgJQgPgQQESFQoIb3JkZXJfYnkYBiABKAlCA+BBASKAAgocTGlzdENyeXB0b0tleVZlcnNpb25zUmVxdWVzdBI5CgZwYXJlbnQYASABKAlCKeBBAvpBIwohY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5EhYKCXBhZ2Vfc2l6ZRgCIAEoBUID4EEBEhcKCnBhZ2VfdG9rZW4YAyABKAlCA+BBARJICgR2aWV3GAQgASgOMjouZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uLkNyeXB0b0tleVZlcnNpb25WaWV3EhMKBmZpbHRlchgFIAEoCUID4EEBEhUKCG9yZGVyX2J5GAYgASgJQgPgQQEirQEKFUxpc3RJbXBvcnRKb2JzUmVxdWVzdBI3CgZwYXJlbnQYASABKAlCJ+BBAvpBIQofY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vS2V5UmluZxIWCglwYWdlX3NpemUYAiABKAVCA+BBARIXCgpwYWdlX3Rva2VuGAMgASgJQgPgQQESEwoGZmlsdGVyGAQgASgJQgPgQQESFQoIb3JkZXJfYnkYBSABKAlCA+BBASJ0ChRMaXN0S2V5UmluZ3NSZXNwb25zZRIvCglrZXlfcmluZ3MYASADKAsyHC5nb29nbGUuY2xvdWQua21zLnYxLktleVJpbmcSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJEhIKCnRvdGFsX3NpemUYAyABKAUiegoWTGlzdENyeXB0b0tleXNSZXNwb25zZRIzCgtjcnlwdG9fa2V5cxgBIAMoCzIeLmdvb2dsZS5jbG91ZC5rbXMudjEuQ3J5cHRvS2V5EhcKD25leHRfcGFnZV90b2tlbhgCIAEoCRISCgp0b3RhbF9zaXplGAMgASgFIpABCh1MaXN0Q3J5cHRvS2V5VmVyc2lvbnNSZXNwb25zZRJCChNjcnlwdG9fa2V5X3ZlcnNpb25zGAEgAygLMiUuZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCRISCgp0b3RhbF9zaXplGAMgASgFInoKFkxpc3RJbXBvcnRKb2JzUmVzcG9uc2USMwoLaW1wb3J0X2pvYnMYASADKAsyHi5nb29nbGUuY2xvdWQua21zLnYxLkltcG9ydEpvYhIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkSEgoKdG90YWxfc2l6ZRgDIAEoBSJKChFHZXRLZXlSaW5nUmVxdWVzdBI1CgRuYW1lGAEgASgJQifgQQL6QSEKH2Nsb3Vka21zLmdvb2dsZWFwaXMuY29tL0tleVJpbmciTgoTR2V0Q3J5cHRvS2V5UmVxdWVzdBI3CgRuYW1lGAEgASgJQingQQL6QSMKIWNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleSJcChpHZXRDcnlwdG9LZXlWZXJzaW9uUmVxdWVzdBI+CgRuYW1lGAEgASgJQjDgQQL6QSoKKGNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleVZlcnNpb24iVQoTR2V0UHVibGljS2V5UmVxdWVzdBI+CgRuYW1lGAEgASgJQjDgQQL6QSoKKGNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleVZlcnNpb24iTgoTR2V0SW1wb3J0Sm9iUmVxdWVzdBI3CgRuYW1lGAEgASgJQingQQL6QSMKIWNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0ltcG9ydEpvYiKgAQoUQ3JlYXRlS2V5UmluZ1JlcXVlc3QSOQoGcGFyZW50GAEgASgJQingQQL6QSMKIWxvY2F0aW9ucy5nb29nbGVhcGlzLmNvbS9Mb2NhdGlvbhIYCgtrZXlfcmluZ19pZBgCIAEoCUID4EECEjMKCGtleV9yaW5nGAMgASgLMhwuZ29vZ2xlLmNsb3VkLmttcy52MS5LZXlSaW5nQgPgQQIizQEKFkNyZWF0ZUNyeXB0b0tleVJlcXVlc3QSNwoGcGFyZW50GAEgASgJQifgQQL6QSEKH2Nsb3Vka21zLmdvb2dsZWFwaXMuY29tL0tleVJpbmcSGgoNY3J5cHRvX2tleV9pZBgCIAEoCUID4EECEjcKCmNyeXB0b19rZXkYAyABKAsyHi5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleUID4EECEiUKHXNraXBfaW5pdGlhbF92ZXJzaW9uX2NyZWF0aW9uGAUgASgIIqIBCh1DcmVhdGVDcnlwdG9LZXlWZXJzaW9uUmVxdWVzdBI5CgZwYXJlbnQYASABKAlCKeBBAvpBIwohY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5EkYKEmNyeXB0b19rZXlfdmVyc2lvbhgCIAEoCzIlLmdvb2dsZS5jbG91ZC5rbXMudjEuQ3J5cHRvS2V5VmVyc2lvbkID4EECIvACCh1JbXBvcnRDcnlwdG9LZXlWZXJzaW9uUmVxdWVzdBI5CgZwYXJlbnQYASABKAlCKeBBAvpBIwohY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5EkwKEmNyeXB0b19rZXlfdmVyc2lvbhgGIAEoCUIw4EEB+kEqCihjbG91ZGttcy5nb29nbGVhcGlzLmNvbS9DcnlwdG9LZXlWZXJzaW9uElcKCWFsZ29yaXRobRgCIAEoDjI/Lmdvb2dsZS5jbG91ZC5rbXMudjEuQ3J5cHRvS2V5VmVyc2lvbi5DcnlwdG9LZXlWZXJzaW9uQWxnb3JpdGhtQgPgQQISFwoKaW1wb3J0X2pvYhgEIAEoCUID4EECEhgKC3dyYXBwZWRfa2V5GAggASgMQgPgQQESIgoTcnNhX2Flc193cmFwcGVkX2tleRgFIAEoDEID4EEBSABCFgoUd3JhcHBlZF9rZXlfbWF0ZXJpYWwipgEKFkNyZWF0ZUltcG9ydEpvYlJlcXVlc3QSNwoGcGFyZW50GAEgASgJQifgQQL6QSEKH2Nsb3Vka21zLmdvb2dsZWFwaXMuY29tL0tleVJpbmcSGgoNaW1wb3J0X2pvYl9pZBgCIAEoCUID4EECEjcKCmltcG9ydF9qb2IYAyABKAsyHi5nb29nbGUuY2xvdWQua21zLnYxLkltcG9ydEpvYkID4EECIocBChZVcGRhdGVDcnlwdG9LZXlSZXF1ZXN0EjcKCmNyeXB0b19rZXkYASABKAsyHi5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleUID4EECEjQKC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFza0ID4EECIp0BCh1VcGRhdGVDcnlwdG9LZXlWZXJzaW9uUmVxdWVzdBJGChJjcnlwdG9fa2V5X3ZlcnNpb24YASABKAsyJS5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleVZlcnNpb25CA+BBAhI0Cgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tCA+BBAiKDAQokVXBkYXRlQ3J5cHRvS2V5UHJpbWFyeVZlcnNpb25SZXF1ZXN0EjcKBG5hbWUYASABKAlCKeBBAvpBIwohY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5EiIKFWNyeXB0b19rZXlfdmVyc2lvbl9pZBgCIAEoCUID4EECImAKHkRlc3Ryb3lDcnlwdG9LZXlWZXJzaW9uUmVxdWVzdBI+CgRuYW1lGAEgASgJQjDgQQL6QSoKKGNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleVZlcnNpb24iYAoeUmVzdG9yZUNyeXB0b0tleVZlcnNpb25SZXF1ZXN0Ej4KBG5hbWUYASABKAlCMOBBAvpBKgooY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5VmVyc2lvbiL5AQoORW5jcnlwdFJlcXVlc3QSFwoEbmFtZRgBIAEoCUIJ4EEC+kEDCgEqEhYKCXBsYWludGV4dBgCIAEoDEID4EECEioKHWFkZGl0aW9uYWxfYXV0aGVudGljYXRlZF9kYXRhGAMgASgMQgPgQQESOgoQcGxhaW50ZXh0X2NyYzMyYxgHIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlQgPgQQESTgokYWRkaXRpb25hbF9hdXRoZW50aWNhdGVkX2RhdGFfY3JjMzJjGAggASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBASKbAgoORGVjcnlwdFJlcXVlc3QSNwoEbmFtZRgBIAEoCUIp4EEC+kEjCiFjbG91ZGttcy5nb29nbGVhcGlzLmNvbS9DcnlwdG9LZXkSFwoKY2lwaGVydGV4dBgCIAEoDEID4EECEioKHWFkZGl0aW9uYWxfYXV0aGVudGljYXRlZF9kYXRhGAMgASgMQgPgQQESOwoRY2lwaGVydGV4dF9jcmMzMmMYBSABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUID4EEBEk4KJGFkZGl0aW9uYWxfYXV0aGVudGljYXRlZF9kYXRhX2NyYzMyYxgGIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlQgPgQQEi4gIKEVJhd0VuY3J5cHRSZXF1ZXN0EhEKBG5hbWUYASABKAlCA+BBAhIWCglwbGFpbnRleHQYAiABKAxCA+BBAhIqCh1hZGRpdGlvbmFsX2F1dGhlbnRpY2F0ZWRfZGF0YRgDIAEoDEID4EEBEjoKEHBsYWludGV4dF9jcmMzMmMYBCABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUID4EEBEk4KJGFkZGl0aW9uYWxfYXV0aGVudGljYXRlZF9kYXRhX2NyYzMyYxgFIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlQgPgQQESIgoVaW5pdGlhbGl6YXRpb25fdmVjdG9yGAYgASgMQgPgQQESRgocaW5pdGlhbGl6YXRpb25fdmVjdG9yX2NyYzMyYxgHIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlQgPgQQEi+AIKEVJhd0RlY3J5cHRSZXF1ZXN0EhEKBG5hbWUYASABKAlCA+BBAhIXCgpjaXBoZXJ0ZXh0GAIgASgMQgPgQQISKgodYWRkaXRpb25hbF9hdXRoZW50aWNhdGVkX2RhdGEYAyABKAxCA+BBARIiChVpbml0aWFsaXphdGlvbl92ZWN0b3IYBCABKAxCA+BBAhISCgp0YWdfbGVuZ3RoGAUgASgFEjsKEWNpcGhlcnRleHRfY3JjMzJjGAYgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBARJOCiRhZGRpdGlvbmFsX2F1dGhlbnRpY2F0ZWRfZGF0YV9jcmMzMmMYByABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUID4EEBEkYKHGluaXRpYWxpemF0aW9uX3ZlY3Rvcl9jcmMzMmMYCCABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUID4EEBIowCChVBc3ltbWV0cmljU2lnblJlcXVlc3QSPgoEbmFtZRgBIAEoCUIw4EEC+kEqCihjbG91ZGttcy5nb29nbGVhcGlzLmNvbS9DcnlwdG9LZXlWZXJzaW9uEjAKBmRpZ2VzdBgDIAEoCzIbLmdvb2dsZS5jbG91ZC5rbXMudjEuRGlnZXN0QgPgQQESNwoNZGlnZXN0X2NyYzMyYxgEIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlQgPgQQESEQoEZGF0YRgGIAEoDEID4EEBEjUKC2RhdGFfY3JjMzJjGAcgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBASKwAQoYQXN5bW1ldHJpY0RlY3J5cHRSZXF1ZXN0Ej4KBG5hbWUYASABKAlCMOBBAvpBKgooY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb20vQ3J5cHRvS2V5VmVyc2lvbhIXCgpjaXBoZXJ0ZXh0GAMgASgMQgPgQQISOwoRY2lwaGVydGV4dF9jcmMzMmMYBCABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUID4EEBIpoBCg5NYWNTaWduUmVxdWVzdBI+CgRuYW1lGAEgASgJQjDgQQL6QSoKKGNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleVZlcnNpb24SEQoEZGF0YRgCIAEoDEID4EECEjUKC2RhdGFfY3JjMzJjGAMgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBASLkAQoQTWFjVmVyaWZ5UmVxdWVzdBI+CgRuYW1lGAEgASgJQjDgQQL6QSoKKGNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleVZlcnNpb24SEQoEZGF0YRgCIAEoDEID4EECEjUKC2RhdGFfY3JjMzJjGAMgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBARIQCgNtYWMYBCABKAxCA+BBAhI0CgptYWNfY3JjMzJjGAUgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVCA+BBASKEAQoaR2VuZXJhdGVSYW5kb21CeXRlc1JlcXVlc3QSEAoIbG9jYXRpb24YASABKAkSFAoMbGVuZ3RoX2J5dGVzGAIgASgFEj4KEHByb3RlY3Rpb25fbGV2ZWwYAyABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCKFAgoPRW5jcnlwdFJlc3BvbnNlEgwKBG5hbWUYASABKAkSEgoKY2lwaGVydGV4dBgCIAEoDBI2ChFjaXBoZXJ0ZXh0X2NyYzMyYxgEIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlEiEKGXZlcmlmaWVkX3BsYWludGV4dF9jcmMzMmMYBSABKAgSNQotdmVyaWZpZWRfYWRkaXRpb25hbF9hdXRoZW50aWNhdGVkX2RhdGFfY3JjMzJjGAYgASgIEj4KEHByb3RlY3Rpb25fbGV2ZWwYByABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCKxAQoPRGVjcnlwdFJlc3BvbnNlEhEKCXBsYWludGV4dBgBIAEoDBI1ChBwbGFpbnRleHRfY3JjMzJjGAIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUSFAoMdXNlZF9wcmltYXJ5GAMgASgIEj4KEHByb3RlY3Rpb25fbGV2ZWwYBCABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCKtAwoSUmF3RW5jcnlwdFJlc3BvbnNlEhIKCmNpcGhlcnRleHQYASABKAwSHQoVaW5pdGlhbGl6YXRpb25fdmVjdG9yGAIgASgMEhIKCnRhZ19sZW5ndGgYAyABKAUSNgoRY2lwaGVydGV4dF9jcmMzMmMYBCABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZRJBChxpbml0aWFsaXphdGlvbl92ZWN0b3JfY3JjMzJjGAUgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUSIQoZdmVyaWZpZWRfcGxhaW50ZXh0X2NyYzMyYxgGIAEoCBI1Ci12ZXJpZmllZF9hZGRpdGlvbmFsX2F1dGhlbnRpY2F0ZWRfZGF0YV9jcmMzMmMYByABKAgSLQoldmVyaWZpZWRfaW5pdGlhbGl6YXRpb25fdmVjdG9yX2NyYzMyYxgKIAEoCBIMCgRuYW1lGAggASgJEj4KEHByb3RlY3Rpb25fbGV2ZWwYCSABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCKoAgoSUmF3RGVjcnlwdFJlc3BvbnNlEhEKCXBsYWludGV4dBgBIAEoDBI1ChBwbGFpbnRleHRfY3JjMzJjGAIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUSPgoQcHJvdGVjdGlvbl9sZXZlbBgDIAEoDjIkLmdvb2dsZS5jbG91ZC5rbXMudjEuUHJvdGVjdGlvbkxldmVsEiIKGnZlcmlmaWVkX2NpcGhlcnRleHRfY3JjMzJjGAQgASgIEjUKLXZlcmlmaWVkX2FkZGl0aW9uYWxfYXV0aGVudGljYXRlZF9kYXRhX2NyYzMyYxgFIAEoCBItCiV2ZXJpZmllZF9pbml0aWFsaXphdGlvbl92ZWN0b3JfY3JjMzJjGAYgASgIIu4BChZBc3ltbWV0cmljU2lnblJlc3BvbnNlEhEKCXNpZ25hdHVyZRgBIAEoDBI1ChBzaWduYXR1cmVfY3JjMzJjGAIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUSHgoWdmVyaWZpZWRfZGlnZXN0X2NyYzMyYxgDIAEoCBIMCgRuYW1lGAQgASgJEhwKFHZlcmlmaWVkX2RhdGFfY3JjMzJjGAUgASgIEj4KEHByb3RlY3Rpb25fbGV2ZWwYBiABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCLJAQoZQXN5bW1ldHJpY0RlY3J5cHRSZXNwb25zZRIRCglwbGFpbnRleHQYASABKAwSNQoQcGxhaW50ZXh0X2NyYzMyYxgCIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlEiIKGnZlcmlmaWVkX2NpcGhlcnRleHRfY3JjMzJjGAMgASgIEj4KEHByb3RlY3Rpb25fbGV2ZWwYBCABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCK7AQoPTWFjU2lnblJlc3BvbnNlEgwKBG5hbWUYASABKAkSCwoDbWFjGAIgASgMEi8KCm1hY19jcmMzMmMYAyABKAsyGy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZRIcChR2ZXJpZmllZF9kYXRhX2NyYzMyYxgEIAEoCBI+ChBwcm90ZWN0aW9uX2xldmVsGAUgASgOMiQuZ29vZ2xlLmNsb3VkLmttcy52MS5Qcm90ZWN0aW9uTGV2ZWwi0QEKEU1hY1ZlcmlmeVJlc3BvbnNlEgwKBG5hbWUYASABKAkSDwoHc3VjY2VzcxgCIAEoCBIcChR2ZXJpZmllZF9kYXRhX2NyYzMyYxgDIAEoCBIbChN2ZXJpZmllZF9tYWNfY3JjMzJjGAQgASgIEiIKGnZlcmlmaWVkX3N1Y2Nlc3NfaW50ZWdyaXR5GAUgASgIEj4KEHByb3RlY3Rpb25fbGV2ZWwYBiABKA4yJC5nb29nbGUuY2xvdWQua21zLnYxLlByb3RlY3Rpb25MZXZlbCJdChtHZW5lcmF0ZVJhbmRvbUJ5dGVzUmVzcG9uc2USDAoEZGF0YRgBIAEoDBIwCgtkYXRhX2NyYzMyYxgDIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlIkgKBkRpZ2VzdBIQCgZzaGEyNTYYASABKAxIABIQCgZzaGEzODQYAiABKAxIABIQCgZzaGE1MTIYAyABKAxIAEIICgZkaWdlc3QiQAoQTG9jYXRpb25NZXRhZGF0YRIVCg1oc21fYXZhaWxhYmxlGAEgASgIEhUKDWVrbV9hdmFpbGFibGUYAiABKAgykC4KFEtleU1hbmFnZW1lbnRTZXJ2aWNlEqIBCgxMaXN0S2V5UmluZ3MSKC5nb29nbGUuY2xvdWQua21zLnYxLkxpc3RLZXlSaW5nc1JlcXVlc3QaKS5nb29nbGUuY2xvdWQua21zLnYxLkxpc3RLZXlSaW5nc1Jlc3BvbnNlIj3aQQZwYXJlbnSC0+STAi4SLC92MS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyp9L2tleVJpbmdzErUBCg5MaXN0Q3J5cHRvS2V5cxIqLmdvb2dsZS5jbG91ZC5rbXMudjEuTGlzdENyeXB0b0tleXNSZXF1ZXN0GisuZ29vZ2xlLmNsb3VkLmttcy52MS5MaXN0Q3J5cHRvS2V5c1Jlc3BvbnNlIkraQQZwYXJlbnSC0+STAjsSOS92MS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKn0vY3J5cHRvS2V5cxLeAQoVTGlzdENyeXB0b0tleVZlcnNpb25zEjEuZ29vZ2xlLmNsb3VkLmttcy52MS5MaXN0Q3J5cHRvS2V5VmVyc2lvbnNSZXF1ZXN0GjIuZ29vZ2xlLmNsb3VkLmttcy52MS5MaXN0Q3J5cHRvS2V5VmVyc2lvbnNSZXNwb25zZSJe2kEGcGFyZW50gtPkkwJPEk0vdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qfS9jcnlwdG9LZXlWZXJzaW9ucxK1AQoOTGlzdEltcG9ydEpvYnMSKi5nb29nbGUuY2xvdWQua21zLnYxLkxpc3RJbXBvcnRKb2JzUmVxdWVzdBorLmdvb2dsZS5jbG91ZC5rbXMudjEuTGlzdEltcG9ydEpvYnNSZXNwb25zZSJK2kEGcGFyZW50gtPkkwI7EjkvdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyp9L2ltcG9ydEpvYnMSjwEKCkdldEtleVJpbmcSJi5nb29nbGUuY2xvdWQua21zLnYxLkdldEtleVJpbmdSZXF1ZXN0GhwuZ29vZ2xlLmNsb3VkLmttcy52MS5LZXlSaW5nIjvaQQRuYW1lgtPkkwIuEiwvdjEve25hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qfRKiAQoMR2V0Q3J5cHRvS2V5EiguZ29vZ2xlLmNsb3VkLmttcy52MS5HZXRDcnlwdG9LZXlSZXF1ZXN0Gh4uZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXkiSNpBBG5hbWWC0+STAjsSOS92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qfRLLAQoTR2V0Q3J5cHRvS2V5VmVyc2lvbhIvLmdvb2dsZS5jbG91ZC5rbXMudjEuR2V0Q3J5cHRvS2V5VmVyc2lvblJlcXVlc3QaJS5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleVZlcnNpb24iXNpBBG5hbWWC0+STAk8STS92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9EsABCgxHZXRQdWJsaWNLZXkSKC5nb29nbGUuY2xvdWQua21zLnYxLkdldFB1YmxpY0tleVJlcXVlc3QaHi5nb29nbGUuY2xvdWQua21zLnYxLlB1YmxpY0tleSJm2kEEbmFtZYLT5JMCWRJXL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKi9jcnlwdG9LZXlzLyovY3J5cHRvS2V5VmVyc2lvbnMvKn0vcHVibGljS2V5EqIBCgxHZXRJbXBvcnRKb2ISKC5nb29nbGUuY2xvdWQua21zLnYxLkdldEltcG9ydEpvYlJlcXVlc3QaHi5nb29nbGUuY2xvdWQua21zLnYxLkltcG9ydEpvYiJI2kEEbmFtZYLT5JMCOxI5L3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKi9pbXBvcnRKb2JzLyp9ErYBCg1DcmVhdGVLZXlSaW5nEikuZ29vZ2xlLmNsb3VkLmttcy52MS5DcmVhdGVLZXlSaW5nUmVxdWVzdBocLmdvb2dsZS5jbG91ZC5rbXMudjEuS2V5UmluZyJc2kEbcGFyZW50LGtleV9yaW5nX2lkLGtleV9yaW5ngtPkkwI4OghrZXlfcmluZyIsL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9sb2NhdGlvbnMvKn0va2V5UmluZ3MSzwEKD0NyZWF0ZUNyeXB0b0tleRIrLmdvb2dsZS5jbG91ZC5rbXMudjEuQ3JlYXRlQ3J5cHRvS2V5UmVxdWVzdBoeLmdvb2dsZS5jbG91ZC5rbXMudjEuQ3J5cHRvS2V5Im/aQR9wYXJlbnQsY3J5cHRvX2tleV9pZCxjcnlwdG9fa2V5gtPkkwJHOgpjcnlwdG9fa2V5IjkvdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyp9L2NyeXB0b0tleXMS+wEKFkNyZWF0ZUNyeXB0b0tleVZlcnNpb24SMi5nb29nbGUuY2xvdWQua21zLnYxLkNyZWF0ZUNyeXB0b0tleVZlcnNpb25SZXF1ZXN0GiUuZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uIoUB2kEZcGFyZW50LGNyeXB0b19rZXlfdmVyc2lvboLT5JMCYzoSY3J5cHRvX2tleV92ZXJzaW9uIk0vdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qfS9jcnlwdG9LZXlWZXJzaW9ucxLUAQoWSW1wb3J0Q3J5cHRvS2V5VmVyc2lvbhIyLmdvb2dsZS5jbG91ZC5rbXMudjEuSW1wb3J0Q3J5cHRvS2V5VmVyc2lvblJlcXVlc3QaJS5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleVZlcnNpb24iX4LT5JMCWToBKiJUL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qL2NyeXB0b0tleXMvKn0vY3J5cHRvS2V5VmVyc2lvbnM6aW1wb3J0Es8BCg9DcmVhdGVJbXBvcnRKb2ISKy5nb29nbGUuY2xvdWQua21zLnYxLkNyZWF0ZUltcG9ydEpvYlJlcXVlc3QaHi5nb29nbGUuY2xvdWQua21zLnYxLkltcG9ydEpvYiJv2kEfcGFyZW50LGltcG9ydF9qb2JfaWQsaW1wb3J0X2pvYoLT5JMCRzoKaW1wb3J0X2pvYiI5L3YxL3twYXJlbnQ9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qfS9pbXBvcnRKb2JzEtEBCg9VcGRhdGVDcnlwdG9LZXkSKy5nb29nbGUuY2xvdWQua21zLnYxLlVwZGF0ZUNyeXB0b0tleVJlcXVlc3QaHi5nb29nbGUuY2xvdWQua21zLnYxLkNyeXB0b0tleSJx2kEWY3J5cHRvX2tleSx1cGRhdGVfbWFza4LT5JMCUjoKY3J5cHRvX2tleTJEL3YxL3tjcnlwdG9fa2V5Lm5hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qL2NyeXB0b0tleXMvKn0SkwIKFlVwZGF0ZUNyeXB0b0tleVZlcnNpb24SMi5nb29nbGUuY2xvdWQua21zLnYxLlVwZGF0ZUNyeXB0b0tleVZlcnNpb25SZXF1ZXN0GiUuZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uIp0B2kEeY3J5cHRvX2tleV92ZXJzaW9uLHVwZGF0ZV9tYXNrgtPkkwJ2OhJjcnlwdG9fa2V5X3ZlcnNpb24yYC92MS97Y3J5cHRvX2tleV92ZXJzaW9uLm5hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qL2NyeXB0b0tleXMvKi9jcnlwdG9LZXlWZXJzaW9ucy8qfRLyAQodVXBkYXRlQ3J5cHRvS2V5UHJpbWFyeVZlcnNpb24SOS5nb29nbGUuY2xvdWQua21zLnYxLlVwZGF0ZUNyeXB0b0tleVByaW1hcnlWZXJzaW9uUmVxdWVzdBoeLmdvb2dsZS5jbG91ZC5rbXMudjEuQ3J5cHRvS2V5InbaQRpuYW1lLGNyeXB0b19rZXlfdmVyc2lvbl9pZILT5JMCUzoBKiJOL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKi9jcnlwdG9LZXlzLyp9OnVwZGF0ZVByaW1hcnlWZXJzaW9uEt4BChdEZXN0cm95Q3J5cHRvS2V5VmVyc2lvbhIzLmdvb2dsZS5jbG91ZC5rbXMudjEuRGVzdHJveUNyeXB0b0tleVZlcnNpb25SZXF1ZXN0GiUuZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uImfaQQRuYW1lgtPkkwJaOgEqIlUvdjEve25hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qL2NyeXB0b0tleXMvKi9jcnlwdG9LZXlWZXJzaW9ucy8qfTpkZXN0cm95Et4BChdSZXN0b3JlQ3J5cHRvS2V5VmVyc2lvbhIzLmdvb2dsZS5jbG91ZC5rbXMudjEuUmVzdG9yZUNyeXB0b0tleVZlcnNpb25SZXF1ZXN0GiUuZ29vZ2xlLmNsb3VkLmttcy52MS5DcnlwdG9LZXlWZXJzaW9uImfaQQRuYW1lgtPkkwJaOgEqIlUvdjEve25hbWU9cHJvamVjdHMvKi9sb2NhdGlvbnMvKi9rZXlSaW5ncy8qL2NyeXB0b0tleXMvKi9jcnlwdG9LZXlWZXJzaW9ucy8qfTpyZXN0b3JlErQBCgdFbmNyeXB0EiMuZ29vZ2xlLmNsb3VkLmttcy52MS5FbmNyeXB0UmVxdWVzdBokLmdvb2dsZS5jbG91ZC5rbXMudjEuRW5jcnlwdFJlc3BvbnNlIl7aQQ5uYW1lLHBsYWludGV4dILT5JMCRzoBKiJCL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKi9jcnlwdG9LZXlzLyoqfTplbmNyeXB0ErQBCgdEZWNyeXB0EiMuZ29vZ2xlLmNsb3VkLmttcy52MS5EZWNyeXB0UmVxdWVzdBokLmdvb2dsZS5jbG91ZC5rbXMudjEuRGVjcnlwdFJlc3BvbnNlIl7aQQ9uYW1lLGNpcGhlcnRleHSC0+STAkY6ASoiQS92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qfTpkZWNyeXB0EsIBCgpSYXdFbmNyeXB0EiYuZ29vZ2xlLmNsb3VkLmttcy52MS5SYXdFbmNyeXB0UmVxdWVzdBonLmdvb2dsZS5jbG91ZC5rbXMudjEuUmF3RW5jcnlwdFJlc3BvbnNlImOC0+STAl06ASoiWC92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9OnJhd0VuY3J5cHQSwgEKClJhd0RlY3J5cHQSJi5nb29nbGUuY2xvdWQua21zLnYxLlJhd0RlY3J5cHRSZXF1ZXN0GicuZ29vZ2xlLmNsb3VkLmttcy52MS5SYXdEZWNyeXB0UmVzcG9uc2UiY4LT5JMCXToBKiJYL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyova2V5UmluZ3MvKi9jcnlwdG9LZXlzLyovY3J5cHRvS2V5VmVyc2lvbnMvKn06cmF3RGVjcnlwdBLgAQoOQXN5bW1ldHJpY1NpZ24SKi5nb29nbGUuY2xvdWQua21zLnYxLkFzeW1tZXRyaWNTaWduUmVxdWVzdBorLmdvb2dsZS5jbG91ZC5rbXMudjEuQXN5bW1ldHJpY1NpZ25SZXNwb25zZSJ12kELbmFtZSxkaWdlc3SC0+STAmE6ASoiXC92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9OmFzeW1tZXRyaWNTaWduEvABChFBc3ltbWV0cmljRGVjcnlwdBItLmdvb2dsZS5jbG91ZC5rbXMudjEuQXN5bW1ldHJpY0RlY3J5cHRSZXF1ZXN0Gi4uZ29vZ2xlLmNsb3VkLmttcy52MS5Bc3ltbWV0cmljRGVjcnlwdFJlc3BvbnNlInzaQQ9uYW1lLGNpcGhlcnRleHSC0+STAmQ6ASoiXy92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9OmFzeW1tZXRyaWNEZWNyeXB0EsIBCgdNYWNTaWduEiMuZ29vZ2xlLmNsb3VkLmttcy52MS5NYWNTaWduUmVxdWVzdBokLmdvb2dsZS5jbG91ZC5rbXMudjEuTWFjU2lnblJlc3BvbnNlImzaQQluYW1lLGRhdGGC0+STAlo6ASoiVS92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9Om1hY1NpZ24SzgEKCU1hY1ZlcmlmeRIlLmdvb2dsZS5jbG91ZC5rbXMudjEuTWFjVmVyaWZ5UmVxdWVzdBomLmdvb2dsZS5jbG91ZC5rbXMudjEuTWFjVmVyaWZ5UmVzcG9uc2UictpBDW5hbWUsZGF0YSxtYWOC0+STAlw6ASoiVy92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2tleVJpbmdzLyovY3J5cHRvS2V5cy8qL2NyeXB0b0tleVZlcnNpb25zLyp9Om1hY1ZlcmlmeRLnAQoTR2VuZXJhdGVSYW5kb21CeXRlcxIvLmdvb2dsZS5jbG91ZC5rbXMudjEuR2VuZXJhdGVSYW5kb21CeXRlc1JlcXVlc3QaMC5nb29nbGUuY2xvdWQua21zLnYxLkdlbmVyYXRlUmFuZG9tQnl0ZXNSZXNwb25zZSJt2kEmbG9jYXRpb24sbGVuZ3RoX2J5dGVzLHByb3RlY3Rpb25fbGV2ZWyC0+STAj46ASoiOS92MS97bG9jYXRpb249cHJvamVjdHMvKi9sb2NhdGlvbnMvKn06Z2VuZXJhdGVSYW5kb21CeXRlcxp0ykEXY2xvdWRrbXMuZ29vZ2xlYXBpcy5jb23SQVdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWRrbXNCfwoXY29tLmdvb2dsZS5jbG91ZC5rbXMudjFCCEttc1Byb3RvUAFaKWNsb3VkLmdvb2dsZS5jb20vZ28va21zL2FwaXYxL2ttc3BiO2ttc3Bi+AEBqgITR29vZ2xlLkNsb3VkLkttcy5WMcoCE0dvb2dsZVxDbG91ZFxLbXNcVjFiBnByb3RvMw", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_cloud_kms_v1_resources, file_google_protobuf_field_mask, file_google_protobuf_wrappers]);

/**
 * Request message for
 * [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
 *
 * @generated from message google.cloud.kms.v1.ListKeyRingsRequest
 */
export type ListKeyRingsRequest = Message<"google.cloud.kms.v1.ListKeyRingsRequest"> & {
  /**
   * Required. The resource name of the location associated with the
   * [KeyRings][google.cloud.kms.v1.KeyRing], in the format
   * `projects/*\/locations/*`.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Optional limit on the number of
   * [KeyRings][google.cloud.kms.v1.KeyRing] to include in the response. Further
   * [KeyRings][google.cloud.kms.v1.KeyRing] can subsequently be obtained by
   * including the
   * [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]
   * in a subsequent request.  If unspecified, the server will pick an
   * appropriate default.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order.  For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message google.cloud.kms.v1.ListKeyRingsRequest.
 * Use `create(ListKeyRingsRequestSchema)` to create a new message.
 */
export const ListKeyRingsRequestSchema: GenMessage<ListKeyRingsRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 0);

/**
 * Request message for
 * [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
 *
 * @generated from message google.cloud.kms.v1.ListCryptoKeysRequest
 */
export type ListCryptoKeysRequest = Message<"google.cloud.kms.v1.ListCryptoKeysRequest"> & {
  /**
   * Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
   * to list, in the format `projects/*\/locations/*\/keyRings/*`.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Optional limit on the number of
   * [CryptoKeys][google.cloud.kms.v1.CryptoKey] to include in the response.
   * Further [CryptoKeys][google.cloud.kms.v1.CryptoKey] can subsequently be
   * obtained by including the
   * [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]
   * in a subsequent request.  If unspecified, the server will pick an
   * appropriate default.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * The fields of the primary version to include in the response.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionView version_view = 4;
   */
  versionView: CryptoKeyVersion_CryptoKeyVersionView;

  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string filter = 5;
   */
  filter: string;

  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string order_by = 6;
   */
  orderBy: string;
};

/**
 * Describes the message google.cloud.kms.v1.ListCryptoKeysRequest.
 * Use `create(ListCryptoKeysRequestSchema)` to create a new message.
 */
export const ListCryptoKeysRequestSchema: GenMessage<ListCryptoKeysRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 1);

/**
 * Request message for
 * [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
 *
 * @generated from message google.cloud.kms.v1.ListCryptoKeyVersionsRequest
 */
export type ListCryptoKeyVersionsRequest = Message<"google.cloud.kms.v1.ListCryptoKeyVersionsRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to list, in the format
   * `projects/*\/locations/*\/keyRings/*\/cryptoKeys/*`.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Optional limit on the number of
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] to include in the
   * response. Further [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
   * can subsequently be obtained by including the
   * [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]
   * in a subsequent request. If unspecified, the server will pick an
   * appropriate default.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * The fields to include in the response.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionView view = 4;
   */
  view: CryptoKeyVersion_CryptoKeyVersionView;

  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string filter = 5;
   */
  filter: string;

  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string order_by = 6;
   */
  orderBy: string;
};

/**
 * Describes the message google.cloud.kms.v1.ListCryptoKeyVersionsRequest.
 * Use `create(ListCryptoKeyVersionsRequestSchema)` to create a new message.
 */
export const ListCryptoKeyVersionsRequestSchema: GenMessage<ListCryptoKeyVersionsRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 2);

/**
 * Request message for
 * [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
 *
 * @generated from message google.cloud.kms.v1.ListImportJobsRequest
 */
export type ListImportJobsRequest = Message<"google.cloud.kms.v1.ListImportJobsRequest"> & {
  /**
   * Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
   * to list, in the format `projects/*\/locations/*\/keyRings/*`.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. Optional limit on the number of
   * [ImportJobs][google.cloud.kms.v1.ImportJob] to include in the response.
   * Further [ImportJobs][google.cloud.kms.v1.ImportJob] can subsequently be
   * obtained by including the
   * [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token]
   * in a subsequent request. If unspecified, the server will pick an
   * appropriate default.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message google.cloud.kms.v1.ListImportJobsRequest.
 * Use `create(ListImportJobsRequestSchema)` to create a new message.
 */
export const ListImportJobsRequestSchema: GenMessage<ListImportJobsRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 3);

/**
 * Response message for
 * [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
 *
 * @generated from message google.cloud.kms.v1.ListKeyRingsResponse
 */
export type ListKeyRingsResponse = Message<"google.cloud.kms.v1.ListKeyRingsResponse"> & {
  /**
   * The list of [KeyRings][google.cloud.kms.v1.KeyRing].
   *
   * @generated from field: repeated google.cloud.kms.v1.KeyRing key_rings = 1;
   */
  keyRings: KeyRing[];

  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListKeyRingsRequest.page_token][google.cloud.kms.v1.ListKeyRingsRequest.page_token]
   * to retrieve the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * The total number of [KeyRings][google.cloud.kms.v1.KeyRing] that matched
   * the query.
   *
   * @generated from field: int32 total_size = 3;
   */
  totalSize: number;
};

/**
 * Describes the message google.cloud.kms.v1.ListKeyRingsResponse.
 * Use `create(ListKeyRingsResponseSchema)` to create a new message.
 */
export const ListKeyRingsResponseSchema: GenMessage<ListKeyRingsResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 4);

/**
 * Response message for
 * [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
 *
 * @generated from message google.cloud.kms.v1.ListCryptoKeysResponse
 */
export type ListCryptoKeysResponse = Message<"google.cloud.kms.v1.ListCryptoKeysResponse"> & {
  /**
   * The list of [CryptoKeys][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from field: repeated google.cloud.kms.v1.CryptoKey crypto_keys = 1;
   */
  cryptoKeys: CryptoKey[];

  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListCryptoKeysRequest.page_token][google.cloud.kms.v1.ListCryptoKeysRequest.page_token]
   * to retrieve the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * The total number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] that
   * matched the query.
   *
   * @generated from field: int32 total_size = 3;
   */
  totalSize: number;
};

/**
 * Describes the message google.cloud.kms.v1.ListCryptoKeysResponse.
 * Use `create(ListCryptoKeysResponseSchema)` to create a new message.
 */
export const ListCryptoKeysResponseSchema: GenMessage<ListCryptoKeysResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 5);

/**
 * Response message for
 * [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
 *
 * @generated from message google.cloud.kms.v1.ListCryptoKeyVersionsResponse
 */
export type ListCryptoKeyVersionsResponse = Message<"google.cloud.kms.v1.ListCryptoKeyVersionsResponse"> & {
  /**
   * The list of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from field: repeated google.cloud.kms.v1.CryptoKeyVersion crypto_key_versions = 1;
   */
  cryptoKeyVersions: CryptoKeyVersion[];

  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListCryptoKeyVersionsRequest.page_token][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]
   * to retrieve the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * The total number of
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] that matched the
   * query.
   *
   * @generated from field: int32 total_size = 3;
   */
  totalSize: number;
};

/**
 * Describes the message google.cloud.kms.v1.ListCryptoKeyVersionsResponse.
 * Use `create(ListCryptoKeyVersionsResponseSchema)` to create a new message.
 */
export const ListCryptoKeyVersionsResponseSchema: GenMessage<ListCryptoKeyVersionsResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 6);

/**
 * Response message for
 * [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
 *
 * @generated from message google.cloud.kms.v1.ListImportJobsResponse
 */
export type ListImportJobsResponse = Message<"google.cloud.kms.v1.ListImportJobsResponse"> & {
  /**
   * The list of [ImportJobs][google.cloud.kms.v1.ImportJob].
   *
   * @generated from field: repeated google.cloud.kms.v1.ImportJob import_jobs = 1;
   */
  importJobs: ImportJob[];

  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListImportJobsRequest.page_token][google.cloud.kms.v1.ListImportJobsRequest.page_token]
   * to retrieve the next page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * The total number of [ImportJobs][google.cloud.kms.v1.ImportJob] that
   * matched the query.
   *
   * @generated from field: int32 total_size = 3;
   */
  totalSize: number;
};

/**
 * Describes the message google.cloud.kms.v1.ListImportJobsResponse.
 * Use `create(ListImportJobsResponseSchema)` to create a new message.
 */
export const ListImportJobsResponseSchema: GenMessage<ListImportJobsResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 7);

/**
 * Request message for
 * [KeyManagementService.GetKeyRing][google.cloud.kms.v1.KeyManagementService.GetKeyRing].
 *
 * @generated from message google.cloud.kms.v1.GetKeyRingRequest
 */
export type GetKeyRingRequest = Message<"google.cloud.kms.v1.GetKeyRingRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
   * [KeyRing][google.cloud.kms.v1.KeyRing] to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.GetKeyRingRequest.
 * Use `create(GetKeyRingRequestSchema)` to create a new message.
 */
export const GetKeyRingRequestSchema: GenMessage<GetKeyRingRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 8);

/**
 * Request message for
 * [KeyManagementService.GetCryptoKey][google.cloud.kms.v1.KeyManagementService.GetCryptoKey].
 *
 * @generated from message google.cloud.kms.v1.GetCryptoKeyRequest
 */
export type GetCryptoKeyRequest = Message<"google.cloud.kms.v1.GetCryptoKeyRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.GetCryptoKeyRequest.
 * Use `create(GetCryptoKeyRequestSchema)` to create a new message.
 */
export const GetCryptoKeyRequestSchema: GenMessage<GetCryptoKeyRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 9);

/**
 * Request message for
 * [KeyManagementService.GetCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.GetCryptoKeyVersionRequest
 */
export type GetCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.GetCryptoKeyVersionRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.GetCryptoKeyVersionRequest.
 * Use `create(GetCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const GetCryptoKeyVersionRequestSchema: GenMessage<GetCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 10);

/**
 * Request message for
 * [KeyManagementService.GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
 *
 * @generated from message google.cloud.kms.v1.GetPublicKeyRequest
 */
export type GetPublicKeyRequest = Message<"google.cloud.kms.v1.GetPublicKeyRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.GetPublicKeyRequest.
 * Use `create(GetPublicKeyRequestSchema)` to create a new message.
 */
export const GetPublicKeyRequestSchema: GenMessage<GetPublicKeyRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 11);

/**
 * Request message for
 * [KeyManagementService.GetImportJob][google.cloud.kms.v1.KeyManagementService.GetImportJob].
 *
 * @generated from message google.cloud.kms.v1.GetImportJobRequest
 */
export type GetImportJobRequest = Message<"google.cloud.kms.v1.GetImportJobRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
   * [ImportJob][google.cloud.kms.v1.ImportJob] to get.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.GetImportJobRequest.
 * Use `create(GetImportJobRequestSchema)` to create a new message.
 */
export const GetImportJobRequestSchema: GenMessage<GetImportJobRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 12);

/**
 * Request message for
 * [KeyManagementService.CreateKeyRing][google.cloud.kms.v1.KeyManagementService.CreateKeyRing].
 *
 * @generated from message google.cloud.kms.v1.CreateKeyRingRequest
 */
export type CreateKeyRingRequest = Message<"google.cloud.kms.v1.CreateKeyRingRequest"> & {
  /**
   * Required. The resource name of the location associated with the
   * [KeyRings][google.cloud.kms.v1.KeyRing], in the format
   * `projects/*\/locations/*`.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. It must be unique within a location and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   *
   * @generated from field: string key_ring_id = 2;
   */
  keyRingId: string;

  /**
   * Required. A [KeyRing][google.cloud.kms.v1.KeyRing] with initial field
   * values.
   *
   * @generated from field: google.cloud.kms.v1.KeyRing key_ring = 3;
   */
  keyRing?: KeyRing;
};

/**
 * Describes the message google.cloud.kms.v1.CreateKeyRingRequest.
 * Use `create(CreateKeyRingRequestSchema)` to create a new message.
 */
export const CreateKeyRingRequestSchema: GenMessage<CreateKeyRingRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 13);

/**
 * Request message for
 * [KeyManagementService.CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey].
 *
 * @generated from message google.cloud.kms.v1.CreateCryptoKeyRequest
 */
export type CreateCryptoKeyRequest = Message<"google.cloud.kms.v1.CreateCryptoKeyRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the KeyRing
   * associated with the [CryptoKeys][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. It must be unique within a KeyRing and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   *
   * @generated from field: string crypto_key_id = 2;
   */
  cryptoKeyId: string;

  /**
   * Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field
   * values.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKey crypto_key = 3;
   */
  cryptoKey?: CryptoKey;

  /**
   * If set to true, the request will create a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] without any
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. You must
   * manually call
   * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
   * or
   * [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]
   * before you can use this [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from field: bool skip_initial_version_creation = 5;
   */
  skipInitialVersionCreation: boolean;
};

/**
 * Describes the message google.cloud.kms.v1.CreateCryptoKeyRequest.
 * Use `create(CreateCryptoKeyRequestSchema)` to create a new message.
 */
export const CreateCryptoKeyRequestSchema: GenMessage<CreateCryptoKeyRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 14);

/**
 * Request message for
 * [KeyManagementService.CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.CreateCryptoKeyVersionRequest
 */
export type CreateCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.CreateCryptoKeyVersionRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with the
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * initial field values.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKeyVersion crypto_key_version = 2;
   */
  cryptoKeyVersion?: CryptoKeyVersion;
};

/**
 * Describes the message google.cloud.kms.v1.CreateCryptoKeyVersionRequest.
 * Use `create(CreateCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const CreateCryptoKeyVersionRequestSchema: GenMessage<CreateCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 15);

/**
 * Request message for
 * [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.ImportCryptoKeyVersionRequest
 */
export type ImportCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.ImportCryptoKeyVersionRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to be imported into.
   *
   * The create permission is only required on this key when creating a new
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Optional. The optional [name][google.cloud.kms.v1.CryptoKeyVersion.name] of
   * an existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to
   * target for an import operation. If this field is not present, a new
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] containing the
   * supplied key material is created.
   *
   * If this field is present, the supplied key material is imported into
   * the existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. To
   * import into an existing
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] must be a child of
   * [ImportCryptoKeyVersionRequest.parent][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent],
   * have been previously created via [ImportCryptoKeyVersion][], and be in
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]
   * or
   * [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]
   * state. The key material and algorithm must match the previous
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] exactly if the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] has ever contained
   * key material.
   *
   * @generated from field: string crypto_key_version = 6;
   */
  cryptoKeyVersion: string;

  /**
   * Required. The
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
   * of the key being imported. This does not need to match the
   * [version_template][google.cloud.kms.v1.CryptoKey.version_template] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] this version imports into.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm algorithm = 2;
   */
  algorithm: CryptoKeyVersion_CryptoKeyVersionAlgorithm;

  /**
   * Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
   * [ImportJob][google.cloud.kms.v1.ImportJob] that was used to wrap this key
   * material.
   *
   * @generated from field: string import_job = 4;
   */
  importJob: string;

  /**
   * Optional. The wrapped key material to import.
   *
   * Before wrapping, key material must be formatted. If importing symmetric key
   * material, the expected key material format is plain bytes. If importing
   * asymmetric key material, the expected key material format is PKCS#8-encoded
   * DER (the PrivateKeyInfo structure from RFC 5208).
   *
   * When wrapping with import methods
   * ([RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
   * or
   * [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]
   * or
   * [RSA_OAEP_3072_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]
   * or
   * [RSA_OAEP_4096_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]),
   *
   * this field must contain the concatenation of:
   * <ol>
   *   <li>An ephemeral AES-256 wrapping key wrapped with the
   *       [public_key][google.cloud.kms.v1.ImportJob.public_key] using
   *       RSAES-OAEP with SHA-1/SHA-256, MGF1 with SHA-1/SHA-256, and an empty
   *       label.
   *   </li>
   *   <li>The formatted key to be imported, wrapped with the ephemeral AES-256
   *       key using AES-KWP (RFC 5649).
   *   </li>
   * </ol>
   *
   * This format is the same as the format produced by PKCS#11 mechanism
   * CKM_RSA_AES_KEY_WRAP.
   *
   * When wrapping with import methods
   * ([RSA_OAEP_3072_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]
   * or
   * [RSA_OAEP_4096_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]),
   *
   * this field must contain the formatted key to be imported, wrapped with the
   * [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP
   * with SHA-256, MGF1 with SHA-256, and an empty label.
   *
   * @generated from field: bytes wrapped_key = 8;
   */
  wrappedKey: Uint8Array;

  /**
   * This field is legacy. Use the field
   * [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key]
   * instead.
   *
   * @generated from oneof google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key_material
   */
  wrappedKeyMaterial: {
    /**
     * Optional. This field has the same meaning as
     * [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key].
     * Prefer to use that field in new work. Either that field or this field
     * (but not both) must be specified.
     *
     * @generated from field: bytes rsa_aes_wrapped_key = 5;
     */
    value: Uint8Array;
    case: "rsaAesWrappedKey";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.kms.v1.ImportCryptoKeyVersionRequest.
 * Use `create(ImportCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const ImportCryptoKeyVersionRequestSchema: GenMessage<ImportCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 16);

/**
 * Request message for
 * [KeyManagementService.CreateImportJob][google.cloud.kms.v1.KeyManagementService.CreateImportJob].
 *
 * @generated from message google.cloud.kms.v1.CreateImportJobRequest
 */
export type CreateImportJobRequest = Message<"google.cloud.kms.v1.CreateImportJobRequest"> & {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
   * [KeyRing][google.cloud.kms.v1.KeyRing] associated with the
   * [ImportJobs][google.cloud.kms.v1.ImportJob].
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. It must be unique within a KeyRing and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   *
   * @generated from field: string import_job_id = 2;
   */
  importJobId: string;

  /**
   * Required. An [ImportJob][google.cloud.kms.v1.ImportJob] with initial field
   * values.
   *
   * @generated from field: google.cloud.kms.v1.ImportJob import_job = 3;
   */
  importJob?: ImportJob;
};

/**
 * Describes the message google.cloud.kms.v1.CreateImportJobRequest.
 * Use `create(CreateImportJobRequestSchema)` to create a new message.
 */
export const CreateImportJobRequestSchema: GenMessage<CreateImportJobRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 17);

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKey][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey].
 *
 * @generated from message google.cloud.kms.v1.UpdateCryptoKeyRequest
 */
export type UpdateCryptoKeyRequest = Message<"google.cloud.kms.v1.UpdateCryptoKeyRequest"> & {
  /**
   * Required. [CryptoKey][google.cloud.kms.v1.CryptoKey] with updated values.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKey crypto_key = 1;
   */
  cryptoKey?: CryptoKey;

  /**
   * Required. List of fields to be updated in this request.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.cloud.kms.v1.UpdateCryptoKeyRequest.
 * Use `create(UpdateCryptoKeyRequestSchema)` to create a new message.
 */
export const UpdateCryptoKeyRequestSchema: GenMessage<UpdateCryptoKeyRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 18);

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.UpdateCryptoKeyVersionRequest
 */
export type UpdateCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.UpdateCryptoKeyVersionRequest"> & {
  /**
   * Required. [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * updated values.
   *
   * @generated from field: google.cloud.kms.v1.CryptoKeyVersion crypto_key_version = 1;
   */
  cryptoKeyVersion?: CryptoKeyVersion;

  /**
   * Required. List of fields to be updated in this request.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.cloud.kms.v1.UpdateCryptoKeyVersionRequest.
 * Use `create(UpdateCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const UpdateCryptoKeyVersionRequestSchema: GenMessage<UpdateCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 19);

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
 *
 * @generated from message google.cloud.kms.v1.UpdateCryptoKeyPrimaryVersionRequest
 */
export type UpdateCryptoKeyPrimaryVersionRequest = Message<"google.cloud.kms.v1.UpdateCryptoKeyPrimaryVersionRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to update.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The id of the child
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use as primary.
   *
   * @generated from field: string crypto_key_version_id = 2;
   */
  cryptoKeyVersionId: string;
};

/**
 * Describes the message google.cloud.kms.v1.UpdateCryptoKeyPrimaryVersionRequest.
 * Use `create(UpdateCryptoKeyPrimaryVersionRequestSchema)` to create a new message.
 */
export const UpdateCryptoKeyPrimaryVersionRequestSchema: GenMessage<UpdateCryptoKeyPrimaryVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 20);

/**
 * Request message for
 * [KeyManagementService.DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.DestroyCryptoKeyVersionRequest
 */
export type DestroyCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.DestroyCryptoKeyVersionRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to destroy.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.DestroyCryptoKeyVersionRequest.
 * Use `create(DestroyCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const DestroyCryptoKeyVersionRequestSchema: GenMessage<DestroyCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 21);

/**
 * Request message for
 * [KeyManagementService.RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion].
 *
 * @generated from message google.cloud.kms.v1.RestoreCryptoKeyVersionRequest
 */
export type RestoreCryptoKeyVersionRequest = Message<"google.cloud.kms.v1.RestoreCryptoKeyVersionRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to restore.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.kms.v1.RestoreCryptoKeyVersionRequest.
 * Use `create(RestoreCryptoKeyVersionRequestSchema)` to create a new message.
 */
export const RestoreCryptoKeyVersionRequestSchema: GenMessage<RestoreCryptoKeyVersionRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 22);

/**
 * Request message for
 * [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
 *
 * @generated from message google.cloud.kms.v1.EncryptRequest
 */
export type EncryptRequest = Message<"google.cloud.kms.v1.EncryptRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] or
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * encryption.
   *
   * If a [CryptoKey][google.cloud.kms.v1.CryptoKey] is specified, the server
   * will use its [primary version][google.cloud.kms.v1.CryptoKey.primary].
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The data to encrypt. Must be no larger than 64KiB.
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
   * [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   *
   * @generated from field: bytes plaintext = 2;
   */
  plaintext: Uint8Array;

  /**
   * Optional. Optional data that, if specified, must also be provided during
   * decryption through
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
   * [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys the
   * AAD must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   *
   * @generated from field: bytes additional_authenticated_data = 3;
   */
  additionalAuthenticatedData: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext])
   * is equal to
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value plaintext_crc32c = 7;
   */
  plaintextCrc32c?: bigint;

  /**
   * Optional. An optional CRC32C checksum of the
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data])
   * is equal to
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value additional_authenticated_data_crc32c = 8;
   */
  additionalAuthenticatedDataCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.EncryptRequest.
 * Use `create(EncryptRequestSchema)` to create a new message.
 */
export const EncryptRequestSchema: GenMessage<EncryptRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 23);

/**
 * Request message for
 * [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
 *
 * @generated from message google.cloud.kms.v1.DecryptRequest
 */
export type DecryptRequest = Message<"google.cloud.kms.v1.DecryptRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to use for decryption. The
   * server will choose the appropriate version.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The encrypted data originally returned in
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
   *
   * @generated from field: bytes ciphertext = 2;
   */
  ciphertext: Uint8Array;

  /**
   * Optional. Optional data that must match the data originally supplied in
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
   *
   * @generated from field: bytes additional_authenticated_data = 3;
   */
  additionalAuthenticatedData: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext])
   * is equal to
   * [DecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value ciphertext_crc32c = 5;
   */
  ciphertextCrc32c?: bigint;

  /**
   * Optional. An optional CRC32C checksum of the
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data])
   * is equal to
   * [DecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value additional_authenticated_data_crc32c = 6;
   */
  additionalAuthenticatedDataCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.DecryptRequest.
 * Use `create(DecryptRequestSchema)` to create a new message.
 */
export const DecryptRequestSchema: GenMessage<DecryptRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 24);

/**
 * Request message for
 * [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
 *
 * @generated from message google.cloud.kms.v1.RawEncryptRequest
 */
export type RawEncryptRequest = Message<"google.cloud.kms.v1.RawEncryptRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * encryption.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The data to encrypt. Must be no larger than 64KiB.
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   *
   * @generated from field: bytes plaintext = 2;
   */
  plaintext: Uint8Array;

  /**
   * Optional. Optional data that, if specified, must also be provided during
   * decryption through
   * [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
   *
   * This field may only be used in conjunction with an
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm] that accepts
   * additional authenticated data (for example, AES-GCM).
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   *
   * @generated from field: bytes additional_authenticated_data = 3;
   */
  additionalAuthenticatedData: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.plaintext][google.cloud.kms.v1.RawEncryptRequest.plaintext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received plaintext using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that CRC32C(plaintext) is equal
   * to plaintext_crc32c, and if so, perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value plaintext_crc32c = 4;
   */
  plaintextCrc32c?: bigint;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received additional_authenticated_data using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(additional_authenticated_data) is equal to
   * additional_authenticated_data_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * @generated from field: google.protobuf.Int64Value additional_authenticated_data_crc32c = 5;
   */
  additionalAuthenticatedDataCrc32c?: bigint;

  /**
   * Optional. A customer-supplied initialization vector that will be used for
   * encryption. If it is not provided for AES-CBC and AES-CTR, one will be
   * generated. It will be returned in
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   *
   * @generated from field: bytes initialization_vector = 6;
   */
  initializationVector: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.initialization_vector][google.cloud.kms.v1.RawEncryptRequest.initialization_vector].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received initialization_vector using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(initialization_vector) is equal to
   * initialization_vector_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * @generated from field: google.protobuf.Int64Value initialization_vector_crc32c = 7;
   */
  initializationVectorCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.RawEncryptRequest.
 * Use `create(RawEncryptRequestSchema)` to create a new message.
 */
export const RawEncryptRequestSchema: GenMessage<RawEncryptRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 25);

/**
 * Request message for
 * [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
 *
 * @generated from message google.cloud.kms.v1.RawDecryptRequest
 */
export type RawDecryptRequest = Message<"google.cloud.kms.v1.RawDecryptRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * decryption.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The encrypted data originally returned in
   * [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
   *
   * @generated from field: bytes ciphertext = 2;
   */
  ciphertext: Uint8Array;

  /**
   * Optional. Optional data that must match the data originally supplied in
   * [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
   *
   * @generated from field: bytes additional_authenticated_data = 3;
   */
  additionalAuthenticatedData: Uint8Array;

  /**
   * Required. The initialization vector (IV) used during encryption, which must
   * match the data originally provided in
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   *
   * @generated from field: bytes initialization_vector = 4;
   */
  initializationVector: Uint8Array;

  /**
   * The length of the authentication tag that is appended to the end of
   * the ciphertext. If unspecified (0), the default value for the key's
   * algorithm will be used (for AES-GCM, the default value is 16).
   *
   * @generated from field: int32 tag_length = 5;
   */
  tagLength: number;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received ciphertext using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that CRC32C(ciphertext) is equal
   * to ciphertext_crc32c, and if so, perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value ciphertext_crc32c = 6;
   */
  ciphertextCrc32c?: bigint;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received additional_authenticated_data using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(additional_authenticated_data) is equal to
   * additional_authenticated_data_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * @generated from field: google.protobuf.Int64Value additional_authenticated_data_crc32c = 7;
   */
  additionalAuthenticatedDataCrc32c?: bigint;

  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received initialization_vector using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(initialization_vector) is equal to initialization_vector_crc32c, and
   * if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * @generated from field: google.protobuf.Int64Value initialization_vector_crc32c = 8;
   */
  initializationVectorCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.RawDecryptRequest.
 * Use `create(RawDecryptRequestSchema)` to create a new message.
 */
export const RawDecryptRequestSchema: GenMessage<RawDecryptRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 26);

/**
 * Request message for
 * [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
 *
 * @generated from message google.cloud.kms.v1.AsymmetricSignRequest
 */
export type AsymmetricSignRequest = Message<"google.cloud.kms.v1.AsymmetricSignRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * signing.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. The digest of the data to sign. The digest must be produced with
   * the same digest algorithm as specified by the key version's
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm].
   *
   * This field may not be supplied if
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
   * is supplied.
   *
   * @generated from field: google.cloud.kms.v1.Digest digest = 3;
   */
  digest?: Digest;

  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest])
   * is equal to
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value digest_crc32c = 4;
   */
  digestCrc32c?: bigint;

  /**
   * Optional. The data to sign.
   * It can't be supplied if
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
   * is supplied.
   *
   * @generated from field: bytes data = 6;
   */
  data: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data])
   * is equal to
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value data_crc32c = 7;
   */
  dataCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.AsymmetricSignRequest.
 * Use `create(AsymmetricSignRequestSchema)` to create a new message.
 */
export const AsymmetricSignRequestSchema: GenMessage<AsymmetricSignRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 27);

/**
 * Request message for
 * [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
 *
 * @generated from message google.cloud.kms.v1.AsymmetricDecryptRequest
 */
export type AsymmetricDecryptRequest = Message<"google.cloud.kms.v1.AsymmetricDecryptRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * decryption.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The data encrypted with the named
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s public key using
   * OAEP.
   *
   * @generated from field: bytes ciphertext = 3;
   */
  ciphertext: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext])
   * is equal to
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value ciphertext_crc32c = 4;
   */
  ciphertextCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.AsymmetricDecryptRequest.
 * Use `create(AsymmetricDecryptRequestSchema)` to create a new message.
 */
export const AsymmetricDecryptRequestSchema: GenMessage<AsymmetricDecryptRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 28);

/**
 * Request message for
 * [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
 *
 * @generated from message google.cloud.kms.v1.MacSignRequest
 */
export type MacSignRequest = Message<"google.cloud.kms.v1.MacSignRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * signing.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The data to sign. The MAC tag is computed over this data field
   * based on the specific algorithm.
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]) is
   * equal to
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value data_crc32c = 3;
   */
  dataCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.MacSignRequest.
 * Use `create(MacSignRequestSchema)` to create a new message.
 */
export const MacSignRequestSchema: GenMessage<MacSignRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 29);

/**
 * Request message for
 * [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
 *
 * @generated from message google.cloud.kms.v1.MacVerifyRequest
 */
export type MacVerifyRequest = Message<"google.cloud.kms.v1.MacVerifyRequest"> & {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * verification.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The data used previously as a
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] to generate
   * the MAC tag.
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data])
   * is equal to
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value data_crc32c = 3;
   */
  dataCrc32c?: bigint;

  /**
   * Required. The signature to verify.
   *
   * @generated from field: bytes mac = 4;
   */
  mac: Uint8Array;

  /**
   * Optional. An optional CRC32C checksum of the
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacVerifyRequest.tag][]) is equal to
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value mac_crc32c = 5;
   */
  macCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.MacVerifyRequest.
 * Use `create(MacVerifyRequestSchema)` to create a new message.
 */
export const MacVerifyRequestSchema: GenMessage<MacVerifyRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 30);

/**
 * Request message for
 * [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
 *
 * @generated from message google.cloud.kms.v1.GenerateRandomBytesRequest
 */
export type GenerateRandomBytesRequest = Message<"google.cloud.kms.v1.GenerateRandomBytesRequest"> & {
  /**
   * The project-specific location in which to generate random bytes.
   * For example, "projects/my-project/locations/us-central1".
   *
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * The length in bytes of the amount of randomness to retrieve.  Minimum 8
   * bytes, maximum 1024 bytes.
   *
   * @generated from field: int32 length_bytes = 2;
   */
  lengthBytes: number;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when
   * generating the random data. Currently, only
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] protection level is
   * supported.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 3;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.GenerateRandomBytesRequest.
 * Use `create(GenerateRandomBytesRequestSchema)` to create a new message.
 */
export const GenerateRandomBytesRequestSchema: GenMessage<GenerateRandomBytesRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 31);

/**
 * Response message for
 * [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
 *
 * @generated from message google.cloud.kms.v1.EncryptResponse
 */
export type EncryptResponse = Message<"google.cloud.kms.v1.EncryptResponse"> & {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption. Check this field to verify that the intended resource was used
   * for encryption.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The encrypted data.
   *
   * @generated from field: bytes ciphertext = 2;
   */
  ciphertext: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
   * An integrity check of
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
   * can be performed by computing the CRC32C checksum of
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value ciphertext_crc32c = 4;
   */
  ciphertextCrc32c?: bigint;

  /**
   * Integrity verification field. A flag indicating whether
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. A false value of
   * this field indicates either that
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_plaintext_crc32c = 5;
   */
  verifiedPlaintextCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [AAD][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. A
   * false value of this field indicates either that
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_additional_authenticated_data_crc32c = 6;
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 7;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.EncryptResponse.
 * Use `create(EncryptResponseSchema)` to create a new message.
 */
export const EncryptResponseSchema: GenMessage<EncryptResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 32);

/**
 * Response message for
 * [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
 *
 * @generated from message google.cloud.kms.v1.DecryptResponse
 */
export type DecryptResponse = Message<"google.cloud.kms.v1.DecryptResponse"> & {
  /**
   * The decrypted data originally supplied in
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
   *
   * @generated from field: bytes plaintext = 1;
   */
  plaintext: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext].
   * An integrity check of
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
   * can be performed by computing the CRC32C checksum of
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: receiving this response message indicates that
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
   * successfully decrypt the
   * [ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   *
   * @generated from field: google.protobuf.Int64Value plaintext_crc32c = 2;
   */
  plaintextCrc32c?: bigint;

  /**
   * Whether the Decryption was performed using the primary key version.
   *
   * @generated from field: bool used_primary = 3;
   */
  usedPrimary: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 4;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.DecryptResponse.
 * Use `create(DecryptResponseSchema)` to create a new message.
 */
export const DecryptResponseSchema: GenMessage<DecryptResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 33);

/**
 * Response message for
 * [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
 *
 * @generated from message google.cloud.kms.v1.RawEncryptResponse
 */
export type RawEncryptResponse = Message<"google.cloud.kms.v1.RawEncryptResponse"> & {
  /**
   * The encrypted data. In the case of AES-GCM, the authentication tag
   * is the [tag_length][google.cloud.kms.v1.RawEncryptResponse.tag_length]
   * bytes at the end of this field.
   *
   * @generated from field: bytes ciphertext = 1;
   */
  ciphertext: Uint8Array;

  /**
   * The initialization vector (IV) generated by the service during
   * encryption. This value must be stored and provided in
   * [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector]
   * at decryption time.
   *
   * @generated from field: bytes initialization_vector = 2;
   */
  initializationVector: Uint8Array;

  /**
   * The length of the authentication tag that is appended to
   * the end of the ciphertext.
   *
   * @generated from field: int32 tag_length = 3;
   */
  tagLength: number;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
   * An integrity check of ciphertext can be performed by computing the CRC32C
   * checksum of ciphertext and comparing your results to this field. Discard
   * the response in case of non-matching checksum values, and perform a limited
   * number of retries. A persistent mismatch may indicate an issue in your
   * computation of the CRC32C checksum. Note: This field is defined as int64
   * for reasons of compatibility across different languages. However, it is a
   * non-negative integer, which will never exceed 2^32-1, and can be safely
   * downconverted to uint32 in languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value ciphertext_crc32c = 4;
   */
  ciphertextCrc32c?: bigint;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   * An integrity check of initialization_vector can be performed by computing
   * the CRC32C checksum of initialization_vector and comparing your results to
   * this field. Discard the response in case of non-matching checksum values,
   * and perform a limited number of retries. A persistent mismatch may indicate
   * an issue in your computation of the CRC32C checksum. Note: This field is
   * defined as int64 for reasons of compatibility across different languages.
   * However, it is a non-negative integer, which will never exceed 2^32-1, and
   * can be safely downconverted to uint32 in languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value initialization_vector_crc32c = 5;
   */
  initializationVectorCrc32c?: bigint;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the plaintext. A false value of this
   * field indicates either that
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_plaintext_crc32c = 6;
   */
  verifiedPlaintextCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of additional_authenticated_data. A false
   * value of this field indicates either that //
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_additional_authenticated_data_crc32c = 7;
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of initialization_vector. A false value of
   * this field indicates either that
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_initialization_vector_crc32c = 10;
   */
  verifiedInitializationVectorCrc32c: boolean;

  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption. Check this field to verify that the intended resource was used
   * for encryption.
   *
   * @generated from field: string name = 8;
   */
  name: string;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 9;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.RawEncryptResponse.
 * Use `create(RawEncryptResponseSchema)` to create a new message.
 */
export const RawEncryptResponseSchema: GenMessage<RawEncryptResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 34);

/**
 * Response message for
 * [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
 *
 * @generated from message google.cloud.kms.v1.RawDecryptResponse
 */
export type RawDecryptResponse = Message<"google.cloud.kms.v1.RawDecryptResponse"> & {
  /**
   * The decrypted data.
   *
   * @generated from field: bytes plaintext = 1;
   */
  plaintext: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawDecryptResponse.plaintext][google.cloud.kms.v1.RawDecryptResponse.plaintext].
   * An integrity check of plaintext can be performed by computing the CRC32C
   * checksum of plaintext and comparing your results to this field. Discard the
   * response in case of non-matching checksum values, and perform a limited
   * number of retries. A persistent mismatch may indicate an issue in your
   * computation of the CRC32C checksum. Note: receiving this response message
   * indicates that
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
   * successfully decrypt the
   * [ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * @generated from field: google.protobuf.Int64Value plaintext_crc32c = 2;
   */
  plaintextCrc32c?: bigint;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 3;
   */
  protectionLevel: ProtectionLevel;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the ciphertext. A false value of this
   * field indicates either that
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_ciphertext_crc32c = 4;
   */
  verifiedCiphertextCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of additional_authenticated_data. A false
   * value of this field indicates either that //
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_additional_authenticated_data_crc32c = 5;
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of initialization_vector. A false value of
   * this field indicates either that
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_initialization_vector_crc32c = 6;
   */
  verifiedInitializationVectorCrc32c: boolean;
};

/**
 * Describes the message google.cloud.kms.v1.RawDecryptResponse.
 * Use `create(RawDecryptResponseSchema)` to create a new message.
 */
export const RawDecryptResponseSchema: GenMessage<RawDecryptResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 35);

/**
 * Response message for
 * [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
 *
 * @generated from message google.cloud.kms.v1.AsymmetricSignResponse
 */
export type AsymmetricSignResponse = Message<"google.cloud.kms.v1.AsymmetricSignResponse"> & {
  /**
   * The created signature.
   *
   * @generated from field: bytes signature = 1;
   */
  signature: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature].
   * An integrity check of
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
   * can be performed by computing the CRC32C checksum of
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value signature_crc32c = 2;
   */
  signatureCrc32c?: bigint;

  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. A false value
   * of this field indicates either that
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_digest_crc32c = 3;
   */
  verifiedDigestCrc32c: boolean;

  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   * Check this field to verify that the intended resource was used for signing.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.AsymmetricSignRequest.data]. A false value of
   * this field indicates either that
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_data_crc32c = 5;
   */
  verifiedDataCrc32c: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 6;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.AsymmetricSignResponse.
 * Use `create(AsymmetricSignResponseSchema)` to create a new message.
 */
export const AsymmetricSignResponseSchema: GenMessage<AsymmetricSignResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 36);

/**
 * Response message for
 * [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
 *
 * @generated from message google.cloud.kms.v1.AsymmetricDecryptResponse
 */
export type AsymmetricDecryptResponse = Message<"google.cloud.kms.v1.AsymmetricDecryptResponse"> & {
  /**
   * The decrypted data originally encrypted with the matching public key.
   *
   * @generated from field: bytes plaintext = 1;
   */
  plaintext: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext].
   * An integrity check of
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
   * can be performed by computing the CRC32C checksum of
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value plaintext_crc32c = 2;
   */
  plaintextCrc32c?: bigint;

  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]. A
   * false value of this field indicates either that
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_ciphertext_crc32c = 3;
   */
  verifiedCiphertextCrc32c: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 4;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.AsymmetricDecryptResponse.
 * Use `create(AsymmetricDecryptResponseSchema)` to create a new message.
 */
export const AsymmetricDecryptResponseSchema: GenMessage<AsymmetricDecryptResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 37);

/**
 * Response message for
 * [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
 *
 * @generated from message google.cloud.kms.v1.MacSignResponse
 */
export type MacSignResponse = Message<"google.cloud.kms.v1.MacSignResponse"> & {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   * Check this field to verify that the intended resource was used for signing.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The created signature.
   *
   * @generated from field: bytes mac = 2;
   */
  mac: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac]. An
   * integrity check of
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] can be
   * performed by computing the CRC32C checksum of
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] and
   * comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value mac_crc32c = 3;
   */
  macCrc32c?: bigint;

  /**
   * Integrity verification field. A flag indicating whether
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacSignRequest.data]. A false value of this
   * field indicates either that
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_data_crc32c = 4;
   */
  verifiedDataCrc32c: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 5;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.MacSignResponse.
 * Use `create(MacSignResponseSchema)` to create a new message.
 */
export const MacSignResponseSchema: GenMessage<MacSignResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 38);

/**
 * Response message for
 * [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
 *
 * @generated from message google.cloud.kms.v1.MacVerifyResponse
 */
export type MacVerifyResponse = Message<"google.cloud.kms.v1.MacVerifyResponse"> & {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
   * verification. Check this field to verify that the intended resource was
   * used for verification.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * This field indicates whether or not the verification operation for
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] over
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] was
   * successful.
   *
   * @generated from field: bool success = 2;
   */
  success: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacVerifyRequest.data]. A false value of this
   * field indicates either that
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_data_crc32c = 3;
   */
  verifiedDataCrc32c: boolean;

  /**
   * Integrity verification field. A flag indicating whether
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacVerifyRequest.mac]. A false value of this
   * field indicates either that
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   *
   * @generated from field: bool verified_mac_crc32c = 4;
   */
  verifiedMacCrc32c: boolean;

  /**
   * Integrity verification field. This value is used for the integrity
   * verification of [MacVerifyResponse.success]. If the value of this field
   * contradicts the value of [MacVerifyResponse.success], discard the response
   * and perform a limited number of retries.
   *
   * @generated from field: bool verified_success_integrity = 5;
   */
  verifiedSuccessIntegrity: boolean;

  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
   * verification.
   *
   * @generated from field: google.cloud.kms.v1.ProtectionLevel protection_level = 6;
   */
  protectionLevel: ProtectionLevel;
};

/**
 * Describes the message google.cloud.kms.v1.MacVerifyResponse.
 * Use `create(MacVerifyResponseSchema)` to create a new message.
 */
export const MacVerifyResponseSchema: GenMessage<MacVerifyResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 39);

/**
 * Response message for
 * [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
 *
 * @generated from message google.cloud.kms.v1.GenerateRandomBytesResponse
 */
export type GenerateRandomBytesResponse = Message<"google.cloud.kms.v1.GenerateRandomBytesResponse"> & {
  /**
   * The generated data.
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;

  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data].
   * An integrity check of
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
   * can be performed by computing the CRC32C checksum of
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   *
   * @generated from field: google.protobuf.Int64Value data_crc32c = 3;
   */
  dataCrc32c?: bigint;
};

/**
 * Describes the message google.cloud.kms.v1.GenerateRandomBytesResponse.
 * Use `create(GenerateRandomBytesResponseSchema)` to create a new message.
 */
export const GenerateRandomBytesResponseSchema: GenMessage<GenerateRandomBytesResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 40);

/**
 * A [Digest][google.cloud.kms.v1.Digest] holds a cryptographic message digest.
 *
 * @generated from message google.cloud.kms.v1.Digest
 */
export type Digest = Message<"google.cloud.kms.v1.Digest"> & {
  /**
   * Required. The message digest.
   *
   * @generated from oneof google.cloud.kms.v1.Digest.digest
   */
  digest: {
    /**
     * A message digest produced with the SHA-256 algorithm.
     *
     * @generated from field: bytes sha256 = 1;
     */
    value: Uint8Array;
    case: "sha256";
  } | {
    /**
     * A message digest produced with the SHA-384 algorithm.
     *
     * @generated from field: bytes sha384 = 2;
     */
    value: Uint8Array;
    case: "sha384";
  } | {
    /**
     * A message digest produced with the SHA-512 algorithm.
     *
     * @generated from field: bytes sha512 = 3;
     */
    value: Uint8Array;
    case: "sha512";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.kms.v1.Digest.
 * Use `create(DigestSchema)` to create a new message.
 */
export const DigestSchema: GenMessage<Digest> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 41);

/**
 * Cloud KMS metadata for the given
 * [google.cloud.location.Location][google.cloud.location.Location].
 *
 * @generated from message google.cloud.kms.v1.LocationMetadata
 */
export type LocationMetadata = Message<"google.cloud.kms.v1.LocationMetadata"> & {
  /**
   * Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] can be created in this
   * location.
   *
   * @generated from field: bool hsm_available = 1;
   */
  hsmAvailable: boolean;

  /**
   * Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] can be created in
   * this location.
   *
   * @generated from field: bool ekm_available = 2;
   */
  ekmAvailable: boolean;
};

/**
 * Describes the message google.cloud.kms.v1.LocationMetadata.
 * Use `create(LocationMetadataSchema)` to create a new message.
 */
export const LocationMetadataSchema: GenMessage<LocationMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_kms_v1_service, 42);

/**
 * Google Cloud Key Management Service
 *
 * Manages cryptographic keys and operations using those keys. Implements a REST
 * model with the following objects:
 *
 * * [KeyRing][google.cloud.kms.v1.KeyRing]
 * * [CryptoKey][google.cloud.kms.v1.CryptoKey]
 * * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
 * * [ImportJob][google.cloud.kms.v1.ImportJob]
 *
 * If you are using manual gRPC libraries, see
 * [Using gRPC with Cloud KMS](https://cloud.google.com/kms/docs/grpc).
 *
 * @generated from service google.cloud.kms.v1.KeyManagementService
 */
export const KeyManagementService: GenService<{
  /**
   * Lists [KeyRings][google.cloud.kms.v1.KeyRing].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.ListKeyRings
   */
  listKeyRings: {
    methodKind: "unary";
    input: typeof ListKeyRingsRequestSchema;
    output: typeof ListKeyRingsResponseSchema;
  },
  /**
   * Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.ListCryptoKeys
   */
  listCryptoKeys: {
    methodKind: "unary";
    input: typeof ListCryptoKeysRequestSchema;
    output: typeof ListCryptoKeysResponseSchema;
  },
  /**
   * Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions
   */
  listCryptoKeyVersions: {
    methodKind: "unary";
    input: typeof ListCryptoKeyVersionsRequestSchema;
    output: typeof ListCryptoKeyVersionsResponseSchema;
  },
  /**
   * Lists [ImportJobs][google.cloud.kms.v1.ImportJob].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.ListImportJobs
   */
  listImportJobs: {
    methodKind: "unary";
    input: typeof ListImportJobsRequestSchema;
    output: typeof ListImportJobsResponseSchema;
  },
  /**
   * Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GetKeyRing
   */
  getKeyRing: {
    methodKind: "unary";
    input: typeof GetKeyRingRequestSchema;
    output: typeof KeyRingSchema;
  },
  /**
   * Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
   * well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GetCryptoKey
   */
  getCryptoKey: {
    methodKind: "unary";
    input: typeof GetCryptoKeyRequestSchema;
    output: typeof CryptoKeySchema;
  },
  /**
   * Returns metadata for a given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion
   */
  getCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof GetCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Returns the public key for the given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
   * or
   * [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GetPublicKey
   */
  getPublicKey: {
    methodKind: "unary";
    input: typeof GetPublicKeyRequestSchema;
    output: typeof PublicKeySchema;
  },
  /**
   * Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GetImportJob
   */
  getImportJob: {
    methodKind: "unary";
    input: typeof GetImportJobRequestSchema;
    output: typeof ImportJobSchema;
  },
  /**
   * Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
   * Location.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.CreateKeyRing
   */
  createKeyRing: {
    methodKind: "unary";
    input: typeof CreateKeyRingRequestSchema;
    output: typeof KeyRingSchema;
  },
  /**
   * Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
   * [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
   * are required.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.CreateCryptoKey
   */
  createCryptoKey: {
    methodKind: "unary";
    input: typeof CreateCryptoKeyRequestSchema;
    output: typeof CryptoKeySchema;
  },
  /**
   * Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * The server will assign the next sequential id. If unset,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion
   */
  createCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof CreateCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Import wrapped key material into a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
   * a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
   * specified in the request, key material will be reimported into that
   * version. Otherwise, a new version will be created, and will be assigned the
   * next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion
   */
  importCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof ImportCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
   * required.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.CreateImportJob
   */
  createImportJob: {
    methodKind: "unary";
    input: typeof CreateImportJobRequestSchema;
    output: typeof ImportJobSchema;
  },
  /**
   * Update a [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey
   */
  updateCryptoKey: {
    methodKind: "unary";
    input: typeof UpdateCryptoKeyRequestSchema;
    output: typeof CryptoKeySchema;
  },
  /**
   * Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
   * metadata.
   *
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * and
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
   * using this method. See
   * [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
   * and
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * to move between other states.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion
   */
  updateCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof UpdateCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
   * will be used in
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
   *
   * Returns an error if called on a key whose purpose is not
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion
   */
  updateCryptoKeyPrimaryVersion: {
    methodKind: "unary";
    input: typeof UpdateCryptoKeyPrimaryVersionRequestSchema;
    output: typeof CryptoKeySchema;
  },
  /**
   * Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
   * destruction.
   *
   * Upon calling this method,
   * [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
   * be set to
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be set to the time
   * [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
   * in the future. At that time, the
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
   * change to
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
   * and the key material will be irrevocably destroyed.
   *
   * Before the
   * [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
   * reached,
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * may be called to reverse the process.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion
   */
  destroyCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof DestroyCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
   * state.
   *
   * Upon restoration of the CryptoKeyVersion,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be cleared.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion
   */
  restoreCryptoKeyVersion: {
    methodKind: "unary";
    input: typeof RestoreCryptoKeyVersionRequestSchema;
    output: typeof CryptoKeyVersionSchema;
  },
  /**
   * Encrypts data, so that it can only be recovered by a call to
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.Encrypt
   */
  encrypt: {
    methodKind: "unary";
    input: typeof EncryptRequestSchema;
    output: typeof EncryptResponseSchema;
  },
  /**
   * Decrypts data that was protected by
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.Decrypt
   */
  decrypt: {
    methodKind: "unary";
    input: typeof DecryptRequestSchema;
    output: typeof DecryptResponseSchema;
  },
  /**
   * Encrypts data using portable cryptographic primitives. Most users should
   * choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
   * their raw counterparts. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.RawEncrypt
   */
  rawEncrypt: {
    methodKind: "unary";
    input: typeof RawEncryptRequestSchema;
    output: typeof RawEncryptResponseSchema;
  },
  /**
   * Decrypts data that was originally encrypted using a raw cryptographic
   * mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.RawDecrypt
   */
  rawDecrypt: {
    methodKind: "unary";
    input: typeof RawDecryptRequestSchema;
    output: typeof RawDecryptResponseSchema;
  },
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_SIGN, producing a signature that can be verified with the public
   * key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.AsymmetricSign
   */
  asymmetricSign: {
    methodKind: "unary";
    input: typeof AsymmetricSignRequestSchema;
    output: typeof AsymmetricSignResponseSchema;
  },
  /**
   * Decrypts data that was encrypted with a public key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
   * corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_DECRYPT.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt
   */
  asymmetricDecrypt: {
    methodKind: "unary";
    input: typeof AsymmetricDecryptRequestSchema;
    output: typeof AsymmetricDecryptResponseSchema;
  },
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
   * producing a tag that can be verified by another source with the same key.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.MacSign
   */
  macSign: {
    methodKind: "unary";
    input: typeof MacSignRequestSchema;
    output: typeof MacSignResponseSchema;
  },
  /**
   * Verifies MAC tag using a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
   * a response that indicates whether or not the verification was successful.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.MacVerify
   */
  macVerify: {
    methodKind: "unary";
    input: typeof MacVerifyRequestSchema;
    output: typeof MacVerifyResponseSchema;
  },
  /**
   * Generate random bytes using the Cloud KMS randomness source in the provided
   * location.
   *
   * @generated from rpc google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes
   */
  generateRandomBytes: {
    methodKind: "unary";
    input: typeof GenerateRandomBytesRequestSchema;
    output: typeof GenerateRandomBytesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_cloud_kms_v1_service, 0);

