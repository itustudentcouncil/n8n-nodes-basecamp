// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/redis/cluster/v1/cloud_redis_cluster.proto (package google.cloud.redis.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../../../api/annotations_pb";
import { file_google_api_client } from "../../../../api/client_pb";
import { file_google_api_field_behavior } from "../../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../../api/resource_pb";
import type { OperationSchema } from "../../../../longrunning/operations_pb";
import { file_google_longrunning_operations } from "../../../../longrunning/operations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/redis/cluster/v1/cloud_redis_cluster.proto.
 */
export const file_google_cloud_redis_cluster_v1_cloud_redis_cluster: GenFile = /*@__PURE__*/
  fileDesc("Cjdnb29nbGUvY2xvdWQvcmVkaXMvY2x1c3Rlci92MS9jbG91ZF9yZWRpc19jbHVzdGVyLnByb3RvEh1nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MSK8AQoUQ3JlYXRlQ2x1c3RlclJlcXVlc3QSOQoGcGFyZW50GAEgASgJQingQQL6QSMKIWxvY2F0aW9ucy5nb29nbGVhcGlzLmNvbS9Mb2NhdGlvbhIXCgpjbHVzdGVyX2lkGAIgASgJQgPgQQISPAoHY2x1c3RlchgDIAEoCzImLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNsdXN0ZXJCA+BBAhISCgpyZXF1ZXN0X2lkGAQgASgJIncKE0xpc3RDbHVzdGVyc1JlcXVlc3QSOQoGcGFyZW50GAEgASgJQingQQL6QSMKIWxvY2F0aW9ucy5nb29nbGVhcGlzLmNvbS9Mb2NhdGlvbhIRCglwYWdlX3NpemUYAiABKAUSEgoKcGFnZV90b2tlbhgDIAEoCSJ+ChRMaXN0Q2x1c3RlcnNSZXNwb25zZRI4CghjbHVzdGVycxgBIAMoCzImLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNsdXN0ZXISFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJEhMKC3VucmVhY2hhYmxlGAMgAygJIp4BChRVcGRhdGVDbHVzdGVyUmVxdWVzdBI0Cgt1cGRhdGVfbWFzaxgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tCA+BBAhI8CgdjbHVzdGVyGAIgASgLMiYuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2x1c3RlckID4EECEhIKCnJlcXVlc3RfaWQYAyABKAkiRwoRR2V0Q2x1c3RlclJlcXVlc3QSMgoEbmFtZRgBIAEoCUIk4EEC+kEeChxyZWRpcy5nb29nbGVhcGlzLmNvbS9DbHVzdGVyIl4KFERlbGV0ZUNsdXN0ZXJSZXF1ZXN0EjIKBG5hbWUYASABKAlCJOBBAvpBHgoccmVkaXMuZ29vZ2xlYXBpcy5jb20vQ2x1c3RlchISCgpyZXF1ZXN0X2lkGAIgASgJImgKJUdldENsdXN0ZXJDZXJ0aWZpY2F0ZUF1dGhvcml0eVJlcXVlc3QSPwoEbmFtZRgBIAEoCUIx4EEC+kErCilyZWRpcy5nb29nbGVhcGlzLmNvbS9DZXJ0aWZpY2F0ZUF1dGhvcml0eSK5DQoHQ2x1c3RlchIRCgRuYW1lGAEgASgJQgPgQQISNAoLY3JlYXRlX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSQAoFc3RhdGUYBCABKA4yLC5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5DbHVzdGVyLlN0YXRlQgPgQQMSEAoDdWlkGAUgASgJQgPgQQMSHwoNcmVwbGljYV9jb3VudBgIIAEoBUID4EEBSACIAQESUQoSYXV0aG9yaXphdGlvbl9tb2RlGAsgASgOMjAuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQXV0aG9yaXphdGlvbk1vZGVCA+BBARJaChd0cmFuc2l0X2VuY3J5cHRpb25fbW9kZRgMIAEoDjI0Lmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLlRyYW5zaXRFbmNyeXB0aW9uTW9kZUID4EEBEhkKB3NpemVfZ2IYDSABKAVCA+BBA0gBiAEBEh0KC3NoYXJkX2NvdW50GA4gASgFQgPgQQJIAogBARJCCgtwc2NfY29uZmlncxgPIAMoCzIoLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLlBzY0NvbmZpZ0ID4EECElIKE2Rpc2NvdmVyeV9lbmRwb2ludHMYECADKAsyMC5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5EaXNjb3ZlcnlFbmRwb2ludEID4EEDEkoKD3BzY19jb25uZWN0aW9ucxgRIAMoCzIsLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLlBzY0Nvbm5lY3Rpb25CA+BBAxJJCgpzdGF0ZV9pbmZvGBIgASgLMjAuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2x1c3Rlci5TdGF0ZUluZm9CA+BBAxI/Cglub2RlX3R5cGUYEyABKA4yJy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5Ob2RlVHlwZUID4EEBElgKEnBlcnNpc3RlbmNlX2NvbmZpZxgUIAEoCzI3Lmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNsdXN0ZXJQZXJzaXN0ZW5jZUNvbmZpZ0ID4EEBElQKDXJlZGlzX2NvbmZpZ3MYFSADKAsyOC5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5DbHVzdGVyLlJlZGlzQ29uZmlnc0VudHJ5QgPgQQESIQoPcHJlY2lzZV9zaXplX2diGBYgASgBQgPgQQNIA4gBARJcChh6b25lX2Rpc3RyaWJ1dGlvbl9jb25maWcYFyABKAsyNS5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5ab25lRGlzdHJpYnV0aW9uQ29uZmlnQgPgQQESLQobZGVsZXRpb25fcHJvdGVjdGlvbl9lbmFibGVkGBkgASgIQgPgQQFIBIgBARrqAQoJU3RhdGVJbmZvElIKC3VwZGF0ZV9pbmZvGAEgASgLMjsuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2x1c3Rlci5TdGF0ZUluZm8uVXBkYXRlSW5mb0gAGoABCgpVcGRhdGVJbmZvEh8KEnRhcmdldF9zaGFyZF9jb3VudBgBIAEoBUgAiAEBEiEKFHRhcmdldF9yZXBsaWNhX2NvdW50GAIgASgFSAGIAQFCFQoTX3RhcmdldF9zaGFyZF9jb3VudEIXChVfdGFyZ2V0X3JlcGxpY2FfY291bnRCBgoEaW5mbxozChFSZWRpc0NvbmZpZ3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIlQKBVN0YXRlEhUKEVNUQVRFX1VOU1BFQ0lGSUVEEAASDAoIQ1JFQVRJTkcQARIKCgZBQ1RJVkUQAhIMCghVUERBVElORxADEgwKCERFTEVUSU5HEAQ6XepBWgoccmVkaXMuZ29vZ2xlYXBpcy5jb20vQ2x1c3RlchI6cHJvamVjdHMve3Byb2plY3R9L2xvY2F0aW9ucy97bG9jYXRpb259L2NsdXN0ZXJzL3tjbHVzdGVyfUIQCg5fcmVwbGljYV9jb3VudEIKCghfc2l6ZV9nYkIOCgxfc2hhcmRfY291bnRCEgoQX3ByZWNpc2Vfc2l6ZV9nYkIeChxfZGVsZXRpb25fcHJvdGVjdGlvbl9lbmFibGVkIiEKCVBzY0NvbmZpZxIUCgduZXR3b3JrGAIgASgJQgPgQQIifwoRRGlzY292ZXJ5RW5kcG9pbnQSFAoHYWRkcmVzcxgBIAEoCUID4EEDEhEKBHBvcnQYAiABKAVCA+BBAxJBCgpwc2NfY29uZmlnGAMgASgLMiguZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuUHNjQ29uZmlnQgPgQQMijQEKDVBzY0Nvbm5lY3Rpb24SHgoRcHNjX2Nvbm5lY3Rpb25faWQYASABKAlCA+BBAxIUCgdhZGRyZXNzGAIgASgJQgPgQQMSHAoPZm9yd2FyZGluZ19ydWxlGAMgASgJQgPgQQMSFwoKcHJvamVjdF9pZBgEIAEoCUID4EEDEg8KB25ldHdvcmsYBSABKAkigAIKEU9wZXJhdGlvbk1ldGFkYXRhEjQKC2NyZWF0ZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjEKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEhMKBnRhcmdldBgDIAEoCUID4EEDEhEKBHZlcmIYBCABKAlCA+BBAxIbCg5zdGF0dXNfbWVzc2FnZRgFIAEoCUID4EEDEiMKFnJlcXVlc3RlZF9jYW5jZWxsYXRpb24YBiABKAhCA+BBAxIYCgthcGlfdmVyc2lvbhgHIAEoCUID4EEDItUDChRDZXJ0aWZpY2F0ZUF1dGhvcml0eRJsChFtYW5hZ2VkX3NlcnZlcl9jYRgBIAEoCzJPLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNlcnRpZmljYXRlQXV0aG9yaXR5Lk1hbmFnZWRDZXJ0aWZpY2F0ZUF1dGhvcml0eUgAEhEKBG5hbWUYAiABKAlCA+BBCBqtAQobTWFuYWdlZENlcnRpZmljYXRlQXV0aG9yaXR5EmsKCGNhX2NlcnRzGAEgAygLMlkuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2VydGlmaWNhdGVBdXRob3JpdHkuTWFuYWdlZENlcnRpZmljYXRlQXV0aG9yaXR5LkNlcnRDaGFpbhohCglDZXJ0Q2hhaW4SFAoMY2VydGlmaWNhdGVzGAEgAygJOn/qQXwKKXJlZGlzLmdvb2dsZWFwaXMuY29tL0NlcnRpZmljYXRlQXV0aG9yaXR5Ek9wcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3tsb2NhdGlvbn0vY2x1c3RlcnMve2NsdXN0ZXJ9L2NlcnRpZmljYXRlQXV0aG9yaXR5QgsKCXNlcnZlcl9jYSKHBwoYQ2x1c3RlclBlcnNpc3RlbmNlQ29uZmlnEloKBG1vZGUYASABKA4yRy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5DbHVzdGVyUGVyc2lzdGVuY2VDb25maWcuUGVyc2lzdGVuY2VNb2RlQgPgQQESWgoKcmRiX2NvbmZpZxgCIAEoCzJBLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNsdXN0ZXJQZXJzaXN0ZW5jZUNvbmZpZy5SREJDb25maWdCA+BBARJaCgphb2ZfY29uZmlnGAMgASgLMkEuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2x1c3RlclBlcnNpc3RlbmNlQ29uZmlnLkFPRkNvbmZpZ0ID4EEBGroCCglSREJDb25maWcScgoTcmRiX3NuYXBzaG90X3BlcmlvZBgBIAEoDjJQLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkNsdXN0ZXJQZXJzaXN0ZW5jZUNvbmZpZy5SREJDb25maWcuU25hcHNob3RQZXJpb2RCA+BBARJAChdyZGJfc25hcHNob3Rfc3RhcnRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBASJ3Cg5TbmFwc2hvdFBlcmlvZBIfChtTTkFQU0hPVF9QRVJJT0RfVU5TUEVDSUZJRUQQABIMCghPTkVfSE9VUhABEg0KCVNJWF9IT1VSUxACEhAKDFRXRUxWRV9IT1VSUxADEhUKEVRXRU5UWV9GT1VSX0hPVVJTEAQaxAEKCUFPRkNvbmZpZxJoCgxhcHBlbmRfZnN5bmMYASABKA4yTS5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5DbHVzdGVyUGVyc2lzdGVuY2VDb25maWcuQU9GQ29uZmlnLkFwcGVuZEZzeW5jQgPgQQEiTQoLQXBwZW5kRnN5bmMSHAoYQVBQRU5EX0ZTWU5DX1VOU1BFQ0lGSUVEEAASBgoCTk8QARIMCghFVkVSWVNFQxACEgoKBkFMV0FZUxADIlMKD1BlcnNpc3RlbmNlTW9kZRIgChxQRVJTSVNURU5DRV9NT0RFX1VOU1BFQ0lGSUVEEAASDAoIRElTQUJMRUQQARIHCgNSREIQAhIHCgNBT0YQAyLrAQoWWm9uZURpc3RyaWJ1dGlvbkNvbmZpZxJdCgRtb2RlGAEgASgOMkouZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuWm9uZURpc3RyaWJ1dGlvbkNvbmZpZy5ab25lRGlzdHJpYnV0aW9uTW9kZUID4EEBEhEKBHpvbmUYAiABKAlCA+BBASJfChRab25lRGlzdHJpYnV0aW9uTW9kZRImCiJaT05FX0RJU1RSSUJVVElPTl9NT0RFX1VOU1BFQ0lGSUVEEAASDgoKTVVMVElfWk9ORRABEg8KC1NJTkdMRV9aT05FEAIqXgoRQXV0aG9yaXphdGlvbk1vZGUSGQoVQVVUSF9NT0RFX1VOU1BFQ0lGSUVEEAASFgoSQVVUSF9NT0RFX0lBTV9BVVRIEAESFgoSQVVUSF9NT0RFX0RJU0FCTEVEEAIqjwEKCE5vZGVUeXBlEhkKFU5PREVfVFlQRV9VTlNQRUNJRklFRBAAEhoKFlJFRElTX1NIQVJFRF9DT1JFX05BTk8QARIYChRSRURJU19ISUdITUVNX01FRElVTRACEhgKFFJFRElTX0hJR0hNRU1fWExBUkdFEAMSGAoUUkVESVNfU1RBTkRBUkRfU01BTEwQBCqZAQoVVHJhbnNpdEVuY3J5cHRpb25Nb2RlEicKI1RSQU5TSVRfRU5DUllQVElPTl9NT0RFX1VOU1BFQ0lGSUVEEAASJAogVFJBTlNJVF9FTkNSWVBUSU9OX01PREVfRElTQUJMRUQQARIxCi1UUkFOU0lUX0VOQ1JZUFRJT05fTU9ERV9TRVJWRVJfQVVUSEVOVElDQVRJT04QAjLECgoRQ2xvdWRSZWRpc0NsdXN0ZXIStgEKDExpc3RDbHVzdGVycxIyLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1JlcXVlc3QaMy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5MaXN0Q2x1c3RlcnNSZXNwb25zZSI92kEGcGFyZW50gtPkkwIuEiwvdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qfS9jbHVzdGVycxKjAQoKR2V0Q2x1c3RlchIwLmdvb2dsZS5jbG91ZC5yZWRpcy5jbHVzdGVyLnYxLkdldENsdXN0ZXJSZXF1ZXN0GiYuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2x1c3RlciI72kEEbmFtZYLT5JMCLhIsL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0S4QEKDVVwZGF0ZUNsdXN0ZXISMy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5VcGRhdGVDbHVzdGVyUmVxdWVzdBodLmdvb2dsZS5sb25ncnVubmluZy5PcGVyYXRpb24ifMpBHgoHQ2x1c3RlchITZ29vZ2xlLnByb3RvYnVmLkFuedpBE2NsdXN0ZXIsdXBkYXRlX21hc2uC0+STAj86B2NsdXN0ZXIyNC92MS97Y2x1c3Rlci5uYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0SzwEKDURlbGV0ZUNsdXN0ZXISMy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5EZWxldGVDbHVzdGVyUmVxdWVzdBodLmdvb2dsZS5sb25ncnVubmluZy5PcGVyYXRpb24iaspBLAoVZ29vZ2xlLnByb3RvYnVmLkVtcHR5EhNnb29nbGUucHJvdG9idWYuQW552kEEbmFtZYLT5JMCLiosL3YxL3tuYW1lPXByb2plY3RzLyovbG9jYXRpb25zLyovY2x1c3RlcnMvKn0S3wEKDUNyZWF0ZUNsdXN0ZXISMy5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVxdWVzdBodLmdvb2dsZS5sb25ncnVubmluZy5PcGVyYXRpb24iespBHgoHQ2x1c3RlchITZ29vZ2xlLnByb3RvYnVmLkFuedpBGXBhcmVudCxjbHVzdGVyLGNsdXN0ZXJfaWSC0+STAjc6B2NsdXN0ZXIiLC92MS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25zLyp9L2NsdXN0ZXJzEu0BCh5HZXRDbHVzdGVyQ2VydGlmaWNhdGVBdXRob3JpdHkSRC5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MS5HZXRDbHVzdGVyQ2VydGlmaWNhdGVBdXRob3JpdHlSZXF1ZXN0GjMuZ29vZ2xlLmNsb3VkLnJlZGlzLmNsdXN0ZXIudjEuQ2VydGlmaWNhdGVBdXRob3JpdHkiUNpBBG5hbWWC0+STAkMSQS92MS97bmFtZT1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qL2NsdXN0ZXJzLyovY2VydGlmaWNhdGVBdXRob3JpdHl9GkjKQRRyZWRpcy5nb29nbGVhcGlzLmNvbdJBLmh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1CngEKIWNvbS5nb29nbGUuY2xvdWQucmVkaXMuY2x1c3Rlci52MUIWQ2xvdWRSZWRpc0NsdXN0ZXJQcm90b1ABWjtjbG91ZC5nb29nbGUuY29tL2dvL3JlZGlzL2NsdXN0ZXIvYXBpdjEvY2x1c3RlcnBiO2NsdXN0ZXJwYuoCIUdvb2dsZTo6Q2xvdWQ6OlJlZGlzOjpDbHVzdGVyOjpWMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_longrunning_operations, file_google_protobuf_any, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Request for [CreateCluster][CloudRedis.CreateCluster].
 *
 * @generated from message google.cloud.redis.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"google.cloud.redis.cluster.v1.CreateClusterRequest"> & {
  /**
   * Required. The resource name of the cluster location using the form:
   *     `projects/{project_id}/locations/{location_id}`
   * where `location_id` refers to a GCP region.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Required. The logical name of the Redis cluster in the customer project
   * with the following restrictions:
   *
   * * Must contain only lowercase letters, numbers, and hyphens.
   * * Must start with a letter.
   * * Must be between 1-63 characters.
   * * Must end with a number or a letter.
   * * Must be unique within the customer project / location
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Required. The cluster that is to be created.
   *
   * @generated from field: google.cloud.redis.cluster.v1.Cluster cluster = 3;
   */
  cluster?: Cluster;

  /**
   * Idempotent request UUID.
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 0);

/**
 * Request for [ListClusters][CloudRedis.ListClusters].
 *
 * @generated from message google.cloud.redis.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"google.cloud.redis.cluster.v1.ListClustersRequest"> & {
  /**
   * Required. The resource name of the cluster location using the form:
   *     `projects/{project_id}/locations/{location_id}`
   * where `location_id` refers to a GCP region.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of items to return.
   *
   * If not specified, a default value of 1000 will be used by the service.
   * Regardless of the page_size value, the response may include a partial list
   * and a caller should only rely on response's
   * [`next_page_token`][google.cloud.redis.cluster.v1.ListClustersResponse.next_page_token]
   * to determine if there are more clusters left to be queried.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * The `next_page_token` value returned from a previous
   * [ListClusters][CloudRedis.ListClusters] request, if any.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 1);

/**
 * Response for [ListClusters][CloudRedis.ListClusters].
 *
 * @generated from message google.cloud.redis.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"google.cloud.redis.cluster.v1.ListClustersResponse"> & {
  /**
   * A list of Redis clusters in the project in the specified location,
   * or across all locations.
   *
   * If the `location_id` in the parent field of the request is "-", all regions
   * available to the project are queried, and the results aggregated.
   * If in such an aggregated query a location is unavailable, a placeholder
   * Redis entry is included in the response with the `name` field set to a
   * value of the form
   * `projects/{project_id}/locations/{location_id}/clusters/`- and the
   * `status` field set to ERROR and `status_message` field set to "location not
   * available for ListClusters".
   *
   * @generated from field: repeated google.cloud.redis.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Locations that could not be reached.
   *
   * @generated from field: repeated string unreachable = 3;
   */
  unreachable: string[];
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 2);

/**
 * Request for [UpdateCluster][CloudRedis.UpdateCluster].
 *
 * @generated from message google.cloud.redis.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"google.cloud.redis.cluster.v1.UpdateClusterRequest"> & {
  /**
   * Required. Mask of fields to update. At least one path must be supplied in
   * this field. The elements of the repeated paths field may only include these
   * fields from [Cluster][google.cloud.redis.cluster.v1.Cluster]:
   *
   *  *   `size_gb`
   *  *   `replica_count`
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 1;
   */
  updateMask?: FieldMask;

  /**
   * Required. Update description.
   * Only fields specified in update_mask are updated.
   *
   * @generated from field: google.cloud.redis.cluster.v1.Cluster cluster = 2;
   */
  cluster?: Cluster;

  /**
   * Idempotent request UUID.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 3);

/**
 * Request for [GetCluster][CloudRedis.GetCluster].
 *
 * @generated from message google.cloud.redis.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"google.cloud.redis.cluster.v1.GetClusterRequest"> & {
  /**
   * Required. Redis cluster resource name using the form:
   *     `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
   * where `location_id` refers to a GCP region.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 4);

/**
 * Request for [DeleteCluster][CloudRedis.DeleteCluster].
 *
 * @generated from message google.cloud.redis.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"google.cloud.redis.cluster.v1.DeleteClusterRequest"> & {
  /**
   * Required. Redis cluster resource name using the form:
   *     `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
   * where `location_id` refers to a GCP region.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Idempotent request UUID.
   *
   * @generated from field: string request_id = 2;
   */
  requestId: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 5);

/**
 * Request for
 * [GetClusterCertificateAuthorityRequest][CloudRedis.GetClusterCertificateAuthorityRequest].
 *
 * @generated from message google.cloud.redis.cluster.v1.GetClusterCertificateAuthorityRequest
 */
export type GetClusterCertificateAuthorityRequest = Message<"google.cloud.redis.cluster.v1.GetClusterCertificateAuthorityRequest"> & {
  /**
   * Required. Redis cluster certificate authority resource name using the form:
   *     `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}/certificateAuthority`
   * where `location_id` refers to a GCP region.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.GetClusterCertificateAuthorityRequest.
 * Use `create(GetClusterCertificateAuthorityRequestSchema)` to create a new message.
 */
export const GetClusterCertificateAuthorityRequestSchema: GenMessage<GetClusterCertificateAuthorityRequest> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 6);

/**
 * A cluster instance.
 *
 * @generated from message google.cloud.redis.cluster.v1.Cluster
 */
export type Cluster = Message<"google.cloud.redis.cluster.v1.Cluster"> & {
  /**
   * Required. Unique name of the resource in this scope including project and
   * location using the form:
   *     `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The timestamp associated with the cluster creation request.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * Output only. The current state of this cluster.
   * Can be CREATING, READY, UPDATING, DELETING and SUSPENDED
   *
   * @generated from field: google.cloud.redis.cluster.v1.Cluster.State state = 4;
   */
  state: Cluster_State;

  /**
   * Output only. System assigned, unique identifier for the cluster.
   *
   * @generated from field: string uid = 5;
   */
  uid: string;

  /**
   * Optional. The number of replica nodes per shard.
   *
   * @generated from field: optional int32 replica_count = 8;
   */
  replicaCount?: number;

  /**
   * Optional. The authorization mode of the Redis cluster.
   * If not provided, auth feature is disabled for the cluster.
   *
   * @generated from field: google.cloud.redis.cluster.v1.AuthorizationMode authorization_mode = 11;
   */
  authorizationMode: AuthorizationMode;

  /**
   * Optional. The in-transit encryption for the Redis cluster.
   * If not provided, encryption  is disabled for the cluster.
   *
   * @generated from field: google.cloud.redis.cluster.v1.TransitEncryptionMode transit_encryption_mode = 12;
   */
  transitEncryptionMode: TransitEncryptionMode;

  /**
   * Output only. Redis memory size in GB for the entire cluster rounded up to
   * the next integer.
   *
   * @generated from field: optional int32 size_gb = 13;
   */
  sizeGb?: number;

  /**
   * Required. Number of shards for the Redis cluster.
   *
   * @generated from field: optional int32 shard_count = 14;
   */
  shardCount?: number;

  /**
   * Required. Each PscConfig configures the consumer network where IPs will
   * be designated to the cluster for client access through Private Service
   * Connect Automation. Currently, only one PscConfig is supported.
   *
   * @generated from field: repeated google.cloud.redis.cluster.v1.PscConfig psc_configs = 15;
   */
  pscConfigs: PscConfig[];

  /**
   * Output only. Endpoints created on each given network, for Redis clients to
   * connect to the cluster. Currently only one discovery endpoint is supported.
   *
   * @generated from field: repeated google.cloud.redis.cluster.v1.DiscoveryEndpoint discovery_endpoints = 16;
   */
  discoveryEndpoints: DiscoveryEndpoint[];

  /**
   * Output only. PSC connections for discovery of the cluster topology and
   * accessing the cluster.
   *
   * @generated from field: repeated google.cloud.redis.cluster.v1.PscConnection psc_connections = 17;
   */
  pscConnections: PscConnection[];

  /**
   * Output only. Additional information about the current state of the cluster.
   *
   * @generated from field: google.cloud.redis.cluster.v1.Cluster.StateInfo state_info = 18;
   */
  stateInfo?: Cluster_StateInfo;

  /**
   * Optional. The type of a redis node in the cluster. NodeType determines the
   * underlying machine-type of a redis node.
   *
   * @generated from field: google.cloud.redis.cluster.v1.NodeType node_type = 19;
   */
  nodeType: NodeType;

  /**
   * Optional. Persistence config (RDB, AOF) for the cluster.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig persistence_config = 20;
   */
  persistenceConfig?: ClusterPersistenceConfig;

  /**
   * Optional. Key/Value pairs of customer overrides for mutable Redis Configs
   *
   * @generated from field: map<string, string> redis_configs = 21;
   */
  redisConfigs: { [key: string]: string };

  /**
   * Output only. Precise value of redis memory size in GB for the entire
   * cluster.
   *
   * @generated from field: optional double precise_size_gb = 22;
   */
  preciseSizeGb?: number;

  /**
   * Optional. This config will be used to determine how the customer wants us
   * to distribute cluster resources within the region.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ZoneDistributionConfig zone_distribution_config = 23;
   */
  zoneDistributionConfig?: ZoneDistributionConfig;

  /**
   * Optional. The delete operation will fail when the value is set to true.
   *
   * @generated from field: optional bool deletion_protection_enabled = 25;
   */
  deletionProtectionEnabled?: boolean;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 7);

/**
 * Represents additional information about the state of the cluster.
 *
 * @generated from message google.cloud.redis.cluster.v1.Cluster.StateInfo
 */
export type Cluster_StateInfo = Message<"google.cloud.redis.cluster.v1.Cluster.StateInfo"> & {
  /**
   * @generated from oneof google.cloud.redis.cluster.v1.Cluster.StateInfo.info
   */
  info: {
    /**
     * Describes ongoing update on the cluster when cluster state is UPDATING.
     *
     * @generated from field: google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo update_info = 1;
     */
    value: Cluster_StateInfo_UpdateInfo;
    case: "updateInfo";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.cloud.redis.cluster.v1.Cluster.StateInfo.
 * Use `create(Cluster_StateInfoSchema)` to create a new message.
 */
export const Cluster_StateInfoSchema: GenMessage<Cluster_StateInfo> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 7, 0);

/**
 * Represents information about an updating cluster.
 *
 * @generated from message google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo
 */
export type Cluster_StateInfo_UpdateInfo = Message<"google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo"> & {
  /**
   * Target number of shards for redis cluster
   *
   * @generated from field: optional int32 target_shard_count = 1;
   */
  targetShardCount?: number;

  /**
   * Target number of replica nodes per shard.
   *
   * @generated from field: optional int32 target_replica_count = 2;
   */
  targetReplicaCount?: number;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo.
 * Use `create(Cluster_StateInfo_UpdateInfoSchema)` to create a new message.
 */
export const Cluster_StateInfo_UpdateInfoSchema: GenMessage<Cluster_StateInfo_UpdateInfo> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 7, 0, 0);

/**
 * Represents the different states of a Redis cluster.
 *
 * @generated from enum google.cloud.redis.cluster.v1.Cluster.State
 */
export enum Cluster_State {
  /**
   * Not set.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * Redis cluster is being created.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * Redis cluster has been created and is fully usable.
   *
   * @generated from enum value: ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * Redis cluster configuration is being updated.
   *
   * @generated from enum value: UPDATING = 3;
   */
  UPDATING = 3,

  /**
   * Redis cluster is being deleted.
   *
   * @generated from enum value: DELETING = 4;
   */
  DELETING = 4,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.Cluster.State.
 */
export const Cluster_StateSchema: GenEnum<Cluster_State> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 7, 0);

/**
 * @generated from message google.cloud.redis.cluster.v1.PscConfig
 */
export type PscConfig = Message<"google.cloud.redis.cluster.v1.PscConfig"> & {
  /**
   * Required. The network where the IP address of the discovery endpoint will
   * be reserved, in the form of
   * projects/{network_project}/global/networks/{network_id}.
   *
   * @generated from field: string network = 2;
   */
  network: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.PscConfig.
 * Use `create(PscConfigSchema)` to create a new message.
 */
export const PscConfigSchema: GenMessage<PscConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 8);

/**
 * Endpoints on each network, for Redis clients to connect to the cluster.
 *
 * @generated from message google.cloud.redis.cluster.v1.DiscoveryEndpoint
 */
export type DiscoveryEndpoint = Message<"google.cloud.redis.cluster.v1.DiscoveryEndpoint"> & {
  /**
   * Output only. Address of the exposed Redis endpoint used by clients to
   * connect to the service. The address could be either IP or hostname.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * Output only. The port number of the exposed Redis endpoint.
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * Output only. Customer configuration for where the endpoint is created and
   * accessed from.
   *
   * @generated from field: google.cloud.redis.cluster.v1.PscConfig psc_config = 3;
   */
  pscConfig?: PscConfig;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.DiscoveryEndpoint.
 * Use `create(DiscoveryEndpointSchema)` to create a new message.
 */
export const DiscoveryEndpointSchema: GenMessage<DiscoveryEndpoint> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 9);

/**
 * Details of consumer resources in a PSC connection.
 *
 * @generated from message google.cloud.redis.cluster.v1.PscConnection
 */
export type PscConnection = Message<"google.cloud.redis.cluster.v1.PscConnection"> & {
  /**
   * Output only. The PSC connection id of the forwarding rule connected to the
   * service attachment.
   *
   * @generated from field: string psc_connection_id = 1;
   */
  pscConnectionId: string;

  /**
   * Output only. The IP allocated on the consumer network for the PSC
   * forwarding rule.
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * Output only. The URI of the consumer side forwarding rule.
   * Example:
   * projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
   *
   * @generated from field: string forwarding_rule = 3;
   */
  forwardingRule: string;

  /**
   * Output only. The consumer project_id where the forwarding rule is created
   * from.
   *
   * @generated from field: string project_id = 4;
   */
  projectId: string;

  /**
   * The consumer network where the IP address resides, in the form of
   * projects/{project_id}/global/networks/{network_id}.
   *
   * @generated from field: string network = 5;
   */
  network: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.PscConnection.
 * Use `create(PscConnectionSchema)` to create a new message.
 */
export const PscConnectionSchema: GenMessage<PscConnection> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 10);

/**
 * Pre-defined metadata fields.
 *
 * @generated from message google.cloud.redis.cluster.v1.OperationMetadata
 */
export type OperationMetadata = Message<"google.cloud.redis.cluster.v1.OperationMetadata"> & {
  /**
   * Output only. The time the operation was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 1;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time the operation finished running.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Output only. Server-defined resource path for the target of the operation.
   *
   * @generated from field: string target = 3;
   */
  target: string;

  /**
   * Output only. Name of the verb executed by the operation.
   *
   * @generated from field: string verb = 4;
   */
  verb: string;

  /**
   * Output only. Human-readable status of the operation, if any.
   *
   * @generated from field: string status_message = 5;
   */
  statusMessage: string;

  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   *
   * @generated from field: bool requested_cancellation = 6;
   */
  requestedCancellation: boolean;

  /**
   * Output only. API version used to start the operation.
   *
   * @generated from field: string api_version = 7;
   */
  apiVersion: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.OperationMetadata.
 * Use `create(OperationMetadataSchema)` to create a new message.
 */
export const OperationMetadataSchema: GenMessage<OperationMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 11);

/**
 * Redis cluster certificate authority
 *
 * @generated from message google.cloud.redis.cluster.v1.CertificateAuthority
 */
export type CertificateAuthority = Message<"google.cloud.redis.cluster.v1.CertificateAuthority"> & {
  /**
   * server ca information
   *
   * @generated from oneof google.cloud.redis.cluster.v1.CertificateAuthority.server_ca
   */
  serverCa: {
    /**
     * @generated from field: google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority managed_server_ca = 1;
     */
    value: CertificateAuthority_ManagedCertificateAuthority;
    case: "managedServerCa";
  } | { case: undefined; value?: undefined };

  /**
   * Identifier. Unique name of the resource in this scope including project,
   * location and cluster using the form:
   *     `projects/{project}/locations/{location}/clusters/{cluster}/certificateAuthority`
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.CertificateAuthority.
 * Use `create(CertificateAuthoritySchema)` to create a new message.
 */
export const CertificateAuthoritySchema: GenMessage<CertificateAuthority> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 12);

/**
 * @generated from message google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority
 */
export type CertificateAuthority_ManagedCertificateAuthority = Message<"google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority"> & {
  /**
   * The PEM encoded CA certificate chains for redis managed
   * server authentication
   *
   * @generated from field: repeated google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain ca_certs = 1;
   */
  caCerts: CertificateAuthority_ManagedCertificateAuthority_CertChain[];
};

/**
 * Describes the message google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.
 * Use `create(CertificateAuthority_ManagedCertificateAuthoritySchema)` to create a new message.
 */
export const CertificateAuthority_ManagedCertificateAuthoritySchema: GenMessage<CertificateAuthority_ManagedCertificateAuthority> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 12, 0);

/**
 * @generated from message google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain
 */
export type CertificateAuthority_ManagedCertificateAuthority_CertChain = Message<"google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain"> & {
  /**
   * The certificates that form the CA chain, from leaf to root order.
   *
   * @generated from field: repeated string certificates = 1;
   */
  certificates: string[];
};

/**
 * Describes the message google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain.
 * Use `create(CertificateAuthority_ManagedCertificateAuthority_CertChainSchema)` to create a new message.
 */
export const CertificateAuthority_ManagedCertificateAuthority_CertChainSchema: GenMessage<CertificateAuthority_ManagedCertificateAuthority_CertChain> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 12, 0, 0);

/**
 * Configuration of the persistence functionality.
 *
 * @generated from message google.cloud.redis.cluster.v1.ClusterPersistenceConfig
 */
export type ClusterPersistenceConfig = Message<"google.cloud.redis.cluster.v1.ClusterPersistenceConfig"> & {
  /**
   * Optional. The mode of persistence.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig.PersistenceMode mode = 1;
   */
  mode: ClusterPersistenceConfig_PersistenceMode;

  /**
   * Optional. RDB configuration. This field will be ignored if mode is not RDB.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig rdb_config = 2;
   */
  rdbConfig?: ClusterPersistenceConfig_RDBConfig;

  /**
   * Optional. AOF configuration. This field will be ignored if mode is not AOF.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig aof_config = 3;
   */
  aofConfig?: ClusterPersistenceConfig_AOFConfig;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ClusterPersistenceConfig.
 * Use `create(ClusterPersistenceConfigSchema)` to create a new message.
 */
export const ClusterPersistenceConfigSchema: GenMessage<ClusterPersistenceConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13);

/**
 * Configuration of the RDB based persistence.
 *
 * @generated from message google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig
 */
export type ClusterPersistenceConfig_RDBConfig = Message<"google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig"> & {
  /**
   * Optional. Period between RDB snapshots.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig.SnapshotPeriod rdb_snapshot_period = 1;
   */
  rdbSnapshotPeriod: ClusterPersistenceConfig_RDBConfig_SnapshotPeriod;

  /**
   * Optional. The time that the first snapshot was/will be attempted, and to
   * which future snapshots will be aligned. If not provided, the current time
   * will be used.
   *
   * @generated from field: google.protobuf.Timestamp rdb_snapshot_start_time = 2;
   */
  rdbSnapshotStartTime?: Timestamp;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig.
 * Use `create(ClusterPersistenceConfig_RDBConfigSchema)` to create a new message.
 */
export const ClusterPersistenceConfig_RDBConfigSchema: GenMessage<ClusterPersistenceConfig_RDBConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13, 0);

/**
 * Available snapshot periods.
 *
 * @generated from enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig.SnapshotPeriod
 */
export enum ClusterPersistenceConfig_RDBConfig_SnapshotPeriod {
  /**
   * Not set.
   *
   * @generated from enum value: SNAPSHOT_PERIOD_UNSPECIFIED = 0;
   */
  SNAPSHOT_PERIOD_UNSPECIFIED = 0,

  /**
   * One hour.
   *
   * @generated from enum value: ONE_HOUR = 1;
   */
  ONE_HOUR = 1,

  /**
   * Six hours.
   *
   * @generated from enum value: SIX_HOURS = 2;
   */
  SIX_HOURS = 2,

  /**
   * Twelve hours.
   *
   * @generated from enum value: TWELVE_HOURS = 3;
   */
  TWELVE_HOURS = 3,

  /**
   * Twenty four hours.
   *
   * @generated from enum value: TWENTY_FOUR_HOURS = 4;
   */
  TWENTY_FOUR_HOURS = 4,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig.SnapshotPeriod.
 */
export const ClusterPersistenceConfig_RDBConfig_SnapshotPeriodSchema: GenEnum<ClusterPersistenceConfig_RDBConfig_SnapshotPeriod> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13, 0, 0);

/**
 * Configuration of the AOF based persistence.
 *
 * @generated from message google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig
 */
export type ClusterPersistenceConfig_AOFConfig = Message<"google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig"> & {
  /**
   * Optional. fsync configuration.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig.AppendFsync append_fsync = 1;
   */
  appendFsync: ClusterPersistenceConfig_AOFConfig_AppendFsync;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig.
 * Use `create(ClusterPersistenceConfig_AOFConfigSchema)` to create a new message.
 */
export const ClusterPersistenceConfig_AOFConfigSchema: GenMessage<ClusterPersistenceConfig_AOFConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13, 1);

/**
 * Available fsync modes.
 *
 * @generated from enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig.AppendFsync
 */
export enum ClusterPersistenceConfig_AOFConfig_AppendFsync {
  /**
   * Not set. Default: EVERYSEC
   *
   * @generated from enum value: APPEND_FSYNC_UNSPECIFIED = 0;
   */
  APPEND_FSYNC_UNSPECIFIED = 0,

  /**
   * Never fsync. Normally Linux will flush data every 30 seconds with this
   * configuration, but it's up to the kernel's exact tuning.
   *
   * @generated from enum value: NO = 1;
   */
  NO = 1,

  /**
   * fsync every second. Fast enough, and you may lose 1 second of data if
   * there is a disaster
   *
   * @generated from enum value: EVERYSEC = 2;
   */
  EVERYSEC = 2,

  /**
   * fsync every time new commands are appended to the AOF. It has the best
   * data loss protection at the cost of performance
   *
   * @generated from enum value: ALWAYS = 3;
   */
  ALWAYS = 3,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig.AppendFsync.
 */
export const ClusterPersistenceConfig_AOFConfig_AppendFsyncSchema: GenEnum<ClusterPersistenceConfig_AOFConfig_AppendFsync> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13, 1, 0);

/**
 * Available persistence modes.
 *
 * @generated from enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.PersistenceMode
 */
export enum ClusterPersistenceConfig_PersistenceMode {
  /**
   * Not set.
   *
   * @generated from enum value: PERSISTENCE_MODE_UNSPECIFIED = 0;
   */
  PERSISTENCE_MODE_UNSPECIFIED = 0,

  /**
   * Persistence is disabled, and any snapshot data is deleted.
   *
   * @generated from enum value: DISABLED = 1;
   */
  DISABLED = 1,

  /**
   * RDB based persistence is enabled.
   *
   * @generated from enum value: RDB = 2;
   */
  RDB = 2,

  /**
   * AOF based persistence is enabled.
   *
   * @generated from enum value: AOF = 3;
   */
  AOF = 3,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.ClusterPersistenceConfig.PersistenceMode.
 */
export const ClusterPersistenceConfig_PersistenceModeSchema: GenEnum<ClusterPersistenceConfig_PersistenceMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 13, 0);

/**
 * Zone distribution config for allocation of cluster resources.
 *
 * @generated from message google.cloud.redis.cluster.v1.ZoneDistributionConfig
 */
export type ZoneDistributionConfig = Message<"google.cloud.redis.cluster.v1.ZoneDistributionConfig"> & {
  /**
   * Optional. The mode of zone distribution. Defaults to MULTI_ZONE, when not
   * specified.
   *
   * @generated from field: google.cloud.redis.cluster.v1.ZoneDistributionConfig.ZoneDistributionMode mode = 1;
   */
  mode: ZoneDistributionConfig_ZoneDistributionMode;

  /**
   * Optional. When SINGLE ZONE distribution is selected, zone field would be
   * used to allocate all resources in that zone. This is not applicable to
   * MULTI_ZONE, and would be ignored for MULTI_ZONE clusters.
   *
   * @generated from field: string zone = 2;
   */
  zone: string;
};

/**
 * Describes the message google.cloud.redis.cluster.v1.ZoneDistributionConfig.
 * Use `create(ZoneDistributionConfigSchema)` to create a new message.
 */
export const ZoneDistributionConfigSchema: GenMessage<ZoneDistributionConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 14);

/**
 * Defines various modes of zone distribution.
 * Currently supports two modes, can be expanded in future to support more
 * types of distribution modes.
 * design doc: go/same-zone-cluster
 *
 * @generated from enum google.cloud.redis.cluster.v1.ZoneDistributionConfig.ZoneDistributionMode
 */
export enum ZoneDistributionConfig_ZoneDistributionMode {
  /**
   * Not Set. Default: MULTI_ZONE
   *
   * @generated from enum value: ZONE_DISTRIBUTION_MODE_UNSPECIFIED = 0;
   */
  ZONE_DISTRIBUTION_MODE_UNSPECIFIED = 0,

  /**
   * Distribute all resources across 3 zones picked at random, within the
   * region.
   *
   * @generated from enum value: MULTI_ZONE = 1;
   */
  MULTI_ZONE = 1,

  /**
   * Distribute all resources in a single zone. The zone field must be
   * specified, when this mode is selected.
   *
   * @generated from enum value: SINGLE_ZONE = 2;
   */
  SINGLE_ZONE = 2,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.ZoneDistributionConfig.ZoneDistributionMode.
 */
export const ZoneDistributionConfig_ZoneDistributionModeSchema: GenEnum<ZoneDistributionConfig_ZoneDistributionMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 14, 0);

/**
 * Available authorization mode of a Redis cluster.
 *
 * @generated from enum google.cloud.redis.cluster.v1.AuthorizationMode
 */
export enum AuthorizationMode {
  /**
   * Not set.
   *
   * @generated from enum value: AUTH_MODE_UNSPECIFIED = 0;
   */
  AUTH_MODE_UNSPECIFIED = 0,

  /**
   * IAM basic authorization mode
   *
   * @generated from enum value: AUTH_MODE_IAM_AUTH = 1;
   */
  AUTH_MODE_IAM_AUTH = 1,

  /**
   * Authorization disabled mode
   *
   * @generated from enum value: AUTH_MODE_DISABLED = 2;
   */
  AUTH_MODE_DISABLED = 2,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.AuthorizationMode.
 */
export const AuthorizationModeSchema: GenEnum<AuthorizationMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 0);

/**
 * NodeType of a redis cluster node,
 *
 * @generated from enum google.cloud.redis.cluster.v1.NodeType
 */
export enum NodeType {
  /**
   * @generated from enum value: NODE_TYPE_UNSPECIFIED = 0;
   */
  NODE_TYPE_UNSPECIFIED = 0,

  /**
   * Redis shared core nano node_type.
   *
   * @generated from enum value: REDIS_SHARED_CORE_NANO = 1;
   */
  REDIS_SHARED_CORE_NANO = 1,

  /**
   * Redis highmem medium node_type.
   *
   * @generated from enum value: REDIS_HIGHMEM_MEDIUM = 2;
   */
  REDIS_HIGHMEM_MEDIUM = 2,

  /**
   * Redis highmem xlarge node_type.
   *
   * @generated from enum value: REDIS_HIGHMEM_XLARGE = 3;
   */
  REDIS_HIGHMEM_XLARGE = 3,

  /**
   * Redis standard small node_type.
   *
   * @generated from enum value: REDIS_STANDARD_SMALL = 4;
   */
  REDIS_STANDARD_SMALL = 4,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.NodeType.
 */
export const NodeTypeSchema: GenEnum<NodeType> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 1);

/**
 * Available mode of in-transit encryption.
 *
 * @generated from enum google.cloud.redis.cluster.v1.TransitEncryptionMode
 */
export enum TransitEncryptionMode {
  /**
   * In-transit encryption not set.
   *
   * @generated from enum value: TRANSIT_ENCRYPTION_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * In-transit encryption disabled.
   *
   * @generated from enum value: TRANSIT_ENCRYPTION_MODE_DISABLED = 1;
   */
  DISABLED = 1,

  /**
   * Use server managed encryption for in-transit encryption.
   *
   * @generated from enum value: TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION = 2;
   */
  SERVER_AUTHENTICATION = 2,
}

/**
 * Describes the enum google.cloud.redis.cluster.v1.TransitEncryptionMode.
 */
export const TransitEncryptionModeSchema: GenEnum<TransitEncryptionMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 2);

/**
 * Configures and manages Cloud Memorystore for Redis clusters
 *
 * Google Cloud Memorystore for Redis Cluster
 *
 * The `redis.googleapis.com` service implements the Google Cloud Memorystore
 * for Redis API and defines the following resource model for managing Redis
 * clusters:
 * * The service works with a collection of cloud projects, named: `/projects/*`
 * * Each project has a collection of available locations, named: `/locations/*`
 * * Each location has a collection of Redis clusters, named: `/clusters/*`
 * * As such, Redis clusters are resources of the form:
 *   `/projects/{project_id}/locations/{location_id}/clusters/{instance_id}`
 *
 * Note that location_id must be a GCP `region`; for example:
 * * `projects/redpepper-1290/locations/us-central1/clusters/my-redis`
 *
 * We use API version selector for Flex APIs
 * * The versioning strategy is release-based versioning
 * * Our backend CLH only deals with the superset version (called v1main)
 * * Existing backend for Redis Gen1 and MRR is not touched.
 * * More details in go/redis-flex-api-versioning
 *
 * @generated from service google.cloud.redis.cluster.v1.CloudRedisCluster
 */
export const CloudRedisCluster: GenService<{
  /**
   * Lists all Redis clusters owned by a project in either the specified
   * location (region) or all locations.
   *
   * The location should have the following format:
   *
   * * `projects/{project_id}/locations/{location_id}`
   *
   * If `location_id` is specified as `-` (wildcard), then all regions
   * available to the project are queried, and the results are aggregated.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * Gets the details of a specific Redis cluster.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof ClusterSchema;
  },
  /**
   * Updates the metadata and configuration of a specific Redis cluster.
   *
   * Completed longrunning.Operation will contain the new cluster object
   * in the response field. The returned operation is automatically deleted
   * after a few hours, so there is no need to call DeleteOperation.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Deletes a specific Redis cluster. Cluster stops serving and data is
   * deleted.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Creates a Redis cluster based on the specified properties.
   * The creation is executed asynchronously and callers may check the returned
   * operation to track its progress. Once the operation is completed the Redis
   * cluster will be fully functional. The completed longrunning.Operation will
   * contain the new cluster object in the response field.
   *
   * The returned operation is automatically deleted after a few hours, so there
   * is no need to call DeleteOperation.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof OperationSchema;
  },
  /**
   * Gets the details of certificate authority information for Redis cluster.
   *
   * @generated from rpc google.cloud.redis.cluster.v1.CloudRedisCluster.GetClusterCertificateAuthority
   */
  getClusterCertificateAuthority: {
    methodKind: "unary";
    input: typeof GetClusterCertificateAuthorityRequestSchema;
    output: typeof CertificateAuthoritySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_cloud_redis_cluster_v1_cloud_redis_cluster, 0);

