// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/gkebackup/logging/v1/logged_restore_plan.proto (package google.cloud.gkebackup.logging.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { NamespacedNames, Namespaces } from "./logged_common_pb";
import { file_google_cloud_gkebackup_logging_v1_logged_common } from "./logged_common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/gkebackup/logging/v1/logged_restore_plan.proto.
 */
export const file_google_cloud_gkebackup_logging_v1_logged_restore_plan: GenFile = /*@__PURE__*/
  fileDesc("Cjtnb29nbGUvY2xvdWQvZ2tlYmFja3VwL2xvZ2dpbmcvdjEvbG9nZ2VkX3Jlc3RvcmVfcGxhbi5wcm90bxIhZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxIpkCChFMb2dnZWRSZXN0b3JlUGxhbhITCgtkZXNjcmlwdGlvbhgBIAEoCRITCgtiYWNrdXBfcGxhbhgCIAEoCRIPCgdjbHVzdGVyGAMgASgJEkgKDnJlc3RvcmVfY29uZmlnGAQgASgLMjAuZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLlJlc3RvcmVDb25maWcSUAoGbGFiZWxzGAUgAygLMkAuZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLkxvZ2dlZFJlc3RvcmVQbGFuLkxhYmVsc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi6wwKDVJlc3RvcmVDb25maWcSbAoadm9sdW1lX2RhdGFfcmVzdG9yZV9wb2xpY3kYASABKA4ySC5nb29nbGUuY2xvdWQuZ2tlYmFja3VwLmxvZ2dpbmcudjEuUmVzdG9yZUNvbmZpZy5Wb2x1bWVEYXRhUmVzdG9yZVBvbGljeRJ4CiBjbHVzdGVyX3Jlc291cmNlX2NvbmZsaWN0X3BvbGljeRgCIAEoDjJOLmdvb2dsZS5jbG91ZC5na2ViYWNrdXAubG9nZ2luZy52MS5SZXN0b3JlQ29uZmlnLkNsdXN0ZXJSZXNvdXJjZUNvbmZsaWN0UG9saWN5EngKIG5hbWVzcGFjZWRfcmVzb3VyY2VfcmVzdG9yZV9tb2RlGAMgASgOMk4uZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLlJlc3RvcmVDb25maWcuTmFtZXNwYWNlZFJlc291cmNlUmVzdG9yZU1vZGUSdAoeY2x1c3Rlcl9yZXNvdXJjZV9yZXN0b3JlX3Njb3BlGAQgASgLMkwuZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLlJlc3RvcmVDb25maWcuQ2x1c3RlclJlc291cmNlUmVzdG9yZVNjb3BlEhgKDmFsbF9uYW1lc3BhY2VzGAUgASgISAASTAoTc2VsZWN0ZWRfbmFtZXNwYWNlcxgGIAEoCzItLmdvb2dsZS5jbG91ZC5na2ViYWNrdXAubG9nZ2luZy52MS5OYW1lc3BhY2VzSAASUwoVc2VsZWN0ZWRfYXBwbGljYXRpb25zGAcgASgLMjIuZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLk5hbWVzcGFjZWROYW1lc0gAEl0KEnN1YnN0aXR1dGlvbl9ydWxlcxgIIAMoCzJBLmdvb2dsZS5jbG91ZC5na2ViYWNrdXAubG9nZ2luZy52MS5SZXN0b3JlQ29uZmlnLlN1YnN0aXR1dGlvblJ1bGUaOgoJR3JvdXBLaW5kEhYKDnJlc291cmNlX2dyb3VwGAEgASgJEhUKDXJlc291cmNlX2tpbmQYAiABKAkadwobQ2x1c3RlclJlc291cmNlUmVzdG9yZVNjb3BlElgKFHNlbGVjdGVkX2dyb3VwX2tpbmRzGAEgAygLMjouZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxLlJlc3RvcmVDb25maWcuR3JvdXBLaW5kGtIBChBTdWJzdGl0dXRpb25SdWxlEhkKEXRhcmdldF9uYW1lc3BhY2VzGAEgAygJElYKEnRhcmdldF9ncm91cF9raW5kcxgCIAMoCzI6Lmdvb2dsZS5jbG91ZC5na2ViYWNrdXAubG9nZ2luZy52MS5SZXN0b3JlQ29uZmlnLkdyb3VwS2luZBIYChB0YXJnZXRfanNvbl9wYXRoGAMgASgJEh4KFm9yaWdpbmFsX3ZhbHVlX3BhdHRlcm4YBCABKAkSEQoJbmV3X3ZhbHVlGAUgASgJIq8BChdWb2x1bWVEYXRhUmVzdG9yZVBvbGljeRIqCiZWT0xVTUVfREFUQV9SRVNUT1JFX1BPTElDWV9VTlNQRUNJRklFRBAAEiMKH1JFU1RPUkVfVk9MVU1FX0RBVEFfRlJPTV9CQUNLVVAQARIjCh9SRVVTRV9WT0xVTUVfSEFORExFX0ZST01fQkFDS1VQEAISHgoaTk9fVk9MVU1FX0RBVEFfUkVTVE9SQVRJT04QAyKDAQodQ2x1c3RlclJlc291cmNlQ29uZmxpY3RQb2xpY3kSMAosQ0xVU1RFUl9SRVNPVVJDRV9DT05GTElDVF9QT0xJQ1lfVU5TUEVDSUZJRUQQABIYChRVU0VfRVhJU1RJTkdfVkVSU0lPThABEhYKElVTRV9CQUNLVVBfVkVSU0lPThACIn8KHU5hbWVzcGFjZWRSZXNvdXJjZVJlc3RvcmVNb2RlEjAKLE5BTUVTUEFDRURfUkVTT1VSQ0VfUkVTVE9SRV9NT0RFX1VOU1BFQ0lGSUVEEAASFgoSREVMRVRFX0FORF9SRVNUT1JFEAESFAoQRkFJTF9PTl9DT05GTElDVBACQiMKIW5hbWVzcGFjZWRfcmVzb3VyY2VfcmVzdG9yZV9zY29wZULuAQohZ29vZ2xlLmNsb3VkLmdrZWJhY2t1cC5sb2dnaW5nLnYxQhZMb2dnZWRSZXN0b3JlUGxhblByb3RvUAFaP2Nsb3VkLmdvb2dsZS5jb20vZ28vZ2tlYmFja3VwL2xvZ2dpbmcvYXBpdjEvbG9nZ2luZ3BiO2xvZ2dpbmdwYqoCIUdvb2dsZS5DbG91ZC5Ha2VCYWNrdXAuTG9nZ2luZy5WMcoCIUdvb2dsZVxDbG91ZFxHa2VCYWNrdXBcTG9nZ2luZ1xWMeoCJUdvb2dsZTo6Q2xvdWQ6OkdrZUJhY2t1cDo6TG9nZ2luZzo6VjFiBnByb3RvMw", [file_google_cloud_gkebackup_logging_v1_logged_common]);

/**
 * RestorePlan as stored in Platform log. It's used to log the details of
 * a createRestorePlan/updateRestorePlan request, so only fields that can be
 * taken from user input are included here.
 *
 * @generated from message google.cloud.gkebackup.logging.v1.LoggedRestorePlan
 */
export type LoggedRestorePlan = Message<"google.cloud.gkebackup.logging.v1.LoggedRestorePlan"> & {
  /**
   * User specified descriptive string for this RestorePlan.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * The BackupPlan from which Backups may be used as the source
   * for Restores created via this RestorePlan.
   * Format: projects/*\/locations/*\/backupPlans/*.
   *
   * @generated from field: string backup_plan = 2;
   */
  backupPlan: string;

  /**
   * The target cluster into which Restores created via this RestorePlan
   * will restore data. NOTE: the cluster's region must be the same as the
   * RestorePlan.
   * Possible formats:
   *   1. projects/*\/locations/*\/clusters/*
   *   2. projects/*\/zones/*\/clusters/*
   *
   * @generated from field: string cluster = 3;
   */
  cluster: string;

  /**
   * Configuration of Restores created via this RestorePlan.
   *
   * @generated from field: google.cloud.gkebackup.logging.v1.RestoreConfig restore_config = 4;
   */
  restoreConfig?: RestoreConfig;

  /**
   * A set of custom labels supplied by user.
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.cloud.gkebackup.logging.v1.LoggedRestorePlan.
 * Use `create(LoggedRestorePlanSchema)` to create a new message.
 */
export const LoggedRestorePlanSchema: GenMessage<LoggedRestorePlan> = /*@__PURE__*/
  messageDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 0);

/**
 * Configuration of a restore.
 *
 * @generated from message google.cloud.gkebackup.logging.v1.RestoreConfig
 */
export type RestoreConfig = Message<"google.cloud.gkebackup.logging.v1.RestoreConfig"> & {
  /**
   * Specifies the mechanism to be used to restore volume data.
   * Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
   * NO_VOLUME_DATA_RESTORATION).
   *
   * @generated from field: google.cloud.gkebackup.logging.v1.RestoreConfig.VolumeDataRestorePolicy volume_data_restore_policy = 1;
   */
  volumeDataRestorePolicy: RestoreConfig_VolumeDataRestorePolicy;

  /**
   * Defines the behavior for handling the situation where cluster-scoped
   * resources being restored already exist in the target cluster. This MUST be
   * set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
   * cluster_resource_restore_scope is not empty.
   *
   * @generated from field: google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceConflictPolicy cluster_resource_conflict_policy = 2;
   */
  clusterResourceConflictPolicy: RestoreConfig_ClusterResourceConflictPolicy;

  /**
   * Defines the behavior for handling the situation where sets of namespaced
   * resources being restored already exist in the target cluster. This MUST be
   * set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED if
   * any namespaced restoration is configured via
   * namespaced_resource_restore_scope .
   *
   * @generated from field: google.cloud.gkebackup.logging.v1.RestoreConfig.NamespacedResourceRestoreMode namespaced_resource_restore_mode = 3;
   */
  namespacedResourceRestoreMode: RestoreConfig_NamespacedResourceRestoreMode;

  /**
   * Identifies the cluster-scoped resources to restore from the Backup.
   * Not specifying it means NO cluster resource will be restored.
   *
   * @generated from field: google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceRestoreScope cluster_resource_restore_scope = 4;
   */
  clusterResourceRestoreScope?: RestoreConfig_ClusterResourceRestoreScope;

  /**
   * Specifies the namespaced resources to restore from the Backup.
   * Only one of the entries may be specified. If not specified, NO namespaced
   * resources will be restored.
   *
   * @generated from oneof google.cloud.gkebackup.logging.v1.RestoreConfig.namespaced_resource_restore_scope
   */
  namespacedResourceRestoreScope: {
    /**
     * Restore all namespaced resources in the Backup if set to "True".
     * Specifying this field to "False" is an error.
     *
     * @generated from field: bool all_namespaces = 5;
     */
    value: boolean;
    case: "allNamespaces";
  } | {
    /**
     * A list of selected Namespaces to restore from the Backup. The listed
     * Namespaces and all resources contained in them will be restored.
     *
     * @generated from field: google.cloud.gkebackup.logging.v1.Namespaces selected_namespaces = 6;
     */
    value: Namespaces;
    case: "selectedNamespaces";
  } | {
    /**
     * A list of selected ProtectedApplications to restore. The listed
     * ProtectedApplications and all the resources to which they refer will be
     * restored.
     *
     * @generated from field: google.cloud.gkebackup.logging.v1.NamespacedNames selected_applications = 7;
     */
    value: NamespacedNames;
    case: "selectedApplications";
  } | { case: undefined; value?: undefined };

  /**
   * A list of transformation rules to be applied against Kubernetes resources
   * as they are selected for restoration from a Backup. Rules are executed in
   * order defined - this order matters, as changes made by a rule may impact
   * the filtering logic of subsequent rules. An empty list means no
   * substitution will occur.
   *
   * @generated from field: repeated google.cloud.gkebackup.logging.v1.RestoreConfig.SubstitutionRule substitution_rules = 8;
   */
  substitutionRules: RestoreConfig_SubstitutionRule[];
};

/**
 * Describes the message google.cloud.gkebackup.logging.v1.RestoreConfig.
 * Use `create(RestoreConfigSchema)` to create a new message.
 */
export const RestoreConfigSchema: GenMessage<RestoreConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1);

/**
 * This is a direct map to the Kubernetes GroupKind type
 * [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind)
 * and is used for identifying specific "types" of resources to restore.
 *
 * @generated from message google.cloud.gkebackup.logging.v1.RestoreConfig.GroupKind
 */
export type RestoreConfig_GroupKind = Message<"google.cloud.gkebackup.logging.v1.RestoreConfig.GroupKind"> & {
  /**
   * API group string of a Kubernetes resource, e.g.
   * "apiextensions.k8s.io", "storage.k8s.io", etc.
   * Note: use empty string for core API group
   *
   * @generated from field: string resource_group = 1;
   */
  resourceGroup: string;

  /**
   * Kind of a Kubernetes resource, e.g.
   * "CustomResourceDefinition", "StorageClass", etc.
   *
   * @generated from field: string resource_kind = 2;
   */
  resourceKind: string;
};

/**
 * Describes the message google.cloud.gkebackup.logging.v1.RestoreConfig.GroupKind.
 * Use `create(RestoreConfig_GroupKindSchema)` to create a new message.
 */
export const RestoreConfig_GroupKindSchema: GenMessage<RestoreConfig_GroupKind> = /*@__PURE__*/
  messageDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 0);

/**
 * Identifies the cluster-scoped resources to restore from the Backup.
 *
 * @generated from message google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceRestoreScope
 */
export type RestoreConfig_ClusterResourceRestoreScope = Message<"google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceRestoreScope"> & {
  /**
   * A list of "types" of cluster-scoped resources to be restored from the
   * Backup.  An empty list means that NO cluster-scoped resources will be
   * restored. Note that Namespaces and PersistentVolume restoration is
   * handled separately and is not governed by this field.
   *
   * @generated from field: repeated google.cloud.gkebackup.logging.v1.RestoreConfig.GroupKind selected_group_kinds = 1;
   */
  selectedGroupKinds: RestoreConfig_GroupKind[];
};

/**
 * Describes the message google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceRestoreScope.
 * Use `create(RestoreConfig_ClusterResourceRestoreScopeSchema)` to create a new message.
 */
export const RestoreConfig_ClusterResourceRestoreScopeSchema: GenMessage<RestoreConfig_ClusterResourceRestoreScope> = /*@__PURE__*/
  messageDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 1);

/**
 * A transformation rule to be applied against Kubernetes resources as they
 * are selected for restoration from a Backup. A rule contains both filtering
 * logic (which resources are subject to substitution) and substitution logic.
 *
 * @generated from message google.cloud.gkebackup.logging.v1.RestoreConfig.SubstitutionRule
 */
export type RestoreConfig_SubstitutionRule = Message<"google.cloud.gkebackup.logging.v1.RestoreConfig.SubstitutionRule"> & {
  /**
   * (Filtering parameter) Any resource subject to substitution must be
   * contained within one of the listed Kubernetes Namespace in the Backup.
   * If this field is not provided, no namespace filtering will be performed
   * (all resources in all Namespaces, including all cluster-scoped resources,
   * will be candidates for substitution).
   * To mix cluster-scoped and namespaced resources in the same rule, use an
   * empty string ("") as one of the target namespaces.
   *
   * @generated from field: repeated string target_namespaces = 1;
   */
  targetNamespaces: string[];

  /**
   * (Filtering parameter) Any resource subject to substitution must belong to
   * one of the listed "types".
   * If this field is not provided, no type filtering will be performed (all
   * resources of all types matching previous filtering parameters will be
   * candidates for substitution).
   *
   * @generated from field: repeated google.cloud.gkebackup.logging.v1.RestoreConfig.GroupKind target_group_kinds = 2;
   */
  targetGroupKinds: RestoreConfig_GroupKind[];

  /**
   * This is a [JSONPath]
   * ([https://kubernetes.io/docs/reference/kubectl/jsonpath/)
   * expression that matches specific fields of candidate
   * resources and it operates as both a filtering parameter (resources that
   * are not matched with this expression will not be candidates for
   * substitution) as well as a field identifier (identifies exactly which
   * fields out of the candidate resources will be modified).
   *
   * @generated from field: string target_json_path = 3;
   */
  targetJsonPath: string;

  /**
   * (Filtering parameter) This is a [regular expression]
   * (https://en.wikipedia.org/wiki/Regular_expression)
   * that is compared against the fields matched by the target_json_path
   * expression (and must also have passed the previous filters).
   * Substitution will not be performed against fields whose
   * value does not match this expression. If this field is NOT specified,
   * then ALL fields matched by the target_json_path expression will undergo
   * substitution. Note that an empty (e.g., "", rather than unspecified)
   * value for for this field will only match empty fields.
   *
   * @generated from field: string original_value_pattern = 4;
   */
  originalValuePattern: string;

  /**
   * This is the new value to set for any fields that pass the filtering and
   * selection criteria. To remove a value from a Kubernetes resource, either
   * leave this field unspecified, or set it to the empty string ("").
   *
   * @generated from field: string new_value = 5;
   */
  newValue: string;
};

/**
 * Describes the message google.cloud.gkebackup.logging.v1.RestoreConfig.SubstitutionRule.
 * Use `create(RestoreConfig_SubstitutionRuleSchema)` to create a new message.
 */
export const RestoreConfig_SubstitutionRuleSchema: GenMessage<RestoreConfig_SubstitutionRule> = /*@__PURE__*/
  messageDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 2);

/**
 * Defines how volume data should be restored
 *
 * @generated from enum google.cloud.gkebackup.logging.v1.RestoreConfig.VolumeDataRestorePolicy
 */
export enum RestoreConfig_VolumeDataRestorePolicy {
  /**
   * unspecified, default value
   *
   * @generated from enum value: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED = 0;
   */
  VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED = 0,

  /**
   * For each PVC to be restored, will create a new underlying volume (and PV)
   * from the corresponding VolumeBackup contained within the Backup.
   *
   * @generated from enum value: RESTORE_VOLUME_DATA_FROM_BACKUP = 1;
   */
  RESTORE_VOLUME_DATA_FROM_BACKUP = 1,

  /**
   * For each PVC to be restored, attempt to reuse the original PV contained
   * in the Backup (with its original underlying volume).  Note that option
   * is likely only usable when restoring a workload to its original cluster.
   *
   * @generated from enum value: REUSE_VOLUME_HANDLE_FROM_BACKUP = 2;
   */
  REUSE_VOLUME_HANDLE_FROM_BACKUP = 2,

  /**
   * For each PVC to be restored, PVCs will be created without any particular
   * action to restore data.  In this case, the normal Kubernetes provisioning
   * logic would kick in, and this would likely result in either dynamically
   * provisioning blank PVs or binding to statically provisioned PVs.
   *
   * @generated from enum value: NO_VOLUME_DATA_RESTORATION = 3;
   */
  NO_VOLUME_DATA_RESTORATION = 3,
}

/**
 * Describes the enum google.cloud.gkebackup.logging.v1.RestoreConfig.VolumeDataRestorePolicy.
 */
export const RestoreConfig_VolumeDataRestorePolicySchema: GenEnum<RestoreConfig_VolumeDataRestorePolicy> = /*@__PURE__*/
  enumDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 0);

/**
 * Defines the behavior for handling the situation where cluster-scoped
 * resources being restored already exist in the target cluster.
 *
 * @generated from enum google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceConflictPolicy
 */
export enum RestoreConfig_ClusterResourceConflictPolicy {
  /**
   * Unspecified. Only allowed if no cluster-scoped resources will be
   * restored.
   *
   * @generated from enum value: CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED = 0;
   */
  CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED = 0,

  /**
   * Do not attempt to restore the conflicting resource.
   *
   * @generated from enum value: USE_EXISTING_VERSION = 1;
   */
  USE_EXISTING_VERSION = 1,

  /**
   * Delete the existing version before re-creating it from the Backup.
   * Note that this is a dangerous option which could cause unintentional
   * data loss if used inappropriately - for example, deleting a CRD will
   * cause Kubernetes to delete all CRs of that type.
   *
   * @generated from enum value: USE_BACKUP_VERSION = 2;
   */
  USE_BACKUP_VERSION = 2,
}

/**
 * Describes the enum google.cloud.gkebackup.logging.v1.RestoreConfig.ClusterResourceConflictPolicy.
 */
export const RestoreConfig_ClusterResourceConflictPolicySchema: GenEnum<RestoreConfig_ClusterResourceConflictPolicy> = /*@__PURE__*/
  enumDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 1);

/**
 * Defines the behavior for handling the situation where sets of namespaced
 * resources being restored already exist in the target cluster.
 *
 * @generated from enum google.cloud.gkebackup.logging.v1.RestoreConfig.NamespacedResourceRestoreMode
 */
export enum RestoreConfig_NamespacedResourceRestoreMode {
  /**
   * Unspecified. Only allowed if no namespaced resources will be restored.
   *
   * @generated from enum value: NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED = 0;
   */
  NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED = 0,

  /**
   * When conflicting top-level resources (either Namespaces or
   * ProtectedApplications, depending upon the scope) are encountered, this
   * will first trigger a delete of the conflicting resource AND ALL OF ITS
   * REFERENCED RESOURCES (e.g., all resources in the Namespace or all
   * resources referenced by the ProtectedApplication) before restoring the
   * resources from the Backup. This mode should only be used when you are
   * intending to revert some portion of a cluster to an earlier state.
   *
   * @generated from enum value: DELETE_AND_RESTORE = 1;
   */
  DELETE_AND_RESTORE = 1,

  /**
   * If conflicting top-level resources (either Namespaces or
   * ProtectedApplications, depending upon the scope) are encountered at the
   * beginning of a restore process, the Restore will fail.  If a conflict
   * occurs during the restore process itself (e.g., because an out of band
   * process creates conflicting resources), a conflict will be reported.
   *
   * @generated from enum value: FAIL_ON_CONFLICT = 2;
   */
  FAIL_ON_CONFLICT = 2,
}

/**
 * Describes the enum google.cloud.gkebackup.logging.v1.RestoreConfig.NamespacedResourceRestoreMode.
 */
export const RestoreConfig_NamespacedResourceRestoreModeSchema: GenEnum<RestoreConfig_NamespacedResourceRestoreMode> = /*@__PURE__*/
  enumDesc(file_google_cloud_gkebackup_logging_v1_logged_restore_plan, 1, 2);

