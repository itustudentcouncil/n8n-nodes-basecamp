// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/cloud/managedkafka/v1/resources.proto (package google.cloud.managedkafka.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_field_behavior } from "../../../api/field_behavior_pb";
import { file_google_api_resource } from "../../../api/resource_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/cloud/managedkafka/v1/resources.proto.
 */
export const file_google_cloud_managedkafka_v1_resources: GenFile = /*@__PURE__*/
  fileDesc("Cixnb29nbGUvY2xvdWQvbWFuYWdlZGthZmthL3YxL3Jlc291cmNlcy5wcm90bxIcZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MSLyBQoHQ2x1c3RlchJCCgpnY3BfY29uZmlnGAkgASgLMicuZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MS5HY3BDb25maWdCA+BBAkgAEhEKBG5hbWUYASABKAlCA+BBCBI0CgtjcmVhdGVfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxI0Cgt1cGRhdGVfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxJGCgZsYWJlbHMYBCADKAsyMS5nb29nbGUuY2xvdWQubWFuYWdlZGthZmthLnYxLkNsdXN0ZXIuTGFiZWxzRW50cnlCA+BBARJKCg9jYXBhY2l0eV9jb25maWcYBSABKAsyLC5nb29nbGUuY2xvdWQubWFuYWdlZGthZmthLnYxLkNhcGFjaXR5Q29uZmlnQgPgQQISTAoQcmViYWxhbmNlX2NvbmZpZxgIIAEoCzItLmdvb2dsZS5jbG91ZC5tYW5hZ2Vka2Fma2EudjEuUmViYWxhbmNlQ29uZmlnQgPgQQESPwoFc3RhdGUYCiABKA4yKy5nb29nbGUuY2xvdWQubWFuYWdlZGthZmthLnYxLkNsdXN0ZXIuU3RhdGVCA+BBAxotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkYKBVN0YXRlEhUKEVNUQVRFX1VOU1BFQ0lGSUVEEAASDAoIQ1JFQVRJTkcQARIKCgZBQ1RJVkUQAhIMCghERUxFVElORxADOnfqQXQKI21hbmFnZWRrYWZrYS5nb29nbGVhcGlzLmNvbS9DbHVzdGVyEjpwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3tsb2NhdGlvbn0vY2x1c3RlcnMve2NsdXN0ZXJ9KghjbHVzdGVyczIHY2x1c3RlckIRCg9wbGF0Zm9ybV9jb25maWciRAoOQ2FwYWNpdHlDb25maWcSFwoKdmNwdV9jb3VudBgBIAEoA0ID4EECEhkKDG1lbW9yeV9ieXRlcxgCIAEoA0ID4EECIqgBCg9SZWJhbGFuY2VDb25maWcSRQoEbW9kZRgBIAEoDjIyLmdvb2dsZS5jbG91ZC5tYW5hZ2Vka2Fma2EudjEuUmViYWxhbmNlQ29uZmlnLk1vZGVCA+BBASJOCgRNb2RlEhQKEE1PREVfVU5TUEVDSUZJRUQQABIQCgxOT19SRUJBTEFOQ0UQARIeChpBVVRPX1JFQkFMQU5DRV9PTl9TQ0FMRV9VUBACIiQKDU5ldHdvcmtDb25maWcSEwoGc3VibmV0GAIgASgJQgPgQQIiWQoMQWNjZXNzQ29uZmlnEkkKD25ldHdvcmtfY29uZmlncxgBIAMoCzIrLmdvb2dsZS5jbG91ZC5tYW5hZ2Vka2Fma2EudjEuTmV0d29ya0NvbmZpZ0ID4EECIpIBCglHY3BDb25maWcSRgoNYWNjZXNzX2NvbmZpZxgDIAEoCzIqLmdvb2dsZS5jbG91ZC5tYW5hZ2Vka2Fma2EudjEuQWNjZXNzQ29uZmlnQgPgQQISPQoHa21zX2tleRgCIAEoCUIs4EEB4EEF+kEjCiFjbG91ZGttcy5nb29nbGVhcGlzLmNvbS9DcnlwdG9LZXki1wIKBVRvcGljEhEKBG5hbWUYASABKAlCA+BBCBIcCg9wYXJ0aXRpb25fY291bnQYAiABKAVCA+BBAhIiChJyZXBsaWNhdGlvbl9mYWN0b3IYAyABKAVCBuBBAuBBBRJGCgdjb25maWdzGAQgAygLMjAuZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MS5Ub3BpYy5Db25maWdzRW50cnlCA+BBARouCgxDb25maWdzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ATqAAepBfQohbWFuYWdlZGthZmthLmdvb2dsZWFwaXMuY29tL1RvcGljEklwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3tsb2NhdGlvbn0vY2x1c3RlcnMve2NsdXN0ZXJ9L3RvcGljcy97dG9waWN9KgZ0b3BpY3MyBXRvcGljIuEBChVDb25zdW1lclRvcGljTWV0YWRhdGESXAoKcGFydGl0aW9ucxgBIAMoCzJDLmdvb2dsZS5jbG91ZC5tYW5hZ2Vka2Fma2EudjEuQ29uc3VtZXJUb3BpY01ldGFkYXRhLlBhcnRpdGlvbnNFbnRyeUID4EEBGmoKD1BhcnRpdGlvbnNFbnRyeRILCgNrZXkYASABKAUSRgoFdmFsdWUYAiABKAsyNy5nb29nbGUuY2xvdWQubWFuYWdlZGthZmthLnYxLkNvbnN1bWVyUGFydGl0aW9uTWV0YWRhdGE6AjgBIkcKGUNvbnN1bWVyUGFydGl0aW9uTWV0YWRhdGESEwoGb2Zmc2V0GAEgASgDQgPgQQISFQoIbWV0YWRhdGEYAiABKAlCA+BBASKBAwoNQ29uc3VtZXJHcm91cBIRCgRuYW1lGAEgASgJQgPgQQgSTAoGdG9waWNzGAIgAygLMjcuZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MS5Db25zdW1lckdyb3VwLlRvcGljc0VudHJ5QgPgQQEaYgoLVG9waWNzRW50cnkSCwoDa2V5GAEgASgJEkIKBXZhbHVlGAIgASgLMjMuZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MS5Db25zdW1lclRvcGljTWV0YWRhdGE6AjgBOqoB6kGmAQopbWFuYWdlZGthZmthLmdvb2dsZWFwaXMuY29tL0NvbnN1bWVyR3JvdXASWnByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9jbHVzdGVycy97Y2x1c3Rlcn0vY29uc3VtZXJHcm91cHMve2NvbnN1bWVyX2dyb3VwfSoOY29uc3VtZXJHcm91cHMyDWNvbnN1bWVyR3JvdXAigAIKEU9wZXJhdGlvbk1ldGFkYXRhEjQKC2NyZWF0ZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEjEKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEDEhMKBnRhcmdldBgDIAEoCUID4EEDEhEKBHZlcmIYBCABKAlCA+BBAxIbCg5zdGF0dXNfbWVzc2FnZRgFIAEoCUID4EEDEiMKFnJlcXVlc3RlZF9jYW5jZWxsYXRpb24YBiABKAhCA+BBAxIYCgthcGlfdmVyc2lvbhgHIAEoCUID4EEDQtUCCiBjb20uZ29vZ2xlLmNsb3VkLm1hbmFnZWRrYWZrYS52MUIOUmVzb3VyY2VzUHJvdG9QAVpEY2xvdWQuZ29vZ2xlLmNvbS9nby9tYW5hZ2Vka2Fma2EvYXBpdjEvbWFuYWdlZGthZmthcGI7bWFuYWdlZGthZmthcGKqAhxHb29nbGUuQ2xvdWQuTWFuYWdlZEthZmthLlYxygIcR29vZ2xlXENsb3VkXE1hbmFnZWRLYWZrYVxWMeoCH0dvb2dsZTo6Q2xvdWQ6Ok1hbmFnZWRLYWZrYTo6VjHqQXgKIWNsb3Vka21zLmdvb2dsZWFwaXMuY29tL0NyeXB0b0tleRJTcHJvamVjdHMve3Byb2plY3R9L2xvY2F0aW9ucy97bG9jYXRpb259L2tleVJpbmdzL3trZXlfcmluZ30vY3J5cHRvS2V5cy97Y3J5cHRvX2tleX1iBnByb3RvMw", [file_google_api_field_behavior, file_google_api_resource, file_google_protobuf_timestamp]);

/**
 * An Apache Kafka cluster deployed in a location.
 *
 * @generated from message google.cloud.managedkafka.v1.Cluster
 */
export type Cluster = Message<"google.cloud.managedkafka.v1.Cluster"> & {
  /**
   * Platform specific configuration properties for a Kafka cluster.
   *
   * @generated from oneof google.cloud.managedkafka.v1.Cluster.platform_config
   */
  platformConfig: {
    /**
     * Required. Configuration properties for a Kafka cluster deployed to Google
     * Cloud Platform.
     *
     * @generated from field: google.cloud.managedkafka.v1.GcpConfig gcp_config = 9;
     */
    value: GcpConfig;
    case: "gcpConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Identifier. The name of the cluster. Structured like:
   * projects/{project_number}/locations/{location}/clusters/{cluster_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output only. The time when the cluster was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time when the cluster was last updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;

  /**
   * Optional. Labels as key value pairs.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Required. Capacity configuration for the Kafka cluster.
   *
   * @generated from field: google.cloud.managedkafka.v1.CapacityConfig capacity_config = 5;
   */
  capacityConfig?: CapacityConfig;

  /**
   * Optional. Rebalance configuration for the Kafka cluster.
   *
   * @generated from field: google.cloud.managedkafka.v1.RebalanceConfig rebalance_config = 8;
   */
  rebalanceConfig?: RebalanceConfig;

  /**
   * Output only. The current state of the cluster.
   *
   * @generated from field: google.cloud.managedkafka.v1.Cluster.State state = 10;
   */
  state: Cluster_State;
};

/**
 * Describes the message google.cloud.managedkafka.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 0);

/**
 * The state of the cluster.
 *
 * @generated from enum google.cloud.managedkafka.v1.Cluster.State
 */
export enum Cluster_State {
  /**
   * A state was not specified.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The cluster is being created.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * The cluster is active.
   *
   * @generated from enum value: ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * The cluster is being deleted.
   *
   * @generated from enum value: DELETING = 3;
   */
  DELETING = 3,
}

/**
 * Describes the enum google.cloud.managedkafka.v1.Cluster.State.
 */
export const Cluster_StateSchema: GenEnum<Cluster_State> = /*@__PURE__*/
  enumDesc(file_google_cloud_managedkafka_v1_resources, 0, 0);

/**
 * A capacity configuration of a Kafka cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.CapacityConfig
 */
export type CapacityConfig = Message<"google.cloud.managedkafka.v1.CapacityConfig"> & {
  /**
   * Required. The number of vCPUs to provision for the cluster. Minimum: 3.
   *
   * @generated from field: int64 vcpu_count = 1;
   */
  vcpuCount: bigint;

  /**
   * Required. The memory to provision for the cluster in bytes.
   * The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8.
   * Minimum: 3221225472 (3 GiB).
   *
   * @generated from field: int64 memory_bytes = 2;
   */
  memoryBytes: bigint;
};

/**
 * Describes the message google.cloud.managedkafka.v1.CapacityConfig.
 * Use `create(CapacityConfigSchema)` to create a new message.
 */
export const CapacityConfigSchema: GenMessage<CapacityConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 1);

/**
 * Defines rebalancing behavior of a Kafka cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.RebalanceConfig
 */
export type RebalanceConfig = Message<"google.cloud.managedkafka.v1.RebalanceConfig"> & {
  /**
   * Optional. The rebalance behavior for the cluster.
   * When not specified, defaults to `NO_REBALANCE`.
   *
   * @generated from field: google.cloud.managedkafka.v1.RebalanceConfig.Mode mode = 1;
   */
  mode: RebalanceConfig_Mode;
};

/**
 * Describes the message google.cloud.managedkafka.v1.RebalanceConfig.
 * Use `create(RebalanceConfigSchema)` to create a new message.
 */
export const RebalanceConfigSchema: GenMessage<RebalanceConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 2);

/**
 * The partition rebalance mode for the cluster.
 *
 * @generated from enum google.cloud.managedkafka.v1.RebalanceConfig.Mode
 */
export enum RebalanceConfig_Mode {
  /**
   * A mode was not specified. Do not use.
   *
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  MODE_UNSPECIFIED = 0,

  /**
   * Do not rebalance automatically.
   *
   * @generated from enum value: NO_REBALANCE = 1;
   */
  NO_REBALANCE = 1,

  /**
   * Automatically rebalance topic partitions among brokers when the
   * cluster is scaled up.
   *
   * @generated from enum value: AUTO_REBALANCE_ON_SCALE_UP = 2;
   */
  AUTO_REBALANCE_ON_SCALE_UP = 2,
}

/**
 * Describes the enum google.cloud.managedkafka.v1.RebalanceConfig.Mode.
 */
export const RebalanceConfig_ModeSchema: GenEnum<RebalanceConfig_Mode> = /*@__PURE__*/
  enumDesc(file_google_cloud_managedkafka_v1_resources, 2, 0);

/**
 * The configuration of a Virtual Private Cloud (VPC) network that can access
 * the Kafka cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.NetworkConfig
 */
export type NetworkConfig = Message<"google.cloud.managedkafka.v1.NetworkConfig"> & {
  /**
   * Required. Name of the VPC subnet in which to create Private Service Connect
   * (PSC) endpoints for the Kafka brokers and bootstrap address. Structured
   * like: projects/{project}/regions/{region}/subnetworks/{subnet_id}
   *
   * The subnet must be located in the same region as the Kafka cluster. The
   * project may differ. Multiple subnets from the same parent network must not
   * be specified.
   *
   * The CIDR range of the subnet must be within the IPv4 address ranges for
   * private networks, as specified in RFC 1918.
   *
   * @generated from field: string subnet = 2;
   */
  subnet: string;
};

/**
 * Describes the message google.cloud.managedkafka.v1.NetworkConfig.
 * Use `create(NetworkConfigSchema)` to create a new message.
 */
export const NetworkConfigSchema: GenMessage<NetworkConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 3);

/**
 * The configuration of access to the Kafka cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.AccessConfig
 */
export type AccessConfig = Message<"google.cloud.managedkafka.v1.AccessConfig"> & {
  /**
   * Required. Virtual Private Cloud (VPC) networks that must be granted direct
   * access to the Kafka cluster. Minimum of 1 network is required. Maximum 10
   * networks can be specified.
   *
   * @generated from field: repeated google.cloud.managedkafka.v1.NetworkConfig network_configs = 1;
   */
  networkConfigs: NetworkConfig[];
};

/**
 * Describes the message google.cloud.managedkafka.v1.AccessConfig.
 * Use `create(AccessConfigSchema)` to create a new message.
 */
export const AccessConfigSchema: GenMessage<AccessConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 4);

/**
 * Configuration properties for a Kafka cluster deployed to Google Cloud
 * Platform.
 *
 * @generated from message google.cloud.managedkafka.v1.GcpConfig
 */
export type GcpConfig = Message<"google.cloud.managedkafka.v1.GcpConfig"> & {
  /**
   * Required. Access configuration for the Kafka cluster.
   *
   * @generated from field: google.cloud.managedkafka.v1.AccessConfig access_config = 3;
   */
  accessConfig?: AccessConfig;

  /**
   * Optional. Immutable. The Cloud KMS Key name to use for encryption. The key
   * must be located in the same region as the cluster and cannot be changed.
   * Structured like:
   * projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.
   *
   * @generated from field: string kms_key = 2;
   */
  kmsKey: string;
};

/**
 * Describes the message google.cloud.managedkafka.v1.GcpConfig.
 * Use `create(GcpConfigSchema)` to create a new message.
 */
export const GcpConfigSchema: GenMessage<GcpConfig> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 5);

/**
 * A Kafka topic in a given cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.Topic
 */
export type Topic = Message<"google.cloud.managedkafka.v1.Topic"> & {
  /**
   * Identifier. The name of the topic. The `topic` segment is used when
   * connecting directly to the cluster. Structured like:
   * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The number of partitions this topic has. The partition count can
   * only be increased, not decreased. Please note that if partitions are
   * increased for a topic that has a key, the partitioning logic or the
   * ordering of the messages will be affected.
   *
   * @generated from field: int32 partition_count = 2;
   */
  partitionCount: number;

  /**
   * Required. Immutable. The number of replicas of each partition. A
   * replication factor of 3 is recommended for high availability.
   *
   * @generated from field: int32 replication_factor = 3;
   */
  replicationFactor: number;

  /**
   * Optional. Configurations for the topic that are overridden from the cluster
   * defaults. The key of the map is a Kafka topic property name, for example:
   * `cleanup.policy`, `compression.type`.
   *
   * @generated from field: map<string, string> configs = 4;
   */
  configs: { [key: string]: string };
};

/**
 * Describes the message google.cloud.managedkafka.v1.Topic.
 * Use `create(TopicSchema)` to create a new message.
 */
export const TopicSchema: GenMessage<Topic> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 6);

/**
 * Metadata for a consumer group corresponding to a specific topic.
 *
 * @generated from message google.cloud.managedkafka.v1.ConsumerTopicMetadata
 */
export type ConsumerTopicMetadata = Message<"google.cloud.managedkafka.v1.ConsumerTopicMetadata"> & {
  /**
   * Optional. Metadata for this consumer group and topic for all partition
   * indexes it has metadata for.
   *
   * @generated from field: map<int32, google.cloud.managedkafka.v1.ConsumerPartitionMetadata> partitions = 1;
   */
  partitions: { [key: number]: ConsumerPartitionMetadata };
};

/**
 * Describes the message google.cloud.managedkafka.v1.ConsumerTopicMetadata.
 * Use `create(ConsumerTopicMetadataSchema)` to create a new message.
 */
export const ConsumerTopicMetadataSchema: GenMessage<ConsumerTopicMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 7);

/**
 * Metadata for a consumer group corresponding to a specific partition.
 *
 * @generated from message google.cloud.managedkafka.v1.ConsumerPartitionMetadata
 */
export type ConsumerPartitionMetadata = Message<"google.cloud.managedkafka.v1.ConsumerPartitionMetadata"> & {
  /**
   * Required. The current offset for this partition, or 0 if no offset has been
   * committed.
   *
   * @generated from field: int64 offset = 1;
   */
  offset: bigint;

  /**
   * Optional. The associated metadata for this partition, or empty if it does
   * not exist.
   *
   * @generated from field: string metadata = 2;
   */
  metadata: string;
};

/**
 * Describes the message google.cloud.managedkafka.v1.ConsumerPartitionMetadata.
 * Use `create(ConsumerPartitionMetadataSchema)` to create a new message.
 */
export const ConsumerPartitionMetadataSchema: GenMessage<ConsumerPartitionMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 8);

/**
 * A Kafka consumer group in a given cluster.
 *
 * @generated from message google.cloud.managedkafka.v1.ConsumerGroup
 */
export type ConsumerGroup = Message<"google.cloud.managedkafka.v1.ConsumerGroup"> & {
  /**
   * Identifier. The name of the consumer group. The `consumer_group` segment is
   * used when connecting directly to the cluster. Structured like:
   * projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. Metadata for this consumer group for all topics it has metadata
   * for. The key of the map is a topic name, structured like:
   * projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}
   *
   * @generated from field: map<string, google.cloud.managedkafka.v1.ConsumerTopicMetadata> topics = 2;
   */
  topics: { [key: string]: ConsumerTopicMetadata };
};

/**
 * Describes the message google.cloud.managedkafka.v1.ConsumerGroup.
 * Use `create(ConsumerGroupSchema)` to create a new message.
 */
export const ConsumerGroupSchema: GenMessage<ConsumerGroup> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 9);

/**
 * Represents the metadata of the long-running operation.
 *
 * @generated from message google.cloud.managedkafka.v1.OperationMetadata
 */
export type OperationMetadata = Message<"google.cloud.managedkafka.v1.OperationMetadata"> & {
  /**
   * Output only. The time the operation was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 1;
   */
  createTime?: Timestamp;

  /**
   * Output only. The time the operation finished running.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Output only. Server-defined resource path for the target of the operation.
   *
   * @generated from field: string target = 3;
   */
  target: string;

  /**
   * Output only. Name of the verb executed by the operation.
   *
   * @generated from field: string verb = 4;
   */
  verb: string;

  /**
   * Output only. Human-readable status of the operation, if any.
   *
   * @generated from field: string status_message = 5;
   */
  statusMessage: string;

  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   *
   * @generated from field: bool requested_cancellation = 6;
   */
  requestedCancellation: boolean;

  /**
   * Output only. API version used to start the operation.
   *
   * @generated from field: string api_version = 7;
   */
  apiVersion: string;
};

/**
 * Describes the message google.cloud.managedkafka.v1.OperationMetadata.
 * Use `create(OperationMetadataSchema)` to create a new message.
 */
export const OperationMetadataSchema: GenMessage<OperationMetadata> = /*@__PURE__*/
  messageDesc(file_google_cloud_managedkafka_v1_resources, 10);

