// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file google/pubsub/v1/pubsub.proto (package google.pubsub.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../../api/annotations_pb";
import { file_google_api_client } from "../../api/client_pb";
import { file_google_api_field_behavior } from "../../api/field_behavior_pb";
import { file_google_api_resource } from "../../api/resource_pb";
import type { Duration, EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Encoding } from "./schema_pb";
import { file_google_pubsub_v1_schema } from "./schema_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file google/pubsub/v1/pubsub.proto.
 */
export const file_google_pubsub_v1_pubsub: GenFile = /*@__PURE__*/
  fileDesc("Ch1nb29nbGUvcHVic3ViL3YxL3B1YnN1Yi5wcm90bxIQZ29vZ2xlLnB1YnN1Yi52MSJhChRNZXNzYWdlU3RvcmFnZVBvbGljeRIoChthbGxvd2VkX3BlcnNpc3RlbmNlX3JlZ2lvbnMYASADKAlCA+BBARIfChJlbmZvcmNlX2luX3RyYW5zaXQYAiABKAhCA+BBASK4AQoOU2NoZW1hU2V0dGluZ3MSNAoGc2NoZW1hGAEgASgJQiTgQQL6QR4KHHB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TY2hlbWESMQoIZW5jb2RpbmcYAiABKA4yGi5nb29nbGUucHVic3ViLnYxLkVuY29kaW5nQgPgQQESHgoRZmlyc3RfcmV2aXNpb25faWQYAyABKAlCA+BBARIdChBsYXN0X3JldmlzaW9uX2lkGAQgASgJQgPgQQEiqQsKG0luZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5ncxJUCgthd3Nfa2luZXNpcxgBIAEoCzI4Lmdvb2dsZS5wdWJzdWIudjEuSW5nZXN0aW9uRGF0YVNvdXJjZVNldHRpbmdzLkF3c0tpbmVzaXNCA+BBAUgAElgKDWNsb3VkX3N0b3JhZ2UYAiABKAsyOi5nb29nbGUucHVic3ViLnYxLkluZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5ncy5DbG91ZFN0b3JhZ2VCA+BBAUgAEksKFnBsYXRmb3JtX2xvZ3Nfc2V0dGluZ3MYBCABKAsyJi5nb29nbGUucHVic3ViLnYxLlBsYXRmb3JtTG9nc1NldHRpbmdzQgPgQQEa6gIKCkF3c0tpbmVzaXMSUgoFc3RhdGUYASABKA4yPi5nb29nbGUucHVic3ViLnYxLkluZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5ncy5Bd3NLaW5lc2lzLlN0YXRlQgPgQQMSFwoKc3RyZWFtX2FybhgCIAEoCUID4EECEhkKDGNvbnN1bWVyX2FybhgDIAEoCUID4EECEhkKDGF3c19yb2xlX2FybhgEIAEoCUID4EECEiAKE2djcF9zZXJ2aWNlX2FjY291bnQYBSABKAlCA+BBAiKWAQoFU3RhdGUSFQoRU1RBVEVfVU5TUEVDSUZJRUQQABIKCgZBQ1RJVkUQARIdChlLSU5FU0lTX1BFUk1JU1NJT05fREVOSUVEEAISHQoZUFVCTElTSF9QRVJNSVNTSU9OX0RFTklFRBADEhQKEFNUUkVBTV9OT1RfRk9VTkQQBBIWChJDT05TVU1FUl9OT1RfRk9VTkQQBRqVBgoMQ2xvdWRTdG9yYWdlElQKBXN0YXRlGAEgASgOMkAuZ29vZ2xlLnB1YnN1Yi52MS5Jbmdlc3Rpb25EYXRhU291cmNlU2V0dGluZ3MuQ2xvdWRTdG9yYWdlLlN0YXRlQgPgQQMSEwoGYnVja2V0GAIgASgJQgPgQQESYQoLdGV4dF9mb3JtYXQYAyABKAsyRS5nb29nbGUucHVic3ViLnYxLkluZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5ncy5DbG91ZFN0b3JhZ2UuVGV4dEZvcm1hdEID4EEBSAASYQoLYXZyb19mb3JtYXQYBCABKAsyRS5nb29nbGUucHVic3ViLnYxLkluZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5ncy5DbG91ZFN0b3JhZ2UuQXZyb0Zvcm1hdEID4EEBSAASbgoScHVic3ViX2F2cm9fZm9ybWF0GAUgASgLMksuZ29vZ2xlLnB1YnN1Yi52MS5Jbmdlc3Rpb25EYXRhU291cmNlU2V0dGluZ3MuQ2xvdWRTdG9yYWdlLlB1YlN1YkF2cm9Gb3JtYXRCA+BBAUgAEkMKGm1pbmltdW1fb2JqZWN0X2NyZWF0ZV90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEBEhcKCm1hdGNoX2dsb2IYCSABKAlCA+BBARo3CgpUZXh0Rm9ybWF0EhsKCWRlbGltaXRlchgBIAEoCUID4EEBSACIAQFCDAoKX2RlbGltaXRlchoMCgpBdnJvRm9ybWF0GhIKEFB1YlN1YkF2cm9Gb3JtYXQimgEKBVN0YXRlEhUKEVNUQVRFX1VOU1BFQ0lGSUVEEAASCgoGQUNUSVZFEAESIwofQ0xPVURfU1RPUkFHRV9QRVJNSVNTSU9OX0RFTklFRBACEh0KGVBVQkxJU0hfUEVSTUlTU0lPTl9ERU5JRUQQAxIUChBCVUNLRVRfTk9UX0ZPVU5EEAQSFAoQVE9PX01BTllfT0JKRUNUUxAFQg4KDGlucHV0X2Zvcm1hdEIICgZzb3VyY2UivwEKFFBsYXRmb3JtTG9nc1NldHRpbmdzEkYKCHNldmVyaXR5GAEgASgOMi8uZ29vZ2xlLnB1YnN1Yi52MS5QbGF0Zm9ybUxvZ3NTZXR0aW5ncy5TZXZlcml0eUID4EEBIl8KCFNldmVyaXR5EhgKFFNFVkVSSVRZX1VOU1BFQ0lGSUVEEAASDAoIRElTQUJMRUQQARIJCgVERUJVRxACEggKBElORk8QAxILCgdXQVJOSU5HEAQSCQoFRVJST1IQBSK6BQoFVG9waWMSEQoEbmFtZRgBIAEoCUID4EECEjgKBmxhYmVscxgCIAMoCzIjLmdvb2dsZS5wdWJzdWIudjEuVG9waWMuTGFiZWxzRW50cnlCA+BBARJLChZtZXNzYWdlX3N0b3JhZ2VfcG9saWN5GAMgASgLMiYuZ29vZ2xlLnB1YnN1Yi52MS5NZXNzYWdlU3RvcmFnZVBvbGljeUID4EEBEhkKDGttc19rZXlfbmFtZRgFIAEoCUID4EEBEj4KD3NjaGVtYV9zZXR0aW5ncxgGIAEoCzIgLmdvb2dsZS5wdWJzdWIudjEuU2NoZW1hU2V0dGluZ3NCA+BBARIaCg1zYXRpc2ZpZXNfcHpzGAcgASgIQgPgQQESQgoabWVzc2FnZV9yZXRlbnRpb25fZHVyYXRpb24YCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBARIxCgVzdGF0ZRgJIAEoDjIdLmdvb2dsZS5wdWJzdWIudjEuVG9waWMuU3RhdGVCA+BBAxJaCh5pbmdlc3Rpb25fZGF0YV9zb3VyY2Vfc2V0dGluZ3MYCiABKAsyLS5nb29nbGUucHVic3ViLnYxLkluZ2VzdGlvbkRhdGFTb3VyY2VTZXR0aW5nc0ID4EEBGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiSAoFU3RhdGUSFQoRU1RBVEVfVU5TUEVDSUZJRUQQABIKCgZBQ1RJVkUQARIcChhJTkdFU1RJT05fUkVTT1VSQ0VfRVJST1IQAjpU6kFRChtwdWJzdWIuZ29vZ2xlYXBpcy5jb20vVG9waWMSIXByb2plY3RzL3twcm9qZWN0fS90b3BpY3Mve3RvcGljfRIPX2RlbGV0ZWQtdG9waWNfIoACCg1QdWJzdWJNZXNzYWdlEhEKBGRhdGEYASABKAxCA+BBARJICgphdHRyaWJ1dGVzGAIgAygLMi8uZ29vZ2xlLnB1YnN1Yi52MS5QdWJzdWJNZXNzYWdlLkF0dHJpYnV0ZXNFbnRyeUID4EEBEhIKCm1lc3NhZ2VfaWQYAyABKAkSMAoMcHVibGlzaF90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIZCgxvcmRlcmluZ19rZXkYBSABKAlCA+BBARoxCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJFCg9HZXRUb3BpY1JlcXVlc3QSMgoFdG9waWMYASABKAlCI+BBAvpBHQobcHVic3ViLmdvb2dsZWFwaXMuY29tL1RvcGljIncKElVwZGF0ZVRvcGljUmVxdWVzdBIrCgV0b3BpYxgBIAEoCzIXLmdvb2dsZS5wdWJzdWIudjEuVG9waWNCA+BBAhI0Cgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tCA+BBAiJ8Cg5QdWJsaXNoUmVxdWVzdBIyCgV0b3BpYxgBIAEoCUIj4EEC+kEdChtwdWJzdWIuZ29vZ2xlYXBpcy5jb20vVG9waWMSNgoIbWVzc2FnZXMYAiADKAsyHy5nb29nbGUucHVic3ViLnYxLlB1YnN1Yk1lc3NhZ2VCA+BBAiIrCg9QdWJsaXNoUmVzcG9uc2USGAoLbWVzc2FnZV9pZHMYASADKAlCA+BBASKKAQoRTGlzdFRvcGljc1JlcXVlc3QSRAoHcHJvamVjdBgBIAEoCUIz4EEC+kEtCitjbG91ZHJlc291cmNlbWFuYWdlci5nb29nbGVhcGlzLmNvbS9Qcm9qZWN0EhYKCXBhZ2Vfc2l6ZRgCIAEoBUID4EEBEhcKCnBhZ2VfdG9rZW4YAyABKAlCA+BBASJgChJMaXN0VG9waWNzUmVzcG9uc2USLAoGdG9waWNzGAEgAygLMhcuZ29vZ2xlLnB1YnN1Yi52MS5Ub3BpY0ID4EEBEhwKD25leHRfcGFnZV90b2tlbhgCIAEoCUID4EEBIoQBCh1MaXN0VG9waWNTdWJzY3JpcHRpb25zUmVxdWVzdBIyCgV0b3BpYxgBIAEoCUIj4EEC+kEdChtwdWJzdWIuZ29vZ2xlYXBpcy5jb20vVG9waWMSFgoJcGFnZV9zaXplGAIgASgFQgPgQQESFwoKcGFnZV90b2tlbhgDIAEoCUID4EEBIoEBCh5MaXN0VG9waWNTdWJzY3JpcHRpb25zUmVzcG9uc2USQQoNc3Vic2NyaXB0aW9ucxgBIAMoCUIq4EEB+kEkCiJwdWJzdWIuZ29vZ2xlYXBpcy5jb20vU3Vic2NyaXB0aW9uEhwKD25leHRfcGFnZV90b2tlbhgCIAEoCUID4EEBIoABChlMaXN0VG9waWNTbmFwc2hvdHNSZXF1ZXN0EjIKBXRvcGljGAEgASgJQiPgQQL6QR0KG3B1YnN1Yi5nb29nbGVhcGlzLmNvbS9Ub3BpYxIWCglwYWdlX3NpemUYAiABKAVCA+BBARIXCgpwYWdlX3Rva2VuGAMgASgJQgPgQQEiUgoaTGlzdFRvcGljU25hcHNob3RzUmVzcG9uc2USFgoJc25hcHNob3RzGAEgAygJQgPgQQESHAoPbmV4dF9wYWdlX3Rva2VuGAIgASgJQgPgQQEiSAoSRGVsZXRlVG9waWNSZXF1ZXN0EjIKBXRvcGljGAEgASgJQiPgQQL6QR0KG3B1YnN1Yi5nb29nbGVhcGlzLmNvbS9Ub3BpYyJdChlEZXRhY2hTdWJzY3JpcHRpb25SZXF1ZXN0EkAKDHN1YnNjcmlwdGlvbhgBIAEoCUIq4EEC+kEkCiJwdWJzdWIuZ29vZ2xlYXBpcy5jb20vU3Vic2NyaXB0aW9uIhwKGkRldGFjaFN1YnNjcmlwdGlvblJlc3BvbnNlIqsKCgxTdWJzY3JpcHRpb24SEQoEbmFtZRgBIAEoCUID4EECEjIKBXRvcGljGAIgASgJQiPgQQL6QR0KG3B1YnN1Yi5nb29nbGVhcGlzLmNvbS9Ub3BpYxI2CgtwdXNoX2NvbmZpZxgEIAEoCzIcLmdvb2dsZS5wdWJzdWIudjEuUHVzaENvbmZpZ0ID4EEBEj4KD2JpZ3F1ZXJ5X2NvbmZpZxgSIAEoCzIgLmdvb2dsZS5wdWJzdWIudjEuQmlnUXVlcnlDb25maWdCA+BBARJHChRjbG91ZF9zdG9yYWdlX2NvbmZpZxgWIAEoCzIkLmdvb2dsZS5wdWJzdWIudjEuQ2xvdWRTdG9yYWdlQ29uZmlnQgPgQQESIQoUYWNrX2RlYWRsaW5lX3NlY29uZHMYBSABKAVCA+BBARIiChVyZXRhaW5fYWNrZWRfbWVzc2FnZXMYByABKAhCA+BBARJCChptZXNzYWdlX3JldGVudGlvbl9kdXJhdGlvbhgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBEj8KBmxhYmVscxgJIAMoCzIqLmdvb2dsZS5wdWJzdWIudjEuU3Vic2NyaXB0aW9uLkxhYmVsc0VudHJ5QgPgQQESJAoXZW5hYmxlX21lc3NhZ2Vfb3JkZXJpbmcYCiABKAhCA+BBARJCChFleHBpcmF0aW9uX3BvbGljeRgLIAEoCzIiLmdvb2dsZS5wdWJzdWIudjEuRXhwaXJhdGlvblBvbGljeUID4EEBEhMKBmZpbHRlchgMIAEoCUID4EEBEkMKEmRlYWRfbGV0dGVyX3BvbGljeRgNIAEoCzIiLmdvb2dsZS5wdWJzdWIudjEuRGVhZExldHRlclBvbGljeUID4EEBEjgKDHJldHJ5X3BvbGljeRgOIAEoCzIdLmdvb2dsZS5wdWJzdWIudjEuUmV0cnlQb2xpY3lCA+BBARIVCghkZXRhY2hlZBgPIAEoCEID4EEBEikKHGVuYWJsZV9leGFjdGx5X29uY2VfZGVsaXZlcnkYECABKAhCA+BBARJICiB0b3BpY19tZXNzYWdlX3JldGVudGlvbl9kdXJhdGlvbhgRIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEDEjgKBXN0YXRlGBMgASgOMiQuZ29vZ2xlLnB1YnN1Yi52MS5TdWJzY3JpcHRpb24uU3RhdGVCA+BBAxJpCh9hbmFseXRpY3NfaHViX3N1YnNjcmlwdGlvbl9pbmZvGBcgASgLMjsuZ29vZ2xlLnB1YnN1Yi52MS5TdWJzY3JpcHRpb24uQW5hbHl0aWNzSHViU3Vic2NyaXB0aW9uSW5mb0ID4EEDGk8KHEFuYWx5dGljc0h1YlN1YnNjcmlwdGlvbkluZm8SFAoHbGlzdGluZxgBIAEoCUID4EEBEhkKDHN1YnNjcmlwdGlvbhgCIAEoCUID4EEBGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiPgoFU3RhdGUSFQoRU1RBVEVfVU5TUEVDSUZJRUQQABIKCgZBQ1RJVkUQARISCg5SRVNPVVJDRV9FUlJPUhACOljqQVUKInB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TdWJzY3JpcHRpb24SL3Byb2plY3RzL3twcm9qZWN0fS9zdWJzY3JpcHRpb25zL3tzdWJzY3JpcHRpb259In8KC1JldHJ5UG9saWN5EjcKD21pbmltdW1fYmFja29mZhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBEjcKD21heGltdW1fYmFja29mZhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBIlYKEERlYWRMZXR0ZXJQb2xpY3kSHgoRZGVhZF9sZXR0ZXJfdG9waWMYASABKAlCA+BBARIiChVtYXhfZGVsaXZlcnlfYXR0ZW1wdHMYAiABKAVCA+BBASI/ChBFeHBpcmF0aW9uUG9saWN5EisKA3R0bBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBIpoECgpQdXNoQ29uZmlnEhoKDXB1c2hfZW5kcG9pbnQYASABKAlCA+BBARJFCgphdHRyaWJ1dGVzGAIgAygLMiwuZ29vZ2xlLnB1YnN1Yi52MS5QdXNoQ29uZmlnLkF0dHJpYnV0ZXNFbnRyeUID4EEBEkEKCm9pZGNfdG9rZW4YAyABKAsyJi5nb29nbGUucHVic3ViLnYxLlB1c2hDb25maWcuT2lkY1Rva2VuQgPgQQFIABJJCg5wdWJzdWJfd3JhcHBlchgEIAEoCzIqLmdvb2dsZS5wdWJzdWIudjEuUHVzaENvbmZpZy5QdWJzdWJXcmFwcGVyQgPgQQFIARJBCgpub193cmFwcGVyGAUgASgLMiYuZ29vZ2xlLnB1YnN1Yi52MS5QdXNoQ29uZmlnLk5vV3JhcHBlckID4EEBSAEaRgoJT2lkY1Rva2VuEiIKFXNlcnZpY2VfYWNjb3VudF9lbWFpbBgBIAEoCUID4EEBEhUKCGF1ZGllbmNlGAIgASgJQgPgQQEaDwoNUHVic3ViV3JhcHBlchooCglOb1dyYXBwZXISGwoOd3JpdGVfbWV0YWRhdGEYASABKAhCA+BBARoxCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIXChVhdXRoZW50aWNhdGlvbl9tZXRob2RCCQoHd3JhcHBlciKOAwoOQmlnUXVlcnlDb25maWcSEgoFdGFibGUYASABKAlCA+BBARIdChB1c2VfdG9waWNfc2NoZW1hGAIgASgIQgPgQQESGwoOd3JpdGVfbWV0YWRhdGEYAyABKAhCA+BBARIgChNkcm9wX3Vua25vd25fZmllbGRzGAQgASgIQgPgQQESOgoFc3RhdGUYBSABKA4yJi5nb29nbGUucHVic3ViLnYxLkJpZ1F1ZXJ5Q29uZmlnLlN0YXRlQgPgQQMSHQoQdXNlX3RhYmxlX3NjaGVtYRgGIAEoCEID4EEBEiIKFXNlcnZpY2VfYWNjb3VudF9lbWFpbBgHIAEoCUID4EEBIooBCgVTdGF0ZRIVChFTVEFURV9VTlNQRUNJRklFRBAAEgoKBkFDVElWRRABEhUKEVBFUk1JU1NJT05fREVOSUVEEAISDQoJTk9UX0ZPVU5EEAMSEwoPU0NIRU1BX01JU01BVENIEAQSIwofSU5fVFJBTlNJVF9MT0NBVElPTl9SRVNUUklDVElPThAFIukFChJDbG91ZFN0b3JhZ2VDb25maWcSEwoGYnVja2V0GAEgASgJQgPgQQISHAoPZmlsZW5hbWVfcHJlZml4GAIgASgJQgPgQQESHAoPZmlsZW5hbWVfc3VmZml4GAMgASgJQgPgQQESJQoYZmlsZW5hbWVfZGF0ZXRpbWVfZm9ybWF0GAogASgJQgPgQQESSwoLdGV4dF9jb25maWcYBCABKAsyLy5nb29nbGUucHVic3ViLnYxLkNsb3VkU3RvcmFnZUNvbmZpZy5UZXh0Q29uZmlnQgPgQQFIABJLCgthdnJvX2NvbmZpZxgFIAEoCzIvLmdvb2dsZS5wdWJzdWIudjEuQ2xvdWRTdG9yYWdlQ29uZmlnLkF2cm9Db25maWdCA+BBAUgAEjQKDG1heF9kdXJhdGlvbhgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EEBEhYKCW1heF9ieXRlcxgHIAEoA0ID4EEBEhkKDG1heF9tZXNzYWdlcxgIIAEoA0ID4EEBEj4KBXN0YXRlGAkgASgOMiouZ29vZ2xlLnB1YnN1Yi52MS5DbG91ZFN0b3JhZ2VDb25maWcuU3RhdGVCA+BBAxIiChVzZXJ2aWNlX2FjY291bnRfZW1haWwYCyABKAlCA+BBARoMCgpUZXh0Q29uZmlnGkgKCkF2cm9Db25maWcSGwoOd3JpdGVfbWV0YWRhdGEYASABKAhCA+BBARIdChB1c2VfdG9waWNfc2NoZW1hGAIgASgIQgPgQQEiigEKBVN0YXRlEhUKEVNUQVRFX1VOU1BFQ0lGSUVEEAASCgoGQUNUSVZFEAESFQoRUEVSTUlTU0lPTl9ERU5JRUQQAhINCglOT1RfRk9VTkQQAxIjCh9JTl9UUkFOU0lUX0xPQ0FUSU9OX1JFU1RSSUNUSU9OEAQSEwoPU0NIRU1BX01JU01BVENIEAVCDwoNb3V0cHV0X2Zvcm1hdCJ8Cg9SZWNlaXZlZE1lc3NhZ2USEwoGYWNrX2lkGAEgASgJQgPgQQESNQoHbWVzc2FnZRgCIAEoCzIfLmdvb2dsZS5wdWJzdWIudjEuUHVic3ViTWVzc2FnZUID4EEBEh0KEGRlbGl2ZXJ5X2F0dGVtcHQYAyABKAVCA+BBASJaChZHZXRTdWJzY3JpcHRpb25SZXF1ZXN0EkAKDHN1YnNjcmlwdGlvbhgBIAEoCUIq4EEC+kEkCiJwdWJzdWIuZ29vZ2xlYXBpcy5jb20vU3Vic2NyaXB0aW9uIowBChlVcGRhdGVTdWJzY3JpcHRpb25SZXF1ZXN0EjkKDHN1YnNjcmlwdGlvbhgBIAEoCzIeLmdvb2dsZS5wdWJzdWIudjEuU3Vic2NyaXB0aW9uQgPgQQISNAoLdXBkYXRlX21hc2sYAiABKAsyGi5nb29nbGUucHJvdG9idWYuRmllbGRNYXNrQgPgQQIikQEKGExpc3RTdWJzY3JpcHRpb25zUmVxdWVzdBJECgdwcm9qZWN0GAEgASgJQjPgQQL6QS0KK2Nsb3VkcmVzb3VyY2VtYW5hZ2VyLmdvb2dsZWFwaXMuY29tL1Byb2plY3QSFgoJcGFnZV9zaXplGAIgASgFQgPgQQESFwoKcGFnZV90b2tlbhgDIAEoCUID4EEBInUKGUxpc3RTdWJzY3JpcHRpb25zUmVzcG9uc2USOgoNc3Vic2NyaXB0aW9ucxgBIAMoCzIeLmdvb2dsZS5wdWJzdWIudjEuU3Vic2NyaXB0aW9uQgPgQQESHAoPbmV4dF9wYWdlX3Rva2VuGAIgASgJQgPgQQEiXQoZRGVsZXRlU3Vic2NyaXB0aW9uUmVxdWVzdBJACgxzdWJzY3JpcHRpb24YASABKAlCKuBBAvpBJAoicHVic3ViLmdvb2dsZWFwaXMuY29tL1N1YnNjcmlwdGlvbiKTAQoXTW9kaWZ5UHVzaENvbmZpZ1JlcXVlc3QSQAoMc3Vic2NyaXB0aW9uGAEgASgJQirgQQL6QSQKInB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TdWJzY3JpcHRpb24SNgoLcHVzaF9jb25maWcYAiABKAsyHC5nb29nbGUucHVic3ViLnYxLlB1c2hDb25maWdCA+BBAiKNAQoLUHVsbFJlcXVlc3QSQAoMc3Vic2NyaXB0aW9uGAEgASgJQirgQQL6QSQKInB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TdWJzY3JpcHRpb24SIQoScmV0dXJuX2ltbWVkaWF0ZWx5GAIgASgIQgUYAeBBARIZCgxtYXhfbWVzc2FnZXMYAyABKAVCA+BBAiJRCgxQdWxsUmVzcG9uc2USQQoRcmVjZWl2ZWRfbWVzc2FnZXMYASADKAsyIS5nb29nbGUucHVic3ViLnYxLlJlY2VpdmVkTWVzc2FnZUID4EEBIpUBChhNb2RpZnlBY2tEZWFkbGluZVJlcXVlc3QSQAoMc3Vic2NyaXB0aW9uGAEgASgJQirgQQL6QSQKInB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TdWJzY3JpcHRpb24SFAoHYWNrX2lkcxgEIAMoCUID4EECEiEKFGFja19kZWFkbGluZV9zZWNvbmRzGAMgASgFQgPgQQIibAoSQWNrbm93bGVkZ2VSZXF1ZXN0EkAKDHN1YnNjcmlwdGlvbhgBIAEoCUIq4EEC+kEkCiJwdWJzdWIuZ29vZ2xlYXBpcy5jb20vU3Vic2NyaXB0aW9uEhQKB2Fja19pZHMYAiADKAlCA+BBAiLHAgoUU3RyZWFtaW5nUHVsbFJlcXVlc3QSQAoMc3Vic2NyaXB0aW9uGAEgASgJQirgQQL6QSQKInB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TdWJzY3JpcHRpb24SFAoHYWNrX2lkcxgCIAMoCUID4EEBEiQKF21vZGlmeV9kZWFkbGluZV9zZWNvbmRzGAMgAygFQgPgQQESJAoXbW9kaWZ5X2RlYWRsaW5lX2Fja19pZHMYBCADKAlCA+BBARIoChtzdHJlYW1fYWNrX2RlYWRsaW5lX3NlY29uZHMYBSABKAVCA+BBAhIWCgljbGllbnRfaWQYBiABKAlCA+BBARIlChhtYXhfb3V0c3RhbmRpbmdfbWVzc2FnZXMYByABKANCA+BBARIiChVtYXhfb3V0c3RhbmRpbmdfYnl0ZXMYCCABKANCA+BBASKeBgoVU3RyZWFtaW5nUHVsbFJlc3BvbnNlEkEKEXJlY2VpdmVkX21lc3NhZ2VzGAEgAygLMiEuZ29vZ2xlLnB1YnN1Yi52MS5SZWNlaXZlZE1lc3NhZ2VCA+BBARJmChhhY2tub3dsZWRnZV9jb25maXJtYXRpb24YBSABKAsyPy5nb29nbGUucHVic3ViLnYxLlN0cmVhbWluZ1B1bGxSZXNwb25zZS5BY2tub3dsZWRnZUNvbmZpcm1hdGlvbkID4EEBEnQKIG1vZGlmeV9hY2tfZGVhZGxpbmVfY29uZmlybWF0aW9uGAMgASgLMkUuZ29vZ2xlLnB1YnN1Yi52MS5TdHJlYW1pbmdQdWxsUmVzcG9uc2UuTW9kaWZ5QWNrRGVhZGxpbmVDb25maXJtYXRpb25CA+BBARJkChdzdWJzY3JpcHRpb25fcHJvcGVydGllcxgEIAEoCzI+Lmdvb2dsZS5wdWJzdWIudjEuU3RyZWFtaW5nUHVsbFJlc3BvbnNlLlN1YnNjcmlwdGlvblByb3BlcnRpZXNCA+BBARqUAQoXQWNrbm93bGVkZ2VDb25maXJtYXRpb24SFAoHYWNrX2lkcxgBIAMoCUID4EEBEhwKD2ludmFsaWRfYWNrX2lkcxgCIAMoCUID4EEBEh4KEXVub3JkZXJlZF9hY2tfaWRzGAMgAygJQgPgQQESJQoYdGVtcG9yYXJ5X2ZhaWxlZF9hY2tfaWRzGAQgAygJQgPgQQEaegodTW9kaWZ5QWNrRGVhZGxpbmVDb25maXJtYXRpb24SFAoHYWNrX2lkcxgBIAMoCUID4EEBEhwKD2ludmFsaWRfYWNrX2lkcxgCIAMoCUID4EEBEiUKGHRlbXBvcmFyeV9mYWlsZWRfYWNrX2lkcxgDIAMoCUID4EEBGmsKFlN1YnNjcmlwdGlvblByb3BlcnRpZXMSKgodZXhhY3RseV9vbmNlX2RlbGl2ZXJ5X2VuYWJsZWQYASABKAhCA+BBARIlChhtZXNzYWdlX29yZGVyaW5nX2VuYWJsZWQYAiABKAhCA+BBASKIAgoVQ3JlYXRlU25hcHNob3RSZXF1ZXN0EjQKBG5hbWUYASABKAlCJuBBAvpBIAoecHVic3ViLmdvb2dsZWFwaXMuY29tL1NuYXBzaG90EkAKDHN1YnNjcmlwdGlvbhgCIAEoCUIq4EEC+kEkCiJwdWJzdWIuZ29vZ2xlYXBpcy5jb20vU3Vic2NyaXB0aW9uEkgKBmxhYmVscxgDIAMoCzIzLmdvb2dsZS5wdWJzdWIudjEuQ3JlYXRlU25hcHNob3RSZXF1ZXN0LkxhYmVsc0VudHJ5QgPgQQEaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKAAQoVVXBkYXRlU25hcHNob3RSZXF1ZXN0EjEKCHNuYXBzaG90GAEgASgLMhouZ29vZ2xlLnB1YnN1Yi52MS5TbmFwc2hvdEID4EECEjQKC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFza0ID4EECIsECCghTbmFwc2hvdBIRCgRuYW1lGAEgASgJQgPgQQESMgoFdG9waWMYAiABKAlCI+BBAfpBHQobcHVic3ViLmdvb2dsZWFwaXMuY29tL1RvcGljEjQKC2V4cGlyZV90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEBEjsKBmxhYmVscxgEIAMoCzImLmdvb2dsZS5wdWJzdWIudjEuU25hcHNob3QuTGFiZWxzRW50cnlCA+BBARotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBOkzqQUkKHnB1YnN1Yi5nb29nbGVhcGlzLmNvbS9TbmFwc2hvdBIncHJvamVjdHMve3Byb2plY3R9L3NuYXBzaG90cy97c25hcHNob3R9Ik4KEkdldFNuYXBzaG90UmVxdWVzdBI4CghzbmFwc2hvdBgBIAEoCUIm4EEC+kEgCh5wdWJzdWIuZ29vZ2xlYXBpcy5jb20vU25hcHNob3QijQEKFExpc3RTbmFwc2hvdHNSZXF1ZXN0EkQKB3Byb2plY3QYASABKAlCM+BBAvpBLQorY2xvdWRyZXNvdXJjZW1hbmFnZXIuZ29vZ2xlYXBpcy5jb20vUHJvamVjdBIWCglwYWdlX3NpemUYAiABKAVCA+BBARIXCgpwYWdlX3Rva2VuGAMgASgJQgPgQQEiaQoVTGlzdFNuYXBzaG90c1Jlc3BvbnNlEjIKCXNuYXBzaG90cxgBIAMoCzIaLmdvb2dsZS5wdWJzdWIudjEuU25hcHNob3RCA+BBARIcCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAlCA+BBASJRChVEZWxldGVTbmFwc2hvdFJlcXVlc3QSOAoIc25hcHNob3QYASABKAlCJuBBAvpBIAoecHVic3ViLmdvb2dsZWFwaXMuY29tL1NuYXBzaG90IsYBCgtTZWVrUmVxdWVzdBJACgxzdWJzY3JpcHRpb24YASABKAlCKuBBAvpBJAoicHVic3ViLmdvb2dsZWFwaXMuY29tL1N1YnNjcmlwdGlvbhIvCgR0aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEID4EEBSAASOgoIc25hcHNob3QYAyABKAlCJuBBAfpBIAoecHVic3ViLmdvb2dsZWFwaXMuY29tL1NuYXBzaG90SABCCAoGdGFyZ2V0Ig4KDFNlZWtSZXNwb25zZTK4CwoJUHVibGlzaGVyEnEKC0NyZWF0ZVRvcGljEhcuZ29vZ2xlLnB1YnN1Yi52MS5Ub3BpYxoXLmdvb2dsZS5wdWJzdWIudjEuVG9waWMiMNpBBG5hbWWC0+STAiM6ASoaHi92MS97bmFtZT1wcm9qZWN0cy8qL3RvcGljcy8qfRKRAQoLVXBkYXRlVG9waWMSJC5nb29nbGUucHVic3ViLnYxLlVwZGF0ZVRvcGljUmVxdWVzdBoXLmdvb2dsZS5wdWJzdWIudjEuVG9waWMiQ9pBEXRvcGljLHVwZGF0ZV9tYXNrgtPkkwIpOgEqMiQvdjEve3RvcGljLm5hbWU9cHJvamVjdHMvKi90b3BpY3MvKn0SkwEKB1B1Ymxpc2gSIC5nb29nbGUucHVic3ViLnYxLlB1Ymxpc2hSZXF1ZXN0GiEuZ29vZ2xlLnB1YnN1Yi52MS5QdWJsaXNoUmVzcG9uc2UiQ9pBDnRvcGljLG1lc3NhZ2VzgtPkkwIsOgEqIicvdjEve3RvcGljPXByb2plY3RzLyovdG9waWNzLyp9OnB1Ymxpc2gSdwoIR2V0VG9waWMSIS5nb29nbGUucHVic3ViLnYxLkdldFRvcGljUmVxdWVzdBoXLmdvb2dsZS5wdWJzdWIudjEuVG9waWMiL9pBBXRvcGljgtPkkwIhEh8vdjEve3RvcGljPXByb2plY3RzLyovdG9waWNzLyp9EooBCgpMaXN0VG9waWNzEiMuZ29vZ2xlLnB1YnN1Yi52MS5MaXN0VG9waWNzUmVxdWVzdBokLmdvb2dsZS5wdWJzdWIudjEuTGlzdFRvcGljc1Jlc3BvbnNlIjHaQQdwcm9qZWN0gtPkkwIhEh8vdjEve3Byb2plY3Q9cHJvamVjdHMvKn0vdG9waWNzEroBChZMaXN0VG9waWNTdWJzY3JpcHRpb25zEi8uZ29vZ2xlLnB1YnN1Yi52MS5MaXN0VG9waWNTdWJzY3JpcHRpb25zUmVxdWVzdBowLmdvb2dsZS5wdWJzdWIudjEuTGlzdFRvcGljU3Vic2NyaXB0aW9uc1Jlc3BvbnNlIj3aQQV0b3BpY4LT5JMCLxItL3YxL3t0b3BpYz1wcm9qZWN0cy8qL3RvcGljcy8qfS9zdWJzY3JpcHRpb25zEqoBChJMaXN0VG9waWNTbmFwc2hvdHMSKy5nb29nbGUucHVic3ViLnYxLkxpc3RUb3BpY1NuYXBzaG90c1JlcXVlc3QaLC5nb29nbGUucHVic3ViLnYxLkxpc3RUb3BpY1NuYXBzaG90c1Jlc3BvbnNlIjnaQQV0b3BpY4LT5JMCKxIpL3YxL3t0b3BpYz1wcm9qZWN0cy8qL3RvcGljcy8qfS9zbmFwc2hvdHMSfAoLRGVsZXRlVG9waWMSJC5nb29nbGUucHVic3ViLnYxLkRlbGV0ZVRvcGljUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIv2kEFdG9waWOC0+STAiEqHy92MS97dG9waWM9cHJvamVjdHMvKi90b3BpY3MvKn0SrQEKEkRldGFjaFN1YnNjcmlwdGlvbhIrLmdvb2dsZS5wdWJzdWIudjEuRGV0YWNoU3Vic2NyaXB0aW9uUmVxdWVzdBosLmdvb2dsZS5wdWJzdWIudjEuRGV0YWNoU3Vic2NyaXB0aW9uUmVzcG9uc2UiPILT5JMCNiI0L3YxL3tzdWJzY3JpcHRpb249cHJvamVjdHMvKi9zdWJzY3JpcHRpb25zLyp9OmRldGFjaBpwykEVcHVic3ViLmdvb2dsZWFwaXMuY29t0kFVaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybSxodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3B1YnN1YjLSFQoKU3Vic2NyaWJlchK0AQoSQ3JlYXRlU3Vic2NyaXB0aW9uEh4uZ29vZ2xlLnB1YnN1Yi52MS5TdWJzY3JpcHRpb24aHi5nb29nbGUucHVic3ViLnYxLlN1YnNjcmlwdGlvbiJe2kErbmFtZSx0b3BpYyxwdXNoX2NvbmZpZyxhY2tfZGVhZGxpbmVfc2Vjb25kc4LT5JMCKjoBKholL3YxL3tuYW1lPXByb2plY3RzLyovc3Vic2NyaXB0aW9ucy8qfRKhAQoPR2V0U3Vic2NyaXB0aW9uEiguZ29vZ2xlLnB1YnN1Yi52MS5HZXRTdWJzY3JpcHRpb25SZXF1ZXN0Gh4uZ29vZ2xlLnB1YnN1Yi52MS5TdWJzY3JpcHRpb24iRNpBDHN1YnNjcmlwdGlvboLT5JMCLxItL3YxL3tzdWJzY3JpcHRpb249cHJvamVjdHMvKi9zdWJzY3JpcHRpb25zLyp9ErsBChJVcGRhdGVTdWJzY3JpcHRpb24SKy5nb29nbGUucHVic3ViLnYxLlVwZGF0ZVN1YnNjcmlwdGlvblJlcXVlc3QaHi5nb29nbGUucHVic3ViLnYxLlN1YnNjcmlwdGlvbiJY2kEYc3Vic2NyaXB0aW9uLHVwZGF0ZV9tYXNrgtPkkwI3OgEqMjIvdjEve3N1YnNjcmlwdGlvbi5uYW1lPXByb2plY3RzLyovc3Vic2NyaXB0aW9ucy8qfRKmAQoRTGlzdFN1YnNjcmlwdGlvbnMSKi5nb29nbGUucHVic3ViLnYxLkxpc3RTdWJzY3JpcHRpb25zUmVxdWVzdBorLmdvb2dsZS5wdWJzdWIudjEuTGlzdFN1YnNjcmlwdGlvbnNSZXNwb25zZSI42kEHcHJvamVjdILT5JMCKBImL3YxL3twcm9qZWN0PXByb2plY3RzLyp9L3N1YnNjcmlwdGlvbnMSnwEKEkRlbGV0ZVN1YnNjcmlwdGlvbhIrLmdvb2dsZS5wdWJzdWIudjEuRGVsZXRlU3Vic2NyaXB0aW9uUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSJE2kEMc3Vic2NyaXB0aW9ugtPkkwIvKi0vdjEve3N1YnNjcmlwdGlvbj1wcm9qZWN0cy8qL3N1YnNjcmlwdGlvbnMvKn0SzwEKEU1vZGlmeUFja0RlYWRsaW5lEiouZ29vZ2xlLnB1YnN1Yi52MS5Nb2RpZnlBY2tEZWFkbGluZVJlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkidtpBKXN1YnNjcmlwdGlvbixhY2tfaWRzLGFja19kZWFkbGluZV9zZWNvbmRzgtPkkwJEOgEqIj8vdjEve3N1YnNjcmlwdGlvbj1wcm9qZWN0cy8qL3N1YnNjcmlwdGlvbnMvKn06bW9kaWZ5QWNrRGVhZGxpbmUSqAEKC0Fja25vd2xlZGdlEiQuZ29vZ2xlLnB1YnN1Yi52MS5BY2tub3dsZWRnZVJlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiW9pBFHN1YnNjcmlwdGlvbixhY2tfaWRzgtPkkwI+OgEqIjkvdjEve3N1YnNjcmlwdGlvbj1wcm9qZWN0cy8qL3N1YnNjcmlwdGlvbnMvKn06YWNrbm93bGVkZ2US0AEKBFB1bGwSHS5nb29nbGUucHVic3ViLnYxLlB1bGxSZXF1ZXN0Gh4uZ29vZ2xlLnB1YnN1Yi52MS5QdWxsUmVzcG9uc2UiiAHaQSxzdWJzY3JpcHRpb24scmV0dXJuX2ltbWVkaWF0ZWx5LG1heF9tZXNzYWdlc9pBGXN1YnNjcmlwdGlvbixtYXhfbWVzc2FnZXOC0+STAjc6ASoiMi92MS97c3Vic2NyaXB0aW9uPXByb2plY3RzLyovc3Vic2NyaXB0aW9ucy8qfTpwdWxsEmYKDVN0cmVhbWluZ1B1bGwSJi5nb29nbGUucHVic3ViLnYxLlN0cmVhbWluZ1B1bGxSZXF1ZXN0GicuZ29vZ2xlLnB1YnN1Yi52MS5TdHJlYW1pbmdQdWxsUmVzcG9uc2UiACgBMAESuwEKEE1vZGlmeVB1c2hDb25maWcSKS5nb29nbGUucHVic3ViLnYxLk1vZGlmeVB1c2hDb25maWdSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5ImTaQRhzdWJzY3JpcHRpb24scHVzaF9jb25maWeC0+STAkM6ASoiPi92MS97c3Vic2NyaXB0aW9uPXByb2plY3RzLyovc3Vic2NyaXB0aW9ucy8qfTptb2RpZnlQdXNoQ29uZmlnEokBCgtHZXRTbmFwc2hvdBIkLmdvb2dsZS5wdWJzdWIudjEuR2V0U25hcHNob3RSZXF1ZXN0GhouZ29vZ2xlLnB1YnN1Yi52MS5TbmFwc2hvdCI42kEIc25hcHNob3SC0+STAicSJS92MS97c25hcHNob3Q9cHJvamVjdHMvKi9zbmFwc2hvdHMvKn0SlgEKDUxpc3RTbmFwc2hvdHMSJi5nb29nbGUucHVic3ViLnYxLkxpc3RTbmFwc2hvdHNSZXF1ZXN0GicuZ29vZ2xlLnB1YnN1Yi52MS5MaXN0U25hcHNob3RzUmVzcG9uc2UiNNpBB3Byb2plY3SC0+STAiQSIi92MS97cHJvamVjdD1wcm9qZWN0cy8qfS9zbmFwc2hvdHMSlwEKDkNyZWF0ZVNuYXBzaG90EicuZ29vZ2xlLnB1YnN1Yi52MS5DcmVhdGVTbmFwc2hvdFJlcXVlc3QaGi5nb29nbGUucHVic3ViLnYxLlNuYXBzaG90IkDaQRFuYW1lLHN1YnNjcmlwdGlvboLT5JMCJjoBKhohL3YxL3tuYW1lPXByb2plY3RzLyovc25hcHNob3RzLyp9EqMBCg5VcGRhdGVTbmFwc2hvdBInLmdvb2dsZS5wdWJzdWIudjEuVXBkYXRlU25hcHNob3RSZXF1ZXN0GhouZ29vZ2xlLnB1YnN1Yi52MS5TbmFwc2hvdCJM2kEUc25hcHNob3QsdXBkYXRlX21hc2uC0+STAi86ASoyKi92MS97c25hcHNob3QubmFtZT1wcm9qZWN0cy8qL3NuYXBzaG90cy8qfRKLAQoORGVsZXRlU25hcHNob3QSJy5nb29nbGUucHVic3ViLnYxLkRlbGV0ZVNuYXBzaG90UmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSI42kEIc25hcHNob3SC0+STAicqJS92MS97c25hcHNob3Q9cHJvamVjdHMvKi9zbmFwc2hvdHMvKn0ShAEKBFNlZWsSHS5nb29nbGUucHVic3ViLnYxLlNlZWtSZXF1ZXN0Gh4uZ29vZ2xlLnB1YnN1Yi52MS5TZWVrUmVzcG9uc2UiPYLT5JMCNzoBKiIyL3YxL3tzdWJzY3JpcHRpb249cHJvamVjdHMvKi9zdWJzY3JpcHRpb25zLyp9OnNlZWsacMpBFXB1YnN1Yi5nb29nbGVhcGlzLmNvbdJBVWh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0saHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9wdWJzdWJCqgEKFGNvbS5nb29nbGUucHVic3ViLnYxQgtQdWJzdWJQcm90b1ABWjJjbG91ZC5nb29nbGUuY29tL2dvL3B1YnN1Yi9hcGl2MS9wdWJzdWJwYjtwdWJzdWJwYvgBAaoCFkdvb2dsZS5DbG91ZC5QdWJTdWIuVjHKAhZHb29nbGVcQ2xvdWRcUHViU3ViXFYx6gIZR29vZ2xlOjpDbG91ZDo6UHViU3ViOjpWMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_api_resource, file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp, file_google_pubsub_v1_schema]);

/**
 * A policy constraining the storage of messages published to the topic.
 *
 * @generated from message google.pubsub.v1.MessageStoragePolicy
 */
export type MessageStoragePolicy = Message<"google.pubsub.v1.MessageStoragePolicy"> & {
  /**
   * Optional. A list of IDs of Google Cloud regions where messages that are
   * published to the topic may be persisted in storage. Messages published by
   * publishers running in non-allowed Google Cloud regions (or running outside
   * of Google Cloud altogether) are routed for storage in one of the allowed
   * regions. An empty list means that no regions are allowed, and is not a
   * valid configuration.
   *
   * @generated from field: repeated string allowed_persistence_regions = 1;
   */
  allowedPersistenceRegions: string[];

  /**
   * Optional. If true, `allowed_persistence_regions` is also used to enforce
   * in-transit guarantees for messages. That is, Pub/Sub will fail
   * Publish operations on this topic and subscribe operations
   * on any subscription attached to this topic in any region that is
   * not in `allowed_persistence_regions`.
   *
   * @generated from field: bool enforce_in_transit = 2;
   */
  enforceInTransit: boolean;
};

/**
 * Describes the message google.pubsub.v1.MessageStoragePolicy.
 * Use `create(MessageStoragePolicySchema)` to create a new message.
 */
export const MessageStoragePolicySchema: GenMessage<MessageStoragePolicy> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 0);

/**
 * Settings for validating messages published against a schema.
 *
 * @generated from message google.pubsub.v1.SchemaSettings
 */
export type SchemaSettings = Message<"google.pubsub.v1.SchemaSettings"> & {
  /**
   * Required. The name of the schema that messages published should be
   * validated against. Format is `projects/{project}/schemas/{schema}`. The
   * value of this field will be `_deleted-schema_` if the schema has been
   * deleted.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * Optional. The encoding of messages validated against `schema`.
   *
   * @generated from field: google.pubsub.v1.Encoding encoding = 2;
   */
  encoding: Encoding;

  /**
   * Optional. The minimum (inclusive) revision allowed for validating messages.
   * If empty or not present, allow any revision to be validated against
   * last_revision or any revision created before.
   *
   * @generated from field: string first_revision_id = 3;
   */
  firstRevisionId: string;

  /**
   * Optional. The maximum (inclusive) revision allowed for validating messages.
   * If empty or not present, allow any revision to be validated against
   * first_revision or any revision created after.
   *
   * @generated from field: string last_revision_id = 4;
   */
  lastRevisionId: string;
};

/**
 * Describes the message google.pubsub.v1.SchemaSettings.
 * Use `create(SchemaSettingsSchema)` to create a new message.
 */
export const SchemaSettingsSchema: GenMessage<SchemaSettings> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 1);

/**
 * Settings for an ingestion data source on a topic.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings
 */
export type IngestionDataSourceSettings = Message<"google.pubsub.v1.IngestionDataSourceSettings"> & {
  /**
   * Only one source type can have settings set.
   *
   * @generated from oneof google.pubsub.v1.IngestionDataSourceSettings.source
   */
  source: {
    /**
     * Optional. Amazon Kinesis Data Streams.
     *
     * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis aws_kinesis = 1;
     */
    value: IngestionDataSourceSettings_AwsKinesis;
    case: "awsKinesis";
  } | {
    /**
     * Optional. Cloud Storage.
     *
     * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.CloudStorage cloud_storage = 2;
     */
    value: IngestionDataSourceSettings_CloudStorage;
    case: "cloudStorage";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. Platform Logs settings. If unset, no Platform Logs will be
   * generated.
   *
   * @generated from field: google.pubsub.v1.PlatformLogsSettings platform_logs_settings = 4;
   */
  platformLogsSettings?: PlatformLogsSettings;
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.
 * Use `create(IngestionDataSourceSettingsSchema)` to create a new message.
 */
export const IngestionDataSourceSettingsSchema: GenMessage<IngestionDataSourceSettings> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2);

/**
 * Ingestion settings for Amazon Kinesis Data Streams.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis
 */
export type IngestionDataSourceSettings_AwsKinesis = Message<"google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis"> & {
  /**
   * Output only. An output-only field that indicates the state of the Kinesis
   * ingestion source.
   *
   * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.State state = 1;
   */
  state: IngestionDataSourceSettings_AwsKinesis_State;

  /**
   * Required. The Kinesis stream ARN to ingest data from.
   *
   * @generated from field: string stream_arn = 2;
   */
  streamArn: string;

  /**
   * Required. The Kinesis consumer ARN to used for ingestion in Enhanced
   * Fan-Out mode. The consumer must be already created and ready to be used.
   *
   * @generated from field: string consumer_arn = 3;
   */
  consumerArn: string;

  /**
   * Required. AWS role ARN to be used for Federated Identity authentication
   * with Kinesis. Check the Pub/Sub docs for how to set up this role and the
   * required permissions that need to be attached to it.
   *
   * @generated from field: string aws_role_arn = 4;
   */
  awsRoleArn: string;

  /**
   * Required. The GCP service account to be used for Federated Identity
   * authentication with Kinesis (via a `AssumeRoleWithWebIdentity` call for
   * the provided role). The `aws_role_arn` must be set up with
   * `accounts.google.com:sub` equals to this service account number.
   *
   * @generated from field: string gcp_service_account = 5;
   */
  gcpServiceAccount: string;
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.
 * Use `create(IngestionDataSourceSettings_AwsKinesisSchema)` to create a new message.
 */
export const IngestionDataSourceSettings_AwsKinesisSchema: GenMessage<IngestionDataSourceSettings_AwsKinesis> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2, 0);

/**
 * Possible states for ingestion from Amazon Kinesis Data Streams.
 *
 * @generated from enum google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.State
 */
export enum IngestionDataSourceSettings_AwsKinesis_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * Ingestion is active.
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Permission denied encountered while consuming data from Kinesis.
   * This can happen if:
   *   - The provided `aws_role_arn` does not exist or does not have the
   *     appropriate permissions attached.
   *   - The provided `aws_role_arn` is not set up properly for Identity
   *     Federation using `gcp_service_account`.
   *   - The Pub/Sub SA is not granted the
   *     `iam.serviceAccounts.getOpenIdToken` permission on
   *     `gcp_service_account`.
   *
   * @generated from enum value: KINESIS_PERMISSION_DENIED = 2;
   */
  KINESIS_PERMISSION_DENIED = 2,

  /**
   * Permission denied encountered while publishing to the topic. This can
   * happen if the Pub/Sub SA has not been granted the [appropriate publish
   * permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
   *
   * @generated from enum value: PUBLISH_PERMISSION_DENIED = 3;
   */
  PUBLISH_PERMISSION_DENIED = 3,

  /**
   * The Kinesis stream does not exist.
   *
   * @generated from enum value: STREAM_NOT_FOUND = 4;
   */
  STREAM_NOT_FOUND = 4,

  /**
   * The Kinesis consumer does not exist.
   *
   * @generated from enum value: CONSUMER_NOT_FOUND = 5;
   */
  CONSUMER_NOT_FOUND = 5,
}

/**
 * Describes the enum google.pubsub.v1.IngestionDataSourceSettings.AwsKinesis.State.
 */
export const IngestionDataSourceSettings_AwsKinesis_StateSchema: GenEnum<IngestionDataSourceSettings_AwsKinesis_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 2, 0, 0);

/**
 * Ingestion settings for Cloud Storage.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage
 */
export type IngestionDataSourceSettings_CloudStorage = Message<"google.pubsub.v1.IngestionDataSourceSettings.CloudStorage"> & {
  /**
   * Output only. An output-only field that indicates the state of the Cloud
   * Storage ingestion source.
   *
   * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.State state = 1;
   */
  state: IngestionDataSourceSettings_CloudStorage_State;

  /**
   * Optional. Cloud Storage bucket. The bucket name must be without any
   * prefix like "gs://". See the [bucket naming requirements]
   * (https://cloud.google.com/storage/docs/buckets#naming).
   *
   * @generated from field: string bucket = 2;
   */
  bucket: string;

  /**
   * Defaults to text format.
   *
   * @generated from oneof google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.input_format
   */
  inputFormat: {
    /**
     * Optional. Data from Cloud Storage will be interpreted as text.
     *
     * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat text_format = 3;
     */
    value: IngestionDataSourceSettings_CloudStorage_TextFormat;
    case: "textFormat";
  } | {
    /**
     * Optional. Data from Cloud Storage will be interpreted in Avro format.
     *
     * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat avro_format = 4;
     */
    value: IngestionDataSourceSettings_CloudStorage_AvroFormat;
    case: "avroFormat";
  } | {
    /**
     * Optional. It will be assumed data from Cloud Storage was written via
     * [Cloud Storage
     * subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage).
     *
     * @generated from field: google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat pubsub_avro_format = 5;
     */
    value: IngestionDataSourceSettings_CloudStorage_PubSubAvroFormat;
    case: "pubsubAvroFormat";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. Only objects with a larger or equal creation timestamp will be
   * ingested.
   *
   * @generated from field: google.protobuf.Timestamp minimum_object_create_time = 6;
   */
  minimumObjectCreateTime?: Timestamp;

  /**
   * Optional. Glob pattern used to match objects that will be ingested. If
   * unset, all objects will be ingested. See the [supported
   * patterns](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob).
   *
   * @generated from field: string match_glob = 9;
   */
  matchGlob: string;
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.
 * Use `create(IngestionDataSourceSettings_CloudStorageSchema)` to create a new message.
 */
export const IngestionDataSourceSettings_CloudStorageSchema: GenMessage<IngestionDataSourceSettings_CloudStorage> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2, 1);

/**
 * Configuration for reading Cloud Storage data in text format. Each line of
 * text as specified by the delimiter will be set to the `data` field of a
 * Pub/Sub message.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat
 */
export type IngestionDataSourceSettings_CloudStorage_TextFormat = Message<"google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat"> & {
  /**
   * Optional. When unset, '\n' is used.
   *
   * @generated from field: optional string delimiter = 1;
   */
  delimiter?: string;
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.TextFormat.
 * Use `create(IngestionDataSourceSettings_CloudStorage_TextFormatSchema)` to create a new message.
 */
export const IngestionDataSourceSettings_CloudStorage_TextFormatSchema: GenMessage<IngestionDataSourceSettings_CloudStorage_TextFormat> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2, 1, 0);

/**
 * Configuration for reading Cloud Storage data in Avro binary format. The
 * bytes of each object will be set to the `data` field of a Pub/Sub
 * message.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat
 */
export type IngestionDataSourceSettings_CloudStorage_AvroFormat = Message<"google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat"> & {
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.AvroFormat.
 * Use `create(IngestionDataSourceSettings_CloudStorage_AvroFormatSchema)` to create a new message.
 */
export const IngestionDataSourceSettings_CloudStorage_AvroFormatSchema: GenMessage<IngestionDataSourceSettings_CloudStorage_AvroFormat> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2, 1, 1);

/**
 * Configuration for reading Cloud Storage data written via [Cloud Storage
 * subscriptions](https://cloud.google.com/pubsub/docs/cloudstorage). The
 * data and attributes fields of the originally exported Pub/Sub message
 * will be restored when publishing.
 *
 * @generated from message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat
 */
export type IngestionDataSourceSettings_CloudStorage_PubSubAvroFormat = Message<"google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat"> & {
};

/**
 * Describes the message google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.PubSubAvroFormat.
 * Use `create(IngestionDataSourceSettings_CloudStorage_PubSubAvroFormatSchema)` to create a new message.
 */
export const IngestionDataSourceSettings_CloudStorage_PubSubAvroFormatSchema: GenMessage<IngestionDataSourceSettings_CloudStorage_PubSubAvroFormat> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 2, 1, 2);

/**
 * Possible states for ingestion from Cloud Storage.
 *
 * @generated from enum google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.State
 */
export enum IngestionDataSourceSettings_CloudStorage_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * Ingestion is active.
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Permission denied encountered while calling the Cloud Storage API. This
   * can happen if the Pub/Sub SA has not been granted the
   * [appropriate
   * permissions](https://cloud.google.com/storage/docs/access-control/iam-permissions):
   * - storage.objects.list: to list the objects in a bucket.
   * - storage.objects.get: to read the objects in a bucket.
   * - storage.buckets.get: to verify the bucket exists.
   *
   * @generated from enum value: CLOUD_STORAGE_PERMISSION_DENIED = 2;
   */
  CLOUD_STORAGE_PERMISSION_DENIED = 2,

  /**
   * Permission denied encountered while publishing to the topic. This can
   * happen if the Pub/Sub SA has not been granted the [appropriate publish
   * permissions](https://cloud.google.com/pubsub/docs/access-control#pubsub.publisher)
   *
   * @generated from enum value: PUBLISH_PERMISSION_DENIED = 3;
   */
  PUBLISH_PERMISSION_DENIED = 3,

  /**
   * The provided Cloud Storage bucket doesn't exist.
   *
   * @generated from enum value: BUCKET_NOT_FOUND = 4;
   */
  BUCKET_NOT_FOUND = 4,

  /**
   * The Cloud Storage bucket has too many objects, ingestion will be
   * paused.
   *
   * @generated from enum value: TOO_MANY_OBJECTS = 5;
   */
  TOO_MANY_OBJECTS = 5,
}

/**
 * Describes the enum google.pubsub.v1.IngestionDataSourceSettings.CloudStorage.State.
 */
export const IngestionDataSourceSettings_CloudStorage_StateSchema: GenEnum<IngestionDataSourceSettings_CloudStorage_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 2, 1, 0);

/**
 * Settings for Platform Logs produced by Pub/Sub.
 *
 * @generated from message google.pubsub.v1.PlatformLogsSettings
 */
export type PlatformLogsSettings = Message<"google.pubsub.v1.PlatformLogsSettings"> & {
  /**
   * Optional. The minimum severity level of Platform Logs that will be written.
   *
   * @generated from field: google.pubsub.v1.PlatformLogsSettings.Severity severity = 1;
   */
  severity: PlatformLogsSettings_Severity;
};

/**
 * Describes the message google.pubsub.v1.PlatformLogsSettings.
 * Use `create(PlatformLogsSettingsSchema)` to create a new message.
 */
export const PlatformLogsSettingsSchema: GenMessage<PlatformLogsSettings> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 3);

/**
 * Severity levels of Platform Logs.
 *
 * @generated from enum google.pubsub.v1.PlatformLogsSettings.Severity
 */
export enum PlatformLogsSettings_Severity {
  /**
   * Default value. Logs level is unspecified. Logs will be disabled.
   *
   * @generated from enum value: SEVERITY_UNSPECIFIED = 0;
   */
  SEVERITY_UNSPECIFIED = 0,

  /**
   * Logs will be disabled.
   *
   * @generated from enum value: DISABLED = 1;
   */
  DISABLED = 1,

  /**
   * Debug logs and higher-severity logs will be written.
   *
   * @generated from enum value: DEBUG = 2;
   */
  DEBUG = 2,

  /**
   * Info logs and higher-severity logs will be written.
   *
   * @generated from enum value: INFO = 3;
   */
  INFO = 3,

  /**
   * Warning logs and higher-severity logs will be written.
   *
   * @generated from enum value: WARNING = 4;
   */
  WARNING = 4,

  /**
   * Only error logs will be written.
   *
   * @generated from enum value: ERROR = 5;
   */
  ERROR = 5,
}

/**
 * Describes the enum google.pubsub.v1.PlatformLogsSettings.Severity.
 */
export const PlatformLogsSettings_SeveritySchema: GenEnum<PlatformLogsSettings_Severity> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 3, 0);

/**
 * A topic resource.
 *
 * @generated from message google.pubsub.v1.Topic
 */
export type Topic = Message<"google.pubsub.v1.Topic"> & {
  /**
   * Required. The name of the topic. It must have the format
   * `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
   * and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
   * underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
   * signs (`%`). It must be between 3 and 255 characters in length, and it
   * must not start with `"goog"`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. See [Creating and managing labels]
   * (https://cloud.google.com/pubsub/docs/labels).
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string };

  /**
   * Optional. Policy constraining the set of Google Cloud Platform regions
   * where messages published to the topic may be stored. If not present, then
   * no constraints are in effect.
   *
   * @generated from field: google.pubsub.v1.MessageStoragePolicy message_storage_policy = 3;
   */
  messageStoragePolicy?: MessageStoragePolicy;

  /**
   * Optional. The resource name of the Cloud KMS CryptoKey to be used to
   * protect access to messages published on this topic.
   *
   * The expected format is `projects/*\/locations/*\/keyRings/*\/cryptoKeys/*`.
   *
   * @generated from field: string kms_key_name = 5;
   */
  kmsKeyName: string;

  /**
   * Optional. Settings for validating messages published against a schema.
   *
   * @generated from field: google.pubsub.v1.SchemaSettings schema_settings = 6;
   */
  schemaSettings?: SchemaSettings;

  /**
   * Optional. Reserved for future use. This field is set only in responses from
   * the server; it is ignored if it is set in any requests.
   *
   * @generated from field: bool satisfies_pzs = 7;
   */
  satisfiesPzs: boolean;

  /**
   * Optional. Indicates the minimum duration to retain a message after it is
   * published to the topic. If this field is set, messages published to the
   * topic in the last `message_retention_duration` are always available to
   * subscribers. For instance, it allows any attached subscription to [seek to
   * a
   * timestamp](https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)
   * that is up to `message_retention_duration` in the past. If this field is
   * not set, message retention is controlled by settings on individual
   * subscriptions. Cannot be more than 31 days or less than 10 minutes.
   *
   * @generated from field: google.protobuf.Duration message_retention_duration = 8;
   */
  messageRetentionDuration?: Duration;

  /**
   * Output only. An output-only field indicating the state of the topic.
   *
   * @generated from field: google.pubsub.v1.Topic.State state = 9;
   */
  state: Topic_State;

  /**
   * Optional. Settings for ingestion from a data source into this topic.
   *
   * @generated from field: google.pubsub.v1.IngestionDataSourceSettings ingestion_data_source_settings = 10;
   */
  ingestionDataSourceSettings?: IngestionDataSourceSettings;
};

/**
 * Describes the message google.pubsub.v1.Topic.
 * Use `create(TopicSchema)` to create a new message.
 */
export const TopicSchema: GenMessage<Topic> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 4);

/**
 * The state of the topic.
 *
 * @generated from enum google.pubsub.v1.Topic.State
 */
export enum Topic_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The topic does not have any persistent errors.
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Ingestion from the data source has encountered a permanent error.
   * See the more detailed error state in the corresponding ingestion
   * source configuration.
   *
   * @generated from enum value: INGESTION_RESOURCE_ERROR = 2;
   */
  INGESTION_RESOURCE_ERROR = 2,
}

/**
 * Describes the enum google.pubsub.v1.Topic.State.
 */
export const Topic_StateSchema: GenEnum<Topic_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 4, 0);

/**
 * A message that is published by publishers and consumed by subscribers. The
 * message must contain either a non-empty data field or at least one attribute.
 * Note that client libraries represent this object differently
 * depending on the language. See the corresponding [client library
 * documentation](https://cloud.google.com/pubsub/docs/reference/libraries) for
 * more information. See [quotas and limits]
 * (https://cloud.google.com/pubsub/quotas) for more information about message
 * limits.
 *
 * @generated from message google.pubsub.v1.PubsubMessage
 */
export type PubsubMessage = Message<"google.pubsub.v1.PubsubMessage"> & {
  /**
   * Optional. The message data field. If this field is empty, the message must
   * contain at least one attribute.
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;

  /**
   * Optional. Attributes for this message. If this field is empty, the message
   * must contain non-empty data. This can be used to filter messages on the
   * subscription.
   *
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string };

  /**
   * ID of this message, assigned by the server when the message is published.
   * Guaranteed to be unique within the topic. This value may be read by a
   * subscriber that receives a `PubsubMessage` via a `Pull` call or a push
   * delivery. It must not be populated by the publisher in a `Publish` call.
   *
   * @generated from field: string message_id = 3;
   */
  messageId: string;

  /**
   * The time at which the message was published, populated by the server when
   * it receives the `Publish` call. It must not be populated by the
   * publisher in a `Publish` call.
   *
   * @generated from field: google.protobuf.Timestamp publish_time = 4;
   */
  publishTime?: Timestamp;

  /**
   * Optional. If non-empty, identifies related messages for which publish order
   * should be respected. If a `Subscription` has `enable_message_ordering` set
   * to `true`, messages published with the same non-empty `ordering_key` value
   * will be delivered to subscribers in the order in which they are received by
   * the Pub/Sub system. All `PubsubMessage`s published in a given
   * `PublishRequest` must specify the same `ordering_key` value. For more
   * information, see [ordering
   * messages](https://cloud.google.com/pubsub/docs/ordering).
   *
   * @generated from field: string ordering_key = 5;
   */
  orderingKey: string;
};

/**
 * Describes the message google.pubsub.v1.PubsubMessage.
 * Use `create(PubsubMessageSchema)` to create a new message.
 */
export const PubsubMessageSchema: GenMessage<PubsubMessage> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 5);

/**
 * Request for the GetTopic method.
 *
 * @generated from message google.pubsub.v1.GetTopicRequest
 */
export type GetTopicRequest = Message<"google.pubsub.v1.GetTopicRequest"> & {
  /**
   * Required. The name of the topic to get.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic: string;
};

/**
 * Describes the message google.pubsub.v1.GetTopicRequest.
 * Use `create(GetTopicRequestSchema)` to create a new message.
 */
export const GetTopicRequestSchema: GenMessage<GetTopicRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 6);

/**
 * Request for the UpdateTopic method.
 *
 * @generated from message google.pubsub.v1.UpdateTopicRequest
 */
export type UpdateTopicRequest = Message<"google.pubsub.v1.UpdateTopicRequest"> & {
  /**
   * Required. The updated topic object.
   *
   * @generated from field: google.pubsub.v1.Topic topic = 1;
   */
  topic?: Topic;

  /**
   * Required. Indicates which fields in the provided topic to update. Must be
   * specified and non-empty. Note that if `update_mask` contains
   * "message_storage_policy" but the `message_storage_policy` is not set in
   * the `topic` provided above, then the updated value is determined by the
   * policy configured at the project or organization level.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.pubsub.v1.UpdateTopicRequest.
 * Use `create(UpdateTopicRequestSchema)` to create a new message.
 */
export const UpdateTopicRequestSchema: GenMessage<UpdateTopicRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 7);

/**
 * Request for the Publish method.
 *
 * @generated from message google.pubsub.v1.PublishRequest
 */
export type PublishRequest = Message<"google.pubsub.v1.PublishRequest"> & {
  /**
   * Required. The messages in the request will be published on this topic.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic: string;

  /**
   * Required. The messages to publish.
   *
   * @generated from field: repeated google.pubsub.v1.PubsubMessage messages = 2;
   */
  messages: PubsubMessage[];
};

/**
 * Describes the message google.pubsub.v1.PublishRequest.
 * Use `create(PublishRequestSchema)` to create a new message.
 */
export const PublishRequestSchema: GenMessage<PublishRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 8);

/**
 * Response for the `Publish` method.
 *
 * @generated from message google.pubsub.v1.PublishResponse
 */
export type PublishResponse = Message<"google.pubsub.v1.PublishResponse"> & {
  /**
   * Optional. The server-assigned ID of each published message, in the same
   * order as the messages in the request. IDs are guaranteed to be unique
   * within the topic.
   *
   * @generated from field: repeated string message_ids = 1;
   */
  messageIds: string[];
};

/**
 * Describes the message google.pubsub.v1.PublishResponse.
 * Use `create(PublishResponseSchema)` to create a new message.
 */
export const PublishResponseSchema: GenMessage<PublishResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 9);

/**
 * Request for the `ListTopics` method.
 *
 * @generated from message google.pubsub.v1.ListTopicsRequest
 */
export type ListTopicsRequest = Message<"google.pubsub.v1.ListTopicsRequest"> & {
  /**
   * Required. The name of the project in which to list topics.
   * Format is `projects/{project-id}`.
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * Optional. Maximum number of topics to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. The value returned by the last `ListTopicsResponse`; indicates
   * that this is a continuation of a prior `ListTopics` call, and that the
   * system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicsRequest.
 * Use `create(ListTopicsRequestSchema)` to create a new message.
 */
export const ListTopicsRequestSchema: GenMessage<ListTopicsRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 10);

/**
 * Response for the `ListTopics` method.
 *
 * @generated from message google.pubsub.v1.ListTopicsResponse
 */
export type ListTopicsResponse = Message<"google.pubsub.v1.ListTopicsResponse"> & {
  /**
   * Optional. The resulting topics.
   *
   * @generated from field: repeated google.pubsub.v1.Topic topics = 1;
   */
  topics: Topic[];

  /**
   * Optional. If not empty, indicates that there may be more topics that match
   * the request; this value should be passed in a new `ListTopicsRequest`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicsResponse.
 * Use `create(ListTopicsResponseSchema)` to create a new message.
 */
export const ListTopicsResponseSchema: GenMessage<ListTopicsResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 11);

/**
 * Request for the `ListTopicSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSubscriptionsRequest
 */
export type ListTopicSubscriptionsRequest = Message<"google.pubsub.v1.ListTopicSubscriptionsRequest"> & {
  /**
   * Required. The name of the topic that subscriptions are attached to.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic: string;

  /**
   * Optional. Maximum number of subscription names to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. The value returned by the last `ListTopicSubscriptionsResponse`;
   * indicates that this is a continuation of a prior `ListTopicSubscriptions`
   * call, and that the system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicSubscriptionsRequest.
 * Use `create(ListTopicSubscriptionsRequestSchema)` to create a new message.
 */
export const ListTopicSubscriptionsRequestSchema: GenMessage<ListTopicSubscriptionsRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 12);

/**
 * Response for the `ListTopicSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSubscriptionsResponse
 */
export type ListTopicSubscriptionsResponse = Message<"google.pubsub.v1.ListTopicSubscriptionsResponse"> & {
  /**
   * Optional. The names of subscriptions attached to the topic specified in the
   * request.
   *
   * @generated from field: repeated string subscriptions = 1;
   */
  subscriptions: string[];

  /**
   * Optional. If not empty, indicates that there may be more subscriptions that
   * match the request; this value should be passed in a new
   * `ListTopicSubscriptionsRequest` to get more subscriptions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicSubscriptionsResponse.
 * Use `create(ListTopicSubscriptionsResponseSchema)` to create a new message.
 */
export const ListTopicSubscriptionsResponseSchema: GenMessage<ListTopicSubscriptionsResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 13);

/**
 * Request for the `ListTopicSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSnapshotsRequest
 */
export type ListTopicSnapshotsRequest = Message<"google.pubsub.v1.ListTopicSnapshotsRequest"> & {
  /**
   * Required. The name of the topic that snapshots are attached to.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic: string;

  /**
   * Optional. Maximum number of snapshot names to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. The value returned by the last `ListTopicSnapshotsResponse`;
   * indicates that this is a continuation of a prior `ListTopicSnapshots` call,
   * and that the system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicSnapshotsRequest.
 * Use `create(ListTopicSnapshotsRequestSchema)` to create a new message.
 */
export const ListTopicSnapshotsRequestSchema: GenMessage<ListTopicSnapshotsRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 14);

/**
 * Response for the `ListTopicSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSnapshotsResponse
 */
export type ListTopicSnapshotsResponse = Message<"google.pubsub.v1.ListTopicSnapshotsResponse"> & {
  /**
   * Optional. The names of the snapshots that match the request.
   *
   * @generated from field: repeated string snapshots = 1;
   */
  snapshots: string[];

  /**
   * Optional. If not empty, indicates that there may be more snapshots that
   * match the request; this value should be passed in a new
   * `ListTopicSnapshotsRequest` to get more snapshots.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListTopicSnapshotsResponse.
 * Use `create(ListTopicSnapshotsResponseSchema)` to create a new message.
 */
export const ListTopicSnapshotsResponseSchema: GenMessage<ListTopicSnapshotsResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 15);

/**
 * Request for the `DeleteTopic` method.
 *
 * @generated from message google.pubsub.v1.DeleteTopicRequest
 */
export type DeleteTopicRequest = Message<"google.pubsub.v1.DeleteTopicRequest"> & {
  /**
   * Required. Name of the topic to delete.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic: string;
};

/**
 * Describes the message google.pubsub.v1.DeleteTopicRequest.
 * Use `create(DeleteTopicRequestSchema)` to create a new message.
 */
export const DeleteTopicRequestSchema: GenMessage<DeleteTopicRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 16);

/**
 * Request for the DetachSubscription method.
 *
 * @generated from message google.pubsub.v1.DetachSubscriptionRequest
 */
export type DetachSubscriptionRequest = Message<"google.pubsub.v1.DetachSubscriptionRequest"> & {
  /**
   * Required. The subscription to detach.
   * Format is `projects/{project}/subscriptions/{subscription}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;
};

/**
 * Describes the message google.pubsub.v1.DetachSubscriptionRequest.
 * Use `create(DetachSubscriptionRequestSchema)` to create a new message.
 */
export const DetachSubscriptionRequestSchema: GenMessage<DetachSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 17);

/**
 * Response for the DetachSubscription method.
 * Reserved for future use.
 *
 * @generated from message google.pubsub.v1.DetachSubscriptionResponse
 */
export type DetachSubscriptionResponse = Message<"google.pubsub.v1.DetachSubscriptionResponse"> & {
};

/**
 * Describes the message google.pubsub.v1.DetachSubscriptionResponse.
 * Use `create(DetachSubscriptionResponseSchema)` to create a new message.
 */
export const DetachSubscriptionResponseSchema: GenMessage<DetachSubscriptionResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 18);

/**
 * A subscription resource. If none of `push_config`, `bigquery_config`, or
 * `cloud_storage_config` is set, then the subscriber will pull and ack messages
 * using API methods. At most one of these fields may be set.
 *
 * @generated from message google.pubsub.v1.Subscription
 */
export type Subscription = Message<"google.pubsub.v1.Subscription"> & {
  /**
   * Required. The name of the subscription. It must have the format
   * `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
   * start with a letter, and contain only letters (`[A-Za-z]`), numbers
   * (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
   * plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
   * in length, and it must not start with `"goog"`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The name of the topic from which this subscription is receiving
   * messages. Format is `projects/{project}/topics/{topic}`. The value of this
   * field will be `_deleted-topic_` if the topic has been deleted.
   *
   * @generated from field: string topic = 2;
   */
  topic: string;

  /**
   * Optional. If push delivery is used with this subscription, this field is
   * used to configure it.
   *
   * @generated from field: google.pubsub.v1.PushConfig push_config = 4;
   */
  pushConfig?: PushConfig;

  /**
   * Optional. If delivery to BigQuery is used with this subscription, this
   * field is used to configure it.
   *
   * @generated from field: google.pubsub.v1.BigQueryConfig bigquery_config = 18;
   */
  bigqueryConfig?: BigQueryConfig;

  /**
   * Optional. If delivery to Google Cloud Storage is used with this
   * subscription, this field is used to configure it.
   *
   * @generated from field: google.pubsub.v1.CloudStorageConfig cloud_storage_config = 22;
   */
  cloudStorageConfig?: CloudStorageConfig;

  /**
   * Optional. The approximate amount of time (on a best-effort basis) Pub/Sub
   * waits for the subscriber to acknowledge receipt before resending the
   * message. In the interval after the message is delivered and before it is
   * acknowledged, it is considered to be _outstanding_. During that time
   * period, the message will not be redelivered (on a best-effort basis).
   *
   * For pull subscriptions, this value is used as the initial value for the ack
   * deadline. To override this value for a given message, call
   * `ModifyAckDeadline` with the corresponding `ack_id` if using
   * non-streaming pull or send the `ack_id` in a
   * `StreamingModifyAckDeadlineRequest` if using streaming pull.
   * The minimum custom deadline you can specify is 10 seconds.
   * The maximum custom deadline you can specify is 600 seconds (10 minutes).
   * If this parameter is 0, a default value of 10 seconds is used.
   *
   * For push delivery, this value is also used to set the request timeout for
   * the call to the push endpoint.
   *
   * If the subscriber never acknowledges the message, the Pub/Sub
   * system will eventually redeliver the message.
   *
   * @generated from field: int32 ack_deadline_seconds = 5;
   */
  ackDeadlineSeconds: number;

  /**
   * Optional. Indicates whether to retain acknowledged messages. If true, then
   * messages are not expunged from the subscription's backlog, even if they are
   * acknowledged, until they fall out of the `message_retention_duration`
   * window. This must be true if you would like to [`Seek` to a timestamp]
   * (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time) in
   * the past to replay previously-acknowledged messages.
   *
   * @generated from field: bool retain_acked_messages = 7;
   */
  retainAckedMessages: boolean;

  /**
   * Optional. How long to retain unacknowledged messages in the subscription's
   * backlog, from the moment a message is published. If `retain_acked_messages`
   * is true, then this also configures the retention of acknowledged messages,
   * and thus configures how far back in time a `Seek` can be done. Defaults to
   * 7 days. Cannot be more than 31 days or less than 10 minutes.
   *
   * @generated from field: google.protobuf.Duration message_retention_duration = 8;
   */
  messageRetentionDuration?: Duration;

  /**
   * Optional. See [Creating and managing
   * labels](https://cloud.google.com/pubsub/docs/labels).
   *
   * @generated from field: map<string, string> labels = 9;
   */
  labels: { [key: string]: string };

  /**
   * Optional. If true, messages published with the same `ordering_key` in
   * `PubsubMessage` will be delivered to the subscribers in the order in which
   * they are received by the Pub/Sub system. Otherwise, they may be delivered
   * in any order.
   *
   * @generated from field: bool enable_message_ordering = 10;
   */
  enableMessageOrdering: boolean;

  /**
   * Optional. A policy that specifies the conditions for this subscription's
   * expiration. A subscription is considered active as long as any connected
   * subscriber is successfully consuming messages from the subscription or is
   * issuing operations on the subscription. If `expiration_policy` is not set,
   * a *default policy* with `ttl` of 31 days will be used. The minimum allowed
   * value for `expiration_policy.ttl` is 1 day. If `expiration_policy` is set,
   * but `expiration_policy.ttl` is not set, the subscription never expires.
   *
   * @generated from field: google.pubsub.v1.ExpirationPolicy expiration_policy = 11;
   */
  expirationPolicy?: ExpirationPolicy;

  /**
   * Optional. An expression written in the Pub/Sub [filter
   * language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
   * then only `PubsubMessage`s whose `attributes` field matches the filter are
   * delivered on this subscription. If empty, then no messages are filtered
   * out.
   *
   * @generated from field: string filter = 12;
   */
  filter: string;

  /**
   * Optional. A policy that specifies the conditions for dead lettering
   * messages in this subscription. If dead_letter_policy is not set, dead
   * lettering is disabled.
   *
   * The Pub/Sub service account associated with this subscriptions's
   * parent project (i.e.,
   * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
   * permission to Acknowledge() messages on this subscription.
   *
   * @generated from field: google.pubsub.v1.DeadLetterPolicy dead_letter_policy = 13;
   */
  deadLetterPolicy?: DeadLetterPolicy;

  /**
   * Optional. A policy that specifies how Pub/Sub retries message delivery for
   * this subscription.
   *
   * If not set, the default retry policy is applied. This generally implies
   * that messages will be retried as soon as possible for healthy subscribers.
   * RetryPolicy will be triggered on NACKs or acknowledgement deadline
   * exceeded events for a given message.
   *
   * @generated from field: google.pubsub.v1.RetryPolicy retry_policy = 14;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Optional. Indicates whether the subscription is detached from its topic.
   * Detached subscriptions don't receive messages from their topic and don't
   * retain any backlog. `Pull` and `StreamingPull` requests will return
   * FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
   * the endpoint will not be made.
   *
   * @generated from field: bool detached = 15;
   */
  detached: boolean;

  /**
   * Optional. If true, Pub/Sub provides the following guarantees for the
   * delivery of a message with a given value of `message_id` on this
   * subscription:
   *
   * * The message sent to a subscriber is guaranteed not to be resent
   * before the message's acknowledgement deadline expires.
   * * An acknowledged message will not be resent to a subscriber.
   *
   * Note that subscribers may still receive multiple copies of a message
   * when `enable_exactly_once_delivery` is true if the message was published
   * multiple times by a publisher client. These copies are  considered distinct
   * by Pub/Sub and have distinct `message_id` values.
   *
   * @generated from field: bool enable_exactly_once_delivery = 16;
   */
  enableExactlyOnceDelivery: boolean;

  /**
   * Output only. Indicates the minimum duration for which a message is retained
   * after it is published to the subscription's topic. If this field is set,
   * messages published to the subscription's topic in the last
   * `topic_message_retention_duration` are always available to subscribers. See
   * the `message_retention_duration` field in `Topic`. This field is set only
   * in responses from the server; it is ignored if it is set in any requests.
   *
   * @generated from field: google.protobuf.Duration topic_message_retention_duration = 17;
   */
  topicMessageRetentionDuration?: Duration;

  /**
   * Output only. An output-only field indicating whether or not the
   * subscription can receive messages.
   *
   * @generated from field: google.pubsub.v1.Subscription.State state = 19;
   */
  state: Subscription_State;

  /**
   * Output only. Information about the associated Analytics Hub subscription.
   * Only set if the subscritpion is created by Analytics Hub.
   *
   * @generated from field: google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo analytics_hub_subscription_info = 23;
   */
  analyticsHubSubscriptionInfo?: Subscription_AnalyticsHubSubscriptionInfo;
};

/**
 * Describes the message google.pubsub.v1.Subscription.
 * Use `create(SubscriptionSchema)` to create a new message.
 */
export const SubscriptionSchema: GenMessage<Subscription> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 19);

/**
 * Information about an associated Analytics Hub subscription
 * (https://cloud.google.com/bigquery/docs/analytics-hub-manage-subscriptions).
 *
 * @generated from message google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo
 */
export type Subscription_AnalyticsHubSubscriptionInfo = Message<"google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo"> & {
  /**
   * Optional. The name of the associated Analytics Hub listing resource.
   * Pattern:
   * "projects/{project}/locations/{location}/dataExchanges/{data_exchange}/listings/{listing}"
   *
   * @generated from field: string listing = 1;
   */
  listing: string;

  /**
   * Optional. The name of the associated Analytics Hub subscription resource.
   * Pattern:
   * "projects/{project}/locations/{location}/subscriptions/{subscription}"
   *
   * @generated from field: string subscription = 2;
   */
  subscription: string;
};

/**
 * Describes the message google.pubsub.v1.Subscription.AnalyticsHubSubscriptionInfo.
 * Use `create(Subscription_AnalyticsHubSubscriptionInfoSchema)` to create a new message.
 */
export const Subscription_AnalyticsHubSubscriptionInfoSchema: GenMessage<Subscription_AnalyticsHubSubscriptionInfo> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 19, 0);

/**
 * Possible states for a subscription.
 *
 * @generated from enum google.pubsub.v1.Subscription.State
 */
export enum Subscription_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The subscription can actively receive messages
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * The subscription cannot receive messages because of an error with the
   * resource to which it pushes messages. See the more detailed error state
   * in the corresponding configuration.
   *
   * @generated from enum value: RESOURCE_ERROR = 2;
   */
  RESOURCE_ERROR = 2,
}

/**
 * Describes the enum google.pubsub.v1.Subscription.State.
 */
export const Subscription_StateSchema: GenEnum<Subscription_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 19, 0);

/**
 * A policy that specifies how Pub/Sub retries message delivery.
 *
 * Retry delay will be exponential based on provided minimum and maximum
 * backoffs. https://en.wikipedia.org/wiki/Exponential_backoff.
 *
 * RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded
 * events for a given message.
 *
 * Retry Policy is implemented on a best effort basis. At times, the delay
 * between consecutive deliveries may not match the configuration. That is,
 * delay can be more or less than configured backoff.
 *
 * @generated from message google.pubsub.v1.RetryPolicy
 */
export type RetryPolicy = Message<"google.pubsub.v1.RetryPolicy"> & {
  /**
   * Optional. The minimum delay between consecutive deliveries of a given
   * message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
   *
   * @generated from field: google.protobuf.Duration minimum_backoff = 1;
   */
  minimumBackoff?: Duration;

  /**
   * Optional. The maximum delay between consecutive deliveries of a given
   * message. Value should be between 0 and 600 seconds. Defaults to 600
   * seconds.
   *
   * @generated from field: google.protobuf.Duration maximum_backoff = 2;
   */
  maximumBackoff?: Duration;
};

/**
 * Describes the message google.pubsub.v1.RetryPolicy.
 * Use `create(RetryPolicySchema)` to create a new message.
 */
export const RetryPolicySchema: GenMessage<RetryPolicy> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 20);

/**
 * Dead lettering is done on a best effort basis. The same message might be
 * dead lettered multiple times.
 *
 * If validation on any of the fields fails at subscription creation/updation,
 * the create/update subscription request will fail.
 *
 * @generated from message google.pubsub.v1.DeadLetterPolicy
 */
export type DeadLetterPolicy = Message<"google.pubsub.v1.DeadLetterPolicy"> & {
  /**
   * Optional. The name of the topic to which dead letter messages should be
   * published. Format is `projects/{project}/topics/{topic}`.The Pub/Sub
   * service account associated with the enclosing subscription's parent project
   * (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must
   * have permission to Publish() to this topic.
   *
   * The operation will fail if the topic does not exist.
   * Users should ensure that there is a subscription attached to this topic
   * since messages published to a topic with no subscriptions are lost.
   *
   * @generated from field: string dead_letter_topic = 1;
   */
  deadLetterTopic: string;

  /**
   * Optional. The maximum number of delivery attempts for any message. The
   * value must be between 5 and 100.
   *
   * The number of delivery attempts is defined as 1 + (the sum of number of
   * NACKs and number of times the acknowledgement deadline has been exceeded
   * for the message).
   *
   * A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
   * client libraries may automatically extend ack_deadlines.
   *
   * This field will be honored on a best effort basis.
   *
   * If this parameter is 0, a default value of 5 is used.
   *
   * @generated from field: int32 max_delivery_attempts = 2;
   */
  maxDeliveryAttempts: number;
};

/**
 * Describes the message google.pubsub.v1.DeadLetterPolicy.
 * Use `create(DeadLetterPolicySchema)` to create a new message.
 */
export const DeadLetterPolicySchema: GenMessage<DeadLetterPolicy> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 21);

/**
 * A policy that specifies the conditions for resource expiration (i.e.,
 * automatic resource deletion).
 *
 * @generated from message google.pubsub.v1.ExpirationPolicy
 */
export type ExpirationPolicy = Message<"google.pubsub.v1.ExpirationPolicy"> & {
  /**
   * Optional. Specifies the "time-to-live" duration for an associated resource.
   * The resource expires if it is not active for a period of `ttl`. The
   * definition of "activity" depends on the type of the associated resource.
   * The minimum and maximum allowed values for `ttl` depend on the type of the
   * associated resource, as well. If `ttl` is not set, the associated resource
   * never expires.
   *
   * @generated from field: google.protobuf.Duration ttl = 1;
   */
  ttl?: Duration;
};

/**
 * Describes the message google.pubsub.v1.ExpirationPolicy.
 * Use `create(ExpirationPolicySchema)` to create a new message.
 */
export const ExpirationPolicySchema: GenMessage<ExpirationPolicy> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 22);

/**
 * Configuration for a push delivery endpoint.
 *
 * @generated from message google.pubsub.v1.PushConfig
 */
export type PushConfig = Message<"google.pubsub.v1.PushConfig"> & {
  /**
   * Optional. A URL locating the endpoint to which messages should be pushed.
   * For example, a Webhook endpoint might use `https://example.com/push`.
   *
   * @generated from field: string push_endpoint = 1;
   */
  pushEndpoint: string;

  /**
   * Optional. Endpoint configuration attributes that can be used to control
   * different aspects of the message delivery.
   *
   * The only currently supported attribute is `x-goog-version`, which you can
   * use to change the format of the pushed message. This attribute
   * indicates the version of the data expected by the endpoint. This
   * controls the shape of the pushed message (i.e., its fields and metadata).
   *
   * If not present during the `CreateSubscription` call, it will default to
   * the version of the Pub/Sub API used to make such call. If not present in a
   * `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
   * calls will always return a valid version, even if the subscription was
   * created without this attribute.
   *
   * The only supported values for the `x-goog-version` attribute are:
   *
   * * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
   * * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
   *
   * For example:
   * `attributes { "x-goog-version": "v1" }`
   *
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string };

  /**
   * An authentication method used by push endpoints to verify the source of
   * push requests. This can be used with push endpoints that are private by
   * default to allow requests only from the Pub/Sub system, for example.
   * This field is optional and should be set only by users interested in
   * authenticated push.
   *
   * @generated from oneof google.pubsub.v1.PushConfig.authentication_method
   */
  authenticationMethod: {
    /**
     * Optional. If specified, Pub/Sub will generate and attach an OIDC JWT
     * token as an `Authorization` header in the HTTP request for every pushed
     * message.
     *
     * @generated from field: google.pubsub.v1.PushConfig.OidcToken oidc_token = 3;
     */
    value: PushConfig_OidcToken;
    case: "oidcToken";
  } | { case: undefined; value?: undefined };

  /**
   * The format of the delivered message to the push endpoint is defined by
   * the chosen wrapper. When unset, `PubsubWrapper` is used.
   *
   * @generated from oneof google.pubsub.v1.PushConfig.wrapper
   */
  wrapper: {
    /**
     * Optional. When set, the payload to the push endpoint is in the form of
     * the JSON representation of a PubsubMessage
     * (https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage).
     *
     * @generated from field: google.pubsub.v1.PushConfig.PubsubWrapper pubsub_wrapper = 4;
     */
    value: PushConfig_PubsubWrapper;
    case: "pubsubWrapper";
  } | {
    /**
     * Optional. When set, the payload to the push endpoint is not wrapped.
     *
     * @generated from field: google.pubsub.v1.PushConfig.NoWrapper no_wrapper = 5;
     */
    value: PushConfig_NoWrapper;
    case: "noWrapper";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.pubsub.v1.PushConfig.
 * Use `create(PushConfigSchema)` to create a new message.
 */
export const PushConfigSchema: GenMessage<PushConfig> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 23);

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 *
 * @generated from message google.pubsub.v1.PushConfig.OidcToken
 */
export type PushConfig_OidcToken = Message<"google.pubsub.v1.PushConfig.OidcToken"> & {
  /**
   * Optional. [Service account
   * email](https://cloud.google.com/iam/docs/service-accounts)
   * used for generating the OIDC token. For more information
   * on setting up authentication, see
   * [Push subscriptions](https://cloud.google.com/pubsub/docs/push).
   *
   * @generated from field: string service_account_email = 1;
   */
  serviceAccountEmail: string;

  /**
   * Optional. Audience to be used when generating OIDC token. The audience
   * claim identifies the recipients that the JWT is intended for. The
   * audience value is a single case-sensitive string. Having multiple values
   * (array) for the audience field is not supported. More info about the OIDC
   * JWT token audience here:
   * https://tools.ietf.org/html/rfc7519#section-4.1.3 Note: if not specified,
   * the Push endpoint URL will be used.
   *
   * @generated from field: string audience = 2;
   */
  audience: string;
};

/**
 * Describes the message google.pubsub.v1.PushConfig.OidcToken.
 * Use `create(PushConfig_OidcTokenSchema)` to create a new message.
 */
export const PushConfig_OidcTokenSchema: GenMessage<PushConfig_OidcToken> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 23, 0);

/**
 * The payload to the push endpoint is in the form of the JSON representation
 * of a PubsubMessage
 * (https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pubsubmessage).
 *
 * @generated from message google.pubsub.v1.PushConfig.PubsubWrapper
 */
export type PushConfig_PubsubWrapper = Message<"google.pubsub.v1.PushConfig.PubsubWrapper"> & {
};

/**
 * Describes the message google.pubsub.v1.PushConfig.PubsubWrapper.
 * Use `create(PushConfig_PubsubWrapperSchema)` to create a new message.
 */
export const PushConfig_PubsubWrapperSchema: GenMessage<PushConfig_PubsubWrapper> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 23, 1);

/**
 * Sets the `data` field as the HTTP body for delivery.
 *
 * @generated from message google.pubsub.v1.PushConfig.NoWrapper
 */
export type PushConfig_NoWrapper = Message<"google.pubsub.v1.PushConfig.NoWrapper"> & {
  /**
   * Optional. When true, writes the Pub/Sub message metadata to
   * `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
   * Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
   *
   * @generated from field: bool write_metadata = 1;
   */
  writeMetadata: boolean;
};

/**
 * Describes the message google.pubsub.v1.PushConfig.NoWrapper.
 * Use `create(PushConfig_NoWrapperSchema)` to create a new message.
 */
export const PushConfig_NoWrapperSchema: GenMessage<PushConfig_NoWrapper> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 23, 2);

/**
 * Configuration for a BigQuery subscription.
 *
 * @generated from message google.pubsub.v1.BigQueryConfig
 */
export type BigQueryConfig = Message<"google.pubsub.v1.BigQueryConfig"> & {
  /**
   * Optional. The name of the table to which to write data, of the form
   * {projectId}.{datasetId}.{tableId}
   *
   * @generated from field: string table = 1;
   */
  table: string;

  /**
   * Optional. When true, use the topic's schema as the columns to write to in
   * BigQuery, if it exists. `use_topic_schema` and `use_table_schema` cannot be
   * enabled at the same time.
   *
   * @generated from field: bool use_topic_schema = 2;
   */
  useTopicSchema: boolean;

  /**
   * Optional. When true, write the subscription name, message_id, publish_time,
   * attributes, and ordering_key to additional columns in the table. The
   * subscription name, message_id, and publish_time fields are put in their own
   * columns while all other message properties (other than data) are written to
   * a JSON object in the attributes column.
   *
   * @generated from field: bool write_metadata = 3;
   */
  writeMetadata: boolean;

  /**
   * Optional. When true and use_topic_schema is true, any fields that are a
   * part of the topic schema that are not part of the BigQuery table schema are
   * dropped when writing to BigQuery. Otherwise, the schemas must be kept in
   * sync and any messages with extra fields are not written and remain in the
   * subscription's backlog.
   *
   * @generated from field: bool drop_unknown_fields = 4;
   */
  dropUnknownFields: boolean;

  /**
   * Output only. An output-only field that indicates whether or not the
   * subscription can receive messages.
   *
   * @generated from field: google.pubsub.v1.BigQueryConfig.State state = 5;
   */
  state: BigQueryConfig_State;

  /**
   * Optional. When true, use the BigQuery table's schema as the columns to
   * write to in BigQuery. `use_table_schema` and `use_topic_schema` cannot be
   * enabled at the same time.
   *
   * @generated from field: bool use_table_schema = 6;
   */
  useTableSchema: boolean;

  /**
   * Optional. The service account to use to write to BigQuery. The subscription
   * creator or updater that specifies this field must have
   * `iam.serviceAccounts.actAs` permission on the service account. If not
   * specified, the Pub/Sub [service
   * agent](https://cloud.google.com/iam/docs/service-agents),
   * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
   *
   * @generated from field: string service_account_email = 7;
   */
  serviceAccountEmail: string;
};

/**
 * Describes the message google.pubsub.v1.BigQueryConfig.
 * Use `create(BigQueryConfigSchema)` to create a new message.
 */
export const BigQueryConfigSchema: GenMessage<BigQueryConfig> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 24);

/**
 * Possible states for a BigQuery subscription.
 *
 * @generated from enum google.pubsub.v1.BigQueryConfig.State
 */
export enum BigQueryConfig_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The subscription can actively send messages to BigQuery
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Cannot write to the BigQuery table because of permission denied errors.
   * This can happen if
   * - Pub/Sub SA has not been granted the [appropriate BigQuery IAM
   * permissions](https://cloud.google.com/pubsub/docs/create-subscription#assign_bigquery_service_account)
   * - bigquery.googleapis.com API is not enabled for the project
   * ([instructions](https://cloud.google.com/service-usage/docs/enable-disable))
   *
   * @generated from enum value: PERMISSION_DENIED = 2;
   */
  PERMISSION_DENIED = 2,

  /**
   * Cannot write to the BigQuery table because it does not exist.
   *
   * @generated from enum value: NOT_FOUND = 3;
   */
  NOT_FOUND = 3,

  /**
   * Cannot write to the BigQuery table due to a schema mismatch.
   *
   * @generated from enum value: SCHEMA_MISMATCH = 4;
   */
  SCHEMA_MISMATCH = 4,

  /**
   * Cannot write to the destination because enforce_in_transit is set to true
   * and the destination locations are not in the allowed regions.
   *
   * @generated from enum value: IN_TRANSIT_LOCATION_RESTRICTION = 5;
   */
  IN_TRANSIT_LOCATION_RESTRICTION = 5,
}

/**
 * Describes the enum google.pubsub.v1.BigQueryConfig.State.
 */
export const BigQueryConfig_StateSchema: GenEnum<BigQueryConfig_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 24, 0);

/**
 * Configuration for a Cloud Storage subscription.
 *
 * @generated from message google.pubsub.v1.CloudStorageConfig
 */
export type CloudStorageConfig = Message<"google.pubsub.v1.CloudStorageConfig"> & {
  /**
   * Required. User-provided name for the Cloud Storage bucket.
   * The bucket must be created by the user. The bucket name must be without
   * any prefix like "gs://". See the [bucket naming
   * requirements] (https://cloud.google.com/storage/docs/buckets#naming).
   *
   * @generated from field: string bucket = 1;
   */
  bucket: string;

  /**
   * Optional. User-provided prefix for Cloud Storage filename. See the [object
   * naming requirements](https://cloud.google.com/storage/docs/objects#naming).
   *
   * @generated from field: string filename_prefix = 2;
   */
  filenamePrefix: string;

  /**
   * Optional. User-provided suffix for Cloud Storage filename. See the [object
   * naming requirements](https://cloud.google.com/storage/docs/objects#naming).
   * Must not end in "/".
   *
   * @generated from field: string filename_suffix = 3;
   */
  filenameSuffix: string;

  /**
   * Optional. User-provided format string specifying how to represent datetimes
   * in Cloud Storage filenames. See the [datetime format
   * guidance](https://cloud.google.com/pubsub/docs/create-cloudstorage-subscription#file_names).
   *
   * @generated from field: string filename_datetime_format = 10;
   */
  filenameDatetimeFormat: string;

  /**
   * Defaults to text format.
   *
   * @generated from oneof google.pubsub.v1.CloudStorageConfig.output_format
   */
  outputFormat: {
    /**
     * Optional. If set, message data will be written to Cloud Storage in text
     * format.
     *
     * @generated from field: google.pubsub.v1.CloudStorageConfig.TextConfig text_config = 4;
     */
    value: CloudStorageConfig_TextConfig;
    case: "textConfig";
  } | {
    /**
     * Optional. If set, message data will be written to Cloud Storage in Avro
     * format.
     *
     * @generated from field: google.pubsub.v1.CloudStorageConfig.AvroConfig avro_config = 5;
     */
    value: CloudStorageConfig_AvroConfig;
    case: "avroConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. The maximum duration that can elapse before a new Cloud Storage
   * file is created. Min 1 minute, max 10 minutes, default 5 minutes. May not
   * exceed the subscription's acknowledgement deadline.
   *
   * @generated from field: google.protobuf.Duration max_duration = 6;
   */
  maxDuration?: Duration;

  /**
   * Optional. The maximum bytes that can be written to a Cloud Storage file
   * before a new file is created. Min 1 KB, max 10 GiB. The max_bytes limit may
   * be exceeded in cases where messages are larger than the limit.
   *
   * @generated from field: int64 max_bytes = 7;
   */
  maxBytes: bigint;

  /**
   * Optional. The maximum number of messages that can be written to a Cloud
   * Storage file before a new file is created. Min 1000 messages.
   *
   * @generated from field: int64 max_messages = 8;
   */
  maxMessages: bigint;

  /**
   * Output only. An output-only field that indicates whether or not the
   * subscription can receive messages.
   *
   * @generated from field: google.pubsub.v1.CloudStorageConfig.State state = 9;
   */
  state: CloudStorageConfig_State;

  /**
   * Optional. The service account to use to write to Cloud Storage. The
   * subscription creator or updater that specifies this field must have
   * `iam.serviceAccounts.actAs` permission on the service account. If not
   * specified, the Pub/Sub
   * [service agent](https://cloud.google.com/iam/docs/service-agents),
   * service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
   *
   * @generated from field: string service_account_email = 11;
   */
  serviceAccountEmail: string;
};

/**
 * Describes the message google.pubsub.v1.CloudStorageConfig.
 * Use `create(CloudStorageConfigSchema)` to create a new message.
 */
export const CloudStorageConfigSchema: GenMessage<CloudStorageConfig> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 25);

/**
 * Configuration for writing message data in text format.
 * Message payloads will be written to files as raw text, separated by a
 * newline.
 *
 * @generated from message google.pubsub.v1.CloudStorageConfig.TextConfig
 */
export type CloudStorageConfig_TextConfig = Message<"google.pubsub.v1.CloudStorageConfig.TextConfig"> & {
};

/**
 * Describes the message google.pubsub.v1.CloudStorageConfig.TextConfig.
 * Use `create(CloudStorageConfig_TextConfigSchema)` to create a new message.
 */
export const CloudStorageConfig_TextConfigSchema: GenMessage<CloudStorageConfig_TextConfig> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 25, 0);

/**
 * Configuration for writing message data in Avro format.
 * Message payloads and metadata will be written to files as an Avro binary.
 *
 * @generated from message google.pubsub.v1.CloudStorageConfig.AvroConfig
 */
export type CloudStorageConfig_AvroConfig = Message<"google.pubsub.v1.CloudStorageConfig.AvroConfig"> & {
  /**
   * Optional. When true, write the subscription name, message_id,
   * publish_time, attributes, and ordering_key as additional fields in the
   * output. The subscription name, message_id, and publish_time fields are
   * put in their own fields while all other message properties other than
   * data (for example, an ordering_key, if present) are added as entries in
   * the attributes map.
   *
   * @generated from field: bool write_metadata = 1;
   */
  writeMetadata: boolean;

  /**
   * Optional. When true, the output Cloud Storage file will be serialized
   * using the topic schema, if it exists.
   *
   * @generated from field: bool use_topic_schema = 2;
   */
  useTopicSchema: boolean;
};

/**
 * Describes the message google.pubsub.v1.CloudStorageConfig.AvroConfig.
 * Use `create(CloudStorageConfig_AvroConfigSchema)` to create a new message.
 */
export const CloudStorageConfig_AvroConfigSchema: GenMessage<CloudStorageConfig_AvroConfig> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 25, 1);

/**
 * Possible states for a Cloud Storage subscription.
 *
 * @generated from enum google.pubsub.v1.CloudStorageConfig.State
 */
export enum CloudStorageConfig_State {
  /**
   * Default value. This value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The subscription can actively send messages to Cloud Storage.
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Cannot write to the Cloud Storage bucket because of permission denied
   * errors.
   *
   * @generated from enum value: PERMISSION_DENIED = 2;
   */
  PERMISSION_DENIED = 2,

  /**
   * Cannot write to the Cloud Storage bucket because it does not exist.
   *
   * @generated from enum value: NOT_FOUND = 3;
   */
  NOT_FOUND = 3,

  /**
   * Cannot write to the destination because enforce_in_transit is set to true
   * and the destination locations are not in the allowed regions.
   *
   * @generated from enum value: IN_TRANSIT_LOCATION_RESTRICTION = 4;
   */
  IN_TRANSIT_LOCATION_RESTRICTION = 4,

  /**
   * Cannot write to the Cloud Storage bucket due to an incompatibility
   * between the topic schema and subscription settings.
   *
   * @generated from enum value: SCHEMA_MISMATCH = 5;
   */
  SCHEMA_MISMATCH = 5,
}

/**
 * Describes the enum google.pubsub.v1.CloudStorageConfig.State.
 */
export const CloudStorageConfig_StateSchema: GenEnum<CloudStorageConfig_State> = /*@__PURE__*/
  enumDesc(file_google_pubsub_v1_pubsub, 25, 0);

/**
 * A message and its corresponding acknowledgment ID.
 *
 * @generated from message google.pubsub.v1.ReceivedMessage
 */
export type ReceivedMessage = Message<"google.pubsub.v1.ReceivedMessage"> & {
  /**
   * Optional. This ID can be used to acknowledge the received message.
   *
   * @generated from field: string ack_id = 1;
   */
  ackId: string;

  /**
   * Optional. The message.
   *
   * @generated from field: google.pubsub.v1.PubsubMessage message = 2;
   */
  message?: PubsubMessage;

  /**
   * Optional. The approximate number of times that Pub/Sub has attempted to
   * deliver the associated message to a subscriber.
   *
   * More precisely, this is 1 + (number of NACKs) +
   * (number of ack_deadline exceeds) for this message.
   *
   * A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline
   * exceeds event is whenever a message is not acknowledged within
   * ack_deadline. Note that ack_deadline is initially
   * Subscription.ackDeadlineSeconds, but may get extended automatically by
   * the client library.
   *
   * Upon the first delivery of a given message, `delivery_attempt` will have a
   * value of 1. The value is calculated at best effort and is approximate.
   *
   * If a DeadLetterPolicy is not set on the subscription, this will be 0.
   *
   * @generated from field: int32 delivery_attempt = 3;
   */
  deliveryAttempt: number;
};

/**
 * Describes the message google.pubsub.v1.ReceivedMessage.
 * Use `create(ReceivedMessageSchema)` to create a new message.
 */
export const ReceivedMessageSchema: GenMessage<ReceivedMessage> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 26);

/**
 * Request for the GetSubscription method.
 *
 * @generated from message google.pubsub.v1.GetSubscriptionRequest
 */
export type GetSubscriptionRequest = Message<"google.pubsub.v1.GetSubscriptionRequest"> & {
  /**
   * Required. The name of the subscription to get.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;
};

/**
 * Describes the message google.pubsub.v1.GetSubscriptionRequest.
 * Use `create(GetSubscriptionRequestSchema)` to create a new message.
 */
export const GetSubscriptionRequestSchema: GenMessage<GetSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 27);

/**
 * Request for the UpdateSubscription method.
 *
 * @generated from message google.pubsub.v1.UpdateSubscriptionRequest
 */
export type UpdateSubscriptionRequest = Message<"google.pubsub.v1.UpdateSubscriptionRequest"> & {
  /**
   * Required. The updated subscription object.
   *
   * @generated from field: google.pubsub.v1.Subscription subscription = 1;
   */
  subscription?: Subscription;

  /**
   * Required. Indicates which fields in the provided subscription to update.
   * Must be specified and non-empty.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.pubsub.v1.UpdateSubscriptionRequest.
 * Use `create(UpdateSubscriptionRequestSchema)` to create a new message.
 */
export const UpdateSubscriptionRequestSchema: GenMessage<UpdateSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 28);

/**
 * Request for the `ListSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListSubscriptionsRequest
 */
export type ListSubscriptionsRequest = Message<"google.pubsub.v1.ListSubscriptionsRequest"> & {
  /**
   * Required. The name of the project in which to list subscriptions.
   * Format is `projects/{project-id}`.
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * Optional. Maximum number of subscriptions to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. The value returned by the last `ListSubscriptionsResponse`;
   * indicates that this is a continuation of a prior `ListSubscriptions` call,
   * and that the system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListSubscriptionsRequest.
 * Use `create(ListSubscriptionsRequestSchema)` to create a new message.
 */
export const ListSubscriptionsRequestSchema: GenMessage<ListSubscriptionsRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 29);

/**
 * Response for the `ListSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListSubscriptionsResponse
 */
export type ListSubscriptionsResponse = Message<"google.pubsub.v1.ListSubscriptionsResponse"> & {
  /**
   * Optional. The subscriptions that match the request.
   *
   * @generated from field: repeated google.pubsub.v1.Subscription subscriptions = 1;
   */
  subscriptions: Subscription[];

  /**
   * Optional. If not empty, indicates that there may be more subscriptions that
   * match the request; this value should be passed in a new
   * `ListSubscriptionsRequest` to get more subscriptions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListSubscriptionsResponse.
 * Use `create(ListSubscriptionsResponseSchema)` to create a new message.
 */
export const ListSubscriptionsResponseSchema: GenMessage<ListSubscriptionsResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 30);

/**
 * Request for the DeleteSubscription method.
 *
 * @generated from message google.pubsub.v1.DeleteSubscriptionRequest
 */
export type DeleteSubscriptionRequest = Message<"google.pubsub.v1.DeleteSubscriptionRequest"> & {
  /**
   * Required. The subscription to delete.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;
};

/**
 * Describes the message google.pubsub.v1.DeleteSubscriptionRequest.
 * Use `create(DeleteSubscriptionRequestSchema)` to create a new message.
 */
export const DeleteSubscriptionRequestSchema: GenMessage<DeleteSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 31);

/**
 * Request for the ModifyPushConfig method.
 *
 * @generated from message google.pubsub.v1.ModifyPushConfigRequest
 */
export type ModifyPushConfigRequest = Message<"google.pubsub.v1.ModifyPushConfigRequest"> & {
  /**
   * Required. The name of the subscription.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * Required. The push configuration for future deliveries.
   *
   * An empty `pushConfig` indicates that the Pub/Sub system should
   * stop pushing messages from the given subscription and allow
   * messages to be pulled and acknowledged - effectively pausing
   * the subscription if `Pull` or `StreamingPull` is not called.
   *
   * @generated from field: google.pubsub.v1.PushConfig push_config = 2;
   */
  pushConfig?: PushConfig;
};

/**
 * Describes the message google.pubsub.v1.ModifyPushConfigRequest.
 * Use `create(ModifyPushConfigRequestSchema)` to create a new message.
 */
export const ModifyPushConfigRequestSchema: GenMessage<ModifyPushConfigRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 32);

/**
 * Request for the `Pull` method.
 *
 * @generated from message google.pubsub.v1.PullRequest
 */
export type PullRequest = Message<"google.pubsub.v1.PullRequest"> & {
  /**
   * Required. The subscription from which messages should be pulled.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * Optional. If this field set to true, the system will respond immediately
   * even if it there are no messages available to return in the `Pull`
   * response. Otherwise, the system may wait (for a bounded amount of time)
   * until at least one message is available, rather than returning no messages.
   * Warning: setting this field to `true` is discouraged because it adversely
   * impacts the performance of `Pull` operations. We recommend that users do
   * not set this field.
   *
   * @generated from field: bool return_immediately = 2 [deprecated = true];
   * @deprecated
   */
  returnImmediately: boolean;

  /**
   * Required. The maximum number of messages to return for this request. Must
   * be a positive integer. The Pub/Sub system may return fewer than the number
   * specified.
   *
   * @generated from field: int32 max_messages = 3;
   */
  maxMessages: number;
};

/**
 * Describes the message google.pubsub.v1.PullRequest.
 * Use `create(PullRequestSchema)` to create a new message.
 */
export const PullRequestSchema: GenMessage<PullRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 33);

/**
 * Response for the `Pull` method.
 *
 * @generated from message google.pubsub.v1.PullResponse
 */
export type PullResponse = Message<"google.pubsub.v1.PullResponse"> & {
  /**
   * Optional. Received Pub/Sub messages. The list will be empty if there are no
   * more messages available in the backlog, or if no messages could be returned
   * before the request timeout. For JSON, the response can be entirely
   * empty. The Pub/Sub system may return fewer than the `maxMessages` requested
   * even if there are more messages available in the backlog.
   *
   * @generated from field: repeated google.pubsub.v1.ReceivedMessage received_messages = 1;
   */
  receivedMessages: ReceivedMessage[];
};

/**
 * Describes the message google.pubsub.v1.PullResponse.
 * Use `create(PullResponseSchema)` to create a new message.
 */
export const PullResponseSchema: GenMessage<PullResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 34);

/**
 * Request for the ModifyAckDeadline method.
 *
 * @generated from message google.pubsub.v1.ModifyAckDeadlineRequest
 */
export type ModifyAckDeadlineRequest = Message<"google.pubsub.v1.ModifyAckDeadlineRequest"> & {
  /**
   * Required. The name of the subscription.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * Required. List of acknowledgment IDs.
   *
   * @generated from field: repeated string ack_ids = 4;
   */
  ackIds: string[];

  /**
   * Required. The new ack deadline with respect to the time this request was
   * sent to the Pub/Sub system. For example, if the value is 10, the new ack
   * deadline will expire 10 seconds after the `ModifyAckDeadline` call was
   * made. Specifying zero might immediately make the message available for
   * delivery to another subscriber client. This typically results in an
   * increase in the rate of message redeliveries (that is, duplicates).
   * The minimum deadline you can specify is 0 seconds.
   * The maximum deadline you can specify in a single request is 600 seconds
   * (10 minutes).
   *
   * @generated from field: int32 ack_deadline_seconds = 3;
   */
  ackDeadlineSeconds: number;
};

/**
 * Describes the message google.pubsub.v1.ModifyAckDeadlineRequest.
 * Use `create(ModifyAckDeadlineRequestSchema)` to create a new message.
 */
export const ModifyAckDeadlineRequestSchema: GenMessage<ModifyAckDeadlineRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 35);

/**
 * Request for the Acknowledge method.
 *
 * @generated from message google.pubsub.v1.AcknowledgeRequest
 */
export type AcknowledgeRequest = Message<"google.pubsub.v1.AcknowledgeRequest"> & {
  /**
   * Required. The subscription whose message is being acknowledged.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * Required. The acknowledgment ID for the messages being acknowledged that
   * was returned by the Pub/Sub system in the `Pull` response. Must not be
   * empty.
   *
   * @generated from field: repeated string ack_ids = 2;
   */
  ackIds: string[];
};

/**
 * Describes the message google.pubsub.v1.AcknowledgeRequest.
 * Use `create(AcknowledgeRequestSchema)` to create a new message.
 */
export const AcknowledgeRequestSchema: GenMessage<AcknowledgeRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 36);

/**
 * Request for the `StreamingPull` streaming RPC method. This request is used to
 * establish the initial stream as well as to stream acknowledgements and ack
 * deadline modifications from the client to the server.
 *
 * @generated from message google.pubsub.v1.StreamingPullRequest
 */
export type StreamingPullRequest = Message<"google.pubsub.v1.StreamingPullRequest"> & {
  /**
   * Required. The subscription for which to initialize the new stream. This
   * must be provided in the first request on the stream, and must not be set in
   * subsequent requests from client to server.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * Optional. List of acknowledgement IDs for acknowledging previously received
   * messages (received on this stream or a different stream). If an ack ID has
   * expired, the corresponding message may be redelivered later. Acknowledging
   * a message more than once will not result in an error. If the
   * acknowledgement ID is malformed, the stream will be aborted with status
   * `INVALID_ARGUMENT`.
   *
   * @generated from field: repeated string ack_ids = 2;
   */
  ackIds: string[];

  /**
   * Optional. The list of new ack deadlines for the IDs listed in
   * `modify_deadline_ack_ids`. The size of this list must be the same as the
   * size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
   * with `INVALID_ARGUMENT`. Each element in this list is applied to the
   * element in the same position in `modify_deadline_ack_ids`. The new ack
   * deadline is with respect to the time this request was sent to the Pub/Sub
   * system. Must be >= 0. For example, if the value is 10, the new ack deadline
   * will expire 10 seconds after this request is received. If the value is 0,
   * the message is immediately made available for another streaming or
   * non-streaming pull request. If the value is < 0 (an error), the stream will
   * be aborted with status `INVALID_ARGUMENT`.
   *
   * @generated from field: repeated int32 modify_deadline_seconds = 3;
   */
  modifyDeadlineSeconds: number[];

  /**
   * Optional. List of acknowledgement IDs whose deadline will be modified based
   * on the corresponding element in `modify_deadline_seconds`. This field can
   * be used to indicate that more time is needed to process a message by the
   * subscriber, or to make the message available for redelivery if the
   * processing was interrupted.
   *
   * @generated from field: repeated string modify_deadline_ack_ids = 4;
   */
  modifyDeadlineAckIds: string[];

  /**
   * Required. The ack deadline to use for the stream. This must be provided in
   * the first request on the stream, but it can also be updated on subsequent
   * requests from client to server. The minimum deadline you can specify is 10
   * seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
   *
   * @generated from field: int32 stream_ack_deadline_seconds = 5;
   */
  streamAckDeadlineSeconds: number;

  /**
   * Optional. A unique identifier that is used to distinguish client instances
   * from each other. Only needs to be provided on the initial request. When a
   * stream disconnects and reconnects for the same stream, the client_id should
   * be set to the same value so that state associated with the old stream can
   * be transferred to the new stream. The same client_id should not be used for
   * different client instances.
   *
   * @generated from field: string client_id = 6;
   */
  clientId: string;

  /**
   * Optional. Flow control settings for the maximum number of outstanding
   * messages. When there are `max_outstanding_messages` currently sent to the
   * streaming pull client that have not yet been acked or nacked, the server
   * stops sending more messages. The sending of messages resumes once the
   * number of outstanding messages is less than this value. If the value is
   * <= 0, there is no limit to the number of outstanding messages. This
   * property can only be set on the initial StreamingPullRequest. If it is set
   * on a subsequent request, the stream will be aborted with status
   * `INVALID_ARGUMENT`.
   *
   * @generated from field: int64 max_outstanding_messages = 7;
   */
  maxOutstandingMessages: bigint;

  /**
   * Optional. Flow control settings for the maximum number of outstanding
   * bytes. When there are `max_outstanding_bytes` or more worth of messages
   * currently sent to the streaming pull client that have not yet been acked or
   * nacked, the server will stop sending more messages. The sending of messages
   * resumes once the number of outstanding bytes is less than this value. If
   * the value is <= 0, there is no limit to the number of outstanding bytes.
   * This property can only be set on the initial StreamingPullRequest. If it is
   * set on a subsequent request, the stream will be aborted with status
   * `INVALID_ARGUMENT`.
   *
   * @generated from field: int64 max_outstanding_bytes = 8;
   */
  maxOutstandingBytes: bigint;
};

/**
 * Describes the message google.pubsub.v1.StreamingPullRequest.
 * Use `create(StreamingPullRequestSchema)` to create a new message.
 */
export const StreamingPullRequestSchema: GenMessage<StreamingPullRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 37);

/**
 * Response for the `StreamingPull` method. This response is used to stream
 * messages from the server to the client.
 *
 * @generated from message google.pubsub.v1.StreamingPullResponse
 */
export type StreamingPullResponse = Message<"google.pubsub.v1.StreamingPullResponse"> & {
  /**
   * Optional. Received Pub/Sub messages. This will not be empty.
   *
   * @generated from field: repeated google.pubsub.v1.ReceivedMessage received_messages = 1;
   */
  receivedMessages: ReceivedMessage[];

  /**
   * Optional. This field will only be set if `enable_exactly_once_delivery` is
   * set to `true`.
   *
   * @generated from field: google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation acknowledge_confirmation = 5;
   */
  acknowledgeConfirmation?: StreamingPullResponse_AcknowledgeConfirmation;

  /**
   * Optional. This field will only be set if `enable_exactly_once_delivery` is
   * set to `true`.
   *
   * @generated from field: google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation modify_ack_deadline_confirmation = 3;
   */
  modifyAckDeadlineConfirmation?: StreamingPullResponse_ModifyAckDeadlineConfirmation;

  /**
   * Optional. Properties associated with this subscription.
   *
   * @generated from field: google.pubsub.v1.StreamingPullResponse.SubscriptionProperties subscription_properties = 4;
   */
  subscriptionProperties?: StreamingPullResponse_SubscriptionProperties;
};

/**
 * Describes the message google.pubsub.v1.StreamingPullResponse.
 * Use `create(StreamingPullResponseSchema)` to create a new message.
 */
export const StreamingPullResponseSchema: GenMessage<StreamingPullResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 38);

/**
 * Acknowledgement IDs sent in one or more previous requests to acknowledge a
 * previously received message.
 *
 * @generated from message google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation
 */
export type StreamingPullResponse_AcknowledgeConfirmation = Message<"google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation"> & {
  /**
   * Optional. Successfully processed acknowledgement IDs.
   *
   * @generated from field: repeated string ack_ids = 1;
   */
  ackIds: string[];

  /**
   * Optional. List of acknowledgement IDs that were malformed or whose
   * acknowledgement deadline has expired.
   *
   * @generated from field: repeated string invalid_ack_ids = 2;
   */
  invalidAckIds: string[];

  /**
   * Optional. List of acknowledgement IDs that were out of order.
   *
   * @generated from field: repeated string unordered_ack_ids = 3;
   */
  unorderedAckIds: string[];

  /**
   * Optional. List of acknowledgement IDs that failed processing with
   * temporary issues.
   *
   * @generated from field: repeated string temporary_failed_ack_ids = 4;
   */
  temporaryFailedAckIds: string[];
};

/**
 * Describes the message google.pubsub.v1.StreamingPullResponse.AcknowledgeConfirmation.
 * Use `create(StreamingPullResponse_AcknowledgeConfirmationSchema)` to create a new message.
 */
export const StreamingPullResponse_AcknowledgeConfirmationSchema: GenMessage<StreamingPullResponse_AcknowledgeConfirmation> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 38, 0);

/**
 * Acknowledgement IDs sent in one or more previous requests to modify the
 * deadline for a specific message.
 *
 * @generated from message google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation
 */
export type StreamingPullResponse_ModifyAckDeadlineConfirmation = Message<"google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation"> & {
  /**
   * Optional. Successfully processed acknowledgement IDs.
   *
   * @generated from field: repeated string ack_ids = 1;
   */
  ackIds: string[];

  /**
   * Optional. List of acknowledgement IDs that were malformed or whose
   * acknowledgement deadline has expired.
   *
   * @generated from field: repeated string invalid_ack_ids = 2;
   */
  invalidAckIds: string[];

  /**
   * Optional. List of acknowledgement IDs that failed processing with
   * temporary issues.
   *
   * @generated from field: repeated string temporary_failed_ack_ids = 3;
   */
  temporaryFailedAckIds: string[];
};

/**
 * Describes the message google.pubsub.v1.StreamingPullResponse.ModifyAckDeadlineConfirmation.
 * Use `create(StreamingPullResponse_ModifyAckDeadlineConfirmationSchema)` to create a new message.
 */
export const StreamingPullResponse_ModifyAckDeadlineConfirmationSchema: GenMessage<StreamingPullResponse_ModifyAckDeadlineConfirmation> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 38, 1);

/**
 * Subscription properties sent as part of the response.
 *
 * @generated from message google.pubsub.v1.StreamingPullResponse.SubscriptionProperties
 */
export type StreamingPullResponse_SubscriptionProperties = Message<"google.pubsub.v1.StreamingPullResponse.SubscriptionProperties"> & {
  /**
   * Optional. True iff exactly once delivery is enabled for this
   * subscription.
   *
   * @generated from field: bool exactly_once_delivery_enabled = 1;
   */
  exactlyOnceDeliveryEnabled: boolean;

  /**
   * Optional. True iff message ordering is enabled for this subscription.
   *
   * @generated from field: bool message_ordering_enabled = 2;
   */
  messageOrderingEnabled: boolean;
};

/**
 * Describes the message google.pubsub.v1.StreamingPullResponse.SubscriptionProperties.
 * Use `create(StreamingPullResponse_SubscriptionPropertiesSchema)` to create a new message.
 */
export const StreamingPullResponse_SubscriptionPropertiesSchema: GenMessage<StreamingPullResponse_SubscriptionProperties> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 38, 2);

/**
 * Request for the `CreateSnapshot` method.
 *
 * @generated from message google.pubsub.v1.CreateSnapshotRequest
 */
export type CreateSnapshotRequest = Message<"google.pubsub.v1.CreateSnapshotRequest"> & {
  /**
   * Required. User-provided name for this snapshot. If the name is not provided
   * in the request, the server will assign a random name for this snapshot on
   * the same project as the subscription. Note that for REST API requests, you
   * must specify a name.  See the [resource name
   * rules](https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
   * Format is `projects/{project}/snapshots/{snap}`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Required. The subscription whose backlog the snapshot retains.
   * Specifically, the created snapshot is guaranteed to retain:
   *  (a) The existing backlog on the subscription. More precisely, this is
   *      defined as the messages in the subscription's backlog that are
   *      unacknowledged upon the successful completion of the
   *      `CreateSnapshot` request; as well as:
   *  (b) Any messages published to the subscription's topic following the
   *      successful completion of the CreateSnapshot request.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 2;
   */
  subscription: string;

  /**
   * Optional. See [Creating and managing
   * labels](https://cloud.google.com/pubsub/docs/labels).
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.pubsub.v1.CreateSnapshotRequest.
 * Use `create(CreateSnapshotRequestSchema)` to create a new message.
 */
export const CreateSnapshotRequestSchema: GenMessage<CreateSnapshotRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 39);

/**
 * Request for the UpdateSnapshot method.
 *
 * @generated from message google.pubsub.v1.UpdateSnapshotRequest
 */
export type UpdateSnapshotRequest = Message<"google.pubsub.v1.UpdateSnapshotRequest"> & {
  /**
   * Required. The updated snapshot object.
   *
   * @generated from field: google.pubsub.v1.Snapshot snapshot = 1;
   */
  snapshot?: Snapshot;

  /**
   * Required. Indicates which fields in the provided snapshot to update.
   * Must be specified and non-empty.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message google.pubsub.v1.UpdateSnapshotRequest.
 * Use `create(UpdateSnapshotRequestSchema)` to create a new message.
 */
export const UpdateSnapshotRequestSchema: GenMessage<UpdateSnapshotRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 40);

/**
 * A snapshot resource. Snapshots are used in
 * [Seek](https://cloud.google.com/pubsub/docs/replay-overview)
 * operations, which allow you to manage message acknowledgments in bulk. That
 * is, you can set the acknowledgment state of messages in an existing
 * subscription to the state captured by a snapshot.
 *
 * @generated from message google.pubsub.v1.Snapshot
 */
export type Snapshot = Message<"google.pubsub.v1.Snapshot"> & {
  /**
   * Optional. The name of the snapshot.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional. The name of the topic from which this snapshot is retaining
   * messages.
   *
   * @generated from field: string topic = 2;
   */
  topic: string;

  /**
   * Optional. The snapshot is guaranteed to exist up until this time.
   * A newly-created snapshot expires no later than 7 days from the time of its
   * creation. Its exact lifetime is determined at creation by the existing
   * backlog in the source subscription. Specifically, the lifetime of the
   * snapshot is `7 days - (age of oldest unacked message in the subscription)`.
   * For example, consider a subscription whose oldest unacked message is 3 days
   * old. If a snapshot is created from this subscription, the snapshot -- which
   * will always capture this 3-day-old backlog as long as the snapshot
   * exists -- will expire in 4 days. The service will refuse to create a
   * snapshot that would expire in less than 1 hour after creation.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 3;
   */
  expireTime?: Timestamp;

  /**
   * Optional. See [Creating and managing labels]
   * (https://cloud.google.com/pubsub/docs/labels).
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message google.pubsub.v1.Snapshot.
 * Use `create(SnapshotSchema)` to create a new message.
 */
export const SnapshotSchema: GenMessage<Snapshot> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 41);

/**
 * Request for the GetSnapshot method.
 *
 * @generated from message google.pubsub.v1.GetSnapshotRequest
 */
export type GetSnapshotRequest = Message<"google.pubsub.v1.GetSnapshotRequest"> & {
  /**
   * Required. The name of the snapshot to get.
   * Format is `projects/{project}/snapshots/{snap}`.
   *
   * @generated from field: string snapshot = 1;
   */
  snapshot: string;
};

/**
 * Describes the message google.pubsub.v1.GetSnapshotRequest.
 * Use `create(GetSnapshotRequestSchema)` to create a new message.
 */
export const GetSnapshotRequestSchema: GenMessage<GetSnapshotRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 42);

/**
 * Request for the `ListSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListSnapshotsRequest
 */
export type ListSnapshotsRequest = Message<"google.pubsub.v1.ListSnapshotsRequest"> & {
  /**
   * Required. The name of the project in which to list snapshots.
   * Format is `projects/{project-id}`.
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * Optional. Maximum number of snapshots to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Optional. The value returned by the last `ListSnapshotsResponse`; indicates
   * that this is a continuation of a prior `ListSnapshots` call, and that the
   * system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListSnapshotsRequest.
 * Use `create(ListSnapshotsRequestSchema)` to create a new message.
 */
export const ListSnapshotsRequestSchema: GenMessage<ListSnapshotsRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 43);

/**
 * Response for the `ListSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListSnapshotsResponse
 */
export type ListSnapshotsResponse = Message<"google.pubsub.v1.ListSnapshotsResponse"> & {
  /**
   * Optional. The resulting snapshots.
   *
   * @generated from field: repeated google.pubsub.v1.Snapshot snapshots = 1;
   */
  snapshots: Snapshot[];

  /**
   * Optional. If not empty, indicates that there may be more snapshot that
   * match the request; this value should be passed in a new
   * `ListSnapshotsRequest`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message google.pubsub.v1.ListSnapshotsResponse.
 * Use `create(ListSnapshotsResponseSchema)` to create a new message.
 */
export const ListSnapshotsResponseSchema: GenMessage<ListSnapshotsResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 44);

/**
 * Request for the `DeleteSnapshot` method.
 *
 * @generated from message google.pubsub.v1.DeleteSnapshotRequest
 */
export type DeleteSnapshotRequest = Message<"google.pubsub.v1.DeleteSnapshotRequest"> & {
  /**
   * Required. The name of the snapshot to delete.
   * Format is `projects/{project}/snapshots/{snap}`.
   *
   * @generated from field: string snapshot = 1;
   */
  snapshot: string;
};

/**
 * Describes the message google.pubsub.v1.DeleteSnapshotRequest.
 * Use `create(DeleteSnapshotRequestSchema)` to create a new message.
 */
export const DeleteSnapshotRequestSchema: GenMessage<DeleteSnapshotRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 45);

/**
 * Request for the `Seek` method.
 *
 * @generated from message google.pubsub.v1.SeekRequest
 */
export type SeekRequest = Message<"google.pubsub.v1.SeekRequest"> & {
  /**
   * Required. The subscription to affect.
   *
   * @generated from field: string subscription = 1;
   */
  subscription: string;

  /**
   * @generated from oneof google.pubsub.v1.SeekRequest.target
   */
  target: {
    /**
     * Optional. The time to seek to.
     * Messages retained in the subscription that were published before this
     * time are marked as acknowledged, and messages retained in the
     * subscription that were published after this time are marked as
     * unacknowledged. Note that this operation affects only those messages
     * retained in the subscription (configured by the combination of
     * `message_retention_duration` and `retain_acked_messages`). For example,
     * if `time` corresponds to a point before the message retention
     * window (or to a point before the system's notion of the subscription
     * creation time), only retained messages will be marked as unacknowledged,
     * and already-expunged messages will not be restored.
     *
     * @generated from field: google.protobuf.Timestamp time = 2;
     */
    value: Timestamp;
    case: "time";
  } | {
    /**
     * Optional. The snapshot to seek to. The snapshot's topic must be the same
     * as that of the provided subscription. Format is
     * `projects/{project}/snapshots/{snap}`.
     *
     * @generated from field: string snapshot = 3;
     */
    value: string;
    case: "snapshot";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message google.pubsub.v1.SeekRequest.
 * Use `create(SeekRequestSchema)` to create a new message.
 */
export const SeekRequestSchema: GenMessage<SeekRequest> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 46);

/**
 * Response for the `Seek` method (this response is empty).
 *
 * @generated from message google.pubsub.v1.SeekResponse
 */
export type SeekResponse = Message<"google.pubsub.v1.SeekResponse"> & {
};

/**
 * Describes the message google.pubsub.v1.SeekResponse.
 * Use `create(SeekResponseSchema)` to create a new message.
 */
export const SeekResponseSchema: GenMessage<SeekResponse> = /*@__PURE__*/
  messageDesc(file_google_pubsub_v1_pubsub, 47);

/**
 * The service that an application uses to manipulate topics, and to send
 * messages to a topic.
 *
 * @generated from service google.pubsub.v1.Publisher
 */
export const Publisher: GenService<{
  /**
   * Creates the given topic with the given name. See the [resource name rules]
   * (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
   *
   * @generated from rpc google.pubsub.v1.Publisher.CreateTopic
   */
  createTopic: {
    methodKind: "unary";
    input: typeof TopicSchema;
    output: typeof TopicSchema;
  },
  /**
   * Updates an existing topic by updating the fields specified in the update
   * mask. Note that certain properties of a topic are not modifiable.
   *
   * @generated from rpc google.pubsub.v1.Publisher.UpdateTopic
   */
  updateTopic: {
    methodKind: "unary";
    input: typeof UpdateTopicRequestSchema;
    output: typeof TopicSchema;
  },
  /**
   * Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic
   * does not exist.
   *
   * @generated from rpc google.pubsub.v1.Publisher.Publish
   */
  publish: {
    methodKind: "unary";
    input: typeof PublishRequestSchema;
    output: typeof PublishResponseSchema;
  },
  /**
   * Gets the configuration of a topic.
   *
   * @generated from rpc google.pubsub.v1.Publisher.GetTopic
   */
  getTopic: {
    methodKind: "unary";
    input: typeof GetTopicRequestSchema;
    output: typeof TopicSchema;
  },
  /**
   * Lists matching topics.
   *
   * @generated from rpc google.pubsub.v1.Publisher.ListTopics
   */
  listTopics: {
    methodKind: "unary";
    input: typeof ListTopicsRequestSchema;
    output: typeof ListTopicsResponseSchema;
  },
  /**
   * Lists the names of the attached subscriptions on this topic.
   *
   * @generated from rpc google.pubsub.v1.Publisher.ListTopicSubscriptions
   */
  listTopicSubscriptions: {
    methodKind: "unary";
    input: typeof ListTopicSubscriptionsRequestSchema;
    output: typeof ListTopicSubscriptionsResponseSchema;
  },
  /**
   * Lists the names of the snapshots on this topic. Snapshots are used in
   * [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
   * which allow you to manage message acknowledgments in bulk. That is, you can
   * set the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   *
   * @generated from rpc google.pubsub.v1.Publisher.ListTopicSnapshots
   */
  listTopicSnapshots: {
    methodKind: "unary";
    input: typeof ListTopicSnapshotsRequestSchema;
    output: typeof ListTopicSnapshotsResponseSchema;
  },
  /**
   * Deletes the topic with the given name. Returns `NOT_FOUND` if the topic
   * does not exist. After a topic is deleted, a new topic may be created with
   * the same name; this is an entirely new topic with none of the old
   * configuration or subscriptions. Existing subscriptions to this topic are
   * not deleted, but their `topic` field is set to `_deleted-topic_`.
   *
   * @generated from rpc google.pubsub.v1.Publisher.DeleteTopic
   */
  deleteTopic: {
    methodKind: "unary";
    input: typeof DeleteTopicRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Detaches a subscription from this topic. All messages retained in the
   * subscription are dropped. Subsequent `Pull` and `StreamingPull` requests
   * will return FAILED_PRECONDITION. If the subscription is a push
   * subscription, pushes to the endpoint will stop.
   *
   * @generated from rpc google.pubsub.v1.Publisher.DetachSubscription
   */
  detachSubscription: {
    methodKind: "unary";
    input: typeof DetachSubscriptionRequestSchema;
    output: typeof DetachSubscriptionResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_pubsub_v1_pubsub, 0);

/**
 * The service that an application uses to manipulate subscriptions and to
 * consume messages from a subscription via the `Pull` method or by
 * establishing a bi-directional stream using the `StreamingPull` method.
 *
 * @generated from service google.pubsub.v1.Subscriber
 */
export const Subscriber: GenService<{
  /**
   * Creates a subscription to a given topic. See the [resource name rules]
   * (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names).
   * If the subscription already exists, returns `ALREADY_EXISTS`.
   * If the corresponding topic doesn't exist, returns `NOT_FOUND`.
   *
   * If the name is not provided in the request, the server will assign a random
   * name for this subscription on the same project as the topic, conforming
   * to the [resource name format]
   * (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
   * generated name is populated in the returned Subscription object. Note that
   * for REST API requests, you must specify a name in the request.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.CreateSubscription
   */
  createSubscription: {
    methodKind: "unary";
    input: typeof SubscriptionSchema;
    output: typeof SubscriptionSchema;
  },
  /**
   * Gets the configuration details of a subscription.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.GetSubscription
   */
  getSubscription: {
    methodKind: "unary";
    input: typeof GetSubscriptionRequestSchema;
    output: typeof SubscriptionSchema;
  },
  /**
   * Updates an existing subscription by updating the fields specified in the
   * update mask. Note that certain properties of a subscription, such as its
   * topic, are not modifiable.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.UpdateSubscription
   */
  updateSubscription: {
    methodKind: "unary";
    input: typeof UpdateSubscriptionRequestSchema;
    output: typeof SubscriptionSchema;
  },
  /**
   * Lists matching subscriptions.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.ListSubscriptions
   */
  listSubscriptions: {
    methodKind: "unary";
    input: typeof ListSubscriptionsRequestSchema;
    output: typeof ListSubscriptionsResponseSchema;
  },
  /**
   * Deletes an existing subscription. All messages retained in the subscription
   * are immediately dropped. Calls to `Pull` after deletion will return
   * `NOT_FOUND`. After a subscription is deleted, a new one may be created with
   * the same name, but the new one has no association with the old
   * subscription or its topic unless the same topic is specified.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.DeleteSubscription
   */
  deleteSubscription: {
    methodKind: "unary";
    input: typeof DeleteSubscriptionRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Modifies the ack deadline for a specific message. This method is useful
   * to indicate that more time is needed to process a message by the
   * subscriber, or to make the message available for redelivery if the
   * processing was interrupted. Note that this does not modify the
   * subscription-level `ackDeadlineSeconds` used for subsequent messages.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.ModifyAckDeadline
   */
  modifyAckDeadline: {
    methodKind: "unary";
    input: typeof ModifyAckDeadlineRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Acknowledges the messages associated with the `ack_ids` in the
   * `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages
   * from the subscription.
   *
   * Acknowledging a message whose ack deadline has expired may succeed,
   * but such a message may be redelivered later. Acknowledging a message more
   * than once will not result in an error.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.Acknowledge
   */
  acknowledge: {
    methodKind: "unary";
    input: typeof AcknowledgeRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Pulls messages from the server.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.Pull
   */
  pull: {
    methodKind: "unary";
    input: typeof PullRequestSchema;
    output: typeof PullResponseSchema;
  },
  /**
   * Establishes a stream with the server, which sends messages down to the
   * client. The client streams acknowledgements and ack deadline modifications
   * back to the server. The server will close the stream and return the status
   * on any error. The server may close the stream with status `UNAVAILABLE` to
   * reassign server-side resources, in which case, the client should
   * re-establish the stream. Flow control can be achieved by configuring the
   * underlying RPC channel.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.StreamingPull
   */
  streamingPull: {
    methodKind: "bidi_streaming";
    input: typeof StreamingPullRequestSchema;
    output: typeof StreamingPullResponseSchema;
  },
  /**
   * Modifies the `PushConfig` for a specified subscription.
   *
   * This may be used to change a push subscription to a pull one (signified by
   * an empty `PushConfig`) or vice versa, or change the endpoint URL and other
   * attributes of a push subscription. Messages will accumulate for delivery
   * continuously through the call regardless of changes to the `PushConfig`.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.ModifyPushConfig
   */
  modifyPushConfig: {
    methodKind: "unary";
    input: typeof ModifyPushConfigRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets the configuration details of a snapshot. Snapshots are used in
   * [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
   * which allow you to manage message acknowledgments in bulk. That is, you can
   * set the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.GetSnapshot
   */
  getSnapshot: {
    methodKind: "unary";
    input: typeof GetSnapshotRequestSchema;
    output: typeof SnapshotSchema;
  },
  /**
   * Lists the existing snapshots. Snapshots are used in [Seek](
   * https://cloud.google.com/pubsub/docs/replay-overview) operations, which
   * allow you to manage message acknowledgments in bulk. That is, you can set
   * the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.ListSnapshots
   */
  listSnapshots: {
    methodKind: "unary";
    input: typeof ListSnapshotsRequestSchema;
    output: typeof ListSnapshotsResponseSchema;
  },
  /**
   * Creates a snapshot from the requested subscription. Snapshots are used in
   * [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
   * which allow you to manage message acknowledgments in bulk. That is, you can
   * set the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   * If the snapshot already exists, returns `ALREADY_EXISTS`.
   * If the requested subscription doesn't exist, returns `NOT_FOUND`.
   * If the backlog in the subscription is too old -- and the resulting snapshot
   * would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.
   * See also the `Snapshot.expire_time` field. If the name is not provided in
   * the request, the server will assign a random
   * name for this snapshot on the same project as the subscription, conforming
   * to the [resource name format]
   * (https://cloud.google.com/pubsub/docs/pubsub-basics#resource_names). The
   * generated name is populated in the returned Snapshot object. Note that for
   * REST API requests, you must specify a name in the request.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.CreateSnapshot
   */
  createSnapshot: {
    methodKind: "unary";
    input: typeof CreateSnapshotRequestSchema;
    output: typeof SnapshotSchema;
  },
  /**
   * Updates an existing snapshot by updating the fields specified in the update
   * mask. Snapshots are used in
   * [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,
   * which allow you to manage message acknowledgments in bulk. That is, you can
   * set the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.UpdateSnapshot
   */
  updateSnapshot: {
    methodKind: "unary";
    input: typeof UpdateSnapshotRequestSchema;
    output: typeof SnapshotSchema;
  },
  /**
   * Removes an existing snapshot. Snapshots are used in [Seek]
   * (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
   * allow you to manage message acknowledgments in bulk. That is, you can set
   * the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot.
   * When the snapshot is deleted, all messages retained in the snapshot
   * are immediately dropped. After a snapshot is deleted, a new one may be
   * created with the same name, but the new one has no association with the old
   * snapshot or its subscription, unless the same subscription is specified.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.DeleteSnapshot
   */
  deleteSnapshot: {
    methodKind: "unary";
    input: typeof DeleteSnapshotRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Seeks an existing subscription to a point in time or to a given snapshot,
   * whichever is provided in the request. Snapshots are used in [Seek]
   * (https://cloud.google.com/pubsub/docs/replay-overview) operations, which
   * allow you to manage message acknowledgments in bulk. That is, you can set
   * the acknowledgment state of messages in an existing subscription to the
   * state captured by a snapshot. Note that both the subscription and the
   * snapshot must be on the same topic.
   *
   * @generated from rpc google.pubsub.v1.Subscriber.Seek
   */
  seek: {
    methodKind: "unary";
    input: typeof SeekRequestSchema;
    output: typeof SeekResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_google_pubsub_v1_pubsub, 1);

