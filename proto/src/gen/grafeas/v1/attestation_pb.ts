// Copyright 2019 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file grafeas/v1/attestation.proto (package grafeas.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Signature } from "./common_pb";
import { file_grafeas_v1_common } from "./common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file grafeas/v1/attestation.proto.
 */
export const file_grafeas_v1_attestation: GenFile = /*@__PURE__*/
  fileDesc("ChxncmFmZWFzL3YxL2F0dGVzdGF0aW9uLnByb3RvEgpncmFmZWFzLnYxImYKD0F0dGVzdGF0aW9uTm90ZRIuCgRoaW50GAEgASgLMiAuZ3JhZmVhcy52MS5BdHRlc3RhdGlvbk5vdGUuSGludBojCgRIaW50EhsKE2h1bWFuX3JlYWRhYmxlX25hbWUYASABKAkiGgoDSnd0EhMKC2NvbXBhY3Rfand0GAEgASgJIn0KFUF0dGVzdGF0aW9uT2NjdXJyZW5jZRIaChJzZXJpYWxpemVkX3BheWxvYWQYASABKAwSKQoKc2lnbmF0dXJlcxgCIAMoCzIVLmdyYWZlYXMudjEuU2lnbmF0dXJlEh0KBGp3dHMYAyADKAsyDy5ncmFmZWFzLnYxLkp3dEJRCg1pby5ncmFmZWFzLnYxUAFaOGdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvZ3JhZmVhcy92MTtncmFmZWFzogIDR1JBYgZwcm90bzM", [file_grafeas_v1_common]);

/**
 * Note kind that represents a logical attestation "role" or "authority". For
 * example, an organization might have one `Authority` for "QA" and one for
 * "build". This note is intended to act strictly as a grouping mechanism for
 * the attached occurrences (Attestations). This grouping mechanism also
 * provides a security boundary, since IAM ACLs gate the ability for a principle
 * to attach an occurrence to a given note. It also provides a single point of
 * lookup to find all attached attestation occurrences, even if they don't all
 * live in the same project.
 *
 * @generated from message grafeas.v1.AttestationNote
 */
export type AttestationNote = Message<"grafeas.v1.AttestationNote"> & {
  /**
   * Hint hints at the purpose of the attestation authority.
   *
   * @generated from field: grafeas.v1.AttestationNote.Hint hint = 1;
   */
  hint?: AttestationNote_Hint;
};

/**
 * Describes the message grafeas.v1.AttestationNote.
 * Use `create(AttestationNoteSchema)` to create a new message.
 */
export const AttestationNoteSchema: GenMessage<AttestationNote> = /*@__PURE__*/
  messageDesc(file_grafeas_v1_attestation, 0);

/**
 * This submessage provides human-readable hints about the purpose of the
 * authority. Because the name of a note acts as its resource reference, it is
 * important to disambiguate the canonical name of the Note (which might be a
 * UUID for security purposes) from "readable" names more suitable for debug
 * output. Note that these hints should not be used to look up authorities in
 * security sensitive contexts, such as when looking up attestations to
 * verify.
 *
 * @generated from message grafeas.v1.AttestationNote.Hint
 */
export type AttestationNote_Hint = Message<"grafeas.v1.AttestationNote.Hint"> & {
  /**
   * Required. The human readable name of this attestation authority, for
   * example "qa".
   *
   * @generated from field: string human_readable_name = 1;
   */
  humanReadableName: string;
};

/**
 * Describes the message grafeas.v1.AttestationNote.Hint.
 * Use `create(AttestationNote_HintSchema)` to create a new message.
 */
export const AttestationNote_HintSchema: GenMessage<AttestationNote_Hint> = /*@__PURE__*/
  messageDesc(file_grafeas_v1_attestation, 0, 0);

/**
 * @generated from message grafeas.v1.Jwt
 */
export type Jwt = Message<"grafeas.v1.Jwt"> & {
  /**
   * The compact encoding of a JWS, which is always three base64 encoded strings
   * joined by periods. For details, see:
   * https://tools.ietf.org/html/rfc7515.html#section-3.1
   *
   * @generated from field: string compact_jwt = 1;
   */
  compactJwt: string;
};

/**
 * Describes the message grafeas.v1.Jwt.
 * Use `create(JwtSchema)` to create a new message.
 */
export const JwtSchema: GenMessage<Jwt> = /*@__PURE__*/
  messageDesc(file_grafeas_v1_attestation, 1);

/**
 * Occurrence that represents a single "attestation". The authenticity of an
 * attestation can be verified using the attached signature. If the verifier
 * trusts the public key of the signer, then verifying the signature is
 * sufficient to establish trust. In this circumstance, the authority to which
 * this attestation is attached is primarily useful for lookup (how to find
 * this attestation if you already know the authority and artifact to be
 * verified) and intent (for which authority this attestation was intended to
 * sign.
 *
 * @generated from message grafeas.v1.AttestationOccurrence
 */
export type AttestationOccurrence = Message<"grafeas.v1.AttestationOccurrence"> & {
  /**
   * Required. The serialized payload that is verified by one or more
   * `signatures`.
   *
   * @generated from field: bytes serialized_payload = 1;
   */
  serializedPayload: Uint8Array;

  /**
   * One or more signatures over `serialized_payload`.  Verifier implementations
   * should consider this attestation message verified if at least one
   * `signature` verifies `serialized_payload`.  See `Signature` in common.proto
   * for more details on signature structure and verification.
   *
   * @generated from field: repeated grafeas.v1.Signature signatures = 2;
   */
  signatures: Signature[];

  /**
   * One or more JWTs encoding a self-contained attestation.
   * Each JWT encodes the payload that it verifies within the JWT itself.
   * Verifier implementation SHOULD ignore the `serialized_payload` field
   * when verifying these JWTs.
   * If only JWTs are present on this AttestationOccurrence, then the
   * `serialized_payload` SHOULD be left empty.
   * Each JWT SHOULD encode a claim specific to the `resource_uri` of this
   * Occurrence, but this is not validated by Grafeas metadata API
   * implementations.  The JWT itself is opaque to Grafeas.
   *
   * @generated from field: repeated grafeas.v1.Jwt jwts = 3;
   */
  jwts: Jwt[];
};

/**
 * Describes the message grafeas.v1.AttestationOccurrence.
 * Use `create(AttestationOccurrenceSchema)` to create a new message.
 */
export const AttestationOccurrenceSchema: GenMessage<AttestationOccurrence> = /*@__PURE__*/
  messageDesc(file_grafeas_v1_attestation, 2);

