// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/intoto_provenance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../google/protobuf/any.js";
import { Timestamp } from "../../google/protobuf/timestamp.js";

export const protobufPackage = "grafeas.v1";

/**
 * Steps taken to build the artifact.
 * For a TaskRun, typically each container corresponds to one step in the
 * recipe.
 */
export interface Recipe {
  /**
   * URI indicating what type of recipe was performed. It determines the meaning
   * of recipe.entryPoint, recipe.arguments, recipe.environment, and materials.
   */
  type: string;
  /**
   * Index in materials containing the recipe steps that are not implied by
   * recipe.type. For example, if the recipe type were "make", then this would
   * point to the source containing the Makefile, not the make program itself.
   * Set to -1 if the recipe doesn't come from a material, as zero is default
   * unset value for int64.
   */
  definedInMaterial: Long;
  /**
   * String identifying the entry point into the build.
   * This is often a path to a configuration file and/or a target label within
   * that file. The syntax and meaning are defined by recipe.type. For example,
   * if the recipe type were "make", then this would reference the directory in
   * which to run make as well as which target to use.
   */
  entryPoint: string;
  /**
   * Collection of all external inputs that influenced the build on top of
   * recipe.definedInMaterial and recipe.entryPoint. For example, if the recipe
   * type were "make", then this might be the flags passed to make aside from
   * the target, which is captured in recipe.entryPoint. Since the arguments
   * field can greatly vary in structure, depending on the builder and recipe
   * type, this is of form "Any".
   */
  arguments: Any[];
  /**
   * Any other builder-controlled inputs necessary for correctly evaluating the
   * recipe. Usually only needed for reproducing the build but not evaluated as
   * part of policy. Since the environment field can greatly vary in structure,
   * depending on the builder and recipe type, this is of form "Any".
   */
  environment: Any[];
}

/**
 * Indicates that the builder claims certain fields in this message to be
 * complete.
 */
export interface Completeness {
  /**
   * If true, the builder claims that recipe.arguments is complete, meaning that
   * all external inputs are properly captured in the recipe.
   */
  arguments: boolean;
  /**
   * If true, the builder claims that recipe.environment is claimed to be
   * complete.
   */
  environment: boolean;
  /**
   * If true, the builder claims that materials are complete, usually through
   * some controls to prevent network access. Sometimes called "hermetic".
   */
  materials: boolean;
}

/** Other properties of the build. */
export interface Metadata {
  /**
   * Identifies the particular build invocation, which can be useful for finding
   * associated logs or other ad-hoc analysis. The value SHOULD be globally
   * unique, per in-toto Provenance spec.
   */
  buildInvocationId: string;
  /** The timestamp of when the build started. */
  buildStartedOn:
    | Date
    | undefined;
  /** The timestamp of when the build completed. */
  buildFinishedOn:
    | Date
    | undefined;
  /**
   * Indicates that the builder claims certain fields in this message to be
   * complete.
   */
  completeness:
    | Completeness
    | undefined;
  /**
   * If true, the builder claims that running the recipe on materials will
   * produce bit-for-bit identical output.
   */
  reproducible: boolean;
}

export interface BuilderConfig {
  id: string;
}

export interface InTotoProvenance {
  /** required */
  builderConfig:
    | BuilderConfig
    | undefined;
  /**
   * Identifies the configuration used for the build.
   * When combined with materials, this SHOULD fully describe the build,
   * such that re-running this recipe results in bit-for-bit identical output
   * (if the build is reproducible).
   */
  recipe: Recipe | undefined;
  metadata:
    | Metadata
    | undefined;
  /**
   * The collection of artifacts that influenced the build including sources,
   * dependencies, build tools, base images, and so on. This is considered to be
   * incomplete unless metadata.completeness.materials is true. Unset or null is
   * equivalent to empty.
   */
  materials: string[];
}

function createBaseRecipe(): Recipe {
  return { type: "", definedInMaterial: Long.ZERO, entryPoint: "", arguments: [], environment: [] };
}

export const Recipe: MessageFns<Recipe> = {
  encode(message: Recipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (!message.definedInMaterial.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.definedInMaterial.toString());
    }
    if (message.entryPoint !== "") {
      writer.uint32(26).string(message.entryPoint);
    }
    for (const v of message.arguments) {
      Any.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.environment) {
      Any.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.definedInMaterial = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryPoint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.arguments.push(Any.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.environment.push(Any.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recipe {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      definedInMaterial: isSet(object.definedInMaterial) ? Long.fromValue(object.definedInMaterial) : Long.ZERO,
      entryPoint: isSet(object.entryPoint) ? globalThis.String(object.entryPoint) : "",
      arguments: globalThis.Array.isArray(object?.arguments) ? object.arguments.map((e: any) => Any.fromJSON(e)) : [],
      environment: globalThis.Array.isArray(object?.environment)
        ? object.environment.map((e: any) => Any.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Recipe): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (!message.definedInMaterial.equals(Long.ZERO)) {
      obj.definedInMaterial = (message.definedInMaterial || Long.ZERO).toString();
    }
    if (message.entryPoint !== "") {
      obj.entryPoint = message.entryPoint;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => Any.toJSON(e));
    }
    if (message.environment?.length) {
      obj.environment = message.environment.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Recipe>): Recipe {
    return Recipe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Recipe>): Recipe {
    const message = createBaseRecipe();
    message.type = object.type ?? "";
    message.definedInMaterial = (object.definedInMaterial !== undefined && object.definedInMaterial !== null)
      ? Long.fromValue(object.definedInMaterial)
      : Long.ZERO;
    message.entryPoint = object.entryPoint ?? "";
    message.arguments = object.arguments?.map((e) => Any.fromPartial(e)) || [];
    message.environment = object.environment?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompleteness(): Completeness {
  return { arguments: false, environment: false, materials: false };
}

export const Completeness: MessageFns<Completeness> = {
  encode(message: Completeness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.arguments !== false) {
      writer.uint32(8).bool(message.arguments);
    }
    if (message.environment !== false) {
      writer.uint32(16).bool(message.environment);
    }
    if (message.materials !== false) {
      writer.uint32(24).bool(message.materials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Completeness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.arguments = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.environment = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.materials = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Completeness {
    return {
      arguments: isSet(object.arguments) ? globalThis.Boolean(object.arguments) : false,
      environment: isSet(object.environment) ? globalThis.Boolean(object.environment) : false,
      materials: isSet(object.materials) ? globalThis.Boolean(object.materials) : false,
    };
  },

  toJSON(message: Completeness): unknown {
    const obj: any = {};
    if (message.arguments !== false) {
      obj.arguments = message.arguments;
    }
    if (message.environment !== false) {
      obj.environment = message.environment;
    }
    if (message.materials !== false) {
      obj.materials = message.materials;
    }
    return obj;
  },

  create(base?: DeepPartial<Completeness>): Completeness {
    return Completeness.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Completeness>): Completeness {
    const message = createBaseCompleteness();
    message.arguments = object.arguments ?? false;
    message.environment = object.environment ?? false;
    message.materials = object.materials ?? false;
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return {
    buildInvocationId: "",
    buildStartedOn: undefined,
    buildFinishedOn: undefined,
    completeness: undefined,
    reproducible: false,
  };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildInvocationId !== "") {
      writer.uint32(10).string(message.buildInvocationId);
    }
    if (message.buildStartedOn !== undefined) {
      Timestamp.encode(toTimestamp(message.buildStartedOn), writer.uint32(18).fork()).join();
    }
    if (message.buildFinishedOn !== undefined) {
      Timestamp.encode(toTimestamp(message.buildFinishedOn), writer.uint32(26).fork()).join();
    }
    if (message.completeness !== undefined) {
      Completeness.encode(message.completeness, writer.uint32(34).fork()).join();
    }
    if (message.reproducible !== false) {
      writer.uint32(40).bool(message.reproducible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildInvocationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buildStartedOn = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildFinishedOn = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.completeness = Completeness.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reproducible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      buildInvocationId: isSet(object.buildInvocationId) ? globalThis.String(object.buildInvocationId) : "",
      buildStartedOn: isSet(object.buildStartedOn) ? fromJsonTimestamp(object.buildStartedOn) : undefined,
      buildFinishedOn: isSet(object.buildFinishedOn) ? fromJsonTimestamp(object.buildFinishedOn) : undefined,
      completeness: isSet(object.completeness) ? Completeness.fromJSON(object.completeness) : undefined,
      reproducible: isSet(object.reproducible) ? globalThis.Boolean(object.reproducible) : false,
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.buildInvocationId !== "") {
      obj.buildInvocationId = message.buildInvocationId;
    }
    if (message.buildStartedOn !== undefined) {
      obj.buildStartedOn = message.buildStartedOn.toISOString();
    }
    if (message.buildFinishedOn !== undefined) {
      obj.buildFinishedOn = message.buildFinishedOn.toISOString();
    }
    if (message.completeness !== undefined) {
      obj.completeness = Completeness.toJSON(message.completeness);
    }
    if (message.reproducible !== false) {
      obj.reproducible = message.reproducible;
    }
    return obj;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.buildInvocationId = object.buildInvocationId ?? "";
    message.buildStartedOn = object.buildStartedOn ?? undefined;
    message.buildFinishedOn = object.buildFinishedOn ?? undefined;
    message.completeness = (object.completeness !== undefined && object.completeness !== null)
      ? Completeness.fromPartial(object.completeness)
      : undefined;
    message.reproducible = object.reproducible ?? false;
    return message;
  },
};

function createBaseBuilderConfig(): BuilderConfig {
  return { id: "" };
}

export const BuilderConfig: MessageFns<BuilderConfig> = {
  encode(message: BuilderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuilderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuilderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuilderConfig {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: BuilderConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<BuilderConfig>): BuilderConfig {
    return BuilderConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuilderConfig>): BuilderConfig {
    const message = createBaseBuilderConfig();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseInTotoProvenance(): InTotoProvenance {
  return { builderConfig: undefined, recipe: undefined, metadata: undefined, materials: [] };
}

export const InTotoProvenance: MessageFns<InTotoProvenance> = {
  encode(message: InTotoProvenance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.builderConfig !== undefined) {
      BuilderConfig.encode(message.builderConfig, writer.uint32(10).fork()).join();
    }
    if (message.recipe !== undefined) {
      Recipe.encode(message.recipe, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    for (const v of message.materials) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InTotoProvenance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInTotoProvenance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.builderConfig = BuilderConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recipe = Recipe.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.materials.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InTotoProvenance {
    return {
      builderConfig: isSet(object.builderConfig) ? BuilderConfig.fromJSON(object.builderConfig) : undefined,
      recipe: isSet(object.recipe) ? Recipe.fromJSON(object.recipe) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      materials: globalThis.Array.isArray(object?.materials)
        ? object.materials.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: InTotoProvenance): unknown {
    const obj: any = {};
    if (message.builderConfig !== undefined) {
      obj.builderConfig = BuilderConfig.toJSON(message.builderConfig);
    }
    if (message.recipe !== undefined) {
      obj.recipe = Recipe.toJSON(message.recipe);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.materials?.length) {
      obj.materials = message.materials;
    }
    return obj;
  },

  create(base?: DeepPartial<InTotoProvenance>): InTotoProvenance {
    return InTotoProvenance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InTotoProvenance>): InTotoProvenance {
    const message = createBaseInTotoProvenance();
    message.builderConfig = (object.builderConfig !== undefined && object.builderConfig !== null)
      ? BuilderConfig.fromPartial(object.builderConfig)
      : undefined;
    message.recipe = (object.recipe !== undefined && object.recipe !== null)
      ? Recipe.fromPartial(object.recipe)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.materials = object.materials?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
