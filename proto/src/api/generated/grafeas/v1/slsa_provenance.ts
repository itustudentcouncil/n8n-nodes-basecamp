// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: grafeas/v1/slsa_provenance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../google/protobuf/any.js";
import { Timestamp } from "../../google/protobuf/timestamp.js";

export const protobufPackage = "grafeas.v1";

export interface SlsaProvenance {
  /** required */
  builder:
    | SlsaProvenance_SlsaBuilder
    | undefined;
  /**
   * Identifies the configuration used for the build.
   * When combined with materials, this SHOULD fully describe the build,
   * such that re-running this recipe results in bit-for-bit identical output
   * (if the build is reproducible).
   */
  recipe: SlsaProvenance_SlsaRecipe | undefined;
  metadata:
    | SlsaProvenance_SlsaMetadata
    | undefined;
  /**
   * The collection of artifacts that influenced the build including sources,
   * dependencies, build tools, base images, and so on. This is considered to be
   * incomplete unless metadata.completeness.materials is true. Unset or null is
   * equivalent to empty.
   */
  materials: SlsaProvenance_Material[];
}

/**
 * Steps taken to build the artifact.
 * For a TaskRun, typically each container corresponds to one step in the
 * recipe.
 */
export interface SlsaProvenance_SlsaRecipe {
  /**
   * URI indicating what type of recipe was performed. It determines the
   * meaning of recipe.entryPoint, recipe.arguments, recipe.environment, and
   * materials.
   */
  type: string;
  /**
   * Index in materials containing the recipe steps that are not implied by
   * recipe.type. For example, if the recipe type were "make", then this would
   * point to the source containing the Makefile, not the make program itself.
   * Set to -1 if the recipe doesn't come from a material, as zero is default
   * unset value for int64.
   */
  definedInMaterial: Long;
  /**
   * String identifying the entry point into the build.
   * This is often a path to a configuration file and/or a target label within
   * that file. The syntax and meaning are defined by recipe.type. For
   * example, if the recipe type were "make", then this would reference the
   * directory in which to run make as well as which target to use.
   */
  entryPoint: string;
  /**
   * Collection of all external inputs that influenced the build on top of
   * recipe.definedInMaterial and recipe.entryPoint. For example, if the
   * recipe type were "make", then this might be the flags passed to make
   * aside from the target, which is captured in recipe.entryPoint. Depending
   * on the recipe Type, the structure may be different.
   */
  arguments:
    | Any
    | undefined;
  /**
   * Any other builder-controlled inputs necessary for correctly evaluating
   * the recipe. Usually only needed for reproducing the build but not
   * evaluated as part of policy. Depending on the recipe Type, the structure
   * may be different.
   */
  environment: Any | undefined;
}

/**
 * Indicates that the builder claims certain fields in this message to be
 * complete.
 */
export interface SlsaProvenance_SlsaCompleteness {
  /**
   * If true, the builder claims that recipe.arguments is complete, meaning
   * that all external inputs are properly captured in the recipe.
   */
  arguments: boolean;
  /**
   * If true, the builder claims that recipe.environment is claimed to be
   * complete.
   */
  environment: boolean;
  /**
   * If true, the builder claims that materials are complete, usually through
   * some controls to prevent network access. Sometimes called "hermetic".
   */
  materials: boolean;
}

/** Other properties of the build. */
export interface SlsaProvenance_SlsaMetadata {
  /**
   * Identifies the particular build invocation, which can be useful for
   * finding associated logs or other ad-hoc analysis. The value SHOULD be
   * globally unique, per in-toto Provenance spec.
   */
  buildInvocationId: string;
  /** The timestamp of when the build started. */
  buildStartedOn:
    | Date
    | undefined;
  /** The timestamp of when the build completed. */
  buildFinishedOn:
    | Date
    | undefined;
  /**
   * Indicates that the builder claims certain fields in this message to be
   * complete.
   */
  completeness:
    | SlsaProvenance_SlsaCompleteness
    | undefined;
  /**
   * If true, the builder claims that running the recipe on materials will
   * produce bit-for-bit identical output.
   */
  reproducible: boolean;
}

export interface SlsaProvenance_SlsaBuilder {
  id: string;
}

export interface SlsaProvenance_Material {
  uri: string;
  digest: { [key: string]: string };
}

export interface SlsaProvenance_Material_DigestEntry {
  key: string;
  value: string;
}

function createBaseSlsaProvenance(): SlsaProvenance {
  return { builder: undefined, recipe: undefined, metadata: undefined, materials: [] };
}

export const SlsaProvenance: MessageFns<SlsaProvenance> = {
  encode(message: SlsaProvenance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.builder !== undefined) {
      SlsaProvenance_SlsaBuilder.encode(message.builder, writer.uint32(10).fork()).join();
    }
    if (message.recipe !== undefined) {
      SlsaProvenance_SlsaRecipe.encode(message.recipe, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      SlsaProvenance_SlsaMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    for (const v of message.materials) {
      SlsaProvenance_Material.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.builder = SlsaProvenance_SlsaBuilder.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recipe = SlsaProvenance_SlsaRecipe.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = SlsaProvenance_SlsaMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.materials.push(SlsaProvenance_Material.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance {
    return {
      builder: isSet(object.builder) ? SlsaProvenance_SlsaBuilder.fromJSON(object.builder) : undefined,
      recipe: isSet(object.recipe) ? SlsaProvenance_SlsaRecipe.fromJSON(object.recipe) : undefined,
      metadata: isSet(object.metadata) ? SlsaProvenance_SlsaMetadata.fromJSON(object.metadata) : undefined,
      materials: globalThis.Array.isArray(object?.materials)
        ? object.materials.map((e: any) => SlsaProvenance_Material.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SlsaProvenance): unknown {
    const obj: any = {};
    if (message.builder !== undefined) {
      obj.builder = SlsaProvenance_SlsaBuilder.toJSON(message.builder);
    }
    if (message.recipe !== undefined) {
      obj.recipe = SlsaProvenance_SlsaRecipe.toJSON(message.recipe);
    }
    if (message.metadata !== undefined) {
      obj.metadata = SlsaProvenance_SlsaMetadata.toJSON(message.metadata);
    }
    if (message.materials?.length) {
      obj.materials = message.materials.map((e) => SlsaProvenance_Material.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance>): SlsaProvenance {
    return SlsaProvenance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance>): SlsaProvenance {
    const message = createBaseSlsaProvenance();
    message.builder = (object.builder !== undefined && object.builder !== null)
      ? SlsaProvenance_SlsaBuilder.fromPartial(object.builder)
      : undefined;
    message.recipe = (object.recipe !== undefined && object.recipe !== null)
      ? SlsaProvenance_SlsaRecipe.fromPartial(object.recipe)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? SlsaProvenance_SlsaMetadata.fromPartial(object.metadata)
      : undefined;
    message.materials = object.materials?.map((e) => SlsaProvenance_Material.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSlsaProvenance_SlsaRecipe(): SlsaProvenance_SlsaRecipe {
  return { type: "", definedInMaterial: Long.ZERO, entryPoint: "", arguments: undefined, environment: undefined };
}

export const SlsaProvenance_SlsaRecipe: MessageFns<SlsaProvenance_SlsaRecipe> = {
  encode(message: SlsaProvenance_SlsaRecipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (!message.definedInMaterial.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.definedInMaterial.toString());
    }
    if (message.entryPoint !== "") {
      writer.uint32(26).string(message.entryPoint);
    }
    if (message.arguments !== undefined) {
      Any.encode(message.arguments, writer.uint32(34).fork()).join();
    }
    if (message.environment !== undefined) {
      Any.encode(message.environment, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_SlsaRecipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_SlsaRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.definedInMaterial = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryPoint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.arguments = Any.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.environment = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_SlsaRecipe {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      definedInMaterial: isSet(object.definedInMaterial) ? Long.fromValue(object.definedInMaterial) : Long.ZERO,
      entryPoint: isSet(object.entryPoint) ? globalThis.String(object.entryPoint) : "",
      arguments: isSet(object.arguments) ? Any.fromJSON(object.arguments) : undefined,
      environment: isSet(object.environment) ? Any.fromJSON(object.environment) : undefined,
    };
  },

  toJSON(message: SlsaProvenance_SlsaRecipe): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (!message.definedInMaterial.equals(Long.ZERO)) {
      obj.definedInMaterial = (message.definedInMaterial || Long.ZERO).toString();
    }
    if (message.entryPoint !== "") {
      obj.entryPoint = message.entryPoint;
    }
    if (message.arguments !== undefined) {
      obj.arguments = Any.toJSON(message.arguments);
    }
    if (message.environment !== undefined) {
      obj.environment = Any.toJSON(message.environment);
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_SlsaRecipe>): SlsaProvenance_SlsaRecipe {
    return SlsaProvenance_SlsaRecipe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_SlsaRecipe>): SlsaProvenance_SlsaRecipe {
    const message = createBaseSlsaProvenance_SlsaRecipe();
    message.type = object.type ?? "";
    message.definedInMaterial = (object.definedInMaterial !== undefined && object.definedInMaterial !== null)
      ? Long.fromValue(object.definedInMaterial)
      : Long.ZERO;
    message.entryPoint = object.entryPoint ?? "";
    message.arguments = (object.arguments !== undefined && object.arguments !== null)
      ? Any.fromPartial(object.arguments)
      : undefined;
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Any.fromPartial(object.environment)
      : undefined;
    return message;
  },
};

function createBaseSlsaProvenance_SlsaCompleteness(): SlsaProvenance_SlsaCompleteness {
  return { arguments: false, environment: false, materials: false };
}

export const SlsaProvenance_SlsaCompleteness: MessageFns<SlsaProvenance_SlsaCompleteness> = {
  encode(message: SlsaProvenance_SlsaCompleteness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.arguments !== false) {
      writer.uint32(8).bool(message.arguments);
    }
    if (message.environment !== false) {
      writer.uint32(16).bool(message.environment);
    }
    if (message.materials !== false) {
      writer.uint32(24).bool(message.materials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_SlsaCompleteness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_SlsaCompleteness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.arguments = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.environment = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.materials = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_SlsaCompleteness {
    return {
      arguments: isSet(object.arguments) ? globalThis.Boolean(object.arguments) : false,
      environment: isSet(object.environment) ? globalThis.Boolean(object.environment) : false,
      materials: isSet(object.materials) ? globalThis.Boolean(object.materials) : false,
    };
  },

  toJSON(message: SlsaProvenance_SlsaCompleteness): unknown {
    const obj: any = {};
    if (message.arguments !== false) {
      obj.arguments = message.arguments;
    }
    if (message.environment !== false) {
      obj.environment = message.environment;
    }
    if (message.materials !== false) {
      obj.materials = message.materials;
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_SlsaCompleteness>): SlsaProvenance_SlsaCompleteness {
    return SlsaProvenance_SlsaCompleteness.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_SlsaCompleteness>): SlsaProvenance_SlsaCompleteness {
    const message = createBaseSlsaProvenance_SlsaCompleteness();
    message.arguments = object.arguments ?? false;
    message.environment = object.environment ?? false;
    message.materials = object.materials ?? false;
    return message;
  },
};

function createBaseSlsaProvenance_SlsaMetadata(): SlsaProvenance_SlsaMetadata {
  return {
    buildInvocationId: "",
    buildStartedOn: undefined,
    buildFinishedOn: undefined,
    completeness: undefined,
    reproducible: false,
  };
}

export const SlsaProvenance_SlsaMetadata: MessageFns<SlsaProvenance_SlsaMetadata> = {
  encode(message: SlsaProvenance_SlsaMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildInvocationId !== "") {
      writer.uint32(10).string(message.buildInvocationId);
    }
    if (message.buildStartedOn !== undefined) {
      Timestamp.encode(toTimestamp(message.buildStartedOn), writer.uint32(18).fork()).join();
    }
    if (message.buildFinishedOn !== undefined) {
      Timestamp.encode(toTimestamp(message.buildFinishedOn), writer.uint32(26).fork()).join();
    }
    if (message.completeness !== undefined) {
      SlsaProvenance_SlsaCompleteness.encode(message.completeness, writer.uint32(34).fork()).join();
    }
    if (message.reproducible !== false) {
      writer.uint32(40).bool(message.reproducible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_SlsaMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_SlsaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildInvocationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buildStartedOn = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildFinishedOn = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.completeness = SlsaProvenance_SlsaCompleteness.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reproducible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_SlsaMetadata {
    return {
      buildInvocationId: isSet(object.buildInvocationId) ? globalThis.String(object.buildInvocationId) : "",
      buildStartedOn: isSet(object.buildStartedOn) ? fromJsonTimestamp(object.buildStartedOn) : undefined,
      buildFinishedOn: isSet(object.buildFinishedOn) ? fromJsonTimestamp(object.buildFinishedOn) : undefined,
      completeness: isSet(object.completeness)
        ? SlsaProvenance_SlsaCompleteness.fromJSON(object.completeness)
        : undefined,
      reproducible: isSet(object.reproducible) ? globalThis.Boolean(object.reproducible) : false,
    };
  },

  toJSON(message: SlsaProvenance_SlsaMetadata): unknown {
    const obj: any = {};
    if (message.buildInvocationId !== "") {
      obj.buildInvocationId = message.buildInvocationId;
    }
    if (message.buildStartedOn !== undefined) {
      obj.buildStartedOn = message.buildStartedOn.toISOString();
    }
    if (message.buildFinishedOn !== undefined) {
      obj.buildFinishedOn = message.buildFinishedOn.toISOString();
    }
    if (message.completeness !== undefined) {
      obj.completeness = SlsaProvenance_SlsaCompleteness.toJSON(message.completeness);
    }
    if (message.reproducible !== false) {
      obj.reproducible = message.reproducible;
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_SlsaMetadata>): SlsaProvenance_SlsaMetadata {
    return SlsaProvenance_SlsaMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_SlsaMetadata>): SlsaProvenance_SlsaMetadata {
    const message = createBaseSlsaProvenance_SlsaMetadata();
    message.buildInvocationId = object.buildInvocationId ?? "";
    message.buildStartedOn = object.buildStartedOn ?? undefined;
    message.buildFinishedOn = object.buildFinishedOn ?? undefined;
    message.completeness = (object.completeness !== undefined && object.completeness !== null)
      ? SlsaProvenance_SlsaCompleteness.fromPartial(object.completeness)
      : undefined;
    message.reproducible = object.reproducible ?? false;
    return message;
  },
};

function createBaseSlsaProvenance_SlsaBuilder(): SlsaProvenance_SlsaBuilder {
  return { id: "" };
}

export const SlsaProvenance_SlsaBuilder: MessageFns<SlsaProvenance_SlsaBuilder> = {
  encode(message: SlsaProvenance_SlsaBuilder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_SlsaBuilder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_SlsaBuilder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_SlsaBuilder {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: SlsaProvenance_SlsaBuilder): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_SlsaBuilder>): SlsaProvenance_SlsaBuilder {
    return SlsaProvenance_SlsaBuilder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_SlsaBuilder>): SlsaProvenance_SlsaBuilder {
    const message = createBaseSlsaProvenance_SlsaBuilder();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseSlsaProvenance_Material(): SlsaProvenance_Material {
  return { uri: "", digest: {} };
}

export const SlsaProvenance_Material: MessageFns<SlsaProvenance_Material> = {
  encode(message: SlsaProvenance_Material, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    Object.entries(message.digest).forEach(([key, value]) => {
      SlsaProvenance_Material_DigestEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_Material {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_Material();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SlsaProvenance_Material_DigestEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.digest[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_Material {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      digest: isObject(object.digest)
        ? Object.entries(object.digest).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SlsaProvenance_Material): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.digest) {
      const entries = Object.entries(message.digest);
      if (entries.length > 0) {
        obj.digest = {};
        entries.forEach(([k, v]) => {
          obj.digest[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_Material>): SlsaProvenance_Material {
    return SlsaProvenance_Material.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_Material>): SlsaProvenance_Material {
    const message = createBaseSlsaProvenance_Material();
    message.uri = object.uri ?? "";
    message.digest = Object.entries(object.digest ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSlsaProvenance_Material_DigestEntry(): SlsaProvenance_Material_DigestEntry {
  return { key: "", value: "" };
}

export const SlsaProvenance_Material_DigestEntry: MessageFns<SlsaProvenance_Material_DigestEntry> = {
  encode(message: SlsaProvenance_Material_DigestEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlsaProvenance_Material_DigestEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlsaProvenance_Material_DigestEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlsaProvenance_Material_DigestEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SlsaProvenance_Material_DigestEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SlsaProvenance_Material_DigestEntry>): SlsaProvenance_Material_DigestEntry {
    return SlsaProvenance_Material_DigestEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlsaProvenance_Material_DigestEntry>): SlsaProvenance_Material_DigestEntry {
    const message = createBaseSlsaProvenance_Material_DigestEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
