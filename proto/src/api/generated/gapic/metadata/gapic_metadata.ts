// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: gapic/metadata/gapic_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.gapic.metadata";

/**
 * Metadata about a GAPIC library for a specific combination of API, version,
 * and computer language.
 */
export interface GapicMetadata {
  /** Schema version of this proto. Current value: 1.0 */
  schema: string;
  /** Any human-readable comments to be included in this file. */
  comment: string;
  /**
   * Computer language of this generated language. This must be
   * spelled out as it spoken in English, with no capitalization or
   * separators (e.g. "csharp", "nodejs").
   */
  language: string;
  /**
   * The proto package containing the API definition for which this
   * GAPIC library was generated.
   */
  protoPackage: string;
  /** The language-specific library package for this GAPIC library. */
  libraryPackage: string;
  /**
   * A map from each proto-defined service to ServiceForTransports,
   * which allows listing information about transport-specific
   * implementations of the service.
   *
   * The key is the name of the service as it appears in the .proto
   * file.
   */
  services: { [key: string]: GapicMetadata_ServiceForTransport };
}

export interface GapicMetadata_ServicesEntry {
  key: string;
  value: GapicMetadata_ServiceForTransport | undefined;
}

/**
 * A map from a transport name to ServiceAsClient, which allows
 * listing information about the client objects that implement the
 * parent RPC service for the specified transport.
 *
 * The key name is the transport, lower-cased with no separators
 * (e.g. "grpc", "rest").
 */
export interface GapicMetadata_ServiceForTransport {
  clients: { [key: string]: GapicMetadata_ServiceAsClient };
}

export interface GapicMetadata_ServiceForTransport_ClientsEntry {
  key: string;
  value: GapicMetadata_ServiceAsClient | undefined;
}

/** Information about a specific client implementing a proto-defined service. */
export interface GapicMetadata_ServiceAsClient {
  /** The name of the library client formatted as it appears in the source code */
  libraryClient: string;
  /**
   * A mapping from each proto-defined RPC name to the the list of
   * methods in library_client that implement it. There can be more
   * than one library_client method for each RPC. RPCs with no
   * library_client methods need not be included.
   *
   * The key name is the name of the RPC as defined and formatted in
   * the proto file.
   */
  rpcs: { [key: string]: GapicMetadata_MethodList };
}

export interface GapicMetadata_ServiceAsClient_RpcsEntry {
  key: string;
  value: GapicMetadata_MethodList | undefined;
}

/**
 * List of GAPIC client methods implementing the proto-defined RPC
 * for the transport and service specified in the containing
 * structures.
 */
export interface GapicMetadata_MethodList {
  /**
   * List of methods for a specific proto-service client in the
   * GAPIC. These names should be formatted as they appear in the
   * source code.
   */
  methods: string[];
}

function createBaseGapicMetadata(): GapicMetadata {
  return { schema: "", comment: "", language: "", protoPackage: "", libraryPackage: "", services: {} };
}

export const GapicMetadata: MessageFns<GapicMetadata> = {
  encode(message: GapicMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    if (message.language !== "") {
      writer.uint32(26).string(message.language);
    }
    if (message.protoPackage !== "") {
      writer.uint32(34).string(message.protoPackage);
    }
    if (message.libraryPackage !== "") {
      writer.uint32(42).string(message.libraryPackage);
    }
    Object.entries(message.services).forEach(([key, value]) => {
      GapicMetadata_ServicesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.language = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.protoPackage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.libraryPackage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = GapicMetadata_ServicesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.services[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      protoPackage: isSet(object.protoPackage) ? globalThis.String(object.protoPackage) : "",
      libraryPackage: isSet(object.libraryPackage) ? globalThis.String(object.libraryPackage) : "",
      services: isObject(object.services)
        ? Object.entries(object.services).reduce<{ [key: string]: GapicMetadata_ServiceForTransport }>(
          (acc, [key, value]) => {
            acc[key] = GapicMetadata_ServiceForTransport.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GapicMetadata): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.protoPackage !== "") {
      obj.protoPackage = message.protoPackage;
    }
    if (message.libraryPackage !== "") {
      obj.libraryPackage = message.libraryPackage;
    }
    if (message.services) {
      const entries = Object.entries(message.services);
      if (entries.length > 0) {
        obj.services = {};
        entries.forEach(([k, v]) => {
          obj.services[k] = GapicMetadata_ServiceForTransport.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata>): GapicMetadata {
    return GapicMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata>): GapicMetadata {
    const message = createBaseGapicMetadata();
    message.schema = object.schema ?? "";
    message.comment = object.comment ?? "";
    message.language = object.language ?? "";
    message.protoPackage = object.protoPackage ?? "";
    message.libraryPackage = object.libraryPackage ?? "";
    message.services = Object.entries(object.services ?? {}).reduce<
      { [key: string]: GapicMetadata_ServiceForTransport }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = GapicMetadata_ServiceForTransport.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGapicMetadata_ServicesEntry(): GapicMetadata_ServicesEntry {
  return { key: "", value: undefined };
}

export const GapicMetadata_ServicesEntry: MessageFns<GapicMetadata_ServicesEntry> = {
  encode(message: GapicMetadata_ServicesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GapicMetadata_ServiceForTransport.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_ServicesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_ServicesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = GapicMetadata_ServiceForTransport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_ServicesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GapicMetadata_ServiceForTransport.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GapicMetadata_ServicesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GapicMetadata_ServiceForTransport.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata_ServicesEntry>): GapicMetadata_ServicesEntry {
    return GapicMetadata_ServicesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata_ServicesEntry>): GapicMetadata_ServicesEntry {
    const message = createBaseGapicMetadata_ServicesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GapicMetadata_ServiceForTransport.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGapicMetadata_ServiceForTransport(): GapicMetadata_ServiceForTransport {
  return { clients: {} };
}

export const GapicMetadata_ServiceForTransport: MessageFns<GapicMetadata_ServiceForTransport> = {
  encode(message: GapicMetadata_ServiceForTransport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.clients).forEach(([key, value]) => {
      GapicMetadata_ServiceForTransport_ClientsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_ServiceForTransport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_ServiceForTransport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GapicMetadata_ServiceForTransport_ClientsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.clients[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_ServiceForTransport {
    return {
      clients: isObject(object.clients)
        ? Object.entries(object.clients).reduce<{ [key: string]: GapicMetadata_ServiceAsClient }>(
          (acc, [key, value]) => {
            acc[key] = GapicMetadata_ServiceAsClient.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GapicMetadata_ServiceForTransport): unknown {
    const obj: any = {};
    if (message.clients) {
      const entries = Object.entries(message.clients);
      if (entries.length > 0) {
        obj.clients = {};
        entries.forEach(([k, v]) => {
          obj.clients[k] = GapicMetadata_ServiceAsClient.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata_ServiceForTransport>): GapicMetadata_ServiceForTransport {
    return GapicMetadata_ServiceForTransport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata_ServiceForTransport>): GapicMetadata_ServiceForTransport {
    const message = createBaseGapicMetadata_ServiceForTransport();
    message.clients = Object.entries(object.clients ?? {}).reduce<{ [key: string]: GapicMetadata_ServiceAsClient }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = GapicMetadata_ServiceAsClient.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGapicMetadata_ServiceForTransport_ClientsEntry(): GapicMetadata_ServiceForTransport_ClientsEntry {
  return { key: "", value: undefined };
}

export const GapicMetadata_ServiceForTransport_ClientsEntry: MessageFns<
  GapicMetadata_ServiceForTransport_ClientsEntry
> = {
  encode(
    message: GapicMetadata_ServiceForTransport_ClientsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GapicMetadata_ServiceAsClient.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_ServiceForTransport_ClientsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_ServiceForTransport_ClientsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = GapicMetadata_ServiceAsClient.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_ServiceForTransport_ClientsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GapicMetadata_ServiceAsClient.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GapicMetadata_ServiceForTransport_ClientsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GapicMetadata_ServiceAsClient.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GapicMetadata_ServiceForTransport_ClientsEntry>,
  ): GapicMetadata_ServiceForTransport_ClientsEntry {
    return GapicMetadata_ServiceForTransport_ClientsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GapicMetadata_ServiceForTransport_ClientsEntry>,
  ): GapicMetadata_ServiceForTransport_ClientsEntry {
    const message = createBaseGapicMetadata_ServiceForTransport_ClientsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GapicMetadata_ServiceAsClient.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGapicMetadata_ServiceAsClient(): GapicMetadata_ServiceAsClient {
  return { libraryClient: "", rpcs: {} };
}

export const GapicMetadata_ServiceAsClient: MessageFns<GapicMetadata_ServiceAsClient> = {
  encode(message: GapicMetadata_ServiceAsClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.libraryClient !== "") {
      writer.uint32(10).string(message.libraryClient);
    }
    Object.entries(message.rpcs).forEach(([key, value]) => {
      GapicMetadata_ServiceAsClient_RpcsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_ServiceAsClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_ServiceAsClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.libraryClient = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GapicMetadata_ServiceAsClient_RpcsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.rpcs[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_ServiceAsClient {
    return {
      libraryClient: isSet(object.libraryClient) ? globalThis.String(object.libraryClient) : "",
      rpcs: isObject(object.rpcs)
        ? Object.entries(object.rpcs).reduce<{ [key: string]: GapicMetadata_MethodList }>((acc, [key, value]) => {
          acc[key] = GapicMetadata_MethodList.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GapicMetadata_ServiceAsClient): unknown {
    const obj: any = {};
    if (message.libraryClient !== "") {
      obj.libraryClient = message.libraryClient;
    }
    if (message.rpcs) {
      const entries = Object.entries(message.rpcs);
      if (entries.length > 0) {
        obj.rpcs = {};
        entries.forEach(([k, v]) => {
          obj.rpcs[k] = GapicMetadata_MethodList.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata_ServiceAsClient>): GapicMetadata_ServiceAsClient {
    return GapicMetadata_ServiceAsClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata_ServiceAsClient>): GapicMetadata_ServiceAsClient {
    const message = createBaseGapicMetadata_ServiceAsClient();
    message.libraryClient = object.libraryClient ?? "";
    message.rpcs = Object.entries(object.rpcs ?? {}).reduce<{ [key: string]: GapicMetadata_MethodList }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = GapicMetadata_MethodList.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGapicMetadata_ServiceAsClient_RpcsEntry(): GapicMetadata_ServiceAsClient_RpcsEntry {
  return { key: "", value: undefined };
}

export const GapicMetadata_ServiceAsClient_RpcsEntry: MessageFns<GapicMetadata_ServiceAsClient_RpcsEntry> = {
  encode(message: GapicMetadata_ServiceAsClient_RpcsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GapicMetadata_MethodList.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_ServiceAsClient_RpcsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_ServiceAsClient_RpcsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = GapicMetadata_MethodList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_ServiceAsClient_RpcsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GapicMetadata_MethodList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GapicMetadata_ServiceAsClient_RpcsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GapicMetadata_MethodList.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata_ServiceAsClient_RpcsEntry>): GapicMetadata_ServiceAsClient_RpcsEntry {
    return GapicMetadata_ServiceAsClient_RpcsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata_ServiceAsClient_RpcsEntry>): GapicMetadata_ServiceAsClient_RpcsEntry {
    const message = createBaseGapicMetadata_ServiceAsClient_RpcsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GapicMetadata_MethodList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGapicMetadata_MethodList(): GapicMetadata_MethodList {
  return { methods: [] };
}

export const GapicMetadata_MethodList: MessageFns<GapicMetadata_MethodList> = {
  encode(message: GapicMetadata_MethodList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.methods) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GapicMetadata_MethodList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGapicMetadata_MethodList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.methods.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GapicMetadata_MethodList {
    return {
      methods: globalThis.Array.isArray(object?.methods) ? object.methods.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GapicMetadata_MethodList): unknown {
    const obj: any = {};
    if (message.methods?.length) {
      obj.methods = message.methods;
    }
    return obj;
  },

  create(base?: DeepPartial<GapicMetadata_MethodList>): GapicMetadata_MethodList {
    return GapicMetadata_MethodList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GapicMetadata_MethodList>): GapicMetadata_MethodList {
    const message = createBaseGapicMetadata_MethodList();
    message.methods = object.methods?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
