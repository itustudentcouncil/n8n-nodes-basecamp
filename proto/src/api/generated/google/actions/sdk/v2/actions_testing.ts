// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/sdk/v2/actions_testing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { LatLng } from "../../../type/latlng.js";
import { Intent } from "./conversation/intent.js";
import { Canvas } from "./conversation/prompt/content/canvas.js";
import { Prompt } from "./conversation/prompt/prompt.js";
import { ExecutionEvent } from "./event_logs.js";

export const protobufPackage = "google.actions.sdk.v2";

/** Request for playing a round of the conversation. */
export interface SendInteractionRequest {
  /**
   * Required. The project being tested, indicated by the Project ID.
   * Format: projects/{project}
   */
  project: string;
  /** Required. Input provided by the user. */
  input:
    | UserInput
    | undefined;
  /** Required. Properties of the device used for interacting with the Action. */
  deviceProperties:
    | DeviceProperties
    | undefined;
  /**
   * Opaque token that must be passed as received from SendInteractionResponse
   * on the previous interaction. This can be left unset in order to start a new
   * conversation, either as the first interaction of a testing session or to
   * abandon a previous conversation and start a new one.
   */
  conversationToken: string;
}

/** User input provided on a conversation round. */
export interface UserInput {
  /** Content of the input sent by the user. */
  query: string;
  /** Type of the input. */
  type: UserInput_InputType;
}

/** Indicates the input source, typed query or voice query. */
export enum UserInput_InputType {
  /** INPUT_TYPE_UNSPECIFIED - Unspecified input source. */
  INPUT_TYPE_UNSPECIFIED = 0,
  /** TOUCH - Query from a GUI interaction. */
  TOUCH = 1,
  /** VOICE - Voice query. */
  VOICE = 2,
  /** KEYBOARD - Typed query. */
  KEYBOARD = 3,
  /** URL - The action was triggered by a URL link. */
  URL = 4,
  UNRECOGNIZED = -1,
}

export function userInput_InputTypeFromJSON(object: any): UserInput_InputType {
  switch (object) {
    case 0:
    case "INPUT_TYPE_UNSPECIFIED":
      return UserInput_InputType.INPUT_TYPE_UNSPECIFIED;
    case 1:
    case "TOUCH":
      return UserInput_InputType.TOUCH;
    case 2:
    case "VOICE":
      return UserInput_InputType.VOICE;
    case 3:
    case "KEYBOARD":
      return UserInput_InputType.KEYBOARD;
    case 4:
    case "URL":
      return UserInput_InputType.URL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserInput_InputType.UNRECOGNIZED;
  }
}

export function userInput_InputTypeToJSON(object: UserInput_InputType): string {
  switch (object) {
    case UserInput_InputType.INPUT_TYPE_UNSPECIFIED:
      return "INPUT_TYPE_UNSPECIFIED";
    case UserInput_InputType.TOUCH:
      return "TOUCH";
    case UserInput_InputType.VOICE:
      return "VOICE";
    case UserInput_InputType.KEYBOARD:
      return "KEYBOARD";
    case UserInput_InputType.URL:
      return "URL";
    case UserInput_InputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Properties of device relevant to a conversation round. */
export interface DeviceProperties {
  /** Surface used for interacting with the Action. */
  surface: DeviceProperties_Surface;
  /** Device location such as latitude, longitude, and formatted address. */
  location:
    | Location
    | undefined;
  /**
   * Locale as set on the device.
   * The format should follow BCP 47: https://tools.ietf.org/html/bcp47
   * Examples: en, en-US, es-419 (more examples at
   * https://tools.ietf.org/html/bcp47#appendix-A).
   */
  locale: string;
  /**
   * Time zone as set on the device.
   * The format should follow the IANA Time Zone Database, e.g.
   * "America/New_York": https://www.iana.org/time-zones
   */
  timeZone: string;
}

/**
 * Possible surfaces used to interact with the Action.
 * Additional values may be included in the future.
 */
export enum DeviceProperties_Surface {
  /** SURFACE_UNSPECIFIED - Default value. This value is unused. */
  SURFACE_UNSPECIFIED = 0,
  /** SPEAKER - Speaker (e.g. Google Home). */
  SPEAKER = 1,
  /** PHONE - Phone. */
  PHONE = 2,
  /** ALLO - Allo Chat. */
  ALLO = 3,
  /** SMART_DISPLAY - Smart Display Device. */
  SMART_DISPLAY = 4,
  /** KAI_OS - KaiOS. */
  KAI_OS = 5,
  UNRECOGNIZED = -1,
}

export function deviceProperties_SurfaceFromJSON(object: any): DeviceProperties_Surface {
  switch (object) {
    case 0:
    case "SURFACE_UNSPECIFIED":
      return DeviceProperties_Surface.SURFACE_UNSPECIFIED;
    case 1:
    case "SPEAKER":
      return DeviceProperties_Surface.SPEAKER;
    case 2:
    case "PHONE":
      return DeviceProperties_Surface.PHONE;
    case 3:
    case "ALLO":
      return DeviceProperties_Surface.ALLO;
    case 4:
    case "SMART_DISPLAY":
      return DeviceProperties_Surface.SMART_DISPLAY;
    case 5:
    case "KAI_OS":
      return DeviceProperties_Surface.KAI_OS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceProperties_Surface.UNRECOGNIZED;
  }
}

export function deviceProperties_SurfaceToJSON(object: DeviceProperties_Surface): string {
  switch (object) {
    case DeviceProperties_Surface.SURFACE_UNSPECIFIED:
      return "SURFACE_UNSPECIFIED";
    case DeviceProperties_Surface.SPEAKER:
      return "SPEAKER";
    case DeviceProperties_Surface.PHONE:
      return "PHONE";
    case DeviceProperties_Surface.ALLO:
      return "ALLO";
    case DeviceProperties_Surface.SMART_DISPLAY:
      return "SMART_DISPLAY";
    case DeviceProperties_Surface.KAI_OS:
      return "KAI_OS";
    case DeviceProperties_Surface.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Container that represents a location. */
export interface Location {
  /**
   * Geo coordinates.
   * Requires the [DEVICE_PRECISE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_PRECISE_LOCATION] permission.
   */
  coordinates:
    | LatLng
    | undefined;
  /**
   * Display address, e.g., "1600 Amphitheatre Pkwy, Mountain View, CA 94043".
   * Requires the [DEVICE_PRECISE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_PRECISE_LOCATION] permission.
   */
  formattedAddress: string;
  /**
   * Zip code.
   * Requires the [DEVICE_PRECISE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_PRECISE_LOCATION] or
   * [DEVICE_COARSE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_COARSE_LOCATION] permission.
   */
  zipCode: string;
  /**
   * City.
   * Requires the [DEVICE_PRECISE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_PRECISE_LOCATION] or
   * [DEVICE_COARSE_LOCATION]
   * [google.actions.v2.Permission.DEVICE_COARSE_LOCATION] permission.
   */
  city: string;
}

/** Response to a round of the conversation. */
export interface SendInteractionResponse {
  /** Output provided to the user. */
  output:
    | Output
    | undefined;
  /** Diagnostics information that explains how the request was handled. */
  diagnostics:
    | Diagnostics
    | undefined;
  /**
   * Opaque token to be set on SendInteractionRequest on the next RPC call in
   * order to continue the same conversation.
   */
  conversationToken: string;
}

/** User-visible output to the conversation round. */
export interface Output {
  /** Spoken response sent to user as a plain string. */
  text: string;
  /**
   * Speech content produced by the Action. This may include markup elements
   * such as SSML.
   */
  speech: string[];
  /** Interactive Canvas content. */
  canvas:
    | Canvas
    | undefined;
  /**
   * State of the prompt at the end of the conversation round.
   * More information about the prompt:
   * https://developers.google.com/assistant/conversational/prompts
   */
  actionsBuilderPrompt: Prompt | undefined;
}

/** Diagnostics information related to the conversation round. */
export interface Diagnostics {
  /**
   * List of events with details about processing of the conversation round
   * throughout the stages of the Actions Builder interaction model.
   * Populated for Actions Builder & Actions SDK apps only.
   */
  actionsBuilderEvents: ExecutionEvent[];
}

/** Request for finding matching intents. */
export interface MatchIntentsRequest {
  /**
   * Required. The project being tested, indicated by the Project ID.
   * Format: projects/{project}
   */
  project: string;
  /** Required. User query as plain text. */
  query: string;
  /**
   * Required. Locale to use to evaluate the query, such as "en".
   * The format should follow BCP 47: https://tools.ietf.org/html/bcp47
   * See the list of supported languages in
   * https://developers.google.com/assistant/console/languages-locales
   */
  locale: string;
}

/** Response for finding matching intents. */
export interface MatchIntentsResponse {
  /**
   * Intents matched, ordered from most to least relevant. Only the first
   * 50 matches are returned.
   */
  matchedIntents: Intent[];
}

/** Request for setting Web & App Activity preferences. */
export interface SetWebAndAppActivityControlRequest {
  /** Whether the setting should be set to an enabled or disabled state. */
  enabled: boolean;
}

function createBaseSendInteractionRequest(): SendInteractionRequest {
  return { project: "", input: undefined, deviceProperties: undefined, conversationToken: "" };
}

export const SendInteractionRequest: MessageFns<SendInteractionRequest> = {
  encode(message: SendInteractionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.input !== undefined) {
      UserInput.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.deviceProperties !== undefined) {
      DeviceProperties.encode(message.deviceProperties, writer.uint32(26).fork()).join();
    }
    if (message.conversationToken !== "") {
      writer.uint32(34).string(message.conversationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendInteractionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendInteractionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = UserInput.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deviceProperties = DeviceProperties.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.conversationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendInteractionRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      input: isSet(object.input) ? UserInput.fromJSON(object.input) : undefined,
      deviceProperties: isSet(object.deviceProperties) ? DeviceProperties.fromJSON(object.deviceProperties) : undefined,
      conversationToken: isSet(object.conversationToken) ? globalThis.String(object.conversationToken) : "",
    };
  },

  toJSON(message: SendInteractionRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.input !== undefined) {
      obj.input = UserInput.toJSON(message.input);
    }
    if (message.deviceProperties !== undefined) {
      obj.deviceProperties = DeviceProperties.toJSON(message.deviceProperties);
    }
    if (message.conversationToken !== "") {
      obj.conversationToken = message.conversationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SendInteractionRequest>): SendInteractionRequest {
    return SendInteractionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendInteractionRequest>): SendInteractionRequest {
    const message = createBaseSendInteractionRequest();
    message.project = object.project ?? "";
    message.input = (object.input !== undefined && object.input !== null)
      ? UserInput.fromPartial(object.input)
      : undefined;
    message.deviceProperties = (object.deviceProperties !== undefined && object.deviceProperties !== null)
      ? DeviceProperties.fromPartial(object.deviceProperties)
      : undefined;
    message.conversationToken = object.conversationToken ?? "";
    return message;
  },
};

function createBaseUserInput(): UserInput {
  return { query: "", type: 0 };
}

export const UserInput: MessageFns<UserInput> = {
  encode(message: UserInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInput {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      type: isSet(object.type) ? userInput_InputTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: UserInput): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.type !== 0) {
      obj.type = userInput_InputTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<UserInput>): UserInput {
    return UserInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInput>): UserInput {
    const message = createBaseUserInput();
    message.query = object.query ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDeviceProperties(): DeviceProperties {
  return { surface: 0, location: undefined, locale: "", timeZone: "" };
}

export const DeviceProperties: MessageFns<DeviceProperties> = {
  encode(message: DeviceProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.surface !== 0) {
      writer.uint32(8).int32(message.surface);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(18).fork()).join();
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.timeZone !== "") {
      writer.uint32(34).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.surface = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceProperties {
    return {
      surface: isSet(object.surface) ? deviceProperties_SurfaceFromJSON(object.surface) : 0,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
    };
  },

  toJSON(message: DeviceProperties): unknown {
    const obj: any = {};
    if (message.surface !== 0) {
      obj.surface = deviceProperties_SurfaceToJSON(message.surface);
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceProperties>): DeviceProperties {
    return DeviceProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceProperties>): DeviceProperties {
    const message = createBaseDeviceProperties();
    message.surface = object.surface ?? 0;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    message.locale = object.locale ?? "";
    message.timeZone = object.timeZone ?? "";
    return message;
  },
};

function createBaseLocation(): Location {
  return { coordinates: undefined, formattedAddress: "", zipCode: "", city: "" };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coordinates !== undefined) {
      LatLng.encode(message.coordinates, writer.uint32(10).fork()).join();
    }
    if (message.formattedAddress !== "") {
      writer.uint32(18).string(message.formattedAddress);
    }
    if (message.zipCode !== "") {
      writer.uint32(26).string(message.zipCode);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coordinates = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.formattedAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zipCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      coordinates: isSet(object.coordinates) ? LatLng.fromJSON(object.coordinates) : undefined,
      formattedAddress: isSet(object.formattedAddress) ? globalThis.String(object.formattedAddress) : "",
      zipCode: isSet(object.zipCode) ? globalThis.String(object.zipCode) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.coordinates !== undefined) {
      obj.coordinates = LatLng.toJSON(message.coordinates);
    }
    if (message.formattedAddress !== "") {
      obj.formattedAddress = message.formattedAddress;
    }
    if (message.zipCode !== "") {
      obj.zipCode = message.zipCode;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    return obj;
  },

  create(base?: DeepPartial<Location>): Location {
    return Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Location>): Location {
    const message = createBaseLocation();
    message.coordinates = (object.coordinates !== undefined && object.coordinates !== null)
      ? LatLng.fromPartial(object.coordinates)
      : undefined;
    message.formattedAddress = object.formattedAddress ?? "";
    message.zipCode = object.zipCode ?? "";
    message.city = object.city ?? "";
    return message;
  },
};

function createBaseSendInteractionResponse(): SendInteractionResponse {
  return { output: undefined, diagnostics: undefined, conversationToken: "" };
}

export const SendInteractionResponse: MessageFns<SendInteractionResponse> = {
  encode(message: SendInteractionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(10).fork()).join();
    }
    if (message.diagnostics !== undefined) {
      Diagnostics.encode(message.diagnostics, writer.uint32(18).fork()).join();
    }
    if (message.conversationToken !== "") {
      writer.uint32(26).string(message.conversationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendInteractionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendInteractionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.diagnostics = Diagnostics.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversationToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendInteractionResponse {
    return {
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
      diagnostics: isSet(object.diagnostics) ? Diagnostics.fromJSON(object.diagnostics) : undefined,
      conversationToken: isSet(object.conversationToken) ? globalThis.String(object.conversationToken) : "",
    };
  },

  toJSON(message: SendInteractionResponse): unknown {
    const obj: any = {};
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    if (message.diagnostics !== undefined) {
      obj.diagnostics = Diagnostics.toJSON(message.diagnostics);
    }
    if (message.conversationToken !== "") {
      obj.conversationToken = message.conversationToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SendInteractionResponse>): SendInteractionResponse {
    return SendInteractionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendInteractionResponse>): SendInteractionResponse {
    const message = createBaseSendInteractionResponse();
    message.output = (object.output !== undefined && object.output !== null)
      ? Output.fromPartial(object.output)
      : undefined;
    message.diagnostics = (object.diagnostics !== undefined && object.diagnostics !== null)
      ? Diagnostics.fromPartial(object.diagnostics)
      : undefined;
    message.conversationToken = object.conversationToken ?? "";
    return message;
  },
};

function createBaseOutput(): Output {
  return { text: "", speech: [], canvas: undefined, actionsBuilderPrompt: undefined };
}

export const Output: MessageFns<Output> = {
  encode(message: Output, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.speech) {
      writer.uint32(18).string(v!);
    }
    if (message.canvas !== undefined) {
      Canvas.encode(message.canvas, writer.uint32(26).fork()).join();
    }
    if (message.actionsBuilderPrompt !== undefined) {
      Prompt.encode(message.actionsBuilderPrompt, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.speech.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.canvas = Canvas.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actionsBuilderPrompt = Prompt.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      speech: globalThis.Array.isArray(object?.speech) ? object.speech.map((e: any) => globalThis.String(e)) : [],
      canvas: isSet(object.canvas) ? Canvas.fromJSON(object.canvas) : undefined,
      actionsBuilderPrompt: isSet(object.actionsBuilderPrompt)
        ? Prompt.fromJSON(object.actionsBuilderPrompt)
        : undefined,
    };
  },

  toJSON(message: Output): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.speech?.length) {
      obj.speech = message.speech;
    }
    if (message.canvas !== undefined) {
      obj.canvas = Canvas.toJSON(message.canvas);
    }
    if (message.actionsBuilderPrompt !== undefined) {
      obj.actionsBuilderPrompt = Prompt.toJSON(message.actionsBuilderPrompt);
    }
    return obj;
  },

  create(base?: DeepPartial<Output>): Output {
    return Output.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Output>): Output {
    const message = createBaseOutput();
    message.text = object.text ?? "";
    message.speech = object.speech?.map((e) => e) || [];
    message.canvas = (object.canvas !== undefined && object.canvas !== null)
      ? Canvas.fromPartial(object.canvas)
      : undefined;
    message.actionsBuilderPrompt = (object.actionsBuilderPrompt !== undefined && object.actionsBuilderPrompt !== null)
      ? Prompt.fromPartial(object.actionsBuilderPrompt)
      : undefined;
    return message;
  },
};

function createBaseDiagnostics(): Diagnostics {
  return { actionsBuilderEvents: [] };
}

export const Diagnostics: MessageFns<Diagnostics> = {
  encode(message: Diagnostics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionsBuilderEvents) {
      ExecutionEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Diagnostics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionsBuilderEvents.push(ExecutionEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Diagnostics {
    return {
      actionsBuilderEvents: globalThis.Array.isArray(object?.actionsBuilderEvents)
        ? object.actionsBuilderEvents.map((e: any) => ExecutionEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Diagnostics): unknown {
    const obj: any = {};
    if (message.actionsBuilderEvents?.length) {
      obj.actionsBuilderEvents = message.actionsBuilderEvents.map((e) => ExecutionEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Diagnostics>): Diagnostics {
    return Diagnostics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Diagnostics>): Diagnostics {
    const message = createBaseDiagnostics();
    message.actionsBuilderEvents = object.actionsBuilderEvents?.map((e) => ExecutionEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMatchIntentsRequest(): MatchIntentsRequest {
  return { project: "", query: "", locale: "" };
}

export const MatchIntentsRequest: MessageFns<MatchIntentsRequest> = {
  encode(message: MatchIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchIntentsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
    };
  },

  toJSON(message: MatchIntentsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    return obj;
  },

  create(base?: DeepPartial<MatchIntentsRequest>): MatchIntentsRequest {
    return MatchIntentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchIntentsRequest>): MatchIntentsRequest {
    const message = createBaseMatchIntentsRequest();
    message.project = object.project ?? "";
    message.query = object.query ?? "";
    message.locale = object.locale ?? "";
    return message;
  },
};

function createBaseMatchIntentsResponse(): MatchIntentsResponse {
  return { matchedIntents: [] };
}

export const MatchIntentsResponse: MessageFns<MatchIntentsResponse> = {
  encode(message: MatchIntentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matchedIntents) {
      Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchIntentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchIntentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchedIntents.push(Intent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchIntentsResponse {
    return {
      matchedIntents: globalThis.Array.isArray(object?.matchedIntents)
        ? object.matchedIntents.map((e: any) => Intent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MatchIntentsResponse): unknown {
    const obj: any = {};
    if (message.matchedIntents?.length) {
      obj.matchedIntents = message.matchedIntents.map((e) => Intent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MatchIntentsResponse>): MatchIntentsResponse {
    return MatchIntentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchIntentsResponse>): MatchIntentsResponse {
    const message = createBaseMatchIntentsResponse();
    message.matchedIntents = object.matchedIntents?.map((e) => Intent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSetWebAndAppActivityControlRequest(): SetWebAndAppActivityControlRequest {
  return { enabled: false };
}

export const SetWebAndAppActivityControlRequest: MessageFns<SetWebAndAppActivityControlRequest> = {
  encode(message: SetWebAndAppActivityControlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetWebAndAppActivityControlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetWebAndAppActivityControlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetWebAndAppActivityControlRequest {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: SetWebAndAppActivityControlRequest): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<SetWebAndAppActivityControlRequest>): SetWebAndAppActivityControlRequest {
    return SetWebAndAppActivityControlRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetWebAndAppActivityControlRequest>): SetWebAndAppActivityControlRequest {
    const message = createBaseSetWebAndAppActivityControlRequest();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

/** Actions Testing API which allows developers to run automated tests. */
export type ActionsTestingDefinition = typeof ActionsTestingDefinition;
export const ActionsTestingDefinition = {
  name: "ActionsTesting",
  fullName: "google.actions.sdk.v2.ActionsTesting",
  methods: {
    /** Plays one round of the conversation. */
    sendInteraction: {
      name: "SendInteraction",
      requestType: SendInteractionRequest,
      requestStream: false,
      responseType: SendInteractionResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              58,
              1,
              42,
              34,
              40,
              47,
              118,
              50,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              110,
              100,
              73,
              110,
              116,
              101,
              114,
              97,
              99,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Finds the intents that match a given query. */
    matchIntents: {
      name: "MatchIntents",
      requestType: MatchIntentsRequest,
      requestStream: false,
      responseType: MatchIntentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              44,
              113,
              117,
              101,
              114,
              121,
              44,
              108,
              111,
              99,
              97,
              108,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              109,
              97,
              116,
              99,
              104,
              73,
              110,
              116,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the Web & App Activity control on a service account.
     *
     * It is necessary to have this setting enabled in order to use call Actions.
     * The setting is originally disabled for service accounts, and it is
     * preserved until set to a different value. This means it only needs to be
     * enabled once per account (and not necessarily once per test), unless it is
     * later disabled.
     *
     * Returns an error if the caller is not a service account. User accounts can
     * change this setting via the Activity Controls page. See
     * https://support.google.com/websearch/answer/54068.
     */
    setWebAndAppActivityControl: {
      name: "SetWebAndAppActivityControl",
      requestType: SetWebAndAppActivityControlRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([7, 101, 110, 97, 98, 108, 101, 100])],
          578365826: [
            Buffer.from([
              36,
              58,
              1,
              42,
              34,
              31,
              47,
              118,
              50,
              58,
              115,
              101,
              116,
              87,
              101,
              98,
              65,
              110,
              100,
              65,
              112,
              112,
              65,
              99,
              116,
              105,
              118,
              105,
              116,
              121,
              67,
              111,
              110,
              116,
              114,
              111,
              108,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ActionsTestingServiceImplementation<CallContextExt = {}> {
  /** Plays one round of the conversation. */
  sendInteraction(
    request: SendInteractionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SendInteractionResponse>>;
  /** Finds the intents that match a given query. */
  matchIntents(
    request: MatchIntentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MatchIntentsResponse>>;
  /**
   * Sets the Web & App Activity control on a service account.
   *
   * It is necessary to have this setting enabled in order to use call Actions.
   * The setting is originally disabled for service accounts, and it is
   * preserved until set to a different value. This means it only needs to be
   * enabled once per account (and not necessarily once per test), unless it is
   * later disabled.
   *
   * Returns an error if the caller is not a service account. User accounts can
   * change this setting via the Activity Controls page. See
   * https://support.google.com/websearch/answer/54068.
   */
  setWebAndAppActivityControl(
    request: SetWebAndAppActivityControlRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface ActionsTestingClient<CallOptionsExt = {}> {
  /** Plays one round of the conversation. */
  sendInteraction(
    request: DeepPartial<SendInteractionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SendInteractionResponse>;
  /** Finds the intents that match a given query. */
  matchIntents(
    request: DeepPartial<MatchIntentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MatchIntentsResponse>;
  /**
   * Sets the Web & App Activity control on a service account.
   *
   * It is necessary to have this setting enabled in order to use call Actions.
   * The setting is originally disabled for service accounts, and it is
   * preserved until set to a different value. This means it only needs to be
   * enabled once per account (and not necessarily once per test), unless it is
   * later disabled.
   *
   * Returns an error if the caller is not a service account. User accounts can
   * change this setting via the Activity Controls page. See
   * https://support.google.com/websearch/answer/54068.
   */
  setWebAndAppActivityControl(
    request: DeepPartial<SetWebAndAppActivityControlRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
