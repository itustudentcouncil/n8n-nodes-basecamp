// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/sdk/v2/event_logs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { IntentParameterValue } from "./conversation/intent.js";
import { Prompt } from "./conversation/prompt/prompt.js";
import { Slot, SlotFillingStatus, slotFillingStatusFromJSON, slotFillingStatusToJSON } from "./conversation/scene.js";

export const protobufPackage = "google.actions.sdk.v2";

/**
 * Contains information about execution event which happened during processing
 * Actions Builder conversation request. For an overview of the stages involved
 * in a conversation request, see
 * https://developers.google.com/assistant/conversational/actions.
 */
export interface ExecutionEvent {
  /** Timestamp when the event happened. */
  eventTime:
    | Date
    | undefined;
  /** State of the execution during this event. */
  executionState:
    | ExecutionState
    | undefined;
  /** Resulting status of particular execution step. */
  status:
    | Status
    | undefined;
  /** User input handling event. */
  userInput?:
    | UserConversationInput
    | undefined;
  /** Intent matching event. */
  intentMatch?:
    | IntentMatch
    | undefined;
  /** Condition evaluation event. */
  conditionsEvaluated?:
    | ConditionsEvaluated
    | undefined;
  /** OnSceneEnter execution event. */
  onSceneEnter?:
    | OnSceneEnter
    | undefined;
  /** Webhook request dispatch event. */
  webhookRequest?:
    | WebhookRequest
    | undefined;
  /** Webhook response receipt event. */
  webhookResponse?:
    | WebhookResponse
    | undefined;
  /** Webhook-initiated transition event. */
  webhookInitiatedTransition?:
    | WebhookInitiatedTransition
    | undefined;
  /** Slot matching event. */
  slotMatch?:
    | SlotMatch
    | undefined;
  /** Slot requesting event. */
  slotRequested?:
    | SlotRequested
    | undefined;
  /** Slot validation event. */
  slotValidated?:
    | SlotValidated
    | undefined;
  /** Form filling event. */
  formFilled?:
    | FormFilled
    | undefined;
  /** Waiting-for-user-input event. */
  waitingUserInput?:
    | WaitingForUserInput
    | undefined;
  /** End-of-conversation event. */
  endConversation?:
    | EndConversation
    | undefined;
  /**
   * List of warnings generated during execution of this Event. Warnings are
   * tips for the developer discovered during the conversation request. These
   * are usually non-critical and do not halt the execution of the request. For
   * example, a warnings might be generated when webhook tries to override a
   * custom Type which does not exist. Errors are reported as a failed status
   * code, but warnings can be present even when the status is OK.
   */
  warningMessages: string[];
}

/** Current state of the execution. */
export interface ExecutionState {
  /** ID of the scene which is currently  active. */
  currentSceneId: string;
  /**
   * State of the session storage:
   * https://developers.google.com/assistant/conversational/storage-session
   */
  sessionStorage:
    | { [key: string]: any }
    | undefined;
  /**
   * State of the slots filling, if applicable:
   * https://developers.google.com/assistant/conversational/scenes#slot_filling
   */
  slots:
    | Slots
    | undefined;
  /**
   * Prompt queue:
   * https://developers.google.com/assistant/conversational/prompts
   */
  promptQueue: Prompt[];
  /**
   * State of the user storage:
   * https://developers.google.com/assistant/conversational/storage-user
   */
  userStorage:
    | { [key: string]: any }
    | undefined;
  /**
   * State of the home storage:
   * https://developers.google.com/assistant/conversational/storage-home
   */
  householdStorage: { [key: string]: any } | undefined;
}

/** Represents the current state of a the scene's slots. */
export interface Slots {
  /** The current status of slot filling. */
  status: SlotFillingStatus;
  /** The slots associated with the current scene. */
  slots: { [key: string]: Slot };
}

export interface Slots_SlotsEntry {
  key: string;
  value: Slot | undefined;
}

/** Information related to user input. */
export interface UserConversationInput {
  /** Type of user input. E.g. keyboard, voice, touch, etc. */
  type: string;
  /** Original text input from the user. */
  originalQuery: string;
}

/**
 * Information about triggered intent match (global or within a scene):
 * https://developers.google.com/assistant/conversational/intents
 */
export interface IntentMatch {
  /** Intent id which triggered this interaction. */
  intentId: string;
  /** Parameters of intent which triggered this interaction. */
  intentParameters: { [key: string]: IntentParameterValue };
  /** Name of the handler attached to this interaction. */
  handler: string;
  /** Scene to which this interaction leads to. */
  nextSceneId: string;
}

export interface IntentMatch_IntentParametersEntry {
  key: string;
  value: IntentParameterValue | undefined;
}

/**
 * Results of conditions evaluation:
 * https://developers.google.com/assistant/conversational/scenes#conditions
 */
export interface ConditionsEvaluated {
  /** List of conditions which were evaluated to 'false'. */
  failedConditions: Condition[];
  /** The first condition which was evaluated to 'true', if any. */
  successCondition: Condition | undefined;
}

/** Evaluated condition. */
export interface Condition {
  /** Expression specified in this condition. */
  expression: string;
  /** Handler name specified in evaluated condition. */
  handler: string;
  /** Destination scene specified in evaluated condition. */
  nextSceneId: string;
}

/**
 * Information about execution of onSceneEnter stage:
 * https://developers.google.com/assistant/conversational/scenes#on_enter
 */
export interface OnSceneEnter {
  /** Handler name specified in onSceneEnter event. */
  handler: string;
}

/**
 * Event triggered by destination scene returned from webhook:
 * https://developers.google.com/assistant/conversational/webhooks#transition_scenes
 */
export interface WebhookInitiatedTransition {
  /** ID of the scene the transition is leading to. */
  nextSceneId: string;
}

/**
 * Information about a request dispatched to the Action webhook:
 * https://developers.google.com/assistant/conversational/webhooks#payloads
 */
export interface WebhookRequest {
  /** Payload of the webhook request. */
  requestJson: string;
}

/**
 * Information about a response received from the Action webhook:
 * https://developers.google.com/assistant/conversational/webhooks#payloads
 */
export interface WebhookResponse {
  /** Payload of the webhook response. */
  responseJson: string;
}

/**
 * Information about matched slot(s):
 * https://developers.google.com/assistant/conversational/scenes#slot_filling
 */
export interface SlotMatch {
  /** Parameters extracted by NLU from user input. */
  nluParameters: { [key: string]: IntentParameterValue };
}

export interface SlotMatch_NluParametersEntry {
  key: string;
  value: IntentParameterValue | undefined;
}

/**
 * Information about currently requested slot:
 * https://developers.google.com/assistant/conversational/scenes#slot_filling
 */
export interface SlotRequested {
  /** Name of the requested slot. */
  slot: string;
  /** Slot prompt. */
  prompt: Prompt | undefined;
}

/**
 * Event which happens after webhook validation was finished for slot(s):
 * https://developers.google.com/assistant/conversational/scenes#slot_filling
 */
export interface SlotValidated {
}

/**
 * Event which happens when form is fully filled:
 * https://developers.google.com/assistant/conversational/scenes#slot_filling
 */
export interface FormFilled {
}

/**
 * Event which happens when system needs user input:
 * https://developers.google.com/assistant/conversational/scenes#input
 */
export interface WaitingForUserInput {
}

/** Event which informs that conversation with agent was ended. */
export interface EndConversation {
}

function createBaseExecutionEvent(): ExecutionEvent {
  return {
    eventTime: undefined,
    executionState: undefined,
    status: undefined,
    userInput: undefined,
    intentMatch: undefined,
    conditionsEvaluated: undefined,
    onSceneEnter: undefined,
    webhookRequest: undefined,
    webhookResponse: undefined,
    webhookInitiatedTransition: undefined,
    slotMatch: undefined,
    slotRequested: undefined,
    slotValidated: undefined,
    formFilled: undefined,
    waitingUserInput: undefined,
    endConversation: undefined,
    warningMessages: [],
  };
}

export const ExecutionEvent: MessageFns<ExecutionEvent> = {
  encode(message: ExecutionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(10).fork()).join();
    }
    if (message.executionState !== undefined) {
      ExecutionState.encode(message.executionState, writer.uint32(18).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    if (message.userInput !== undefined) {
      UserConversationInput.encode(message.userInput, writer.uint32(34).fork()).join();
    }
    if (message.intentMatch !== undefined) {
      IntentMatch.encode(message.intentMatch, writer.uint32(42).fork()).join();
    }
    if (message.conditionsEvaluated !== undefined) {
      ConditionsEvaluated.encode(message.conditionsEvaluated, writer.uint32(50).fork()).join();
    }
    if (message.onSceneEnter !== undefined) {
      OnSceneEnter.encode(message.onSceneEnter, writer.uint32(58).fork()).join();
    }
    if (message.webhookRequest !== undefined) {
      WebhookRequest.encode(message.webhookRequest, writer.uint32(66).fork()).join();
    }
    if (message.webhookResponse !== undefined) {
      WebhookResponse.encode(message.webhookResponse, writer.uint32(74).fork()).join();
    }
    if (message.webhookInitiatedTransition !== undefined) {
      WebhookInitiatedTransition.encode(message.webhookInitiatedTransition, writer.uint32(82).fork()).join();
    }
    if (message.slotMatch !== undefined) {
      SlotMatch.encode(message.slotMatch, writer.uint32(90).fork()).join();
    }
    if (message.slotRequested !== undefined) {
      SlotRequested.encode(message.slotRequested, writer.uint32(98).fork()).join();
    }
    if (message.slotValidated !== undefined) {
      SlotValidated.encode(message.slotValidated, writer.uint32(106).fork()).join();
    }
    if (message.formFilled !== undefined) {
      FormFilled.encode(message.formFilled, writer.uint32(114).fork()).join();
    }
    if (message.waitingUserInput !== undefined) {
      WaitingForUserInput.encode(message.waitingUserInput, writer.uint32(122).fork()).join();
    }
    if (message.endConversation !== undefined) {
      EndConversation.encode(message.endConversation, writer.uint32(130).fork()).join();
    }
    for (const v of message.warningMessages) {
      writer.uint32(138).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionState = ExecutionState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userInput = UserConversationInput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intentMatch = IntentMatch.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conditionsEvaluated = ConditionsEvaluated.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onSceneEnter = OnSceneEnter.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.webhookRequest = WebhookRequest.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.webhookResponse = WebhookResponse.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.webhookInitiatedTransition = WebhookInitiatedTransition.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.slotMatch = SlotMatch.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.slotRequested = SlotRequested.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.slotValidated = SlotValidated.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.formFilled = FormFilled.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.waitingUserInput = WaitingForUserInput.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.endConversation = EndConversation.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.warningMessages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionEvent {
    return {
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      executionState: isSet(object.executionState) ? ExecutionState.fromJSON(object.executionState) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      userInput: isSet(object.userInput) ? UserConversationInput.fromJSON(object.userInput) : undefined,
      intentMatch: isSet(object.intentMatch) ? IntentMatch.fromJSON(object.intentMatch) : undefined,
      conditionsEvaluated: isSet(object.conditionsEvaluated)
        ? ConditionsEvaluated.fromJSON(object.conditionsEvaluated)
        : undefined,
      onSceneEnter: isSet(object.onSceneEnter) ? OnSceneEnter.fromJSON(object.onSceneEnter) : undefined,
      webhookRequest: isSet(object.webhookRequest) ? WebhookRequest.fromJSON(object.webhookRequest) : undefined,
      webhookResponse: isSet(object.webhookResponse) ? WebhookResponse.fromJSON(object.webhookResponse) : undefined,
      webhookInitiatedTransition: isSet(object.webhookInitiatedTransition)
        ? WebhookInitiatedTransition.fromJSON(object.webhookInitiatedTransition)
        : undefined,
      slotMatch: isSet(object.slotMatch) ? SlotMatch.fromJSON(object.slotMatch) : undefined,
      slotRequested: isSet(object.slotRequested) ? SlotRequested.fromJSON(object.slotRequested) : undefined,
      slotValidated: isSet(object.slotValidated) ? SlotValidated.fromJSON(object.slotValidated) : undefined,
      formFilled: isSet(object.formFilled) ? FormFilled.fromJSON(object.formFilled) : undefined,
      waitingUserInput: isSet(object.waitingUserInput)
        ? WaitingForUserInput.fromJSON(object.waitingUserInput)
        : undefined,
      endConversation: isSet(object.endConversation) ? EndConversation.fromJSON(object.endConversation) : undefined,
      warningMessages: globalThis.Array.isArray(object?.warningMessages)
        ? object.warningMessages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExecutionEvent): unknown {
    const obj: any = {};
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.executionState !== undefined) {
      obj.executionState = ExecutionState.toJSON(message.executionState);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.userInput !== undefined) {
      obj.userInput = UserConversationInput.toJSON(message.userInput);
    }
    if (message.intentMatch !== undefined) {
      obj.intentMatch = IntentMatch.toJSON(message.intentMatch);
    }
    if (message.conditionsEvaluated !== undefined) {
      obj.conditionsEvaluated = ConditionsEvaluated.toJSON(message.conditionsEvaluated);
    }
    if (message.onSceneEnter !== undefined) {
      obj.onSceneEnter = OnSceneEnter.toJSON(message.onSceneEnter);
    }
    if (message.webhookRequest !== undefined) {
      obj.webhookRequest = WebhookRequest.toJSON(message.webhookRequest);
    }
    if (message.webhookResponse !== undefined) {
      obj.webhookResponse = WebhookResponse.toJSON(message.webhookResponse);
    }
    if (message.webhookInitiatedTransition !== undefined) {
      obj.webhookInitiatedTransition = WebhookInitiatedTransition.toJSON(message.webhookInitiatedTransition);
    }
    if (message.slotMatch !== undefined) {
      obj.slotMatch = SlotMatch.toJSON(message.slotMatch);
    }
    if (message.slotRequested !== undefined) {
      obj.slotRequested = SlotRequested.toJSON(message.slotRequested);
    }
    if (message.slotValidated !== undefined) {
      obj.slotValidated = SlotValidated.toJSON(message.slotValidated);
    }
    if (message.formFilled !== undefined) {
      obj.formFilled = FormFilled.toJSON(message.formFilled);
    }
    if (message.waitingUserInput !== undefined) {
      obj.waitingUserInput = WaitingForUserInput.toJSON(message.waitingUserInput);
    }
    if (message.endConversation !== undefined) {
      obj.endConversation = EndConversation.toJSON(message.endConversation);
    }
    if (message.warningMessages?.length) {
      obj.warningMessages = message.warningMessages;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionEvent>): ExecutionEvent {
    return ExecutionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionEvent>): ExecutionEvent {
    const message = createBaseExecutionEvent();
    message.eventTime = object.eventTime ?? undefined;
    message.executionState = (object.executionState !== undefined && object.executionState !== null)
      ? ExecutionState.fromPartial(object.executionState)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.userInput = (object.userInput !== undefined && object.userInput !== null)
      ? UserConversationInput.fromPartial(object.userInput)
      : undefined;
    message.intentMatch = (object.intentMatch !== undefined && object.intentMatch !== null)
      ? IntentMatch.fromPartial(object.intentMatch)
      : undefined;
    message.conditionsEvaluated = (object.conditionsEvaluated !== undefined && object.conditionsEvaluated !== null)
      ? ConditionsEvaluated.fromPartial(object.conditionsEvaluated)
      : undefined;
    message.onSceneEnter = (object.onSceneEnter !== undefined && object.onSceneEnter !== null)
      ? OnSceneEnter.fromPartial(object.onSceneEnter)
      : undefined;
    message.webhookRequest = (object.webhookRequest !== undefined && object.webhookRequest !== null)
      ? WebhookRequest.fromPartial(object.webhookRequest)
      : undefined;
    message.webhookResponse = (object.webhookResponse !== undefined && object.webhookResponse !== null)
      ? WebhookResponse.fromPartial(object.webhookResponse)
      : undefined;
    message.webhookInitiatedTransition =
      (object.webhookInitiatedTransition !== undefined && object.webhookInitiatedTransition !== null)
        ? WebhookInitiatedTransition.fromPartial(object.webhookInitiatedTransition)
        : undefined;
    message.slotMatch = (object.slotMatch !== undefined && object.slotMatch !== null)
      ? SlotMatch.fromPartial(object.slotMatch)
      : undefined;
    message.slotRequested = (object.slotRequested !== undefined && object.slotRequested !== null)
      ? SlotRequested.fromPartial(object.slotRequested)
      : undefined;
    message.slotValidated = (object.slotValidated !== undefined && object.slotValidated !== null)
      ? SlotValidated.fromPartial(object.slotValidated)
      : undefined;
    message.formFilled = (object.formFilled !== undefined && object.formFilled !== null)
      ? FormFilled.fromPartial(object.formFilled)
      : undefined;
    message.waitingUserInput = (object.waitingUserInput !== undefined && object.waitingUserInput !== null)
      ? WaitingForUserInput.fromPartial(object.waitingUserInput)
      : undefined;
    message.endConversation = (object.endConversation !== undefined && object.endConversation !== null)
      ? EndConversation.fromPartial(object.endConversation)
      : undefined;
    message.warningMessages = object.warningMessages?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecutionState(): ExecutionState {
  return {
    currentSceneId: "",
    sessionStorage: undefined,
    slots: undefined,
    promptQueue: [],
    userStorage: undefined,
    householdStorage: undefined,
  };
}

export const ExecutionState: MessageFns<ExecutionState> = {
  encode(message: ExecutionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentSceneId !== "") {
      writer.uint32(10).string(message.currentSceneId);
    }
    if (message.sessionStorage !== undefined) {
      Struct.encode(Struct.wrap(message.sessionStorage), writer.uint32(18).fork()).join();
    }
    if (message.slots !== undefined) {
      Slots.encode(message.slots, writer.uint32(42).fork()).join();
    }
    for (const v of message.promptQueue) {
      Prompt.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.userStorage !== undefined) {
      Struct.encode(Struct.wrap(message.userStorage), writer.uint32(50).fork()).join();
    }
    if (message.householdStorage !== undefined) {
      Struct.encode(Struct.wrap(message.householdStorage), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentSceneId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionStorage = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.slots = Slots.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.promptQueue.push(Prompt.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userStorage = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.householdStorage = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionState {
    return {
      currentSceneId: isSet(object.currentSceneId) ? globalThis.String(object.currentSceneId) : "",
      sessionStorage: isObject(object.sessionStorage) ? object.sessionStorage : undefined,
      slots: isSet(object.slots) ? Slots.fromJSON(object.slots) : undefined,
      promptQueue: globalThis.Array.isArray(object?.promptQueue)
        ? object.promptQueue.map((e: any) => Prompt.fromJSON(e))
        : [],
      userStorage: isObject(object.userStorage) ? object.userStorage : undefined,
      householdStorage: isObject(object.householdStorage) ? object.householdStorage : undefined,
    };
  },

  toJSON(message: ExecutionState): unknown {
    const obj: any = {};
    if (message.currentSceneId !== "") {
      obj.currentSceneId = message.currentSceneId;
    }
    if (message.sessionStorage !== undefined) {
      obj.sessionStorage = message.sessionStorage;
    }
    if (message.slots !== undefined) {
      obj.slots = Slots.toJSON(message.slots);
    }
    if (message.promptQueue?.length) {
      obj.promptQueue = message.promptQueue.map((e) => Prompt.toJSON(e));
    }
    if (message.userStorage !== undefined) {
      obj.userStorage = message.userStorage;
    }
    if (message.householdStorage !== undefined) {
      obj.householdStorage = message.householdStorage;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionState>): ExecutionState {
    return ExecutionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionState>): ExecutionState {
    const message = createBaseExecutionState();
    message.currentSceneId = object.currentSceneId ?? "";
    message.sessionStorage = object.sessionStorage ?? undefined;
    message.slots = (object.slots !== undefined && object.slots !== null) ? Slots.fromPartial(object.slots) : undefined;
    message.promptQueue = object.promptQueue?.map((e) => Prompt.fromPartial(e)) || [];
    message.userStorage = object.userStorage ?? undefined;
    message.householdStorage = object.householdStorage ?? undefined;
    return message;
  },
};

function createBaseSlots(): Slots {
  return { status: 0, slots: {} };
}

export const Slots: MessageFns<Slots> = {
  encode(message: Slots, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    Object.entries(message.slots).forEach(([key, value]) => {
      Slots_SlotsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slots {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlots();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Slots_SlotsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.slots[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slots {
    return {
      status: isSet(object.status) ? slotFillingStatusFromJSON(object.status) : 0,
      slots: isObject(object.slots)
        ? Object.entries(object.slots).reduce<{ [key: string]: Slot }>((acc, [key, value]) => {
          acc[key] = Slot.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Slots): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = slotFillingStatusToJSON(message.status);
    }
    if (message.slots) {
      const entries = Object.entries(message.slots);
      if (entries.length > 0) {
        obj.slots = {};
        entries.forEach(([k, v]) => {
          obj.slots[k] = Slot.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Slots>): Slots {
    return Slots.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slots>): Slots {
    const message = createBaseSlots();
    message.status = object.status ?? 0;
    message.slots = Object.entries(object.slots ?? {}).reduce<{ [key: string]: Slot }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Slot.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSlots_SlotsEntry(): Slots_SlotsEntry {
  return { key: "", value: undefined };
}

export const Slots_SlotsEntry: MessageFns<Slots_SlotsEntry> = {
  encode(message: Slots_SlotsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Slot.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Slots_SlotsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlots_SlotsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Slot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Slots_SlotsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Slot.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Slots_SlotsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Slot.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Slots_SlotsEntry>): Slots_SlotsEntry {
    return Slots_SlotsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Slots_SlotsEntry>): Slots_SlotsEntry {
    const message = createBaseSlots_SlotsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Slot.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUserConversationInput(): UserConversationInput {
  return { type: "", originalQuery: "" };
}

export const UserConversationInput: MessageFns<UserConversationInput> = {
  encode(message: UserConversationInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.originalQuery !== "") {
      writer.uint32(18).string(message.originalQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserConversationInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserConversationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserConversationInput {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      originalQuery: isSet(object.originalQuery) ? globalThis.String(object.originalQuery) : "",
    };
  },

  toJSON(message: UserConversationInput): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.originalQuery !== "") {
      obj.originalQuery = message.originalQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<UserConversationInput>): UserConversationInput {
    return UserConversationInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserConversationInput>): UserConversationInput {
    const message = createBaseUserConversationInput();
    message.type = object.type ?? "";
    message.originalQuery = object.originalQuery ?? "";
    return message;
  },
};

function createBaseIntentMatch(): IntentMatch {
  return { intentId: "", intentParameters: {}, handler: "", nextSceneId: "" };
}

export const IntentMatch: MessageFns<IntentMatch> = {
  encode(message: IntentMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentId !== "") {
      writer.uint32(10).string(message.intentId);
    }
    Object.entries(message.intentParameters).forEach(([key, value]) => {
      IntentMatch_IntentParametersEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.handler !== "") {
      writer.uint32(26).string(message.handler);
    }
    if (message.nextSceneId !== "") {
      writer.uint32(34).string(message.nextSceneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intentId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = IntentMatch_IntentParametersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.intentParameters[entry5.key] = entry5.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.handler = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextSceneId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentMatch {
    return {
      intentId: isSet(object.intentId) ? globalThis.String(object.intentId) : "",
      intentParameters: isObject(object.intentParameters)
        ? Object.entries(object.intentParameters).reduce<{ [key: string]: IntentParameterValue }>(
          (acc, [key, value]) => {
            acc[key] = IntentParameterValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      handler: isSet(object.handler) ? globalThis.String(object.handler) : "",
      nextSceneId: isSet(object.nextSceneId) ? globalThis.String(object.nextSceneId) : "",
    };
  },

  toJSON(message: IntentMatch): unknown {
    const obj: any = {};
    if (message.intentId !== "") {
      obj.intentId = message.intentId;
    }
    if (message.intentParameters) {
      const entries = Object.entries(message.intentParameters);
      if (entries.length > 0) {
        obj.intentParameters = {};
        entries.forEach(([k, v]) => {
          obj.intentParameters[k] = IntentParameterValue.toJSON(v);
        });
      }
    }
    if (message.handler !== "") {
      obj.handler = message.handler;
    }
    if (message.nextSceneId !== "") {
      obj.nextSceneId = message.nextSceneId;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentMatch>): IntentMatch {
    return IntentMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentMatch>): IntentMatch {
    const message = createBaseIntentMatch();
    message.intentId = object.intentId ?? "";
    message.intentParameters = Object.entries(object.intentParameters ?? {}).reduce<
      { [key: string]: IntentParameterValue }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = IntentParameterValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.handler = object.handler ?? "";
    message.nextSceneId = object.nextSceneId ?? "";
    return message;
  },
};

function createBaseIntentMatch_IntentParametersEntry(): IntentMatch_IntentParametersEntry {
  return { key: "", value: undefined };
}

export const IntentMatch_IntentParametersEntry: MessageFns<IntentMatch_IntentParametersEntry> = {
  encode(message: IntentMatch_IntentParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      IntentParameterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentMatch_IntentParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentMatch_IntentParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = IntentParameterValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentMatch_IntentParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? IntentParameterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IntentMatch_IntentParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = IntentParameterValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<IntentMatch_IntentParametersEntry>): IntentMatch_IntentParametersEntry {
    return IntentMatch_IntentParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentMatch_IntentParametersEntry>): IntentMatch_IntentParametersEntry {
    const message = createBaseIntentMatch_IntentParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? IntentParameterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseConditionsEvaluated(): ConditionsEvaluated {
  return { failedConditions: [], successCondition: undefined };
}

export const ConditionsEvaluated: MessageFns<ConditionsEvaluated> = {
  encode(message: ConditionsEvaluated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.failedConditions) {
      Condition.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.successCondition !== undefined) {
      Condition.encode(message.successCondition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionsEvaluated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionsEvaluated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failedConditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.successCondition = Condition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionsEvaluated {
    return {
      failedConditions: globalThis.Array.isArray(object?.failedConditions)
        ? object.failedConditions.map((e: any) => Condition.fromJSON(e))
        : [],
      successCondition: isSet(object.successCondition) ? Condition.fromJSON(object.successCondition) : undefined,
    };
  },

  toJSON(message: ConditionsEvaluated): unknown {
    const obj: any = {};
    if (message.failedConditions?.length) {
      obj.failedConditions = message.failedConditions.map((e) => Condition.toJSON(e));
    }
    if (message.successCondition !== undefined) {
      obj.successCondition = Condition.toJSON(message.successCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionsEvaluated>): ConditionsEvaluated {
    return ConditionsEvaluated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionsEvaluated>): ConditionsEvaluated {
    const message = createBaseConditionsEvaluated();
    message.failedConditions = object.failedConditions?.map((e) => Condition.fromPartial(e)) || [];
    message.successCondition = (object.successCondition !== undefined && object.successCondition !== null)
      ? Condition.fromPartial(object.successCondition)
      : undefined;
    return message;
  },
};

function createBaseCondition(): Condition {
  return { expression: "", handler: "", nextSceneId: "" };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.handler !== "") {
      writer.uint32(18).string(message.handler);
    }
    if (message.nextSceneId !== "") {
      writer.uint32(26).string(message.nextSceneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handler = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextSceneId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      handler: isSet(object.handler) ? globalThis.String(object.handler) : "",
      nextSceneId: isSet(object.nextSceneId) ? globalThis.String(object.nextSceneId) : "",
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.handler !== "") {
      obj.handler = message.handler;
    }
    if (message.nextSceneId !== "") {
      obj.nextSceneId = message.nextSceneId;
    }
    return obj;
  },

  create(base?: DeepPartial<Condition>): Condition {
    return Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition>): Condition {
    const message = createBaseCondition();
    message.expression = object.expression ?? "";
    message.handler = object.handler ?? "";
    message.nextSceneId = object.nextSceneId ?? "";
    return message;
  },
};

function createBaseOnSceneEnter(): OnSceneEnter {
  return { handler: "" };
}

export const OnSceneEnter: MessageFns<OnSceneEnter> = {
  encode(message: OnSceneEnter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handler !== "") {
      writer.uint32(10).string(message.handler);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnSceneEnter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnSceneEnter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.handler = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnSceneEnter {
    return { handler: isSet(object.handler) ? globalThis.String(object.handler) : "" };
  },

  toJSON(message: OnSceneEnter): unknown {
    const obj: any = {};
    if (message.handler !== "") {
      obj.handler = message.handler;
    }
    return obj;
  },

  create(base?: DeepPartial<OnSceneEnter>): OnSceneEnter {
    return OnSceneEnter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OnSceneEnter>): OnSceneEnter {
    const message = createBaseOnSceneEnter();
    message.handler = object.handler ?? "";
    return message;
  },
};

function createBaseWebhookInitiatedTransition(): WebhookInitiatedTransition {
  return { nextSceneId: "" };
}

export const WebhookInitiatedTransition: MessageFns<WebhookInitiatedTransition> = {
  encode(message: WebhookInitiatedTransition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextSceneId !== "") {
      writer.uint32(10).string(message.nextSceneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookInitiatedTransition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookInitiatedTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextSceneId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookInitiatedTransition {
    return { nextSceneId: isSet(object.nextSceneId) ? globalThis.String(object.nextSceneId) : "" };
  },

  toJSON(message: WebhookInitiatedTransition): unknown {
    const obj: any = {};
    if (message.nextSceneId !== "") {
      obj.nextSceneId = message.nextSceneId;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookInitiatedTransition>): WebhookInitiatedTransition {
    return WebhookInitiatedTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookInitiatedTransition>): WebhookInitiatedTransition {
    const message = createBaseWebhookInitiatedTransition();
    message.nextSceneId = object.nextSceneId ?? "";
    return message;
  },
};

function createBaseWebhookRequest(): WebhookRequest {
  return { requestJson: "" };
}

export const WebhookRequest: MessageFns<WebhookRequest> = {
  encode(message: WebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestJson !== "") {
      writer.uint32(10).string(message.requestJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestJson = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest {
    return { requestJson: isSet(object.requestJson) ? globalThis.String(object.requestJson) : "" };
  },

  toJSON(message: WebhookRequest): unknown {
    const obj: any = {};
    if (message.requestJson !== "") {
      obj.requestJson = message.requestJson;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest>): WebhookRequest {
    return WebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookRequest>): WebhookRequest {
    const message = createBaseWebhookRequest();
    message.requestJson = object.requestJson ?? "";
    return message;
  },
};

function createBaseWebhookResponse(): WebhookResponse {
  return { responseJson: "" };
}

export const WebhookResponse: MessageFns<WebhookResponse> = {
  encode(message: WebhookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseJson !== "") {
      writer.uint32(10).string(message.responseJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responseJson = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookResponse {
    return { responseJson: isSet(object.responseJson) ? globalThis.String(object.responseJson) : "" };
  },

  toJSON(message: WebhookResponse): unknown {
    const obj: any = {};
    if (message.responseJson !== "") {
      obj.responseJson = message.responseJson;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookResponse>): WebhookResponse {
    return WebhookResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookResponse>): WebhookResponse {
    const message = createBaseWebhookResponse();
    message.responseJson = object.responseJson ?? "";
    return message;
  },
};

function createBaseSlotMatch(): SlotMatch {
  return { nluParameters: {} };
}

export const SlotMatch: MessageFns<SlotMatch> = {
  encode(message: SlotMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.nluParameters).forEach(([key, value]) => {
      SlotMatch_NluParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SlotMatch_NluParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.nluParameters[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlotMatch {
    return {
      nluParameters: isObject(object.nluParameters)
        ? Object.entries(object.nluParameters).reduce<{ [key: string]: IntentParameterValue }>((acc, [key, value]) => {
          acc[key] = IntentParameterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SlotMatch): unknown {
    const obj: any = {};
    if (message.nluParameters) {
      const entries = Object.entries(message.nluParameters);
      if (entries.length > 0) {
        obj.nluParameters = {};
        entries.forEach(([k, v]) => {
          obj.nluParameters[k] = IntentParameterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SlotMatch>): SlotMatch {
    return SlotMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlotMatch>): SlotMatch {
    const message = createBaseSlotMatch();
    message.nluParameters = Object.entries(object.nluParameters ?? {}).reduce<{ [key: string]: IntentParameterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = IntentParameterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSlotMatch_NluParametersEntry(): SlotMatch_NluParametersEntry {
  return { key: "", value: undefined };
}

export const SlotMatch_NluParametersEntry: MessageFns<SlotMatch_NluParametersEntry> = {
  encode(message: SlotMatch_NluParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      IntentParameterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotMatch_NluParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotMatch_NluParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = IntentParameterValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlotMatch_NluParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? IntentParameterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SlotMatch_NluParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = IntentParameterValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SlotMatch_NluParametersEntry>): SlotMatch_NluParametersEntry {
    return SlotMatch_NluParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlotMatch_NluParametersEntry>): SlotMatch_NluParametersEntry {
    const message = createBaseSlotMatch_NluParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? IntentParameterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSlotRequested(): SlotRequested {
  return { slot: "", prompt: undefined };
}

export const SlotRequested: MessageFns<SlotRequested> = {
  encode(message: SlotRequested, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slot !== "") {
      writer.uint32(10).string(message.slot);
    }
    if (message.prompt !== undefined) {
      Prompt.encode(message.prompt, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotRequested {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotRequested();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.slot = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prompt = Prompt.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlotRequested {
    return {
      slot: isSet(object.slot) ? globalThis.String(object.slot) : "",
      prompt: isSet(object.prompt) ? Prompt.fromJSON(object.prompt) : undefined,
    };
  },

  toJSON(message: SlotRequested): unknown {
    const obj: any = {};
    if (message.slot !== "") {
      obj.slot = message.slot;
    }
    if (message.prompt !== undefined) {
      obj.prompt = Prompt.toJSON(message.prompt);
    }
    return obj;
  },

  create(base?: DeepPartial<SlotRequested>): SlotRequested {
    return SlotRequested.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlotRequested>): SlotRequested {
    const message = createBaseSlotRequested();
    message.slot = object.slot ?? "";
    message.prompt = (object.prompt !== undefined && object.prompt !== null)
      ? Prompt.fromPartial(object.prompt)
      : undefined;
    return message;
  },
};

function createBaseSlotValidated(): SlotValidated {
  return {};
}

export const SlotValidated: MessageFns<SlotValidated> = {
  encode(_: SlotValidated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotValidated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotValidated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SlotValidated {
    return {};
  },

  toJSON(_: SlotValidated): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SlotValidated>): SlotValidated {
    return SlotValidated.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SlotValidated>): SlotValidated {
    const message = createBaseSlotValidated();
    return message;
  },
};

function createBaseFormFilled(): FormFilled {
  return {};
}

export const FormFilled: MessageFns<FormFilled> = {
  encode(_: FormFilled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FormFilled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormFilled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FormFilled {
    return {};
  },

  toJSON(_: FormFilled): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FormFilled>): FormFilled {
    return FormFilled.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FormFilled>): FormFilled {
    const message = createBaseFormFilled();
    return message;
  },
};

function createBaseWaitingForUserInput(): WaitingForUserInput {
  return {};
}

export const WaitingForUserInput: MessageFns<WaitingForUserInput> = {
  encode(_: WaitingForUserInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WaitingForUserInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitingForUserInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WaitingForUserInput {
    return {};
  },

  toJSON(_: WaitingForUserInput): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<WaitingForUserInput>): WaitingForUserInput {
    return WaitingForUserInput.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<WaitingForUserInput>): WaitingForUserInput {
    const message = createBaseWaitingForUserInput();
    return message;
  },
};

function createBaseEndConversation(): EndConversation {
  return {};
}

export const EndConversation: MessageFns<EndConversation> = {
  encode(_: EndConversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndConversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EndConversation {
    return {};
  },

  toJSON(_: EndConversation): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EndConversation>): EndConversation {
    return EndConversation.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EndConversation>): EndConversation {
    const message = createBaseEndConversation();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
