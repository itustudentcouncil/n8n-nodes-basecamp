// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/sdk/v2/actions_sdk.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { BoolValue } from "../../../protobuf/wrappers.js";
import { AccountLinkingSecret } from "./account_linking_secret.js";
import { Files } from "./files.js";
import { ReleaseChannel } from "./release_channel.js";
import { ValidationResults } from "./validation_results.js";
import { Version } from "./version.js";

export const protobufPackage = "google.actions.sdk.v2";

/** Streaming RPC request for WriteDraft. */
export interface WriteDraftRequest {
  /**
   * Required. The parent resource name in the format `projects/{project}`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  parent: string;
  /**
   * Required. List of files sent to the server at a time. This is a list of config files
   * or data files.
   * 1. The first request must be a ConfigFiles.
   * 2. The first request must have a ConfigFile with 'settings'.
   * 3. The first request must have a ConfigFile with 'manifest'.
   * 4. The webhook ConfigFile corresponding to inline cloud function must be
   *    streamed before the DataFile corresponding to its source code.
   */
  files: Files | undefined;
}

/** Definition of draft resource. */
export interface Draft {
  /**
   * The unique identifier of the draft in the following format.
   * `projects/{project}/draft`
   */
  name: string;
  /**
   * Validation results associated with the project draft content. Note that
   * WriteDraft updates the draft despite the warnings as warnings are not draft
   * blocking.
   */
  validationResults: ValidationResults | undefined;
}

/** Streaming RPC request for WritePreview. */
export interface WritePreviewRequest {
  /**
   * Required. The parent resource name in the format `projects/{project}`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  parent: string;
  /**
   * List of files sent to the server at a time. This is a list of config
   * files or data files.
   * 1. The first request must be a ConfigFiles.
   * 2. The first request must have a ConfigFile with 'settings'.
   * 3. The first request must have a ConfigFile with 'manifest'.
   * 4. The webhook ConfigFile corresponding to inline cloud function must be
   *    streamed before the DataFile corresponding to its source code.
   */
  files?:
    | Files
    | undefined;
  /** Content sourced from the project draft. */
  draft?:
    | WritePreviewRequest_ContentFromDraft
    | undefined;
  /** Content sourced from the an exiting version. */
  submittedVersion?:
    | WritePreviewRequest_ContentFromSubmittedVersion
    | undefined;
  /** Required. The settings for updating the user's preview. */
  previewSettings: WritePreviewRequest_PreviewSettings | undefined;
}

/** Indicates the preview content will be coming from the Draft. */
export interface WritePreviewRequest_ContentFromDraft {
}

/** Indicates the preview content will be coming from an exiting version. */
export interface WritePreviewRequest_ContentFromSubmittedVersion {
  /**
   * Required. Submitted version of the project to be used to create a preview.
   * Format: `projects/{project}/versions/{version}`
   */
  version: string;
}

/** Settings for updating the preview. */
export interface WritePreviewRequest_PreviewSettings {
  /**
   * Indicates whether or not to run certain operations, such as transactions,
   * in sandbox mode. By default, preview requests run these operations in
   * sandbox mode. In other words, the default value for `sandbox` is `true`.
   */
  sandbox: boolean | undefined;
}

/** Definition of preview resource. */
export interface Preview {
  /**
   * The unique identifier of the preview.
   * Format: `projects/{project}/preview`
   */
  name: string;
  /** Validation results associated with the user project preview content. */
  validationResults:
    | ValidationResults
    | undefined;
  /** The simulator URL to test the user preview. */
  simulatorUrl: string;
}

/** Streaming RPC request for CreateVersion. */
export interface CreateVersionRequest {
  /**
   * Required. The parent resource name in the format `projects/{project}`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  parent: string;
  /**
   * Required. List of files sent to the server at a time. This is a list of config files
   * or data files.
   * 1. The first request must be a ConfigFiles.
   * 2. The first request must have a ConfigFile with 'settings'.
   * 3. The first request must have a ConfigFile with 'manifest'.
   * 4. The webhook ConfigFile corresponding to inline cloud function must be
   *    streamed before the DataFile corresponding to its source code.
   */
  files:
    | Files
    | undefined;
  /**
   * Optional. The release channel to deploy the version, if specified. The supported
   * built in release channels are actions.channels.Production,
   * actions.channels.ClosedBeta, actions.channels.Alpha.
   * .
   */
  releaseChannel: string;
}

/** RPC request for ReadDraft. */
export interface ReadDraftRequest {
  /**
   * Required. The name of the resource in the format `projects/{project}/draft`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  name: string;
  /**
   * Optional. The version of the crypto key used to encrypt the account linking OAuth
   * client secret. If not specified, the primary key version is used for
   * encryption. Only relevant for projects with account linking with client
   * secret.
   */
  clientSecretEncryptionKeyVersion: string;
}

/** Streaming RPC response for ReadDraft. */
export interface ReadDraftResponse {
  /** List of files sent from the server at a time. */
  files: Files | undefined;
}

/** RPC request for ReadVersion. */
export interface ReadVersionRequest {
  /**
   * Required. The name of the version resource in the format
   * `projects/{project}/versions/{version}`. `{project}` is the
   * cloud project ID associated with the project, `{version}` is the
   * identifier of the version being read.
   */
  name: string;
  /**
   * Optional. The version of the crypto key used to encrypt the account linking OAuth
   * client secret. If not specified, the primary key version is used for
   * encryption. Only relevant for projects with account linking with client
   * secret.
   */
  clientSecretEncryptionKeyVersion: string;
}

/** Streaming RPC response for ReadVersion. */
export interface ReadVersionResponse {
  /** List of files sent from the server at a time. */
  files: Files | undefined;
}

/** RPC request for EncryptSecret. */
export interface EncryptSecretRequest {
  /** Required. The account linking client secret plaintext. */
  clientSecret: string;
}

/** RPC response for EncryptSecret. */
export interface EncryptSecretResponse {
  /**
   * Contains the encrypted account linking client secret and the key version
   * used to encrypt the secret.
   */
  accountLinkingSecret: AccountLinkingSecret | undefined;
}

/** RPC request for DecryptSecret. */
export interface DecryptSecretRequest {
  /** Required. The account linking client secret ciphertext. */
  encryptedClientSecret: Buffer;
}

/** RPC response for DecryptSecret. */
export interface DecryptSecretResponse {
  /** The account linking client secret plaintext. */
  clientSecret: string;
}

/** RPC request for ListSampleProjects. */
export interface ListSampleProjectsRequest {
  /**
   * Optional. The maximum number of sample projects to return. The service may return
   * fewer than this value.
   * If unspecified, at most 1000 sample projects will be returned. Values above
   * 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous 'ListSampleProjects' call.
   * Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/** RPC response for ListSampleProjects. */
export interface ListSampleProjectsResponse {
  /** The list of sample projects supported. */
  sampleProjects: SampleProject[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Definition of sample project resource. */
export interface SampleProject {
  /**
   * The name of the sample project.
   * Format: `sampleProjects/{sample_project}`
   */
  name: string;
  /** The URL to the zip file where the sample is hosted. */
  hostedUrl: string;
  /** The description of the sample project. */
  description: string;
}

/** RPC request for listing release channels */
export interface ListReleaseChannelsRequest {
  /**
   * Required. The name of the resource in the format `projects/{project}`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  parent: string;
  /**
   * The maximum number of release channels to return. The service may return
   * fewer than this value. If unspecified, at most 50 release channels will be
   * returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListReleaseChannels` call.
   * Provide this to retrieve the subsequent page.
   * When paginating, all other parameters provided to `ListReleaseChannels`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** RPC response for listing release channels */
export interface ListReleaseChannelsResponse {
  /** List of the release channels for the given project id. */
  releaseChannels: ReleaseChannel[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** RPC request for listing versions */
export interface ListVersionsRequest {
  /**
   * Required. The name of the resource in the format `projects/{project}`. The
   * `{project}` is the cloud project ID associated with the project.
   */
  parent: string;
  /**
   * The maximum number of versions to return. The service may return
   * fewer than this value. If unspecified, at most 50 versions will be
   * returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListVersions` call.
   * Provide this to retrieve the subsequent page.
   * When paginating, all other parameters provided to `ListVersions`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** RPC response for listing versions */
export interface ListVersionsResponse {
  /** List of the versions for the given project id. */
  versions: Version[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

function createBaseWriteDraftRequest(): WriteDraftRequest {
  return { parent: "", files: undefined };
}

export const WriteDraftRequest: MessageFns<WriteDraftRequest> = {
  encode(message: WriteDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.files !== undefined) {
      Files.encode(message.files, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.files = Files.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteDraftRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      files: isSet(object.files) ? Files.fromJSON(object.files) : undefined,
    };
  },

  toJSON(message: WriteDraftRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.files !== undefined) {
      obj.files = Files.toJSON(message.files);
    }
    return obj;
  },

  create(base?: DeepPartial<WriteDraftRequest>): WriteDraftRequest {
    return WriteDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WriteDraftRequest>): WriteDraftRequest {
    const message = createBaseWriteDraftRequest();
    message.parent = object.parent ?? "";
    message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
    return message;
  },
};

function createBaseDraft(): Draft {
  return { name: "", validationResults: undefined };
}

export const Draft: MessageFns<Draft> = {
  encode(message: Draft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validationResults !== undefined) {
      ValidationResults.encode(message.validationResults, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Draft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validationResults = ValidationResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Draft {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validationResults: isSet(object.validationResults)
        ? ValidationResults.fromJSON(object.validationResults)
        : undefined,
    };
  },

  toJSON(message: Draft): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validationResults !== undefined) {
      obj.validationResults = ValidationResults.toJSON(message.validationResults);
    }
    return obj;
  },

  create(base?: DeepPartial<Draft>): Draft {
    return Draft.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Draft>): Draft {
    const message = createBaseDraft();
    message.name = object.name ?? "";
    message.validationResults = (object.validationResults !== undefined && object.validationResults !== null)
      ? ValidationResults.fromPartial(object.validationResults)
      : undefined;
    return message;
  },
};

function createBaseWritePreviewRequest(): WritePreviewRequest {
  return { parent: "", files: undefined, draft: undefined, submittedVersion: undefined, previewSettings: undefined };
}

export const WritePreviewRequest: MessageFns<WritePreviewRequest> = {
  encode(message: WritePreviewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.files !== undefined) {
      Files.encode(message.files, writer.uint32(42).fork()).join();
    }
    if (message.draft !== undefined) {
      WritePreviewRequest_ContentFromDraft.encode(message.draft, writer.uint32(50).fork()).join();
    }
    if (message.submittedVersion !== undefined) {
      WritePreviewRequest_ContentFromSubmittedVersion.encode(message.submittedVersion, writer.uint32(58).fork()).join();
    }
    if (message.previewSettings !== undefined) {
      WritePreviewRequest_PreviewSettings.encode(message.previewSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WritePreviewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWritePreviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.files = Files.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.draft = WritePreviewRequest_ContentFromDraft.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.submittedVersion = WritePreviewRequest_ContentFromSubmittedVersion.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.previewSettings = WritePreviewRequest_PreviewSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WritePreviewRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      files: isSet(object.files) ? Files.fromJSON(object.files) : undefined,
      draft: isSet(object.draft) ? WritePreviewRequest_ContentFromDraft.fromJSON(object.draft) : undefined,
      submittedVersion: isSet(object.submittedVersion)
        ? WritePreviewRequest_ContentFromSubmittedVersion.fromJSON(object.submittedVersion)
        : undefined,
      previewSettings: isSet(object.previewSettings)
        ? WritePreviewRequest_PreviewSettings.fromJSON(object.previewSettings)
        : undefined,
    };
  },

  toJSON(message: WritePreviewRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.files !== undefined) {
      obj.files = Files.toJSON(message.files);
    }
    if (message.draft !== undefined) {
      obj.draft = WritePreviewRequest_ContentFromDraft.toJSON(message.draft);
    }
    if (message.submittedVersion !== undefined) {
      obj.submittedVersion = WritePreviewRequest_ContentFromSubmittedVersion.toJSON(message.submittedVersion);
    }
    if (message.previewSettings !== undefined) {
      obj.previewSettings = WritePreviewRequest_PreviewSettings.toJSON(message.previewSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<WritePreviewRequest>): WritePreviewRequest {
    return WritePreviewRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WritePreviewRequest>): WritePreviewRequest {
    const message = createBaseWritePreviewRequest();
    message.parent = object.parent ?? "";
    message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
    message.draft = (object.draft !== undefined && object.draft !== null)
      ? WritePreviewRequest_ContentFromDraft.fromPartial(object.draft)
      : undefined;
    message.submittedVersion = (object.submittedVersion !== undefined && object.submittedVersion !== null)
      ? WritePreviewRequest_ContentFromSubmittedVersion.fromPartial(object.submittedVersion)
      : undefined;
    message.previewSettings = (object.previewSettings !== undefined && object.previewSettings !== null)
      ? WritePreviewRequest_PreviewSettings.fromPartial(object.previewSettings)
      : undefined;
    return message;
  },
};

function createBaseWritePreviewRequest_ContentFromDraft(): WritePreviewRequest_ContentFromDraft {
  return {};
}

export const WritePreviewRequest_ContentFromDraft: MessageFns<WritePreviewRequest_ContentFromDraft> = {
  encode(_: WritePreviewRequest_ContentFromDraft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WritePreviewRequest_ContentFromDraft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWritePreviewRequest_ContentFromDraft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WritePreviewRequest_ContentFromDraft {
    return {};
  },

  toJSON(_: WritePreviewRequest_ContentFromDraft): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<WritePreviewRequest_ContentFromDraft>): WritePreviewRequest_ContentFromDraft {
    return WritePreviewRequest_ContentFromDraft.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<WritePreviewRequest_ContentFromDraft>): WritePreviewRequest_ContentFromDraft {
    const message = createBaseWritePreviewRequest_ContentFromDraft();
    return message;
  },
};

function createBaseWritePreviewRequest_ContentFromSubmittedVersion(): WritePreviewRequest_ContentFromSubmittedVersion {
  return { version: "" };
}

export const WritePreviewRequest_ContentFromSubmittedVersion: MessageFns<
  WritePreviewRequest_ContentFromSubmittedVersion
> = {
  encode(
    message: WritePreviewRequest_ContentFromSubmittedVersion,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WritePreviewRequest_ContentFromSubmittedVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWritePreviewRequest_ContentFromSubmittedVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WritePreviewRequest_ContentFromSubmittedVersion {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: WritePreviewRequest_ContentFromSubmittedVersion): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WritePreviewRequest_ContentFromSubmittedVersion>,
  ): WritePreviewRequest_ContentFromSubmittedVersion {
    return WritePreviewRequest_ContentFromSubmittedVersion.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WritePreviewRequest_ContentFromSubmittedVersion>,
  ): WritePreviewRequest_ContentFromSubmittedVersion {
    const message = createBaseWritePreviewRequest_ContentFromSubmittedVersion();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseWritePreviewRequest_PreviewSettings(): WritePreviewRequest_PreviewSettings {
  return { sandbox: undefined };
}

export const WritePreviewRequest_PreviewSettings: MessageFns<WritePreviewRequest_PreviewSettings> = {
  encode(message: WritePreviewRequest_PreviewSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandbox !== undefined) {
      BoolValue.encode({ value: message.sandbox! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WritePreviewRequest_PreviewSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWritePreviewRequest_PreviewSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sandbox = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WritePreviewRequest_PreviewSettings {
    return { sandbox: isSet(object.sandbox) ? Boolean(object.sandbox) : undefined };
  },

  toJSON(message: WritePreviewRequest_PreviewSettings): unknown {
    const obj: any = {};
    if (message.sandbox !== undefined) {
      obj.sandbox = message.sandbox;
    }
    return obj;
  },

  create(base?: DeepPartial<WritePreviewRequest_PreviewSettings>): WritePreviewRequest_PreviewSettings {
    return WritePreviewRequest_PreviewSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WritePreviewRequest_PreviewSettings>): WritePreviewRequest_PreviewSettings {
    const message = createBaseWritePreviewRequest_PreviewSettings();
    message.sandbox = object.sandbox ?? undefined;
    return message;
  },
};

function createBasePreview(): Preview {
  return { name: "", validationResults: undefined, simulatorUrl: "" };
}

export const Preview: MessageFns<Preview> = {
  encode(message: Preview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validationResults !== undefined) {
      ValidationResults.encode(message.validationResults, writer.uint32(18).fork()).join();
    }
    if (message.simulatorUrl !== "") {
      writer.uint32(26).string(message.simulatorUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Preview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validationResults = ValidationResults.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.simulatorUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Preview {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validationResults: isSet(object.validationResults)
        ? ValidationResults.fromJSON(object.validationResults)
        : undefined,
      simulatorUrl: isSet(object.simulatorUrl) ? globalThis.String(object.simulatorUrl) : "",
    };
  },

  toJSON(message: Preview): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validationResults !== undefined) {
      obj.validationResults = ValidationResults.toJSON(message.validationResults);
    }
    if (message.simulatorUrl !== "") {
      obj.simulatorUrl = message.simulatorUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<Preview>): Preview {
    return Preview.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Preview>): Preview {
    const message = createBasePreview();
    message.name = object.name ?? "";
    message.validationResults = (object.validationResults !== undefined && object.validationResults !== null)
      ? ValidationResults.fromPartial(object.validationResults)
      : undefined;
    message.simulatorUrl = object.simulatorUrl ?? "";
    return message;
  },
};

function createBaseCreateVersionRequest(): CreateVersionRequest {
  return { parent: "", files: undefined, releaseChannel: "" };
}

export const CreateVersionRequest: MessageFns<CreateVersionRequest> = {
  encode(message: CreateVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.files !== undefined) {
      Files.encode(message.files, writer.uint32(42).fork()).join();
    }
    if (message.releaseChannel !== "") {
      writer.uint32(34).string(message.releaseChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.files = Files.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.releaseChannel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVersionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      files: isSet(object.files) ? Files.fromJSON(object.files) : undefined,
      releaseChannel: isSet(object.releaseChannel) ? globalThis.String(object.releaseChannel) : "",
    };
  },

  toJSON(message: CreateVersionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.files !== undefined) {
      obj.files = Files.toJSON(message.files);
    }
    if (message.releaseChannel !== "") {
      obj.releaseChannel = message.releaseChannel;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVersionRequest>): CreateVersionRequest {
    return CreateVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVersionRequest>): CreateVersionRequest {
    const message = createBaseCreateVersionRequest();
    message.parent = object.parent ?? "";
    message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
    message.releaseChannel = object.releaseChannel ?? "";
    return message;
  },
};

function createBaseReadDraftRequest(): ReadDraftRequest {
  return { name: "", clientSecretEncryptionKeyVersion: "" };
}

export const ReadDraftRequest: MessageFns<ReadDraftRequest> = {
  encode(message: ReadDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.clientSecretEncryptionKeyVersion !== "") {
      writer.uint32(18).string(message.clientSecretEncryptionKeyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientSecretEncryptionKeyVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadDraftRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clientSecretEncryptionKeyVersion: isSet(object.clientSecretEncryptionKeyVersion)
        ? globalThis.String(object.clientSecretEncryptionKeyVersion)
        : "",
    };
  },

  toJSON(message: ReadDraftRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clientSecretEncryptionKeyVersion !== "") {
      obj.clientSecretEncryptionKeyVersion = message.clientSecretEncryptionKeyVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadDraftRequest>): ReadDraftRequest {
    return ReadDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadDraftRequest>): ReadDraftRequest {
    const message = createBaseReadDraftRequest();
    message.name = object.name ?? "";
    message.clientSecretEncryptionKeyVersion = object.clientSecretEncryptionKeyVersion ?? "";
    return message;
  },
};

function createBaseReadDraftResponse(): ReadDraftResponse {
  return { files: undefined };
}

export const ReadDraftResponse: MessageFns<ReadDraftResponse> = {
  encode(message: ReadDraftResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.files !== undefined) {
      Files.encode(message.files, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadDraftResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadDraftResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.files = Files.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadDraftResponse {
    return { files: isSet(object.files) ? Files.fromJSON(object.files) : undefined };
  },

  toJSON(message: ReadDraftResponse): unknown {
    const obj: any = {};
    if (message.files !== undefined) {
      obj.files = Files.toJSON(message.files);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadDraftResponse>): ReadDraftResponse {
    return ReadDraftResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadDraftResponse>): ReadDraftResponse {
    const message = createBaseReadDraftResponse();
    message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
    return message;
  },
};

function createBaseReadVersionRequest(): ReadVersionRequest {
  return { name: "", clientSecretEncryptionKeyVersion: "" };
}

export const ReadVersionRequest: MessageFns<ReadVersionRequest> = {
  encode(message: ReadVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.clientSecretEncryptionKeyVersion !== "") {
      writer.uint32(18).string(message.clientSecretEncryptionKeyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientSecretEncryptionKeyVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadVersionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clientSecretEncryptionKeyVersion: isSet(object.clientSecretEncryptionKeyVersion)
        ? globalThis.String(object.clientSecretEncryptionKeyVersion)
        : "",
    };
  },

  toJSON(message: ReadVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.clientSecretEncryptionKeyVersion !== "") {
      obj.clientSecretEncryptionKeyVersion = message.clientSecretEncryptionKeyVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadVersionRequest>): ReadVersionRequest {
    return ReadVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadVersionRequest>): ReadVersionRequest {
    const message = createBaseReadVersionRequest();
    message.name = object.name ?? "";
    message.clientSecretEncryptionKeyVersion = object.clientSecretEncryptionKeyVersion ?? "";
    return message;
  },
};

function createBaseReadVersionResponse(): ReadVersionResponse {
  return { files: undefined };
}

export const ReadVersionResponse: MessageFns<ReadVersionResponse> = {
  encode(message: ReadVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.files !== undefined) {
      Files.encode(message.files, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.files = Files.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadVersionResponse {
    return { files: isSet(object.files) ? Files.fromJSON(object.files) : undefined };
  },

  toJSON(message: ReadVersionResponse): unknown {
    const obj: any = {};
    if (message.files !== undefined) {
      obj.files = Files.toJSON(message.files);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadVersionResponse>): ReadVersionResponse {
    return ReadVersionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadVersionResponse>): ReadVersionResponse {
    const message = createBaseReadVersionResponse();
    message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
    return message;
  },
};

function createBaseEncryptSecretRequest(): EncryptSecretRequest {
  return { clientSecret: "" };
}

export const EncryptSecretRequest: MessageFns<EncryptSecretRequest> = {
  encode(message: EncryptSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientSecret !== "") {
      writer.uint32(10).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptSecretRequest {
    return { clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "" };
  },

  toJSON(message: EncryptSecretRequest): unknown {
    const obj: any = {};
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptSecretRequest>): EncryptSecretRequest {
    return EncryptSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptSecretRequest>): EncryptSecretRequest {
    const message = createBaseEncryptSecretRequest();
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseEncryptSecretResponse(): EncryptSecretResponse {
  return { accountLinkingSecret: undefined };
}

export const EncryptSecretResponse: MessageFns<EncryptSecretResponse> = {
  encode(message: EncryptSecretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountLinkingSecret !== undefined) {
      AccountLinkingSecret.encode(message.accountLinkingSecret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptSecretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountLinkingSecret = AccountLinkingSecret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptSecretResponse {
    return {
      accountLinkingSecret: isSet(object.accountLinkingSecret)
        ? AccountLinkingSecret.fromJSON(object.accountLinkingSecret)
        : undefined,
    };
  },

  toJSON(message: EncryptSecretResponse): unknown {
    const obj: any = {};
    if (message.accountLinkingSecret !== undefined) {
      obj.accountLinkingSecret = AccountLinkingSecret.toJSON(message.accountLinkingSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptSecretResponse>): EncryptSecretResponse {
    return EncryptSecretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptSecretResponse>): EncryptSecretResponse {
    const message = createBaseEncryptSecretResponse();
    message.accountLinkingSecret = (object.accountLinkingSecret !== undefined && object.accountLinkingSecret !== null)
      ? AccountLinkingSecret.fromPartial(object.accountLinkingSecret)
      : undefined;
    return message;
  },
};

function createBaseDecryptSecretRequest(): DecryptSecretRequest {
  return { encryptedClientSecret: Buffer.alloc(0) };
}

export const DecryptSecretRequest: MessageFns<DecryptSecretRequest> = {
  encode(message: DecryptSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encryptedClientSecret.length !== 0) {
      writer.uint32(10).bytes(message.encryptedClientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encryptedClientSecret = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptSecretRequest {
    return {
      encryptedClientSecret: isSet(object.encryptedClientSecret)
        ? Buffer.from(bytesFromBase64(object.encryptedClientSecret))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: DecryptSecretRequest): unknown {
    const obj: any = {};
    if (message.encryptedClientSecret.length !== 0) {
      obj.encryptedClientSecret = base64FromBytes(message.encryptedClientSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptSecretRequest>): DecryptSecretRequest {
    return DecryptSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptSecretRequest>): DecryptSecretRequest {
    const message = createBaseDecryptSecretRequest();
    message.encryptedClientSecret = object.encryptedClientSecret ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDecryptSecretResponse(): DecryptSecretResponse {
  return { clientSecret: "" };
}

export const DecryptSecretResponse: MessageFns<DecryptSecretResponse> = {
  encode(message: DecryptSecretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientSecret !== "") {
      writer.uint32(10).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptSecretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptSecretResponse {
    return { clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "" };
  },

  toJSON(message: DecryptSecretResponse): unknown {
    const obj: any = {};
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptSecretResponse>): DecryptSecretResponse {
    return DecryptSecretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptSecretResponse>): DecryptSecretResponse {
    const message = createBaseDecryptSecretResponse();
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseListSampleProjectsRequest(): ListSampleProjectsRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListSampleProjectsRequest: MessageFns<ListSampleProjectsRequest> = {
  encode(message: ListSampleProjectsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSampleProjectsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSampleProjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSampleProjectsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSampleProjectsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSampleProjectsRequest>): ListSampleProjectsRequest {
    return ListSampleProjectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSampleProjectsRequest>): ListSampleProjectsRequest {
    const message = createBaseListSampleProjectsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSampleProjectsResponse(): ListSampleProjectsResponse {
  return { sampleProjects: [], nextPageToken: "" };
}

export const ListSampleProjectsResponse: MessageFns<ListSampleProjectsResponse> = {
  encode(message: ListSampleProjectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sampleProjects) {
      SampleProject.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSampleProjectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSampleProjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sampleProjects.push(SampleProject.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSampleProjectsResponse {
    return {
      sampleProjects: globalThis.Array.isArray(object?.sampleProjects)
        ? object.sampleProjects.map((e: any) => SampleProject.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSampleProjectsResponse): unknown {
    const obj: any = {};
    if (message.sampleProjects?.length) {
      obj.sampleProjects = message.sampleProjects.map((e) => SampleProject.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSampleProjectsResponse>): ListSampleProjectsResponse {
    return ListSampleProjectsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSampleProjectsResponse>): ListSampleProjectsResponse {
    const message = createBaseListSampleProjectsResponse();
    message.sampleProjects = object.sampleProjects?.map((e) => SampleProject.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSampleProject(): SampleProject {
  return { name: "", hostedUrl: "", description: "" };
}

export const SampleProject: MessageFns<SampleProject> = {
  encode(message: SampleProject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.hostedUrl !== "") {
      writer.uint32(18).string(message.hostedUrl);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SampleProject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSampleProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostedUrl = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SampleProject {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hostedUrl: isSet(object.hostedUrl) ? globalThis.String(object.hostedUrl) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: SampleProject): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hostedUrl !== "") {
      obj.hostedUrl = message.hostedUrl;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<SampleProject>): SampleProject {
    return SampleProject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SampleProject>): SampleProject {
    const message = createBaseSampleProject();
    message.name = object.name ?? "";
    message.hostedUrl = object.hostedUrl ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseListReleaseChannelsRequest(): ListReleaseChannelsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReleaseChannelsRequest: MessageFns<ListReleaseChannelsRequest> = {
  encode(message: ListReleaseChannelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReleaseChannelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReleaseChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReleaseChannelsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReleaseChannelsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReleaseChannelsRequest>): ListReleaseChannelsRequest {
    return ListReleaseChannelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReleaseChannelsRequest>): ListReleaseChannelsRequest {
    const message = createBaseListReleaseChannelsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReleaseChannelsResponse(): ListReleaseChannelsResponse {
  return { releaseChannels: [], nextPageToken: "" };
}

export const ListReleaseChannelsResponse: MessageFns<ListReleaseChannelsResponse> = {
  encode(message: ListReleaseChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.releaseChannels) {
      ReleaseChannel.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReleaseChannelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReleaseChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.releaseChannels.push(ReleaseChannel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReleaseChannelsResponse {
    return {
      releaseChannels: globalThis.Array.isArray(object?.releaseChannels)
        ? object.releaseChannels.map((e: any) => ReleaseChannel.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReleaseChannelsResponse): unknown {
    const obj: any = {};
    if (message.releaseChannels?.length) {
      obj.releaseChannels = message.releaseChannels.map((e) => ReleaseChannel.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReleaseChannelsResponse>): ListReleaseChannelsResponse {
    return ListReleaseChannelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReleaseChannelsResponse>): ListReleaseChannelsResponse {
    const message = createBaseListReleaseChannelsResponse();
    message.releaseChannels = object.releaseChannels?.map((e) => ReleaseChannel.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListVersionsRequest(): ListVersionsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListVersionsRequest: MessageFns<ListVersionsRequest> = {
  encode(message: ListVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVersionsRequest>): ListVersionsRequest {
    return ListVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVersionsRequest>): ListVersionsRequest {
    const message = createBaseListVersionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListVersionsResponse(): ListVersionsResponse {
  return { versions: [], nextPageToken: "" };
}

export const ListVersionsResponse: MessageFns<ListVersionsResponse> = {
  encode(message: ListVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.versions) {
      Version.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.versions.push(Version.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsResponse {
    return {
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e: any) => Version.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListVersionsResponse): unknown {
    const obj: any = {};
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => Version.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVersionsResponse>): ListVersionsResponse {
    return ListVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVersionsResponse>): ListVersionsResponse {
    const message = createBaseListVersionsResponse();
    message.versions = object.versions?.map((e) => Version.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** Actions SDK API which allows developers to build projects using the SDK. */
export type ActionsSdkDefinition = typeof ActionsSdkDefinition;
export const ActionsSdkDefinition = {
  name: "ActionsSdk",
  fullName: "google.actions.sdk.v2.ActionsSdk",
  methods: {
    /** Updates the project draft based on the model. */
    writeDraft: {
      name: "WriteDraft",
      requestType: WriteDraftRequest,
      requestStream: true,
      responseType: Draft,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              58,
              1,
              42,
              34,
              35,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              114,
              97,
              102,
              116,
              58,
              119,
              114,
              105,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Updates the user's project preview based on the model. */
    writePreview: {
      name: "WritePreview",
      requestType: WritePreviewRequest,
      requestStream: true,
      responseType: Preview,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              101,
              118,
              105,
              101,
              119,
              58,
              119,
              114,
              105,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a project version based on the model and triggers deployment to the
     * specified release channel, if specified.
     */
    createVersion: {
      name: "CreateVersion",
      requestType: CreateVersionRequest,
      requestStream: true,
      responseType: Version,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              58,
              99,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Reads the entire content of the project draft. */
    readDraft: {
      name: "ReadDraft",
      requestType: ReadDraftRequest,
      requestStream: false,
      responseType: ReadDraftResponse,
      responseStream: true,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              37,
              58,
              1,
              42,
              34,
              32,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              114,
              97,
              102,
              116,
              125,
              58,
              114,
              101,
              97,
              100,
            ]),
          ],
        },
      },
    },
    /** Reads the entire content of a project version. */
    readVersion: {
      name: "ReadVersion",
      requestType: ReadVersionRequest,
      requestStream: false,
      responseType: ReadVersionResponse,
      responseStream: true,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              97,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Encrypts the OAuth client secret used in account linking flows.
     * This can be used to encrypt the client secret for the first time (e.g.
     * before the first push or after changing the client secret) or to re-encrypt
     * a client secret using the latest primary key version (considering key
     * rotation).
     */
    encryptSecret: {
      name: "EncryptSecret",
      requestType: EncryptSecretRequest,
      requestStream: false,
      responseType: EncryptSecretResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              22,
              58,
              1,
              42,
              34,
              17,
              47,
              118,
              50,
              58,
              101,
              110,
              99,
              114,
              121,
              112,
              116,
              83,
              101,
              99,
              114,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Decrypts the OAuth client secret used in account linking flows.
     * This can be used to view the client secret (e.g. after pulling a project).
     */
    decryptSecret: {
      name: "DecryptSecret",
      requestType: DecryptSecretRequest,
      requestStream: false,
      responseType: DecryptSecretResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              22,
              58,
              1,
              42,
              34,
              17,
              47,
              118,
              50,
              58,
              100,
              101,
              99,
              114,
              121,
              112,
              116,
              83,
              101,
              99,
              114,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /** Lists all the sample projects supported by the gactions CLI. */
    listSampleProjects: {
      name: "ListSampleProjects",
      requestType: ListSampleProjectsRequest,
      requestStream: false,
      responseType: ListSampleProjectsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              20,
              18,
              18,
              47,
              118,
              50,
              47,
              115,
              97,
              109,
              112,
              108,
              101,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all release channels and corresponding versions, if any. */
    listReleaseChannels: {
      name: "ListReleaseChannels",
      requestType: ListReleaseChannelsRequest,
      requestStream: false,
      responseType: ListReleaseChannelsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all versions and their current states. */
    listVersions: {
      name: "ListVersions",
      requestType: ListVersionsRequest,
      requestStream: false,
      responseType: ListVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ActionsSdkServiceImplementation<CallContextExt = {}> {
  /** Updates the project draft based on the model. */
  writeDraft(
    request: AsyncIterable<WriteDraftRequest>,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Draft>>;
  /** Updates the user's project preview based on the model. */
  writePreview(
    request: AsyncIterable<WritePreviewRequest>,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Preview>>;
  /**
   * Creates a project version based on the model and triggers deployment to the
   * specified release channel, if specified.
   */
  createVersion(
    request: AsyncIterable<CreateVersionRequest>,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Version>>;
  /** Reads the entire content of the project draft. */
  readDraft(
    request: ReadDraftRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<ReadDraftResponse>>;
  /** Reads the entire content of a project version. */
  readVersion(
    request: ReadVersionRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<ReadVersionResponse>>;
  /**
   * Encrypts the OAuth client secret used in account linking flows.
   * This can be used to encrypt the client secret for the first time (e.g.
   * before the first push or after changing the client secret) or to re-encrypt
   * a client secret using the latest primary key version (considering key
   * rotation).
   */
  encryptSecret(
    request: EncryptSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EncryptSecretResponse>>;
  /**
   * Decrypts the OAuth client secret used in account linking flows.
   * This can be used to view the client secret (e.g. after pulling a project).
   */
  decryptSecret(
    request: DecryptSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DecryptSecretResponse>>;
  /** Lists all the sample projects supported by the gactions CLI. */
  listSampleProjects(
    request: ListSampleProjectsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSampleProjectsResponse>>;
  /** Lists all release channels and corresponding versions, if any. */
  listReleaseChannels(
    request: ListReleaseChannelsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReleaseChannelsResponse>>;
  /** Lists all versions and their current states. */
  listVersions(
    request: ListVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListVersionsResponse>>;
}

export interface ActionsSdkClient<CallOptionsExt = {}> {
  /** Updates the project draft based on the model. */
  writeDraft(
    request: AsyncIterable<DeepPartial<WriteDraftRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Draft>;
  /** Updates the user's project preview based on the model. */
  writePreview(
    request: AsyncIterable<DeepPartial<WritePreviewRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Preview>;
  /**
   * Creates a project version based on the model and triggers deployment to the
   * specified release channel, if specified.
   */
  createVersion(
    request: AsyncIterable<DeepPartial<CreateVersionRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Version>;
  /** Reads the entire content of the project draft. */
  readDraft(
    request: DeepPartial<ReadDraftRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ReadDraftResponse>;
  /** Reads the entire content of a project version. */
  readVersion(
    request: DeepPartial<ReadVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ReadVersionResponse>;
  /**
   * Encrypts the OAuth client secret used in account linking flows.
   * This can be used to encrypt the client secret for the first time (e.g.
   * before the first push or after changing the client secret) or to re-encrypt
   * a client secret using the latest primary key version (considering key
   * rotation).
   */
  encryptSecret(
    request: DeepPartial<EncryptSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EncryptSecretResponse>;
  /**
   * Decrypts the OAuth client secret used in account linking flows.
   * This can be used to view the client secret (e.g. after pulling a project).
   */
  decryptSecret(
    request: DeepPartial<DecryptSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DecryptSecretResponse>;
  /** Lists all the sample projects supported by the gactions CLI. */
  listSampleProjects(
    request: DeepPartial<ListSampleProjectsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSampleProjectsResponse>;
  /** Lists all release channels and corresponding versions, if any. */
  listReleaseChannels(
    request: DeepPartial<ListReleaseChannelsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReleaseChannelsResponse>;
  /** Lists all versions and their current states. */
  listVersions(
    request: DeepPartial<ListVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListVersionsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
