// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/actions/type/date_range.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { DateMessage } from "../../type/date.js";

export const protobufPackage = "google.actions.type";

/**
 * Represents a range based on whole or partial calendar dates, e.g. the
 * duration of a hotel reservation or the Common Era. This can represent:
 *
 * * A range between full dates, e.g. the duration of a hotel reservation
 * * A range between years, e.g. a historical era
 * * A range between year/month dates, e.g. the duration of a job on a resume
 * * A range beginning in a year, e.g. the Common Era
 * * A range ending on a specific date, e.g. the period of time before an event
 *
 * While [google.type.Date][google.type.Date] allows zero years, DateRange does not. Year must
 * always be non-zero.
 *
 * End cannot be chronologically before start. For example, if start has year
 * 2000, end cannot have year 1999.
 *
 * When both set, start and end must have exactly the same precision. That is,
 * they must have the same fields populated with non-zero values. For example,
 * if start specifies only year and month, then end must also specify only year
 * and month (but not day).
 *
 * The date range is inclusive. That is, the dates specified by start and end
 * are part of the date range. For example, the date January 1, 2000 falls
 * within any date with start or end equal to January 1, 2000. When determining
 * whether a date is inside a date range, the date should only be compared to
 * start and end when those values are set.
 *
 * When a date and date range are specified to different degrees of precision,
 * the rules for evaluating whether that date is inside the date range are as
 * follows:
 *
 *  * When comparing the date to the start of the date range, unspecified months
 *    should be replaced with 1, and unspecified days should be replaced with 1.
 *    For example, the year 2000 is within the date range with start equal to
 *    January 1, 2000 and no end. And the date January 1, 2000 is within the
 *    date range with start equal to the year 2000 and no end.
 *
 *  * When comparing the date to the end of the date range, unspecified months
 *    should be replaced with 12, and unspecified days should be replaced with
 *    the last valid day for the month/year. For example, the year 2000 is
 *    within the date range with start equal to January 1, 1999 and end equal to
 *    December 31, 2000. And the date December 31, 2001 is within the date range
 *    with start equal to the year 2000 and end equal to the year 2001.
 *
 * The semantics of start and end are the same as those of [google.type.Date][google.type.Date],
 * except that year must always be non-zero in DateRange.
 */
export interface DateRange {
  /**
   * Date at which the date range begins. If unset, the date range has no
   * beginning bound.
   */
  start:
    | DateMessage
    | undefined;
  /**
   * Date at which the date range ends. If unset, the date range has no ending
   * bound.
   */
  end: DateMessage | undefined;
}

function createBaseDateRange(): DateRange {
  return { start: undefined, end: undefined };
}

export const DateRange: MessageFns<DateRange> = {
  encode(message: DateRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      DateMessage.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      DateMessage.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateRange {
    return {
      start: isSet(object.start) ? DateMessage.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? DateMessage.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: DateRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = DateMessage.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = DateMessage.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<DateRange>): DateRange {
    return DateRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateRange>): DateRange {
    const message = createBaseDateRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? DateMessage.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? DateMessage.fromPartial(object.end) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
