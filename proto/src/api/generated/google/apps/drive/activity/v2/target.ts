// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/drive/activity/v2/target.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { User } from "./actor.js";
import { Domain } from "./common.js";

export const protobufPackage = "google.apps.drive.activity.v2";

/**
 * Information about the target of activity.
 *
 * For more information on how activity history is shared with users, see
 * [Activity history
 * visibility](https://developers.google.com/drive/activity/v2#activityhistory).
 */
export interface Target {
  /** The target is a Drive item. */
  driveItem?:
    | DriveItem
    | undefined;
  /** The target is a shared drive. */
  drive?:
    | Drive
    | undefined;
  /** The target is a comment on a Drive file. */
  fileComment?:
    | FileComment
    | undefined;
  /**
   * This field is deprecated; please use the `drive` field instead.
   *
   * @deprecated
   */
  teamDrive: TeamDrive | undefined;
}

/** A lightweight reference to the target of activity. */
export interface TargetReference {
  /** The target is a Drive item. */
  driveItem?:
    | DriveItemReference
    | undefined;
  /** The target is a shared drive. */
  drive?:
    | DriveReference
    | undefined;
  /**
   * This field is deprecated; please use the `drive` field instead.
   *
   * @deprecated
   */
  teamDrive: TeamDriveReference | undefined;
}

/** A comment on a file. */
export interface FileComment {
  /**
   * The comment in the discussion thread. This identifier is an opaque string
   * compatible with the Drive API; see
   * https://developers.google.com/drive/v3/reference/comments/get
   */
  legacyCommentId: string;
  /**
   * The discussion thread to which the comment was added. This identifier is an
   * opaque string compatible with the Drive API and references the first
   * comment in a discussion; see
   * https://developers.google.com/drive/v3/reference/comments/get
   */
  legacyDiscussionId: string;
  /**
   * The link to the discussion thread containing this comment, for example,
   * `https://docs.google.com/DOCUMENT_ID/edit?disco=THREAD_ID`.
   */
  linkToDiscussion: string;
  /** The Drive item containing this comment. */
  parent: DriveItem | undefined;
}

/** A Drive item, such as a file or folder. */
export interface DriveItem {
  /** The target Drive item. The format is `items/ITEM_ID`. */
  name: string;
  /** The title of the Drive item. */
  title: string;
  /**
   * This field is deprecated; please use the `driveFile` field instead.
   *
   * @deprecated
   */
  file:
    | DriveItem_File
    | undefined;
  /**
   * This field is deprecated; please use the `driveFolder` field instead.
   *
   * @deprecated
   */
  folder:
    | DriveItem_Folder
    | undefined;
  /** The Drive item is a file. */
  driveFile?:
    | DriveItem_DriveFile
    | undefined;
  /**
   * The Drive item is a folder. Includes information about the type of
   * folder.
   */
  driveFolder?:
    | DriveItem_DriveFolder
    | undefined;
  /**
   * The MIME type of the Drive item.  See
   * https://developers.google.com/drive/v3/web/mime-types.
   */
  mimeType: string;
  /** Information about the owner of this Drive item. */
  owner: Owner | undefined;
}

/**
 * This item is deprecated; please see `DriveFile` instead.
 *
 * @deprecated
 */
export interface DriveItem_File {
}

/**
 * This item is deprecated; please see `DriveFolder` instead.
 *
 * @deprecated
 */
export interface DriveItem_Folder {
  /** This field is deprecated; please see `DriveFolder.type` instead. */
  type: DriveItem_Folder_Type;
}

/**
 * This item is deprecated; please see `DriveFolder.Type` instead.
 *
 * @deprecated
 */
export enum DriveItem_Folder_Type {
  /** TYPE_UNSPECIFIED - This item is deprecated; please see `DriveFolder.Type` instead. */
  TYPE_UNSPECIFIED = 0,
  /** MY_DRIVE_ROOT - This item is deprecated; please see `DriveFolder.Type` instead. */
  MY_DRIVE_ROOT = 1,
  /** TEAM_DRIVE_ROOT - This item is deprecated; please see `DriveFolder.Type` instead. */
  TEAM_DRIVE_ROOT = 2,
  /** STANDARD_FOLDER - This item is deprecated; please see `DriveFolder.Type` instead. */
  STANDARD_FOLDER = 3,
  UNRECOGNIZED = -1,
}

export function driveItem_Folder_TypeFromJSON(object: any): DriveItem_Folder_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return DriveItem_Folder_Type.TYPE_UNSPECIFIED;
    case 1:
    case "MY_DRIVE_ROOT":
      return DriveItem_Folder_Type.MY_DRIVE_ROOT;
    case 2:
    case "TEAM_DRIVE_ROOT":
      return DriveItem_Folder_Type.TEAM_DRIVE_ROOT;
    case 3:
    case "STANDARD_FOLDER":
      return DriveItem_Folder_Type.STANDARD_FOLDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DriveItem_Folder_Type.UNRECOGNIZED;
  }
}

export function driveItem_Folder_TypeToJSON(object: DriveItem_Folder_Type): string {
  switch (object) {
    case DriveItem_Folder_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case DriveItem_Folder_Type.MY_DRIVE_ROOT:
      return "MY_DRIVE_ROOT";
    case DriveItem_Folder_Type.TEAM_DRIVE_ROOT:
      return "TEAM_DRIVE_ROOT";
    case DriveItem_Folder_Type.STANDARD_FOLDER:
      return "STANDARD_FOLDER";
    case DriveItem_Folder_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Drive item which is a file. */
export interface DriveItem_DriveFile {
}

/** A Drive item which is a folder. */
export interface DriveItem_DriveFolder {
  /** The type of Drive folder. */
  type: DriveItem_DriveFolder_Type;
}

/** The type of a Drive folder. */
export enum DriveItem_DriveFolder_Type {
  /** TYPE_UNSPECIFIED - The folder type is unknown. */
  TYPE_UNSPECIFIED = 0,
  /** MY_DRIVE_ROOT - The folder is the root of a user's MyDrive. */
  MY_DRIVE_ROOT = 1,
  /** SHARED_DRIVE_ROOT - The folder is the root of a shared drive. */
  SHARED_DRIVE_ROOT = 2,
  /** STANDARD_FOLDER - The folder is a standard, non-root, folder. */
  STANDARD_FOLDER = 3,
  UNRECOGNIZED = -1,
}

export function driveItem_DriveFolder_TypeFromJSON(object: any): DriveItem_DriveFolder_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return DriveItem_DriveFolder_Type.TYPE_UNSPECIFIED;
    case 1:
    case "MY_DRIVE_ROOT":
      return DriveItem_DriveFolder_Type.MY_DRIVE_ROOT;
    case 2:
    case "SHARED_DRIVE_ROOT":
      return DriveItem_DriveFolder_Type.SHARED_DRIVE_ROOT;
    case 3:
    case "STANDARD_FOLDER":
      return DriveItem_DriveFolder_Type.STANDARD_FOLDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DriveItem_DriveFolder_Type.UNRECOGNIZED;
  }
}

export function driveItem_DriveFolder_TypeToJSON(object: DriveItem_DriveFolder_Type): string {
  switch (object) {
    case DriveItem_DriveFolder_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case DriveItem_DriveFolder_Type.MY_DRIVE_ROOT:
      return "MY_DRIVE_ROOT";
    case DriveItem_DriveFolder_Type.SHARED_DRIVE_ROOT:
      return "SHARED_DRIVE_ROOT";
    case DriveItem_DriveFolder_Type.STANDARD_FOLDER:
      return "STANDARD_FOLDER";
    case DriveItem_DriveFolder_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the owner of a Drive item. */
export interface Owner {
  /** The user that owns the Drive item. */
  user?:
    | User
    | undefined;
  /** The drive that owns the item. */
  drive?:
    | DriveReference
    | undefined;
  /**
   * This field is deprecated; please use the `drive` field instead.
   *
   * @deprecated
   */
  teamDrive:
    | TeamDriveReference
    | undefined;
  /** The domain of the Drive item owner. */
  domain: Domain | undefined;
}

/**
 * This item is deprecated; please see `Drive` instead.
 *
 * @deprecated
 */
export interface TeamDrive {
  /** This field is deprecated; please see `Drive.name` instead. */
  name: string;
  /** This field is deprecated; please see `Drive.title` instead. */
  title: string;
  /** This field is deprecated; please see `Drive.root` instead. */
  root: DriveItem | undefined;
}

/** Information about a shared drive. */
export interface Drive {
  /**
   * The resource name of the shared drive. The format is
   * `COLLECTION_ID/DRIVE_ID`. Clients should not assume a specific collection
   * ID for this resource name.
   */
  name: string;
  /** The title of the shared drive. */
  title: string;
  /** The root of this shared drive. */
  root: DriveItem | undefined;
}

/** A lightweight reference to a Drive item, such as a file or folder. */
export interface DriveItemReference {
  /** The target Drive item. The format is `items/ITEM_ID`. */
  name: string;
  /** The title of the Drive item. */
  title: string;
  /**
   * This field is deprecated; please use the `driveFile` field instead.
   *
   * @deprecated
   */
  file:
    | DriveItem_File
    | undefined;
  /**
   * This field is deprecated; please use the `driveFolder` field instead.
   *
   * @deprecated
   */
  folder:
    | DriveItem_Folder
    | undefined;
  /** The Drive item is a file. */
  driveFile?:
    | DriveItem_DriveFile
    | undefined;
  /**
   * The Drive item is a folder. Includes information about the type of
   * folder.
   */
  driveFolder?: DriveItem_DriveFolder | undefined;
}

/**
 * This item is deprecated; please see `DriveReference` instead.
 *
 * @deprecated
 */
export interface TeamDriveReference {
  /** This field is deprecated; please see `DriveReference.name` instead. */
  name: string;
  /** This field is deprecated; please see `DriveReference.title` instead. */
  title: string;
}

/** A lightweight reference to a shared drive. */
export interface DriveReference {
  /**
   * The resource name of the shared drive. The format is
   * `COLLECTION_ID/DRIVE_ID`. Clients should not assume a specific collection
   * ID for this resource name.
   */
  name: string;
  /** The title of the shared drive. */
  title: string;
}

function createBaseTarget(): Target {
  return { driveItem: undefined, drive: undefined, fileComment: undefined, teamDrive: undefined };
}

export const Target: MessageFns<Target> = {
  encode(message: Target, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driveItem !== undefined) {
      DriveItem.encode(message.driveItem, writer.uint32(10).fork()).join();
    }
    if (message.drive !== undefined) {
      Drive.encode(message.drive, writer.uint32(42).fork()).join();
    }
    if (message.fileComment !== undefined) {
      FileComment.encode(message.fileComment, writer.uint32(26).fork()).join();
    }
    if (message.teamDrive !== undefined) {
      TeamDrive.encode(message.teamDrive, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Target {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.driveItem = DriveItem.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.drive = Drive.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileComment = FileComment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamDrive = TeamDrive.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Target {
    return {
      driveItem: isSet(object.driveItem) ? DriveItem.fromJSON(object.driveItem) : undefined,
      drive: isSet(object.drive) ? Drive.fromJSON(object.drive) : undefined,
      fileComment: isSet(object.fileComment) ? FileComment.fromJSON(object.fileComment) : undefined,
      teamDrive: isSet(object.teamDrive) ? TeamDrive.fromJSON(object.teamDrive) : undefined,
    };
  },

  toJSON(message: Target): unknown {
    const obj: any = {};
    if (message.driveItem !== undefined) {
      obj.driveItem = DriveItem.toJSON(message.driveItem);
    }
    if (message.drive !== undefined) {
      obj.drive = Drive.toJSON(message.drive);
    }
    if (message.fileComment !== undefined) {
      obj.fileComment = FileComment.toJSON(message.fileComment);
    }
    if (message.teamDrive !== undefined) {
      obj.teamDrive = TeamDrive.toJSON(message.teamDrive);
    }
    return obj;
  },

  create(base?: DeepPartial<Target>): Target {
    return Target.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Target>): Target {
    const message = createBaseTarget();
    message.driveItem = (object.driveItem !== undefined && object.driveItem !== null)
      ? DriveItem.fromPartial(object.driveItem)
      : undefined;
    message.drive = (object.drive !== undefined && object.drive !== null) ? Drive.fromPartial(object.drive) : undefined;
    message.fileComment = (object.fileComment !== undefined && object.fileComment !== null)
      ? FileComment.fromPartial(object.fileComment)
      : undefined;
    message.teamDrive = (object.teamDrive !== undefined && object.teamDrive !== null)
      ? TeamDrive.fromPartial(object.teamDrive)
      : undefined;
    return message;
  },
};

function createBaseTargetReference(): TargetReference {
  return { driveItem: undefined, drive: undefined, teamDrive: undefined };
}

export const TargetReference: MessageFns<TargetReference> = {
  encode(message: TargetReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driveItem !== undefined) {
      DriveItemReference.encode(message.driveItem, writer.uint32(10).fork()).join();
    }
    if (message.drive !== undefined) {
      DriveReference.encode(message.drive, writer.uint32(26).fork()).join();
    }
    if (message.teamDrive !== undefined) {
      TeamDriveReference.encode(message.teamDrive, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.driveItem = DriveItemReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.drive = DriveReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamDrive = TeamDriveReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetReference {
    return {
      driveItem: isSet(object.driveItem) ? DriveItemReference.fromJSON(object.driveItem) : undefined,
      drive: isSet(object.drive) ? DriveReference.fromJSON(object.drive) : undefined,
      teamDrive: isSet(object.teamDrive) ? TeamDriveReference.fromJSON(object.teamDrive) : undefined,
    };
  },

  toJSON(message: TargetReference): unknown {
    const obj: any = {};
    if (message.driveItem !== undefined) {
      obj.driveItem = DriveItemReference.toJSON(message.driveItem);
    }
    if (message.drive !== undefined) {
      obj.drive = DriveReference.toJSON(message.drive);
    }
    if (message.teamDrive !== undefined) {
      obj.teamDrive = TeamDriveReference.toJSON(message.teamDrive);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetReference>): TargetReference {
    return TargetReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetReference>): TargetReference {
    const message = createBaseTargetReference();
    message.driveItem = (object.driveItem !== undefined && object.driveItem !== null)
      ? DriveItemReference.fromPartial(object.driveItem)
      : undefined;
    message.drive = (object.drive !== undefined && object.drive !== null)
      ? DriveReference.fromPartial(object.drive)
      : undefined;
    message.teamDrive = (object.teamDrive !== undefined && object.teamDrive !== null)
      ? TeamDriveReference.fromPartial(object.teamDrive)
      : undefined;
    return message;
  },
};

function createBaseFileComment(): FileComment {
  return { legacyCommentId: "", legacyDiscussionId: "", linkToDiscussion: "", parent: undefined };
}

export const FileComment: MessageFns<FileComment> = {
  encode(message: FileComment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacyCommentId !== "") {
      writer.uint32(10).string(message.legacyCommentId);
    }
    if (message.legacyDiscussionId !== "") {
      writer.uint32(18).string(message.legacyDiscussionId);
    }
    if (message.linkToDiscussion !== "") {
      writer.uint32(26).string(message.linkToDiscussion);
    }
    if (message.parent !== undefined) {
      DriveItem.encode(message.parent, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileComment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.legacyCommentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.legacyDiscussionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.linkToDiscussion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = DriveItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileComment {
    return {
      legacyCommentId: isSet(object.legacyCommentId) ? globalThis.String(object.legacyCommentId) : "",
      legacyDiscussionId: isSet(object.legacyDiscussionId) ? globalThis.String(object.legacyDiscussionId) : "",
      linkToDiscussion: isSet(object.linkToDiscussion) ? globalThis.String(object.linkToDiscussion) : "",
      parent: isSet(object.parent) ? DriveItem.fromJSON(object.parent) : undefined,
    };
  },

  toJSON(message: FileComment): unknown {
    const obj: any = {};
    if (message.legacyCommentId !== "") {
      obj.legacyCommentId = message.legacyCommentId;
    }
    if (message.legacyDiscussionId !== "") {
      obj.legacyDiscussionId = message.legacyDiscussionId;
    }
    if (message.linkToDiscussion !== "") {
      obj.linkToDiscussion = message.linkToDiscussion;
    }
    if (message.parent !== undefined) {
      obj.parent = DriveItem.toJSON(message.parent);
    }
    return obj;
  },

  create(base?: DeepPartial<FileComment>): FileComment {
    return FileComment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileComment>): FileComment {
    const message = createBaseFileComment();
    message.legacyCommentId = object.legacyCommentId ?? "";
    message.legacyDiscussionId = object.legacyDiscussionId ?? "";
    message.linkToDiscussion = object.linkToDiscussion ?? "";
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? DriveItem.fromPartial(object.parent)
      : undefined;
    return message;
  },
};

function createBaseDriveItem(): DriveItem {
  return {
    name: "",
    title: "",
    file: undefined,
    folder: undefined,
    driveFile: undefined,
    driveFolder: undefined,
    mimeType: "",
    owner: undefined,
  };
}

export const DriveItem: MessageFns<DriveItem> = {
  encode(message: DriveItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.file !== undefined) {
      DriveItem_File.encode(message.file, writer.uint32(26).fork()).join();
    }
    if (message.folder !== undefined) {
      DriveItem_Folder.encode(message.folder, writer.uint32(34).fork()).join();
    }
    if (message.driveFile !== undefined) {
      DriveItem_DriveFile.encode(message.driveFile, writer.uint32(66).fork()).join();
    }
    if (message.driveFolder !== undefined) {
      DriveItem_DriveFolder.encode(message.driveFolder, writer.uint32(74).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(50).string(message.mimeType);
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.file = DriveItem_File.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.folder = DriveItem_Folder.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.driveFile = DriveItem_DriveFile.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.driveFolder = DriveItem_DriveFolder.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      file: isSet(object.file) ? DriveItem_File.fromJSON(object.file) : undefined,
      folder: isSet(object.folder) ? DriveItem_Folder.fromJSON(object.folder) : undefined,
      driveFile: isSet(object.driveFile) ? DriveItem_DriveFile.fromJSON(object.driveFile) : undefined,
      driveFolder: isSet(object.driveFolder) ? DriveItem_DriveFolder.fromJSON(object.driveFolder) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: DriveItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.file !== undefined) {
      obj.file = DriveItem_File.toJSON(message.file);
    }
    if (message.folder !== undefined) {
      obj.folder = DriveItem_Folder.toJSON(message.folder);
    }
    if (message.driveFile !== undefined) {
      obj.driveFile = DriveItem_DriveFile.toJSON(message.driveFile);
    }
    if (message.driveFolder !== undefined) {
      obj.driveFolder = DriveItem_DriveFolder.toJSON(message.driveFolder);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    return obj;
  },

  create(base?: DeepPartial<DriveItem>): DriveItem {
    return DriveItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveItem>): DriveItem {
    const message = createBaseDriveItem();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.file = (object.file !== undefined && object.file !== null)
      ? DriveItem_File.fromPartial(object.file)
      : undefined;
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? DriveItem_Folder.fromPartial(object.folder)
      : undefined;
    message.driveFile = (object.driveFile !== undefined && object.driveFile !== null)
      ? DriveItem_DriveFile.fromPartial(object.driveFile)
      : undefined;
    message.driveFolder = (object.driveFolder !== undefined && object.driveFolder !== null)
      ? DriveItem_DriveFolder.fromPartial(object.driveFolder)
      : undefined;
    message.mimeType = object.mimeType ?? "";
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    return message;
  },
};

function createBaseDriveItem_File(): DriveItem_File {
  return {};
}

export const DriveItem_File: MessageFns<DriveItem_File> = {
  encode(_: DriveItem_File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItem_File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItem_File();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DriveItem_File {
    return {};
  },

  toJSON(_: DriveItem_File): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DriveItem_File>): DriveItem_File {
    return DriveItem_File.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DriveItem_File>): DriveItem_File {
    const message = createBaseDriveItem_File();
    return message;
  },
};

function createBaseDriveItem_Folder(): DriveItem_Folder {
  return { type: 0 };
}

export const DriveItem_Folder: MessageFns<DriveItem_Folder> = {
  encode(message: DriveItem_Folder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItem_Folder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItem_Folder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveItem_Folder {
    return { type: isSet(object.type) ? driveItem_Folder_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: DriveItem_Folder): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = driveItem_Folder_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<DriveItem_Folder>): DriveItem_Folder {
    return DriveItem_Folder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveItem_Folder>): DriveItem_Folder {
    const message = createBaseDriveItem_Folder();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDriveItem_DriveFile(): DriveItem_DriveFile {
  return {};
}

export const DriveItem_DriveFile: MessageFns<DriveItem_DriveFile> = {
  encode(_: DriveItem_DriveFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItem_DriveFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItem_DriveFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DriveItem_DriveFile {
    return {};
  },

  toJSON(_: DriveItem_DriveFile): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DriveItem_DriveFile>): DriveItem_DriveFile {
    return DriveItem_DriveFile.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DriveItem_DriveFile>): DriveItem_DriveFile {
    const message = createBaseDriveItem_DriveFile();
    return message;
  },
};

function createBaseDriveItem_DriveFolder(): DriveItem_DriveFolder {
  return { type: 0 };
}

export const DriveItem_DriveFolder: MessageFns<DriveItem_DriveFolder> = {
  encode(message: DriveItem_DriveFolder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItem_DriveFolder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItem_DriveFolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveItem_DriveFolder {
    return { type: isSet(object.type) ? driveItem_DriveFolder_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: DriveItem_DriveFolder): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = driveItem_DriveFolder_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<DriveItem_DriveFolder>): DriveItem_DriveFolder {
    return DriveItem_DriveFolder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveItem_DriveFolder>): DriveItem_DriveFolder {
    const message = createBaseDriveItem_DriveFolder();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseOwner(): Owner {
  return { user: undefined, drive: undefined, teamDrive: undefined, domain: undefined };
}

export const Owner: MessageFns<Owner> = {
  encode(message: Owner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.drive !== undefined) {
      DriveReference.encode(message.drive, writer.uint32(34).fork()).join();
    }
    if (message.teamDrive !== undefined) {
      TeamDriveReference.encode(message.teamDrive, writer.uint32(18).fork()).join();
    }
    if (message.domain !== undefined) {
      Domain.encode(message.domain, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Owner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.drive = DriveReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamDrive = TeamDriveReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.domain = Domain.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Owner {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      drive: isSet(object.drive) ? DriveReference.fromJSON(object.drive) : undefined,
      teamDrive: isSet(object.teamDrive) ? TeamDriveReference.fromJSON(object.teamDrive) : undefined,
      domain: isSet(object.domain) ? Domain.fromJSON(object.domain) : undefined,
    };
  },

  toJSON(message: Owner): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.drive !== undefined) {
      obj.drive = DriveReference.toJSON(message.drive);
    }
    if (message.teamDrive !== undefined) {
      obj.teamDrive = TeamDriveReference.toJSON(message.teamDrive);
    }
    if (message.domain !== undefined) {
      obj.domain = Domain.toJSON(message.domain);
    }
    return obj;
  },

  create(base?: DeepPartial<Owner>): Owner {
    return Owner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Owner>): Owner {
    const message = createBaseOwner();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.drive = (object.drive !== undefined && object.drive !== null)
      ? DriveReference.fromPartial(object.drive)
      : undefined;
    message.teamDrive = (object.teamDrive !== undefined && object.teamDrive !== null)
      ? TeamDriveReference.fromPartial(object.teamDrive)
      : undefined;
    message.domain = (object.domain !== undefined && object.domain !== null)
      ? Domain.fromPartial(object.domain)
      : undefined;
    return message;
  },
};

function createBaseTeamDrive(): TeamDrive {
  return { name: "", title: "", root: undefined };
}

export const TeamDrive: MessageFns<TeamDrive> = {
  encode(message: TeamDrive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.root !== undefined) {
      DriveItem.encode(message.root, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamDrive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamDrive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.root = DriveItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamDrive {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      root: isSet(object.root) ? DriveItem.fromJSON(object.root) : undefined,
    };
  },

  toJSON(message: TeamDrive): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.root !== undefined) {
      obj.root = DriveItem.toJSON(message.root);
    }
    return obj;
  },

  create(base?: DeepPartial<TeamDrive>): TeamDrive {
    return TeamDrive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeamDrive>): TeamDrive {
    const message = createBaseTeamDrive();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.root = (object.root !== undefined && object.root !== null) ? DriveItem.fromPartial(object.root) : undefined;
    return message;
  },
};

function createBaseDrive(): Drive {
  return { name: "", title: "", root: undefined };
}

export const Drive: MessageFns<Drive> = {
  encode(message: Drive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.root !== undefined) {
      DriveItem.encode(message.root, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Drive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.root = DriveItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Drive {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      root: isSet(object.root) ? DriveItem.fromJSON(object.root) : undefined,
    };
  },

  toJSON(message: Drive): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.root !== undefined) {
      obj.root = DriveItem.toJSON(message.root);
    }
    return obj;
  },

  create(base?: DeepPartial<Drive>): Drive {
    return Drive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Drive>): Drive {
    const message = createBaseDrive();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.root = (object.root !== undefined && object.root !== null) ? DriveItem.fromPartial(object.root) : undefined;
    return message;
  },
};

function createBaseDriveItemReference(): DriveItemReference {
  return { name: "", title: "", file: undefined, folder: undefined, driveFile: undefined, driveFolder: undefined };
}

export const DriveItemReference: MessageFns<DriveItemReference> = {
  encode(message: DriveItemReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.file !== undefined) {
      DriveItem_File.encode(message.file, writer.uint32(26).fork()).join();
    }
    if (message.folder !== undefined) {
      DriveItem_Folder.encode(message.folder, writer.uint32(34).fork()).join();
    }
    if (message.driveFile !== undefined) {
      DriveItem_DriveFile.encode(message.driveFile, writer.uint32(66).fork()).join();
    }
    if (message.driveFolder !== undefined) {
      DriveItem_DriveFolder.encode(message.driveFolder, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveItemReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveItemReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.file = DriveItem_File.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.folder = DriveItem_Folder.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.driveFile = DriveItem_DriveFile.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.driveFolder = DriveItem_DriveFolder.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveItemReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      file: isSet(object.file) ? DriveItem_File.fromJSON(object.file) : undefined,
      folder: isSet(object.folder) ? DriveItem_Folder.fromJSON(object.folder) : undefined,
      driveFile: isSet(object.driveFile) ? DriveItem_DriveFile.fromJSON(object.driveFile) : undefined,
      driveFolder: isSet(object.driveFolder) ? DriveItem_DriveFolder.fromJSON(object.driveFolder) : undefined,
    };
  },

  toJSON(message: DriveItemReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.file !== undefined) {
      obj.file = DriveItem_File.toJSON(message.file);
    }
    if (message.folder !== undefined) {
      obj.folder = DriveItem_Folder.toJSON(message.folder);
    }
    if (message.driveFile !== undefined) {
      obj.driveFile = DriveItem_DriveFile.toJSON(message.driveFile);
    }
    if (message.driveFolder !== undefined) {
      obj.driveFolder = DriveItem_DriveFolder.toJSON(message.driveFolder);
    }
    return obj;
  },

  create(base?: DeepPartial<DriveItemReference>): DriveItemReference {
    return DriveItemReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveItemReference>): DriveItemReference {
    const message = createBaseDriveItemReference();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.file = (object.file !== undefined && object.file !== null)
      ? DriveItem_File.fromPartial(object.file)
      : undefined;
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? DriveItem_Folder.fromPartial(object.folder)
      : undefined;
    message.driveFile = (object.driveFile !== undefined && object.driveFile !== null)
      ? DriveItem_DriveFile.fromPartial(object.driveFile)
      : undefined;
    message.driveFolder = (object.driveFolder !== undefined && object.driveFolder !== null)
      ? DriveItem_DriveFolder.fromPartial(object.driveFolder)
      : undefined;
    return message;
  },
};

function createBaseTeamDriveReference(): TeamDriveReference {
  return { name: "", title: "" };
}

export const TeamDriveReference: MessageFns<TeamDriveReference> = {
  encode(message: TeamDriveReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeamDriveReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamDriveReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamDriveReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: TeamDriveReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<TeamDriveReference>): TeamDriveReference {
    return TeamDriveReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeamDriveReference>): TeamDriveReference {
    const message = createBaseTeamDriveReference();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseDriveReference(): DriveReference {
  return { name: "", title: "" };
}

export const DriveReference: MessageFns<DriveReference> = {
  encode(message: DriveReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: DriveReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<DriveReference>): DriveReference {
    return DriveReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveReference>): DriveReference {
    const message = createBaseDriveReference();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
