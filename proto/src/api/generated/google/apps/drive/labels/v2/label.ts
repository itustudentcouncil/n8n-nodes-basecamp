// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/drive/labels/v2/label.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Lifecycle, LockStatus, UserInfo } from "./common.js";
import { Field } from "./field.js";

export const protobufPackage = "google.apps.drive.labels.v2";

/**
 * A label defines a taxonomy that can be applied to Drive items in order to
 * organize and search across items. Labels can be simple strings, or can
 * contain fields that describe additional metadata that can be further used to
 * organize and search Drive items.
 */
export interface Label {
  /**
   * Output only. Resource name of the label. Will be in the form of either:
   * `labels/{id}` or `labels/{id}@{revision_id}` depending on the request.
   * See `id` and `revision_id` below.
   */
  name: string;
  /**
   * Output only. Globally unique identifier of this label. ID makes up part of
   * the label `name`, but unlike `name`, ID is consistent between revisions.
   * Matches the regex: `([a-zA-Z0-9])+`
   */
  id: string;
  /**
   * Output only. Revision ID of the label. Revision ID might be part of the
   * label `name` depending on the request issued. A new revision is created
   * whenever revisioned properties of a label are changed. Matches the regex:
   * `([a-zA-Z0-9])+`
   */
  revisionId: string;
  /** Required. The type of label. */
  labelType: Label_LabelType;
  /** Output only. The user who created this label. */
  creator:
    | UserInfo
    | undefined;
  /** Output only. The time this label was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The user who created this label revision. */
  revisionCreator:
    | UserInfo
    | undefined;
  /** Output only. The time this label revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /**
   * Output only. The user who published this label.  This value has no meaning
   * when the label is not published.
   */
  publisher:
    | UserInfo
    | undefined;
  /**
   * Output only. The time this label was published. This value has no meaning
   * when the label is not published.
   */
  publishTime:
    | Date
    | undefined;
  /**
   * Output only. The user who disabled this label. This value has no meaning
   * when the label is not disabled.
   */
  disabler:
    | UserInfo
    | undefined;
  /**
   * Output only. The time this label was disabled. This value has no meaning
   * when the label is not disabled.
   */
  disableTime:
    | Date
    | undefined;
  /**
   * Output only. The customer this label belongs to.
   * For example: "customers/123abc789."
   */
  customer: string;
  /** Required. The basic properties of the label. */
  properties:
    | Label_Properties
    | undefined;
  /**
   * Output only. The lifecycle state of the label including whether it's
   * published, deprecated, and has draft changes.
   */
  lifecycle:
    | Lifecycle
    | undefined;
  /** Output only. UI display hints for rendering the label. */
  displayHints:
    | Label_DisplayHints
    | undefined;
  /** Output only. The capabilities related to this label on applied metadata. */
  appliedCapabilities:
    | Label_AppliedCapabilities
    | undefined;
  /** Output only. The capabilities the user has on this label. */
  schemaCapabilities:
    | Label_SchemaCapabilities
    | undefined;
  /** Output only. Behavior of this label when it's applied to Drive items. */
  appliedLabelPolicy:
    | Label_AppliedLabelPolicy
    | undefined;
  /** List of fields in descending priority order. */
  fields: Field[];
  /**
   * Custom URL to present to users to allow them to learn more about this label
   * and how it should be used.
   */
  learnMoreUri: string;
  /** Output only. The LockStatus of this label. */
  lockStatus: LockStatus | undefined;
}

/** The type of this label. */
export enum Label_LabelType {
  /** LABEL_TYPE_UNSPECIFIED - Unknown label type. */
  LABEL_TYPE_UNSPECIFIED = 0,
  /** SHARED - Shared labels may be shared with users to apply to Drive items. */
  SHARED = 1,
  /**
   * ADMIN - Admin-owned label. Only creatable and editable by admins. Supports some
   * additional admin-only features.
   */
  ADMIN = 2,
  /**
   * GOOGLE_APP - A label owned by an internal Google application rather than a customer.
   * These labels are read-only.
   */
  GOOGLE_APP = 3,
  UNRECOGNIZED = -1,
}

export function label_LabelTypeFromJSON(object: any): Label_LabelType {
  switch (object) {
    case 0:
    case "LABEL_TYPE_UNSPECIFIED":
      return Label_LabelType.LABEL_TYPE_UNSPECIFIED;
    case 1:
    case "SHARED":
      return Label_LabelType.SHARED;
    case 2:
    case "ADMIN":
      return Label_LabelType.ADMIN;
    case 3:
    case "GOOGLE_APP":
      return Label_LabelType.GOOGLE_APP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Label_LabelType.UNRECOGNIZED;
  }
}

export function label_LabelTypeToJSON(object: Label_LabelType): string {
  switch (object) {
    case Label_LabelType.LABEL_TYPE_UNSPECIFIED:
      return "LABEL_TYPE_UNSPECIFIED";
    case Label_LabelType.SHARED:
      return "SHARED";
    case Label_LabelType.ADMIN:
      return "ADMIN";
    case Label_LabelType.GOOGLE_APP:
      return "GOOGLE_APP";
    case Label_LabelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Basic properties of the label. */
export interface Label_Properties {
  /** Required. Title of the label. */
  title: string;
  /** The description of the label. */
  description: string;
}

/** UI display hints for rendering the label. */
export interface Label_DisplayHints {
  /** Whether the label should be shown in the UI as disabled. */
  disabled: boolean;
  /**
   * This label should be hidden in the search menu when searching for Drive
   * items.
   */
  hiddenInSearch: boolean;
  /**
   * This label should be shown in the apply menu when applying values to a
   * Drive item.
   */
  shownInApply: boolean;
  /** Order to display label in a list. */
  priority: Long;
}

/** The capabilities a user has on this label's applied metadata. */
export interface Label_AppliedCapabilities {
  /** Whether the user can read applied metadata related to this label. */
  canRead: boolean;
  /** Whether the user can apply this label to items. */
  canApply: boolean;
  /** Whether the user can remove this label from items. */
  canRemove: boolean;
}

/** The capabilities related to this label when editing the label. */
export interface Label_SchemaCapabilities {
  /** Whether the user can change this label. */
  canUpdate: boolean;
  /**
   * Whether the user can delete this label.
   * The user must have permission and the label must be disabled.
   */
  canDelete: boolean;
  /**
   * Whether the user can disable this label.
   * The user must have permission and this label must not already be
   * disabled.
   */
  canDisable: boolean;
  /**
   * Whether the user can enable this label.
   * The user must have permission and this label must be disabled.
   */
  canEnable: boolean;
}

/** Behavior of this label when it's applied to Drive items. */
export interface Label_AppliedLabelPolicy {
  /**
   * Indicates how the applied label and field values should be copied when
   * a Drive item is copied.
   */
  copyMode: Label_AppliedLabelPolicy_CopyMode;
}

/**
 * Indicates how the applied label and field values should be copied when
 * a Drive item is copied.
 */
export enum Label_AppliedLabelPolicy_CopyMode {
  /** COPY_MODE_UNSPECIFIED - Copy mode unspecified. */
  COPY_MODE_UNSPECIFIED = 0,
  /**
   * DO_NOT_COPY - The applied label and field values are not copied by default when
   * the Drive item it's applied to is copied.
   */
  DO_NOT_COPY = 1,
  /**
   * ALWAYS_COPY - The applied label and field values are always copied when the
   * Drive item it's applied to is copied.
   * Only admins can use this mode.
   */
  ALWAYS_COPY = 2,
  /**
   * COPY_APPLIABLE - The applied label and field values are copied if the
   * label is appliable by the user making the copy.
   */
  COPY_APPLIABLE = 3,
  UNRECOGNIZED = -1,
}

export function label_AppliedLabelPolicy_CopyModeFromJSON(object: any): Label_AppliedLabelPolicy_CopyMode {
  switch (object) {
    case 0:
    case "COPY_MODE_UNSPECIFIED":
      return Label_AppliedLabelPolicy_CopyMode.COPY_MODE_UNSPECIFIED;
    case 1:
    case "DO_NOT_COPY":
      return Label_AppliedLabelPolicy_CopyMode.DO_NOT_COPY;
    case 2:
    case "ALWAYS_COPY":
      return Label_AppliedLabelPolicy_CopyMode.ALWAYS_COPY;
    case 3:
    case "COPY_APPLIABLE":
      return Label_AppliedLabelPolicy_CopyMode.COPY_APPLIABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Label_AppliedLabelPolicy_CopyMode.UNRECOGNIZED;
  }
}

export function label_AppliedLabelPolicy_CopyModeToJSON(object: Label_AppliedLabelPolicy_CopyMode): string {
  switch (object) {
    case Label_AppliedLabelPolicy_CopyMode.COPY_MODE_UNSPECIFIED:
      return "COPY_MODE_UNSPECIFIED";
    case Label_AppliedLabelPolicy_CopyMode.DO_NOT_COPY:
      return "DO_NOT_COPY";
    case Label_AppliedLabelPolicy_CopyMode.ALWAYS_COPY:
      return "ALWAYS_COPY";
    case Label_AppliedLabelPolicy_CopyMode.COPY_APPLIABLE:
      return "COPY_APPLIABLE";
    case Label_AppliedLabelPolicy_CopyMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseLabel(): Label {
  return {
    name: "",
    id: "",
    revisionId: "",
    labelType: 0,
    creator: undefined,
    createTime: undefined,
    revisionCreator: undefined,
    revisionCreateTime: undefined,
    publisher: undefined,
    publishTime: undefined,
    disabler: undefined,
    disableTime: undefined,
    customer: "",
    properties: undefined,
    lifecycle: undefined,
    displayHints: undefined,
    appliedCapabilities: undefined,
    schemaCapabilities: undefined,
    appliedLabelPolicy: undefined,
    fields: [],
    learnMoreUri: "",
    lockStatus: undefined,
  };
}

export const Label: MessageFns<Label> = {
  encode(message: Label, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.revisionId !== "") {
      writer.uint32(26).string(message.revisionId);
    }
    if (message.labelType !== 0) {
      writer.uint32(32).int32(message.labelType);
    }
    if (message.creator !== undefined) {
      UserInfo.encode(message.creator, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.revisionCreator !== undefined) {
      UserInfo.encode(message.revisionCreator, writer.uint32(58).fork()).join();
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(66).fork()).join();
    }
    if (message.publisher !== undefined) {
      UserInfo.encode(message.publisher, writer.uint32(74).fork()).join();
    }
    if (message.publishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.publishTime), writer.uint32(82).fork()).join();
    }
    if (message.disabler !== undefined) {
      UserInfo.encode(message.disabler, writer.uint32(90).fork()).join();
    }
    if (message.disableTime !== undefined) {
      Timestamp.encode(toTimestamp(message.disableTime), writer.uint32(98).fork()).join();
    }
    if (message.customer !== "") {
      writer.uint32(106).string(message.customer);
    }
    if (message.properties !== undefined) {
      Label_Properties.encode(message.properties, writer.uint32(114).fork()).join();
    }
    if (message.lifecycle !== undefined) {
      Lifecycle.encode(message.lifecycle, writer.uint32(122).fork()).join();
    }
    if (message.displayHints !== undefined) {
      Label_DisplayHints.encode(message.displayHints, writer.uint32(130).fork()).join();
    }
    if (message.appliedCapabilities !== undefined) {
      Label_AppliedCapabilities.encode(message.appliedCapabilities, writer.uint32(138).fork()).join();
    }
    if (message.schemaCapabilities !== undefined) {
      Label_SchemaCapabilities.encode(message.schemaCapabilities, writer.uint32(146).fork()).join();
    }
    if (message.appliedLabelPolicy !== undefined) {
      Label_AppliedLabelPolicy.encode(message.appliedLabelPolicy, writer.uint32(154).fork()).join();
    }
    for (const v of message.fields) {
      Field.encode(v!, writer.uint32(162).fork()).join();
    }
    if (message.learnMoreUri !== "") {
      writer.uint32(170).string(message.learnMoreUri);
    }
    if (message.lockStatus !== undefined) {
      LockStatus.encode(message.lockStatus, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.labelType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator = UserInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.revisionCreator = UserInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.publisher = UserInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.publishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.disabler = UserInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.disableTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customer = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.properties = Label_Properties.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.lifecycle = Lifecycle.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.displayHints = Label_DisplayHints.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.appliedCapabilities = Label_AppliedCapabilities.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.schemaCapabilities = Label_SchemaCapabilities.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.appliedLabelPolicy = Label_AppliedLabelPolicy.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.fields.push(Field.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.learnMoreUri = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.lockStatus = LockStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      labelType: isSet(object.labelType) ? label_LabelTypeFromJSON(object.labelType) : 0,
      creator: isSet(object.creator) ? UserInfo.fromJSON(object.creator) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      revisionCreator: isSet(object.revisionCreator) ? UserInfo.fromJSON(object.revisionCreator) : undefined,
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      publisher: isSet(object.publisher) ? UserInfo.fromJSON(object.publisher) : undefined,
      publishTime: isSet(object.publishTime) ? fromJsonTimestamp(object.publishTime) : undefined,
      disabler: isSet(object.disabler) ? UserInfo.fromJSON(object.disabler) : undefined,
      disableTime: isSet(object.disableTime) ? fromJsonTimestamp(object.disableTime) : undefined,
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
      properties: isSet(object.properties) ? Label_Properties.fromJSON(object.properties) : undefined,
      lifecycle: isSet(object.lifecycle) ? Lifecycle.fromJSON(object.lifecycle) : undefined,
      displayHints: isSet(object.displayHints) ? Label_DisplayHints.fromJSON(object.displayHints) : undefined,
      appliedCapabilities: isSet(object.appliedCapabilities)
        ? Label_AppliedCapabilities.fromJSON(object.appliedCapabilities)
        : undefined,
      schemaCapabilities: isSet(object.schemaCapabilities)
        ? Label_SchemaCapabilities.fromJSON(object.schemaCapabilities)
        : undefined,
      appliedLabelPolicy: isSet(object.appliedLabelPolicy)
        ? Label_AppliedLabelPolicy.fromJSON(object.appliedLabelPolicy)
        : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Field.fromJSON(e)) : [],
      learnMoreUri: isSet(object.learnMoreUri) ? globalThis.String(object.learnMoreUri) : "",
      lockStatus: isSet(object.lockStatus) ? LockStatus.fromJSON(object.lockStatus) : undefined,
    };
  },

  toJSON(message: Label): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.labelType !== 0) {
      obj.labelType = label_LabelTypeToJSON(message.labelType);
    }
    if (message.creator !== undefined) {
      obj.creator = UserInfo.toJSON(message.creator);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.revisionCreator !== undefined) {
      obj.revisionCreator = UserInfo.toJSON(message.revisionCreator);
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.publisher !== undefined) {
      obj.publisher = UserInfo.toJSON(message.publisher);
    }
    if (message.publishTime !== undefined) {
      obj.publishTime = message.publishTime.toISOString();
    }
    if (message.disabler !== undefined) {
      obj.disabler = UserInfo.toJSON(message.disabler);
    }
    if (message.disableTime !== undefined) {
      obj.disableTime = message.disableTime.toISOString();
    }
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.properties !== undefined) {
      obj.properties = Label_Properties.toJSON(message.properties);
    }
    if (message.lifecycle !== undefined) {
      obj.lifecycle = Lifecycle.toJSON(message.lifecycle);
    }
    if (message.displayHints !== undefined) {
      obj.displayHints = Label_DisplayHints.toJSON(message.displayHints);
    }
    if (message.appliedCapabilities !== undefined) {
      obj.appliedCapabilities = Label_AppliedCapabilities.toJSON(message.appliedCapabilities);
    }
    if (message.schemaCapabilities !== undefined) {
      obj.schemaCapabilities = Label_SchemaCapabilities.toJSON(message.schemaCapabilities);
    }
    if (message.appliedLabelPolicy !== undefined) {
      obj.appliedLabelPolicy = Label_AppliedLabelPolicy.toJSON(message.appliedLabelPolicy);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Field.toJSON(e));
    }
    if (message.learnMoreUri !== "") {
      obj.learnMoreUri = message.learnMoreUri;
    }
    if (message.lockStatus !== undefined) {
      obj.lockStatus = LockStatus.toJSON(message.lockStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<Label>): Label {
    return Label.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label>): Label {
    const message = createBaseLabel();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.revisionId = object.revisionId ?? "";
    message.labelType = object.labelType ?? 0;
    message.creator = (object.creator !== undefined && object.creator !== null)
      ? UserInfo.fromPartial(object.creator)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.revisionCreator = (object.revisionCreator !== undefined && object.revisionCreator !== null)
      ? UserInfo.fromPartial(object.revisionCreator)
      : undefined;
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.publisher = (object.publisher !== undefined && object.publisher !== null)
      ? UserInfo.fromPartial(object.publisher)
      : undefined;
    message.publishTime = object.publishTime ?? undefined;
    message.disabler = (object.disabler !== undefined && object.disabler !== null)
      ? UserInfo.fromPartial(object.disabler)
      : undefined;
    message.disableTime = object.disableTime ?? undefined;
    message.customer = object.customer ?? "";
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? Label_Properties.fromPartial(object.properties)
      : undefined;
    message.lifecycle = (object.lifecycle !== undefined && object.lifecycle !== null)
      ? Lifecycle.fromPartial(object.lifecycle)
      : undefined;
    message.displayHints = (object.displayHints !== undefined && object.displayHints !== null)
      ? Label_DisplayHints.fromPartial(object.displayHints)
      : undefined;
    message.appliedCapabilities = (object.appliedCapabilities !== undefined && object.appliedCapabilities !== null)
      ? Label_AppliedCapabilities.fromPartial(object.appliedCapabilities)
      : undefined;
    message.schemaCapabilities = (object.schemaCapabilities !== undefined && object.schemaCapabilities !== null)
      ? Label_SchemaCapabilities.fromPartial(object.schemaCapabilities)
      : undefined;
    message.appliedLabelPolicy = (object.appliedLabelPolicy !== undefined && object.appliedLabelPolicy !== null)
      ? Label_AppliedLabelPolicy.fromPartial(object.appliedLabelPolicy)
      : undefined;
    message.fields = object.fields?.map((e) => Field.fromPartial(e)) || [];
    message.learnMoreUri = object.learnMoreUri ?? "";
    message.lockStatus = (object.lockStatus !== undefined && object.lockStatus !== null)
      ? LockStatus.fromPartial(object.lockStatus)
      : undefined;
    return message;
  },
};

function createBaseLabel_Properties(): Label_Properties {
  return { title: "", description: "" };
}

export const Label_Properties: MessageFns<Label_Properties> = {
  encode(message: Label_Properties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label_Properties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel_Properties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label_Properties {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Label_Properties): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Label_Properties>): Label_Properties {
    return Label_Properties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label_Properties>): Label_Properties {
    const message = createBaseLabel_Properties();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseLabel_DisplayHints(): Label_DisplayHints {
  return { disabled: false, hiddenInSearch: false, shownInApply: false, priority: Long.ZERO };
}

export const Label_DisplayHints: MessageFns<Label_DisplayHints> = {
  encode(message: Label_DisplayHints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    if (message.hiddenInSearch !== false) {
      writer.uint32(16).bool(message.hiddenInSearch);
    }
    if (message.shownInApply !== false) {
      writer.uint32(24).bool(message.shownInApply);
    }
    if (!message.priority.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.priority.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label_DisplayHints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel_DisplayHints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hiddenInSearch = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.shownInApply = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priority = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label_DisplayHints {
    return {
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      hiddenInSearch: isSet(object.hiddenInSearch) ? globalThis.Boolean(object.hiddenInSearch) : false,
      shownInApply: isSet(object.shownInApply) ? globalThis.Boolean(object.shownInApply) : false,
      priority: isSet(object.priority) ? Long.fromValue(object.priority) : Long.ZERO,
    };
  },

  toJSON(message: Label_DisplayHints): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.hiddenInSearch !== false) {
      obj.hiddenInSearch = message.hiddenInSearch;
    }
    if (message.shownInApply !== false) {
      obj.shownInApply = message.shownInApply;
    }
    if (!message.priority.equals(Long.ZERO)) {
      obj.priority = (message.priority || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Label_DisplayHints>): Label_DisplayHints {
    return Label_DisplayHints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label_DisplayHints>): Label_DisplayHints {
    const message = createBaseLabel_DisplayHints();
    message.disabled = object.disabled ?? false;
    message.hiddenInSearch = object.hiddenInSearch ?? false;
    message.shownInApply = object.shownInApply ?? false;
    message.priority = (object.priority !== undefined && object.priority !== null)
      ? Long.fromValue(object.priority)
      : Long.ZERO;
    return message;
  },
};

function createBaseLabel_AppliedCapabilities(): Label_AppliedCapabilities {
  return { canRead: false, canApply: false, canRemove: false };
}

export const Label_AppliedCapabilities: MessageFns<Label_AppliedCapabilities> = {
  encode(message: Label_AppliedCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canRead !== false) {
      writer.uint32(8).bool(message.canRead);
    }
    if (message.canApply !== false) {
      writer.uint32(16).bool(message.canApply);
    }
    if (message.canRemove !== false) {
      writer.uint32(24).bool(message.canRemove);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label_AppliedCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel_AppliedCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.canRead = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canApply = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canRemove = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label_AppliedCapabilities {
    return {
      canRead: isSet(object.canRead) ? globalThis.Boolean(object.canRead) : false,
      canApply: isSet(object.canApply) ? globalThis.Boolean(object.canApply) : false,
      canRemove: isSet(object.canRemove) ? globalThis.Boolean(object.canRemove) : false,
    };
  },

  toJSON(message: Label_AppliedCapabilities): unknown {
    const obj: any = {};
    if (message.canRead !== false) {
      obj.canRead = message.canRead;
    }
    if (message.canApply !== false) {
      obj.canApply = message.canApply;
    }
    if (message.canRemove !== false) {
      obj.canRemove = message.canRemove;
    }
    return obj;
  },

  create(base?: DeepPartial<Label_AppliedCapabilities>): Label_AppliedCapabilities {
    return Label_AppliedCapabilities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label_AppliedCapabilities>): Label_AppliedCapabilities {
    const message = createBaseLabel_AppliedCapabilities();
    message.canRead = object.canRead ?? false;
    message.canApply = object.canApply ?? false;
    message.canRemove = object.canRemove ?? false;
    return message;
  },
};

function createBaseLabel_SchemaCapabilities(): Label_SchemaCapabilities {
  return { canUpdate: false, canDelete: false, canDisable: false, canEnable: false };
}

export const Label_SchemaCapabilities: MessageFns<Label_SchemaCapabilities> = {
  encode(message: Label_SchemaCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canUpdate !== false) {
      writer.uint32(8).bool(message.canUpdate);
    }
    if (message.canDelete !== false) {
      writer.uint32(16).bool(message.canDelete);
    }
    if (message.canDisable !== false) {
      writer.uint32(24).bool(message.canDisable);
    }
    if (message.canEnable !== false) {
      writer.uint32(32).bool(message.canEnable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label_SchemaCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel_SchemaCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.canUpdate = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.canDelete = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canDisable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canEnable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label_SchemaCapabilities {
    return {
      canUpdate: isSet(object.canUpdate) ? globalThis.Boolean(object.canUpdate) : false,
      canDelete: isSet(object.canDelete) ? globalThis.Boolean(object.canDelete) : false,
      canDisable: isSet(object.canDisable) ? globalThis.Boolean(object.canDisable) : false,
      canEnable: isSet(object.canEnable) ? globalThis.Boolean(object.canEnable) : false,
    };
  },

  toJSON(message: Label_SchemaCapabilities): unknown {
    const obj: any = {};
    if (message.canUpdate !== false) {
      obj.canUpdate = message.canUpdate;
    }
    if (message.canDelete !== false) {
      obj.canDelete = message.canDelete;
    }
    if (message.canDisable !== false) {
      obj.canDisable = message.canDisable;
    }
    if (message.canEnable !== false) {
      obj.canEnable = message.canEnable;
    }
    return obj;
  },

  create(base?: DeepPartial<Label_SchemaCapabilities>): Label_SchemaCapabilities {
    return Label_SchemaCapabilities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label_SchemaCapabilities>): Label_SchemaCapabilities {
    const message = createBaseLabel_SchemaCapabilities();
    message.canUpdate = object.canUpdate ?? false;
    message.canDelete = object.canDelete ?? false;
    message.canDisable = object.canDisable ?? false;
    message.canEnable = object.canEnable ?? false;
    return message;
  },
};

function createBaseLabel_AppliedLabelPolicy(): Label_AppliedLabelPolicy {
  return { copyMode: 0 };
}

export const Label_AppliedLabelPolicy: MessageFns<Label_AppliedLabelPolicy> = {
  encode(message: Label_AppliedLabelPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.copyMode !== 0) {
      writer.uint32(8).int32(message.copyMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Label_AppliedLabelPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel_AppliedLabelPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.copyMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label_AppliedLabelPolicy {
    return { copyMode: isSet(object.copyMode) ? label_AppliedLabelPolicy_CopyModeFromJSON(object.copyMode) : 0 };
  },

  toJSON(message: Label_AppliedLabelPolicy): unknown {
    const obj: any = {};
    if (message.copyMode !== 0) {
      obj.copyMode = label_AppliedLabelPolicy_CopyModeToJSON(message.copyMode);
    }
    return obj;
  },

  create(base?: DeepPartial<Label_AppliedLabelPolicy>): Label_AppliedLabelPolicy {
    return Label_AppliedLabelPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Label_AppliedLabelPolicy>): Label_AppliedLabelPolicy {
    const message = createBaseLabel_AppliedLabelPolicy();
    message.copyMode = object.copyMode ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
