// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/card/v1/card.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Color } from "../../../type/color.js";

export const protobufPackage = "google.apps.card.v1";

/**
 * A card interface displayed in a Google Chat message or Google Workspace
 * Add-on.
 *
 * Cards support a defined layout, interactive UI elements like buttons, and
 * rich media like images. Use cards to present detailed information,
 * gather information from users, and guide users to take a next step.
 *
 * [Card builder](https://addons.gsuite.google.com/uikit/builder)
 *
 * To learn how
 * to build cards, see the following documentation:
 *
 * * For Google Chat apps, see [Design the components of a card or
 *   dialog](https://developers.google.com/workspace/chat/design-components-card-dialog).
 * * For Google Workspace Add-ons, see [Card-based
 * interfaces](https://developers.google.com/apps-script/add-ons/concepts/cards).
 *
 * **Example: Card message for a Google Chat app**
 *
 * ![Example contact
 * card](https://developers.google.com/workspace/chat/images/card_api_reference.png)
 *
 * To create the sample card message in Google Chat, use the following JSON:
 *
 * ```
 * {
 *   "cardsV2": [
 *     {
 *       "cardId": "unique-card-id",
 *       "card": {
 *         "header": {
 *            "title": "Sasha",
 *            "subtitle": "Software Engineer",
 *            "imageUrl":
 *            "https://developers.google.com/workspace/chat/images/quickstart-app-avatar.png",
 *            "imageType": "CIRCLE",
 *            "imageAltText": "Avatar for Sasha"
 *          },
 *          "sections": [
 *            {
 *              "header": "Contact Info",
 *              "collapsible": true,
 *              "uncollapsibleWidgetsCount": 1,
 *              "widgets": [
 *                {
 *                  "decoratedText": {
 *                    "startIcon": {
 *                      "knownIcon": "EMAIL"
 *                    },
 *                    "text": "sasha@example.com"
 *                  }
 *                },
 *                {
 *                  "decoratedText": {
 *                    "startIcon": {
 *                      "knownIcon": "PERSON"
 *                    },
 *                    "text": "<font color=\"#80e27e\">Online</font>"
 *                  }
 *                },
 *                {
 *                  "decoratedText": {
 *                    "startIcon": {
 *                      "knownIcon": "PHONE"
 *                    },
 *                    "text": "+1 (555) 555-1234"
 *                  }
 *                },
 *                {
 *                  "buttonList": {
 *                    "buttons": [
 *                      {
 *                        "text": "Share",
 *                        "onClick": {
 *                         "openLink": {
 *                            "url": "https://example.com/share"
 *                          }
 *                        }
 *                      },
 *                      {
 *                        "text": "Edit",
 *                        "onClick": {
 *                          "action": {
 *                            "function": "goToView",
 *                            "parameters": [
 *                              {
 *                                "key": "viewType",
 *                                "value": "EDIT"
 *                              }
 *                            ]
 *                          }
 *                        }
 *                      }
 *                    ]
 *                  }
 *                }
 *              ]
 *            }
 *          ]
 *        }
 *     }
 *   ]
 * }
 * ```
 */
export interface Card {
  /**
   * The header of the card. A header usually contains a leading image and a
   * title. Headers always appear at the top of a card.
   */
  header:
    | Card_CardHeader
    | undefined;
  /**
   * Contains a collection of widgets. Each section has its own, optional
   * header. Sections are visually separated by a line divider. For an example
   * in Google Chat apps, see [Define a section of a
   * card](https://developers.google.com/workspace/chat/design-components-card-dialog#define_a_section_of_a_card).
   */
  sections: Card_Section[];
  /** The divider style between sections. */
  sectionDividerStyle: Card_DividerStyle;
  /**
   * The card's actions. Actions are added to the card's toolbar menu.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   *
   * For example, the following JSON constructs a card action menu with
   * `Settings` and `Send Feedback` options:
   *
   * ```
   * "card_actions": [
   *   {
   *     "actionLabel": "Settings",
   *     "onClick": {
   *       "action": {
   *         "functionName": "goToView",
   *         "parameters": [
   *           {
   *             "key": "viewType",
   *             "value": "SETTING"
   *          }
   *         ],
   *         "loadIndicator": "LoadIndicator.SPINNER"
   *       }
   *     }
   *   },
   *   {
   *     "actionLabel": "Send Feedback",
   *     "onClick": {
   *       "openLink": {
   *         "url": "https://example.com/feedback"
   *       }
   *     }
   *   }
   * ]
   * ```
   */
  cardActions: Card_CardAction[];
  /**
   * Name of the card. Used as a card identifier in card navigation.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  name: string;
  /**
   * The fixed footer shown at the bottom of this card.
   *
   * Setting `fixedFooter` without specifying a `primaryButton` or a
   * `secondaryButton` causes an error. For Chat apps, you can use fixed footers
   * in
   * [dialogs](https://developers.google.com/workspace/chat/dialogs), but not
   * [card
   * messages](https://developers.google.com/workspace/chat/create-messages#create).
   *
   * [Google Workspace Add-ons and Chat
   * apps](https://developers.google.com/workspace/extend):
   */
  fixedFooter:
    | Card_CardFixedFooter
    | undefined;
  /**
   * In Google Workspace Add-ons, sets the display properties of the
   * `peekCardHeader`.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  displayStyle: Card_DisplayStyle;
  /**
   * When displaying contextual content, the peek card header acts as a
   * placeholder so that the user can navigate forward between the homepage
   * cards and the contextual cards.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  peekCardHeader: Card_CardHeader | undefined;
}

/**
 * The divider style of a card. Currently only used for dividers betweens card
 * sections.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum Card_DividerStyle {
  /** DIVIDER_STYLE_UNSPECIFIED - Don't use. Unspecified. */
  DIVIDER_STYLE_UNSPECIFIED = 0,
  /** SOLID_DIVIDER - Default option. Render a solid divider between sections. */
  SOLID_DIVIDER = 1,
  /** NO_DIVIDER - If set, no divider is rendered between sections. */
  NO_DIVIDER = 2,
  UNRECOGNIZED = -1,
}

export function card_DividerStyleFromJSON(object: any): Card_DividerStyle {
  switch (object) {
    case 0:
    case "DIVIDER_STYLE_UNSPECIFIED":
      return Card_DividerStyle.DIVIDER_STYLE_UNSPECIFIED;
    case 1:
    case "SOLID_DIVIDER":
      return Card_DividerStyle.SOLID_DIVIDER;
    case 2:
    case "NO_DIVIDER":
      return Card_DividerStyle.NO_DIVIDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Card_DividerStyle.UNRECOGNIZED;
  }
}

export function card_DividerStyleToJSON(object: Card_DividerStyle): string {
  switch (object) {
    case Card_DividerStyle.DIVIDER_STYLE_UNSPECIFIED:
      return "DIVIDER_STYLE_UNSPECIFIED";
    case Card_DividerStyle.SOLID_DIVIDER:
      return "SOLID_DIVIDER";
    case Card_DividerStyle.NO_DIVIDER:
      return "NO_DIVIDER";
    case Card_DividerStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * In Google Workspace Add-ons,
 * determines how a card is displayed.
 *
 * [Google Workspace
 * Add-ons](https://developers.google.com/workspace/add-ons):
 */
export enum Card_DisplayStyle {
  /** DISPLAY_STYLE_UNSPECIFIED - Don't use. Unspecified. */
  DISPLAY_STYLE_UNSPECIFIED = 0,
  /**
   * PEEK - The header of the card appears at the bottom of the
   * sidebar, partially covering the current top card of the stack. Clicking
   * the header pops the card into the card stack. If the card has no header,
   * a generated header is used instead.
   */
  PEEK = 1,
  /**
   * REPLACE - Default value. The card is shown by replacing the view of the top card in
   * the card stack.
   */
  REPLACE = 2,
  UNRECOGNIZED = -1,
}

export function card_DisplayStyleFromJSON(object: any): Card_DisplayStyle {
  switch (object) {
    case 0:
    case "DISPLAY_STYLE_UNSPECIFIED":
      return Card_DisplayStyle.DISPLAY_STYLE_UNSPECIFIED;
    case 1:
    case "PEEK":
      return Card_DisplayStyle.PEEK;
    case 2:
    case "REPLACE":
      return Card_DisplayStyle.REPLACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Card_DisplayStyle.UNRECOGNIZED;
  }
}

export function card_DisplayStyleToJSON(object: Card_DisplayStyle): string {
  switch (object) {
    case Card_DisplayStyle.DISPLAY_STYLE_UNSPECIFIED:
      return "DISPLAY_STYLE_UNSPECIFIED";
    case Card_DisplayStyle.PEEK:
      return "PEEK";
    case Card_DisplayStyle.REPLACE:
      return "REPLACE";
    case Card_DisplayStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a card header. For an example in Google Chat apps, see [Add a
 * header](https://developers.google.com/workspace/chat/design-components-card-dialog#add_a_header).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Card_CardHeader {
  /**
   * Required. The title of the card header.
   * The header has a fixed height: if both a
   * title and subtitle are specified, each takes up one line. If only the
   * title is specified, it takes up both lines.
   */
  title: string;
  /**
   * The subtitle of the card header. If specified, appears on its own line
   * below the `title`.
   */
  subtitle: string;
  /**
   * The shape used to crop the image.
   *
   * [Google Workspace Add-ons and Chat
   * apps](https://developers.google.com/workspace/extend):
   */
  imageType: Widget_ImageType;
  /** The HTTPS URL of the image in the card header. */
  imageUrl: string;
  /** The alternative text of this image that's used for accessibility. */
  imageAltText: string;
}

/**
 * A section contains a collection of widgets that are rendered
 * vertically in the order that they're specified.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Card_Section {
  /**
   * Text that appears at the top of a section.
   * Supports simple HTML formatted text. For more information
   * about formatting text, see
   * [Formatting text in Google Chat
   * apps](https://developers.google.com/workspace/chat/format-messages#card-formatting)
   * and
   * [Formatting
   * text in Google Workspace
   * Add-ons](https://developers.google.com/apps-script/add-ons/concepts/widgets#text_formatting).
   */
  header: string;
  /**
   * All the widgets in the section.
   * Must contain at least one widget.
   */
  widgets: Widget[];
  /**
   * Indicates whether this section is collapsible.
   *
   * Collapsible sections hide some or all widgets, but users can expand the
   * section to reveal the hidden widgets by clicking **Show more**. Users
   * can hide the widgets again by clicking **Show less**.
   *
   * To determine which widgets are hidden, specify
   * `uncollapsibleWidgetsCount`.
   */
  collapsible: boolean;
  /**
   * The number of uncollapsible widgets which remain visible even when a
   * section is collapsed.
   *
   * For example, when a section
   * contains five widgets and the `uncollapsibleWidgetsCount` is set to `2`,
   * the first two widgets are always shown and the last three are collapsed
   * by default. The `uncollapsibleWidgetsCount` is taken into account only
   * when `collapsible` is `true`.
   */
  uncollapsibleWidgetsCount: number;
}

/**
 * A card action is the action associated with the card. For example,
 * an invoice card might include actions such as delete invoice, email
 * invoice, or open the invoice in a browser.
 *
 * [Google Workspace
 * Add-ons](https://developers.google.com/workspace/add-ons):
 */
export interface Card_CardAction {
  /** The label that displays as the action menu item. */
  actionLabel: string;
  /** The `onClick` action for this action item. */
  onClick: OnClick | undefined;
}

/**
 * A persistent (sticky) footer that that appears at the bottom of the card.
 *
 * Setting `fixedFooter` without specifying a `primaryButton` or a
 * `secondaryButton` causes an error.
 *
 * For Chat apps, you can use fixed footers in
 * [dialogs](https://developers.google.com/workspace/chat/dialogs), but not
 * [card
 * messages](https://developers.google.com/workspace/chat/create-messages#create).
 * For an example in Google Chat apps, see [Add a persistent
 * footer](https://developers.google.com/workspace/chat/design-components-card-dialog#add_a_persistent_footer).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Card_CardFixedFooter {
  /**
   * The primary button of the fixed footer. The button must be a text button
   * with text and color set.
   */
  primaryButton:
    | Button
    | undefined;
  /**
   * The secondary button of the fixed footer.  The button must be a text
   * button with text and color set.
   * If `secondaryButton` is set, you must also set `primaryButton`.
   */
  secondaryButton: Button | undefined;
}

/**
 * Each card is made up of widgets.
 *
 * A widget is a composite object that can represent one of text, images,
 * buttons, and other object types.
 */
export interface Widget {
  /**
   * Displays a text paragraph. Supports simple HTML formatted text. For more
   * information about formatting text, see
   * [Formatting text in Google Chat
   * apps](https://developers.google.com/workspace/chat/format-messages#card-formatting)
   * and
   * [Formatting
   * text in Google Workspace
   * Add-ons](https://developers.google.com/apps-script/add-ons/concepts/widgets#text_formatting).
   *
   * For example, the following JSON creates a bolded text:
   * ```
   * "textParagraph": {
   *   "text": "  <b>bold text</b>"
   * }
   * ```
   */
  textParagraph?:
    | TextParagraph
    | undefined;
  /**
   * Displays an image.
   *
   * For example, the following JSON creates an image with alternative text:
   * ```
   * "image": {
   *   "imageUrl":
   *   "https://developers.google.com/workspace/chat/images/quickstart-app-avatar.png",
   *   "altText": "Chat app avatar"
   * }
   * ```
   */
  image?:
    | Image
    | undefined;
  /**
   * Displays a decorated text item.
   *
   * For example, the following JSON creates a decorated text widget showing
   * email address:
   *
   * ```
   * "decoratedText": {
   *   "icon": {
   *     "knownIcon": "EMAIL"
   *   },
   *   "topLabel": "Email Address",
   *   "text": "sasha@example.com",
   *   "bottomLabel": "This is a new Email address!",
   *   "switchControl": {
   *     "name": "has_send_welcome_email_to_sasha",
   *     "selected": false,
   *     "controlType": "CHECKBOX"
   *   }
   * }
   * ```
   */
  decoratedText?:
    | DecoratedText
    | undefined;
  /**
   * A list of buttons.
   *
   * For example, the following JSON creates two buttons. The first
   * is a blue text button and the second is an image button that opens a
   * link:
   * ```
   * "buttonList": {
   *   "buttons": [
   *     {
   *       "text": "Edit",
   *       "color": {
   *         "red": 0,
   *         "green": 0,
   *         "blue": 1,
   *         "alpha": 1
   *       },
   *       "disabled": true,
   *     },
   *     {
   *       "icon": {
   *         "knownIcon": "INVITE",
   *         "altText": "check calendar"
   *       },
   *       "onClick": {
   *         "openLink": {
   *           "url": "https://example.com/calendar"
   *         }
   *       }
   *     }
   *   ]
   * }
   * ```
   */
  buttonList?:
    | ButtonList
    | undefined;
  /**
   * Displays a text box that users can type into.
   *
   * For example, the following JSON creates a text input for an email
   * address:
   *
   * ```
   * "textInput": {
   *   "name": "mailing_address",
   *   "label": "Mailing Address"
   * }
   * ```
   *
   * As another example, the following JSON creates a text input for a
   * programming language with static suggestions:
   * ```
   * "textInput": {
   *   "name": "preferred_programing_language",
   *   "label": "Preferred Language",
   *   "initialSuggestions": {
   *     "items": [
   *       {
   *         "text": "C++"
   *       },
   *       {
   *         "text": "Java"
   *       },
   *       {
   *         "text": "JavaScript"
   *       },
   *       {
   *         "text": "Python"
   *       }
   *     ]
   *   }
   * }
   * ```
   */
  textInput?:
    | TextInput
    | undefined;
  /**
   * Displays a selection control that lets users select items. Selection
   * controls can be checkboxes, radio buttons, switches, or dropdown menus.
   *
   * For example, the following JSON creates a dropdown menu that lets users
   * choose a size:
   *
   * ```
   * "selectionInput": {
   *   "name": "size",
   *   "label": "Size"
   *   "type": "DROPDOWN",
   *   "items": [
   *     {
   *       "text": "S",
   *       "value": "small",
   *       "selected": false
   *     },
   *     {
   *       "text": "M",
   *       "value": "medium",
   *       "selected": true
   *     },
   *     {
   *       "text": "L",
   *       "value": "large",
   *       "selected": false
   *     },
   *     {
   *       "text": "XL",
   *       "value": "extra_large",
   *       "selected": false
   *     }
   *   ]
   * }
   * ```
   */
  selectionInput?:
    | SelectionInput
    | undefined;
  /**
   * Displays a widget that lets users input a date, time, or date and time.
   *
   * For example, the following JSON creates a date time picker to schedule an
   * appointment:
   *
   * ```
   * "dateTimePicker": {
   *   "name": "appointment_time",
   *   "label": "Book your appointment at:",
   *   "type": "DATE_AND_TIME",
   *   "valueMsEpoch": "796435200000"
   * }
   * ```
   */
  dateTimePicker?:
    | DateTimePicker
    | undefined;
  /**
   * Displays a horizontal line divider between widgets.
   *
   * For example, the following JSON creates a divider:
   * ```
   * "divider": {
   * }
   * ```
   */
  divider?:
    | Divider
    | undefined;
  /**
   * Displays a grid with a collection of items.
   *
   * A grid supports any number of columns and items. The number of rows is
   * determined by the upper bounds of the number items divided by the number
   * of columns. A grid with 10 items and 2 columns has 5 rows. A grid with 11
   * items and 2 columns has 6 rows.
   *
   * [Google Workspace Add-ons and
   * Chat apps](https://developers.google.com/workspace/extend):
   *
   * For example, the following JSON creates a 2 column grid with a single
   * item:
   *
   * ```
   * "grid": {
   *   "title": "A fine collection of items",
   *   "columnCount": 2,
   *   "borderStyle": {
   *     "type": "STROKE",
   *     "cornerRadius": 4
   *   },
   *   "items": [
   *     {
   *       "image": {
   *         "imageUri": "https://www.example.com/image.png",
   *         "cropStyle": {
   *           "type": "SQUARE"
   *         },
   *         "borderStyle": {
   *           "type": "STROKE"
   *         }
   *       },
   *       "title": "An item",
   *       "textAlignment": "CENTER"
   *     }
   *   ],
   *   "onClick": {
   *     "openLink": {
   *       "url": "https://www.example.com"
   *     }
   *   }
   * }
   * ```
   */
  grid?:
    | Grid
    | undefined;
  /**
   * Displays up to 2 columns.
   *
   * To include more than 2 columns, or to use rows, use the `Grid` widget.
   *
   * For example, the following JSON creates 2 columns that each contain
   * text paragraphs:
   *
   * ```
   * "columns": {
   *   "columnItems": [
   *     {
   *       "horizontalSizeStyle": "FILL_AVAILABLE_SPACE",
   *       "horizontalAlignment": "CENTER",
   *       "verticalAlignment": "CENTER",
   *       "widgets": [
   *         {
   *           "textParagraph": {
   *             "text": "First column text paragraph"
   *           }
   *         }
   *       ]
   *     },
   *     {
   *       "horizontalSizeStyle": "FILL_AVAILABLE_SPACE",
   *       "horizontalAlignment": "CENTER",
   *       "verticalAlignment": "CENTER",
   *       "widgets": [
   *         {
   *           "textParagraph": {
   *             "text": "Second column text paragraph"
   *           }
   *         }
   *       ]
   *     }
   *   ]
   * }
   * ```
   */
  columns?:
    | Columns
    | undefined;
  /** Specifies whether widgets align to the left, right, or center of a column. */
  horizontalAlignment: Widget_HorizontalAlignment;
}

/**
 * The shape used to crop the image.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum Widget_ImageType {
  /**
   * SQUARE - Default value. Applies a square mask to the image. For example, a 4x3
   * image becomes 3x3.
   */
  SQUARE = 0,
  /**
   * CIRCLE - Applies a circular mask to the image. For example, a 4x3 image becomes a
   * circle with a diameter of 3.
   */
  CIRCLE = 1,
  UNRECOGNIZED = -1,
}

export function widget_ImageTypeFromJSON(object: any): Widget_ImageType {
  switch (object) {
    case 0:
    case "SQUARE":
      return Widget_ImageType.SQUARE;
    case 1:
    case "CIRCLE":
      return Widget_ImageType.CIRCLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Widget_ImageType.UNRECOGNIZED;
  }
}

export function widget_ImageTypeToJSON(object: Widget_ImageType): string {
  switch (object) {
    case Widget_ImageType.SQUARE:
      return "SQUARE";
    case Widget_ImageType.CIRCLE:
      return "CIRCLE";
    case Widget_ImageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies whether widgets align to the left, right, or center of a column.
 *
 * [Google Chat apps](https://developers.google.com/workspace/chat):
 */
export enum Widget_HorizontalAlignment {
  /** HORIZONTAL_ALIGNMENT_UNSPECIFIED - Don't use. Unspecified. */
  HORIZONTAL_ALIGNMENT_UNSPECIFIED = 0,
  /**
   * START - Default value. Aligns widgets to the start position of the column. For
   * left-to-right layouts, aligns to the left. For right-to-left layouts,
   * aligns to the right.
   */
  START = 1,
  /** CENTER - Aligns widgets to the center of the column. */
  CENTER = 2,
  /**
   * END - Aligns widgets to the end position of the column. For left-to-right
   * layouts, aligns widgets to the right. For right-to-left layouts, aligns
   * widgets to the left.
   */
  END = 3,
  UNRECOGNIZED = -1,
}

export function widget_HorizontalAlignmentFromJSON(object: any): Widget_HorizontalAlignment {
  switch (object) {
    case 0:
    case "HORIZONTAL_ALIGNMENT_UNSPECIFIED":
      return Widget_HorizontalAlignment.HORIZONTAL_ALIGNMENT_UNSPECIFIED;
    case 1:
    case "START":
      return Widget_HorizontalAlignment.START;
    case 2:
    case "CENTER":
      return Widget_HorizontalAlignment.CENTER;
    case 3:
    case "END":
      return Widget_HorizontalAlignment.END;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Widget_HorizontalAlignment.UNRECOGNIZED;
  }
}

export function widget_HorizontalAlignmentToJSON(object: Widget_HorizontalAlignment): string {
  switch (object) {
    case Widget_HorizontalAlignment.HORIZONTAL_ALIGNMENT_UNSPECIFIED:
      return "HORIZONTAL_ALIGNMENT_UNSPECIFIED";
    case Widget_HorizontalAlignment.START:
      return "START";
    case Widget_HorizontalAlignment.CENTER:
      return "CENTER";
    case Widget_HorizontalAlignment.END:
      return "END";
    case Widget_HorizontalAlignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A paragraph of text that supports formatting. For an example in
 * Google Chat apps, see [Add a paragraph of formatted
 * text](https://developers.google.com/workspace/chat/add-text-image-card-dialog#add_a_paragraph_of_formatted_text).
 * For more information
 * about formatting text, see
 * [Formatting text in Google Chat
 * apps](https://developers.google.com/workspace/chat/format-messages#card-formatting)
 * and
 * [Formatting
 * text in Google Workspace
 * Add-ons](https://developers.google.com/apps-script/add-ons/concepts/widgets#text_formatting).
 *
 * [Google Workspace Add-ons and
 * Chat apps](https://developers.google.com/workspace/extend):
 */
export interface TextParagraph {
  /** The text that's shown in the widget. */
  text: string;
}

/**
 * An image that is specified by a URL and can have an `onClick` action. For an
 * example, see [Add an
 * image](https://developers.google.com/workspace/chat/add-text-image-card-dialog#add_an_image).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Image {
  /**
   * The HTTPS URL that hosts the image.
   *
   * For example:
   *
   * ```
   * https://developers.google.com/workspace/chat/images/quickstart-app-avatar.png
   * ```
   */
  imageUrl: string;
  /** When a user clicks the image, the click triggers this action. */
  onClick:
    | OnClick
    | undefined;
  /** The alternative text of this image that's used for accessibility. */
  altText: string;
}

/**
 * Displays a divider between widgets as a horizontal line. For an example in
 * Google Chat apps, see
 * [Add a horizontal divider between
 * widgets](https://developers.google.com/workspace/chat/format-structure-card-dialog#add_a_horizontal_divider_between_widgets).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 *
 * For example, the following JSON creates a divider:
 *
 * ```
 * "divider": {}
 * ```
 */
export interface Divider {
}

/**
 * A widget that displays text with optional decorations such as a label above
 * or below the text, an icon in front of the text, a selection widget, or a
 * button after the text. For an example in
 * Google Chat apps, see [Display text with decorative
 * text](https://developers.google.com/workspace/chat/add-text-image-card-dialog#display_text_with_decorative_elements).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface DecoratedText {
  /**
   * Deprecated in favor of `startIcon`.
   *
   * @deprecated
   */
  icon:
    | Icon
    | undefined;
  /** The icon displayed in front of the text. */
  startIcon:
    | Icon
    | undefined;
  /** The text that appears above `text`. Always truncates. */
  topLabel: string;
  /**
   * Required. The primary text.
   *
   * Supports simple formatting. For more information
   * about formatting text, see
   * [Formatting text in Google Chat
   * apps](https://developers.google.com/workspace/chat/format-messages#card-formatting)
   * and
   * [Formatting
   * text in Google Workspace
   * Add-ons](https://developers.google.com/apps-script/add-ons/concepts/widgets#text_formatting).
   */
  text: string;
  /**
   * The wrap text setting. If `true`, the text wraps and displays on
   * multiple lines. Otherwise, the text is truncated.
   *
   * Only applies to `text`, not `topLabel` and `bottomLabel`.
   */
  wrapText: boolean;
  /** The text that appears below `text`. Always wraps. */
  bottomLabel: string;
  /** This action is triggered when users click `topLabel` or `bottomLabel`. */
  onClick:
    | OnClick
    | undefined;
  /** A button that a user can click to trigger an action. */
  button?:
    | Button
    | undefined;
  /**
   * A switch widget that a user can click to change its state and trigger an
   * action.
   */
  switchControl?:
    | DecoratedText_SwitchControl
    | undefined;
  /**
   * An icon displayed after the text.
   *
   * Supports
   * [built-in](https://developers.google.com/workspace/chat/format-messages#builtinicons)
   * and
   * [custom](https://developers.google.com/workspace/chat/format-messages#customicons)
   * icons.
   */
  endIcon?: Icon | undefined;
}

/**
 * Either a toggle-style switch or a checkbox inside a `decoratedText` widget.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 *
 * Only supported in the `decoratedText` widget.
 */
export interface DecoratedText_SwitchControl {
  /**
   * The name by which the switch widget is identified in a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  name: string;
  /**
   * The value entered by a user, returned as part of a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  value: string;
  /** When `true`, the switch is selected. */
  selected: boolean;
  /**
   * The action to perform when the switch state is changed, such as what
   *  function to run.
   */
  onChangeAction:
    | Action
    | undefined;
  /**
   * How the switch appears in the user interface.
   *
   * [Google Workspace Add-ons
   * and Chat apps](https://developers.google.com/workspace/extend):
   */
  controlType: DecoratedText_SwitchControl_ControlType;
}

/**
 * How the switch appears in the user interface.
 *
 * [Google Workspace Add-ons
 * and Chat apps](https://developers.google.com/workspace/extend):
 */
export enum DecoratedText_SwitchControl_ControlType {
  /** SWITCH - A toggle-style switch. */
  SWITCH = 0,
  /** CHECKBOX - Deprecated in favor of `CHECK_BOX`. */
  CHECKBOX = 1,
  /** CHECK_BOX - A checkbox. */
  CHECK_BOX = 2,
  UNRECOGNIZED = -1,
}

export function decoratedText_SwitchControl_ControlTypeFromJSON(object: any): DecoratedText_SwitchControl_ControlType {
  switch (object) {
    case 0:
    case "SWITCH":
      return DecoratedText_SwitchControl_ControlType.SWITCH;
    case 1:
    case "CHECKBOX":
      return DecoratedText_SwitchControl_ControlType.CHECKBOX;
    case 2:
    case "CHECK_BOX":
      return DecoratedText_SwitchControl_ControlType.CHECK_BOX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DecoratedText_SwitchControl_ControlType.UNRECOGNIZED;
  }
}

export function decoratedText_SwitchControl_ControlTypeToJSON(object: DecoratedText_SwitchControl_ControlType): string {
  switch (object) {
    case DecoratedText_SwitchControl_ControlType.SWITCH:
      return "SWITCH";
    case DecoratedText_SwitchControl_ControlType.CHECKBOX:
      return "CHECKBOX";
    case DecoratedText_SwitchControl_ControlType.CHECK_BOX:
      return "CHECK_BOX";
    case DecoratedText_SwitchControl_ControlType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A field in which users can enter text. Supports suggestions and on-change
 * actions. For an example in Google Chat apps, see [Add a field in which a user
 * can enter
 * text](https://developers.google.com/workspace/chat/design-interactive-card-dialog#add_a_field_in_which_a_user_can_enter_text).
 *
 * Chat apps receive and can process the value of entered text during form input
 * events. For details about working with form inputs, see [Receive form
 * data](https://developers.google.com/workspace/chat/read-form-data).
 *
 * When you need to collect undefined or abstract data from users,
 * use a text input. To collect defined or enumerated data from users, use the
 * [SelectionInput][google.apps.card.v1.SelectionInput] widget.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface TextInput {
  /**
   * The name by which the text input is identified in a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  name: string;
  /**
   * The text that appears above the text input field in the user interface.
   *
   * Specify text that helps the user enter the information your app needs.
   * For example, if you are asking someone's name, but specifically need their
   * surname, write `surname` instead of `name`.
   *
   * Required if `hintText` is unspecified. Otherwise, optional.
   */
  label: string;
  /**
   * Text that appears below the text input field meant to assist users by
   * prompting them to enter a certain value. This text is always visible.
   *
   * Required if `label` is unspecified. Otherwise, optional.
   */
  hintText: string;
  /**
   * The value entered by a user, returned as part of a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  value: string;
  /**
   * How a text input field appears in the user interface.
   * For example, whether the field is single or multi-line.
   */
  type: TextInput_Type;
  /**
   * What to do when a change occurs in the text input field. For example, a
   * user adding to the field or deleting text.
   *
   * Examples of actions to take include running a custom function or opening
   * a [dialog](https://developers.google.com/workspace/chat/dialogs)
   * in Google Chat.
   */
  onChangeAction:
    | Action
    | undefined;
  /**
   * Suggested values that users can enter. These values appear when users click
   * inside the text input field. As users type, the suggested values
   * dynamically filter to match what the users have typed.
   *
   * For example, a text input field for programming language might suggest
   * Java, JavaScript, Python, and C++. When users start typing `Jav`, the list
   * of suggestions filters to show just `Java` and `JavaScript`.
   *
   * Suggested values help guide users to enter values that your app can make
   * sense of. When referring to JavaScript, some users might enter `javascript`
   * and others `java script`. Suggesting `JavaScript` can standardize how users
   * interact with your app.
   *
   * When specified, `TextInput.type` is always `SINGLE_LINE`, even if it's set
   * to `MULTIPLE_LINE`.
   *
   * [Google Workspace
   * Add-ons and Chat apps](https://developers.google.com/workspace/extend):
   */
  initialSuggestions:
    | Suggestions
    | undefined;
  /**
   * Optional. Specify what action to take when the text input field provides
   * suggestions to users who interact with it.
   *
   * If unspecified, the suggestions are set by `initialSuggestions` and
   * are processed by the client.
   *
   * If specified, the app takes the action specified here, such as running
   * a custom function.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  autoCompleteAction:
    | Action
    | undefined;
  /**
   * Text that appears in the text input field when the field is empty.
   * Use this text to prompt users to enter a value. For example, `Enter a
   * number from 0 to 100`.
   *
   * [Google Chat apps](https://developers.google.com/workspace/chat):
   */
  placeholderText: string;
}

/**
 * How a text input field appears in the user interface. For example,
 * whether it's a single line input field, or a multi-line input. If
 * `initialSuggestions` is specified, `type` is always `SINGLE_LINE`,
 * even if it's set to `MULTIPLE_LINE`.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum TextInput_Type {
  /** SINGLE_LINE - The text input field has a fixed height of one line. */
  SINGLE_LINE = 0,
  /** MULTIPLE_LINE - The text input field has a fixed height of multiple lines. */
  MULTIPLE_LINE = 1,
  UNRECOGNIZED = -1,
}

export function textInput_TypeFromJSON(object: any): TextInput_Type {
  switch (object) {
    case 0:
    case "SINGLE_LINE":
      return TextInput_Type.SINGLE_LINE;
    case 1:
    case "MULTIPLE_LINE":
      return TextInput_Type.MULTIPLE_LINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextInput_Type.UNRECOGNIZED;
  }
}

export function textInput_TypeToJSON(object: TextInput_Type): string {
  switch (object) {
    case TextInput_Type.SINGLE_LINE:
      return "SINGLE_LINE";
    case TextInput_Type.MULTIPLE_LINE:
      return "MULTIPLE_LINE";
    case TextInput_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Suggested values that users can enter. These values appear when users click
 * inside the text input field. As users type, the suggested values
 * dynamically filter to match what the users have typed.
 *
 * For example, a text input field for programming language might suggest
 * Java, JavaScript, Python, and C++. When users start typing `Jav`, the list
 * of suggestions filters to show `Java` and `JavaScript`.
 *
 * Suggested values help guide users to enter values that your app can make
 * sense of. When referring to JavaScript, some users might enter `javascript`
 * and others `java script`. Suggesting `JavaScript` can standardize how users
 * interact with your app.
 *
 * When specified, `TextInput.type` is always `SINGLE_LINE`, even if it's set
 * to `MULTIPLE_LINE`.
 *
 * [Google Workspace
 * Add-ons and Chat apps](https://developers.google.com/workspace/extend):
 */
export interface Suggestions {
  /**
   * A list of suggestions used for autocomplete recommendations in text input
   * fields.
   */
  items: Suggestions_SuggestionItem[];
}

/**
 * One suggested value that users can enter in a text input field.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Suggestions_SuggestionItem {
  /**
   * The value of a suggested input to a text input field. This is
   * equivalent to what users enter themselves.
   */
  text?: string | undefined;
}

/**
 * A list of buttons layed out horizontally. For an example in
 * Google Chat apps, see
 * [Add a
 * button](https://developers.google.com/workspace/chat/design-interactive-card-dialog#add_a_button).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface ButtonList {
  /** An array of buttons. */
  buttons: Button[];
}

/**
 * A widget that creates one or more UI items that users can select.
 * For example, a dropdown menu or checkboxes. You can use this widget to
 * collect data that can be predicted or enumerated. For an example in Google
 * Chat apps, see [Add selectable UI
 * elements](/workspace/chat/design-interactive-card-dialog#add_selectable_ui_elements).
 *
 * Chat apps can process the value of items that users select or input. For
 * details about working with form inputs, see [Receive form
 * data](https://developers.google.com/workspace/chat/read-form-data).
 *
 * To collect undefined or abstract data from users, use
 * the [TextInput][google.apps.card.v1.TextInput] widget.
 *
 * [Google Workspace Add-ons
 * and Chat apps](https://developers.google.com/workspace/extend):
 */
export interface SelectionInput {
  /**
   * The name that identifies the selection input in a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  name: string;
  /**
   * The text that appears above the selection input field in the user
   * interface.
   *
   * Specify text that helps the user enter the information your app needs.
   * For example, if users are selecting the urgency of a work ticket from a
   * drop-down menu, the label might be "Urgency" or "Select urgency".
   */
  label: string;
  /**
   * The type of items that are displayed to users in a `SelectionInput` widget.
   * Selection types support different types of interactions. For example, users
   * can select one or more checkboxes, but they can only select one value from
   * a dropdown menu.
   */
  type: SelectionInput_SelectionType;
  /**
   * An array of selectable items. For example, an array of radio buttons or
   * checkboxes. Supports up to 100 items.
   */
  items: SelectionInput_SelectionItem[];
  /**
   * If specified, the form is submitted when the selection changes. If not
   * specified, you must specify a separate button that submits the form.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  onChangeAction:
    | Action
    | undefined;
  /**
   * For multiselect menus, the maximum number of items that a user can select.
   * Minimum value is 1 item. If unspecified, defaults to 3 items.
   */
  multiSelectMaxSelectedItems: number;
  /**
   * For multiselect menus, the number of text characters that a user inputs
   * before the app queries autocomplete and displays suggested items
   * in the menu.
   *
   * If unspecified, defaults to 0 characters for static data sources and 3
   * characters for external data sources.
   */
  multiSelectMinQueryLength: number;
  /** An external data source, such as a relational data base. */
  externalDataSource?:
    | Action
    | undefined;
  /** A data source from Google Workspace. */
  platformDataSource?: SelectionInput_PlatformDataSource | undefined;
}

/**
 * The format for the items that users can select. Different options support
 * different types of interactions. For example, users can select multiple
 * checkboxes, but can only select one item from a dropdown menu.
 *
 * Each selection input supports one type of selection. Mixing checkboxes
 * and switches, for example, isn't supported.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum SelectionInput_SelectionType {
  /** CHECK_BOX - A set of checkboxes. Users can select one or more checkboxes. */
  CHECK_BOX = 0,
  /** RADIO_BUTTON - A set of radio buttons. Users can select one radio button. */
  RADIO_BUTTON = 1,
  /** SWITCH - A set of switches. Users can turn on one or more switches. */
  SWITCH = 2,
  /** DROPDOWN - A dropdown menu. Users can select one item from the menu. */
  DROPDOWN = 3,
  /**
   * MULTI_SELECT - A multiselect menu for static or dynamic data. From the menu bar,
   * users select one or more items. Users can also input values to populate
   * dynamic data. For example, users can start typing the name of a Google
   * Chat space and the widget autosuggests the space.
   *
   * To populate items for a multiselect menu, you can use one of the
   * following types of data sources:
   *
   *  * Static data: Items are specified as `SelectionItem` objects in the
   *    widget. Up to 100 items.
   *  * Google Workspace data: Items are populated using data from Google
   *    Workspace, such as Google Workspace users or Google Chat spaces.
   *  * External data: Items are populated from an external data
   *    source outside of Google Workspace.
   *
   * For examples of how to implement multiselect menus, see
   * [Add a multiselect
   * menu](https://developers.google.com/workspace/chat/design-interactive-card-dialog#multiselect-menu).
   *
   * [Google Workspace Add-ons and Chat
   * apps](https://developers.google.com/workspace/extend):
   * Multiselect for Google Workspace Add-ons are in
   * Developer Preview.
   */
  MULTI_SELECT = 4,
  UNRECOGNIZED = -1,
}

export function selectionInput_SelectionTypeFromJSON(object: any): SelectionInput_SelectionType {
  switch (object) {
    case 0:
    case "CHECK_BOX":
      return SelectionInput_SelectionType.CHECK_BOX;
    case 1:
    case "RADIO_BUTTON":
      return SelectionInput_SelectionType.RADIO_BUTTON;
    case 2:
    case "SWITCH":
      return SelectionInput_SelectionType.SWITCH;
    case 3:
    case "DROPDOWN":
      return SelectionInput_SelectionType.DROPDOWN;
    case 4:
    case "MULTI_SELECT":
      return SelectionInput_SelectionType.MULTI_SELECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SelectionInput_SelectionType.UNRECOGNIZED;
  }
}

export function selectionInput_SelectionTypeToJSON(object: SelectionInput_SelectionType): string {
  switch (object) {
    case SelectionInput_SelectionType.CHECK_BOX:
      return "CHECK_BOX";
    case SelectionInput_SelectionType.RADIO_BUTTON:
      return "RADIO_BUTTON";
    case SelectionInput_SelectionType.SWITCH:
      return "SWITCH";
    case SelectionInput_SelectionType.DROPDOWN:
      return "DROPDOWN";
    case SelectionInput_SelectionType.MULTI_SELECT:
      return "MULTI_SELECT";
    case SelectionInput_SelectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An item that users can select in a selection input, such as a checkbox
 * or switch.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface SelectionInput_SelectionItem {
  /** The text that identifies or describes the item to users. */
  text: string;
  /**
   * The value associated with this item. The client should use this as a form
   * input value.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  value: string;
  /**
   * Whether the item is selected by default. If the selection input only
   * accepts one value (such as for radio buttons or a dropdown menu), only
   * set this field for one item.
   */
  selected: boolean;
  /**
   * For multiselect menus, the URL for the icon displayed next to
   * the item's `text` field. Supports PNG and JPEG files. Must be an `HTTPS`
   * URL. For example,
   * `https://developers.google.com/workspace/chat/images/quickstart-app-avatar.png`.
   */
  startIconUri: string;
  /**
   * For multiselect menus, a text description or label that's
   * displayed below the item's `text` field.
   */
  bottomText: string;
}

/**
 * For a
 * [`SelectionInput`][google.apps.card.v1.SelectionInput] widget that uses a
 * multiselect menu, a data source from Google Workspace. Used to populate
 * items in a multiselect menu.
 *
 * [Google Chat apps](https://developers.google.com/workspace/chat):
 */
export interface SelectionInput_PlatformDataSource {
  /**
   * A data source shared by all Google Workspace applications, such as
   * users in a Google Workspace organization.
   */
  commonDataSource?: SelectionInput_PlatformDataSource_CommonDataSource | undefined;
}

/**
 * A data source shared by all [Google Workspace
 * applications]
 * (https://developers.google.com/workspace/chat/api/reference/rest/v1/HostApp).
 *
 * [Google Chat apps](https://developers.google.com/workspace/chat):
 */
export enum SelectionInput_PlatformDataSource_CommonDataSource {
  /** UNKNOWN - Default value. Don't use. */
  UNKNOWN = 0,
  /**
   * USER - Google Workspace users. The user can only view and select users from
   * their Google Workspace organization.
   */
  USER = 1,
  UNRECOGNIZED = -1,
}

export function selectionInput_PlatformDataSource_CommonDataSourceFromJSON(
  object: any,
): SelectionInput_PlatformDataSource_CommonDataSource {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return SelectionInput_PlatformDataSource_CommonDataSource.UNKNOWN;
    case 1:
    case "USER":
      return SelectionInput_PlatformDataSource_CommonDataSource.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SelectionInput_PlatformDataSource_CommonDataSource.UNRECOGNIZED;
  }
}

export function selectionInput_PlatformDataSource_CommonDataSourceToJSON(
  object: SelectionInput_PlatformDataSource_CommonDataSource,
): string {
  switch (object) {
    case SelectionInput_PlatformDataSource_CommonDataSource.UNKNOWN:
      return "UNKNOWN";
    case SelectionInput_PlatformDataSource_CommonDataSource.USER:
      return "USER";
    case SelectionInput_PlatformDataSource_CommonDataSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Lets users input a date, a time, or both a date and a time. For an example in
 * Google Chat apps, see [Let a user pick a date and
 * time](https://developers.google.com/workspace/chat/design-interactive-card-dialog#let_a_user_pick_a_date_and_time).
 *
 * Users can input text or use the picker to select dates and times. If users
 * input an invalid date or time, the picker shows an error that prompts users
 * to input the information correctly.
 *
 * [Google Workspace
 * Add-ons and Chat apps](https://developers.google.com/workspace/extend):
 */
export interface DateTimePicker {
  /**
   * The name by which the `DateTimePicker` is identified in a form input event.
   *
   * For details about working with form inputs, see [Receive form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  name: string;
  /**
   * The text that prompts users to input a date, a time, or a date and time.
   * For example, if users are scheduling an appointment, use a label such as
   * `Appointment date` or `Appointment date and time`.
   */
  label: string;
  /** Whether the widget supports inputting a date, a time, or the date and time. */
  type: DateTimePicker_DateTimePickerType;
  /**
   * The default value displayed in the widget, in milliseconds since [Unix
   * epoch time](https://en.wikipedia.org/wiki/Unix_time).
   *
   * Specify the value based on the type of picker (`DateTimePickerType`):
   *
   * * `DATE_AND_TIME`: a calendar date and time in UTC. For example, to
   *   represent January 1, 2023 at 12:00 PM UTC, use `1672574400000`.
   * * `DATE_ONLY`: a calendar date at 00:00:00 UTC. For example, to represent
   *   January 1, 2023, use `1672531200000`.
   * * `TIME_ONLY`: a time in UTC. For example, to represent 12:00 PM, use
   *   `43200000` (or `12 * 60 * 60 * 1000`).
   */
  valueMsEpoch: Long;
  /**
   * The number representing the time zone offset from UTC, in minutes.
   * If set, the `value_ms_epoch` is displayed in the specified time zone.
   * If unset, the value defaults to the user's time zone setting.
   */
  timezoneOffsetDate: number;
  /**
   * Triggered when the user clicks **Save** or **Clear** from the
   * `DateTimePicker` interface.
   */
  onChangeAction: Action | undefined;
}

/**
 * The format for the date and time in the `DateTimePicker` widget.
 * Determines whether users can input a date, a time, or both a date and time.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum DateTimePicker_DateTimePickerType {
  /** DATE_AND_TIME - Users input a date and time. */
  DATE_AND_TIME = 0,
  /** DATE_ONLY - Users input a date. */
  DATE_ONLY = 1,
  /** TIME_ONLY - Users input a time. */
  TIME_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function dateTimePicker_DateTimePickerTypeFromJSON(object: any): DateTimePicker_DateTimePickerType {
  switch (object) {
    case 0:
    case "DATE_AND_TIME":
      return DateTimePicker_DateTimePickerType.DATE_AND_TIME;
    case 1:
    case "DATE_ONLY":
      return DateTimePicker_DateTimePickerType.DATE_ONLY;
    case 2:
    case "TIME_ONLY":
      return DateTimePicker_DateTimePickerType.TIME_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DateTimePicker_DateTimePickerType.UNRECOGNIZED;
  }
}

export function dateTimePicker_DateTimePickerTypeToJSON(object: DateTimePicker_DateTimePickerType): string {
  switch (object) {
    case DateTimePicker_DateTimePickerType.DATE_AND_TIME:
      return "DATE_AND_TIME";
    case DateTimePicker_DateTimePickerType.DATE_ONLY:
      return "DATE_ONLY";
    case DateTimePicker_DateTimePickerType.TIME_ONLY:
      return "TIME_ONLY";
    case DateTimePicker_DateTimePickerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A text, icon, or text and icon button that users can click. For an example in
 * Google Chat apps, see
 * [Add a
 * button](https://developers.google.com/workspace/chat/design-interactive-card-dialog#add_a_button).
 *
 * To make an image a clickable button, specify an
 * [`Image`][google.apps.card.v1.Image] (not an
 * [`ImageComponent`][google.apps.card.v1.ImageComponent]) and set an
 * `onClick` action.
 *
 * [Google Workspace
 * Add-ons and Chat apps](https://developers.google.com/workspace/extend):
 */
export interface Button {
  /** The text displayed inside the button. */
  text: string;
  /**
   * The icon image. If both `icon` and `text` are set, then the icon appears
   * before the text.
   */
  icon:
    | Icon
    | undefined;
  /**
   * If set, the button is filled with a solid background color and the font
   * color changes to maintain contrast with the background color. For example,
   * setting a blue background likely results in white text.
   *
   * If unset, the image background is white and the font color is blue.
   *
   * For red, green, and blue, the value of each field is a `float` number that
   * you can express in either of two ways: as a number between 0 and 255
   * divided by 255 (153/255), or as a value between 0 and 1 (0.6). 0 represents
   * the absence of a color and 1 or 255/255 represent the full presence of that
   * color on the RGB scale.
   *
   * Optionally set `alpha`, which sets a level of transparency using this
   * equation:
   *
   * ```
   * pixel color = alpha * (this color) + (1.0 - alpha) * (background color)
   * ```
   *
   * For `alpha`, a value of `1` corresponds with a solid color, and a value of
   * `0` corresponds with a completely transparent color.
   *
   * For example, the following color represents a half transparent red:
   *
   * ```
   * "color": {
   *    "red": 1,
   *    "green": 0,
   *    "blue": 0,
   *    "alpha": 0.5
   * }
   * ```
   */
  color:
    | Color
    | undefined;
  /**
   * Required. The action to perform when a user clicks the button, such as
   * opening a hyperlink or running a custom function.
   */
  onClick:
    | OnClick
    | undefined;
  /**
   * If `true`, the button is displayed in an inactive state and doesn't respond
   * to user actions.
   */
  disabled: boolean;
  /**
   * The alternative text that's used for accessibility.
   *
   * Set descriptive text that lets users know what the button does. For
   * example, if a button opens a hyperlink, you might write: "Opens a new
   * browser tab and navigates to the Google Chat developer documentation at
   * https://developers.google.com/workspace/chat".
   */
  altText: string;
}

/**
 * An icon displayed in a widget on a card. For an example in Google Chat apps,
 * see [Add an
 * icon](https://developers.google.com/workspace/chat/add-text-image-card-dialog#add_an_icon).
 *
 * Supports
 * [built-in](https://developers.google.com/workspace/chat/format-messages#builtinicons)
 * and
 * [custom](https://developers.google.com/workspace/chat/format-messages#customicons)
 * icons.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Icon {
  /**
   * Display one of the built-in icons provided by Google Workspace.
   *
   * For example, to display an airplane icon, specify `AIRPLANE`.
   * For a bus, specify `BUS`.
   *
   * For a full list of supported icons, see [built-in
   * icons](https://developers.google.com/workspace/chat/format-messages#builtinicons).
   */
  knownIcon?:
    | string
    | undefined;
  /**
   * Display a custom icon hosted at an HTTPS URL.
   *
   * For example:
   *
   * ```
   * "iconUrl":
   * "https://developers.google.com/workspace/chat/images/quickstart-app-avatar.png"
   * ```
   *
   * Supported file types include `.png` and `.jpg`.
   */
  iconUrl?:
    | string
    | undefined;
  /**
   * Display one of the [Google Material
   * Icons](https://fonts.google.com/icons).
   *
   * For example, to display a [checkbox
   * icon](https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck_box%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048),
   * use
   * ```
   * "material_icon": {
   *   "name": "check_box"
   * }
   * ```
   *
   * [Google Chat apps](https://developers.google.com/workspace/chat):
   */
  materialIcon?:
    | MaterialIcon
    | undefined;
  /**
   * Optional. A description of the icon used for accessibility.
   * If unspecified, the default value `Button` is provided. As a best practice,
   * you should set a helpful description for what the icon displays, and if
   * applicable, what it does. For example, `A user's account portrait`, or
   * `Opens a new browser tab and navigates to the Google Chat developer
   * documentation at https://developers.google.com/workspace/chat`.
   *
   * If the icon is set in a [`Button`][google.apps.card.v1.Button], the
   * `altText` appears as helper text when the user hovers over the button.
   * However, if the button also sets `text`, the icon's `altText` is ignored.
   */
  altText: string;
  /**
   * The crop style applied to the image. In some cases, applying a
   * `CIRCLE` crop causes the image to be drawn larger than a built-in
   * icon.
   */
  imageType: Widget_ImageType;
}

/**
 * A [Google Material Icon](https://fonts.google.com/icons), which includes over
 * 2500+ options.
 *
 * For example, to display a [checkbox
 * icon](https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck_box%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048)
 * with customized weight and grade, write the following:
 *
 * ```
 * {
 *   "name": "check_box",
 *   "fill": true,
 *   "weight": 300,
 *   "grade": -25
 * }
 * ```
 *
 * [Google Chat apps](https://developers.google.com/workspace/chat):
 */
export interface MaterialIcon {
  /**
   * The icon name defined in the [Google Material
   * Icon](https://fonts.google.com/icons), for example, `check_box`. Any
   * invalid names are abandoned and replaced with empty string and
   * results in the icon failing to render.
   */
  name: string;
  /**
   * Whether the icon renders as filled. Default value is false.
   *
   * To preview different icon settings, go to
   * [Google Font Icons](https://fonts.google.com/icons) and adjust the
   * settings under **Customize**.
   */
  fill: boolean;
  /**
   * The stroke weight of the icon. Choose from {100, 200, 300, 400,
   * 500, 600, 700}. If absent, default value is 400. If any other value is
   * specified, the default value is used.
   *
   * To preview different icon settings, go to
   * [Google Font Icons](https://fonts.google.com/icons) and adjust the
   * settings under **Customize**.
   */
  weight: number;
  /**
   * Weight and grade affect a symbol’s thickness. Adjustments to grade are more
   * granular than adjustments to weight and have a small impact on the size of
   * the symbol. Choose from {-25, 0, 200}. If absent, default value is 0. If
   * any other value is specified, the default value is used.
   *
   * To preview different icon settings, go to
   * [Google Font Icons](https://fonts.google.com/icons) and adjust the
   * settings under **Customize**.
   */
  grade: number;
}

/**
 * Represents the crop style applied to an image.
 *
 * [Google Workspace Add-ons and
 * Chat apps](https://developers.google.com/workspace/extend):
 *
 * For example, here's how to apply a 16:9 aspect ratio:
 *
 * ```
 * cropStyle {
 *  "type": "RECTANGLE_CUSTOM",
 *  "aspectRatio": 16/9
 * }
 * ```
 */
export interface ImageCropStyle {
  /** The crop type. */
  type: ImageCropStyle_ImageCropType;
  /**
   * The aspect ratio to use if the crop type is `RECTANGLE_CUSTOM`.
   *
   * For example, here's how to apply a 16:9 aspect ratio:
   *
   * ```
   * cropStyle {
   *  "type": "RECTANGLE_CUSTOM",
   *  "aspectRatio": 16/9
   * }
   * ```
   */
  aspectRatio: number;
}

/**
 * Represents the crop style applied to an image.
 *
 * [Google Workspace Add-ons
 * and Chat apps](https://developers.google.com/workspace/extend):
 */
export enum ImageCropStyle_ImageCropType {
  /** IMAGE_CROP_TYPE_UNSPECIFIED - Don't use. Unspecified. */
  IMAGE_CROP_TYPE_UNSPECIFIED = 0,
  /** SQUARE - Default value. Applies a square crop. */
  SQUARE = 1,
  /** CIRCLE - Applies a circular crop. */
  CIRCLE = 2,
  /**
   * RECTANGLE_CUSTOM - Applies a rectangular crop with a custom aspect ratio. Set the custom
   * aspect ratio with `aspectRatio`.
   */
  RECTANGLE_CUSTOM = 3,
  /** RECTANGLE_4_3 - Applies a rectangular crop with a 4:3 aspect ratio. */
  RECTANGLE_4_3 = 4,
  UNRECOGNIZED = -1,
}

export function imageCropStyle_ImageCropTypeFromJSON(object: any): ImageCropStyle_ImageCropType {
  switch (object) {
    case 0:
    case "IMAGE_CROP_TYPE_UNSPECIFIED":
      return ImageCropStyle_ImageCropType.IMAGE_CROP_TYPE_UNSPECIFIED;
    case 1:
    case "SQUARE":
      return ImageCropStyle_ImageCropType.SQUARE;
    case 2:
    case "CIRCLE":
      return ImageCropStyle_ImageCropType.CIRCLE;
    case 3:
    case "RECTANGLE_CUSTOM":
      return ImageCropStyle_ImageCropType.RECTANGLE_CUSTOM;
    case 4:
    case "RECTANGLE_4_3":
      return ImageCropStyle_ImageCropType.RECTANGLE_4_3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageCropStyle_ImageCropType.UNRECOGNIZED;
  }
}

export function imageCropStyle_ImageCropTypeToJSON(object: ImageCropStyle_ImageCropType): string {
  switch (object) {
    case ImageCropStyle_ImageCropType.IMAGE_CROP_TYPE_UNSPECIFIED:
      return "IMAGE_CROP_TYPE_UNSPECIFIED";
    case ImageCropStyle_ImageCropType.SQUARE:
      return "SQUARE";
    case ImageCropStyle_ImageCropType.CIRCLE:
      return "CIRCLE";
    case ImageCropStyle_ImageCropType.RECTANGLE_CUSTOM:
      return "RECTANGLE_CUSTOM";
    case ImageCropStyle_ImageCropType.RECTANGLE_4_3:
      return "RECTANGLE_4_3";
    case ImageCropStyle_ImageCropType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The style options for the border of a card or widget, including the border
 * type and color.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface BorderStyle {
  /** The border type. */
  type: BorderStyle_BorderType;
  /** The colors to use when the type is `BORDER_TYPE_STROKE`. */
  strokeColor:
    | Color
    | undefined;
  /** The corner radius for the border. */
  cornerRadius: number;
}

/**
 * Represents the border types applied to widgets.
 *
 * [Google Workspace Add-ons
 * and Chat apps](https://developers.google.com/workspace/extend):
 */
export enum BorderStyle_BorderType {
  /** BORDER_TYPE_UNSPECIFIED - Don't use. Unspecified. */
  BORDER_TYPE_UNSPECIFIED = 0,
  /** NO_BORDER - Default value. No border. */
  NO_BORDER = 1,
  /** STROKE - Outline. */
  STROKE = 2,
  UNRECOGNIZED = -1,
}

export function borderStyle_BorderTypeFromJSON(object: any): BorderStyle_BorderType {
  switch (object) {
    case 0:
    case "BORDER_TYPE_UNSPECIFIED":
      return BorderStyle_BorderType.BORDER_TYPE_UNSPECIFIED;
    case 1:
    case "NO_BORDER":
      return BorderStyle_BorderType.NO_BORDER;
    case 2:
    case "STROKE":
      return BorderStyle_BorderType.STROKE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BorderStyle_BorderType.UNRECOGNIZED;
  }
}

export function borderStyle_BorderTypeToJSON(object: BorderStyle_BorderType): string {
  switch (object) {
    case BorderStyle_BorderType.BORDER_TYPE_UNSPECIFIED:
      return "BORDER_TYPE_UNSPECIFIED";
    case BorderStyle_BorderType.NO_BORDER:
      return "NO_BORDER";
    case BorderStyle_BorderType.STROKE:
      return "STROKE";
    case BorderStyle_BorderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents an image.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface ImageComponent {
  /** The image URL. */
  imageUri: string;
  /** The accessibility label for the image. */
  altText: string;
  /** The crop style to apply to the image. */
  cropStyle:
    | ImageCropStyle
    | undefined;
  /** The border style to apply to the image. */
  borderStyle: BorderStyle | undefined;
}

/**
 * Displays a grid with a collection of items. Items can only include text or
 * images. For responsive columns, or to include more than text or images, use
 * [`Columns`][google.apps.card.v1.Columns]. For an example in Google Chat apps,
 * see [Display a Grid with a collection of
 * items](https://developers.google.com/workspace/chat/format-structure-card-dialog#display_a_grid_with_a_collection_of_items).
 *
 * A grid supports any number of columns and items. The number of rows is
 * determined by items divided by columns. A grid with
 * 10 items and 2 columns has 5 rows. A grid with 11 items and 2 columns
 * has 6 rows.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 *
 * For example, the following JSON creates a 2 column grid with a single
 * item:
 *
 * ```
 * "grid": {
 *   "title": "A fine collection of items",
 *   "columnCount": 2,
 *   "borderStyle": {
 *     "type": "STROKE",
 *     "cornerRadius": 4
 *   },
 *   "items": [
 *     {
 *       "image": {
 *         "imageUri": "https://www.example.com/image.png",
 *         "cropStyle": {
 *           "type": "SQUARE"
 *         },
 *         "borderStyle": {
 *           "type": "STROKE"
 *         }
 *       },
 *       "title": "An item",
 *       "textAlignment": "CENTER"
 *     }
 *   ],
 *   "onClick": {
 *     "openLink": {
 *       "url": "https://www.example.com"
 *     }
 *   }
 * }
 * ```
 */
export interface Grid {
  /** The text that displays in the grid header. */
  title: string;
  /** The items to display in the grid. */
  items: Grid_GridItem[];
  /** The border style to apply to each grid item. */
  borderStyle:
    | BorderStyle
    | undefined;
  /**
   * The number of columns to display in the grid. A default value
   * is used if this field isn't specified, and that default value is
   * different depending on where the grid is shown (dialog versus companion).
   */
  columnCount: number;
  /**
   * This callback is reused by each individual grid item, but with the
   * item's identifier and index in the items list added to the callback's
   * parameters.
   */
  onClick: OnClick | undefined;
}

/**
 * Represents an item in a grid layout. Items can contain text, an image, or
 * both text and an image.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Grid_GridItem {
  /**
   * A user-specified identifier for this grid item. This identifier is
   * returned in the parent grid's `onClick` callback parameters.
   */
  id: string;
  /** The image that displays in the grid item. */
  image:
    | ImageComponent
    | undefined;
  /** The grid item's title. */
  title: string;
  /** The grid item's subtitle. */
  subtitle: string;
  /** The layout to use for the grid item. */
  layout: Grid_GridItem_GridItemLayout;
}

/**
 * Represents the various layout options available for a grid item.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum Grid_GridItem_GridItemLayout {
  /** GRID_ITEM_LAYOUT_UNSPECIFIED - Don't use. Unspecified. */
  GRID_ITEM_LAYOUT_UNSPECIFIED = 0,
  /** TEXT_BELOW - The title and subtitle are shown below the grid item's image. */
  TEXT_BELOW = 1,
  /** TEXT_ABOVE - The title and subtitle are shown above the grid item's image. */
  TEXT_ABOVE = 2,
  UNRECOGNIZED = -1,
}

export function grid_GridItem_GridItemLayoutFromJSON(object: any): Grid_GridItem_GridItemLayout {
  switch (object) {
    case 0:
    case "GRID_ITEM_LAYOUT_UNSPECIFIED":
      return Grid_GridItem_GridItemLayout.GRID_ITEM_LAYOUT_UNSPECIFIED;
    case 1:
    case "TEXT_BELOW":
      return Grid_GridItem_GridItemLayout.TEXT_BELOW;
    case 2:
    case "TEXT_ABOVE":
      return Grid_GridItem_GridItemLayout.TEXT_ABOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Grid_GridItem_GridItemLayout.UNRECOGNIZED;
  }
}

export function grid_GridItem_GridItemLayoutToJSON(object: Grid_GridItem_GridItemLayout): string {
  switch (object) {
    case Grid_GridItem_GridItemLayout.GRID_ITEM_LAYOUT_UNSPECIFIED:
      return "GRID_ITEM_LAYOUT_UNSPECIFIED";
    case Grid_GridItem_GridItemLayout.TEXT_BELOW:
      return "TEXT_BELOW";
    case Grid_GridItem_GridItemLayout.TEXT_ABOVE:
      return "TEXT_ABOVE";
    case Grid_GridItem_GridItemLayout.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The `Columns` widget displays up to 2 columns in a card or dialog. You can
 * add widgets to each column; the widgets appear in the order that they are
 * specified. For an example in Google Chat apps, see
 * [Display cards and dialogs in
 * columns](https://developers.google.com/workspace/chat/format-structure-card-dialog#display_cards_and_dialogs_in_columns).
 *
 * The height of each column is determined by the taller column. For example, if
 * the first column is taller than the second column, both columns have the
 * height of the first column. Because each column can contain a different
 * number of widgets, you can't define rows or align widgets between the
 * columns.
 *
 * Columns are displayed side-by-side. You can customize the width of each
 * column using the `HorizontalSizeStyle` field. If the user's
 * screen width is too narrow, the second column wraps below the first:
 *
 * * On web, the second column wraps if the screen width is less than or equal
 *   to 480 pixels.
 * * On iOS devices, the second column wraps if the screen width is
 *   less than or equal to 300 pt.
 * * On Android devices, the second column wraps if the screen width is
 *   less than or equal to 320 dp.
 *
 * To include more than 2 columns, or to use rows, use the
 * [`Grid`][google.apps.card.v1.Grid] widget.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 * Columns for Google Workspace Add-ons are in
 * Developer Preview.
 */
export interface Columns {
  /** An array of columns. You can include up to 2 columns in a card or dialog. */
  columnItems: Columns_Column[];
}

/**
 * A column.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 * Columns for Google Workspace Add-ons are in
 * Developer Preview.
 */
export interface Columns_Column {
  /** Specifies how a column fills the width of the card. */
  horizontalSizeStyle: Columns_Column_HorizontalSizeStyle;
  /**
   * Specifies whether widgets align to the left, right, or center of a
   * column.
   */
  horizontalAlignment: Widget_HorizontalAlignment;
  /**
   * Specifies whether widgets align to the top, bottom, or center of a
   * column.
   */
  verticalAlignment: Columns_Column_VerticalAlignment;
  /**
   * An array of widgets included in a column. Widgets appear in the order
   * that they are specified.
   */
  widgets: Columns_Column_Widgets[];
}

/**
 * Specifies how a column fills the width of the card. The width of each
 * column depends on both the `HorizontalSizeStyle` and the width of the
 * widgets within the column.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 * Columns for Google Workspace Add-ons are in
 * Developer Preview.
 */
export enum Columns_Column_HorizontalSizeStyle {
  /** HORIZONTAL_SIZE_STYLE_UNSPECIFIED - Don't use. Unspecified. */
  HORIZONTAL_SIZE_STYLE_UNSPECIFIED = 0,
  /**
   * FILL_AVAILABLE_SPACE - Default value. Column fills the available space, up to 70% of the
   * card's width. If both columns are set to `FILL_AVAILABLE_SPACE`, each
   * column fills 50% of the space.
   */
  FILL_AVAILABLE_SPACE = 1,
  /**
   * FILL_MINIMUM_SPACE - Column fills the least amount of space possible and no more than 30% of
   * the card's width.
   */
  FILL_MINIMUM_SPACE = 2,
  UNRECOGNIZED = -1,
}

export function columns_Column_HorizontalSizeStyleFromJSON(object: any): Columns_Column_HorizontalSizeStyle {
  switch (object) {
    case 0:
    case "HORIZONTAL_SIZE_STYLE_UNSPECIFIED":
      return Columns_Column_HorizontalSizeStyle.HORIZONTAL_SIZE_STYLE_UNSPECIFIED;
    case 1:
    case "FILL_AVAILABLE_SPACE":
      return Columns_Column_HorizontalSizeStyle.FILL_AVAILABLE_SPACE;
    case 2:
    case "FILL_MINIMUM_SPACE":
      return Columns_Column_HorizontalSizeStyle.FILL_MINIMUM_SPACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Columns_Column_HorizontalSizeStyle.UNRECOGNIZED;
  }
}

export function columns_Column_HorizontalSizeStyleToJSON(object: Columns_Column_HorizontalSizeStyle): string {
  switch (object) {
    case Columns_Column_HorizontalSizeStyle.HORIZONTAL_SIZE_STYLE_UNSPECIFIED:
      return "HORIZONTAL_SIZE_STYLE_UNSPECIFIED";
    case Columns_Column_HorizontalSizeStyle.FILL_AVAILABLE_SPACE:
      return "FILL_AVAILABLE_SPACE";
    case Columns_Column_HorizontalSizeStyle.FILL_MINIMUM_SPACE:
      return "FILL_MINIMUM_SPACE";
    case Columns_Column_HorizontalSizeStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies whether widgets align to the top, bottom, or center of a
 * column.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 * Columns for Google Workspace Add-ons are in
 * Developer Preview.
 */
export enum Columns_Column_VerticalAlignment {
  /** VERTICAL_ALIGNMENT_UNSPECIFIED - Don't use. Unspecified. */
  VERTICAL_ALIGNMENT_UNSPECIFIED = 0,
  /** CENTER - Default value. Aligns widgets to the center of a column. */
  CENTER = 1,
  /** TOP - Aligns widgets to the top of a column. */
  TOP = 2,
  /** BOTTOM - Aligns widgets to the bottom of a column. */
  BOTTOM = 3,
  UNRECOGNIZED = -1,
}

export function columns_Column_VerticalAlignmentFromJSON(object: any): Columns_Column_VerticalAlignment {
  switch (object) {
    case 0:
    case "VERTICAL_ALIGNMENT_UNSPECIFIED":
      return Columns_Column_VerticalAlignment.VERTICAL_ALIGNMENT_UNSPECIFIED;
    case 1:
    case "CENTER":
      return Columns_Column_VerticalAlignment.CENTER;
    case 2:
    case "TOP":
      return Columns_Column_VerticalAlignment.TOP;
    case 3:
    case "BOTTOM":
      return Columns_Column_VerticalAlignment.BOTTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Columns_Column_VerticalAlignment.UNRECOGNIZED;
  }
}

export function columns_Column_VerticalAlignmentToJSON(object: Columns_Column_VerticalAlignment): string {
  switch (object) {
    case Columns_Column_VerticalAlignment.VERTICAL_ALIGNMENT_UNSPECIFIED:
      return "VERTICAL_ALIGNMENT_UNSPECIFIED";
    case Columns_Column_VerticalAlignment.CENTER:
      return "CENTER";
    case Columns_Column_VerticalAlignment.TOP:
      return "TOP";
    case Columns_Column_VerticalAlignment.BOTTOM:
      return "BOTTOM";
    case Columns_Column_VerticalAlignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The supported widgets that you can include in a column.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 * Columns for Google Workspace Add-ons are in
 * Developer Preview.
 */
export interface Columns_Column_Widgets {
  /** [TextParagraph][google.apps.card.v1.TextParagraph] widget. */
  textParagraph?:
    | TextParagraph
    | undefined;
  /** [Image][google.apps.card.v1.Image] widget. */
  image?:
    | Image
    | undefined;
  /** [DecoratedText][google.apps.card.v1.DecoratedText] widget. */
  decoratedText?:
    | DecoratedText
    | undefined;
  /** [ButtonList][google.apps.card.v1.ButtonList] widget. */
  buttonList?:
    | ButtonList
    | undefined;
  /** [TextInput][google.apps.card.v1.TextInput] widget. */
  textInput?:
    | TextInput
    | undefined;
  /** [SelectionInput][google.apps.card.v1.SelectionInput] widget. */
  selectionInput?:
    | SelectionInput
    | undefined;
  /** [DateTimePicker][google.apps.card.v1.DateTimePicker] widget. */
  dateTimePicker?: DateTimePicker | undefined;
}

/**
 * Represents how to respond when users click an interactive element on
 * a card, such as a button.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface OnClick {
  /** If specified, an action is triggered by this `onClick`. */
  action?:
    | Action
    | undefined;
  /** If specified, this `onClick` triggers an open link action. */
  openLink?:
    | OpenLink
    | undefined;
  /**
   * An add-on triggers this action when the action needs to open a
   * link. This differs from the `open_link` above in that this needs to talk
   * to server to get the link. Thus some preparation work is required for
   * web client to do before the open link action response comes back.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  openDynamicLinkAction?:
    | Action
    | undefined;
  /**
   * A new card is pushed to the card stack after clicking if specified.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  card?: Card | undefined;
}

/**
 * Represents an `onClick` event that opens a hyperlink.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface OpenLink {
  /** The URL to open. */
  url: string;
  /**
   * How to open a link.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  openAs: OpenLink_OpenAs;
  /**
   * Whether the client forgets about a link after opening it, or observes it
   * until the window closes.
   *
   * [Google Workspace
   * Add-ons](https://developers.google.com/workspace/add-ons):
   */
  onClose: OpenLink_OnClose;
}

/**
 * When an `OnClick` action opens a link, then the client can either open it
 * as a full-size window (if that's the frame used by the client), or an
 * overlay (such as a pop-up). The implementation depends on the client
 * platform capabilities, and the value selected might be ignored if the
 * client doesn't support it. `FULL_SIZE` is supported by all clients.
 *
 * [Google Workspace
 * Add-ons](https://developers.google.com/workspace/add-ons):
 */
export enum OpenLink_OpenAs {
  /**
   * FULL_SIZE - The link opens as a full-size window (if that's the frame used by the
   * client).
   */
  FULL_SIZE = 0,
  /** OVERLAY - The link opens as an overlay, such as a pop-up. */
  OVERLAY = 1,
  UNRECOGNIZED = -1,
}

export function openLink_OpenAsFromJSON(object: any): OpenLink_OpenAs {
  switch (object) {
    case 0:
    case "FULL_SIZE":
      return OpenLink_OpenAs.FULL_SIZE;
    case 1:
    case "OVERLAY":
      return OpenLink_OpenAs.OVERLAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpenLink_OpenAs.UNRECOGNIZED;
  }
}

export function openLink_OpenAsToJSON(object: OpenLink_OpenAs): string {
  switch (object) {
    case OpenLink_OpenAs.FULL_SIZE:
      return "FULL_SIZE";
    case OpenLink_OpenAs.OVERLAY:
      return "OVERLAY";
    case OpenLink_OpenAs.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * What the client does when a link opened by an `OnClick` action is closed.
 *
 * Implementation depends on client platform capabilities. For example, a web
 * browser might open a link in a pop-up window with an `OnClose` handler.
 *
 * If both `OnOpen` and `OnClose` handlers are set, and the client platform
 * can't support both values, `OnClose` takes precedence.
 *
 * [Google Workspace
 * Add-ons](https://developers.google.com/workspace/add-ons):
 */
export enum OpenLink_OnClose {
  /** NOTHING - Default value. The card doesn't reload; nothing happens. */
  NOTHING = 0,
  /**
   * RELOAD - Reloads the card after the child window closes.
   *
   * If used in conjunction with
   * [`OpenAs.OVERLAY`](https://developers.google.com/workspace/add-ons/reference/rpc/google.apps.card.v1#openas),
   * the child window acts as a modal dialog and the parent card is blocked
   * until the child window closes.
   */
  RELOAD = 1,
  UNRECOGNIZED = -1,
}

export function openLink_OnCloseFromJSON(object: any): OpenLink_OnClose {
  switch (object) {
    case 0:
    case "NOTHING":
      return OpenLink_OnClose.NOTHING;
    case 1:
    case "RELOAD":
      return OpenLink_OnClose.RELOAD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpenLink_OnClose.UNRECOGNIZED;
  }
}

export function openLink_OnCloseToJSON(object: OpenLink_OnClose): string {
  switch (object) {
    case OpenLink_OnClose.NOTHING:
      return "NOTHING";
    case OpenLink_OnClose.RELOAD:
      return "RELOAD";
    case OpenLink_OnClose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An action that describes the behavior when the form is submitted.
 * For example, you can invoke an Apps Script script to handle the form.
 * If the action is triggered, the form values are sent to the server.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Action {
  /**
   * A custom function to invoke when the containing element is
   * clicked or othrwise activated.
   *
   * For example usage, see [Read form
   * data](https://developers.google.com/workspace/chat/read-form-data).
   */
  function: string;
  /** List of action parameters. */
  parameters: Action_ActionParameter[];
  /**
   * Specifies the loading indicator that the action displays while
   * making the call to the action.
   */
  loadIndicator: Action_LoadIndicator;
  /**
   * Indicates whether form values persist after the action. The default value
   * is `false`.
   *
   * If `true`, form values remain after the action is triggered. To let the
   * user make changes while the action is being processed, set
   * [`LoadIndicator`](https://developers.google.com/workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator)
   * to `NONE`. For [card
   * messages](https://developers.google.com/workspace/chat/api/guides/v1/messages/create#create)
   * in Chat apps, you must also set the action's
   * [`ResponseType`](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces.messages#responsetype)
   * to `UPDATE_MESSAGE` and use the same
   * [`card_id`](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces.messages#CardWithId)
   * from the card that contained the action.
   *
   * If `false`, the form values are cleared when the action is triggered.
   * To prevent the user from making changes while the action is being
   * processed, set
   * [`LoadIndicator`](https://developers.google.com/workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator)
   * to `SPINNER`.
   */
  persistValues: boolean;
  /**
   * Optional. Required when opening a
   * [dialog](https://developers.google.com/workspace/chat/dialogs).
   *
   * What to do in response to an interaction with a user, such as a user
   * clicking a button in a card message.
   *
   * If unspecified, the app responds by executing an `action`—like opening a
   * link or running a function—as normal.
   *
   * By specifying an `interaction`, the app can respond in special interactive
   * ways. For example, by setting `interaction` to `OPEN_DIALOG`, the app can
   * open a [dialog](https://developers.google.com/workspace/chat/dialogs). When
   * specified, a loading indicator isn't shown. If specified for
   * an add-on, the entire card is stripped and nothing is shown in the client.
   *
   * [Google Chat apps](https://developers.google.com/workspace/chat):
   */
  interaction: Action_Interaction;
}

/**
 * Specifies the loading indicator that the action displays while
 * making the call to the action.
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export enum Action_LoadIndicator {
  /** SPINNER - Displays a spinner to indicate that content is loading. */
  SPINNER = 0,
  /** NONE - Nothing is displayed. */
  NONE = 1,
  UNRECOGNIZED = -1,
}

export function action_LoadIndicatorFromJSON(object: any): Action_LoadIndicator {
  switch (object) {
    case 0:
    case "SPINNER":
      return Action_LoadIndicator.SPINNER;
    case 1:
    case "NONE":
      return Action_LoadIndicator.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Action_LoadIndicator.UNRECOGNIZED;
  }
}

export function action_LoadIndicatorToJSON(object: Action_LoadIndicator): string {
  switch (object) {
    case Action_LoadIndicator.SPINNER:
      return "SPINNER";
    case Action_LoadIndicator.NONE:
      return "NONE";
    case Action_LoadIndicator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Optional. Required when opening a
 * [dialog](https://developers.google.com/workspace/chat/dialogs).
 *
 * What to do in response to an interaction with a user, such as a user
 * clicking a button in a card message.
 *
 * If unspecified, the app responds by executing an `action`—like opening a
 * link or running a function—as normal.
 *
 * By specifying an `interaction`, the app can respond in special interactive
 * ways. For example, by setting `interaction` to `OPEN_DIALOG`, the app can
 * open a [dialog](https://developers.google.com/workspace/chat/dialogs).
 *
 * When specified, a loading indicator isn't shown. If specified for
 * an add-on, the entire card is stripped and nothing is shown in the client.
 *
 * [Google Chat apps](https://developers.google.com/workspace/chat):
 */
export enum Action_Interaction {
  /** INTERACTION_UNSPECIFIED - Default value. The `action` executes as normal. */
  INTERACTION_UNSPECIFIED = 0,
  /**
   * OPEN_DIALOG - Opens a [dialog](https://developers.google.com/workspace/chat/dialogs), a
   * windowed, card-based interface that Chat apps use to interact with users.
   *
   * Only supported by Chat apps in response to button-clicks on card
   * messages. If specified for
   * an add-on, the entire card is stripped and nothing is shown in the
   * client.
   *
   * [Google Chat apps](https://developers.google.com/workspace/chat):
   */
  OPEN_DIALOG = 1,
  UNRECOGNIZED = -1,
}

export function action_InteractionFromJSON(object: any): Action_Interaction {
  switch (object) {
    case 0:
    case "INTERACTION_UNSPECIFIED":
      return Action_Interaction.INTERACTION_UNSPECIFIED;
    case 1:
    case "OPEN_DIALOG":
      return Action_Interaction.OPEN_DIALOG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Action_Interaction.UNRECOGNIZED;
  }
}

export function action_InteractionToJSON(object: Action_Interaction): string {
  switch (object) {
    case Action_Interaction.INTERACTION_UNSPECIFIED:
      return "INTERACTION_UNSPECIFIED";
    case Action_Interaction.OPEN_DIALOG:
      return "OPEN_DIALOG";
    case Action_Interaction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * List of string parameters to supply when the action method is invoked.
 * For example, consider three snooze buttons: snooze now, snooze one day,
 * or snooze next week. You might use `action method = snooze()`, passing the
 * snooze type and snooze time in the list of string parameters.
 *
 * To learn more, see
 * [`CommonEventObject`](https://developers.google.com/workspace/chat/api/reference/rest/v1/Event#commoneventobject).
 *
 * [Google Workspace Add-ons and Chat
 * apps](https://developers.google.com/workspace/extend):
 */
export interface Action_ActionParameter {
  /** The name of the parameter for the action script. */
  key: string;
  /** The value of the parameter. */
  value: string;
}

function createBaseCard(): Card {
  return {
    header: undefined,
    sections: [],
    sectionDividerStyle: 0,
    cardActions: [],
    name: "",
    fixedFooter: undefined,
    displayStyle: 0,
    peekCardHeader: undefined,
  };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      Card_CardHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.sections) {
      Card_Section.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.sectionDividerStyle !== 0) {
      writer.uint32(72).int32(message.sectionDividerStyle);
    }
    for (const v of message.cardActions) {
      Card_CardAction.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.fixedFooter !== undefined) {
      Card_CardFixedFooter.encode(message.fixedFooter, writer.uint32(42).fork()).join();
    }
    if (message.displayStyle !== 0) {
      writer.uint32(48).int32(message.displayStyle);
    }
    if (message.peekCardHeader !== undefined) {
      Card_CardHeader.encode(message.peekCardHeader, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = Card_CardHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sections.push(Card_Section.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sectionDividerStyle = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cardActions.push(Card_CardAction.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fixedFooter = Card_CardFixedFooter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.displayStyle = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.peekCardHeader = Card_CardHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      header: isSet(object.header) ? Card_CardHeader.fromJSON(object.header) : undefined,
      sections: globalThis.Array.isArray(object?.sections)
        ? object.sections.map((e: any) => Card_Section.fromJSON(e))
        : [],
      sectionDividerStyle: isSet(object.sectionDividerStyle)
        ? card_DividerStyleFromJSON(object.sectionDividerStyle)
        : 0,
      cardActions: globalThis.Array.isArray(object?.cardActions)
        ? object.cardActions.map((e: any) => Card_CardAction.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fixedFooter: isSet(object.fixedFooter) ? Card_CardFixedFooter.fromJSON(object.fixedFooter) : undefined,
      displayStyle: isSet(object.displayStyle) ? card_DisplayStyleFromJSON(object.displayStyle) : 0,
      peekCardHeader: isSet(object.peekCardHeader) ? Card_CardHeader.fromJSON(object.peekCardHeader) : undefined,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = Card_CardHeader.toJSON(message.header);
    }
    if (message.sections?.length) {
      obj.sections = message.sections.map((e) => Card_Section.toJSON(e));
    }
    if (message.sectionDividerStyle !== 0) {
      obj.sectionDividerStyle = card_DividerStyleToJSON(message.sectionDividerStyle);
    }
    if (message.cardActions?.length) {
      obj.cardActions = message.cardActions.map((e) => Card_CardAction.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fixedFooter !== undefined) {
      obj.fixedFooter = Card_CardFixedFooter.toJSON(message.fixedFooter);
    }
    if (message.displayStyle !== 0) {
      obj.displayStyle = card_DisplayStyleToJSON(message.displayStyle);
    }
    if (message.peekCardHeader !== undefined) {
      obj.peekCardHeader = Card_CardHeader.toJSON(message.peekCardHeader);
    }
    return obj;
  },

  create(base?: DeepPartial<Card>): Card {
    return Card.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card>): Card {
    const message = createBaseCard();
    message.header = (object.header !== undefined && object.header !== null)
      ? Card_CardHeader.fromPartial(object.header)
      : undefined;
    message.sections = object.sections?.map((e) => Card_Section.fromPartial(e)) || [];
    message.sectionDividerStyle = object.sectionDividerStyle ?? 0;
    message.cardActions = object.cardActions?.map((e) => Card_CardAction.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.fixedFooter = (object.fixedFooter !== undefined && object.fixedFooter !== null)
      ? Card_CardFixedFooter.fromPartial(object.fixedFooter)
      : undefined;
    message.displayStyle = object.displayStyle ?? 0;
    message.peekCardHeader = (object.peekCardHeader !== undefined && object.peekCardHeader !== null)
      ? Card_CardHeader.fromPartial(object.peekCardHeader)
      : undefined;
    return message;
  },
};

function createBaseCard_CardHeader(): Card_CardHeader {
  return { title: "", subtitle: "", imageType: 0, imageUrl: "", imageAltText: "" };
}

export const Card_CardHeader: MessageFns<Card_CardHeader> = {
  encode(message: Card_CardHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.subtitle !== "") {
      writer.uint32(18).string(message.subtitle);
    }
    if (message.imageType !== 0) {
      writer.uint32(24).int32(message.imageType);
    }
    if (message.imageUrl !== "") {
      writer.uint32(34).string(message.imageUrl);
    }
    if (message.imageAltText !== "") {
      writer.uint32(42).string(message.imageAltText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card_CardHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard_CardHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subtitle = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.imageType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageAltText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card_CardHeader {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      subtitle: isSet(object.subtitle) ? globalThis.String(object.subtitle) : "",
      imageType: isSet(object.imageType) ? widget_ImageTypeFromJSON(object.imageType) : 0,
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      imageAltText: isSet(object.imageAltText) ? globalThis.String(object.imageAltText) : "",
    };
  },

  toJSON(message: Card_CardHeader): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.subtitle !== "") {
      obj.subtitle = message.subtitle;
    }
    if (message.imageType !== 0) {
      obj.imageType = widget_ImageTypeToJSON(message.imageType);
    }
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.imageAltText !== "") {
      obj.imageAltText = message.imageAltText;
    }
    return obj;
  },

  create(base?: DeepPartial<Card_CardHeader>): Card_CardHeader {
    return Card_CardHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card_CardHeader>): Card_CardHeader {
    const message = createBaseCard_CardHeader();
    message.title = object.title ?? "";
    message.subtitle = object.subtitle ?? "";
    message.imageType = object.imageType ?? 0;
    message.imageUrl = object.imageUrl ?? "";
    message.imageAltText = object.imageAltText ?? "";
    return message;
  },
};

function createBaseCard_Section(): Card_Section {
  return { header: "", widgets: [], collapsible: false, uncollapsibleWidgetsCount: 0 };
}

export const Card_Section: MessageFns<Card_Section> = {
  encode(message: Card_Section, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    for (const v of message.widgets) {
      Widget.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.collapsible !== false) {
      writer.uint32(40).bool(message.collapsible);
    }
    if (message.uncollapsibleWidgetsCount !== 0) {
      writer.uint32(48).int32(message.uncollapsibleWidgetsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card_Section {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard_Section();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.widgets.push(Widget.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.collapsible = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.uncollapsibleWidgetsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card_Section {
    return {
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      widgets: globalThis.Array.isArray(object?.widgets) ? object.widgets.map((e: any) => Widget.fromJSON(e)) : [],
      collapsible: isSet(object.collapsible) ? globalThis.Boolean(object.collapsible) : false,
      uncollapsibleWidgetsCount: isSet(object.uncollapsibleWidgetsCount)
        ? globalThis.Number(object.uncollapsibleWidgetsCount)
        : 0,
    };
  },

  toJSON(message: Card_Section): unknown {
    const obj: any = {};
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.widgets?.length) {
      obj.widgets = message.widgets.map((e) => Widget.toJSON(e));
    }
    if (message.collapsible !== false) {
      obj.collapsible = message.collapsible;
    }
    if (message.uncollapsibleWidgetsCount !== 0) {
      obj.uncollapsibleWidgetsCount = Math.round(message.uncollapsibleWidgetsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Card_Section>): Card_Section {
    return Card_Section.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card_Section>): Card_Section {
    const message = createBaseCard_Section();
    message.header = object.header ?? "";
    message.widgets = object.widgets?.map((e) => Widget.fromPartial(e)) || [];
    message.collapsible = object.collapsible ?? false;
    message.uncollapsibleWidgetsCount = object.uncollapsibleWidgetsCount ?? 0;
    return message;
  },
};

function createBaseCard_CardAction(): Card_CardAction {
  return { actionLabel: "", onClick: undefined };
}

export const Card_CardAction: MessageFns<Card_CardAction> = {
  encode(message: Card_CardAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionLabel !== "") {
      writer.uint32(10).string(message.actionLabel);
    }
    if (message.onClick !== undefined) {
      OnClick.encode(message.onClick, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card_CardAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard_CardAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionLabel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.onClick = OnClick.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card_CardAction {
    return {
      actionLabel: isSet(object.actionLabel) ? globalThis.String(object.actionLabel) : "",
      onClick: isSet(object.onClick) ? OnClick.fromJSON(object.onClick) : undefined,
    };
  },

  toJSON(message: Card_CardAction): unknown {
    const obj: any = {};
    if (message.actionLabel !== "") {
      obj.actionLabel = message.actionLabel;
    }
    if (message.onClick !== undefined) {
      obj.onClick = OnClick.toJSON(message.onClick);
    }
    return obj;
  },

  create(base?: DeepPartial<Card_CardAction>): Card_CardAction {
    return Card_CardAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card_CardAction>): Card_CardAction {
    const message = createBaseCard_CardAction();
    message.actionLabel = object.actionLabel ?? "";
    message.onClick = (object.onClick !== undefined && object.onClick !== null)
      ? OnClick.fromPartial(object.onClick)
      : undefined;
    return message;
  },
};

function createBaseCard_CardFixedFooter(): Card_CardFixedFooter {
  return { primaryButton: undefined, secondaryButton: undefined };
}

export const Card_CardFixedFooter: MessageFns<Card_CardFixedFooter> = {
  encode(message: Card_CardFixedFooter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryButton !== undefined) {
      Button.encode(message.primaryButton, writer.uint32(10).fork()).join();
    }
    if (message.secondaryButton !== undefined) {
      Button.encode(message.secondaryButton, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card_CardFixedFooter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard_CardFixedFooter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryButton = Button.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryButton = Button.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card_CardFixedFooter {
    return {
      primaryButton: isSet(object.primaryButton) ? Button.fromJSON(object.primaryButton) : undefined,
      secondaryButton: isSet(object.secondaryButton) ? Button.fromJSON(object.secondaryButton) : undefined,
    };
  },

  toJSON(message: Card_CardFixedFooter): unknown {
    const obj: any = {};
    if (message.primaryButton !== undefined) {
      obj.primaryButton = Button.toJSON(message.primaryButton);
    }
    if (message.secondaryButton !== undefined) {
      obj.secondaryButton = Button.toJSON(message.secondaryButton);
    }
    return obj;
  },

  create(base?: DeepPartial<Card_CardFixedFooter>): Card_CardFixedFooter {
    return Card_CardFixedFooter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Card_CardFixedFooter>): Card_CardFixedFooter {
    const message = createBaseCard_CardFixedFooter();
    message.primaryButton = (object.primaryButton !== undefined && object.primaryButton !== null)
      ? Button.fromPartial(object.primaryButton)
      : undefined;
    message.secondaryButton = (object.secondaryButton !== undefined && object.secondaryButton !== null)
      ? Button.fromPartial(object.secondaryButton)
      : undefined;
    return message;
  },
};

function createBaseWidget(): Widget {
  return {
    textParagraph: undefined,
    image: undefined,
    decoratedText: undefined,
    buttonList: undefined,
    textInput: undefined,
    selectionInput: undefined,
    dateTimePicker: undefined,
    divider: undefined,
    grid: undefined,
    columns: undefined,
    horizontalAlignment: 0,
  };
}

export const Widget: MessageFns<Widget> = {
  encode(message: Widget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textParagraph !== undefined) {
      TextParagraph.encode(message.textParagraph, writer.uint32(10).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.decoratedText !== undefined) {
      DecoratedText.encode(message.decoratedText, writer.uint32(26).fork()).join();
    }
    if (message.buttonList !== undefined) {
      ButtonList.encode(message.buttonList, writer.uint32(34).fork()).join();
    }
    if (message.textInput !== undefined) {
      TextInput.encode(message.textInput, writer.uint32(42).fork()).join();
    }
    if (message.selectionInput !== undefined) {
      SelectionInput.encode(message.selectionInput, writer.uint32(50).fork()).join();
    }
    if (message.dateTimePicker !== undefined) {
      DateTimePicker.encode(message.dateTimePicker, writer.uint32(58).fork()).join();
    }
    if (message.divider !== undefined) {
      Divider.encode(message.divider, writer.uint32(74).fork()).join();
    }
    if (message.grid !== undefined) {
      Grid.encode(message.grid, writer.uint32(82).fork()).join();
    }
    if (message.columns !== undefined) {
      Columns.encode(message.columns, writer.uint32(90).fork()).join();
    }
    if (message.horizontalAlignment !== 0) {
      writer.uint32(64).int32(message.horizontalAlignment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Widget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textParagraph = TextParagraph.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.decoratedText = DecoratedText.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.buttonList = ButtonList.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.selectionInput = SelectionInput.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dateTimePicker = DateTimePicker.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.divider = Divider.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.grid = Grid.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.columns = Columns.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.horizontalAlignment = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Widget {
    return {
      textParagraph: isSet(object.textParagraph) ? TextParagraph.fromJSON(object.textParagraph) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      decoratedText: isSet(object.decoratedText) ? DecoratedText.fromJSON(object.decoratedText) : undefined,
      buttonList: isSet(object.buttonList) ? ButtonList.fromJSON(object.buttonList) : undefined,
      textInput: isSet(object.textInput) ? TextInput.fromJSON(object.textInput) : undefined,
      selectionInput: isSet(object.selectionInput) ? SelectionInput.fromJSON(object.selectionInput) : undefined,
      dateTimePicker: isSet(object.dateTimePicker) ? DateTimePicker.fromJSON(object.dateTimePicker) : undefined,
      divider: isSet(object.divider) ? Divider.fromJSON(object.divider) : undefined,
      grid: isSet(object.grid) ? Grid.fromJSON(object.grid) : undefined,
      columns: isSet(object.columns) ? Columns.fromJSON(object.columns) : undefined,
      horizontalAlignment: isSet(object.horizontalAlignment)
        ? widget_HorizontalAlignmentFromJSON(object.horizontalAlignment)
        : 0,
    };
  },

  toJSON(message: Widget): unknown {
    const obj: any = {};
    if (message.textParagraph !== undefined) {
      obj.textParagraph = TextParagraph.toJSON(message.textParagraph);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.decoratedText !== undefined) {
      obj.decoratedText = DecoratedText.toJSON(message.decoratedText);
    }
    if (message.buttonList !== undefined) {
      obj.buttonList = ButtonList.toJSON(message.buttonList);
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInput.toJSON(message.textInput);
    }
    if (message.selectionInput !== undefined) {
      obj.selectionInput = SelectionInput.toJSON(message.selectionInput);
    }
    if (message.dateTimePicker !== undefined) {
      obj.dateTimePicker = DateTimePicker.toJSON(message.dateTimePicker);
    }
    if (message.divider !== undefined) {
      obj.divider = Divider.toJSON(message.divider);
    }
    if (message.grid !== undefined) {
      obj.grid = Grid.toJSON(message.grid);
    }
    if (message.columns !== undefined) {
      obj.columns = Columns.toJSON(message.columns);
    }
    if (message.horizontalAlignment !== 0) {
      obj.horizontalAlignment = widget_HorizontalAlignmentToJSON(message.horizontalAlignment);
    }
    return obj;
  },

  create(base?: DeepPartial<Widget>): Widget {
    return Widget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Widget>): Widget {
    const message = createBaseWidget();
    message.textParagraph = (object.textParagraph !== undefined && object.textParagraph !== null)
      ? TextParagraph.fromPartial(object.textParagraph)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.decoratedText = (object.decoratedText !== undefined && object.decoratedText !== null)
      ? DecoratedText.fromPartial(object.decoratedText)
      : undefined;
    message.buttonList = (object.buttonList !== undefined && object.buttonList !== null)
      ? ButtonList.fromPartial(object.buttonList)
      : undefined;
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInput.fromPartial(object.textInput)
      : undefined;
    message.selectionInput = (object.selectionInput !== undefined && object.selectionInput !== null)
      ? SelectionInput.fromPartial(object.selectionInput)
      : undefined;
    message.dateTimePicker = (object.dateTimePicker !== undefined && object.dateTimePicker !== null)
      ? DateTimePicker.fromPartial(object.dateTimePicker)
      : undefined;
    message.divider = (object.divider !== undefined && object.divider !== null)
      ? Divider.fromPartial(object.divider)
      : undefined;
    message.grid = (object.grid !== undefined && object.grid !== null) ? Grid.fromPartial(object.grid) : undefined;
    message.columns = (object.columns !== undefined && object.columns !== null)
      ? Columns.fromPartial(object.columns)
      : undefined;
    message.horizontalAlignment = object.horizontalAlignment ?? 0;
    return message;
  },
};

function createBaseTextParagraph(): TextParagraph {
  return { text: "" };
}

export const TextParagraph: MessageFns<TextParagraph> = {
  encode(message: TextParagraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextParagraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextParagraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextParagraph {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextParagraph): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<TextParagraph>): TextParagraph {
    return TextParagraph.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextParagraph>): TextParagraph {
    const message = createBaseTextParagraph();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseImage(): Image {
  return { imageUrl: "", onClick: undefined, altText: "" };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    if (message.onClick !== undefined) {
      OnClick.encode(message.onClick, writer.uint32(18).fork()).join();
    }
    if (message.altText !== "") {
      writer.uint32(26).string(message.altText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.onClick = OnClick.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.altText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      onClick: isSet(object.onClick) ? OnClick.fromJSON(object.onClick) : undefined,
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.onClick !== undefined) {
      obj.onClick = OnClick.toJSON(message.onClick);
    }
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    return obj;
  },

  create(base?: DeepPartial<Image>): Image {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Image>): Image {
    const message = createBaseImage();
    message.imageUrl = object.imageUrl ?? "";
    message.onClick = (object.onClick !== undefined && object.onClick !== null)
      ? OnClick.fromPartial(object.onClick)
      : undefined;
    message.altText = object.altText ?? "";
    return message;
  },
};

function createBaseDivider(): Divider {
  return {};
}

export const Divider: MessageFns<Divider> = {
  encode(_: Divider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Divider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDivider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Divider {
    return {};
  },

  toJSON(_: Divider): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Divider>): Divider {
    return Divider.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Divider>): Divider {
    const message = createBaseDivider();
    return message;
  },
};

function createBaseDecoratedText(): DecoratedText {
  return {
    icon: undefined,
    startIcon: undefined,
    topLabel: "",
    text: "",
    wrapText: false,
    bottomLabel: "",
    onClick: undefined,
    button: undefined,
    switchControl: undefined,
    endIcon: undefined,
  };
}

export const DecoratedText: MessageFns<DecoratedText> = {
  encode(message: DecoratedText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Icon.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.startIcon !== undefined) {
      Icon.encode(message.startIcon, writer.uint32(98).fork()).join();
    }
    if (message.topLabel !== "") {
      writer.uint32(26).string(message.topLabel);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.wrapText !== false) {
      writer.uint32(40).bool(message.wrapText);
    }
    if (message.bottomLabel !== "") {
      writer.uint32(50).string(message.bottomLabel);
    }
    if (message.onClick !== undefined) {
      OnClick.encode(message.onClick, writer.uint32(58).fork()).join();
    }
    if (message.button !== undefined) {
      Button.encode(message.button, writer.uint32(66).fork()).join();
    }
    if (message.switchControl !== undefined) {
      DecoratedText_SwitchControl.encode(message.switchControl, writer.uint32(74).fork()).join();
    }
    if (message.endIcon !== undefined) {
      Icon.encode(message.endIcon, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecoratedText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecoratedText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.icon = Icon.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.startIcon = Icon.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topLabel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.wrapText = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bottomLabel = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onClick = OnClick.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.button = Button.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.switchControl = DecoratedText_SwitchControl.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endIcon = Icon.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecoratedText {
    return {
      icon: isSet(object.icon) ? Icon.fromJSON(object.icon) : undefined,
      startIcon: isSet(object.startIcon) ? Icon.fromJSON(object.startIcon) : undefined,
      topLabel: isSet(object.topLabel) ? globalThis.String(object.topLabel) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      wrapText: isSet(object.wrapText) ? globalThis.Boolean(object.wrapText) : false,
      bottomLabel: isSet(object.bottomLabel) ? globalThis.String(object.bottomLabel) : "",
      onClick: isSet(object.onClick) ? OnClick.fromJSON(object.onClick) : undefined,
      button: isSet(object.button) ? Button.fromJSON(object.button) : undefined,
      switchControl: isSet(object.switchControl)
        ? DecoratedText_SwitchControl.fromJSON(object.switchControl)
        : undefined,
      endIcon: isSet(object.endIcon) ? Icon.fromJSON(object.endIcon) : undefined,
    };
  },

  toJSON(message: DecoratedText): unknown {
    const obj: any = {};
    if (message.icon !== undefined) {
      obj.icon = Icon.toJSON(message.icon);
    }
    if (message.startIcon !== undefined) {
      obj.startIcon = Icon.toJSON(message.startIcon);
    }
    if (message.topLabel !== "") {
      obj.topLabel = message.topLabel;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.wrapText !== false) {
      obj.wrapText = message.wrapText;
    }
    if (message.bottomLabel !== "") {
      obj.bottomLabel = message.bottomLabel;
    }
    if (message.onClick !== undefined) {
      obj.onClick = OnClick.toJSON(message.onClick);
    }
    if (message.button !== undefined) {
      obj.button = Button.toJSON(message.button);
    }
    if (message.switchControl !== undefined) {
      obj.switchControl = DecoratedText_SwitchControl.toJSON(message.switchControl);
    }
    if (message.endIcon !== undefined) {
      obj.endIcon = Icon.toJSON(message.endIcon);
    }
    return obj;
  },

  create(base?: DeepPartial<DecoratedText>): DecoratedText {
    return DecoratedText.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecoratedText>): DecoratedText {
    const message = createBaseDecoratedText();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Icon.fromPartial(object.icon) : undefined;
    message.startIcon = (object.startIcon !== undefined && object.startIcon !== null)
      ? Icon.fromPartial(object.startIcon)
      : undefined;
    message.topLabel = object.topLabel ?? "";
    message.text = object.text ?? "";
    message.wrapText = object.wrapText ?? false;
    message.bottomLabel = object.bottomLabel ?? "";
    message.onClick = (object.onClick !== undefined && object.onClick !== null)
      ? OnClick.fromPartial(object.onClick)
      : undefined;
    message.button = (object.button !== undefined && object.button !== null)
      ? Button.fromPartial(object.button)
      : undefined;
    message.switchControl = (object.switchControl !== undefined && object.switchControl !== null)
      ? DecoratedText_SwitchControl.fromPartial(object.switchControl)
      : undefined;
    message.endIcon = (object.endIcon !== undefined && object.endIcon !== null)
      ? Icon.fromPartial(object.endIcon)
      : undefined;
    return message;
  },
};

function createBaseDecoratedText_SwitchControl(): DecoratedText_SwitchControl {
  return { name: "", value: "", selected: false, onChangeAction: undefined, controlType: 0 };
}

export const DecoratedText_SwitchControl: MessageFns<DecoratedText_SwitchControl> = {
  encode(message: DecoratedText_SwitchControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.selected !== false) {
      writer.uint32(24).bool(message.selected);
    }
    if (message.onChangeAction !== undefined) {
      Action.encode(message.onChangeAction, writer.uint32(34).fork()).join();
    }
    if (message.controlType !== 0) {
      writer.uint32(40).int32(message.controlType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecoratedText_SwitchControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecoratedText_SwitchControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.selected = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.onChangeAction = Action.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.controlType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecoratedText_SwitchControl {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
      onChangeAction: isSet(object.onChangeAction) ? Action.fromJSON(object.onChangeAction) : undefined,
      controlType: isSet(object.controlType) ? decoratedText_SwitchControl_ControlTypeFromJSON(object.controlType) : 0,
    };
  },

  toJSON(message: DecoratedText_SwitchControl): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    if (message.onChangeAction !== undefined) {
      obj.onChangeAction = Action.toJSON(message.onChangeAction);
    }
    if (message.controlType !== 0) {
      obj.controlType = decoratedText_SwitchControl_ControlTypeToJSON(message.controlType);
    }
    return obj;
  },

  create(base?: DeepPartial<DecoratedText_SwitchControl>): DecoratedText_SwitchControl {
    return DecoratedText_SwitchControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecoratedText_SwitchControl>): DecoratedText_SwitchControl {
    const message = createBaseDecoratedText_SwitchControl();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.selected = object.selected ?? false;
    message.onChangeAction = (object.onChangeAction !== undefined && object.onChangeAction !== null)
      ? Action.fromPartial(object.onChangeAction)
      : undefined;
    message.controlType = object.controlType ?? 0;
    return message;
  },
};

function createBaseTextInput(): TextInput {
  return {
    name: "",
    label: "",
    hintText: "",
    value: "",
    type: 0,
    onChangeAction: undefined,
    initialSuggestions: undefined,
    autoCompleteAction: undefined,
    placeholderText: "",
  };
}

export const TextInput: MessageFns<TextInput> = {
  encode(message: TextInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.hintText !== "") {
      writer.uint32(26).string(message.hintText);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.onChangeAction !== undefined) {
      Action.encode(message.onChangeAction, writer.uint32(50).fork()).join();
    }
    if (message.initialSuggestions !== undefined) {
      Suggestions.encode(message.initialSuggestions, writer.uint32(58).fork()).join();
    }
    if (message.autoCompleteAction !== undefined) {
      Action.encode(message.autoCompleteAction, writer.uint32(66).fork()).join();
    }
    if (message.placeholderText !== "") {
      writer.uint32(98).string(message.placeholderText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hintText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.onChangeAction = Action.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.initialSuggestions = Suggestions.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.autoCompleteAction = Action.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.placeholderText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInput {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      hintText: isSet(object.hintText) ? globalThis.String(object.hintText) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      type: isSet(object.type) ? textInput_TypeFromJSON(object.type) : 0,
      onChangeAction: isSet(object.onChangeAction) ? Action.fromJSON(object.onChangeAction) : undefined,
      initialSuggestions: isSet(object.initialSuggestions)
        ? Suggestions.fromJSON(object.initialSuggestions)
        : undefined,
      autoCompleteAction: isSet(object.autoCompleteAction) ? Action.fromJSON(object.autoCompleteAction) : undefined,
      placeholderText: isSet(object.placeholderText) ? globalThis.String(object.placeholderText) : "",
    };
  },

  toJSON(message: TextInput): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.hintText !== "") {
      obj.hintText = message.hintText;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.type !== 0) {
      obj.type = textInput_TypeToJSON(message.type);
    }
    if (message.onChangeAction !== undefined) {
      obj.onChangeAction = Action.toJSON(message.onChangeAction);
    }
    if (message.initialSuggestions !== undefined) {
      obj.initialSuggestions = Suggestions.toJSON(message.initialSuggestions);
    }
    if (message.autoCompleteAction !== undefined) {
      obj.autoCompleteAction = Action.toJSON(message.autoCompleteAction);
    }
    if (message.placeholderText !== "") {
      obj.placeholderText = message.placeholderText;
    }
    return obj;
  },

  create(base?: DeepPartial<TextInput>): TextInput {
    return TextInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextInput>): TextInput {
    const message = createBaseTextInput();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.hintText = object.hintText ?? "";
    message.value = object.value ?? "";
    message.type = object.type ?? 0;
    message.onChangeAction = (object.onChangeAction !== undefined && object.onChangeAction !== null)
      ? Action.fromPartial(object.onChangeAction)
      : undefined;
    message.initialSuggestions = (object.initialSuggestions !== undefined && object.initialSuggestions !== null)
      ? Suggestions.fromPartial(object.initialSuggestions)
      : undefined;
    message.autoCompleteAction = (object.autoCompleteAction !== undefined && object.autoCompleteAction !== null)
      ? Action.fromPartial(object.autoCompleteAction)
      : undefined;
    message.placeholderText = object.placeholderText ?? "";
    return message;
  },
};

function createBaseSuggestions(): Suggestions {
  return { items: [] };
}

export const Suggestions: MessageFns<Suggestions> = {
  encode(message: Suggestions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Suggestions_SuggestionItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Suggestions_SuggestionItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestions {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => Suggestions_SuggestionItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Suggestions): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Suggestions_SuggestionItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestions>): Suggestions {
    return Suggestions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestions>): Suggestions {
    const message = createBaseSuggestions();
    message.items = object.items?.map((e) => Suggestions_SuggestionItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSuggestions_SuggestionItem(): Suggestions_SuggestionItem {
  return { text: undefined };
}

export const Suggestions_SuggestionItem: MessageFns<Suggestions_SuggestionItem> = {
  encode(message: Suggestions_SuggestionItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestions_SuggestionItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestions_SuggestionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestions_SuggestionItem {
    return { text: isSet(object.text) ? globalThis.String(object.text) : undefined };
  },

  toJSON(message: Suggestions_SuggestionItem): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestions_SuggestionItem>): Suggestions_SuggestionItem {
    return Suggestions_SuggestionItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestions_SuggestionItem>): Suggestions_SuggestionItem {
    const message = createBaseSuggestions_SuggestionItem();
    message.text = object.text ?? undefined;
    return message;
  },
};

function createBaseButtonList(): ButtonList {
  return { buttons: [] };
}

export const ButtonList: MessageFns<ButtonList> = {
  encode(message: ButtonList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.buttons) {
      Button.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ButtonList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buttons.push(Button.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonList {
    return {
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e: any) => Button.fromJSON(e)) : [],
    };
  },

  toJSON(message: ButtonList): unknown {
    const obj: any = {};
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => Button.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ButtonList>): ButtonList {
    return ButtonList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ButtonList>): ButtonList {
    const message = createBaseButtonList();
    message.buttons = object.buttons?.map((e) => Button.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSelectionInput(): SelectionInput {
  return {
    name: "",
    label: "",
    type: 0,
    items: [],
    onChangeAction: undefined,
    multiSelectMaxSelectedItems: 0,
    multiSelectMinQueryLength: 0,
    externalDataSource: undefined,
    platformDataSource: undefined,
  };
}

export const SelectionInput: MessageFns<SelectionInput> = {
  encode(message: SelectionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    for (const v of message.items) {
      SelectionInput_SelectionItem.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.onChangeAction !== undefined) {
      Action.encode(message.onChangeAction, writer.uint32(42).fork()).join();
    }
    if (message.multiSelectMaxSelectedItems !== 0) {
      writer.uint32(48).int32(message.multiSelectMaxSelectedItems);
    }
    if (message.multiSelectMinQueryLength !== 0) {
      writer.uint32(56).int32(message.multiSelectMinQueryLength);
    }
    if (message.externalDataSource !== undefined) {
      Action.encode(message.externalDataSource, writer.uint32(66).fork()).join();
    }
    if (message.platformDataSource !== undefined) {
      SelectionInput_PlatformDataSource.encode(message.platformDataSource, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.items.push(SelectionInput_SelectionItem.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.onChangeAction = Action.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.multiSelectMaxSelectedItems = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.multiSelectMinQueryLength = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalDataSource = Action.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.platformDataSource = SelectionInput_PlatformDataSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectionInput {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      type: isSet(object.type) ? selectionInput_SelectionTypeFromJSON(object.type) : 0,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => SelectionInput_SelectionItem.fromJSON(e))
        : [],
      onChangeAction: isSet(object.onChangeAction) ? Action.fromJSON(object.onChangeAction) : undefined,
      multiSelectMaxSelectedItems: isSet(object.multiSelectMaxSelectedItems)
        ? globalThis.Number(object.multiSelectMaxSelectedItems)
        : 0,
      multiSelectMinQueryLength: isSet(object.multiSelectMinQueryLength)
        ? globalThis.Number(object.multiSelectMinQueryLength)
        : 0,
      externalDataSource: isSet(object.externalDataSource) ? Action.fromJSON(object.externalDataSource) : undefined,
      platformDataSource: isSet(object.platformDataSource)
        ? SelectionInput_PlatformDataSource.fromJSON(object.platformDataSource)
        : undefined,
    };
  },

  toJSON(message: SelectionInput): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.type !== 0) {
      obj.type = selectionInput_SelectionTypeToJSON(message.type);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => SelectionInput_SelectionItem.toJSON(e));
    }
    if (message.onChangeAction !== undefined) {
      obj.onChangeAction = Action.toJSON(message.onChangeAction);
    }
    if (message.multiSelectMaxSelectedItems !== 0) {
      obj.multiSelectMaxSelectedItems = Math.round(message.multiSelectMaxSelectedItems);
    }
    if (message.multiSelectMinQueryLength !== 0) {
      obj.multiSelectMinQueryLength = Math.round(message.multiSelectMinQueryLength);
    }
    if (message.externalDataSource !== undefined) {
      obj.externalDataSource = Action.toJSON(message.externalDataSource);
    }
    if (message.platformDataSource !== undefined) {
      obj.platformDataSource = SelectionInput_PlatformDataSource.toJSON(message.platformDataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<SelectionInput>): SelectionInput {
    return SelectionInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SelectionInput>): SelectionInput {
    const message = createBaseSelectionInput();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.type = object.type ?? 0;
    message.items = object.items?.map((e) => SelectionInput_SelectionItem.fromPartial(e)) || [];
    message.onChangeAction = (object.onChangeAction !== undefined && object.onChangeAction !== null)
      ? Action.fromPartial(object.onChangeAction)
      : undefined;
    message.multiSelectMaxSelectedItems = object.multiSelectMaxSelectedItems ?? 0;
    message.multiSelectMinQueryLength = object.multiSelectMinQueryLength ?? 0;
    message.externalDataSource = (object.externalDataSource !== undefined && object.externalDataSource !== null)
      ? Action.fromPartial(object.externalDataSource)
      : undefined;
    message.platformDataSource = (object.platformDataSource !== undefined && object.platformDataSource !== null)
      ? SelectionInput_PlatformDataSource.fromPartial(object.platformDataSource)
      : undefined;
    return message;
  },
};

function createBaseSelectionInput_SelectionItem(): SelectionInput_SelectionItem {
  return { text: "", value: "", selected: false, startIconUri: "", bottomText: "" };
}

export const SelectionInput_SelectionItem: MessageFns<SelectionInput_SelectionItem> = {
  encode(message: SelectionInput_SelectionItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.selected !== false) {
      writer.uint32(24).bool(message.selected);
    }
    if (message.startIconUri !== "") {
      writer.uint32(34).string(message.startIconUri);
    }
    if (message.bottomText !== "") {
      writer.uint32(42).string(message.bottomText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectionInput_SelectionItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectionInput_SelectionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.selected = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startIconUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bottomText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectionInput_SelectionItem {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
      startIconUri: isSet(object.startIconUri) ? globalThis.String(object.startIconUri) : "",
      bottomText: isSet(object.bottomText) ? globalThis.String(object.bottomText) : "",
    };
  },

  toJSON(message: SelectionInput_SelectionItem): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    if (message.startIconUri !== "") {
      obj.startIconUri = message.startIconUri;
    }
    if (message.bottomText !== "") {
      obj.bottomText = message.bottomText;
    }
    return obj;
  },

  create(base?: DeepPartial<SelectionInput_SelectionItem>): SelectionInput_SelectionItem {
    return SelectionInput_SelectionItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SelectionInput_SelectionItem>): SelectionInput_SelectionItem {
    const message = createBaseSelectionInput_SelectionItem();
    message.text = object.text ?? "";
    message.value = object.value ?? "";
    message.selected = object.selected ?? false;
    message.startIconUri = object.startIconUri ?? "";
    message.bottomText = object.bottomText ?? "";
    return message;
  },
};

function createBaseSelectionInput_PlatformDataSource(): SelectionInput_PlatformDataSource {
  return { commonDataSource: undefined };
}

export const SelectionInput_PlatformDataSource: MessageFns<SelectionInput_PlatformDataSource> = {
  encode(message: SelectionInput_PlatformDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commonDataSource !== undefined) {
      writer.uint32(8).int32(message.commonDataSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectionInput_PlatformDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectionInput_PlatformDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.commonDataSource = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectionInput_PlatformDataSource {
    return {
      commonDataSource: isSet(object.commonDataSource)
        ? selectionInput_PlatformDataSource_CommonDataSourceFromJSON(object.commonDataSource)
        : undefined,
    };
  },

  toJSON(message: SelectionInput_PlatformDataSource): unknown {
    const obj: any = {};
    if (message.commonDataSource !== undefined) {
      obj.commonDataSource = selectionInput_PlatformDataSource_CommonDataSourceToJSON(message.commonDataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<SelectionInput_PlatformDataSource>): SelectionInput_PlatformDataSource {
    return SelectionInput_PlatformDataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SelectionInput_PlatformDataSource>): SelectionInput_PlatformDataSource {
    const message = createBaseSelectionInput_PlatformDataSource();
    message.commonDataSource = object.commonDataSource ?? undefined;
    return message;
  },
};

function createBaseDateTimePicker(): DateTimePicker {
  return { name: "", label: "", type: 0, valueMsEpoch: Long.ZERO, timezoneOffsetDate: 0, onChangeAction: undefined };
}

export const DateTimePicker: MessageFns<DateTimePicker> = {
  encode(message: DateTimePicker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (!message.valueMsEpoch.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.valueMsEpoch.toString());
    }
    if (message.timezoneOffsetDate !== 0) {
      writer.uint32(40).int32(message.timezoneOffsetDate);
    }
    if (message.onChangeAction !== undefined) {
      Action.encode(message.onChangeAction, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimePicker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimePicker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.valueMsEpoch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timezoneOffsetDate = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.onChangeAction = Action.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimePicker {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      type: isSet(object.type) ? dateTimePicker_DateTimePickerTypeFromJSON(object.type) : 0,
      valueMsEpoch: isSet(object.valueMsEpoch) ? Long.fromValue(object.valueMsEpoch) : Long.ZERO,
      timezoneOffsetDate: isSet(object.timezoneOffsetDate) ? globalThis.Number(object.timezoneOffsetDate) : 0,
      onChangeAction: isSet(object.onChangeAction) ? Action.fromJSON(object.onChangeAction) : undefined,
    };
  },

  toJSON(message: DateTimePicker): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.type !== 0) {
      obj.type = dateTimePicker_DateTimePickerTypeToJSON(message.type);
    }
    if (!message.valueMsEpoch.equals(Long.ZERO)) {
      obj.valueMsEpoch = (message.valueMsEpoch || Long.ZERO).toString();
    }
    if (message.timezoneOffsetDate !== 0) {
      obj.timezoneOffsetDate = Math.round(message.timezoneOffsetDate);
    }
    if (message.onChangeAction !== undefined) {
      obj.onChangeAction = Action.toJSON(message.onChangeAction);
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimePicker>): DateTimePicker {
    return DateTimePicker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimePicker>): DateTimePicker {
    const message = createBaseDateTimePicker();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.type = object.type ?? 0;
    message.valueMsEpoch = (object.valueMsEpoch !== undefined && object.valueMsEpoch !== null)
      ? Long.fromValue(object.valueMsEpoch)
      : Long.ZERO;
    message.timezoneOffsetDate = object.timezoneOffsetDate ?? 0;
    message.onChangeAction = (object.onChangeAction !== undefined && object.onChangeAction !== null)
      ? Action.fromPartial(object.onChangeAction)
      : undefined;
    return message;
  },
};

function createBaseButton(): Button {
  return { text: "", icon: undefined, color: undefined, onClick: undefined, disabled: false, altText: "" };
}

export const Button: MessageFns<Button> = {
  encode(message: Button, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.icon !== undefined) {
      Icon.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.color !== undefined) {
      Color.encode(message.color, writer.uint32(26).fork()).join();
    }
    if (message.onClick !== undefined) {
      OnClick.encode(message.onClick, writer.uint32(34).fork()).join();
    }
    if (message.disabled !== false) {
      writer.uint32(40).bool(message.disabled);
    }
    if (message.altText !== "") {
      writer.uint32(50).string(message.altText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Button {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.icon = Icon.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.color = Color.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.onClick = OnClick.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.altText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Button {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      icon: isSet(object.icon) ? Icon.fromJSON(object.icon) : undefined,
      color: isSet(object.color) ? Color.fromJSON(object.color) : undefined,
      onClick: isSet(object.onClick) ? OnClick.fromJSON(object.onClick) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
    };
  },

  toJSON(message: Button): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.icon !== undefined) {
      obj.icon = Icon.toJSON(message.icon);
    }
    if (message.color !== undefined) {
      obj.color = Color.toJSON(message.color);
    }
    if (message.onClick !== undefined) {
      obj.onClick = OnClick.toJSON(message.onClick);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    return obj;
  },

  create(base?: DeepPartial<Button>): Button {
    return Button.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Button>): Button {
    const message = createBaseButton();
    message.text = object.text ?? "";
    message.icon = (object.icon !== undefined && object.icon !== null) ? Icon.fromPartial(object.icon) : undefined;
    message.color = (object.color !== undefined && object.color !== null) ? Color.fromPartial(object.color) : undefined;
    message.onClick = (object.onClick !== undefined && object.onClick !== null)
      ? OnClick.fromPartial(object.onClick)
      : undefined;
    message.disabled = object.disabled ?? false;
    message.altText = object.altText ?? "";
    return message;
  },
};

function createBaseIcon(): Icon {
  return { knownIcon: undefined, iconUrl: undefined, materialIcon: undefined, altText: "", imageType: 0 };
}

export const Icon: MessageFns<Icon> = {
  encode(message: Icon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.knownIcon !== undefined) {
      writer.uint32(10).string(message.knownIcon);
    }
    if (message.iconUrl !== undefined) {
      writer.uint32(18).string(message.iconUrl);
    }
    if (message.materialIcon !== undefined) {
      MaterialIcon.encode(message.materialIcon, writer.uint32(42).fork()).join();
    }
    if (message.altText !== "") {
      writer.uint32(26).string(message.altText);
    }
    if (message.imageType !== 0) {
      writer.uint32(32).int32(message.imageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Icon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.knownIcon = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iconUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.materialIcon = MaterialIcon.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.altText = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.imageType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Icon {
    return {
      knownIcon: isSet(object.knownIcon) ? globalThis.String(object.knownIcon) : undefined,
      iconUrl: isSet(object.iconUrl) ? globalThis.String(object.iconUrl) : undefined,
      materialIcon: isSet(object.materialIcon) ? MaterialIcon.fromJSON(object.materialIcon) : undefined,
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
      imageType: isSet(object.imageType) ? widget_ImageTypeFromJSON(object.imageType) : 0,
    };
  },

  toJSON(message: Icon): unknown {
    const obj: any = {};
    if (message.knownIcon !== undefined) {
      obj.knownIcon = message.knownIcon;
    }
    if (message.iconUrl !== undefined) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.materialIcon !== undefined) {
      obj.materialIcon = MaterialIcon.toJSON(message.materialIcon);
    }
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    if (message.imageType !== 0) {
      obj.imageType = widget_ImageTypeToJSON(message.imageType);
    }
    return obj;
  },

  create(base?: DeepPartial<Icon>): Icon {
    return Icon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Icon>): Icon {
    const message = createBaseIcon();
    message.knownIcon = object.knownIcon ?? undefined;
    message.iconUrl = object.iconUrl ?? undefined;
    message.materialIcon = (object.materialIcon !== undefined && object.materialIcon !== null)
      ? MaterialIcon.fromPartial(object.materialIcon)
      : undefined;
    message.altText = object.altText ?? "";
    message.imageType = object.imageType ?? 0;
    return message;
  },
};

function createBaseMaterialIcon(): MaterialIcon {
  return { name: "", fill: false, weight: 0, grade: 0 };
}

export const MaterialIcon: MessageFns<MaterialIcon> = {
  encode(message: MaterialIcon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fill !== false) {
      writer.uint32(16).bool(message.fill);
    }
    if (message.weight !== 0) {
      writer.uint32(24).int32(message.weight);
    }
    if (message.grade !== 0) {
      writer.uint32(32).int32(message.grade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterialIcon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterialIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fill = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.weight = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.grade = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterialIcon {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fill: isSet(object.fill) ? globalThis.Boolean(object.fill) : false,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      grade: isSet(object.grade) ? globalThis.Number(object.grade) : 0,
    };
  },

  toJSON(message: MaterialIcon): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fill !== false) {
      obj.fill = message.fill;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.grade !== 0) {
      obj.grade = Math.round(message.grade);
    }
    return obj;
  },

  create(base?: DeepPartial<MaterialIcon>): MaterialIcon {
    return MaterialIcon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterialIcon>): MaterialIcon {
    const message = createBaseMaterialIcon();
    message.name = object.name ?? "";
    message.fill = object.fill ?? false;
    message.weight = object.weight ?? 0;
    message.grade = object.grade ?? 0;
    return message;
  },
};

function createBaseImageCropStyle(): ImageCropStyle {
  return { type: 0, aspectRatio: 0 };
}

export const ImageCropStyle: MessageFns<ImageCropStyle> = {
  encode(message: ImageCropStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.aspectRatio !== 0) {
      writer.uint32(17).double(message.aspectRatio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageCropStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageCropStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.aspectRatio = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageCropStyle {
    return {
      type: isSet(object.type) ? imageCropStyle_ImageCropTypeFromJSON(object.type) : 0,
      aspectRatio: isSet(object.aspectRatio) ? globalThis.Number(object.aspectRatio) : 0,
    };
  },

  toJSON(message: ImageCropStyle): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = imageCropStyle_ImageCropTypeToJSON(message.type);
    }
    if (message.aspectRatio !== 0) {
      obj.aspectRatio = message.aspectRatio;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageCropStyle>): ImageCropStyle {
    return ImageCropStyle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageCropStyle>): ImageCropStyle {
    const message = createBaseImageCropStyle();
    message.type = object.type ?? 0;
    message.aspectRatio = object.aspectRatio ?? 0;
    return message;
  },
};

function createBaseBorderStyle(): BorderStyle {
  return { type: 0, strokeColor: undefined, cornerRadius: 0 };
}

export const BorderStyle: MessageFns<BorderStyle> = {
  encode(message: BorderStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.strokeColor !== undefined) {
      Color.encode(message.strokeColor, writer.uint32(18).fork()).join();
    }
    if (message.cornerRadius !== 0) {
      writer.uint32(24).int32(message.cornerRadius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorderStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorderStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.strokeColor = Color.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cornerRadius = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorderStyle {
    return {
      type: isSet(object.type) ? borderStyle_BorderTypeFromJSON(object.type) : 0,
      strokeColor: isSet(object.strokeColor) ? Color.fromJSON(object.strokeColor) : undefined,
      cornerRadius: isSet(object.cornerRadius) ? globalThis.Number(object.cornerRadius) : 0,
    };
  },

  toJSON(message: BorderStyle): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = borderStyle_BorderTypeToJSON(message.type);
    }
    if (message.strokeColor !== undefined) {
      obj.strokeColor = Color.toJSON(message.strokeColor);
    }
    if (message.cornerRadius !== 0) {
      obj.cornerRadius = Math.round(message.cornerRadius);
    }
    return obj;
  },

  create(base?: DeepPartial<BorderStyle>): BorderStyle {
    return BorderStyle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BorderStyle>): BorderStyle {
    const message = createBaseBorderStyle();
    message.type = object.type ?? 0;
    message.strokeColor = (object.strokeColor !== undefined && object.strokeColor !== null)
      ? Color.fromPartial(object.strokeColor)
      : undefined;
    message.cornerRadius = object.cornerRadius ?? 0;
    return message;
  },
};

function createBaseImageComponent(): ImageComponent {
  return { imageUri: "", altText: "", cropStyle: undefined, borderStyle: undefined };
}

export const ImageComponent: MessageFns<ImageComponent> = {
  encode(message: ImageComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUri !== "") {
      writer.uint32(10).string(message.imageUri);
    }
    if (message.altText !== "") {
      writer.uint32(18).string(message.altText);
    }
    if (message.cropStyle !== undefined) {
      ImageCropStyle.encode(message.cropStyle, writer.uint32(26).fork()).join();
    }
    if (message.borderStyle !== undefined) {
      BorderStyle.encode(message.borderStyle, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.altText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cropStyle = ImageCropStyle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.borderStyle = BorderStyle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageComponent {
    return {
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
      cropStyle: isSet(object.cropStyle) ? ImageCropStyle.fromJSON(object.cropStyle) : undefined,
      borderStyle: isSet(object.borderStyle) ? BorderStyle.fromJSON(object.borderStyle) : undefined,
    };
  },

  toJSON(message: ImageComponent): unknown {
    const obj: any = {};
    if (message.imageUri !== "") {
      obj.imageUri = message.imageUri;
    }
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    if (message.cropStyle !== undefined) {
      obj.cropStyle = ImageCropStyle.toJSON(message.cropStyle);
    }
    if (message.borderStyle !== undefined) {
      obj.borderStyle = BorderStyle.toJSON(message.borderStyle);
    }
    return obj;
  },

  create(base?: DeepPartial<ImageComponent>): ImageComponent {
    return ImageComponent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageComponent>): ImageComponent {
    const message = createBaseImageComponent();
    message.imageUri = object.imageUri ?? "";
    message.altText = object.altText ?? "";
    message.cropStyle = (object.cropStyle !== undefined && object.cropStyle !== null)
      ? ImageCropStyle.fromPartial(object.cropStyle)
      : undefined;
    message.borderStyle = (object.borderStyle !== undefined && object.borderStyle !== null)
      ? BorderStyle.fromPartial(object.borderStyle)
      : undefined;
    return message;
  },
};

function createBaseGrid(): Grid {
  return { title: "", items: [], borderStyle: undefined, columnCount: 0, onClick: undefined };
}

export const Grid: MessageFns<Grid> = {
  encode(message: Grid, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.items) {
      Grid_GridItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.borderStyle !== undefined) {
      BorderStyle.encode(message.borderStyle, writer.uint32(26).fork()).join();
    }
    if (message.columnCount !== 0) {
      writer.uint32(32).int32(message.columnCount);
    }
    if (message.onClick !== undefined) {
      OnClick.encode(message.onClick, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grid {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(Grid_GridItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.borderStyle = BorderStyle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.columnCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.onClick = OnClick.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grid {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Grid_GridItem.fromJSON(e)) : [],
      borderStyle: isSet(object.borderStyle) ? BorderStyle.fromJSON(object.borderStyle) : undefined,
      columnCount: isSet(object.columnCount) ? globalThis.Number(object.columnCount) : 0,
      onClick: isSet(object.onClick) ? OnClick.fromJSON(object.onClick) : undefined,
    };
  },

  toJSON(message: Grid): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Grid_GridItem.toJSON(e));
    }
    if (message.borderStyle !== undefined) {
      obj.borderStyle = BorderStyle.toJSON(message.borderStyle);
    }
    if (message.columnCount !== 0) {
      obj.columnCount = Math.round(message.columnCount);
    }
    if (message.onClick !== undefined) {
      obj.onClick = OnClick.toJSON(message.onClick);
    }
    return obj;
  },

  create(base?: DeepPartial<Grid>): Grid {
    return Grid.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Grid>): Grid {
    const message = createBaseGrid();
    message.title = object.title ?? "";
    message.items = object.items?.map((e) => Grid_GridItem.fromPartial(e)) || [];
    message.borderStyle = (object.borderStyle !== undefined && object.borderStyle !== null)
      ? BorderStyle.fromPartial(object.borderStyle)
      : undefined;
    message.columnCount = object.columnCount ?? 0;
    message.onClick = (object.onClick !== undefined && object.onClick !== null)
      ? OnClick.fromPartial(object.onClick)
      : undefined;
    return message;
  },
};

function createBaseGrid_GridItem(): Grid_GridItem {
  return { id: "", image: undefined, title: "", subtitle: "", layout: 0 };
}

export const Grid_GridItem: MessageFns<Grid_GridItem> = {
  encode(message: Grid_GridItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.image !== undefined) {
      ImageComponent.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.subtitle !== "") {
      writer.uint32(34).string(message.subtitle);
    }
    if (message.layout !== 0) {
      writer.uint32(72).int32(message.layout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grid_GridItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrid_GridItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.image = ImageComponent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subtitle = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.layout = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grid_GridItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      image: isSet(object.image) ? ImageComponent.fromJSON(object.image) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      subtitle: isSet(object.subtitle) ? globalThis.String(object.subtitle) : "",
      layout: isSet(object.layout) ? grid_GridItem_GridItemLayoutFromJSON(object.layout) : 0,
    };
  },

  toJSON(message: Grid_GridItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.image !== undefined) {
      obj.image = ImageComponent.toJSON(message.image);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.subtitle !== "") {
      obj.subtitle = message.subtitle;
    }
    if (message.layout !== 0) {
      obj.layout = grid_GridItem_GridItemLayoutToJSON(message.layout);
    }
    return obj;
  },

  create(base?: DeepPartial<Grid_GridItem>): Grid_GridItem {
    return Grid_GridItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Grid_GridItem>): Grid_GridItem {
    const message = createBaseGrid_GridItem();
    message.id = object.id ?? "";
    message.image = (object.image !== undefined && object.image !== null)
      ? ImageComponent.fromPartial(object.image)
      : undefined;
    message.title = object.title ?? "";
    message.subtitle = object.subtitle ?? "";
    message.layout = object.layout ?? 0;
    return message;
  },
};

function createBaseColumns(): Columns {
  return { columnItems: [] };
}

export const Columns: MessageFns<Columns> = {
  encode(message: Columns, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columnItems) {
      Columns_Column.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Columns {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columnItems.push(Columns_Column.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Columns {
    return {
      columnItems: globalThis.Array.isArray(object?.columnItems)
        ? object.columnItems.map((e: any) => Columns_Column.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Columns): unknown {
    const obj: any = {};
    if (message.columnItems?.length) {
      obj.columnItems = message.columnItems.map((e) => Columns_Column.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Columns>): Columns {
    return Columns.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Columns>): Columns {
    const message = createBaseColumns();
    message.columnItems = object.columnItems?.map((e) => Columns_Column.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumns_Column(): Columns_Column {
  return { horizontalSizeStyle: 0, horizontalAlignment: 0, verticalAlignment: 0, widgets: [] };
}

export const Columns_Column: MessageFns<Columns_Column> = {
  encode(message: Columns_Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.horizontalSizeStyle !== 0) {
      writer.uint32(8).int32(message.horizontalSizeStyle);
    }
    if (message.horizontalAlignment !== 0) {
      writer.uint32(16).int32(message.horizontalAlignment);
    }
    if (message.verticalAlignment !== 0) {
      writer.uint32(24).int32(message.verticalAlignment);
    }
    for (const v of message.widgets) {
      Columns_Column_Widgets.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Columns_Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumns_Column();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.horizontalSizeStyle = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.horizontalAlignment = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.verticalAlignment = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.widgets.push(Columns_Column_Widgets.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Columns_Column {
    return {
      horizontalSizeStyle: isSet(object.horizontalSizeStyle)
        ? columns_Column_HorizontalSizeStyleFromJSON(object.horizontalSizeStyle)
        : 0,
      horizontalAlignment: isSet(object.horizontalAlignment)
        ? widget_HorizontalAlignmentFromJSON(object.horizontalAlignment)
        : 0,
      verticalAlignment: isSet(object.verticalAlignment)
        ? columns_Column_VerticalAlignmentFromJSON(object.verticalAlignment)
        : 0,
      widgets: globalThis.Array.isArray(object?.widgets)
        ? object.widgets.map((e: any) => Columns_Column_Widgets.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Columns_Column): unknown {
    const obj: any = {};
    if (message.horizontalSizeStyle !== 0) {
      obj.horizontalSizeStyle = columns_Column_HorizontalSizeStyleToJSON(message.horizontalSizeStyle);
    }
    if (message.horizontalAlignment !== 0) {
      obj.horizontalAlignment = widget_HorizontalAlignmentToJSON(message.horizontalAlignment);
    }
    if (message.verticalAlignment !== 0) {
      obj.verticalAlignment = columns_Column_VerticalAlignmentToJSON(message.verticalAlignment);
    }
    if (message.widgets?.length) {
      obj.widgets = message.widgets.map((e) => Columns_Column_Widgets.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Columns_Column>): Columns_Column {
    return Columns_Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Columns_Column>): Columns_Column {
    const message = createBaseColumns_Column();
    message.horizontalSizeStyle = object.horizontalSizeStyle ?? 0;
    message.horizontalAlignment = object.horizontalAlignment ?? 0;
    message.verticalAlignment = object.verticalAlignment ?? 0;
    message.widgets = object.widgets?.map((e) => Columns_Column_Widgets.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumns_Column_Widgets(): Columns_Column_Widgets {
  return {
    textParagraph: undefined,
    image: undefined,
    decoratedText: undefined,
    buttonList: undefined,
    textInput: undefined,
    selectionInput: undefined,
    dateTimePicker: undefined,
  };
}

export const Columns_Column_Widgets: MessageFns<Columns_Column_Widgets> = {
  encode(message: Columns_Column_Widgets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textParagraph !== undefined) {
      TextParagraph.encode(message.textParagraph, writer.uint32(10).fork()).join();
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.decoratedText !== undefined) {
      DecoratedText.encode(message.decoratedText, writer.uint32(26).fork()).join();
    }
    if (message.buttonList !== undefined) {
      ButtonList.encode(message.buttonList, writer.uint32(34).fork()).join();
    }
    if (message.textInput !== undefined) {
      TextInput.encode(message.textInput, writer.uint32(42).fork()).join();
    }
    if (message.selectionInput !== undefined) {
      SelectionInput.encode(message.selectionInput, writer.uint32(50).fork()).join();
    }
    if (message.dateTimePicker !== undefined) {
      DateTimePicker.encode(message.dateTimePicker, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Columns_Column_Widgets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumns_Column_Widgets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textParagraph = TextParagraph.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.decoratedText = DecoratedText.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.buttonList = ButtonList.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.selectionInput = SelectionInput.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dateTimePicker = DateTimePicker.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Columns_Column_Widgets {
    return {
      textParagraph: isSet(object.textParagraph) ? TextParagraph.fromJSON(object.textParagraph) : undefined,
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      decoratedText: isSet(object.decoratedText) ? DecoratedText.fromJSON(object.decoratedText) : undefined,
      buttonList: isSet(object.buttonList) ? ButtonList.fromJSON(object.buttonList) : undefined,
      textInput: isSet(object.textInput) ? TextInput.fromJSON(object.textInput) : undefined,
      selectionInput: isSet(object.selectionInput) ? SelectionInput.fromJSON(object.selectionInput) : undefined,
      dateTimePicker: isSet(object.dateTimePicker) ? DateTimePicker.fromJSON(object.dateTimePicker) : undefined,
    };
  },

  toJSON(message: Columns_Column_Widgets): unknown {
    const obj: any = {};
    if (message.textParagraph !== undefined) {
      obj.textParagraph = TextParagraph.toJSON(message.textParagraph);
    }
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.decoratedText !== undefined) {
      obj.decoratedText = DecoratedText.toJSON(message.decoratedText);
    }
    if (message.buttonList !== undefined) {
      obj.buttonList = ButtonList.toJSON(message.buttonList);
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInput.toJSON(message.textInput);
    }
    if (message.selectionInput !== undefined) {
      obj.selectionInput = SelectionInput.toJSON(message.selectionInput);
    }
    if (message.dateTimePicker !== undefined) {
      obj.dateTimePicker = DateTimePicker.toJSON(message.dateTimePicker);
    }
    return obj;
  },

  create(base?: DeepPartial<Columns_Column_Widgets>): Columns_Column_Widgets {
    return Columns_Column_Widgets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Columns_Column_Widgets>): Columns_Column_Widgets {
    const message = createBaseColumns_Column_Widgets();
    message.textParagraph = (object.textParagraph !== undefined && object.textParagraph !== null)
      ? TextParagraph.fromPartial(object.textParagraph)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.decoratedText = (object.decoratedText !== undefined && object.decoratedText !== null)
      ? DecoratedText.fromPartial(object.decoratedText)
      : undefined;
    message.buttonList = (object.buttonList !== undefined && object.buttonList !== null)
      ? ButtonList.fromPartial(object.buttonList)
      : undefined;
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInput.fromPartial(object.textInput)
      : undefined;
    message.selectionInput = (object.selectionInput !== undefined && object.selectionInput !== null)
      ? SelectionInput.fromPartial(object.selectionInput)
      : undefined;
    message.dateTimePicker = (object.dateTimePicker !== undefined && object.dateTimePicker !== null)
      ? DateTimePicker.fromPartial(object.dateTimePicker)
      : undefined;
    return message;
  },
};

function createBaseOnClick(): OnClick {
  return { action: undefined, openLink: undefined, openDynamicLinkAction: undefined, card: undefined };
}

export const OnClick: MessageFns<OnClick> = {
  encode(message: OnClick, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(10).fork()).join();
    }
    if (message.openLink !== undefined) {
      OpenLink.encode(message.openLink, writer.uint32(18).fork()).join();
    }
    if (message.openDynamicLinkAction !== undefined) {
      Action.encode(message.openDynamicLinkAction, writer.uint32(26).fork()).join();
    }
    if (message.card !== undefined) {
      Card.encode(message.card, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnClick {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnClick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.openLink = OpenLink.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.openDynamicLinkAction = Action.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.card = Card.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnClick {
    return {
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      openLink: isSet(object.openLink) ? OpenLink.fromJSON(object.openLink) : undefined,
      openDynamicLinkAction: isSet(object.openDynamicLinkAction)
        ? Action.fromJSON(object.openDynamicLinkAction)
        : undefined,
      card: isSet(object.card) ? Card.fromJSON(object.card) : undefined,
    };
  },

  toJSON(message: OnClick): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.openLink !== undefined) {
      obj.openLink = OpenLink.toJSON(message.openLink);
    }
    if (message.openDynamicLinkAction !== undefined) {
      obj.openDynamicLinkAction = Action.toJSON(message.openDynamicLinkAction);
    }
    if (message.card !== undefined) {
      obj.card = Card.toJSON(message.card);
    }
    return obj;
  },

  create(base?: DeepPartial<OnClick>): OnClick {
    return OnClick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OnClick>): OnClick {
    const message = createBaseOnClick();
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.openLink = (object.openLink !== undefined && object.openLink !== null)
      ? OpenLink.fromPartial(object.openLink)
      : undefined;
    message.openDynamicLinkAction =
      (object.openDynamicLinkAction !== undefined && object.openDynamicLinkAction !== null)
        ? Action.fromPartial(object.openDynamicLinkAction)
        : undefined;
    message.card = (object.card !== undefined && object.card !== null) ? Card.fromPartial(object.card) : undefined;
    return message;
  },
};

function createBaseOpenLink(): OpenLink {
  return { url: "", openAs: 0, onClose: 0 };
}

export const OpenLink: MessageFns<OpenLink> = {
  encode(message: OpenLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.openAs !== 0) {
      writer.uint32(16).int32(message.openAs);
    }
    if (message.onClose !== 0) {
      writer.uint32(24).int32(message.onClose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.openAs = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.onClose = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenLink {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      openAs: isSet(object.openAs) ? openLink_OpenAsFromJSON(object.openAs) : 0,
      onClose: isSet(object.onClose) ? openLink_OnCloseFromJSON(object.onClose) : 0,
    };
  },

  toJSON(message: OpenLink): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.openAs !== 0) {
      obj.openAs = openLink_OpenAsToJSON(message.openAs);
    }
    if (message.onClose !== 0) {
      obj.onClose = openLink_OnCloseToJSON(message.onClose);
    }
    return obj;
  },

  create(base?: DeepPartial<OpenLink>): OpenLink {
    return OpenLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenLink>): OpenLink {
    const message = createBaseOpenLink();
    message.url = object.url ?? "";
    message.openAs = object.openAs ?? 0;
    message.onClose = object.onClose ?? 0;
    return message;
  },
};

function createBaseAction(): Action {
  return { function: "", parameters: [], loadIndicator: 0, persistValues: false, interaction: 0 };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.function !== "") {
      writer.uint32(10).string(message.function);
    }
    for (const v of message.parameters) {
      Action_ActionParameter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.loadIndicator !== 0) {
      writer.uint32(24).int32(message.loadIndicator);
    }
    if (message.persistValues !== false) {
      writer.uint32(32).bool(message.persistValues);
    }
    if (message.interaction !== 0) {
      writer.uint32(40).int32(message.interaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.function = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters.push(Action_ActionParameter.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.loadIndicator = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.persistValues = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.interaction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Action_ActionParameter.fromJSON(e))
        : [],
      loadIndicator: isSet(object.loadIndicator) ? action_LoadIndicatorFromJSON(object.loadIndicator) : 0,
      persistValues: isSet(object.persistValues) ? globalThis.Boolean(object.persistValues) : false,
      interaction: isSet(object.interaction) ? action_InteractionFromJSON(object.interaction) : 0,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Action_ActionParameter.toJSON(e));
    }
    if (message.loadIndicator !== 0) {
      obj.loadIndicator = action_LoadIndicatorToJSON(message.loadIndicator);
    }
    if (message.persistValues !== false) {
      obj.persistValues = message.persistValues;
    }
    if (message.interaction !== 0) {
      obj.interaction = action_InteractionToJSON(message.interaction);
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.function = object.function ?? "";
    message.parameters = object.parameters?.map((e) => Action_ActionParameter.fromPartial(e)) || [];
    message.loadIndicator = object.loadIndicator ?? 0;
    message.persistValues = object.persistValues ?? false;
    message.interaction = object.interaction ?? 0;
    return message;
  },
};

function createBaseAction_ActionParameter(): Action_ActionParameter {
  return { key: "", value: "" };
}

export const Action_ActionParameter: MessageFns<Action_ActionParameter> = {
  encode(message: Action_ActionParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_ActionParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_ActionParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_ActionParameter {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Action_ActionParameter): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Action_ActionParameter>): Action_ActionParameter {
    return Action_ActionParameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action_ActionParameter>): Action_ActionParameter {
    const message = createBaseAction_ActionParameter();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
