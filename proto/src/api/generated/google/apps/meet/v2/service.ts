// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/meet/v2/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import {
  ConferenceRecord,
  Participant,
  ParticipantSession,
  Recording,
  Space,
  Transcript,
  TranscriptEntry,
} from "./resource.js";

export const protobufPackage = "google.apps.meet.v2";

/** Request to create a space. */
export interface CreateSpaceRequest {
  /**
   * Space to be created. As of May 2023, the input space can be empty. Later on
   * the input space can be non-empty when space configuration is introduced.
   */
  space: Space | undefined;
}

/** Request to get a space. */
export interface GetSpaceRequest {
  /** Required. Resource name of the space. */
  name: string;
}

/** Request to update a space. */
export interface UpdateSpaceRequest {
  /** Required. Space to be updated. */
  space:
    | Space
    | undefined;
  /**
   * Optional. Field mask used to specify the fields to be updated in the space.
   * If update_mask isn't provided, it defaults to '*' and updates all
   * fields provided in the request, including deleting fields not set in the
   * request.
   */
  updateMask: string[] | undefined;
}

/** Request to end an ongoing conference of a space. */
export interface EndActiveConferenceRequest {
  /** Required. Resource name of the space. */
  name: string;
}

/** Request to get a conference record. */
export interface GetConferenceRecordRequest {
  /** Required. Resource name of the conference. */
  name: string;
}

/** Request to fetch list of conference records per user. */
export interface ListConferenceRecordsRequest {
  /**
   * Optional. Maximum number of conference records to return. The service might
   * return fewer than this value. If unspecified, at most 25 conference records
   * are returned. The maximum value is 100; values above 100 are coerced to
   * 100. Maximum might change in the future.
   */
  pageSize: number;
  /** Optional. Page token returned from previous List Call. */
  pageToken: string;
  /**
   * Optional. User specified filtering condition in [EBNF
   * format](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form).
   * The following are the filterable fields:
   *
   * * `space.meeting_code`
   * * `space.name`
   * * `start_time`
   * * `end_time`
   *
   * For example, `space.meeting_code = "abc-mnop-xyz"`.
   */
  filter: string;
}

/** Response of ListConferenceRecords method. */
export interface ListConferenceRecordsResponse {
  /** List of conferences in one page. */
  conferenceRecords: ConferenceRecord[];
  /**
   * Token to be circulated back for further List call if current List does NOT
   * include all the Conferences. Unset if all conferences have been returned.
   */
  nextPageToken: string;
}

/** Request to get a participant. */
export interface GetParticipantRequest {
  /** Required. Resource name of the participant. */
  name: string;
}

/** Request to fetch list of participants per conference. */
export interface ListParticipantsRequest {
  /** Required. Format: `conferenceRecords/{conference_record}` */
  parent: string;
  /**
   * Maximum number of participants to return. The service might return fewer
   * than this value.
   * If unspecified, at most 100 participants are returned.
   * The maximum value is 250; values above 250 are coerced to 250.
   * Maximum might change in the future.
   */
  pageSize: number;
  /** Page token returned from previous List Call. */
  pageToken: string;
  /**
   * Optional. User specified filtering condition in [EBNF
   * format](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form).
   * The following are the filterable fields:
   *
   * * `earliest_start_time`
   * * `latest_end_time`
   *
   * For example, `latest_end_time IS NULL` returns active participants in
   * the conference.
   */
  filter: string;
}

/** Response of ListParticipants method. */
export interface ListParticipantsResponse {
  /** List of participants in one page. */
  participants: Participant[];
  /**
   * Token to be circulated back for further List call if current List doesn't
   * include all the participants. Unset if all participants are returned.
   */
  nextPageToken: string;
  /**
   * Total, exact number of `participants`. By default, this field isn't
   * included in the response. Set the field mask in
   * [SystemParameterContext](https://cloud.google.com/apis/docs/system-parameters)
   * to receive this field in the response.
   */
  totalSize: number;
}

/** Request to get a participant session. */
export interface GetParticipantSessionRequest {
  /** Required. Resource name of the participant. */
  name: string;
}

/**
 * Request to fetch list of participant sessions per conference record, per
 * participant.
 */
export interface ListParticipantSessionsRequest {
  /**
   * Required. Format:
   * `conferenceRecords/{conference_record}/participants/{participant}`
   */
  parent: string;
  /**
   * Optional. Maximum number of participant sessions to return. The service
   * might return fewer than this value. If unspecified, at most 100
   * participants are returned. The maximum value is 250; values above 250 are
   * coerced to 250. Maximum might change in the future.
   */
  pageSize: number;
  /** Optional. Page token returned from previous List Call. */
  pageToken: string;
  /**
   * Optional. User specified filtering condition in [EBNF
   * format](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form).
   * The following are the filterable fields:
   *
   * * `start_time`
   * * `end_time`
   *
   * For example, `end_time IS NULL` returns active participant sessions in
   * the conference record.
   */
  filter: string;
}

/** Response of ListParticipants method. */
export interface ListParticipantSessionsResponse {
  /** List of participants in one page. */
  participantSessions: ParticipantSession[];
  /**
   * Token to be circulated back for further List call if current List doesn't
   * include all the participants. Unset if all participants are returned.
   */
  nextPageToken: string;
}

/** Request message for GetRecording method. */
export interface GetRecordingRequest {
  /** Required. Resource name of the recording. */
  name: string;
}

/** Request for ListRecordings method. */
export interface ListRecordingsRequest {
  /** Required. Format: `conferenceRecords/{conference_record}` */
  parent: string;
  /**
   * Maximum number of recordings to return. The service might return fewer
   * than this value.
   * If unspecified, at most 10 recordings are returned.
   * The maximum value is 100; values above 100 are coerced to 100.
   * Maximum might change in the future.
   */
  pageSize: number;
  /** Page token returned from previous List Call. */
  pageToken: string;
}

/** Response for ListRecordings method. */
export interface ListRecordingsResponse {
  /** List of recordings in one page. */
  recordings: Recording[];
  /**
   * Token to be circulated back for further List call if current List doesn't
   * include all the recordings. Unset if all recordings are returned.
   */
  nextPageToken: string;
}

/** Request for GetTranscript method. */
export interface GetTranscriptRequest {
  /** Required. Resource name of the transcript. */
  name: string;
}

/** Request for ListTranscripts method. */
export interface ListTranscriptsRequest {
  /** Required. Format: `conferenceRecords/{conference_record}` */
  parent: string;
  /**
   * Maximum number of transcripts to return. The service might return fewer
   * than this value.
   * If unspecified, at most 10 transcripts are returned.
   * The maximum value is 100; values above 100 are coerced to 100.
   * Maximum might change in the future.
   */
  pageSize: number;
  /** Page token returned from previous List Call. */
  pageToken: string;
}

/** Response for ListTranscripts method. */
export interface ListTranscriptsResponse {
  /** List of transcripts in one page. */
  transcripts: Transcript[];
  /**
   * Token to be circulated back for further List call if current List doesn't
   * include all the transcripts. Unset if all transcripts are returned.
   */
  nextPageToken: string;
}

/** Request for GetTranscriptEntry method. */
export interface GetTranscriptEntryRequest {
  /** Required. Resource name of the `TranscriptEntry`. */
  name: string;
}

/** Request for ListTranscriptEntries method. */
export interface ListTranscriptEntriesRequest {
  /**
   * Required. Format:
   * `conferenceRecords/{conference_record}/transcripts/{transcript}`
   */
  parent: string;
  /**
   * Maximum number of entries to return. The service might return fewer than
   * this value.
   * If unspecified, at most 10 entries are returned.
   * The maximum value is 100; values above 100 are coerced to 100.
   * Maximum might change in the future.
   */
  pageSize: number;
  /** Page token returned from previous List Call. */
  pageToken: string;
}

/** Response for ListTranscriptEntries method. */
export interface ListTranscriptEntriesResponse {
  /** List of TranscriptEntries in one page. */
  transcriptEntries: TranscriptEntry[];
  /**
   * Token to be circulated back for further List call if current List doesn't
   * include all the transcript entries. Unset if all entries are returned.
   */
  nextPageToken: string;
}

function createBaseCreateSpaceRequest(): CreateSpaceRequest {
  return { space: undefined };
}

export const CreateSpaceRequest: MessageFns<CreateSpaceRequest> = {
  encode(message: CreateSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSpaceRequest {
    return { space: isSet(object.space) ? Space.fromJSON(object.space) : undefined };
  },

  toJSON(message: CreateSpaceRequest): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSpaceRequest>): CreateSpaceRequest {
    return CreateSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSpaceRequest>): CreateSpaceRequest {
    const message = createBaseCreateSpaceRequest();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    return message;
  },
};

function createBaseGetSpaceRequest(): GetSpaceRequest {
  return { name: "" };
}

export const GetSpaceRequest: MessageFns<GetSpaceRequest> = {
  encode(message: GetSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpaceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSpaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSpaceRequest>): GetSpaceRequest {
    return GetSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSpaceRequest>): GetSpaceRequest {
    const message = createBaseGetSpaceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSpaceRequest(): UpdateSpaceRequest {
  return { space: undefined, updateMask: undefined };
}

export const UpdateSpaceRequest: MessageFns<UpdateSpaceRequest> = {
  encode(message: UpdateSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSpaceRequest {
    return {
      space: isSet(object.space) ? Space.fromJSON(object.space) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSpaceRequest): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSpaceRequest>): UpdateSpaceRequest {
    return UpdateSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSpaceRequest>): UpdateSpaceRequest {
    const message = createBaseUpdateSpaceRequest();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseEndActiveConferenceRequest(): EndActiveConferenceRequest {
  return { name: "" };
}

export const EndActiveConferenceRequest: MessageFns<EndActiveConferenceRequest> = {
  encode(message: EndActiveConferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndActiveConferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndActiveConferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndActiveConferenceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EndActiveConferenceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<EndActiveConferenceRequest>): EndActiveConferenceRequest {
    return EndActiveConferenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndActiveConferenceRequest>): EndActiveConferenceRequest {
    const message = createBaseEndActiveConferenceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetConferenceRecordRequest(): GetConferenceRecordRequest {
  return { name: "" };
}

export const GetConferenceRecordRequest: MessageFns<GetConferenceRecordRequest> = {
  encode(message: GetConferenceRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConferenceRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConferenceRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConferenceRecordRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConferenceRecordRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConferenceRecordRequest>): GetConferenceRecordRequest {
    return GetConferenceRecordRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConferenceRecordRequest>): GetConferenceRecordRequest {
    const message = createBaseGetConferenceRecordRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConferenceRecordsRequest(): ListConferenceRecordsRequest {
  return { pageSize: 0, pageToken: "", filter: "" };
}

export const ListConferenceRecordsRequest: MessageFns<ListConferenceRecordsRequest> = {
  encode(message: ListConferenceRecordsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConferenceRecordsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConferenceRecordsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConferenceRecordsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListConferenceRecordsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConferenceRecordsRequest>): ListConferenceRecordsRequest {
    return ListConferenceRecordsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConferenceRecordsRequest>): ListConferenceRecordsRequest {
    const message = createBaseListConferenceRecordsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListConferenceRecordsResponse(): ListConferenceRecordsResponse {
  return { conferenceRecords: [], nextPageToken: "" };
}

export const ListConferenceRecordsResponse: MessageFns<ListConferenceRecordsResponse> = {
  encode(message: ListConferenceRecordsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conferenceRecords) {
      ConferenceRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConferenceRecordsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConferenceRecordsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conferenceRecords.push(ConferenceRecord.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConferenceRecordsResponse {
    return {
      conferenceRecords: globalThis.Array.isArray(object?.conferenceRecords)
        ? object.conferenceRecords.map((e: any) => ConferenceRecord.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConferenceRecordsResponse): unknown {
    const obj: any = {};
    if (message.conferenceRecords?.length) {
      obj.conferenceRecords = message.conferenceRecords.map((e) => ConferenceRecord.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConferenceRecordsResponse>): ListConferenceRecordsResponse {
    return ListConferenceRecordsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConferenceRecordsResponse>): ListConferenceRecordsResponse {
    const message = createBaseListConferenceRecordsResponse();
    message.conferenceRecords = object.conferenceRecords?.map((e) => ConferenceRecord.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetParticipantRequest(): GetParticipantRequest {
  return { name: "" };
}

export const GetParticipantRequest: MessageFns<GetParticipantRequest> = {
  encode(message: GetParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParticipantRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetParticipantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    return GetParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    const message = createBaseGetParticipantRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListParticipantsRequest(): ListParticipantsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListParticipantsRequest: MessageFns<ListParticipantsRequest> = {
  encode(message: ListParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListParticipantsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    return ListParticipantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    const message = createBaseListParticipantsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListParticipantsResponse(): ListParticipantsResponse {
  return { participants: [], nextPageToken: "", totalSize: 0 };
}

export const ListParticipantsResponse: MessageFns<ListParticipantsResponse> = {
  encode(message: ListParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      Participant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participants.push(Participant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => Participant.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => Participant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    return ListParticipantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    const message = createBaseListParticipantsResponse();
    message.participants = object.participants?.map((e) => Participant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetParticipantSessionRequest(): GetParticipantSessionRequest {
  return { name: "" };
}

export const GetParticipantSessionRequest: MessageFns<GetParticipantSessionRequest> = {
  encode(message: GetParticipantSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParticipantSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParticipantSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParticipantSessionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetParticipantSessionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetParticipantSessionRequest>): GetParticipantSessionRequest {
    return GetParticipantSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetParticipantSessionRequest>): GetParticipantSessionRequest {
    const message = createBaseGetParticipantSessionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListParticipantSessionsRequest(): ListParticipantSessionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListParticipantSessionsRequest: MessageFns<ListParticipantSessionsRequest> = {
  encode(message: ListParticipantSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantSessionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListParticipantSessionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantSessionsRequest>): ListParticipantSessionsRequest {
    return ListParticipantSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantSessionsRequest>): ListParticipantSessionsRequest {
    const message = createBaseListParticipantSessionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListParticipantSessionsResponse(): ListParticipantSessionsResponse {
  return { participantSessions: [], nextPageToken: "" };
}

export const ListParticipantSessionsResponse: MessageFns<ListParticipantSessionsResponse> = {
  encode(message: ListParticipantSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participantSessions) {
      ParticipantSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participantSessions.push(ParticipantSession.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantSessionsResponse {
    return {
      participantSessions: globalThis.Array.isArray(object?.participantSessions)
        ? object.participantSessions.map((e: any) => ParticipantSession.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListParticipantSessionsResponse): unknown {
    const obj: any = {};
    if (message.participantSessions?.length) {
      obj.participantSessions = message.participantSessions.map((e) => ParticipantSession.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantSessionsResponse>): ListParticipantSessionsResponse {
    return ListParticipantSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantSessionsResponse>): ListParticipantSessionsResponse {
    const message = createBaseListParticipantSessionsResponse();
    message.participantSessions = object.participantSessions?.map((e) => ParticipantSession.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetRecordingRequest(): GetRecordingRequest {
  return { name: "" };
}

export const GetRecordingRequest: MessageFns<GetRecordingRequest> = {
  encode(message: GetRecordingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecordingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecordingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRecordingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRecordingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRecordingRequest>): GetRecordingRequest {
    return GetRecordingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRecordingRequest>): GetRecordingRequest {
    const message = createBaseGetRecordingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRecordingsRequest(): ListRecordingsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRecordingsRequest: MessageFns<ListRecordingsRequest> = {
  encode(message: ListRecordingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecordingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecordingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecordingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRecordingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecordingsRequest>): ListRecordingsRequest {
    return ListRecordingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecordingsRequest>): ListRecordingsRequest {
    const message = createBaseListRecordingsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRecordingsResponse(): ListRecordingsResponse {
  return { recordings: [], nextPageToken: "" };
}

export const ListRecordingsResponse: MessageFns<ListRecordingsResponse> = {
  encode(message: ListRecordingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recordings) {
      Recording.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecordingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecordingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recordings.push(Recording.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecordingsResponse {
    return {
      recordings: globalThis.Array.isArray(object?.recordings)
        ? object.recordings.map((e: any) => Recording.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRecordingsResponse): unknown {
    const obj: any = {};
    if (message.recordings?.length) {
      obj.recordings = message.recordings.map((e) => Recording.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecordingsResponse>): ListRecordingsResponse {
    return ListRecordingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecordingsResponse>): ListRecordingsResponse {
    const message = createBaseListRecordingsResponse();
    message.recordings = object.recordings?.map((e) => Recording.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTranscriptRequest(): GetTranscriptRequest {
  return { name: "" };
}

export const GetTranscriptRequest: MessageFns<GetTranscriptRequest> = {
  encode(message: GetTranscriptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTranscriptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTranscriptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTranscriptRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTranscriptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTranscriptRequest>): GetTranscriptRequest {
    return GetTranscriptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTranscriptRequest>): GetTranscriptRequest {
    const message = createBaseGetTranscriptRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTranscriptsRequest(): ListTranscriptsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTranscriptsRequest: MessageFns<ListTranscriptsRequest> = {
  encode(message: ListTranscriptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTranscriptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTranscriptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTranscriptsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTranscriptsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTranscriptsRequest>): ListTranscriptsRequest {
    return ListTranscriptsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTranscriptsRequest>): ListTranscriptsRequest {
    const message = createBaseListTranscriptsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTranscriptsResponse(): ListTranscriptsResponse {
  return { transcripts: [], nextPageToken: "" };
}

export const ListTranscriptsResponse: MessageFns<ListTranscriptsResponse> = {
  encode(message: ListTranscriptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transcripts) {
      Transcript.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTranscriptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTranscriptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transcripts.push(Transcript.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTranscriptsResponse {
    return {
      transcripts: globalThis.Array.isArray(object?.transcripts)
        ? object.transcripts.map((e: any) => Transcript.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTranscriptsResponse): unknown {
    const obj: any = {};
    if (message.transcripts?.length) {
      obj.transcripts = message.transcripts.map((e) => Transcript.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTranscriptsResponse>): ListTranscriptsResponse {
    return ListTranscriptsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTranscriptsResponse>): ListTranscriptsResponse {
    const message = createBaseListTranscriptsResponse();
    message.transcripts = object.transcripts?.map((e) => Transcript.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTranscriptEntryRequest(): GetTranscriptEntryRequest {
  return { name: "" };
}

export const GetTranscriptEntryRequest: MessageFns<GetTranscriptEntryRequest> = {
  encode(message: GetTranscriptEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTranscriptEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTranscriptEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTranscriptEntryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTranscriptEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTranscriptEntryRequest>): GetTranscriptEntryRequest {
    return GetTranscriptEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTranscriptEntryRequest>): GetTranscriptEntryRequest {
    const message = createBaseGetTranscriptEntryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTranscriptEntriesRequest(): ListTranscriptEntriesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTranscriptEntriesRequest: MessageFns<ListTranscriptEntriesRequest> = {
  encode(message: ListTranscriptEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTranscriptEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTranscriptEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTranscriptEntriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTranscriptEntriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTranscriptEntriesRequest>): ListTranscriptEntriesRequest {
    return ListTranscriptEntriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTranscriptEntriesRequest>): ListTranscriptEntriesRequest {
    const message = createBaseListTranscriptEntriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTranscriptEntriesResponse(): ListTranscriptEntriesResponse {
  return { transcriptEntries: [], nextPageToken: "" };
}

export const ListTranscriptEntriesResponse: MessageFns<ListTranscriptEntriesResponse> = {
  encode(message: ListTranscriptEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transcriptEntries) {
      TranscriptEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTranscriptEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTranscriptEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transcriptEntries.push(TranscriptEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTranscriptEntriesResponse {
    return {
      transcriptEntries: globalThis.Array.isArray(object?.transcriptEntries)
        ? object.transcriptEntries.map((e: any) => TranscriptEntry.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTranscriptEntriesResponse): unknown {
    const obj: any = {};
    if (message.transcriptEntries?.length) {
      obj.transcriptEntries = message.transcriptEntries.map((e) => TranscriptEntry.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTranscriptEntriesResponse>): ListTranscriptEntriesResponse {
    return ListTranscriptEntriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTranscriptEntriesResponse>): ListTranscriptEntriesResponse {
    const message = createBaseListTranscriptEntriesResponse();
    message.transcriptEntries = object.transcriptEntries?.map((e) => TranscriptEntry.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** REST API for services dealing with spaces. */
export type SpacesServiceDefinition = typeof SpacesServiceDefinition;
export const SpacesServiceDefinition = {
  name: "SpacesService",
  fullName: "google.apps.meet.v2.SpacesService",
  methods: {
    /** Creates a space. */
    createSpace: {
      name: "CreateSpace",
      requestType: CreateSpaceRequest,
      requestStream: false,
      responseType: Space,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 115, 112, 97, 99, 101])],
          578365826: [
            Buffer.from([19, 58, 5, 115, 112, 97, 99, 101, 34, 10, 47, 118, 50, 47, 115, 112, 97, 99, 101, 115]),
          ],
        },
      },
    },
    /** Gets a space by `space_id` or `meeting_code`. */
    getSpace: {
      name: "GetSpace",
      requestType: GetSpaceRequest,
      requestStream: false,
      responseType: Space,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              21,
              18,
              19,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a space. */
    updateSpace: {
      name: "UpdateSpace",
      requestType: UpdateSpaceRequest,
      requestStream: false,
      responseType: Space,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 115, 112, 97, 99, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              34,
              58,
              5,
              115,
              112,
              97,
              99,
              101,
              50,
              25,
              47,
              118,
              50,
              47,
              123,
              115,
              112,
              97,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Ends an active conference (if there's one). */
    endActiveConference: {
      name: "EndActiveConference",
      requestType: EndActiveConferenceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              101,
              110,
              100,
              65,
              99,
              116,
              105,
              118,
              101,
              67,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SpacesServiceImplementation<CallContextExt = {}> {
  /** Creates a space. */
  createSpace(request: CreateSpaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Space>>;
  /** Gets a space by `space_id` or `meeting_code`. */
  getSpace(request: GetSpaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Space>>;
  /** Updates a space. */
  updateSpace(request: UpdateSpaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Space>>;
  /** Ends an active conference (if there's one). */
  endActiveConference(
    request: EndActiveConferenceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface SpacesServiceClient<CallOptionsExt = {}> {
  /** Creates a space. */
  createSpace(request: DeepPartial<CreateSpaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Space>;
  /** Gets a space by `space_id` or `meeting_code`. */
  getSpace(request: DeepPartial<GetSpaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Space>;
  /** Updates a space. */
  updateSpace(request: DeepPartial<UpdateSpaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Space>;
  /** Ends an active conference (if there's one). */
  endActiveConference(
    request: DeepPartial<EndActiveConferenceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

/** REST API for services dealing with conference records. */
export type ConferenceRecordsServiceDefinition = typeof ConferenceRecordsServiceDefinition;
export const ConferenceRecordsServiceDefinition = {
  name: "ConferenceRecordsService",
  fullName: "google.apps.meet.v2.ConferenceRecordsService",
  methods: {
    /** Gets a conference record by conference ID. */
    getConferenceRecord: {
      name: "GetConferenceRecord",
      requestType: GetConferenceRecordRequest,
      requestStream: false,
      responseType: ConferenceRecord,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the conference records. By default, ordered by start time and in
     * descending order.
     */
    listConferenceRecords: {
      name: "ListConferenceRecords",
      requestType: ListConferenceRecordsRequest,
      requestStream: false,
      responseType: ListConferenceRecordsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              18,
              21,
              47,
              118,
              50,
              47,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a participant by participant ID. */
    getParticipant: {
      name: "GetParticipant",
      requestType: GetParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the participants in a conference record. By default, ordered by join
     * time and in descending order. This API supports `fields` as standard
     * parameters like every other API. However, when the `fields` request
     * parameter is omitted, this API defaults to `'participants/*,
     * next_page_token'`.
     */
    listParticipants: {
      name: "ListParticipants",
      requestType: ListParticipantsRequest,
      requestStream: false,
      responseType: ListParticipantsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a participant session by participant session ID. */
    getParticipantSession: {
      name: "GetParticipantSession",
      requestType: GetParticipantSessionRequest,
      requestStream: false,
      responseType: ParticipantSession,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the participant sessions of a participant in a conference record. By
     * default, ordered by join time and in descending order. This API supports
     * `fields` as standard parameters like every other API. However, when the
     * `fields` request parameter is omitted this API defaults to
     * `'participantsessions/*, next_page_token'`.
     */
    listParticipantSessions: {
      name: "ListParticipantSessions",
      requestType: ListParticipantSessionsRequest,
      requestStream: false,
      responseType: ListParticipantSessionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a recording by recording ID. */
    getRecording: {
      name: "GetRecording",
      requestType: GetRecordingRequest,
      requestStream: false,
      responseType: Recording,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              114,
              101,
              99,
              111,
              114,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the recording resources from the conference record. By default,
     * ordered by start time and in ascending order.
     */
    listRecordings: {
      name: "ListRecordings",
      requestType: ListRecordingsRequest,
      requestStream: false,
      responseType: ListRecordingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              99,
              111,
              114,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a transcript by transcript ID. */
    getTranscript: {
      name: "GetTranscript",
      requestType: GetTranscriptRequest,
      requestStream: false,
      responseType: Transcript,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              116,
              114,
              97,
              110,
              115,
              99,
              114,
              105,
              112,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the set of transcripts from the conference record. By default,
     * ordered by start time and in ascending order.
     */
    listTranscripts: {
      name: "ListTranscripts",
      requestType: ListTranscriptsRequest,
      requestStream: false,
      responseType: ListTranscriptsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              97,
              110,
              115,
              99,
              114,
              105,
              112,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a `TranscriptEntry` resource by entry ID.
     *
     * Note: The transcript entries returned by the Google Meet API might not
     * match the transcription found in the Google Docs transcript file. This can
     * occur when the Google Docs transcript file is modified after generation.
     */
    getTranscriptEntry: {
      name: "GetTranscriptEntry",
      requestType: GetTranscriptEntryRequest,
      requestStream: false,
      responseType: TranscriptEntry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              116,
              114,
              97,
              110,
              115,
              99,
              114,
              105,
              112,
              116,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the structured transcript entries per transcript. By default, ordered
     * by start time and in ascending order.
     *
     * Note: The transcript entries returned by the Google Meet API might not
     * match the transcription found in the Google Docs transcript file. This can
     * occur when the Google Docs transcript file is modified after generation.
     */
    listTranscriptEntries: {
      name: "ListTranscriptEntries",
      requestType: ListTranscriptEntriesRequest,
      requestStream: false,
      responseType: ListTranscriptEntriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              110,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              47,
              116,
              114,
              97,
              110,
              115,
              99,
              114,
              105,
              112,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConferenceRecordsServiceImplementation<CallContextExt = {}> {
  /** Gets a conference record by conference ID. */
  getConferenceRecord(
    request: GetConferenceRecordRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConferenceRecord>>;
  /**
   * Lists the conference records. By default, ordered by start time and in
   * descending order.
   */
  listConferenceRecords(
    request: ListConferenceRecordsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConferenceRecordsResponse>>;
  /** Gets a participant by participant ID. */
  getParticipant(
    request: GetParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /**
   * Lists the participants in a conference record. By default, ordered by join
   * time and in descending order. This API supports `fields` as standard
   * parameters like every other API. However, when the `fields` request
   * parameter is omitted, this API defaults to `'participants/*,
   * next_page_token'`.
   */
  listParticipants(
    request: ListParticipantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListParticipantsResponse>>;
  /** Gets a participant session by participant session ID. */
  getParticipantSession(
    request: GetParticipantSessionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ParticipantSession>>;
  /**
   * Lists the participant sessions of a participant in a conference record. By
   * default, ordered by join time and in descending order. This API supports
   * `fields` as standard parameters like every other API. However, when the
   * `fields` request parameter is omitted this API defaults to
   * `'participantsessions/*, next_page_token'`.
   */
  listParticipantSessions(
    request: ListParticipantSessionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListParticipantSessionsResponse>>;
  /** Gets a recording by recording ID. */
  getRecording(request: GetRecordingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Recording>>;
  /**
   * Lists the recording resources from the conference record. By default,
   * ordered by start time and in ascending order.
   */
  listRecordings(
    request: ListRecordingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRecordingsResponse>>;
  /** Gets a transcript by transcript ID. */
  getTranscript(request: GetTranscriptRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Transcript>>;
  /**
   * Lists the set of transcripts from the conference record. By default,
   * ordered by start time and in ascending order.
   */
  listTranscripts(
    request: ListTranscriptsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTranscriptsResponse>>;
  /**
   * Gets a `TranscriptEntry` resource by entry ID.
   *
   * Note: The transcript entries returned by the Google Meet API might not
   * match the transcription found in the Google Docs transcript file. This can
   * occur when the Google Docs transcript file is modified after generation.
   */
  getTranscriptEntry(
    request: GetTranscriptEntryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TranscriptEntry>>;
  /**
   * Lists the structured transcript entries per transcript. By default, ordered
   * by start time and in ascending order.
   *
   * Note: The transcript entries returned by the Google Meet API might not
   * match the transcription found in the Google Docs transcript file. This can
   * occur when the Google Docs transcript file is modified after generation.
   */
  listTranscriptEntries(
    request: ListTranscriptEntriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTranscriptEntriesResponse>>;
}

export interface ConferenceRecordsServiceClient<CallOptionsExt = {}> {
  /** Gets a conference record by conference ID. */
  getConferenceRecord(
    request: DeepPartial<GetConferenceRecordRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConferenceRecord>;
  /**
   * Lists the conference records. By default, ordered by start time and in
   * descending order.
   */
  listConferenceRecords(
    request: DeepPartial<ListConferenceRecordsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConferenceRecordsResponse>;
  /** Gets a participant by participant ID. */
  getParticipant(
    request: DeepPartial<GetParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /**
   * Lists the participants in a conference record. By default, ordered by join
   * time and in descending order. This API supports `fields` as standard
   * parameters like every other API. However, when the `fields` request
   * parameter is omitted, this API defaults to `'participants/*,
   * next_page_token'`.
   */
  listParticipants(
    request: DeepPartial<ListParticipantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListParticipantsResponse>;
  /** Gets a participant session by participant session ID. */
  getParticipantSession(
    request: DeepPartial<GetParticipantSessionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ParticipantSession>;
  /**
   * Lists the participant sessions of a participant in a conference record. By
   * default, ordered by join time and in descending order. This API supports
   * `fields` as standard parameters like every other API. However, when the
   * `fields` request parameter is omitted this API defaults to
   * `'participantsessions/*, next_page_token'`.
   */
  listParticipantSessions(
    request: DeepPartial<ListParticipantSessionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListParticipantSessionsResponse>;
  /** Gets a recording by recording ID. */
  getRecording(request: DeepPartial<GetRecordingRequest>, options?: CallOptions & CallOptionsExt): Promise<Recording>;
  /**
   * Lists the recording resources from the conference record. By default,
   * ordered by start time and in ascending order.
   */
  listRecordings(
    request: DeepPartial<ListRecordingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRecordingsResponse>;
  /** Gets a transcript by transcript ID. */
  getTranscript(
    request: DeepPartial<GetTranscriptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Transcript>;
  /**
   * Lists the set of transcripts from the conference record. By default,
   * ordered by start time and in ascending order.
   */
  listTranscripts(
    request: DeepPartial<ListTranscriptsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTranscriptsResponse>;
  /**
   * Gets a `TranscriptEntry` resource by entry ID.
   *
   * Note: The transcript entries returned by the Google Meet API might not
   * match the transcription found in the Google Docs transcript file. This can
   * occur when the Google Docs transcript file is modified after generation.
   */
  getTranscriptEntry(
    request: DeepPartial<GetTranscriptEntryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TranscriptEntry>;
  /**
   * Lists the structured transcript entries per transcript. By default, ordered
   * by start time and in ascending order.
   *
   * Note: The transcript entries returned by the Google Meet API might not
   * match the transcription found in the Google Docs transcript file. This can
   * occur when the Google Docs transcript file is modified after generation.
   */
  listTranscriptEntries(
    request: DeepPartial<ListTranscriptEntriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTranscriptEntriesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
