// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/meet/v2beta/resource.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.apps.meet.v2beta";

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Virtual place where conferences are held. Only one active conference can be
 * held in one space at any given time.
 */
export interface Space {
  /**
   * Immutable. Resource name of the space.
   * Format: `spaces/{space}`
   */
  name: string;
  /**
   * Output only. URI used to join meeting, such as
   * `https://meet.google.com/abc-mnop-xyz`.
   */
  meetingUri: string;
  /**
   * Output only. Type friendly code to join the meeting. Format:
   * `[a-z]+-[a-z]+-[a-z]+` such as `abc-mnop-xyz`. The maximum length is 128
   * characters. Can ONLY be used as alias of the space ID to get the space.
   */
  meetingCode: string;
  /** Configuration pertaining to the meeting space. */
  config:
    | SpaceConfig
    | undefined;
  /** Active conference if it exists. */
  activeConference: ActiveConference | undefined;
}

/** Active conference. */
export interface ActiveConference {
  /**
   * Output only. Reference to 'ConferenceRecord' resource.
   * Format: `conferenceRecords/{conference_record}` where `{conference_record}`
   * is a unique id for each instance of a call within a space.
   */
  conferenceRecord: string;
}

/** The configuration pertaining to a meeting space. */
export interface SpaceConfig {
  /**
   * Access type of the meeting space that determines who can join without
   * knocking. Default: The user's default access settings.  Controlled by the
   * user's admin for enterprise users or RESTRICTED.
   */
  accessType: SpaceConfig_AccessType;
  /**
   * Defines the entry points that can be used to join meetings hosted in this
   * meeting space.
   * Default: EntryPointAccess.ALL
   */
  entryPointAccess: SpaceConfig_EntryPointAccess;
}

/** Possible access types for a meeting space. */
export enum SpaceConfig_AccessType {
  /**
   * ACCESS_TYPE_UNSPECIFIED - Default value specified by the user's organization.
   * Note: This is never returned, as the configured access type is
   * returned instead.
   */
  ACCESS_TYPE_UNSPECIFIED = 0,
  /**
   * OPEN - Anyone with the join information (for example, the URL or phone access
   * information) can join without knocking.
   */
  OPEN = 1,
  /**
   * TRUSTED - Members of the host's organization, invited external users, and dial-in
   * users can join without knocking. Everyone else must knock.
   */
  TRUSTED = 2,
  /** RESTRICTED - Only invitees can join without knocking. Everyone else must knock. */
  RESTRICTED = 3,
  UNRECOGNIZED = -1,
}

export function spaceConfig_AccessTypeFromJSON(object: any): SpaceConfig_AccessType {
  switch (object) {
    case 0:
    case "ACCESS_TYPE_UNSPECIFIED":
      return SpaceConfig_AccessType.ACCESS_TYPE_UNSPECIFIED;
    case 1:
    case "OPEN":
      return SpaceConfig_AccessType.OPEN;
    case 2:
    case "TRUSTED":
      return SpaceConfig_AccessType.TRUSTED;
    case 3:
    case "RESTRICTED":
      return SpaceConfig_AccessType.RESTRICTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpaceConfig_AccessType.UNRECOGNIZED;
  }
}

export function spaceConfig_AccessTypeToJSON(object: SpaceConfig_AccessType): string {
  switch (object) {
    case SpaceConfig_AccessType.ACCESS_TYPE_UNSPECIFIED:
      return "ACCESS_TYPE_UNSPECIFIED";
    case SpaceConfig_AccessType.OPEN:
      return "OPEN";
    case SpaceConfig_AccessType.TRUSTED:
      return "TRUSTED";
    case SpaceConfig_AccessType.RESTRICTED:
      return "RESTRICTED";
    case SpaceConfig_AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Entry points that can be used to join a meeting.  Example:
 * `meet.google.com`, the Embed SDK Web, or a mobile application.
 */
export enum SpaceConfig_EntryPointAccess {
  /** ENTRY_POINT_ACCESS_UNSPECIFIED - Unused. */
  ENTRY_POINT_ACCESS_UNSPECIFIED = 0,
  /** ALL - All entry points are allowed. */
  ALL = 1,
  /**
   * CREATOR_APP_ONLY - Only entry points owned by the Google Cloud project that created the
   * space can be used to join meetings in this space.  Apps can use the Embed
   * SDK Web or mobile Meet SDKs to create owned entry points.
   */
  CREATOR_APP_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function spaceConfig_EntryPointAccessFromJSON(object: any): SpaceConfig_EntryPointAccess {
  switch (object) {
    case 0:
    case "ENTRY_POINT_ACCESS_UNSPECIFIED":
      return SpaceConfig_EntryPointAccess.ENTRY_POINT_ACCESS_UNSPECIFIED;
    case 1:
    case "ALL":
      return SpaceConfig_EntryPointAccess.ALL;
    case 2:
    case "CREATOR_APP_ONLY":
      return SpaceConfig_EntryPointAccess.CREATOR_APP_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpaceConfig_EntryPointAccess.UNRECOGNIZED;
  }
}

export function spaceConfig_EntryPointAccessToJSON(object: SpaceConfig_EntryPointAccess): string {
  switch (object) {
    case SpaceConfig_EntryPointAccess.ENTRY_POINT_ACCESS_UNSPECIFIED:
      return "ENTRY_POINT_ACCESS_UNSPECIFIED";
    case SpaceConfig_EntryPointAccess.ALL:
      return "ALL";
    case SpaceConfig_EntryPointAccess.CREATOR_APP_ONLY:
      return "CREATOR_APP_ONLY";
    case SpaceConfig_EntryPointAccess.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Single instance of a meeting held in a space.
 */
export interface ConferenceRecord {
  /**
   * Identifier. Resource name of the conference record.
   * Format: `conferenceRecords/{conference_record}` where `{conference_record}`
   * is a unique id for each instance of a call within a space.
   */
  name: string;
  /** Output only. Timestamp when the conference started, always set. */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp when the conference ended.
   * Set for past conferences. Unset if the conference is ongoing.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Output only. Server enforced expire time for when this conference record
   * resource is deleted. The resource is deleted 30 days after the conference
   * ends.
   */
  expireTime:
    | Date
    | undefined;
  /** Output only. The space where the conference was held. */
  space: string;
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * User who attended or is attending a conference.
 */
export interface Participant {
  /** Signed-in user. */
  signedinUser?:
    | SignedinUser
    | undefined;
  /** Anonymous user. */
  anonymousUser?:
    | AnonymousUser
    | undefined;
  /** User who calls in from their phone. */
  phoneUser?:
    | PhoneUser
    | undefined;
  /**
   * Output only. Resource name of the participant.
   * Format: `conferenceRecords/{conference_record}/participants/{participant}`
   */
  name: string;
  /**
   * Output only. Time when the participant joined the meeting for the first
   * time.
   */
  earliestStartTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the participant left the meeting for the last time.
   * This can be null if it is an active meeting.
   */
  latestEndTime: Date | undefined;
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Refers to each unique join/leave session when a user joins a conference from
 * a device. Note that any time a user joins the conference a new unique ID is
 * assigned. That means if a user joins a space multiple times from the same
 * device, they're assigned different IDs, and are also be treated as different
 * participant sessions.
 */
export interface ParticipantSession {
  /** Identifier. Session id. */
  name: string;
  /** Output only. Timestamp when the user session started. */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp when the user session ended. Unset if the user
   * session hasnâ€™t ended.
   */
  endTime: Date | undefined;
}

/**
 * A signed-in user can be:
 * a) An individual joining from a personal computer, mobile device, or through
 * companion mode.
 * b) A robot account used by conference room devices.
 */
export interface SignedinUser {
  /**
   * Output only. Unique ID for the user. Interoperable with Admin SDK API and
   * People API. Format: `users/{user}`
   */
  user: string;
  /**
   * Output only. For a personal device, it's the user's first and last name.
   * For a robot account, it's the admin specified device name. For example,
   * "Altostrat Room".
   */
  displayName: string;
}

/** User who joins anonymously (meaning not signed into a Google Account). */
export interface AnonymousUser {
  /** Output only. User provided name when they join a conference anonymously. */
  displayName: string;
}

/**
 * User dialing in from a phone where the user's identity is unknown because
 * they haven't signed in with a Google Account.
 */
export interface PhoneUser {
  /** Output only. Partially redacted user's phone number when they call in. */
  displayName: string;
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Metadata about a recording created during a conference.
 */
export interface Recording {
  /**
   * Output only. Recording is saved to Google Drive as an mp4 file. The
   * `drive_destination` includes the Drive `fileId` that can be used to
   * download the file using the `files.get` method of the Drive API.
   */
  driveDestination?:
    | DriveDestination
    | undefined;
  /**
   * Output only. Resource name of the recording.
   * Format: `conferenceRecords/{conference_record}/recordings/{recording}`
   * where `{recording}` is a 1:1 mapping to each unique recording session
   * during the conference.
   */
  name: string;
  /** Output only. Current state. */
  state: Recording_State;
  /** Output only. Timestamp when the recording started. */
  startTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the recording ended. */
  endTime: Date | undefined;
}

/** Current state of the recording session. */
export enum Recording_State {
  /** STATE_UNSPECIFIED - Default, never used. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - An active recording session has started. */
  STARTED = 1,
  /**
   * ENDED - This recording session has ended, but the recording file hasn't been
   * generated yet.
   */
  ENDED = 2,
  /** FILE_GENERATED - Recording file is generated and ready to download. */
  FILE_GENERATED = 3,
  UNRECOGNIZED = -1,
}

export function recording_StateFromJSON(object: any): Recording_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Recording_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return Recording_State.STARTED;
    case 2:
    case "ENDED":
      return Recording_State.ENDED;
    case 3:
    case "FILE_GENERATED":
      return Recording_State.FILE_GENERATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Recording_State.UNRECOGNIZED;
  }
}

export function recording_StateToJSON(object: Recording_State): string {
  switch (object) {
    case Recording_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Recording_State.STARTED:
      return "STARTED";
    case Recording_State.ENDED:
      return "ENDED";
    case Recording_State.FILE_GENERATED:
      return "FILE_GENERATED";
    case Recording_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Export location where a recording file is saved in Google Drive. */
export interface DriveDestination {
  /**
   * Output only. The `fileId` for the underlying MP4 file. For example,
   * "1kuceFZohVoCh6FulBHxwy6I15Ogpc4hP". Use `$ GET
   * https://www.googleapis.com/drive/v3/files/{$fileId}?alt=media` to download
   * the blob. For more information, see
   * https://developers.google.com/drive/api/v3/reference/files/get.
   */
  file: string;
  /**
   * Output only. Link used to play back the recording file in the browser. For
   * example, `https://drive.google.com/file/d/{$fileId}/view`.
   */
  exportUri: string;
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Metadata for a transcript generated from a conference. It refers to the ASR
 * (Automatic Speech Recognition) result of user's speech during the conference.
 */
export interface Transcript {
  /** Output only. Where the Google Docs transcript is saved. */
  docsDestination?:
    | DocsDestination
    | undefined;
  /**
   * Output only. Resource name of the transcript.
   * Format: `conferenceRecords/{conference_record}/transcripts/{transcript}`,
   * where `{transcript}` is a 1:1 mapping to each unique transcription session
   * of the conference.
   */
  name: string;
  /** Output only. Current state. */
  state: Transcript_State;
  /** Output only. Timestamp when the transcript started. */
  startTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the transcript stopped. */
  endTime: Date | undefined;
}

/** Current state of the transcript session. */
export enum Transcript_State {
  /** STATE_UNSPECIFIED - Default, never used. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - An active transcript session has started. */
  STARTED = 1,
  /**
   * ENDED - This transcript session has ended, but the transcript file hasn't been
   * generated yet.
   */
  ENDED = 2,
  /** FILE_GENERATED - Transcript file is generated and ready to download. */
  FILE_GENERATED = 3,
  UNRECOGNIZED = -1,
}

export function transcript_StateFromJSON(object: any): Transcript_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Transcript_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return Transcript_State.STARTED;
    case 2:
    case "ENDED":
      return Transcript_State.ENDED;
    case 3:
    case "FILE_GENERATED":
      return Transcript_State.FILE_GENERATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transcript_State.UNRECOGNIZED;
  }
}

export function transcript_StateToJSON(object: Transcript_State): string {
  switch (object) {
    case Transcript_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Transcript_State.STARTED:
      return "STARTED";
    case Transcript_State.ENDED:
      return "ENDED";
    case Transcript_State.FILE_GENERATED:
      return "FILE_GENERATED";
    case Transcript_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Google Docs location where the transcript file is saved. */
export interface DocsDestination {
  /**
   * Output only. The document ID for the underlying Google Docs transcript
   * file. For example, "1kuceFZohVoCh6FulBHxwy6I15Ogpc4hP". Use the
   * `documents.get` method of the Google Docs API
   * (https://developers.google.com/docs/api/reference/rest/v1/documents/get) to
   * fetch the content.
   */
  document: string;
  /**
   * Output only. URI for the Google Docs transcript file. Use
   * `https://docs.google.com/document/d/{$DocumentId}/view` to browse the
   * transcript in the browser.
   */
  exportUri: string;
}

/**
 * [Developer Preview](https://developers.google.com/workspace/preview).
 * Single entry for one userâ€™s speech during a transcript session.
 */
export interface TranscriptEntry {
  /**
   * Output only. Resource name of the entry. Format:
   * "conferenceRecords/{conference_record}/transcripts/{transcript}/entries/{entry}"
   */
  name: string;
  /** Output only. Refer to the participant who speaks. */
  participant: string;
  /**
   * Output only. The transcribed text of the participant's voice, at maximum
   * 10K words. Note that the limit is subject to change.
   */
  text: string;
  /**
   * Output only. Language of spoken text, such as "en-US".
   * IETF BCP 47 syntax (https://tools.ietf.org/html/bcp47)
   */
  languageCode: string;
  /** Output only. Timestamp when the transcript entry started. */
  startTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the transcript entry ended. */
  endTime: Date | undefined;
}

function createBaseSpace(): Space {
  return { name: "", meetingUri: "", meetingCode: "", config: undefined, activeConference: undefined };
}

export const Space: MessageFns<Space> = {
  encode(message: Space, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.meetingUri !== "") {
      writer.uint32(18).string(message.meetingUri);
    }
    if (message.meetingCode !== "") {
      writer.uint32(26).string(message.meetingCode);
    }
    if (message.config !== undefined) {
      SpaceConfig.encode(message.config, writer.uint32(42).fork()).join();
    }
    if (message.activeConference !== undefined) {
      ActiveConference.encode(message.activeConference, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Space {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.meetingUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.meetingCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.config = SpaceConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.activeConference = ActiveConference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Space {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      meetingUri: isSet(object.meetingUri) ? globalThis.String(object.meetingUri) : "",
      meetingCode: isSet(object.meetingCode) ? globalThis.String(object.meetingCode) : "",
      config: isSet(object.config) ? SpaceConfig.fromJSON(object.config) : undefined,
      activeConference: isSet(object.activeConference) ? ActiveConference.fromJSON(object.activeConference) : undefined,
    };
  },

  toJSON(message: Space): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.meetingUri !== "") {
      obj.meetingUri = message.meetingUri;
    }
    if (message.meetingCode !== "") {
      obj.meetingCode = message.meetingCode;
    }
    if (message.config !== undefined) {
      obj.config = SpaceConfig.toJSON(message.config);
    }
    if (message.activeConference !== undefined) {
      obj.activeConference = ActiveConference.toJSON(message.activeConference);
    }
    return obj;
  },

  create(base?: DeepPartial<Space>): Space {
    return Space.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Space>): Space {
    const message = createBaseSpace();
    message.name = object.name ?? "";
    message.meetingUri = object.meetingUri ?? "";
    message.meetingCode = object.meetingCode ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? SpaceConfig.fromPartial(object.config)
      : undefined;
    message.activeConference = (object.activeConference !== undefined && object.activeConference !== null)
      ? ActiveConference.fromPartial(object.activeConference)
      : undefined;
    return message;
  },
};

function createBaseActiveConference(): ActiveConference {
  return { conferenceRecord: "" };
}

export const ActiveConference: MessageFns<ActiveConference> = {
  encode(message: ActiveConference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conferenceRecord !== "") {
      writer.uint32(10).string(message.conferenceRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveConference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveConference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conferenceRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveConference {
    return { conferenceRecord: isSet(object.conferenceRecord) ? globalThis.String(object.conferenceRecord) : "" };
  },

  toJSON(message: ActiveConference): unknown {
    const obj: any = {};
    if (message.conferenceRecord !== "") {
      obj.conferenceRecord = message.conferenceRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveConference>): ActiveConference {
    return ActiveConference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveConference>): ActiveConference {
    const message = createBaseActiveConference();
    message.conferenceRecord = object.conferenceRecord ?? "";
    return message;
  },
};

function createBaseSpaceConfig(): SpaceConfig {
  return { accessType: 0, entryPointAccess: 0 };
}

export const SpaceConfig: MessageFns<SpaceConfig> = {
  encode(message: SpaceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessType !== 0) {
      writer.uint32(8).int32(message.accessType);
    }
    if (message.entryPointAccess !== 0) {
      writer.uint32(16).int32(message.entryPointAccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpaceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accessType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entryPointAccess = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceConfig {
    return {
      accessType: isSet(object.accessType) ? spaceConfig_AccessTypeFromJSON(object.accessType) : 0,
      entryPointAccess: isSet(object.entryPointAccess)
        ? spaceConfig_EntryPointAccessFromJSON(object.entryPointAccess)
        : 0,
    };
  },

  toJSON(message: SpaceConfig): unknown {
    const obj: any = {};
    if (message.accessType !== 0) {
      obj.accessType = spaceConfig_AccessTypeToJSON(message.accessType);
    }
    if (message.entryPointAccess !== 0) {
      obj.entryPointAccess = spaceConfig_EntryPointAccessToJSON(message.entryPointAccess);
    }
    return obj;
  },

  create(base?: DeepPartial<SpaceConfig>): SpaceConfig {
    return SpaceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpaceConfig>): SpaceConfig {
    const message = createBaseSpaceConfig();
    message.accessType = object.accessType ?? 0;
    message.entryPointAccess = object.entryPointAccess ?? 0;
    return message;
  },
};

function createBaseConferenceRecord(): ConferenceRecord {
  return { name: "", startTime: undefined, endTime: undefined, expireTime: undefined, space: "" };
}

export const ConferenceRecord: MessageFns<ConferenceRecord> = {
  encode(message: ConferenceRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(34).fork()).join();
    }
    if (message.space !== "") {
      writer.uint32(42).string(message.space);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConferenceRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConferenceRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.space = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConferenceRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      space: isSet(object.space) ? globalThis.String(object.space) : "",
    };
  },

  toJSON(message: ConferenceRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.space !== "") {
      obj.space = message.space;
    }
    return obj;
  },

  create(base?: DeepPartial<ConferenceRecord>): ConferenceRecord {
    return ConferenceRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConferenceRecord>): ConferenceRecord {
    const message = createBaseConferenceRecord();
    message.name = object.name ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.space = object.space ?? "";
    return message;
  },
};

function createBaseParticipant(): Participant {
  return {
    signedinUser: undefined,
    anonymousUser: undefined,
    phoneUser: undefined,
    name: "",
    earliestStartTime: undefined,
    latestEndTime: undefined,
  };
}

export const Participant: MessageFns<Participant> = {
  encode(message: Participant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedinUser !== undefined) {
      SignedinUser.encode(message.signedinUser, writer.uint32(34).fork()).join();
    }
    if (message.anonymousUser !== undefined) {
      AnonymousUser.encode(message.anonymousUser, writer.uint32(42).fork()).join();
    }
    if (message.phoneUser !== undefined) {
      PhoneUser.encode(message.phoneUser, writer.uint32(50).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.earliestStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStartTime), writer.uint32(58).fork()).join();
    }
    if (message.latestEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.latestEndTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signedinUser = SignedinUser.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.anonymousUser = AnonymousUser.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.phoneUser = PhoneUser.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.earliestStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latestEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant {
    return {
      signedinUser: isSet(object.signedinUser) ? SignedinUser.fromJSON(object.signedinUser) : undefined,
      anonymousUser: isSet(object.anonymousUser) ? AnonymousUser.fromJSON(object.anonymousUser) : undefined,
      phoneUser: isSet(object.phoneUser) ? PhoneUser.fromJSON(object.phoneUser) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      earliestStartTime: isSet(object.earliestStartTime) ? fromJsonTimestamp(object.earliestStartTime) : undefined,
      latestEndTime: isSet(object.latestEndTime) ? fromJsonTimestamp(object.latestEndTime) : undefined,
    };
  },

  toJSON(message: Participant): unknown {
    const obj: any = {};
    if (message.signedinUser !== undefined) {
      obj.signedinUser = SignedinUser.toJSON(message.signedinUser);
    }
    if (message.anonymousUser !== undefined) {
      obj.anonymousUser = AnonymousUser.toJSON(message.anonymousUser);
    }
    if (message.phoneUser !== undefined) {
      obj.phoneUser = PhoneUser.toJSON(message.phoneUser);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.earliestStartTime !== undefined) {
      obj.earliestStartTime = message.earliestStartTime.toISOString();
    }
    if (message.latestEndTime !== undefined) {
      obj.latestEndTime = message.latestEndTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Participant>): Participant {
    return Participant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Participant>): Participant {
    const message = createBaseParticipant();
    message.signedinUser = (object.signedinUser !== undefined && object.signedinUser !== null)
      ? SignedinUser.fromPartial(object.signedinUser)
      : undefined;
    message.anonymousUser = (object.anonymousUser !== undefined && object.anonymousUser !== null)
      ? AnonymousUser.fromPartial(object.anonymousUser)
      : undefined;
    message.phoneUser = (object.phoneUser !== undefined && object.phoneUser !== null)
      ? PhoneUser.fromPartial(object.phoneUser)
      : undefined;
    message.name = object.name ?? "";
    message.earliestStartTime = object.earliestStartTime ?? undefined;
    message.latestEndTime = object.latestEndTime ?? undefined;
    return message;
  },
};

function createBaseParticipantSession(): ParticipantSession {
  return { name: "", startTime: undefined, endTime: undefined };
}

export const ParticipantSession: MessageFns<ParticipantSession> = {
  encode(message: ParticipantSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParticipantSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipantSession {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ParticipantSession): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ParticipantSession>): ParticipantSession {
    return ParticipantSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParticipantSession>): ParticipantSession {
    const message = createBaseParticipantSession();
    message.name = object.name ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseSignedinUser(): SignedinUser {
  return { user: "", displayName: "" };
}

export const SignedinUser: MessageFns<SignedinUser> = {
  encode(message: SignedinUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedinUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedinUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedinUser {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: SignedinUser): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedinUser>): SignedinUser {
    return SignedinUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedinUser>): SignedinUser {
    const message = createBaseSignedinUser();
    message.user = object.user ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseAnonymousUser(): AnonymousUser {
  return { displayName: "" };
}

export const AnonymousUser: MessageFns<AnonymousUser> = {
  encode(message: AnonymousUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnonymousUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnonymousUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnonymousUser {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: AnonymousUser): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<AnonymousUser>): AnonymousUser {
    return AnonymousUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnonymousUser>): AnonymousUser {
    const message = createBaseAnonymousUser();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBasePhoneUser(): PhoneUser {
  return { displayName: "" };
}

export const PhoneUser: MessageFns<PhoneUser> = {
  encode(message: PhoneUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneUser {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: PhoneUser): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<PhoneUser>): PhoneUser {
    return PhoneUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhoneUser>): PhoneUser {
    const message = createBasePhoneUser();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseRecording(): Recording {
  return { driveDestination: undefined, name: "", state: 0, startTime: undefined, endTime: undefined };
}

export const Recording: MessageFns<Recording> = {
  encode(message: Recording, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driveDestination !== undefined) {
      DriveDestination.encode(message.driveDestination, writer.uint32(50).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recording {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecording();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.driveDestination = DriveDestination.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recording {
    return {
      driveDestination: isSet(object.driveDestination) ? DriveDestination.fromJSON(object.driveDestination) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? recording_StateFromJSON(object.state) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Recording): unknown {
    const obj: any = {};
    if (message.driveDestination !== undefined) {
      obj.driveDestination = DriveDestination.toJSON(message.driveDestination);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = recording_StateToJSON(message.state);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Recording>): Recording {
    return Recording.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Recording>): Recording {
    const message = createBaseRecording();
    message.driveDestination = (object.driveDestination !== undefined && object.driveDestination !== null)
      ? DriveDestination.fromPartial(object.driveDestination)
      : undefined;
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseDriveDestination(): DriveDestination {
  return { file: "", exportUri: "" };
}

export const DriveDestination: MessageFns<DriveDestination> = {
  encode(message: DriveDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== "") {
      writer.uint32(10).string(message.file);
    }
    if (message.exportUri !== "") {
      writer.uint32(18).string(message.exportUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.file = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exportUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveDestination {
    return {
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      exportUri: isSet(object.exportUri) ? globalThis.String(object.exportUri) : "",
    };
  },

  toJSON(message: DriveDestination): unknown {
    const obj: any = {};
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.exportUri !== "") {
      obj.exportUri = message.exportUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DriveDestination>): DriveDestination {
    return DriveDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DriveDestination>): DriveDestination {
    const message = createBaseDriveDestination();
    message.file = object.file ?? "";
    message.exportUri = object.exportUri ?? "";
    return message;
  },
};

function createBaseTranscript(): Transcript {
  return { docsDestination: undefined, name: "", state: 0, startTime: undefined, endTime: undefined };
}

export const Transcript: MessageFns<Transcript> = {
  encode(message: Transcript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.docsDestination !== undefined) {
      DocsDestination.encode(message.docsDestination, writer.uint32(50).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transcript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.docsDestination = DocsDestination.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transcript {
    return {
      docsDestination: isSet(object.docsDestination) ? DocsDestination.fromJSON(object.docsDestination) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? transcript_StateFromJSON(object.state) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Transcript): unknown {
    const obj: any = {};
    if (message.docsDestination !== undefined) {
      obj.docsDestination = DocsDestination.toJSON(message.docsDestination);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = transcript_StateToJSON(message.state);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Transcript>): Transcript {
    return Transcript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transcript>): Transcript {
    const message = createBaseTranscript();
    message.docsDestination = (object.docsDestination !== undefined && object.docsDestination !== null)
      ? DocsDestination.fromPartial(object.docsDestination)
      : undefined;
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseDocsDestination(): DocsDestination {
  return { document: "", exportUri: "" };
}

export const DocsDestination: MessageFns<DocsDestination> = {
  encode(message: DocsDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    if (message.exportUri !== "") {
      writer.uint32(18).string(message.exportUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocsDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocsDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exportUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocsDestination {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      exportUri: isSet(object.exportUri) ? globalThis.String(object.exportUri) : "",
    };
  },

  toJSON(message: DocsDestination): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.exportUri !== "") {
      obj.exportUri = message.exportUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DocsDestination>): DocsDestination {
    return DocsDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocsDestination>): DocsDestination {
    const message = createBaseDocsDestination();
    message.document = object.document ?? "";
    message.exportUri = object.exportUri ?? "";
    return message;
  },
};

function createBaseTranscriptEntry(): TranscriptEntry {
  return { name: "", participant: "", text: "", languageCode: "", startTime: undefined, endTime: undefined };
}

export const TranscriptEntry: MessageFns<TranscriptEntry> = {
  encode(message: TranscriptEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.participant !== "") {
      writer.uint32(18).string(message.participant);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TranscriptEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptEntry>): TranscriptEntry {
    return TranscriptEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptEntry>): TranscriptEntry {
    const message = createBaseTranscriptEntry();
    message.name = object.name ?? "";
    message.participant = object.participant ?? "";
    message.text = object.text ?? "";
    message.languageCode = object.languageCode ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
