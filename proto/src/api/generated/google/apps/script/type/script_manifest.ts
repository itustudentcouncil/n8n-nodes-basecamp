// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/script/type/script_manifest.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../../protobuf/struct.js";
import { AddOnWidgetSet } from "./addon_widget_set.js";
import { HomepageExtensionPoint, UniversalActionExtensionPoint } from "./extension_point.js";

export const protobufPackage = "google.apps.script.type";

/** Authorization header sent in add-on HTTP requests */
export enum HttpAuthorizationHeader {
  /** HTTP_AUTHORIZATION_HEADER_UNSPECIFIED - Default value, equivalent to `SYSTEM_ID_TOKEN` */
  HTTP_AUTHORIZATION_HEADER_UNSPECIFIED = 0,
  /**
   * SYSTEM_ID_TOKEN - Send an ID token for the project-specific Google Workspace Add-ons system
   * service account (default)
   */
  SYSTEM_ID_TOKEN = 1,
  /** USER_ID_TOKEN - Send an ID token for the end user */
  USER_ID_TOKEN = 2,
  /** NONE - Do not send an Authentication header */
  NONE = 3,
  UNRECOGNIZED = -1,
}

export function httpAuthorizationHeaderFromJSON(object: any): HttpAuthorizationHeader {
  switch (object) {
    case 0:
    case "HTTP_AUTHORIZATION_HEADER_UNSPECIFIED":
      return HttpAuthorizationHeader.HTTP_AUTHORIZATION_HEADER_UNSPECIFIED;
    case 1:
    case "SYSTEM_ID_TOKEN":
      return HttpAuthorizationHeader.SYSTEM_ID_TOKEN;
    case 2:
    case "USER_ID_TOKEN":
      return HttpAuthorizationHeader.USER_ID_TOKEN;
    case 3:
    case "NONE":
      return HttpAuthorizationHeader.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpAuthorizationHeader.UNRECOGNIZED;
  }
}

export function httpAuthorizationHeaderToJSON(object: HttpAuthorizationHeader): string {
  switch (object) {
    case HttpAuthorizationHeader.HTTP_AUTHORIZATION_HEADER_UNSPECIFIED:
      return "HTTP_AUTHORIZATION_HEADER_UNSPECIFIED";
    case HttpAuthorizationHeader.SYSTEM_ID_TOKEN:
      return "SYSTEM_ID_TOKEN";
    case HttpAuthorizationHeader.USER_ID_TOKEN:
      return "USER_ID_TOKEN";
    case HttpAuthorizationHeader.NONE:
      return "NONE";
    case HttpAuthorizationHeader.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Add-on configuration that is shared across all add-on host applications. */
export interface CommonAddOnManifest {
  /** Required. The display name of the add-on. */
  name: string;
  /** Required. The URL for the logo image shown in the add-on toolbar. */
  logoUrl: string;
  /** Common layout properties for the add-on cards. */
  layoutProperties:
    | LayoutProperties
    | undefined;
  /**
   * The widgets used in the add-on. If this field is not specified,
   * it indicates that default set is used.
   */
  addOnWidgetSet:
    | AddOnWidgetSet
    | undefined;
  /** Whether to pass locale information from host app. */
  useLocaleFromApp: boolean;
  /**
   * Defines an endpoint that will be executed in any context, in
   * any host. Any cards generated by this function will always be available to
   * the user, but may be eclipsed by contextual content when this add-on
   * declares more targeted triggers.
   */
  homepageTrigger:
    | HomepageExtensionPoint
    | undefined;
  /**
   * Defines a list of extension points in the universal action menu which
   * serves as a setting menu for the add-on. The extension point can be
   * link URL to open or an endpoint to execute as a form
   * submission.
   */
  universalActions: UniversalActionExtensionPoint[];
  /**
   * An OpenLink action
   * can only use a URL with an HTTPS, MAILTO or TEL scheme.  For HTTPS links,
   * the URL must also
   * [match](/gmail/add-ons/concepts/manifests#whitelisting_urls) one of the
   * prefixes specified in this whitelist. If the prefix omits the scheme, HTTPS
   * is assumed.  Notice that HTTP links are automatically rewritten to HTTPS
   * links.
   */
  openLinkUrlPrefixes: Array<any> | undefined;
}

/** Card layout properties shared across all add-on host applications. */
export interface LayoutProperties {
  /**
   * The primary color of the add-on. It sets the color of toolbar. If no
   * primary color is set explicitly, the default value provided by the
   * framework is used.
   */
  primaryColor: string;
  /**
   * The secondary color of the add-on. It sets the color of buttons.
   * If primary color is set but no secondary color is set, the
   * secondary color is the same as the primary color. If neither primary
   * color nor secondary color is set, the default value provided by the
   * framework is used.
   */
  secondaryColor: string;
}

/** Options for sending requests to add-on HTTP endpoints */
export interface HttpOptions {
  /** Configuration for the token sent in the HTTP Authorization header */
  authorizationHeader: HttpAuthorizationHeader;
}

function createBaseCommonAddOnManifest(): CommonAddOnManifest {
  return {
    name: "",
    logoUrl: "",
    layoutProperties: undefined,
    addOnWidgetSet: undefined,
    useLocaleFromApp: false,
    homepageTrigger: undefined,
    universalActions: [],
    openLinkUrlPrefixes: undefined,
  };
}

export const CommonAddOnManifest: MessageFns<CommonAddOnManifest> = {
  encode(message: CommonAddOnManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.logoUrl !== "") {
      writer.uint32(18).string(message.logoUrl);
    }
    if (message.layoutProperties !== undefined) {
      LayoutProperties.encode(message.layoutProperties, writer.uint32(26).fork()).join();
    }
    if (message.addOnWidgetSet !== undefined) {
      AddOnWidgetSet.encode(message.addOnWidgetSet, writer.uint32(34).fork()).join();
    }
    if (message.useLocaleFromApp !== false) {
      writer.uint32(40).bool(message.useLocaleFromApp);
    }
    if (message.homepageTrigger !== undefined) {
      HomepageExtensionPoint.encode(message.homepageTrigger, writer.uint32(50).fork()).join();
    }
    for (const v of message.universalActions) {
      UniversalActionExtensionPoint.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.openLinkUrlPrefixes !== undefined) {
      ListValue.encode(ListValue.wrap(message.openLinkUrlPrefixes), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonAddOnManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonAddOnManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logoUrl = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.layoutProperties = LayoutProperties.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addOnWidgetSet = AddOnWidgetSet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useLocaleFromApp = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.homepageTrigger = HomepageExtensionPoint.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.universalActions.push(UniversalActionExtensionPoint.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.openLinkUrlPrefixes = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonAddOnManifest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
      layoutProperties: isSet(object.layoutProperties) ? LayoutProperties.fromJSON(object.layoutProperties) : undefined,
      addOnWidgetSet: isSet(object.addOnWidgetSet) ? AddOnWidgetSet.fromJSON(object.addOnWidgetSet) : undefined,
      useLocaleFromApp: isSet(object.useLocaleFromApp) ? globalThis.Boolean(object.useLocaleFromApp) : false,
      homepageTrigger: isSet(object.homepageTrigger)
        ? HomepageExtensionPoint.fromJSON(object.homepageTrigger)
        : undefined,
      universalActions: globalThis.Array.isArray(object?.universalActions)
        ? object.universalActions.map((e: any) => UniversalActionExtensionPoint.fromJSON(e))
        : [],
      openLinkUrlPrefixes: globalThis.Array.isArray(object.openLinkUrlPrefixes)
        ? [...object.openLinkUrlPrefixes]
        : undefined,
    };
  },

  toJSON(message: CommonAddOnManifest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logoUrl !== "") {
      obj.logoUrl = message.logoUrl;
    }
    if (message.layoutProperties !== undefined) {
      obj.layoutProperties = LayoutProperties.toJSON(message.layoutProperties);
    }
    if (message.addOnWidgetSet !== undefined) {
      obj.addOnWidgetSet = AddOnWidgetSet.toJSON(message.addOnWidgetSet);
    }
    if (message.useLocaleFromApp !== false) {
      obj.useLocaleFromApp = message.useLocaleFromApp;
    }
    if (message.homepageTrigger !== undefined) {
      obj.homepageTrigger = HomepageExtensionPoint.toJSON(message.homepageTrigger);
    }
    if (message.universalActions?.length) {
      obj.universalActions = message.universalActions.map((e) => UniversalActionExtensionPoint.toJSON(e));
    }
    if (message.openLinkUrlPrefixes !== undefined) {
      obj.openLinkUrlPrefixes = message.openLinkUrlPrefixes;
    }
    return obj;
  },

  create(base?: DeepPartial<CommonAddOnManifest>): CommonAddOnManifest {
    return CommonAddOnManifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommonAddOnManifest>): CommonAddOnManifest {
    const message = createBaseCommonAddOnManifest();
    message.name = object.name ?? "";
    message.logoUrl = object.logoUrl ?? "";
    message.layoutProperties = (object.layoutProperties !== undefined && object.layoutProperties !== null)
      ? LayoutProperties.fromPartial(object.layoutProperties)
      : undefined;
    message.addOnWidgetSet = (object.addOnWidgetSet !== undefined && object.addOnWidgetSet !== null)
      ? AddOnWidgetSet.fromPartial(object.addOnWidgetSet)
      : undefined;
    message.useLocaleFromApp = object.useLocaleFromApp ?? false;
    message.homepageTrigger = (object.homepageTrigger !== undefined && object.homepageTrigger !== null)
      ? HomepageExtensionPoint.fromPartial(object.homepageTrigger)
      : undefined;
    message.universalActions = object.universalActions?.map((e) => UniversalActionExtensionPoint.fromPartial(e)) || [];
    message.openLinkUrlPrefixes = object.openLinkUrlPrefixes ?? undefined;
    return message;
  },
};

function createBaseLayoutProperties(): LayoutProperties {
  return { primaryColor: "", secondaryColor: "" };
}

export const LayoutProperties: MessageFns<LayoutProperties> = {
  encode(message: LayoutProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryColor !== "") {
      writer.uint32(10).string(message.primaryColor);
    }
    if (message.secondaryColor !== "") {
      writer.uint32(18).string(message.secondaryColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryColor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutProperties {
    return {
      primaryColor: isSet(object.primaryColor) ? globalThis.String(object.primaryColor) : "",
      secondaryColor: isSet(object.secondaryColor) ? globalThis.String(object.secondaryColor) : "",
    };
  },

  toJSON(message: LayoutProperties): unknown {
    const obj: any = {};
    if (message.primaryColor !== "") {
      obj.primaryColor = message.primaryColor;
    }
    if (message.secondaryColor !== "") {
      obj.secondaryColor = message.secondaryColor;
    }
    return obj;
  },

  create(base?: DeepPartial<LayoutProperties>): LayoutProperties {
    return LayoutProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LayoutProperties>): LayoutProperties {
    const message = createBaseLayoutProperties();
    message.primaryColor = object.primaryColor ?? "";
    message.secondaryColor = object.secondaryColor ?? "";
    return message;
  },
};

function createBaseHttpOptions(): HttpOptions {
  return { authorizationHeader: 0 };
}

export const HttpOptions: MessageFns<HttpOptions> = {
  encode(message: HttpOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationHeader !== 0) {
      writer.uint32(8).int32(message.authorizationHeader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authorizationHeader = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpOptions {
    return {
      authorizationHeader: isSet(object.authorizationHeader)
        ? httpAuthorizationHeaderFromJSON(object.authorizationHeader)
        : 0,
    };
  },

  toJSON(message: HttpOptions): unknown {
    const obj: any = {};
    if (message.authorizationHeader !== 0) {
      obj.authorizationHeader = httpAuthorizationHeaderToJSON(message.authorizationHeader);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpOptions>): HttpOptions {
    return HttpOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpOptions>): HttpOptions {
    const message = createBaseHttpOptions();
    message.authorizationHeader = object.authorizationHeader ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
