// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/events/subscriptions/v1/subscription_resource.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";

export const protobufPackage = "google.apps.events.subscriptions.v1";

/**
 * A subscription to receive events about a Google Workspace resource. To learn
 * more about subscriptions, see the [Google Workspace Events API
 * overview](https://developers.google.com/workspace/events).
 */
export interface Subscription {
  /**
   * Non-empty default. The timestamp in UTC when the subscription expires.
   * Always displayed on output, regardless of what was used on input.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Input only. The time-to-live (TTL) or duration for the subscription. If
   * unspecified or set to `0`, uses the maximum possible duration.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Optional. Immutable. Identifier. Resource name of the subscription.
   *
   * Format: `subscriptions/{subscription}`
   */
  name: string;
  /** Output only. System-assigned unique identifier for the subscription. */
  uid: string;
  /**
   * Required. Immutable. The Google Workspace resource that's monitored for
   * events, formatted as the [full resource
   * name](https://google.aip.dev/122#full-resource-names). To learn about
   * target resources and the events that they support, see [Supported Google
   * Workspace
   * events](https://developers.google.com/workspace/events#supported-events).
   *
   * A user can only authorize your app to create one subscription for a given
   * target resource. If your app tries to create another subscription with the
   * same user credentials, the request returns an `ALREADY_EXISTS` error.
   */
  targetResource: string;
  /**
   * Required. Immutable. Unordered list. Input for creating a subscription.
   * Otherwise, output only. One or more types of events to receive about the
   * target resource. Formatted according to the CloudEvents specification.
   *
   * The supported event types depend on the target resource of your
   * subscription. For details, see [Supported Google Workspace
   * events](https://developers.google.com/workspace/events/guides#supported-events).
   *
   * By default, you also receive events about the [lifecycle of your
   * subscription](https://developers.google.com/workspace/events/guides/events-lifecycle).
   * You don't need to specify lifecycle events for this field.
   *
   * If you specify an event type that doesn't exist for the target resource,
   * the request returns an HTTP `400 Bad Request` status code.
   */
  eventTypes: string[];
  /**
   * Optional. Options about what data to include in the event payload. Only
   * supported for Google Chat events.
   */
  payloadOptions:
    | PayloadOptions
    | undefined;
  /**
   * Required. Immutable. The endpoint where the subscription delivers events,
   * such as a Pub/Sub topic.
   */
  notificationEndpoint:
    | NotificationEndpoint
    | undefined;
  /**
   * Output only. The state of the subscription. Determines whether the
   * subscription can receive events and deliver them to the notification
   * endpoint.
   */
  state: Subscription_State;
  /**
   * Output only. The error that suspended the subscription.
   *
   * To reactivate the subscription, resolve the error and call the
   * [`ReactivateSubscription`][google.apps.events.subscriptions.v1.SubscriptionsService.ReactivateSubscription]
   * method.
   */
  suspensionReason: Subscription_ErrorType;
  /**
   * Output only. The user who authorized the creation of the
   * subscription.
   *
   * Format: `users/{user}`
   *
   * For Google Workspace users, the `{user}` value is the
   * [`user.id`](https://developers.google.com/admin-sdk/directory/reference/rest/v1/users#User.FIELDS.ids)
   * field from the Directory API.
   */
  authority: string;
  /** Output only. The time when the subscription is created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last time that the subscription is updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. If `true`, the subscription is in the process of being
   * updated.
   */
  reconciling: boolean;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and might be sent on update requests to ensure the client has
   * an up-to-date value before proceeding.
   */
  etag: string;
}

/** Possible states for the subscription. */
export enum Subscription_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - The subscription is active and can receive and deliver events to its
   * notification endpoint.
   */
  ACTIVE = 1,
  /**
   * SUSPENDED - The subscription is unable to receive events due to an error.
   * To identify the error, see the
   * [`suspension_reason`][google.apps.events.subscriptions.v1.Subscription.suspension_reason]
   * field.
   */
  SUSPENDED = 2,
  /** DELETED - The subscription is deleted. */
  DELETED = 3,
  UNRECOGNIZED = -1,
}

export function subscription_StateFromJSON(object: any): Subscription_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Subscription_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Subscription_State.ACTIVE;
    case 2:
    case "SUSPENDED":
      return Subscription_State.SUSPENDED;
    case 3:
    case "DELETED":
      return Subscription_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subscription_State.UNRECOGNIZED;
  }
}

export function subscription_StateToJSON(object: Subscription_State): string {
  switch (object) {
    case Subscription_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Subscription_State.ACTIVE:
      return "ACTIVE";
    case Subscription_State.SUSPENDED:
      return "SUSPENDED";
    case Subscription_State.DELETED:
      return "DELETED";
    case Subscription_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible errors for a subscription. */
export enum Subscription_ErrorType {
  /** ERROR_TYPE_UNSPECIFIED - Default value. This value is unused. */
  ERROR_TYPE_UNSPECIFIED = 0,
  /**
   * USER_SCOPE_REVOKED - The authorizing user has revoked the grant of one or more OAuth scopes.
   * To learn more about authorization for Google Workspace, see [Configure
   * the OAuth consent
   * screen](https://developers.google.com/workspace/guides/configure-oauth-consent#choose-scopes).
   */
  USER_SCOPE_REVOKED = 1,
  /** RESOURCE_DELETED - The target resource for the subscription no longer exists. */
  RESOURCE_DELETED = 2,
  /**
   * USER_AUTHORIZATION_FAILURE - The user that authorized the creation of the subscription no longer has
   * access to the subscription's target resource.
   */
  USER_AUTHORIZATION_FAILURE = 3,
  /**
   * ENDPOINT_PERMISSION_DENIED - The Google Workspace application doesn't have access to deliver
   * events to your subscription's notification endpoint.
   */
  ENDPOINT_PERMISSION_DENIED = 4,
  /**
   * ENDPOINT_NOT_FOUND - The subscription's notification endpoint doesn't exist, or the endpoint
   * can't be found in the Google Cloud project where you created the
   * subscription.
   */
  ENDPOINT_NOT_FOUND = 6,
  /**
   * ENDPOINT_RESOURCE_EXHAUSTED - The subscription's notification endpoint failed to receive events due to
   * insufficient quota or reaching rate limiting.
   */
  ENDPOINT_RESOURCE_EXHAUSTED = 7,
  /** OTHER - An unidentified error has occurred. */
  OTHER = 5,
  UNRECOGNIZED = -1,
}

export function subscription_ErrorTypeFromJSON(object: any): Subscription_ErrorType {
  switch (object) {
    case 0:
    case "ERROR_TYPE_UNSPECIFIED":
      return Subscription_ErrorType.ERROR_TYPE_UNSPECIFIED;
    case 1:
    case "USER_SCOPE_REVOKED":
      return Subscription_ErrorType.USER_SCOPE_REVOKED;
    case 2:
    case "RESOURCE_DELETED":
      return Subscription_ErrorType.RESOURCE_DELETED;
    case 3:
    case "USER_AUTHORIZATION_FAILURE":
      return Subscription_ErrorType.USER_AUTHORIZATION_FAILURE;
    case 4:
    case "ENDPOINT_PERMISSION_DENIED":
      return Subscription_ErrorType.ENDPOINT_PERMISSION_DENIED;
    case 6:
    case "ENDPOINT_NOT_FOUND":
      return Subscription_ErrorType.ENDPOINT_NOT_FOUND;
    case 7:
    case "ENDPOINT_RESOURCE_EXHAUSTED":
      return Subscription_ErrorType.ENDPOINT_RESOURCE_EXHAUSTED;
    case 5:
    case "OTHER":
      return Subscription_ErrorType.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subscription_ErrorType.UNRECOGNIZED;
  }
}

export function subscription_ErrorTypeToJSON(object: Subscription_ErrorType): string {
  switch (object) {
    case Subscription_ErrorType.ERROR_TYPE_UNSPECIFIED:
      return "ERROR_TYPE_UNSPECIFIED";
    case Subscription_ErrorType.USER_SCOPE_REVOKED:
      return "USER_SCOPE_REVOKED";
    case Subscription_ErrorType.RESOURCE_DELETED:
      return "RESOURCE_DELETED";
    case Subscription_ErrorType.USER_AUTHORIZATION_FAILURE:
      return "USER_AUTHORIZATION_FAILURE";
    case Subscription_ErrorType.ENDPOINT_PERMISSION_DENIED:
      return "ENDPOINT_PERMISSION_DENIED";
    case Subscription_ErrorType.ENDPOINT_NOT_FOUND:
      return "ENDPOINT_NOT_FOUND";
    case Subscription_ErrorType.ENDPOINT_RESOURCE_EXHAUSTED:
      return "ENDPOINT_RESOURCE_EXHAUSTED";
    case Subscription_ErrorType.OTHER:
      return "OTHER";
    case Subscription_ErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Options about what data to include in the event payload. Only supported for
 * Google Chat events.
 */
export interface PayloadOptions {
  /**
   * Optional. Whether the event payload includes data about the resource that
   * changed. For example, for an event where a Google Chat message was created,
   * whether the payload contains data about the
   * [`Message`](https://developers.google.com/chat/api/reference/rest/v1/spaces.messages)
   * resource. If false, the event payload only includes the name of the changed
   * resource.
   */
  includeResource: boolean;
  /**
   * Optional. If `include_resource` is set to `true`, the list of fields to
   * include in the event payload. Separate fields with a comma. For example, to
   * include a Google Chat message's sender and create time, enter
   * `message.sender,message.createTime`. If omitted, the payload includes all
   * fields for the resource.
   *
   * If you specify a field that doesn't exist for the resource, the system
   * ignores the field.
   */
  fieldMask: string[] | undefined;
}

/** The endpoint where the subscription delivers events. */
export interface NotificationEndpoint {
  /**
   * Immutable. The Cloud Pub/Sub topic that receives events for the
   * subscription.
   *
   * Format: `projects/{project}/topics/{topic}`
   *
   * You must create the topic in the same Google Cloud project where
   * you create this subscription.
   *
   * When the topic receives events, the events are encoded as Cloud Pub/Sub
   * messages. For details, see the [Google Cloud Pub/Sub Protocol Binding for
   * CloudEvents](https://github.com/googleapis/google-cloudevents/blob/main/docs/spec/pubsub.md).
   */
  pubsubTopic?: string | undefined;
}

function createBaseSubscription(): Subscription {
  return {
    expireTime: undefined,
    ttl: undefined,
    name: "",
    uid: "",
    targetResource: "",
    eventTypes: [],
    payloadOptions: undefined,
    notificationEndpoint: undefined,
    state: 0,
    suspensionReason: 0,
    authority: "",
    createTime: undefined,
    updateTime: undefined,
    reconciling: false,
    etag: "",
  };
}

export const Subscription: MessageFns<Subscription> = {
  encode(message: Subscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(106).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(114).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.targetResource !== "") {
      writer.uint32(34).string(message.targetResource);
    }
    for (const v of message.eventTypes) {
      writer.uint32(42).string(v!);
    }
    if (message.payloadOptions !== undefined) {
      PayloadOptions.encode(message.payloadOptions, writer.uint32(50).fork()).join();
    }
    if (message.notificationEndpoint !== undefined) {
      NotificationEndpoint.encode(message.notificationEndpoint, writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.suspensionReason !== 0) {
      writer.uint32(144).int32(message.suspensionReason);
    }
    if (message.authority !== "") {
      writer.uint32(82).string(message.authority);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.reconciling !== false) {
      writer.uint32(120).bool(message.reconciling);
    }
    if (message.etag !== "") {
      writer.uint32(138).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13:
          if (tag !== 106) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetResource = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payloadOptions = PayloadOptions.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.notificationEndpoint = NotificationEndpoint.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.suspensionReason = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      targetResource: isSet(object.targetResource) ? globalThis.String(object.targetResource) : "",
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      payloadOptions: isSet(object.payloadOptions) ? PayloadOptions.fromJSON(object.payloadOptions) : undefined,
      notificationEndpoint: isSet(object.notificationEndpoint)
        ? NotificationEndpoint.fromJSON(object.notificationEndpoint)
        : undefined,
      state: isSet(object.state) ? subscription_StateFromJSON(object.state) : 0,
      suspensionReason: isSet(object.suspensionReason) ? subscription_ErrorTypeFromJSON(object.suspensionReason) : 0,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.targetResource !== "") {
      obj.targetResource = message.targetResource;
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.payloadOptions !== undefined) {
      obj.payloadOptions = PayloadOptions.toJSON(message.payloadOptions);
    }
    if (message.notificationEndpoint !== undefined) {
      obj.notificationEndpoint = NotificationEndpoint.toJSON(message.notificationEndpoint);
    }
    if (message.state !== 0) {
      obj.state = subscription_StateToJSON(message.state);
    }
    if (message.suspensionReason !== 0) {
      obj.suspensionReason = subscription_ErrorTypeToJSON(message.suspensionReason);
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Subscription>): Subscription {
    return Subscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subscription>): Subscription {
    const message = createBaseSubscription();
    message.expireTime = object.expireTime ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.targetResource = object.targetResource ?? "";
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.payloadOptions = (object.payloadOptions !== undefined && object.payloadOptions !== null)
      ? PayloadOptions.fromPartial(object.payloadOptions)
      : undefined;
    message.notificationEndpoint = (object.notificationEndpoint !== undefined && object.notificationEndpoint !== null)
      ? NotificationEndpoint.fromPartial(object.notificationEndpoint)
      : undefined;
    message.state = object.state ?? 0;
    message.suspensionReason = object.suspensionReason ?? 0;
    message.authority = object.authority ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reconciling = object.reconciling ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBasePayloadOptions(): PayloadOptions {
  return { includeResource: false, fieldMask: undefined };
}

export const PayloadOptions: MessageFns<PayloadOptions> = {
  encode(message: PayloadOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeResource !== false) {
      writer.uint32(8).bool(message.includeResource);
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayloadOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayloadOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeResource = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayloadOptions {
    return {
      includeResource: isSet(object.includeResource) ? globalThis.Boolean(object.includeResource) : false,
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
    };
  },

  toJSON(message: PayloadOptions): unknown {
    const obj: any = {};
    if (message.includeResource !== false) {
      obj.includeResource = message.includeResource;
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    return obj;
  },

  create(base?: DeepPartial<PayloadOptions>): PayloadOptions {
    return PayloadOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PayloadOptions>): PayloadOptions {
    const message = createBasePayloadOptions();
    message.includeResource = object.includeResource ?? false;
    message.fieldMask = object.fieldMask ?? undefined;
    return message;
  },
};

function createBaseNotificationEndpoint(): NotificationEndpoint {
  return { pubsubTopic: undefined };
}

export const NotificationEndpoint: MessageFns<NotificationEndpoint> = {
  encode(message: NotificationEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsubTopic !== undefined) {
      writer.uint32(10).string(message.pubsubTopic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubTopic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationEndpoint {
    return { pubsubTopic: isSet(object.pubsubTopic) ? globalThis.String(object.pubsubTopic) : undefined };
  },

  toJSON(message: NotificationEndpoint): unknown {
    const obj: any = {};
    if (message.pubsubTopic !== undefined) {
      obj.pubsubTopic = message.pubsubTopic;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationEndpoint>): NotificationEndpoint {
    return NotificationEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationEndpoint>): NotificationEndpoint {
    const message = createBaseNotificationEndpoint();
    message.pubsubTopic = object.pubsubTopic ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
