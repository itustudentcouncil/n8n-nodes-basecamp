// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/apps/alertcenter/v1beta1/alertcenter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Any } from "../../../protobuf/any.js";
import { Empty } from "../../../protobuf/empty.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.apps.alertcenter.v1beta1";

/** The type of alert feedback. */
export enum AlertFeedbackType {
  /** ALERT_FEEDBACK_TYPE_UNSPECIFIED - The feedback type is not specified. */
  ALERT_FEEDBACK_TYPE_UNSPECIFIED = 0,
  /** NOT_USEFUL - The alert report is not useful. */
  NOT_USEFUL = 1,
  /** SOMEWHAT_USEFUL - The alert report is somewhat useful. */
  SOMEWHAT_USEFUL = 2,
  /** VERY_USEFUL - The alert report is very useful. */
  VERY_USEFUL = 3,
  UNRECOGNIZED = -1,
}

export function alertFeedbackTypeFromJSON(object: any): AlertFeedbackType {
  switch (object) {
    case 0:
    case "ALERT_FEEDBACK_TYPE_UNSPECIFIED":
      return AlertFeedbackType.ALERT_FEEDBACK_TYPE_UNSPECIFIED;
    case 1:
    case "NOT_USEFUL":
      return AlertFeedbackType.NOT_USEFUL;
    case 2:
    case "SOMEWHAT_USEFUL":
      return AlertFeedbackType.SOMEWHAT_USEFUL;
    case 3:
    case "VERY_USEFUL":
      return AlertFeedbackType.VERY_USEFUL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlertFeedbackType.UNRECOGNIZED;
  }
}

export function alertFeedbackTypeToJSON(object: AlertFeedbackType): string {
  switch (object) {
    case AlertFeedbackType.ALERT_FEEDBACK_TYPE_UNSPECIFIED:
      return "ALERT_FEEDBACK_TYPE_UNSPECIFIED";
    case AlertFeedbackType.NOT_USEFUL:
      return "NOT_USEFUL";
    case AlertFeedbackType.SOMEWHAT_USEFUL:
      return "SOMEWHAT_USEFUL";
    case AlertFeedbackType.VERY_USEFUL:
      return "VERY_USEFUL";
    case AlertFeedbackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An alert affecting a customer. */
export interface Alert {
  /**
   * Output only. The unique identifier of the Google Workspace account of the
   * customer.
   */
  customerId: string;
  /** Output only. The unique identifier for the alert. */
  alertId: string;
  /** Output only. The time this alert was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Required. The time the event that caused this alert was started or
   * detected.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Optional. The time the event that caused this alert ceased being active.
   * If provided, the end time must not be earlier than the start time.
   * If not provided, it indicates an ongoing alert.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Required. The type of the alert.
   * This is output only after alert is created.
   * For a list of available alert types see
   * [Google Workspace Alert
   * types](https://developers.google.com/admin-sdk/alertcenter/reference/alert-types).
   */
  type: string;
  /**
   * Required. A unique identifier for the system that reported the alert.
   * This is output only after alert is created.
   *
   * Supported sources are any of the following:
   *
   * * Google Operations
   * * Mobile device management
   * * Gmail phishing
   * * Data Loss Prevention
   * * Domain wide takeout
   * * State sponsored attack
   * * Google identity
   * * Apps outage
   */
  source: string;
  /**
   * Optional. The data associated with this alert, for example
   * [google.apps.alertcenter.type.DeviceCompromised]
   * [google.apps.alertcenter.type.DeviceCompromised].
   */
  data:
    | Any
    | undefined;
  /**
   * Output only. An optional
   * [Security Investigation Tool](https://support.google.com/a/answer/7575955)
   * query for this alert.
   */
  securityInvestigationToolLink: string;
  /** Output only. `True` if this alert is marked for deletion. */
  deleted: boolean;
  /** Output only. The metadata associated with this alert. */
  metadata:
    | AlertMetadata
    | undefined;
  /** Output only. The time this alert was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. `etag` is used for optimistic concurrency control as a way to
   * help prevent simultaneous updates of an alert from overwriting each other.
   * It is strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform alert updates in order to avoid race
   * conditions: An `etag` is returned in the response which contains alerts,
   * and systems are expected to put that etag in the request to update alert to
   * ensure that their change will be applied to the same version of the alert.
   *
   * If no `etag` is provided in the call to update alert, then the existing
   * alert is overwritten blindly.
   */
  etag: string;
}

/** A customer feedback about an alert. */
export interface AlertFeedback {
  /**
   * Output only. The unique identifier of the Google Workspace account of the
   * customer.
   */
  customerId: string;
  /** Output only. The alert identifier. */
  alertId: string;
  /** Output only. The unique identifier for the feedback. */
  feedbackId: string;
  /** Output only. The time this feedback was created. */
  createTime:
    | Date
    | undefined;
  /** Required. The type of the feedback. */
  type: AlertFeedbackType;
  /** Output only. The email of the user that provided the feedback. */
  email: string;
}

/** An alert metadata. */
export interface AlertMetadata {
  /**
   * Output only. The unique identifier of the Google Workspace account of the
   * customer.
   */
  customerId: string;
  /** Output only. The alert identifier. */
  alertId: string;
  /**
   * The current status of the alert.
   * The supported values are the following:
   *
   * * NOT_STARTED
   * * IN_PROGRESS
   * * CLOSED
   */
  status: string;
  /** The email address of the user assigned to the alert. */
  assignee: string;
  /** Output only. The time this metadata was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * The severity value of the alert. Alert Center will set this field at alert
   * creation time, default's to an empty string when it could not be
   * determined.
   * The supported values for update actions on this field are the following:
   *
   * * HIGH
   * * MEDIUM
   * * LOW
   */
  severity: string;
  /**
   * Optional. `etag` is used for optimistic concurrency control as a way to
   * help prevent simultaneous updates of an alert metadata from overwriting
   * each other. It is strongly suggested that systems make use of the `etag` in
   * the read-modify-write cycle to perform metadata updates in order to avoid
   * race conditions: An `etag` is returned in the response which contains alert
   * metadata, and systems are expected to put that etag in the request to
   * update alert metadata to ensure that their change will be applied to the
   * same version of the alert metadata.
   *
   * If no `etag` is provided in the call to update alert metadata, then the
   * existing alert metadata is overwritten blindly.
   */
  etag: string;
}

/** Customer-level settings. */
export interface Settings {
  /** The list of notifications. */
  notifications: Settings_Notification[];
}

/**
 * Settings for callback notifications.
 * For more details see [Google Workspace Alert
 * Notification](https://developers.google.com/admin-sdk/alertcenter/guides/notifications).
 */
export interface Settings_Notification {
  /** A Google Cloud Pub/sub topic destination. */
  cloudPubsubTopic?: Settings_Notification_CloudPubsubTopic | undefined;
}

/** The format of the payload. */
export enum Settings_Notification_PayloadFormat {
  /** PAYLOAD_FORMAT_UNSPECIFIED - Payload format is not specified (will use JSON as default). */
  PAYLOAD_FORMAT_UNSPECIFIED = 0,
  /** JSON - Use JSON. */
  JSON = 1,
  UNRECOGNIZED = -1,
}

export function settings_Notification_PayloadFormatFromJSON(object: any): Settings_Notification_PayloadFormat {
  switch (object) {
    case 0:
    case "PAYLOAD_FORMAT_UNSPECIFIED":
      return Settings_Notification_PayloadFormat.PAYLOAD_FORMAT_UNSPECIFIED;
    case 1:
    case "JSON":
      return Settings_Notification_PayloadFormat.JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Settings_Notification_PayloadFormat.UNRECOGNIZED;
  }
}

export function settings_Notification_PayloadFormatToJSON(object: Settings_Notification_PayloadFormat): string {
  switch (object) {
    case Settings_Notification_PayloadFormat.PAYLOAD_FORMAT_UNSPECIFIED:
      return "PAYLOAD_FORMAT_UNSPECIFIED";
    case Settings_Notification_PayloadFormat.JSON:
      return "JSON";
    case Settings_Notification_PayloadFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A reference to a Cloud Pubsub topic.
 *
 * To register for notifications, the owner of the topic must grant
 * `alerts-api-push-notifications@system.gserviceaccount.com` the
 *  `projects.topics.publish` permission.
 */
export interface Settings_Notification_CloudPubsubTopic {
  /**
   * The `name` field of a Cloud Pubsub [Topic]
   * (https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics#Topic).
   */
  topicName: string;
  /**
   * Optional. The format of the payload that would be sent.
   * If not specified the format will be JSON.
   */
  payloadFormat: Settings_Notification_PayloadFormat;
}

/** A request to perform batch delete on alerts. */
export interface BatchDeleteAlertsRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alerts are associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The list of alert IDs to delete. */
  alertId: string[];
}

/** Response to batch delete operation on alerts. */
export interface BatchDeleteAlertsResponse {
  /** The successful list of alert IDs. */
  successAlertIds: string[];
  /** The status details for each failed `alert_id`. */
  failedAlertStatus: { [key: string]: Status };
}

export interface BatchDeleteAlertsResponse_FailedAlertStatusEntry {
  key: string;
  value: Status | undefined;
}

/** A request to perform batch undelete on alerts. */
export interface BatchUndeleteAlertsRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alerts are associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The list of alert IDs to undelete. */
  alertId: string[];
}

/** Response to batch undelete operation on alerts. */
export interface BatchUndeleteAlertsResponse {
  /** The successful list of alert IDs. */
  successAlertIds: string[];
  /** The status details for each failed `alert_id`. */
  failedAlertStatus: { [key: string]: Status };
}

export interface BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
  key: string;
  value: Status | undefined;
}

/** An alert listing request. */
export interface ListAlertsRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alerts are associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /**
   * Optional. The requested page size. Server may return fewer items than
   * requested. If unspecified, server picks an appropriate default.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   * If empty, a new iteration is started. To continue an iteration, pass in
   * the value from the previous ListAlertsResponse's
   * [next_page_token][google.apps.alertcenter.v1beta1.ListAlertsResponse.next_page_token]
   * field.
   */
  pageToken: string;
  /**
   * Optional. A query string for filtering alert results.
   * For more details, see [Query
   * filters](https://developers.google.com/admin-sdk/alertcenter/guides/query-filters)
   * and [Supported query filter
   * fields](https://developers.google.com/admin-sdk/alertcenter/reference/filter-fields#alerts.list).
   */
  filter: string;
  /**
   * Optional. The sort order of the list results.
   * If not specified results may be returned in arbitrary order.
   * You can sort the results in descending order based on the creation
   * timestamp using `order_by="create_time desc"`.
   * Currently, supported sorting are `create_time asc`, `create_time desc`,
   * `update_time desc`
   */
  orderBy: string;
}

/** Response message for an alert listing request. */
export interface ListAlertsResponse {
  /** The list of alerts. */
  alerts: Alert[];
  /**
   * The token for the next page. If not empty, indicates that there may be more
   * alerts that match the listing request; this value can be used in a
   * subsequent
   * [ListAlertsRequest][google.apps.alertcenter.v1beta1.ListAlertsRequest] to
   * get alerts continuing from last result of the current list call.
   */
  nextPageToken: string;
}

/** Request for a specific alert. */
export interface GetAlertRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert is associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The identifier of the alert to retrieve. */
  alertId: string;
}

/** A request to mark a specific alert for deletion. */
export interface DeleteAlertRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert is associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The identifier of the alert to delete. */
  alertId: string;
}

/** A request to undelete a specific alert that was marked for deletion. */
export interface UndeleteAlertRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert is associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The identifier of the alert to undelete. */
  alertId: string;
}

/** A request to create a new alert feedback. */
export interface CreateAlertFeedbackRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert is associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The identifier of the alert this feedback belongs to. */
  alertId: string;
  /** Required. The new alert feedback to create. */
  feedback: AlertFeedback | undefined;
}

/** An alert feedback listing request. */
export interface ListAlertFeedbackRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert is associated with. The `customer_id` must have the
   * initial "C" stripped (for example, `046psxkn`). Inferred from the caller
   * identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /**
   * Required. The alert identifier.
   * The "-" wildcard could be used to represent all alerts.
   */
  alertId: string;
  /**
   * Optional. A query string for filtering alert feedback results.
   * For more details, see [Query
   * filters](https://developers.google.com/admin-sdk/alertcenter/guides/query-filters)
   * and [Supported query filter
   * fields](https://developers.google.com/admin-sdk/alertcenter/reference/filter-fields#alerts.feedback.list).
   */
  filter: string;
}

/** Response message for an alert feedback listing request. */
export interface ListAlertFeedbackResponse {
  /**
   * The list of alert feedback.
   * Feedback entries for each alert are ordered by creation time descending.
   */
  feedback: AlertFeedback[];
}

/** Get the alert metadata. */
export interface GetAlertMetadataRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert metadata is associated with. The `customer_id` must
   * have the initial "C" stripped (for example, `046psxkn`). Inferred from the
   * caller identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** Required. The identifier of the alert this metadata belongs to. */
  alertId: string;
}

/** Get the customer level settings. */
export interface GetSettingsRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert settings are associated with. The `customer_id` must/
   * have the initial "C" stripped (for example, `046psxkn`). Inferred from the
   * caller identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
}

/** Update the customer level settings. */
export interface UpdateSettingsRequest {
  /**
   * Optional. The unique identifier of the Google Workspace account of the
   * customer the alert settings are associated with. The `customer_id` must
   * have the initial "C" stripped (for example, `046psxkn`). Inferred from the
   * caller identity if not provided. [Find your customer
   * ID](https://support.google.com/cloudidentity/answer/10070793).
   */
  customerId: string;
  /** The customer settings to update. */
  settings: Settings | undefined;
}

function createBaseAlert(): Alert {
  return {
    customerId: "",
    alertId: "",
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    type: "",
    source: "",
    data: undefined,
    securityInvestigationToolLink: "",
    deleted: false,
    metadata: undefined,
    updateTime: undefined,
    etag: "",
  };
}

export const Alert: MessageFns<Alert> = {
  encode(message: Alert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.source !== "") {
      writer.uint32(58).string(message.source);
    }
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(66).fork()).join();
    }
    if (message.securityInvestigationToolLink !== "") {
      writer.uint32(74).string(message.securityInvestigationToolLink);
    }
    if (message.deleted !== false) {
      writer.uint32(88).bool(message.deleted);
    }
    if (message.metadata !== undefined) {
      AlertMetadata.encode(message.metadata, writer.uint32(98).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(106).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(114).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Alert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.source = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.securityInvestigationToolLink = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.metadata = AlertMetadata.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      securityInvestigationToolLink: isSet(object.securityInvestigationToolLink)
        ? globalThis.String(object.securityInvestigationToolLink)
        : "",
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      metadata: isSet(object.metadata) ? AlertMetadata.fromJSON(object.metadata) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Alert): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.securityInvestigationToolLink !== "") {
      obj.securityInvestigationToolLink = message.securityInvestigationToolLink;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.metadata !== undefined) {
      obj.metadata = AlertMetadata.toJSON(message.metadata);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Alert>): Alert {
    return Alert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Alert>): Alert {
    const message = createBaseAlert();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.type = object.type ?? "";
    message.source = object.source ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.securityInvestigationToolLink = object.securityInvestigationToolLink ?? "";
    message.deleted = object.deleted ?? false;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AlertMetadata.fromPartial(object.metadata)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseAlertFeedback(): AlertFeedback {
  return { customerId: "", alertId: "", feedbackId: "", createTime: undefined, type: 0, email: "" };
}

export const AlertFeedback: MessageFns<AlertFeedback> = {
  encode(message: AlertFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    if (message.feedbackId !== "") {
      writer.uint32(26).string(message.feedbackId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.email !== "") {
      writer.uint32(50).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedbackId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertFeedback {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      feedbackId: isSet(object.feedbackId) ? globalThis.String(object.feedbackId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      type: isSet(object.type) ? alertFeedbackTypeFromJSON(object.type) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: AlertFeedback): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.feedbackId !== "") {
      obj.feedbackId = message.feedbackId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.type !== 0) {
      obj.type = alertFeedbackTypeToJSON(message.type);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<AlertFeedback>): AlertFeedback {
    return AlertFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertFeedback>): AlertFeedback {
    const message = createBaseAlertFeedback();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    message.feedbackId = object.feedbackId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.type = object.type ?? 0;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseAlertMetadata(): AlertMetadata {
  return { customerId: "", alertId: "", status: "", assignee: "", updateTime: undefined, severity: "", etag: "" };
}

export const AlertMetadata: MessageFns<AlertMetadata> = {
  encode(message: AlertMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.assignee !== "") {
      writer.uint32(42).string(message.assignee);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.severity !== "") {
      writer.uint32(58).string(message.severity);
    }
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.assignee = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.severity = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertMetadata {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      assignee: isSet(object.assignee) ? globalThis.String(object.assignee) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: AlertMetadata): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.assignee !== "") {
      obj.assignee = message.assignee;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<AlertMetadata>): AlertMetadata {
    return AlertMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertMetadata>): AlertMetadata {
    const message = createBaseAlertMetadata();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    message.status = object.status ?? "";
    message.assignee = object.assignee ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.severity = object.severity ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseSettings(): Settings {
  return { notifications: [] };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notifications) {
      Settings_Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Settings_Notification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Settings_Notification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Settings_Notification.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.notifications = object.notifications?.map((e) => Settings_Notification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSettings_Notification(): Settings_Notification {
  return { cloudPubsubTopic: undefined };
}

export const Settings_Notification: MessageFns<Settings_Notification> = {
  encode(message: Settings_Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudPubsubTopic !== undefined) {
      Settings_Notification_CloudPubsubTopic.encode(message.cloudPubsubTopic, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_Notification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudPubsubTopic = Settings_Notification_CloudPubsubTopic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_Notification {
    return {
      cloudPubsubTopic: isSet(object.cloudPubsubTopic)
        ? Settings_Notification_CloudPubsubTopic.fromJSON(object.cloudPubsubTopic)
        : undefined,
    };
  },

  toJSON(message: Settings_Notification): unknown {
    const obj: any = {};
    if (message.cloudPubsubTopic !== undefined) {
      obj.cloudPubsubTopic = Settings_Notification_CloudPubsubTopic.toJSON(message.cloudPubsubTopic);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_Notification>): Settings_Notification {
    return Settings_Notification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_Notification>): Settings_Notification {
    const message = createBaseSettings_Notification();
    message.cloudPubsubTopic = (object.cloudPubsubTopic !== undefined && object.cloudPubsubTopic !== null)
      ? Settings_Notification_CloudPubsubTopic.fromPartial(object.cloudPubsubTopic)
      : undefined;
    return message;
  },
};

function createBaseSettings_Notification_CloudPubsubTopic(): Settings_Notification_CloudPubsubTopic {
  return { topicName: "", payloadFormat: 0 };
}

export const Settings_Notification_CloudPubsubTopic: MessageFns<Settings_Notification_CloudPubsubTopic> = {
  encode(message: Settings_Notification_CloudPubsubTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicName !== "") {
      writer.uint32(10).string(message.topicName);
    }
    if (message.payloadFormat !== 0) {
      writer.uint32(16).int32(message.payloadFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_Notification_CloudPubsubTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_Notification_CloudPubsubTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topicName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.payloadFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_Notification_CloudPubsubTopic {
    return {
      topicName: isSet(object.topicName) ? globalThis.String(object.topicName) : "",
      payloadFormat: isSet(object.payloadFormat)
        ? settings_Notification_PayloadFormatFromJSON(object.payloadFormat)
        : 0,
    };
  },

  toJSON(message: Settings_Notification_CloudPubsubTopic): unknown {
    const obj: any = {};
    if (message.topicName !== "") {
      obj.topicName = message.topicName;
    }
    if (message.payloadFormat !== 0) {
      obj.payloadFormat = settings_Notification_PayloadFormatToJSON(message.payloadFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_Notification_CloudPubsubTopic>): Settings_Notification_CloudPubsubTopic {
    return Settings_Notification_CloudPubsubTopic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_Notification_CloudPubsubTopic>): Settings_Notification_CloudPubsubTopic {
    const message = createBaseSettings_Notification_CloudPubsubTopic();
    message.topicName = object.topicName ?? "";
    message.payloadFormat = object.payloadFormat ?? 0;
    return message;
  },
};

function createBaseBatchDeleteAlertsRequest(): BatchDeleteAlertsRequest {
  return { customerId: "", alertId: [] };
}

export const BatchDeleteAlertsRequest: MessageFns<BatchDeleteAlertsRequest> = {
  encode(message: BatchDeleteAlertsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.alertId) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteAlertsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteAlertsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteAlertsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: globalThis.Array.isArray(object?.alertId) ? object.alertId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeleteAlertsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId?.length) {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteAlertsRequest>): BatchDeleteAlertsRequest {
    return BatchDeleteAlertsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteAlertsRequest>): BatchDeleteAlertsRequest {
    const message = createBaseBatchDeleteAlertsRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchDeleteAlertsResponse(): BatchDeleteAlertsResponse {
  return { successAlertIds: [], failedAlertStatus: {} };
}

export const BatchDeleteAlertsResponse: MessageFns<BatchDeleteAlertsResponse> = {
  encode(message: BatchDeleteAlertsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.successAlertIds) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.failedAlertStatus).forEach(([key, value]) => {
      BatchDeleteAlertsResponse_FailedAlertStatusEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteAlertsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteAlertsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.successAlertIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = BatchDeleteAlertsResponse_FailedAlertStatusEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.failedAlertStatus[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteAlertsResponse {
    return {
      successAlertIds: globalThis.Array.isArray(object?.successAlertIds)
        ? object.successAlertIds.map((e: any) => globalThis.String(e))
        : [],
      failedAlertStatus: isObject(object.failedAlertStatus)
        ? Object.entries(object.failedAlertStatus).reduce<{ [key: string]: Status }>((acc, [key, value]) => {
          acc[key] = Status.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchDeleteAlertsResponse): unknown {
    const obj: any = {};
    if (message.successAlertIds?.length) {
      obj.successAlertIds = message.successAlertIds;
    }
    if (message.failedAlertStatus) {
      const entries = Object.entries(message.failedAlertStatus);
      if (entries.length > 0) {
        obj.failedAlertStatus = {};
        entries.forEach(([k, v]) => {
          obj.failedAlertStatus[k] = Status.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteAlertsResponse>): BatchDeleteAlertsResponse {
    return BatchDeleteAlertsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteAlertsResponse>): BatchDeleteAlertsResponse {
    const message = createBaseBatchDeleteAlertsResponse();
    message.successAlertIds = object.successAlertIds?.map((e) => e) || [];
    message.failedAlertStatus = Object.entries(object.failedAlertStatus ?? {}).reduce<{ [key: string]: Status }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Status.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBatchDeleteAlertsResponse_FailedAlertStatusEntry(): BatchDeleteAlertsResponse_FailedAlertStatusEntry {
  return { key: "", value: undefined };
}

export const BatchDeleteAlertsResponse_FailedAlertStatusEntry: MessageFns<
  BatchDeleteAlertsResponse_FailedAlertStatusEntry
> = {
  encode(
    message: BatchDeleteAlertsResponse_FailedAlertStatusEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Status.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteAlertsResponse_FailedAlertStatusEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteAlertsResponse_FailedAlertStatusEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteAlertsResponse_FailedAlertStatusEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Status.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchDeleteAlertsResponse_FailedAlertStatusEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Status.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchDeleteAlertsResponse_FailedAlertStatusEntry>,
  ): BatchDeleteAlertsResponse_FailedAlertStatusEntry {
    return BatchDeleteAlertsResponse_FailedAlertStatusEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchDeleteAlertsResponse_FailedAlertStatusEntry>,
  ): BatchDeleteAlertsResponse_FailedAlertStatusEntry {
    const message = createBaseBatchDeleteAlertsResponse_FailedAlertStatusEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Status.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBatchUndeleteAlertsRequest(): BatchUndeleteAlertsRequest {
  return { customerId: "", alertId: [] };
}

export const BatchUndeleteAlertsRequest: MessageFns<BatchUndeleteAlertsRequest> = {
  encode(message: BatchUndeleteAlertsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.alertId) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUndeleteAlertsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUndeleteAlertsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUndeleteAlertsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: globalThis.Array.isArray(object?.alertId) ? object.alertId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchUndeleteAlertsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId?.length) {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUndeleteAlertsRequest>): BatchUndeleteAlertsRequest {
    return BatchUndeleteAlertsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUndeleteAlertsRequest>): BatchUndeleteAlertsRequest {
    const message = createBaseBatchUndeleteAlertsRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchUndeleteAlertsResponse(): BatchUndeleteAlertsResponse {
  return { successAlertIds: [], failedAlertStatus: {} };
}

export const BatchUndeleteAlertsResponse: MessageFns<BatchUndeleteAlertsResponse> = {
  encode(message: BatchUndeleteAlertsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.successAlertIds) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.failedAlertStatus).forEach(([key, value]) => {
      BatchUndeleteAlertsResponse_FailedAlertStatusEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUndeleteAlertsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUndeleteAlertsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.successAlertIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = BatchUndeleteAlertsResponse_FailedAlertStatusEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.failedAlertStatus[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUndeleteAlertsResponse {
    return {
      successAlertIds: globalThis.Array.isArray(object?.successAlertIds)
        ? object.successAlertIds.map((e: any) => globalThis.String(e))
        : [],
      failedAlertStatus: isObject(object.failedAlertStatus)
        ? Object.entries(object.failedAlertStatus).reduce<{ [key: string]: Status }>((acc, [key, value]) => {
          acc[key] = Status.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchUndeleteAlertsResponse): unknown {
    const obj: any = {};
    if (message.successAlertIds?.length) {
      obj.successAlertIds = message.successAlertIds;
    }
    if (message.failedAlertStatus) {
      const entries = Object.entries(message.failedAlertStatus);
      if (entries.length > 0) {
        obj.failedAlertStatus = {};
        entries.forEach(([k, v]) => {
          obj.failedAlertStatus[k] = Status.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUndeleteAlertsResponse>): BatchUndeleteAlertsResponse {
    return BatchUndeleteAlertsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUndeleteAlertsResponse>): BatchUndeleteAlertsResponse {
    const message = createBaseBatchUndeleteAlertsResponse();
    message.successAlertIds = object.successAlertIds?.map((e) => e) || [];
    message.failedAlertStatus = Object.entries(object.failedAlertStatus ?? {}).reduce<{ [key: string]: Status }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Status.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBatchUndeleteAlertsResponse_FailedAlertStatusEntry(): BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
  return { key: "", value: undefined };
}

export const BatchUndeleteAlertsResponse_FailedAlertStatusEntry: MessageFns<
  BatchUndeleteAlertsResponse_FailedAlertStatusEntry
> = {
  encode(
    message: BatchUndeleteAlertsResponse_FailedAlertStatusEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Status.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUndeleteAlertsResponse_FailedAlertStatusEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Status.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchUndeleteAlertsResponse_FailedAlertStatusEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Status.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchUndeleteAlertsResponse_FailedAlertStatusEntry>,
  ): BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
    return BatchUndeleteAlertsResponse_FailedAlertStatusEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchUndeleteAlertsResponse_FailedAlertStatusEntry>,
  ): BatchUndeleteAlertsResponse_FailedAlertStatusEntry {
    const message = createBaseBatchUndeleteAlertsResponse_FailedAlertStatusEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Status.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListAlertsRequest(): ListAlertsRequest {
  return { customerId: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAlertsRequest: MessageFns<ListAlertsRequest> = {
  encode(message: ListAlertsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAlertsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAlertsRequest>): ListAlertsRequest {
    return ListAlertsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAlertsRequest>): ListAlertsRequest {
    const message = createBaseListAlertsRequest();
    message.customerId = object.customerId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAlertsResponse(): ListAlertsResponse {
  return { alerts: [], nextPageToken: "" };
}

export const ListAlertsResponse: MessageFns<ListAlertsResponse> = {
  encode(message: ListAlertsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alerts) {
      Alert.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alerts.push(Alert.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertsResponse {
    return {
      alerts: globalThis.Array.isArray(object?.alerts) ? object.alerts.map((e: any) => Alert.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAlertsResponse): unknown {
    const obj: any = {};
    if (message.alerts?.length) {
      obj.alerts = message.alerts.map((e) => Alert.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAlertsResponse>): ListAlertsResponse {
    return ListAlertsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAlertsResponse>): ListAlertsResponse {
    const message = createBaseListAlertsResponse();
    message.alerts = object.alerts?.map((e) => Alert.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetAlertRequest(): GetAlertRequest {
  return { customerId: "", alertId: "" };
}

export const GetAlertRequest: MessageFns<GetAlertRequest> = {
  encode(message: GetAlertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAlertRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
    };
  },

  toJSON(message: GetAlertRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAlertRequest>): GetAlertRequest {
    return GetAlertRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAlertRequest>): GetAlertRequest {
    const message = createBaseGetAlertRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    return message;
  },
};

function createBaseDeleteAlertRequest(): DeleteAlertRequest {
  return { customerId: "", alertId: "" };
}

export const DeleteAlertRequest: MessageFns<DeleteAlertRequest> = {
  encode(message: DeleteAlertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAlertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAlertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAlertRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
    };
  },

  toJSON(message: DeleteAlertRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAlertRequest>): DeleteAlertRequest {
    return DeleteAlertRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAlertRequest>): DeleteAlertRequest {
    const message = createBaseDeleteAlertRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    return message;
  },
};

function createBaseUndeleteAlertRequest(): UndeleteAlertRequest {
  return { customerId: "", alertId: "" };
}

export const UndeleteAlertRequest: MessageFns<UndeleteAlertRequest> = {
  encode(message: UndeleteAlertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteAlertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteAlertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteAlertRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
    };
  },

  toJSON(message: UndeleteAlertRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteAlertRequest>): UndeleteAlertRequest {
    return UndeleteAlertRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteAlertRequest>): UndeleteAlertRequest {
    const message = createBaseUndeleteAlertRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    return message;
  },
};

function createBaseCreateAlertFeedbackRequest(): CreateAlertFeedbackRequest {
  return { customerId: "", alertId: "", feedback: undefined };
}

export const CreateAlertFeedbackRequest: MessageFns<CreateAlertFeedbackRequest> = {
  encode(message: CreateAlertFeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    if (message.feedback !== undefined) {
      AlertFeedback.encode(message.feedback, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAlertFeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAlertFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedback = AlertFeedback.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAlertFeedbackRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      feedback: isSet(object.feedback) ? AlertFeedback.fromJSON(object.feedback) : undefined,
    };
  },

  toJSON(message: CreateAlertFeedbackRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.feedback !== undefined) {
      obj.feedback = AlertFeedback.toJSON(message.feedback);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAlertFeedbackRequest>): CreateAlertFeedbackRequest {
    return CreateAlertFeedbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAlertFeedbackRequest>): CreateAlertFeedbackRequest {
    const message = createBaseCreateAlertFeedbackRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    message.feedback = (object.feedback !== undefined && object.feedback !== null)
      ? AlertFeedback.fromPartial(object.feedback)
      : undefined;
    return message;
  },
};

function createBaseListAlertFeedbackRequest(): ListAlertFeedbackRequest {
  return { customerId: "", alertId: "", filter: "" };
}

export const ListAlertFeedbackRequest: MessageFns<ListAlertFeedbackRequest> = {
  encode(message: ListAlertFeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertFeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertFeedbackRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAlertFeedbackRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAlertFeedbackRequest>): ListAlertFeedbackRequest {
    return ListAlertFeedbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAlertFeedbackRequest>): ListAlertFeedbackRequest {
    const message = createBaseListAlertFeedbackRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAlertFeedbackResponse(): ListAlertFeedbackResponse {
  return { feedback: [] };
}

export const ListAlertFeedbackResponse: MessageFns<ListAlertFeedbackResponse> = {
  encode(message: ListAlertFeedbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.feedback) {
      AlertFeedback.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertFeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.feedback.push(AlertFeedback.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertFeedbackResponse {
    return {
      feedback: globalThis.Array.isArray(object?.feedback)
        ? object.feedback.map((e: any) => AlertFeedback.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListAlertFeedbackResponse): unknown {
    const obj: any = {};
    if (message.feedback?.length) {
      obj.feedback = message.feedback.map((e) => AlertFeedback.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListAlertFeedbackResponse>): ListAlertFeedbackResponse {
    return ListAlertFeedbackResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAlertFeedbackResponse>): ListAlertFeedbackResponse {
    const message = createBaseListAlertFeedbackResponse();
    message.feedback = object.feedback?.map((e) => AlertFeedback.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAlertMetadataRequest(): GetAlertMetadataRequest {
  return { customerId: "", alertId: "" };
}

export const GetAlertMetadataRequest: MessageFns<GetAlertMetadataRequest> = {
  encode(message: GetAlertMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.alertId !== "") {
      writer.uint32(18).string(message.alertId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlertMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlertMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alertId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAlertMetadataRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      alertId: isSet(object.alertId) ? globalThis.String(object.alertId) : "",
    };
  },

  toJSON(message: GetAlertMetadataRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.alertId !== "") {
      obj.alertId = message.alertId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAlertMetadataRequest>): GetAlertMetadataRequest {
    return GetAlertMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAlertMetadataRequest>): GetAlertMetadataRequest {
    const message = createBaseGetAlertMetadataRequest();
    message.customerId = object.customerId ?? "";
    message.alertId = object.alertId ?? "";
    return message;
  },
};

function createBaseGetSettingsRequest(): GetSettingsRequest {
  return { customerId: "" };
}

export const GetSettingsRequest: MessageFns<GetSettingsRequest> = {
  encode(message: GetSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSettingsRequest {
    return { customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "" };
  },

  toJSON(message: GetSettingsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    return GetSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    const message = createBaseGetSettingsRequest();
    message.customerId = object.customerId ?? "";
    return message;
  },
};

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
  return { customerId: "", settings: undefined };
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
  encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: UpdateSettingsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    return UpdateSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    const message = createBaseUpdateSettingsRequest();
    message.customerId = object.customerId ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

/** Google Workspace Alert Center API (beta). */
export type AlertCenterServiceDefinition = typeof AlertCenterServiceDefinition;
export const AlertCenterServiceDefinition = {
  name: "AlertCenterService",
  fullName: "google.apps.alertcenter.v1beta1.AlertCenterService",
  methods: {
    /** Lists the alerts. */
    listAlerts: {
      name: "ListAlerts",
      requestType: ListAlertsRequest,
      requestStream: false,
      responseType: ListAlertsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [Buffer.from([17, 18, 15, 47, 118, 49, 98, 101, 116, 97, 49, 47, 97, 108, 101, 114, 116, 115])],
        },
      },
    },
    /**
     * Gets the specified alert. Attempting to get a nonexistent alert returns
     * `NOT_FOUND` error.
     */
    getAlert: {
      name: "GetAlert",
      requestType: GetAlertRequest,
      requestStream: false,
      responseType: Alert,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              18,
              26,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Marks the specified alert for deletion. An alert that has been marked for
     * deletion is removed from Alert Center after 30 days.
     * Marking an alert for deletion has no effect on an alert which has
     * already been marked for deletion. Attempting to mark a nonexistent alert
     * for deletion results in a `NOT_FOUND` error.
     */
    deleteAlert: {
      name: "DeleteAlert",
      requestType: DeleteAlertRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              28,
              42,
              26,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Restores, or "undeletes", an alert that was marked for deletion within the
     * past 30 days. Attempting to undelete an alert which was marked for deletion
     * over 30 days ago (which has been removed from the Alert Center database) or
     * a nonexistent alert returns a `NOT_FOUND` error. Attempting to
     * undelete an alert which has not been marked for deletion has no effect.
     */
    undeleteAlert: {
      name: "UndeleteAlert",
      requestType: UndeleteAlertRequest,
      requestStream: false,
      responseType: Alert,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              58,
              1,
              42,
              34,
              35,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates new feedback for an alert. Attempting to create a feedback for
     * a non-existent alert returns `NOT_FOUND` error. Attempting to create a
     * feedback for an alert that is marked for deletion returns
     * `FAILED_PRECONDITION' error.
     */
    createAlertFeedback: {
      name: "CreateAlertFeedback",
      requestType: CreateAlertFeedbackRequest,
      requestStream: false,
      responseType: AlertFeedback,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              58,
              8,
              102,
              101,
              101,
              100,
              98,
              97,
              99,
              107,
              34,
              35,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
              47,
              102,
              101,
              101,
              100,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all the feedback for an alert. Attempting to list feedbacks for
     * a non-existent alert returns `NOT_FOUND` error.
     */
    listAlertFeedback: {
      name: "ListAlertFeedback",
      requestType: ListAlertFeedbackRequest,
      requestStream: false,
      responseType: ListAlertFeedbackResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              37,
              18,
              35,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
              47,
              102,
              101,
              101,
              100,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the metadata of an alert. Attempting to get metadata for
     * a non-existent alert returns `NOT_FOUND` error.
     */
    getAlertMetadata: {
      name: "GetAlertMetadata",
      requestType: GetAlertMetadataRequest,
      requestStream: false,
      responseType: AlertMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              37,
              18,
              35,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              47,
              123,
              97,
              108,
              101,
              114,
              116,
              95,
              105,
              100,
              125,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
        },
      },
    },
    /** Returns customer-level settings. */
    getSettings: {
      name: "GetSettings",
      requestType: GetSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([19, 18, 17, 47, 118, 49, 98, 101, 116, 97, 49, 47, 115, 101, 116, 116, 105, 110, 103, 115]),
          ],
        },
      },
    },
    /** Updates the customer-level settings. */
    updateSettings: {
      name: "UpdateSettings",
      requestType: UpdateSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              29,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              17,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Performs batch delete operation on alerts. */
    batchDeleteAlerts: {
      name: "BatchDeleteAlerts",
      requestType: BatchDeleteAlertsRequest,
      requestStream: false,
      responseType: BatchDeleteAlertsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              58,
              1,
              42,
              34,
              27,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Performs batch undelete operation on alerts. */
    batchUndeleteAlerts: {
      name: "BatchUndeleteAlerts",
      requestType: BatchUndeleteAlertsRequest,
      requestStream: false,
      responseType: BatchUndeleteAlertsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              58,
              1,
              42,
              34,
              29,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              97,
              108,
              101,
              114,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AlertCenterServiceImplementation<CallContextExt = {}> {
  /** Lists the alerts. */
  listAlerts(
    request: ListAlertsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAlertsResponse>>;
  /**
   * Gets the specified alert. Attempting to get a nonexistent alert returns
   * `NOT_FOUND` error.
   */
  getAlert(request: GetAlertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Alert>>;
  /**
   * Marks the specified alert for deletion. An alert that has been marked for
   * deletion is removed from Alert Center after 30 days.
   * Marking an alert for deletion has no effect on an alert which has
   * already been marked for deletion. Attempting to mark a nonexistent alert
   * for deletion results in a `NOT_FOUND` error.
   */
  deleteAlert(request: DeleteAlertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Restores, or "undeletes", an alert that was marked for deletion within the
   * past 30 days. Attempting to undelete an alert which was marked for deletion
   * over 30 days ago (which has been removed from the Alert Center database) or
   * a nonexistent alert returns a `NOT_FOUND` error. Attempting to
   * undelete an alert which has not been marked for deletion has no effect.
   */
  undeleteAlert(request: UndeleteAlertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Alert>>;
  /**
   * Creates new feedback for an alert. Attempting to create a feedback for
   * a non-existent alert returns `NOT_FOUND` error. Attempting to create a
   * feedback for an alert that is marked for deletion returns
   * `FAILED_PRECONDITION' error.
   */
  createAlertFeedback(
    request: CreateAlertFeedbackRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AlertFeedback>>;
  /**
   * Lists all the feedback for an alert. Attempting to list feedbacks for
   * a non-existent alert returns `NOT_FOUND` error.
   */
  listAlertFeedback(
    request: ListAlertFeedbackRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAlertFeedbackResponse>>;
  /**
   * Returns the metadata of an alert. Attempting to get metadata for
   * a non-existent alert returns `NOT_FOUND` error.
   */
  getAlertMetadata(
    request: GetAlertMetadataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AlertMetadata>>;
  /** Returns customer-level settings. */
  getSettings(request: GetSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
  /** Updates the customer-level settings. */
  updateSettings(request: UpdateSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
  /** Performs batch delete operation on alerts. */
  batchDeleteAlerts(
    request: BatchDeleteAlertsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchDeleteAlertsResponse>>;
  /** Performs batch undelete operation on alerts. */
  batchUndeleteAlerts(
    request: BatchUndeleteAlertsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchUndeleteAlertsResponse>>;
}

export interface AlertCenterServiceClient<CallOptionsExt = {}> {
  /** Lists the alerts. */
  listAlerts(
    request: DeepPartial<ListAlertsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAlertsResponse>;
  /**
   * Gets the specified alert. Attempting to get a nonexistent alert returns
   * `NOT_FOUND` error.
   */
  getAlert(request: DeepPartial<GetAlertRequest>, options?: CallOptions & CallOptionsExt): Promise<Alert>;
  /**
   * Marks the specified alert for deletion. An alert that has been marked for
   * deletion is removed from Alert Center after 30 days.
   * Marking an alert for deletion has no effect on an alert which has
   * already been marked for deletion. Attempting to mark a nonexistent alert
   * for deletion results in a `NOT_FOUND` error.
   */
  deleteAlert(request: DeepPartial<DeleteAlertRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Restores, or "undeletes", an alert that was marked for deletion within the
   * past 30 days. Attempting to undelete an alert which was marked for deletion
   * over 30 days ago (which has been removed from the Alert Center database) or
   * a nonexistent alert returns a `NOT_FOUND` error. Attempting to
   * undelete an alert which has not been marked for deletion has no effect.
   */
  undeleteAlert(request: DeepPartial<UndeleteAlertRequest>, options?: CallOptions & CallOptionsExt): Promise<Alert>;
  /**
   * Creates new feedback for an alert. Attempting to create a feedback for
   * a non-existent alert returns `NOT_FOUND` error. Attempting to create a
   * feedback for an alert that is marked for deletion returns
   * `FAILED_PRECONDITION' error.
   */
  createAlertFeedback(
    request: DeepPartial<CreateAlertFeedbackRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AlertFeedback>;
  /**
   * Lists all the feedback for an alert. Attempting to list feedbacks for
   * a non-existent alert returns `NOT_FOUND` error.
   */
  listAlertFeedback(
    request: DeepPartial<ListAlertFeedbackRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAlertFeedbackResponse>;
  /**
   * Returns the metadata of an alert. Attempting to get metadata for
   * a non-existent alert returns `NOT_FOUND` error.
   */
  getAlertMetadata(
    request: DeepPartial<GetAlertMetadataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AlertMetadata>;
  /** Returns customer-level settings. */
  getSettings(request: DeepPartial<GetSettingsRequest>, options?: CallOptions & CallOptionsExt): Promise<Settings>;
  /** Updates the customer-level settings. */
  updateSettings(
    request: DeepPartial<UpdateSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Settings>;
  /** Performs batch delete operation on alerts. */
  batchDeleteAlerts(
    request: DeepPartial<BatchDeleteAlertsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchDeleteAlertsResponse>;
  /** Performs batch undelete operation on alerts. */
  batchUndeleteAlerts(
    request: DeepPartial<BatchUndeleteAlertsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchUndeleteAlertsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
