// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/cloudbuild/v2/repositories.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { HttpBody } from "../../../api/httpbody.js";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.devtools.cloudbuild.v2";

/**
 * A connection to a SCM like GitHub, GitHub Enterprise, Bitbucket Data Center,
 * Bitbucket Cloud or GitLab.
 */
export interface Connection {
  /**
   * Immutable. The resource name of the connection, in the format
   * `projects/{project}/locations/{location}/connections/{connection_id}`.
   */
  name: string;
  /** Output only. Server assigned timestamp for when the connection was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Server assigned timestamp for when the connection was updated. */
  updateTime:
    | Date
    | undefined;
  /** Configuration for connections to github.com. */
  githubConfig?:
    | GitHubConfig
    | undefined;
  /** Configuration for connections to an instance of GitHub Enterprise. */
  githubEnterpriseConfig?:
    | GitHubEnterpriseConfig
    | undefined;
  /**
   * Configuration for connections to gitlab.com or an instance of GitLab
   * Enterprise.
   */
  gitlabConfig?:
    | GitLabConfig
    | undefined;
  /** Configuration for connections to Bitbucket Data Center. */
  bitbucketDataCenterConfig?:
    | BitbucketDataCenterConfig
    | undefined;
  /** Configuration for connections to Bitbucket Cloud. */
  bitbucketCloudConfig?:
    | BitbucketCloudConfig
    | undefined;
  /** Output only. Installation state of the Connection. */
  installationState:
    | InstallationState
    | undefined;
  /**
   * If disabled is set to true, functionality is disabled for this connection.
   * Repository based API methods and webhooks processing for repositories in
   * this connection will be disabled.
   */
  disabled: boolean;
  /**
   * Output only. Set to true when the connection is being set up or updated in
   * the background.
   */
  reconciling: boolean;
  /** Allows clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

export interface Connection_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes stage and necessary actions to be taken by the
 * user to complete the installation. Used for GitHub and GitHub Enterprise
 * based connections.
 */
export interface InstallationState {
  /** Output only. Current step of the installation process. */
  stage: InstallationState_Stage;
  /**
   * Output only. Message of what the user should do next to continue the
   * installation. Empty string if the installation is already complete.
   */
  message: string;
  /**
   * Output only. Link to follow for next action. Empty string if the
   * installation is already complete.
   */
  actionUri: string;
}

/** Stage of the installation process. */
export enum InstallationState_Stage {
  /** STAGE_UNSPECIFIED - No stage specified. */
  STAGE_UNSPECIFIED = 0,
  /**
   * PENDING_CREATE_APP - Only for GitHub Enterprise. An App creation has been requested.
   * The user needs to confirm the creation in their GitHub enterprise host.
   */
  PENDING_CREATE_APP = 1,
  /** PENDING_USER_OAUTH - User needs to authorize the GitHub (or Enterprise) App via OAuth. */
  PENDING_USER_OAUTH = 2,
  /** PENDING_INSTALL_APP - User needs to follow the link to install the GitHub (or Enterprise) App. */
  PENDING_INSTALL_APP = 3,
  /** COMPLETE - Installation process has been completed. */
  COMPLETE = 10,
  UNRECOGNIZED = -1,
}

export function installationState_StageFromJSON(object: any): InstallationState_Stage {
  switch (object) {
    case 0:
    case "STAGE_UNSPECIFIED":
      return InstallationState_Stage.STAGE_UNSPECIFIED;
    case 1:
    case "PENDING_CREATE_APP":
      return InstallationState_Stage.PENDING_CREATE_APP;
    case 2:
    case "PENDING_USER_OAUTH":
      return InstallationState_Stage.PENDING_USER_OAUTH;
    case 3:
    case "PENDING_INSTALL_APP":
      return InstallationState_Stage.PENDING_INSTALL_APP;
    case 10:
    case "COMPLETE":
      return InstallationState_Stage.COMPLETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstallationState_Stage.UNRECOGNIZED;
  }
}

export function installationState_StageToJSON(object: InstallationState_Stage): string {
  switch (object) {
    case InstallationState_Stage.STAGE_UNSPECIFIED:
      return "STAGE_UNSPECIFIED";
    case InstallationState_Stage.PENDING_CREATE_APP:
      return "PENDING_CREATE_APP";
    case InstallationState_Stage.PENDING_USER_OAUTH:
      return "PENDING_USER_OAUTH";
    case InstallationState_Stage.PENDING_INSTALL_APP:
      return "PENDING_INSTALL_APP";
    case InstallationState_Stage.COMPLETE:
      return "COMPLETE";
    case InstallationState_Stage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for FetchLinkableRepositories. */
export interface FetchLinkableRepositoriesRequest {
  /**
   * Required. The name of the Connection.
   * Format: `projects/* /locations/* /connections/*`.
   */
  connection: string;
  /** Number of results to return in the list. Default to 20. */
  pageSize: number;
  /** Page start. */
  pageToken: string;
}

/** Response message for FetchLinkableRepositories. */
export interface FetchLinkableRepositoriesResponse {
  /** repositories ready to be created. */
  repositories: Repository[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
}

/** Configuration for connections to github.com. */
export interface GitHubConfig {
  /**
   * OAuth credential of the account that authorized the Cloud Build GitHub App.
   * It is recommended to use a robot account instead of a human user account.
   * The OAuth token must be tied to the Cloud Build GitHub App.
   */
  authorizerCredential:
    | OAuthCredential
    | undefined;
  /** GitHub App installation id. */
  appInstallationId: Long;
}

/** Configuration for connections to an instance of GitHub Enterprise. */
export interface GitHubEnterpriseConfig {
  /** Required. The URI of the GitHub Enterprise host this connection is for. */
  hostUri: string;
  /** Required. API Key used for authentication of webhook events. */
  apiKey: string;
  /** Id of the GitHub App created from the manifest. */
  appId: Long;
  /** The URL-friendly name of the GitHub App. */
  appSlug: string;
  /**
   * SecretManager resource containing the private key of the GitHub App,
   * formatted as `projects/* /secrets/* /versions/*`.
   */
  privateKeySecretVersion: string;
  /**
   * SecretManager resource containing the webhook secret of the GitHub App,
   * formatted as `projects/* /secrets/* /versions/*`.
   */
  webhookSecretSecretVersion: string;
  /** ID of the installation of the GitHub App. */
  appInstallationId: Long;
  /**
   * Configuration for using Service Directory to privately connect to a GitHub
   * Enterprise server. This should only be set if the GitHub Enterprise server
   * is hosted on-premises and not reachable by public internet. If this field
   * is left empty, calls to the GitHub Enterprise server will be made over the
   * public internet.
   */
  serviceDirectoryConfig:
    | ServiceDirectoryConfig
    | undefined;
  /** SSL certificate to use for requests to GitHub Enterprise. */
  sslCa: string;
  /** Output only. GitHub Enterprise version installed at the host_uri. */
  serverVersion: string;
}

/**
 * Configuration for connections to gitlab.com or an instance of GitLab
 * Enterprise.
 */
export interface GitLabConfig {
  /**
   * The URI of the GitLab Enterprise host this connection is for.
   * If not specified, the default value is https://gitlab.com.
   */
  hostUri: string;
  /**
   * Required. Immutable. SecretManager resource containing the webhook secret
   * of a GitLab Enterprise project, formatted as
   * `projects/* /secrets/* /versions/*`.
   */
  webhookSecretSecretVersion: string;
  /**
   * Required. A GitLab personal access token with the minimum `read_api` scope
   * access.
   */
  readAuthorizerCredential:
    | UserCredential
    | undefined;
  /** Required. A GitLab personal access token with the `api` scope access. */
  authorizerCredential:
    | UserCredential
    | undefined;
  /**
   * Configuration for using Service Directory to privately connect to a GitLab
   * Enterprise server. This should only be set if the GitLab Enterprise server
   * is hosted on-premises and not reachable by public internet. If this field
   * is left empty, calls to the GitLab Enterprise server will be made over the
   * public internet.
   */
  serviceDirectoryConfig:
    | ServiceDirectoryConfig
    | undefined;
  /** SSL certificate to use for requests to GitLab Enterprise. */
  sslCa: string;
  /**
   * Output only. Version of the GitLab Enterprise server running on the
   * `host_uri`.
   */
  serverVersion: string;
}

/** Configuration for connections to Bitbucket Data Center. */
export interface BitbucketDataCenterConfig {
  /**
   * Required. The URI of the Bitbucket Data Center instance or cluster this
   * connection is for.
   */
  hostUri: string;
  /**
   * Required. Immutable. SecretManager resource containing the webhook secret
   * used to verify webhook events, formatted as
   * `projects/* /secrets/* /versions/*`.
   */
  webhookSecretSecretVersion: string;
  /** Required. A http access token with the `REPO_READ` access. */
  readAuthorizerCredential:
    | UserCredential
    | undefined;
  /** Required. A http access token with the `REPO_ADMIN` scope access. */
  authorizerCredential:
    | UserCredential
    | undefined;
  /**
   * Optional. Configuration for using Service Directory to privately connect to
   * a Bitbucket Data Center. This should only be set if the Bitbucket Data
   * Center is hosted on-premises and not reachable by public internet. If this
   * field is left empty, calls to the Bitbucket Data Center will be made over
   * the public internet.
   */
  serviceDirectoryConfig:
    | ServiceDirectoryConfig
    | undefined;
  /** Optional. SSL certificate to use for requests to the Bitbucket Data Center. */
  sslCa: string;
  /**
   * Output only. Version of the Bitbucket Data Center running on the
   * `host_uri`.
   */
  serverVersion: string;
}

/** Configuration for connections to Bitbucket Cloud. */
export interface BitbucketCloudConfig {
  /**
   * Required. The Bitbucket Cloud Workspace ID to be connected to Google Cloud
   * Platform.
   */
  workspace: string;
  /**
   * Required. SecretManager resource containing the webhook secret used to
   * verify webhook events, formatted as `projects/* /secrets/* /versions/*`.
   */
  webhookSecretSecretVersion: string;
  /**
   * Required. An access token with the `repository` access. It can be either a
   * workspace, project or repository access token. It's recommended to use a
   * system account to generate the credentials.
   */
  readAuthorizerCredential:
    | UserCredential
    | undefined;
  /**
   * Required. An access token with the `webhook`, `repository`,
   * `repository:admin` and `pullrequest` scope access. It can be either a
   * workspace, project or repository access token. It's recommended to use a
   * system account to generate these credentials.
   */
  authorizerCredential: UserCredential | undefined;
}

/**
 * ServiceDirectoryConfig represents Service Directory configuration for a
 * connection.
 */
export interface ServiceDirectoryConfig {
  /**
   * Required. The Service Directory service name.
   * Format:
   * projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
   */
  service: string;
}

/** A repository associated to a parent connection. */
export interface Repository {
  /**
   * Immutable. Resource name of the repository, in the format
   * `projects/* /locations/* /connections/* /repositories/*`.
   */
  name: string;
  /** Required. Git Clone HTTPS URI. */
  remoteUri: string;
  /** Output only. Server assigned timestamp for when the connection was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Server assigned timestamp for when the connection was updated. */
  updateTime:
    | Date
    | undefined;
  /** Allows clients to store small amounts of arbitrary data. */
  annotations: { [key: string]: string };
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /** Output only. External ID of the webhook created for the repository. */
  webhookId: string;
}

export interface Repository_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Represents an OAuth token of the account that authorized the Connection,
 * and associated metadata.
 */
export interface OAuthCredential {
  /**
   * A SecretManager resource containing the OAuth token that authorizes
   * the Cloud Build connection. Format: `projects/* /secrets/* /versions/*`.
   */
  oauthTokenSecretVersion: string;
  /** Output only. The username associated to this token. */
  username: string;
}

/**
 * Represents a personal access token that authorized the Connection,
 * and associated metadata.
 */
export interface UserCredential {
  /**
   * Required. A SecretManager resource containing the user token that
   * authorizes the Cloud Build connection. Format:
   * `projects/* /secrets/* /versions/*`.
   */
  userTokenSecretVersion: string;
  /** Output only. The username associated to this token. */
  username: string;
}

/** Message for creating a Connection */
export interface CreateConnectionRequest {
  /**
   * Required. Project and location where the connection will be created.
   * Format: `projects/* /locations/*`.
   */
  parent: string;
  /** Required. The Connection to create. */
  connection:
    | Connection
    | undefined;
  /**
   * Required. The ID to use for the Connection, which will become the final
   * component of the Connection's resource name. Names must be unique
   * per-project per-location. Allows alphanumeric characters and any of
   * -._~%!$&'()*+,;=@.
   */
  connectionId: string;
}

/** Message for getting the details of a Connection. */
export interface GetConnectionRequest {
  /**
   * Required. The name of the Connection to retrieve.
   * Format: `projects/* /locations/* /connections/*`.
   */
  name: string;
}

/** Message for requesting list of Connections. */
export interface ListConnectionsRequest {
  /**
   * Required. The parent, which owns this collection of Connections.
   * Format: `projects/* /locations/*`.
   */
  parent: string;
  /** Number of results to return in the list. */
  pageSize: number;
  /** Page start. */
  pageToken: string;
}

/** Message for response to listing Connections. */
export interface ListConnectionsResponse {
  /** The list of Connections. */
  connections: Connection[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
}

/** Message for updating a Connection. */
export interface UpdateConnectionRequest {
  /** Required. The Connection to update. */
  connection:
    | Connection
    | undefined;
  /** The list of fields to be updated. */
  updateMask:
    | string[]
    | undefined;
  /**
   * If set to true, and the connection is not found a new connection
   * will be created. In this situation `update_mask` is ignored.
   * The creation will succeed only if the input connection has all the
   * necessary information (e.g a github_config with both  user_oauth_token and
   * installation_id properties).
   */
  allowMissing: boolean;
  /**
   * The current etag of the connection.
   * If an etag is provided and does not match the current etag of the
   * connection, update will be blocked and an ABORTED error will be returned.
   */
  etag: string;
}

/** Message for deleting a Connection. */
export interface DeleteConnectionRequest {
  /**
   * Required. The name of the Connection to delete.
   * Format: `projects/* /locations/* /connections/*`.
   */
  name: string;
  /**
   * The current etag of the connection.
   * If an etag is provided and does not match the current etag of the
   * connection, deletion will be blocked and an ABORTED error will be returned.
   */
  etag: string;
  /** If set, validate the request, but do not actually post it. */
  validateOnly: boolean;
}

/** Message for creating a Repository. */
export interface CreateRepositoryRequest {
  /**
   * Required. The connection to contain the repository. If the request is part
   * of a BatchCreateRepositoriesRequest, this field should be empty or match
   * the parent specified there.
   */
  parent: string;
  /** Required. The repository to create. */
  repository:
    | Repository
    | undefined;
  /**
   * Required. The ID to use for the repository, which will become the final
   * component of the repository's resource name. This ID should be unique in
   * the connection. Allows alphanumeric characters and any of
   * -._~%!$&'()*+,;=@.
   */
  repositoryId: string;
}

/** Message for creating repositoritories in batch. */
export interface BatchCreateRepositoriesRequest {
  /**
   * Required. The connection to contain all the repositories being created.
   * Format: projects/* /locations/* /connections/*
   * The parent field in the CreateRepositoryRequest messages
   * must either be empty or match this field.
   */
  parent: string;
  /** Required. The request messages specifying the repositories to create. */
  requests: CreateRepositoryRequest[];
}

/** Message for response of creating repositories in batch. */
export interface BatchCreateRepositoriesResponse {
  /** Repository resources created. */
  repositories: Repository[];
}

/** Message for getting the details of a Repository. */
export interface GetRepositoryRequest {
  /**
   * Required. The name of the Repository to retrieve.
   * Format: `projects/* /locations/* /connections/* /repositories/*`.
   */
  name: string;
}

/** Message for requesting list of Repositories. */
export interface ListRepositoriesRequest {
  /**
   * Required. The parent, which owns this collection of Repositories.
   * Format: `projects/* /locations/* /connections/*`.
   */
  parent: string;
  /** Number of results to return in the list. */
  pageSize: number;
  /** Page start. */
  pageToken: string;
  /**
   * A filter expression that filters resources listed in the response.
   * Expressions must follow API improvement proposal
   * [AIP-160](https://google.aip.dev/160). e.g.
   * `remote_uri:"https://github.com*"`.
   */
  filter: string;
}

/** Message for response to listing Repositories. */
export interface ListRepositoriesResponse {
  /** The list of Repositories. */
  repositories: Repository[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
}

/** Message for deleting a Repository. */
export interface DeleteRepositoryRequest {
  /**
   * Required. The name of the Repository to delete.
   * Format: `projects/* /locations/* /connections/* /repositories/*`.
   */
  name: string;
  /**
   * The current etag of the repository.
   * If an etag is provided and does not match the current etag of the
   * repository, deletion will be blocked and an ABORTED error will be returned.
   */
  etag: string;
  /** If set, validate the request, but do not actually post it. */
  validateOnly: boolean;
}

/** Message for fetching SCM read/write token. */
export interface FetchReadWriteTokenRequest {
  /**
   * Required. The resource name of the repository in the format
   * `projects/* /locations/* /connections/* /repositories/*`.
   */
  repository: string;
}

/** Message for fetching SCM read token. */
export interface FetchReadTokenRequest {
  /**
   * Required. The resource name of the repository in the format
   * `projects/* /locations/* /connections/* /repositories/*`.
   */
  repository: string;
}

/** Message for responding to get read token. */
export interface FetchReadTokenResponse {
  /** The token content. */
  token: string;
  /** Expiration timestamp. Can be empty if unknown or non-expiring. */
  expirationTime: Date | undefined;
}

/** Message for responding to get read/write token. */
export interface FetchReadWriteTokenResponse {
  /** The token content. */
  token: string;
  /** Expiration timestamp. Can be empty if unknown or non-expiring. */
  expirationTime: Date | undefined;
}

/** RPC request object accepted by the ProcessWebhook RPC method. */
export interface ProcessWebhookRequest {
  /**
   * Required. Project and location where the webhook will be received.
   * Format: `projects/* /locations/*`.
   */
  parent: string;
  /** HTTP request body. */
  body:
    | HttpBody
    | undefined;
  /**
   * Arbitrary additional key to find the maching repository for a webhook event
   * if needed.
   */
  webhookKey: string;
}

/** Request for fetching git refs */
export interface FetchGitRefsRequest {
  /**
   * Required. The resource name of the repository in the format
   * `projects/* /locations/* /connections/* /repositories/*`.
   */
  repository: string;
  /** Type of refs to fetch */
  refType: FetchGitRefsRequest_RefType;
}

/** Type of refs */
export enum FetchGitRefsRequest_RefType {
  /** REF_TYPE_UNSPECIFIED - No type specified. */
  REF_TYPE_UNSPECIFIED = 0,
  /** TAG - To fetch tags. */
  TAG = 1,
  /** BRANCH - To fetch branches. */
  BRANCH = 2,
  UNRECOGNIZED = -1,
}

export function fetchGitRefsRequest_RefTypeFromJSON(object: any): FetchGitRefsRequest_RefType {
  switch (object) {
    case 0:
    case "REF_TYPE_UNSPECIFIED":
      return FetchGitRefsRequest_RefType.REF_TYPE_UNSPECIFIED;
    case 1:
    case "TAG":
      return FetchGitRefsRequest_RefType.TAG;
    case 2:
    case "BRANCH":
      return FetchGitRefsRequest_RefType.BRANCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FetchGitRefsRequest_RefType.UNRECOGNIZED;
  }
}

export function fetchGitRefsRequest_RefTypeToJSON(object: FetchGitRefsRequest_RefType): string {
  switch (object) {
    case FetchGitRefsRequest_RefType.REF_TYPE_UNSPECIFIED:
      return "REF_TYPE_UNSPECIFIED";
    case FetchGitRefsRequest_RefType.TAG:
      return "TAG";
    case FetchGitRefsRequest_RefType.BRANCH:
      return "BRANCH";
    case FetchGitRefsRequest_RefType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response for fetching git refs */
export interface FetchGitRefsResponse {
  /** Name of the refs fetched. */
  refNames: string[];
}

function createBaseConnection(): Connection {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    githubConfig: undefined,
    githubEnterpriseConfig: undefined,
    gitlabConfig: undefined,
    bitbucketDataCenterConfig: undefined,
    bitbucketCloudConfig: undefined,
    installationState: undefined,
    disabled: false,
    reconciling: false,
    annotations: {},
    etag: "",
  };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.githubConfig !== undefined) {
      GitHubConfig.encode(message.githubConfig, writer.uint32(42).fork()).join();
    }
    if (message.githubEnterpriseConfig !== undefined) {
      GitHubEnterpriseConfig.encode(message.githubEnterpriseConfig, writer.uint32(50).fork()).join();
    }
    if (message.gitlabConfig !== undefined) {
      GitLabConfig.encode(message.gitlabConfig, writer.uint32(58).fork()).join();
    }
    if (message.bitbucketDataCenterConfig !== undefined) {
      BitbucketDataCenterConfig.encode(message.bitbucketDataCenterConfig, writer.uint32(66).fork()).join();
    }
    if (message.bitbucketCloudConfig !== undefined) {
      BitbucketCloudConfig.encode(message.bitbucketCloudConfig, writer.uint32(74).fork()).join();
    }
    if (message.installationState !== undefined) {
      InstallationState.encode(message.installationState, writer.uint32(98).fork()).join();
    }
    if (message.disabled !== false) {
      writer.uint32(104).bool(message.disabled);
    }
    if (message.reconciling !== false) {
      writer.uint32(112).bool(message.reconciling);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Connection_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(130).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.githubConfig = GitHubConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.githubEnterpriseConfig = GitHubEnterpriseConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gitlabConfig = GitLabConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bitbucketDataCenterConfig = BitbucketDataCenterConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.bitbucketCloudConfig = BitbucketCloudConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.installationState = InstallationState.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = Connection_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.annotations[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      githubConfig: isSet(object.githubConfig) ? GitHubConfig.fromJSON(object.githubConfig) : undefined,
      githubEnterpriseConfig: isSet(object.githubEnterpriseConfig)
        ? GitHubEnterpriseConfig.fromJSON(object.githubEnterpriseConfig)
        : undefined,
      gitlabConfig: isSet(object.gitlabConfig) ? GitLabConfig.fromJSON(object.gitlabConfig) : undefined,
      bitbucketDataCenterConfig: isSet(object.bitbucketDataCenterConfig)
        ? BitbucketDataCenterConfig.fromJSON(object.bitbucketDataCenterConfig)
        : undefined,
      bitbucketCloudConfig: isSet(object.bitbucketCloudConfig)
        ? BitbucketCloudConfig.fromJSON(object.bitbucketCloudConfig)
        : undefined,
      installationState: isSet(object.installationState)
        ? InstallationState.fromJSON(object.installationState)
        : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.githubConfig !== undefined) {
      obj.githubConfig = GitHubConfig.toJSON(message.githubConfig);
    }
    if (message.githubEnterpriseConfig !== undefined) {
      obj.githubEnterpriseConfig = GitHubEnterpriseConfig.toJSON(message.githubEnterpriseConfig);
    }
    if (message.gitlabConfig !== undefined) {
      obj.gitlabConfig = GitLabConfig.toJSON(message.gitlabConfig);
    }
    if (message.bitbucketDataCenterConfig !== undefined) {
      obj.bitbucketDataCenterConfig = BitbucketDataCenterConfig.toJSON(message.bitbucketDataCenterConfig);
    }
    if (message.bitbucketCloudConfig !== undefined) {
      obj.bitbucketCloudConfig = BitbucketCloudConfig.toJSON(message.bitbucketCloudConfig);
    }
    if (message.installationState !== undefined) {
      obj.installationState = InstallationState.toJSON(message.installationState);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Connection>): Connection {
    return Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection>): Connection {
    const message = createBaseConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.githubConfig = (object.githubConfig !== undefined && object.githubConfig !== null)
      ? GitHubConfig.fromPartial(object.githubConfig)
      : undefined;
    message.githubEnterpriseConfig =
      (object.githubEnterpriseConfig !== undefined && object.githubEnterpriseConfig !== null)
        ? GitHubEnterpriseConfig.fromPartial(object.githubEnterpriseConfig)
        : undefined;
    message.gitlabConfig = (object.gitlabConfig !== undefined && object.gitlabConfig !== null)
      ? GitLabConfig.fromPartial(object.gitlabConfig)
      : undefined;
    message.bitbucketDataCenterConfig =
      (object.bitbucketDataCenterConfig !== undefined && object.bitbucketDataCenterConfig !== null)
        ? BitbucketDataCenterConfig.fromPartial(object.bitbucketDataCenterConfig)
        : undefined;
    message.bitbucketCloudConfig = (object.bitbucketCloudConfig !== undefined && object.bitbucketCloudConfig !== null)
      ? BitbucketCloudConfig.fromPartial(object.bitbucketCloudConfig)
      : undefined;
    message.installationState = (object.installationState !== undefined && object.installationState !== null)
      ? InstallationState.fromPartial(object.installationState)
      : undefined;
    message.disabled = object.disabled ?? false;
    message.reconciling = object.reconciling ?? false;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseConnection_AnnotationsEntry(): Connection_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Connection_AnnotationsEntry: MessageFns<Connection_AnnotationsEntry> = {
  encode(message: Connection_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Connection_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Connection_AnnotationsEntry>): Connection_AnnotationsEntry {
    return Connection_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection_AnnotationsEntry>): Connection_AnnotationsEntry {
    const message = createBaseConnection_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstallationState(): InstallationState {
  return { stage: 0, message: "", actionUri: "" };
}

export const InstallationState: MessageFns<InstallationState> = {
  encode(message: InstallationState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== 0) {
      writer.uint32(8).int32(message.stage);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.actionUri !== "") {
      writer.uint32(26).string(message.actionUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstallationState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstallationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stage = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstallationState {
    return {
      stage: isSet(object.stage) ? installationState_StageFromJSON(object.stage) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      actionUri: isSet(object.actionUri) ? globalThis.String(object.actionUri) : "",
    };
  },

  toJSON(message: InstallationState): unknown {
    const obj: any = {};
    if (message.stage !== 0) {
      obj.stage = installationState_StageToJSON(message.stage);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.actionUri !== "") {
      obj.actionUri = message.actionUri;
    }
    return obj;
  },

  create(base?: DeepPartial<InstallationState>): InstallationState {
    return InstallationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstallationState>): InstallationState {
    const message = createBaseInstallationState();
    message.stage = object.stage ?? 0;
    message.message = object.message ?? "";
    message.actionUri = object.actionUri ?? "";
    return message;
  },
};

function createBaseFetchLinkableRepositoriesRequest(): FetchLinkableRepositoriesRequest {
  return { connection: "", pageSize: 0, pageToken: "" };
}

export const FetchLinkableRepositoriesRequest: MessageFns<FetchLinkableRepositoriesRequest> = {
  encode(message: FetchLinkableRepositoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection !== "") {
      writer.uint32(10).string(message.connection);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchLinkableRepositoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchLinkableRepositoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connection = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchLinkableRepositoriesRequest {
    return {
      connection: isSet(object.connection) ? globalThis.String(object.connection) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: FetchLinkableRepositoriesRequest): unknown {
    const obj: any = {};
    if (message.connection !== "") {
      obj.connection = message.connection;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchLinkableRepositoriesRequest>): FetchLinkableRepositoriesRequest {
    return FetchLinkableRepositoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchLinkableRepositoriesRequest>): FetchLinkableRepositoriesRequest {
    const message = createBaseFetchLinkableRepositoriesRequest();
    message.connection = object.connection ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseFetchLinkableRepositoriesResponse(): FetchLinkableRepositoriesResponse {
  return { repositories: [], nextPageToken: "" };
}

export const FetchLinkableRepositoriesResponse: MessageFns<FetchLinkableRepositoriesResponse> = {
  encode(message: FetchLinkableRepositoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repositories) {
      Repository.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchLinkableRepositoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchLinkableRepositoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repositories.push(Repository.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchLinkableRepositoriesResponse {
    return {
      repositories: globalThis.Array.isArray(object?.repositories)
        ? object.repositories.map((e: any) => Repository.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: FetchLinkableRepositoriesResponse): unknown {
    const obj: any = {};
    if (message.repositories?.length) {
      obj.repositories = message.repositories.map((e) => Repository.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchLinkableRepositoriesResponse>): FetchLinkableRepositoriesResponse {
    return FetchLinkableRepositoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchLinkableRepositoriesResponse>): FetchLinkableRepositoriesResponse {
    const message = createBaseFetchLinkableRepositoriesResponse();
    message.repositories = object.repositories?.map((e) => Repository.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGitHubConfig(): GitHubConfig {
  return { authorizerCredential: undefined, appInstallationId: Long.ZERO };
}

export const GitHubConfig: MessageFns<GitHubConfig> = {
  encode(message: GitHubConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizerCredential !== undefined) {
      OAuthCredential.encode(message.authorizerCredential, writer.uint32(10).fork()).join();
    }
    if (!message.appInstallationId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.appInstallationId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitHubConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitHubConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authorizerCredential = OAuthCredential.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appInstallationId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitHubConfig {
    return {
      authorizerCredential: isSet(object.authorizerCredential)
        ? OAuthCredential.fromJSON(object.authorizerCredential)
        : undefined,
      appInstallationId: isSet(object.appInstallationId) ? Long.fromValue(object.appInstallationId) : Long.ZERO,
    };
  },

  toJSON(message: GitHubConfig): unknown {
    const obj: any = {};
    if (message.authorizerCredential !== undefined) {
      obj.authorizerCredential = OAuthCredential.toJSON(message.authorizerCredential);
    }
    if (!message.appInstallationId.equals(Long.ZERO)) {
      obj.appInstallationId = (message.appInstallationId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GitHubConfig>): GitHubConfig {
    return GitHubConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitHubConfig>): GitHubConfig {
    const message = createBaseGitHubConfig();
    message.authorizerCredential = (object.authorizerCredential !== undefined && object.authorizerCredential !== null)
      ? OAuthCredential.fromPartial(object.authorizerCredential)
      : undefined;
    message.appInstallationId = (object.appInstallationId !== undefined && object.appInstallationId !== null)
      ? Long.fromValue(object.appInstallationId)
      : Long.ZERO;
    return message;
  },
};

function createBaseGitHubEnterpriseConfig(): GitHubEnterpriseConfig {
  return {
    hostUri: "",
    apiKey: "",
    appId: Long.ZERO,
    appSlug: "",
    privateKeySecretVersion: "",
    webhookSecretSecretVersion: "",
    appInstallationId: Long.ZERO,
    serviceDirectoryConfig: undefined,
    sslCa: "",
    serverVersion: "",
  };
}

export const GitHubEnterpriseConfig: MessageFns<GitHubEnterpriseConfig> = {
  encode(message: GitHubEnterpriseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUri !== "") {
      writer.uint32(10).string(message.hostUri);
    }
    if (message.apiKey !== "") {
      writer.uint32(98).string(message.apiKey);
    }
    if (!message.appId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.appId.toString());
    }
    if (message.appSlug !== "") {
      writer.uint32(106).string(message.appSlug);
    }
    if (message.privateKeySecretVersion !== "") {
      writer.uint32(34).string(message.privateKeySecretVersion);
    }
    if (message.webhookSecretSecretVersion !== "") {
      writer.uint32(42).string(message.webhookSecretSecretVersion);
    }
    if (!message.appInstallationId.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.appInstallationId.toString());
    }
    if (message.serviceDirectoryConfig !== undefined) {
      ServiceDirectoryConfig.encode(message.serviceDirectoryConfig, writer.uint32(82).fork()).join();
    }
    if (message.sslCa !== "") {
      writer.uint32(90).string(message.sslCa);
    }
    if (message.serverVersion !== "") {
      writer.uint32(114).string(message.serverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitHubEnterpriseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitHubEnterpriseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostUri = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appId = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.appSlug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.privateKeySecretVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.webhookSecretSecretVersion = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.appInstallationId = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.serviceDirectoryConfig = ServiceDirectoryConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sslCa = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitHubEnterpriseConfig {
    return {
      hostUri: isSet(object.hostUri) ? globalThis.String(object.hostUri) : "",
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      appId: isSet(object.appId) ? Long.fromValue(object.appId) : Long.ZERO,
      appSlug: isSet(object.appSlug) ? globalThis.String(object.appSlug) : "",
      privateKeySecretVersion: isSet(object.privateKeySecretVersion)
        ? globalThis.String(object.privateKeySecretVersion)
        : "",
      webhookSecretSecretVersion: isSet(object.webhookSecretSecretVersion)
        ? globalThis.String(object.webhookSecretSecretVersion)
        : "",
      appInstallationId: isSet(object.appInstallationId) ? Long.fromValue(object.appInstallationId) : Long.ZERO,
      serviceDirectoryConfig: isSet(object.serviceDirectoryConfig)
        ? ServiceDirectoryConfig.fromJSON(object.serviceDirectoryConfig)
        : undefined,
      sslCa: isSet(object.sslCa) ? globalThis.String(object.sslCa) : "",
      serverVersion: isSet(object.serverVersion) ? globalThis.String(object.serverVersion) : "",
    };
  },

  toJSON(message: GitHubEnterpriseConfig): unknown {
    const obj: any = {};
    if (message.hostUri !== "") {
      obj.hostUri = message.hostUri;
    }
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (!message.appId.equals(Long.ZERO)) {
      obj.appId = (message.appId || Long.ZERO).toString();
    }
    if (message.appSlug !== "") {
      obj.appSlug = message.appSlug;
    }
    if (message.privateKeySecretVersion !== "") {
      obj.privateKeySecretVersion = message.privateKeySecretVersion;
    }
    if (message.webhookSecretSecretVersion !== "") {
      obj.webhookSecretSecretVersion = message.webhookSecretSecretVersion;
    }
    if (!message.appInstallationId.equals(Long.ZERO)) {
      obj.appInstallationId = (message.appInstallationId || Long.ZERO).toString();
    }
    if (message.serviceDirectoryConfig !== undefined) {
      obj.serviceDirectoryConfig = ServiceDirectoryConfig.toJSON(message.serviceDirectoryConfig);
    }
    if (message.sslCa !== "") {
      obj.sslCa = message.sslCa;
    }
    if (message.serverVersion !== "") {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<GitHubEnterpriseConfig>): GitHubEnterpriseConfig {
    return GitHubEnterpriseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitHubEnterpriseConfig>): GitHubEnterpriseConfig {
    const message = createBaseGitHubEnterpriseConfig();
    message.hostUri = object.hostUri ?? "";
    message.apiKey = object.apiKey ?? "";
    message.appId = (object.appId !== undefined && object.appId !== null) ? Long.fromValue(object.appId) : Long.ZERO;
    message.appSlug = object.appSlug ?? "";
    message.privateKeySecretVersion = object.privateKeySecretVersion ?? "";
    message.webhookSecretSecretVersion = object.webhookSecretSecretVersion ?? "";
    message.appInstallationId = (object.appInstallationId !== undefined && object.appInstallationId !== null)
      ? Long.fromValue(object.appInstallationId)
      : Long.ZERO;
    message.serviceDirectoryConfig =
      (object.serviceDirectoryConfig !== undefined && object.serviceDirectoryConfig !== null)
        ? ServiceDirectoryConfig.fromPartial(object.serviceDirectoryConfig)
        : undefined;
    message.sslCa = object.sslCa ?? "";
    message.serverVersion = object.serverVersion ?? "";
    return message;
  },
};

function createBaseGitLabConfig(): GitLabConfig {
  return {
    hostUri: "",
    webhookSecretSecretVersion: "",
    readAuthorizerCredential: undefined,
    authorizerCredential: undefined,
    serviceDirectoryConfig: undefined,
    sslCa: "",
    serverVersion: "",
  };
}

export const GitLabConfig: MessageFns<GitLabConfig> = {
  encode(message: GitLabConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUri !== "") {
      writer.uint32(10).string(message.hostUri);
    }
    if (message.webhookSecretSecretVersion !== "") {
      writer.uint32(18).string(message.webhookSecretSecretVersion);
    }
    if (message.readAuthorizerCredential !== undefined) {
      UserCredential.encode(message.readAuthorizerCredential, writer.uint32(26).fork()).join();
    }
    if (message.authorizerCredential !== undefined) {
      UserCredential.encode(message.authorizerCredential, writer.uint32(34).fork()).join();
    }
    if (message.serviceDirectoryConfig !== undefined) {
      ServiceDirectoryConfig.encode(message.serviceDirectoryConfig, writer.uint32(42).fork()).join();
    }
    if (message.sslCa !== "") {
      writer.uint32(50).string(message.sslCa);
    }
    if (message.serverVersion !== "") {
      writer.uint32(58).string(message.serverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitLabConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitLabConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhookSecretSecretVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readAuthorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceDirectoryConfig = ServiceDirectoryConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sslCa = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitLabConfig {
    return {
      hostUri: isSet(object.hostUri) ? globalThis.String(object.hostUri) : "",
      webhookSecretSecretVersion: isSet(object.webhookSecretSecretVersion)
        ? globalThis.String(object.webhookSecretSecretVersion)
        : "",
      readAuthorizerCredential: isSet(object.readAuthorizerCredential)
        ? UserCredential.fromJSON(object.readAuthorizerCredential)
        : undefined,
      authorizerCredential: isSet(object.authorizerCredential)
        ? UserCredential.fromJSON(object.authorizerCredential)
        : undefined,
      serviceDirectoryConfig: isSet(object.serviceDirectoryConfig)
        ? ServiceDirectoryConfig.fromJSON(object.serviceDirectoryConfig)
        : undefined,
      sslCa: isSet(object.sslCa) ? globalThis.String(object.sslCa) : "",
      serverVersion: isSet(object.serverVersion) ? globalThis.String(object.serverVersion) : "",
    };
  },

  toJSON(message: GitLabConfig): unknown {
    const obj: any = {};
    if (message.hostUri !== "") {
      obj.hostUri = message.hostUri;
    }
    if (message.webhookSecretSecretVersion !== "") {
      obj.webhookSecretSecretVersion = message.webhookSecretSecretVersion;
    }
    if (message.readAuthorizerCredential !== undefined) {
      obj.readAuthorizerCredential = UserCredential.toJSON(message.readAuthorizerCredential);
    }
    if (message.authorizerCredential !== undefined) {
      obj.authorizerCredential = UserCredential.toJSON(message.authorizerCredential);
    }
    if (message.serviceDirectoryConfig !== undefined) {
      obj.serviceDirectoryConfig = ServiceDirectoryConfig.toJSON(message.serviceDirectoryConfig);
    }
    if (message.sslCa !== "") {
      obj.sslCa = message.sslCa;
    }
    if (message.serverVersion !== "") {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<GitLabConfig>): GitLabConfig {
    return GitLabConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitLabConfig>): GitLabConfig {
    const message = createBaseGitLabConfig();
    message.hostUri = object.hostUri ?? "";
    message.webhookSecretSecretVersion = object.webhookSecretSecretVersion ?? "";
    message.readAuthorizerCredential =
      (object.readAuthorizerCredential !== undefined && object.readAuthorizerCredential !== null)
        ? UserCredential.fromPartial(object.readAuthorizerCredential)
        : undefined;
    message.authorizerCredential = (object.authorizerCredential !== undefined && object.authorizerCredential !== null)
      ? UserCredential.fromPartial(object.authorizerCredential)
      : undefined;
    message.serviceDirectoryConfig =
      (object.serviceDirectoryConfig !== undefined && object.serviceDirectoryConfig !== null)
        ? ServiceDirectoryConfig.fromPartial(object.serviceDirectoryConfig)
        : undefined;
    message.sslCa = object.sslCa ?? "";
    message.serverVersion = object.serverVersion ?? "";
    return message;
  },
};

function createBaseBitbucketDataCenterConfig(): BitbucketDataCenterConfig {
  return {
    hostUri: "",
    webhookSecretSecretVersion: "",
    readAuthorizerCredential: undefined,
    authorizerCredential: undefined,
    serviceDirectoryConfig: undefined,
    sslCa: "",
    serverVersion: "",
  };
}

export const BitbucketDataCenterConfig: MessageFns<BitbucketDataCenterConfig> = {
  encode(message: BitbucketDataCenterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUri !== "") {
      writer.uint32(10).string(message.hostUri);
    }
    if (message.webhookSecretSecretVersion !== "") {
      writer.uint32(18).string(message.webhookSecretSecretVersion);
    }
    if (message.readAuthorizerCredential !== undefined) {
      UserCredential.encode(message.readAuthorizerCredential, writer.uint32(26).fork()).join();
    }
    if (message.authorizerCredential !== undefined) {
      UserCredential.encode(message.authorizerCredential, writer.uint32(34).fork()).join();
    }
    if (message.serviceDirectoryConfig !== undefined) {
      ServiceDirectoryConfig.encode(message.serviceDirectoryConfig, writer.uint32(42).fork()).join();
    }
    if (message.sslCa !== "") {
      writer.uint32(50).string(message.sslCa);
    }
    if (message.serverVersion !== "") {
      writer.uint32(58).string(message.serverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BitbucketDataCenterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBitbucketDataCenterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhookSecretSecretVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readAuthorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceDirectoryConfig = ServiceDirectoryConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sslCa = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BitbucketDataCenterConfig {
    return {
      hostUri: isSet(object.hostUri) ? globalThis.String(object.hostUri) : "",
      webhookSecretSecretVersion: isSet(object.webhookSecretSecretVersion)
        ? globalThis.String(object.webhookSecretSecretVersion)
        : "",
      readAuthorizerCredential: isSet(object.readAuthorizerCredential)
        ? UserCredential.fromJSON(object.readAuthorizerCredential)
        : undefined,
      authorizerCredential: isSet(object.authorizerCredential)
        ? UserCredential.fromJSON(object.authorizerCredential)
        : undefined,
      serviceDirectoryConfig: isSet(object.serviceDirectoryConfig)
        ? ServiceDirectoryConfig.fromJSON(object.serviceDirectoryConfig)
        : undefined,
      sslCa: isSet(object.sslCa) ? globalThis.String(object.sslCa) : "",
      serverVersion: isSet(object.serverVersion) ? globalThis.String(object.serverVersion) : "",
    };
  },

  toJSON(message: BitbucketDataCenterConfig): unknown {
    const obj: any = {};
    if (message.hostUri !== "") {
      obj.hostUri = message.hostUri;
    }
    if (message.webhookSecretSecretVersion !== "") {
      obj.webhookSecretSecretVersion = message.webhookSecretSecretVersion;
    }
    if (message.readAuthorizerCredential !== undefined) {
      obj.readAuthorizerCredential = UserCredential.toJSON(message.readAuthorizerCredential);
    }
    if (message.authorizerCredential !== undefined) {
      obj.authorizerCredential = UserCredential.toJSON(message.authorizerCredential);
    }
    if (message.serviceDirectoryConfig !== undefined) {
      obj.serviceDirectoryConfig = ServiceDirectoryConfig.toJSON(message.serviceDirectoryConfig);
    }
    if (message.sslCa !== "") {
      obj.sslCa = message.sslCa;
    }
    if (message.serverVersion !== "") {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<BitbucketDataCenterConfig>): BitbucketDataCenterConfig {
    return BitbucketDataCenterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BitbucketDataCenterConfig>): BitbucketDataCenterConfig {
    const message = createBaseBitbucketDataCenterConfig();
    message.hostUri = object.hostUri ?? "";
    message.webhookSecretSecretVersion = object.webhookSecretSecretVersion ?? "";
    message.readAuthorizerCredential =
      (object.readAuthorizerCredential !== undefined && object.readAuthorizerCredential !== null)
        ? UserCredential.fromPartial(object.readAuthorizerCredential)
        : undefined;
    message.authorizerCredential = (object.authorizerCredential !== undefined && object.authorizerCredential !== null)
      ? UserCredential.fromPartial(object.authorizerCredential)
      : undefined;
    message.serviceDirectoryConfig =
      (object.serviceDirectoryConfig !== undefined && object.serviceDirectoryConfig !== null)
        ? ServiceDirectoryConfig.fromPartial(object.serviceDirectoryConfig)
        : undefined;
    message.sslCa = object.sslCa ?? "";
    message.serverVersion = object.serverVersion ?? "";
    return message;
  },
};

function createBaseBitbucketCloudConfig(): BitbucketCloudConfig {
  return {
    workspace: "",
    webhookSecretSecretVersion: "",
    readAuthorizerCredential: undefined,
    authorizerCredential: undefined,
  };
}

export const BitbucketCloudConfig: MessageFns<BitbucketCloudConfig> = {
  encode(message: BitbucketCloudConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspace !== "") {
      writer.uint32(10).string(message.workspace);
    }
    if (message.webhookSecretSecretVersion !== "") {
      writer.uint32(18).string(message.webhookSecretSecretVersion);
    }
    if (message.readAuthorizerCredential !== undefined) {
      UserCredential.encode(message.readAuthorizerCredential, writer.uint32(26).fork()).join();
    }
    if (message.authorizerCredential !== undefined) {
      UserCredential.encode(message.authorizerCredential, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BitbucketCloudConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBitbucketCloudConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workspace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhookSecretSecretVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readAuthorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authorizerCredential = UserCredential.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BitbucketCloudConfig {
    return {
      workspace: isSet(object.workspace) ? globalThis.String(object.workspace) : "",
      webhookSecretSecretVersion: isSet(object.webhookSecretSecretVersion)
        ? globalThis.String(object.webhookSecretSecretVersion)
        : "",
      readAuthorizerCredential: isSet(object.readAuthorizerCredential)
        ? UserCredential.fromJSON(object.readAuthorizerCredential)
        : undefined,
      authorizerCredential: isSet(object.authorizerCredential)
        ? UserCredential.fromJSON(object.authorizerCredential)
        : undefined,
    };
  },

  toJSON(message: BitbucketCloudConfig): unknown {
    const obj: any = {};
    if (message.workspace !== "") {
      obj.workspace = message.workspace;
    }
    if (message.webhookSecretSecretVersion !== "") {
      obj.webhookSecretSecretVersion = message.webhookSecretSecretVersion;
    }
    if (message.readAuthorizerCredential !== undefined) {
      obj.readAuthorizerCredential = UserCredential.toJSON(message.readAuthorizerCredential);
    }
    if (message.authorizerCredential !== undefined) {
      obj.authorizerCredential = UserCredential.toJSON(message.authorizerCredential);
    }
    return obj;
  },

  create(base?: DeepPartial<BitbucketCloudConfig>): BitbucketCloudConfig {
    return BitbucketCloudConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BitbucketCloudConfig>): BitbucketCloudConfig {
    const message = createBaseBitbucketCloudConfig();
    message.workspace = object.workspace ?? "";
    message.webhookSecretSecretVersion = object.webhookSecretSecretVersion ?? "";
    message.readAuthorizerCredential =
      (object.readAuthorizerCredential !== undefined && object.readAuthorizerCredential !== null)
        ? UserCredential.fromPartial(object.readAuthorizerCredential)
        : undefined;
    message.authorizerCredential = (object.authorizerCredential !== undefined && object.authorizerCredential !== null)
      ? UserCredential.fromPartial(object.authorizerCredential)
      : undefined;
    return message;
  },
};

function createBaseServiceDirectoryConfig(): ServiceDirectoryConfig {
  return { service: "" };
}

export const ServiceDirectoryConfig: MessageFns<ServiceDirectoryConfig> = {
  encode(message: ServiceDirectoryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceDirectoryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceDirectoryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceDirectoryConfig {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: ServiceDirectoryConfig): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceDirectoryConfig>): ServiceDirectoryConfig {
    return ServiceDirectoryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceDirectoryConfig>): ServiceDirectoryConfig {
    const message = createBaseServiceDirectoryConfig();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseRepository(): Repository {
  return {
    name: "",
    remoteUri: "",
    createTime: undefined,
    updateTime: undefined,
    annotations: {},
    etag: "",
    webhookId: "",
  };
}

export const Repository: MessageFns<Repository> = {
  encode(message: Repository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.remoteUri !== "") {
      writer.uint32(18).string(message.remoteUri);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Repository_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(58).string(message.etag);
    }
    if (message.webhookId !== "") {
      writer.uint32(66).string(message.webhookId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Repository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remoteUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Repository_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.annotations[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.webhookId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Repository {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      remoteUri: isSet(object.remoteUri) ? globalThis.String(object.remoteUri) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      webhookId: isSet(object.webhookId) ? globalThis.String(object.webhookId) : "",
    };
  },

  toJSON(message: Repository): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.remoteUri !== "") {
      obj.remoteUri = message.remoteUri;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.webhookId !== "") {
      obj.webhookId = message.webhookId;
    }
    return obj;
  },

  create(base?: DeepPartial<Repository>): Repository {
    return Repository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Repository>): Repository {
    const message = createBaseRepository();
    message.name = object.name ?? "";
    message.remoteUri = object.remoteUri ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    message.webhookId = object.webhookId ?? "";
    return message;
  },
};

function createBaseRepository_AnnotationsEntry(): Repository_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Repository_AnnotationsEntry: MessageFns<Repository_AnnotationsEntry> = {
  encode(message: Repository_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Repository_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepository_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Repository_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Repository_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Repository_AnnotationsEntry>): Repository_AnnotationsEntry {
    return Repository_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Repository_AnnotationsEntry>): Repository_AnnotationsEntry {
    const message = createBaseRepository_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOAuthCredential(): OAuthCredential {
  return { oauthTokenSecretVersion: "", username: "" };
}

export const OAuthCredential: MessageFns<OAuthCredential> = {
  encode(message: OAuthCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oauthTokenSecretVersion !== "") {
      writer.uint32(10).string(message.oauthTokenSecretVersion);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oauthTokenSecretVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthCredential {
    return {
      oauthTokenSecretVersion: isSet(object.oauthTokenSecretVersion)
        ? globalThis.String(object.oauthTokenSecretVersion)
        : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: OAuthCredential): unknown {
    const obj: any = {};
    if (message.oauthTokenSecretVersion !== "") {
      obj.oauthTokenSecretVersion = message.oauthTokenSecretVersion;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<OAuthCredential>): OAuthCredential {
    return OAuthCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OAuthCredential>): OAuthCredential {
    const message = createBaseOAuthCredential();
    message.oauthTokenSecretVersion = object.oauthTokenSecretVersion ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseUserCredential(): UserCredential {
  return { userTokenSecretVersion: "", username: "" };
}

export const UserCredential: MessageFns<UserCredential> = {
  encode(message: UserCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userTokenSecretVersion !== "") {
      writer.uint32(10).string(message.userTokenSecretVersion);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userTokenSecretVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCredential {
    return {
      userTokenSecretVersion: isSet(object.userTokenSecretVersion)
        ? globalThis.String(object.userTokenSecretVersion)
        : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: UserCredential): unknown {
    const obj: any = {};
    if (message.userTokenSecretVersion !== "") {
      obj.userTokenSecretVersion = message.userTokenSecretVersion;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<UserCredential>): UserCredential {
    return UserCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserCredential>): UserCredential {
    const message = createBaseUserCredential();
    message.userTokenSecretVersion = object.userTokenSecretVersion ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { parent: "", connection: undefined, connectionId: "" };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(18).fork()).join();
    }
    if (message.connectionId !== "") {
      writer.uint32(26).string(message.connectionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connectionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.parent = object.parent ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    message.connectionId = object.connectionId ?? "";
    return message;
  },
};

function createBaseGetConnectionRequest(): GetConnectionRequest {
  return { name: "" };
}

export const GetConnectionRequest: MessageFns<GetConnectionRequest> = {
  encode(message: GetConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    return GetConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    const message = createBaseGetConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { connections: [], nextPageToken: "" };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateConnectionRequest(): UpdateConnectionRequest {
  return { connection: undefined, updateMask: undefined, allowMissing: false, etag: "" };
}

export const UpdateConnectionRequest: MessageFns<UpdateConnectionRequest> = {
  encode(message: UpdateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest {
    return {
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: UpdateConnectionRequest): unknown {
    const obj: any = {};
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    return UpdateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    const message = createBaseUpdateConnectionRequest();
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { name: "", etag: "", validateOnly: false };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseCreateRepositoryRequest(): CreateRepositoryRequest {
  return { parent: "", repository: undefined, repositoryId: "" };
}

export const CreateRepositoryRequest: MessageFns<CreateRepositoryRequest> = {
  encode(message: CreateRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.repository !== undefined) {
      Repository.encode(message.repository, writer.uint32(18).fork()).join();
    }
    if (message.repositoryId !== "") {
      writer.uint32(26).string(message.repositoryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repository = Repository.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repositoryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRepositoryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      repository: isSet(object.repository) ? Repository.fromJSON(object.repository) : undefined,
      repositoryId: isSet(object.repositoryId) ? globalThis.String(object.repositoryId) : "",
    };
  },

  toJSON(message: CreateRepositoryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.repository !== undefined) {
      obj.repository = Repository.toJSON(message.repository);
    }
    if (message.repositoryId !== "") {
      obj.repositoryId = message.repositoryId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRepositoryRequest>): CreateRepositoryRequest {
    return CreateRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRepositoryRequest>): CreateRepositoryRequest {
    const message = createBaseCreateRepositoryRequest();
    message.parent = object.parent ?? "";
    message.repository = (object.repository !== undefined && object.repository !== null)
      ? Repository.fromPartial(object.repository)
      : undefined;
    message.repositoryId = object.repositoryId ?? "";
    return message;
  },
};

function createBaseBatchCreateRepositoriesRequest(): BatchCreateRepositoriesRequest {
  return { parent: "", requests: [] };
}

export const BatchCreateRepositoriesRequest: MessageFns<BatchCreateRepositoriesRequest> = {
  encode(message: BatchCreateRepositoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      CreateRepositoryRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRepositoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRepositoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(CreateRepositoryRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRepositoriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateRepositoryRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateRepositoriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateRepositoryRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRepositoriesRequest>): BatchCreateRepositoriesRequest {
    return BatchCreateRepositoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRepositoriesRequest>): BatchCreateRepositoriesRequest {
    const message = createBaseBatchCreateRepositoriesRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => CreateRepositoryRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateRepositoriesResponse(): BatchCreateRepositoriesResponse {
  return { repositories: [] };
}

export const BatchCreateRepositoriesResponse: MessageFns<BatchCreateRepositoriesResponse> = {
  encode(message: BatchCreateRepositoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repositories) {
      Repository.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRepositoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRepositoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repositories.push(Repository.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRepositoriesResponse {
    return {
      repositories: globalThis.Array.isArray(object?.repositories)
        ? object.repositories.map((e: any) => Repository.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateRepositoriesResponse): unknown {
    const obj: any = {};
    if (message.repositories?.length) {
      obj.repositories = message.repositories.map((e) => Repository.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRepositoriesResponse>): BatchCreateRepositoriesResponse {
    return BatchCreateRepositoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRepositoriesResponse>): BatchCreateRepositoriesResponse {
    const message = createBaseBatchCreateRepositoriesResponse();
    message.repositories = object.repositories?.map((e) => Repository.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRepositoryRequest(): GetRepositoryRequest {
  return { name: "" };
}

export const GetRepositoryRequest: MessageFns<GetRepositoryRequest> = {
  encode(message: GetRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepositoryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRepositoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRepositoryRequest>): GetRepositoryRequest {
    return GetRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRepositoryRequest>): GetRepositoryRequest {
    const message = createBaseGetRepositoryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRepositoriesRequest(): ListRepositoriesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRepositoriesRequest: MessageFns<ListRepositoriesRequest> = {
  encode(message: ListRepositoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepositoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepositoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepositoriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRepositoriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepositoriesRequest>): ListRepositoriesRequest {
    return ListRepositoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepositoriesRequest>): ListRepositoriesRequest {
    const message = createBaseListRepositoriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRepositoriesResponse(): ListRepositoriesResponse {
  return { repositories: [], nextPageToken: "" };
}

export const ListRepositoriesResponse: MessageFns<ListRepositoriesResponse> = {
  encode(message: ListRepositoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repositories) {
      Repository.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepositoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepositoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repositories.push(Repository.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepositoriesResponse {
    return {
      repositories: globalThis.Array.isArray(object?.repositories)
        ? object.repositories.map((e: any) => Repository.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRepositoriesResponse): unknown {
    const obj: any = {};
    if (message.repositories?.length) {
      obj.repositories = message.repositories.map((e) => Repository.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepositoriesResponse>): ListRepositoriesResponse {
    return ListRepositoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepositoriesResponse>): ListRepositoriesResponse {
    const message = createBaseListRepositoriesResponse();
    message.repositories = object.repositories?.map((e) => Repository.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteRepositoryRequest(): DeleteRepositoryRequest {
  return { name: "", etag: "", validateOnly: false };
}

export const DeleteRepositoryRequest: MessageFns<DeleteRepositoryRequest> = {
  encode(message: DeleteRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRepositoryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: DeleteRepositoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRepositoryRequest>): DeleteRepositoryRequest {
    return DeleteRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRepositoryRequest>): DeleteRepositoryRequest {
    const message = createBaseDeleteRepositoryRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseFetchReadWriteTokenRequest(): FetchReadWriteTokenRequest {
  return { repository: "" };
}

export const FetchReadWriteTokenRequest: MessageFns<FetchReadWriteTokenRequest> = {
  encode(message: FetchReadWriteTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReadWriteTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReadWriteTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReadWriteTokenRequest {
    return { repository: isSet(object.repository) ? globalThis.String(object.repository) : "" };
  },

  toJSON(message: FetchReadWriteTokenRequest): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReadWriteTokenRequest>): FetchReadWriteTokenRequest {
    return FetchReadWriteTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReadWriteTokenRequest>): FetchReadWriteTokenRequest {
    const message = createBaseFetchReadWriteTokenRequest();
    message.repository = object.repository ?? "";
    return message;
  },
};

function createBaseFetchReadTokenRequest(): FetchReadTokenRequest {
  return { repository: "" };
}

export const FetchReadTokenRequest: MessageFns<FetchReadTokenRequest> = {
  encode(message: FetchReadTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReadTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReadTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReadTokenRequest {
    return { repository: isSet(object.repository) ? globalThis.String(object.repository) : "" };
  },

  toJSON(message: FetchReadTokenRequest): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReadTokenRequest>): FetchReadTokenRequest {
    return FetchReadTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReadTokenRequest>): FetchReadTokenRequest {
    const message = createBaseFetchReadTokenRequest();
    message.repository = object.repository ?? "";
    return message;
  },
};

function createBaseFetchReadTokenResponse(): FetchReadTokenResponse {
  return { token: "", expirationTime: undefined };
}

export const FetchReadTokenResponse: MessageFns<FetchReadTokenResponse> = {
  encode(message: FetchReadTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReadTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReadTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReadTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expirationTime: isSet(object.expirationTime) ? fromJsonTimestamp(object.expirationTime) : undefined,
    };
  },

  toJSON(message: FetchReadTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReadTokenResponse>): FetchReadTokenResponse {
    return FetchReadTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReadTokenResponse>): FetchReadTokenResponse {
    const message = createBaseFetchReadTokenResponse();
    message.token = object.token ?? "";
    message.expirationTime = object.expirationTime ?? undefined;
    return message;
  },
};

function createBaseFetchReadWriteTokenResponse(): FetchReadWriteTokenResponse {
  return { token: "", expirationTime: undefined };
}

export const FetchReadWriteTokenResponse: MessageFns<FetchReadWriteTokenResponse> = {
  encode(message: FetchReadWriteTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReadWriteTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReadWriteTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReadWriteTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expirationTime: isSet(object.expirationTime) ? fromJsonTimestamp(object.expirationTime) : undefined,
    };
  },

  toJSON(message: FetchReadWriteTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReadWriteTokenResponse>): FetchReadWriteTokenResponse {
    return FetchReadWriteTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReadWriteTokenResponse>): FetchReadWriteTokenResponse {
    const message = createBaseFetchReadWriteTokenResponse();
    message.token = object.token ?? "";
    message.expirationTime = object.expirationTime ?? undefined;
    return message;
  },
};

function createBaseProcessWebhookRequest(): ProcessWebhookRequest {
  return { parent: "", body: undefined, webhookKey: "" };
}

export const ProcessWebhookRequest: MessageFns<ProcessWebhookRequest> = {
  encode(message: ProcessWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.body !== undefined) {
      HttpBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    if (message.webhookKey !== "") {
      writer.uint32(26).string(message.webhookKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = HttpBody.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.webhookKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessWebhookRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      body: isSet(object.body) ? HttpBody.fromJSON(object.body) : undefined,
      webhookKey: isSet(object.webhookKey) ? globalThis.String(object.webhookKey) : "",
    };
  },

  toJSON(message: ProcessWebhookRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.body !== undefined) {
      obj.body = HttpBody.toJSON(message.body);
    }
    if (message.webhookKey !== "") {
      obj.webhookKey = message.webhookKey;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessWebhookRequest>): ProcessWebhookRequest {
    return ProcessWebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessWebhookRequest>): ProcessWebhookRequest {
    const message = createBaseProcessWebhookRequest();
    message.parent = object.parent ?? "";
    message.body = (object.body !== undefined && object.body !== null) ? HttpBody.fromPartial(object.body) : undefined;
    message.webhookKey = object.webhookKey ?? "";
    return message;
  },
};

function createBaseFetchGitRefsRequest(): FetchGitRefsRequest {
  return { repository: "", refType: 0 };
}

export const FetchGitRefsRequest: MessageFns<FetchGitRefsRequest> = {
  encode(message: FetchGitRefsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.refType !== 0) {
      writer.uint32(16).int32(message.refType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchGitRefsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchGitRefsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.refType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchGitRefsRequest {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      refType: isSet(object.refType) ? fetchGitRefsRequest_RefTypeFromJSON(object.refType) : 0,
    };
  },

  toJSON(message: FetchGitRefsRequest): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.refType !== 0) {
      obj.refType = fetchGitRefsRequest_RefTypeToJSON(message.refType);
    }
    return obj;
  },

  create(base?: DeepPartial<FetchGitRefsRequest>): FetchGitRefsRequest {
    return FetchGitRefsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchGitRefsRequest>): FetchGitRefsRequest {
    const message = createBaseFetchGitRefsRequest();
    message.repository = object.repository ?? "";
    message.refType = object.refType ?? 0;
    return message;
  },
};

function createBaseFetchGitRefsResponse(): FetchGitRefsResponse {
  return { refNames: [] };
}

export const FetchGitRefsResponse: MessageFns<FetchGitRefsResponse> = {
  encode(message: FetchGitRefsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.refNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchGitRefsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchGitRefsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchGitRefsResponse {
    return {
      refNames: globalThis.Array.isArray(object?.refNames) ? object.refNames.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: FetchGitRefsResponse): unknown {
    const obj: any = {};
    if (message.refNames?.length) {
      obj.refNames = message.refNames;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchGitRefsResponse>): FetchGitRefsResponse {
    return FetchGitRefsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchGitRefsResponse>): FetchGitRefsResponse {
    const message = createBaseFetchGitRefsResponse();
    message.refNames = object.refNames?.map((e) => e) || [];
    return message;
  },
};

/** Manages connections to source code repositories. */
export type RepositoryManagerDefinition = typeof RepositoryManagerDefinition;
export const RepositoryManagerDefinition = {
  name: "RepositoryManager",
  fullName: "google.devtools.cloudbuild.v2.RepositoryManager",
  methods: {
    /** Creates a Connection. */
    createConnection: {
      name: "CreateConnection",
      requestType: CreateConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              61,
              10,
              10,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              47,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single connection. */
    getConnection: {
      name: "GetConnection",
      requestType: GetConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Connections in a given project and location. */
    listConnections: {
      name: "ListConnections",
      requestType: ListConnectionsRequest,
      requestStream: false,
      responseType: ListConnectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a single connection. */
    updateConnection: {
      name: "UpdateConnection",
      requestType: UpdateConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              61,
              10,
              10,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              22,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              72,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              58,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single connection. */
    deleteConnection: {
      name: "DeleteConnection",
      requestType: DeleteConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              72,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a Repository. */
    createRepository: {
      name: "CreateRepository",
      requestType: CreateRepositoryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              61,
              10,
              10,
              82,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              44,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              76,
              58,
              10,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              34,
              62,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates multiple repositories inside a connection. */
    batchCreateRepositories: {
      name: "BatchCreateRepositories",
      requestType: BatchCreateRepositoriesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              82,
              10,
              31,
              66,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
              82,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 114, 101, 113, 117, 101, 115, 116, 115])],
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single repository. */
    getRepository: {
      name: "GetRepository",
      requestType: GetRepositoryRequest,
      requestStream: false,
      responseType: Repository,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Repositories in a given connection. */
    listRepositories: {
      name: "ListRepositories",
      requestType: ListRepositoriesRequest,
      requestStream: false,
      responseType: ListRepositoriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single repository. */
    deleteRepository: {
      name: "DeleteRepository",
      requestType: DeleteRepositoryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              72,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              100,
              101,
              118,
              116,
              111,
              111,
              108,
              115,
              46,
              99,
              108,
              111,
              117,
              100,
              98,
              117,
              105,
              108,
              100,
              46,
              118,
              50,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              42,
              62,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Fetches read/write token of a given repository. */
    fetchReadWriteToken: {
      name: "FetchReadWriteToken",
      requestType: FetchReadWriteTokenRequest,
      requestStream: false,
      responseType: FetchReadWriteTokenResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 114, 101, 112, 111, 115, 105, 116, 111, 114, 121])],
          578365826: [
            Buffer.from([
              94,
              58,
              1,
              42,
              34,
              89,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              99,
              99,
              101,
              115,
              115,
              82,
              101,
              97,
              100,
              87,
              114,
              105,
              116,
              101,
              84,
              111,
              107,
              101,
              110,
            ]),
          ],
        },
      },
    },
    /** Fetches read token of a given repository. */
    fetchReadToken: {
      name: "FetchReadToken",
      requestType: FetchReadTokenRequest,
      requestStream: false,
      responseType: FetchReadTokenResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 114, 101, 112, 111, 115, 105, 116, 111, 114, 121])],
          578365826: [
            Buffer.from([
              89,
              58,
              1,
              42,
              34,
              84,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              99,
              99,
              101,
              115,
              115,
              82,
              101,
              97,
              100,
              84,
              111,
              107,
              101,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * FetchLinkableRepositories get repositories from SCM that are
     * accessible and could be added to the connection.
     */
    fetchLinkableRepositories: {
      name: "FetchLinkableRepositories",
      requestType: FetchLinkableRepositoriesRequest,
      requestStream: false,
      responseType: FetchLinkableRepositoriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              81,
              18,
              79,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              76,
              105,
              110,
              107,
              97,
              98,
              108,
              101,
              82,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Fetch the list of branches or tags for a given repository. */
    fetchGitRefs: {
      name: "FetchGitRefs",
      requestType: FetchGitRefsRequest,
      requestStream: false,
      responseType: FetchGitRefsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 114, 101, 112, 111, 115, 105, 116, 111, 114, 121])],
          578365826: [
            Buffer.from([
              83,
              18,
              81,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              71,
              105,
              116,
              82,
              101,
              102,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface RepositoryManagerServiceImplementation<CallContextExt = {}> {
  /** Creates a Connection. */
  createConnection(
    request: CreateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets details of a single connection. */
  getConnection(request: GetConnectionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Connection>>;
  /** Lists Connections in a given project and location. */
  listConnections(
    request: ListConnectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConnectionsResponse>>;
  /** Updates a single connection. */
  updateConnection(
    request: UpdateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single connection. */
  deleteConnection(
    request: DeleteConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a Repository. */
  createRepository(
    request: CreateRepositoryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates multiple repositories inside a connection. */
  batchCreateRepositories(
    request: BatchCreateRepositoriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets details of a single repository. */
  getRepository(request: GetRepositoryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Repository>>;
  /** Lists Repositories in a given connection. */
  listRepositories(
    request: ListRepositoriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRepositoriesResponse>>;
  /** Deletes a single repository. */
  deleteRepository(
    request: DeleteRepositoryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Fetches read/write token of a given repository. */
  fetchReadWriteToken(
    request: FetchReadWriteTokenRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchReadWriteTokenResponse>>;
  /** Fetches read token of a given repository. */
  fetchReadToken(
    request: FetchReadTokenRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchReadTokenResponse>>;
  /**
   * FetchLinkableRepositories get repositories from SCM that are
   * accessible and could be added to the connection.
   */
  fetchLinkableRepositories(
    request: FetchLinkableRepositoriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchLinkableRepositoriesResponse>>;
  /** Fetch the list of branches or tags for a given repository. */
  fetchGitRefs(
    request: FetchGitRefsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchGitRefsResponse>>;
}

export interface RepositoryManagerClient<CallOptionsExt = {}> {
  /** Creates a Connection. */
  createConnection(
    request: DeepPartial<CreateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets details of a single connection. */
  getConnection(
    request: DeepPartial<GetConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Lists Connections in a given project and location. */
  listConnections(
    request: DeepPartial<ListConnectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConnectionsResponse>;
  /** Updates a single connection. */
  updateConnection(
    request: DeepPartial<UpdateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single connection. */
  deleteConnection(
    request: DeepPartial<DeleteConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a Repository. */
  createRepository(
    request: DeepPartial<CreateRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates multiple repositories inside a connection. */
  batchCreateRepositories(
    request: DeepPartial<BatchCreateRepositoriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets details of a single repository. */
  getRepository(
    request: DeepPartial<GetRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Repository>;
  /** Lists Repositories in a given connection. */
  listRepositories(
    request: DeepPartial<ListRepositoriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRepositoriesResponse>;
  /** Deletes a single repository. */
  deleteRepository(
    request: DeepPartial<DeleteRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Fetches read/write token of a given repository. */
  fetchReadWriteToken(
    request: DeepPartial<FetchReadWriteTokenRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchReadWriteTokenResponse>;
  /** Fetches read token of a given repository. */
  fetchReadToken(
    request: DeepPartial<FetchReadTokenRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchReadTokenResponse>;
  /**
   * FetchLinkableRepositories get repositories from SCM that are
   * accessible and could be added to the connection.
   */
  fetchLinkableRepositories(
    request: DeepPartial<FetchLinkableRepositoriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchLinkableRepositoriesResponse>;
  /** Fetch the list of branches or tags for a given repository. */
  fetchGitRefs(
    request: DeepPartial<FetchGitRefsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchGitRefsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
