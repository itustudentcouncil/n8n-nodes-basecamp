// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/testing/v1/direct_access_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { AdbMessage, DeviceMessage } from "./adb_service.js";
import { AndroidDevice } from "./test_execution.js";

export const protobufPackage = "google.devtools.testing.v1";

/** A Request for the device session from the session service. */
export interface CreateDeviceSessionRequest {
  /**
   * Required. The Compute Engine project under which this device will be
   * allocated. "projects/{project_id}"
   */
  parent: string;
  /** Required. A device session to create. */
  deviceSession: DeviceSession | undefined;
}

/**
 * Request a list of device sessions in the provided parent matching the given
 * filter.
 */
export interface ListDeviceSessionsRequest {
  /** Required. The name of the parent to request, e.g. "projects/{project_id}" */
  parent: string;
  /** Optional. The maximum number of DeviceSessions to return. */
  pageSize: number;
  /** Optional. A continuation token for paging. */
  pageToken: string;
  /**
   * Optional. If specified, responses will be filtered by the given filter.
   * Allowed fields are: session_state.
   */
  filter: string;
}

/** A list of device sessions. */
export interface ListDeviceSessionsResponse {
  /** The sessions matching the specified filter in the given cloud project. */
  deviceSessions: DeviceSession[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The request object for a Device Session. */
export interface GetDeviceSessionRequest {
  /**
   * Required. Name of the DeviceSession, e.g.
   * "projects/{project_id}/deviceSessions/{session_id}"
   */
  name: string;
}

/** The request object for cancelling a Device Session. */
export interface CancelDeviceSessionRequest {
  /**
   * Required. Name of the DeviceSession, e.g.
   * "projects/{project_id}/deviceSessions/{session_id}"
   */
  name: string;
}

/** The request object for the UpdateDeviceSession RPC. */
export interface UpdateDeviceSessionRequest {
  /**
   * Required. DeviceSession to update.
   * The device session's `name` field is used to identify the session to update
   * "projects/{project_id}/deviceSessions/{session_id}"
   */
  deviceSession:
    | DeviceSession
    | undefined;
  /** Required. The list of fields to update. */
  updateMask: string[] | undefined;
}

/** Protobuf message describing the device message, used from several RPCs. */
export interface DeviceSession {
  /**
   * Optional. Name of the DeviceSession, e.g.
   * "projects/{project_id}/deviceSessions/{session_id}"
   */
  name: string;
  /** Output only. The title of the DeviceSession to be presented in the UI. */
  displayName: string;
  /** Output only. Current state of the DeviceSession. */
  state: DeviceSession_SessionState;
  /**
   * Output only. The historical state transitions of the session_state message
   * including the current session state.
   */
  stateHistories: DeviceSession_SessionStateEvent[];
  /**
   * Optional. The amount of time that a device will be initially allocated
   * for. This can eventually be extended with the UpdateDeviceSession RPC.
   * Default: 15 minutes.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Optional. If the device is still in use at this time, any connections
   * will be ended and the SessionState will transition from ACTIVE to
   * FINISHED.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Output only. The interval of time that this device must be interacted with
   * before it transitions from ACTIVE to TIMEOUT_INACTIVITY.
   */
  inactivityTimeout:
    | Duration
    | undefined;
  /** Output only. The time that the Session was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp that the session first became ACTIVE. */
  activeStartTime:
    | Date
    | undefined;
  /** Required. The requested device */
  androidDevice: AndroidDevice | undefined;
}

/** The state that the device session resides. */
export enum DeviceSession_SessionState {
  /** SESSION_STATE_UNSPECIFIED - Default value. This value is unused. */
  SESSION_STATE_UNSPECIFIED = 0,
  /**
   * REQUESTED - Initial state of a session request. The session is being validated for
   * correctness and a device is not yet requested.
   */
  REQUESTED = 1,
  /** PENDING - The session has been validated and is in the queue for a device. */
  PENDING = 2,
  /**
   * ACTIVE - The session has been granted and the device is accepting
   * connections.
   */
  ACTIVE = 3,
  /**
   * EXPIRED - The session duration exceeded the deviceâ€™s reservation time period and
   * timed out automatically.
   */
  EXPIRED = 4,
  /**
   * FINISHED - The user is finished with the session and it was canceled by the user
   * while the request was still getting allocated or after allocation and
   * during device usage period.
   */
  FINISHED = 5,
  /**
   * UNAVAILABLE - Unable to complete the session because the device was unavailable and
   * it failed to allocate through the scheduler. For example, a device not
   * in the catalog was requested or the request expired in the allocation
   * queue.
   */
  UNAVAILABLE = 6,
  /**
   * ERROR - Unable to complete the session for an internal reason, such as an
   * infrastructure failure.
   */
  ERROR = 7,
  UNRECOGNIZED = -1,
}

export function deviceSession_SessionStateFromJSON(object: any): DeviceSession_SessionState {
  switch (object) {
    case 0:
    case "SESSION_STATE_UNSPECIFIED":
      return DeviceSession_SessionState.SESSION_STATE_UNSPECIFIED;
    case 1:
    case "REQUESTED":
      return DeviceSession_SessionState.REQUESTED;
    case 2:
    case "PENDING":
      return DeviceSession_SessionState.PENDING;
    case 3:
    case "ACTIVE":
      return DeviceSession_SessionState.ACTIVE;
    case 4:
    case "EXPIRED":
      return DeviceSession_SessionState.EXPIRED;
    case 5:
    case "FINISHED":
      return DeviceSession_SessionState.FINISHED;
    case 6:
    case "UNAVAILABLE":
      return DeviceSession_SessionState.UNAVAILABLE;
    case 7:
    case "ERROR":
      return DeviceSession_SessionState.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceSession_SessionState.UNRECOGNIZED;
  }
}

export function deviceSession_SessionStateToJSON(object: DeviceSession_SessionState): string {
  switch (object) {
    case DeviceSession_SessionState.SESSION_STATE_UNSPECIFIED:
      return "SESSION_STATE_UNSPECIFIED";
    case DeviceSession_SessionState.REQUESTED:
      return "REQUESTED";
    case DeviceSession_SessionState.PENDING:
      return "PENDING";
    case DeviceSession_SessionState.ACTIVE:
      return "ACTIVE";
    case DeviceSession_SessionState.EXPIRED:
      return "EXPIRED";
    case DeviceSession_SessionState.FINISHED:
      return "FINISHED";
    case DeviceSession_SessionState.UNAVAILABLE:
      return "UNAVAILABLE";
    case DeviceSession_SessionState.ERROR:
      return "ERROR";
    case DeviceSession_SessionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A message encapsulating a series of Session states and the time that the
 * DeviceSession first entered those states.
 */
export interface DeviceSession_SessionStateEvent {
  /** Output only. The session_state tracked by this event */
  sessionState: DeviceSession_SessionState;
  /**
   * Output only. The time that the session_state first encountered that
   * state.
   */
  eventTime:
    | Date
    | undefined;
  /** Output only. A human-readable message to explain the state. */
  stateMessage: string;
}

function createBaseCreateDeviceSessionRequest(): CreateDeviceSessionRequest {
  return { parent: "", deviceSession: undefined };
}

export const CreateDeviceSessionRequest: MessageFns<CreateDeviceSessionRequest> = {
  encode(message: CreateDeviceSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.deviceSession !== undefined) {
      DeviceSession.encode(message.deviceSession, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDeviceSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeviceSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deviceSession = DeviceSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDeviceSessionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      deviceSession: isSet(object.deviceSession) ? DeviceSession.fromJSON(object.deviceSession) : undefined,
    };
  },

  toJSON(message: CreateDeviceSessionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.deviceSession !== undefined) {
      obj.deviceSession = DeviceSession.toJSON(message.deviceSession);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDeviceSessionRequest>): CreateDeviceSessionRequest {
    return CreateDeviceSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDeviceSessionRequest>): CreateDeviceSessionRequest {
    const message = createBaseCreateDeviceSessionRequest();
    message.parent = object.parent ?? "";
    message.deviceSession = (object.deviceSession !== undefined && object.deviceSession !== null)
      ? DeviceSession.fromPartial(object.deviceSession)
      : undefined;
    return message;
  },
};

function createBaseListDeviceSessionsRequest(): ListDeviceSessionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListDeviceSessionsRequest: MessageFns<ListDeviceSessionsRequest> = {
  encode(message: ListDeviceSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeviceSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeviceSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeviceSessionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListDeviceSessionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeviceSessionsRequest>): ListDeviceSessionsRequest {
    return ListDeviceSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeviceSessionsRequest>): ListDeviceSessionsRequest {
    const message = createBaseListDeviceSessionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListDeviceSessionsResponse(): ListDeviceSessionsResponse {
  return { deviceSessions: [], nextPageToken: "" };
}

export const ListDeviceSessionsResponse: MessageFns<ListDeviceSessionsResponse> = {
  encode(message: ListDeviceSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deviceSessions) {
      DeviceSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeviceSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeviceSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceSessions.push(DeviceSession.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeviceSessionsResponse {
    return {
      deviceSessions: globalThis.Array.isArray(object?.deviceSessions)
        ? object.deviceSessions.map((e: any) => DeviceSession.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDeviceSessionsResponse): unknown {
    const obj: any = {};
    if (message.deviceSessions?.length) {
      obj.deviceSessions = message.deviceSessions.map((e) => DeviceSession.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeviceSessionsResponse>): ListDeviceSessionsResponse {
    return ListDeviceSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeviceSessionsResponse>): ListDeviceSessionsResponse {
    const message = createBaseListDeviceSessionsResponse();
    message.deviceSessions = object.deviceSessions?.map((e) => DeviceSession.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetDeviceSessionRequest(): GetDeviceSessionRequest {
  return { name: "" };
}

export const GetDeviceSessionRequest: MessageFns<GetDeviceSessionRequest> = {
  encode(message: GetDeviceSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceSessionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDeviceSessionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeviceSessionRequest>): GetDeviceSessionRequest {
    return GetDeviceSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeviceSessionRequest>): GetDeviceSessionRequest {
    const message = createBaseGetDeviceSessionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCancelDeviceSessionRequest(): CancelDeviceSessionRequest {
  return { name: "" };
}

export const CancelDeviceSessionRequest: MessageFns<CancelDeviceSessionRequest> = {
  encode(message: CancelDeviceSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelDeviceSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelDeviceSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelDeviceSessionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelDeviceSessionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelDeviceSessionRequest>): CancelDeviceSessionRequest {
    return CancelDeviceSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelDeviceSessionRequest>): CancelDeviceSessionRequest {
    const message = createBaseCancelDeviceSessionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateDeviceSessionRequest(): UpdateDeviceSessionRequest {
  return { deviceSession: undefined, updateMask: undefined };
}

export const UpdateDeviceSessionRequest: MessageFns<UpdateDeviceSessionRequest> = {
  encode(message: UpdateDeviceSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceSession !== undefined) {
      DeviceSession.encode(message.deviceSession, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeviceSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeviceSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceSession = DeviceSession.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeviceSessionRequest {
    return {
      deviceSession: isSet(object.deviceSession) ? DeviceSession.fromJSON(object.deviceSession) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDeviceSessionRequest): unknown {
    const obj: any = {};
    if (message.deviceSession !== undefined) {
      obj.deviceSession = DeviceSession.toJSON(message.deviceSession);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDeviceSessionRequest>): UpdateDeviceSessionRequest {
    return UpdateDeviceSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDeviceSessionRequest>): UpdateDeviceSessionRequest {
    const message = createBaseUpdateDeviceSessionRequest();
    message.deviceSession = (object.deviceSession !== undefined && object.deviceSession !== null)
      ? DeviceSession.fromPartial(object.deviceSession)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeviceSession(): DeviceSession {
  return {
    name: "",
    displayName: "",
    state: 0,
    stateHistories: [],
    ttl: undefined,
    expireTime: undefined,
    inactivityTimeout: undefined,
    createTime: undefined,
    activeStartTime: undefined,
    androidDevice: undefined,
  };
}

export const DeviceSession: MessageFns<DeviceSession> = {
  encode(message: DeviceSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    for (const v of message.stateHistories) {
      DeviceSession_SessionStateEvent.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(106).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(42).fork()).join();
    }
    if (message.inactivityTimeout !== undefined) {
      Duration.encode(message.inactivityTimeout, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.activeStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.activeStartTime), writer.uint32(74).fork()).join();
    }
    if (message.androidDevice !== undefined) {
      AndroidDevice.encode(message.androidDevice, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.stateHistories.push(DeviceSession_SessionStateEvent.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.inactivityTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.activeStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.androidDevice = AndroidDevice.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceSession {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? deviceSession_SessionStateFromJSON(object.state) : 0,
      stateHistories: globalThis.Array.isArray(object?.stateHistories)
        ? object.stateHistories.map((e: any) => DeviceSession_SessionStateEvent.fromJSON(e))
        : [],
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      inactivityTimeout: isSet(object.inactivityTimeout) ? Duration.fromJSON(object.inactivityTimeout) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      activeStartTime: isSet(object.activeStartTime) ? fromJsonTimestamp(object.activeStartTime) : undefined,
      androidDevice: isSet(object.androidDevice) ? AndroidDevice.fromJSON(object.androidDevice) : undefined,
    };
  },

  toJSON(message: DeviceSession): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = deviceSession_SessionStateToJSON(message.state);
    }
    if (message.stateHistories?.length) {
      obj.stateHistories = message.stateHistories.map((e) => DeviceSession_SessionStateEvent.toJSON(e));
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.inactivityTimeout !== undefined) {
      obj.inactivityTimeout = Duration.toJSON(message.inactivityTimeout);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.activeStartTime !== undefined) {
      obj.activeStartTime = message.activeStartTime.toISOString();
    }
    if (message.androidDevice !== undefined) {
      obj.androidDevice = AndroidDevice.toJSON(message.androidDevice);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceSession>): DeviceSession {
    return DeviceSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceSession>): DeviceSession {
    const message = createBaseDeviceSession();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.stateHistories = object.stateHistories?.map((e) => DeviceSession_SessionStateEvent.fromPartial(e)) || [];
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.inactivityTimeout = (object.inactivityTimeout !== undefined && object.inactivityTimeout !== null)
      ? Duration.fromPartial(object.inactivityTimeout)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.activeStartTime = object.activeStartTime ?? undefined;
    message.androidDevice = (object.androidDevice !== undefined && object.androidDevice !== null)
      ? AndroidDevice.fromPartial(object.androidDevice)
      : undefined;
    return message;
  },
};

function createBaseDeviceSession_SessionStateEvent(): DeviceSession_SessionStateEvent {
  return { sessionState: 0, eventTime: undefined, stateMessage: "" };
}

export const DeviceSession_SessionStateEvent: MessageFns<DeviceSession_SessionStateEvent> = {
  encode(message: DeviceSession_SessionStateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionState !== 0) {
      writer.uint32(8).int32(message.sessionState);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(18).fork()).join();
    }
    if (message.stateMessage !== "") {
      writer.uint32(26).string(message.stateMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceSession_SessionStateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceSession_SessionStateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceSession_SessionStateEvent {
    return {
      sessionState: isSet(object.sessionState) ? deviceSession_SessionStateFromJSON(object.sessionState) : 0,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
    };
  },

  toJSON(message: DeviceSession_SessionStateEvent): unknown {
    const obj: any = {};
    if (message.sessionState !== 0) {
      obj.sessionState = deviceSession_SessionStateToJSON(message.sessionState);
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceSession_SessionStateEvent>): DeviceSession_SessionStateEvent {
    return DeviceSession_SessionStateEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceSession_SessionStateEvent>): DeviceSession_SessionStateEvent {
    const message = createBaseDeviceSession_SessionStateEvent();
    message.sessionState = object.sessionState ?? 0;
    message.eventTime = object.eventTime ?? undefined;
    message.stateMessage = object.stateMessage ?? "";
    return message;
  },
};

/**
 * A service for allocating devices and interacting with the live-allocated
 * devices.
 *
 * This service is part of Firebase Test Lab. To learn about how to use the
 * product, and how to integrate it with your system,
 * visit https://firebase.google.com/docs/test-lab.
 *
 * Each Session will wait for available capacity, at a higher
 * priority over Test Execution. When allocated, the session will be exposed
 * through a stream for integration.
 *
 * DirectAccessService is currently available as a preview to select developers.
 * You can register today on behalf of you and your team at
 * https://developer.android.com/studio/preview/android-device-streaming
 */
export type DirectAccessServiceDefinition = typeof DirectAccessServiceDefinition;
export const DirectAccessServiceDefinition = {
  name: "DirectAccessService",
  fullName: "google.devtools.testing.v1.DirectAccessService",
  methods: {
    /** POST /v1/projects/{project_id}/deviceSessions */
    createDeviceSession: {
      name: "CreateDeviceSession",
      requestType: CreateDeviceSessionRequest,
      requestStream: false,
      responseType: DeviceSession,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              101,
              118,
              105,
              99,
              101,
              95,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              14,
              100,
              101,
              118,
              105,
              99,
              101,
              95,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              118,
              105,
              99,
              101,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * GET /v1/projects/{project_id}/deviceSessions
     * Lists device Sessions owned by the project user.
     */
    listDeviceSessions: {
      name: "ListDeviceSessions",
      requestType: ListDeviceSessionsRequest,
      requestStream: false,
      responseType: ListDeviceSessionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              118,
              105,
              99,
              101,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * GET /v1/projects/{project_id}/deviceSessions/{device_session_id}
     * Return a DeviceSession, which documents the allocation status and
     * whether the device is allocated. Clients making requests from this API
     * must poll GetDeviceSession.
     */
    getDeviceSession: {
      name: "GetDeviceSession",
      requestType: GetDeviceSessionRequest,
      requestStream: false,
      responseType: DeviceSession,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              101,
              118,
              105,
              99,
              101,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * POST
     * /v1/projects/{project_id}/deviceSessions/{device_session_id}:cancel
     * Changes the DeviceSession to state FINISHED and terminates all connections.
     * Canceled sessions are not deleted and can be retrieved or
     * listed by the user until they expire based on the 28 day deletion policy.
     */
    cancelDeviceSession: {
      name: "CancelDeviceSession",
      requestType: CancelDeviceSessionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              50,
              58,
              1,
              42,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              101,
              118,
              105,
              99,
              101,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /**
     * PATCH
     * /v1/projects/{projectId}/deviceSessions/deviceSessionId}:updateDeviceSession
     * Updates the current device session to the fields described by the
     * update_mask.
     */
    updateDeviceSession: {
      name: "UpdateDeviceSession",
      requestType: UpdateDeviceSessionRequest,
      requestStream: false,
      responseType: DeviceSession,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              100,
              101,
              118,
              105,
              99,
              101,
              95,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              14,
              100,
              101,
              118,
              105,
              99,
              101,
              95,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
              50,
              53,
              47,
              118,
              49,
              47,
              123,
              100,
              101,
              118,
              105,
              99,
              101,
              95,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              101,
              118,
              105,
              99,
              101,
              83,
              101,
              115,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Exposes ADB connection for use with the Adb Device Forwarder project
     * if the reserved device supports ADB.
     * gRPC headers are used to authenticate the Connect RPC, as well as
     * associate to a particular device session.
     * In particular, the user must specify the "X-FTL-Session-Name" header.
     */
    adbConnect: {
      name: "AdbConnect",
      requestType: AdbMessage,
      requestStream: true,
      responseType: DeviceMessage,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface DirectAccessServiceImplementation<CallContextExt = {}> {
  /** POST /v1/projects/{project_id}/deviceSessions */
  createDeviceSession(
    request: CreateDeviceSessionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeviceSession>>;
  /**
   * GET /v1/projects/{project_id}/deviceSessions
   * Lists device Sessions owned by the project user.
   */
  listDeviceSessions(
    request: ListDeviceSessionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDeviceSessionsResponse>>;
  /**
   * GET /v1/projects/{project_id}/deviceSessions/{device_session_id}
   * Return a DeviceSession, which documents the allocation status and
   * whether the device is allocated. Clients making requests from this API
   * must poll GetDeviceSession.
   */
  getDeviceSession(
    request: GetDeviceSessionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeviceSession>>;
  /**
   * POST
   * /v1/projects/{project_id}/deviceSessions/{device_session_id}:cancel
   * Changes the DeviceSession to state FINISHED and terminates all connections.
   * Canceled sessions are not deleted and can be retrieved or
   * listed by the user until they expire based on the 28 day deletion policy.
   */
  cancelDeviceSession(
    request: CancelDeviceSessionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * PATCH
   * /v1/projects/{projectId}/deviceSessions/deviceSessionId}:updateDeviceSession
   * Updates the current device session to the fields described by the
   * update_mask.
   */
  updateDeviceSession(
    request: UpdateDeviceSessionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeviceSession>>;
  /**
   * Exposes ADB connection for use with the Adb Device Forwarder project
   * if the reserved device supports ADB.
   * gRPC headers are used to authenticate the Connect RPC, as well as
   * associate to a particular device session.
   * In particular, the user must specify the "X-FTL-Session-Name" header.
   */
  adbConnect(
    request: AsyncIterable<AdbMessage>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<DeviceMessage>>;
}

export interface DirectAccessServiceClient<CallOptionsExt = {}> {
  /** POST /v1/projects/{project_id}/deviceSessions */
  createDeviceSession(
    request: DeepPartial<CreateDeviceSessionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeviceSession>;
  /**
   * GET /v1/projects/{project_id}/deviceSessions
   * Lists device Sessions owned by the project user.
   */
  listDeviceSessions(
    request: DeepPartial<ListDeviceSessionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDeviceSessionsResponse>;
  /**
   * GET /v1/projects/{project_id}/deviceSessions/{device_session_id}
   * Return a DeviceSession, which documents the allocation status and
   * whether the device is allocated. Clients making requests from this API
   * must poll GetDeviceSession.
   */
  getDeviceSession(
    request: DeepPartial<GetDeviceSessionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeviceSession>;
  /**
   * POST
   * /v1/projects/{project_id}/deviceSessions/{device_session_id}:cancel
   * Changes the DeviceSession to state FINISHED and terminates all connections.
   * Canceled sessions are not deleted and can be retrieved or
   * listed by the user until they expire based on the 28 day deletion policy.
   */
  cancelDeviceSession(
    request: DeepPartial<CancelDeviceSessionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * PATCH
   * /v1/projects/{projectId}/deviceSessions/deviceSessionId}:updateDeviceSession
   * Updates the current device session to the fields described by the
   * update_mask.
   */
  updateDeviceSession(
    request: DeepPartial<UpdateDeviceSessionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeviceSession>;
  /**
   * Exposes ADB connection for use with the Adb Device Forwarder project
   * if the reserved device supports ADB.
   * gRPC headers are used to authenticate the Connect RPC, as well as
   * associate to a particular device session.
   * In particular, the user must specify the "X-FTL-Session-Name" header.
   */
  adbConnect(
    request: AsyncIterable<DeepPartial<AdbMessage>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<DeviceMessage>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
