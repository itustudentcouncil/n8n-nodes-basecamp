// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/testing/v1/adb_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.devtools.testing.v1";

/** A message returned from a device. */
export interface DeviceMessage {
  /** Information about the device's state. */
  statusUpdate?:
    | StatusUpdate
    | undefined;
  /** The result of a device stream from ADB. */
  streamStatus?:
    | StreamStatus
    | undefined;
  /** Data from an open stream. */
  streamData?: StreamData | undefined;
}

/** A message to an ADB server. */
export interface AdbMessage {
  /** Open a new stream. */
  open?:
    | Open
    | undefined;
  /** Send data to a stream. */
  streamData?: StreamData | undefined;
}

/** A StatusUpdate message given over the ADB protocol for the device state. */
export interface StatusUpdate {
  /** The device's state */
  state: StatusUpdate_DeviceState;
  /** A map of properties with information about this device. */
  properties: { [key: string]: string };
  /** A comma-separated list of "features" that this device supports. */
  features: string;
}

/** The state displayed with the ADB Device when running "adb devices" */
export enum StatusUpdate_DeviceState {
  /** DEVICE_STATE_UNSPECIFIED - The device state is unknown. */
  DEVICE_STATE_UNSPECIFIED = 0,
  /** DEVICE - The ADB device is in the "device" status. */
  DEVICE = 1,
  /** RECOVERY - The ADB device is in the "recovery" status. */
  RECOVERY = 2,
  /** RESCUE - The ADB device is in the "rescue" status. */
  RESCUE = 3,
  /** SIDELOAD - The ADB device is in the "sideload" status. */
  SIDELOAD = 4,
  /** MISSING - The ADB device is in the "missing" status. */
  MISSING = 10,
  /** OFFLINE - The ADB device is in the "offline" status. */
  OFFLINE = 11,
  /** UNAUTHORIZED - The ADB device is in the "unauthorized" status. */
  UNAUTHORIZED = 12,
  /** AUTHORIZING - The ADB device is in the "authorizing" status. */
  AUTHORIZING = 13,
  /** CONNECTING - The ADB device is in the "connecting" status. */
  CONNECTING = 14,
  UNRECOGNIZED = -1,
}

export function statusUpdate_DeviceStateFromJSON(object: any): StatusUpdate_DeviceState {
  switch (object) {
    case 0:
    case "DEVICE_STATE_UNSPECIFIED":
      return StatusUpdate_DeviceState.DEVICE_STATE_UNSPECIFIED;
    case 1:
    case "DEVICE":
      return StatusUpdate_DeviceState.DEVICE;
    case 2:
    case "RECOVERY":
      return StatusUpdate_DeviceState.RECOVERY;
    case 3:
    case "RESCUE":
      return StatusUpdate_DeviceState.RESCUE;
    case 4:
    case "SIDELOAD":
      return StatusUpdate_DeviceState.SIDELOAD;
    case 10:
    case "MISSING":
      return StatusUpdate_DeviceState.MISSING;
    case 11:
    case "OFFLINE":
      return StatusUpdate_DeviceState.OFFLINE;
    case 12:
    case "UNAUTHORIZED":
      return StatusUpdate_DeviceState.UNAUTHORIZED;
    case 13:
    case "AUTHORIZING":
      return StatusUpdate_DeviceState.AUTHORIZING;
    case 14:
    case "CONNECTING":
      return StatusUpdate_DeviceState.CONNECTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatusUpdate_DeviceState.UNRECOGNIZED;
  }
}

export function statusUpdate_DeviceStateToJSON(object: StatusUpdate_DeviceState): string {
  switch (object) {
    case StatusUpdate_DeviceState.DEVICE_STATE_UNSPECIFIED:
      return "DEVICE_STATE_UNSPECIFIED";
    case StatusUpdate_DeviceState.DEVICE:
      return "DEVICE";
    case StatusUpdate_DeviceState.RECOVERY:
      return "RECOVERY";
    case StatusUpdate_DeviceState.RESCUE:
      return "RESCUE";
    case StatusUpdate_DeviceState.SIDELOAD:
      return "SIDELOAD";
    case StatusUpdate_DeviceState.MISSING:
      return "MISSING";
    case StatusUpdate_DeviceState.OFFLINE:
      return "OFFLINE";
    case StatusUpdate_DeviceState.UNAUTHORIZED:
      return "UNAUTHORIZED";
    case StatusUpdate_DeviceState.AUTHORIZING:
      return "AUTHORIZING";
    case StatusUpdate_DeviceState.CONNECTING:
      return "CONNECTING";
    case StatusUpdate_DeviceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface StatusUpdate_PropertiesEntry {
  key: string;
  value: string;
}

/** The result of a stream. */
export interface StreamStatus {
  /** The unique ID of this stream, assigned by the client. */
  streamId: number;
  /** Okay for success. */
  okay?:
    | Okay
    | undefined;
  /** Fail for failure. */
  fail?: Fail | undefined;
}

/** Message for opening a new stream. */
export interface Open {
  /**
   * The unique ID that will be used to talk to this stream. This should
   * probably just be a number that increments for each new Open request.
   */
  streamId: number;
  /** An ADB service to use in the new stream. */
  service: string;
}

/** Data for a stream. */
export interface StreamData {
  /** The unique ID of this stream, assigned by the client. */
  streamId: number;
  /** Data in the stream. */
  data?:
    | Buffer
    | undefined;
  /** The stream is closing. EOF. */
  close?: Close | undefined;
}

/** Message signifying that the stream is open */
export interface Okay {
}

/** Message signifying that the stream failed to open */
export interface Fail {
  /** A user-displayable failure reason. */
  reason: string;
}

/** Message signifying that the stream closed. */
export interface Close {
}

function createBaseDeviceMessage(): DeviceMessage {
  return { statusUpdate: undefined, streamStatus: undefined, streamData: undefined };
}

export const DeviceMessage: MessageFns<DeviceMessage> = {
  encode(message: DeviceMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusUpdate !== undefined) {
      StatusUpdate.encode(message.statusUpdate, writer.uint32(10).fork()).join();
    }
    if (message.streamStatus !== undefined) {
      StreamStatus.encode(message.streamStatus, writer.uint32(18).fork()).join();
    }
    if (message.streamData !== undefined) {
      StreamData.encode(message.streamData, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statusUpdate = StatusUpdate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streamStatus = StreamStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.streamData = StreamData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceMessage {
    return {
      statusUpdate: isSet(object.statusUpdate) ? StatusUpdate.fromJSON(object.statusUpdate) : undefined,
      streamStatus: isSet(object.streamStatus) ? StreamStatus.fromJSON(object.streamStatus) : undefined,
      streamData: isSet(object.streamData) ? StreamData.fromJSON(object.streamData) : undefined,
    };
  },

  toJSON(message: DeviceMessage): unknown {
    const obj: any = {};
    if (message.statusUpdate !== undefined) {
      obj.statusUpdate = StatusUpdate.toJSON(message.statusUpdate);
    }
    if (message.streamStatus !== undefined) {
      obj.streamStatus = StreamStatus.toJSON(message.streamStatus);
    }
    if (message.streamData !== undefined) {
      obj.streamData = StreamData.toJSON(message.streamData);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceMessage>): DeviceMessage {
    return DeviceMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceMessage>): DeviceMessage {
    const message = createBaseDeviceMessage();
    message.statusUpdate = (object.statusUpdate !== undefined && object.statusUpdate !== null)
      ? StatusUpdate.fromPartial(object.statusUpdate)
      : undefined;
    message.streamStatus = (object.streamStatus !== undefined && object.streamStatus !== null)
      ? StreamStatus.fromPartial(object.streamStatus)
      : undefined;
    message.streamData = (object.streamData !== undefined && object.streamData !== null)
      ? StreamData.fromPartial(object.streamData)
      : undefined;
    return message;
  },
};

function createBaseAdbMessage(): AdbMessage {
  return { open: undefined, streamData: undefined };
}

export const AdbMessage: MessageFns<AdbMessage> = {
  encode(message: AdbMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.open !== undefined) {
      Open.encode(message.open, writer.uint32(10).fork()).join();
    }
    if (message.streamData !== undefined) {
      StreamData.encode(message.streamData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdbMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdbMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.open = Open.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streamData = StreamData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdbMessage {
    return {
      open: isSet(object.open) ? Open.fromJSON(object.open) : undefined,
      streamData: isSet(object.streamData) ? StreamData.fromJSON(object.streamData) : undefined,
    };
  },

  toJSON(message: AdbMessage): unknown {
    const obj: any = {};
    if (message.open !== undefined) {
      obj.open = Open.toJSON(message.open);
    }
    if (message.streamData !== undefined) {
      obj.streamData = StreamData.toJSON(message.streamData);
    }
    return obj;
  },

  create(base?: DeepPartial<AdbMessage>): AdbMessage {
    return AdbMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdbMessage>): AdbMessage {
    const message = createBaseAdbMessage();
    message.open = (object.open !== undefined && object.open !== null) ? Open.fromPartial(object.open) : undefined;
    message.streamData = (object.streamData !== undefined && object.streamData !== null)
      ? StreamData.fromPartial(object.streamData)
      : undefined;
    return message;
  },
};

function createBaseStatusUpdate(): StatusUpdate {
  return { state: 0, properties: {}, features: "" };
}

export const StatusUpdate: MessageFns<StatusUpdate> = {
  encode(message: StatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      StatusUpdate_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.features !== "") {
      writer.uint32(26).string(message.features);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = StatusUpdate_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.features = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate {
    return {
      state: isSet(object.state) ? statusUpdate_DeviceStateFromJSON(object.state) : 0,
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      features: isSet(object.features) ? globalThis.String(object.features) : "",
    };
  },

  toJSON(message: StatusUpdate): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = statusUpdate_DeviceStateToJSON(message.state);
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    if (message.features !== "") {
      obj.features = message.features;
    }
    return obj;
  },

  create(base?: DeepPartial<StatusUpdate>): StatusUpdate {
    return StatusUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusUpdate>): StatusUpdate {
    const message = createBaseStatusUpdate();
    message.state = object.state ?? 0;
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.features = object.features ?? "";
    return message;
  },
};

function createBaseStatusUpdate_PropertiesEntry(): StatusUpdate_PropertiesEntry {
  return { key: "", value: "" };
}

export const StatusUpdate_PropertiesEntry: MessageFns<StatusUpdate_PropertiesEntry> = {
  encode(message: StatusUpdate_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusUpdate_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StatusUpdate_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StatusUpdate_PropertiesEntry>): StatusUpdate_PropertiesEntry {
    return StatusUpdate_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusUpdate_PropertiesEntry>): StatusUpdate_PropertiesEntry {
    const message = createBaseStatusUpdate_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStreamStatus(): StreamStatus {
  return { streamId: 0, okay: undefined, fail: undefined };
}

export const StreamStatus: MessageFns<StreamStatus> = {
  encode(message: StreamStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== 0) {
      writer.uint32(8).int32(message.streamId);
    }
    if (message.okay !== undefined) {
      Okay.encode(message.okay, writer.uint32(18).fork()).join();
    }
    if (message.fail !== undefined) {
      Fail.encode(message.fail, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.streamId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.okay = Okay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fail = Fail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStatus {
    return {
      streamId: isSet(object.streamId) ? globalThis.Number(object.streamId) : 0,
      okay: isSet(object.okay) ? Okay.fromJSON(object.okay) : undefined,
      fail: isSet(object.fail) ? Fail.fromJSON(object.fail) : undefined,
    };
  },

  toJSON(message: StreamStatus): unknown {
    const obj: any = {};
    if (message.streamId !== 0) {
      obj.streamId = Math.round(message.streamId);
    }
    if (message.okay !== undefined) {
      obj.okay = Okay.toJSON(message.okay);
    }
    if (message.fail !== undefined) {
      obj.fail = Fail.toJSON(message.fail);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStatus>): StreamStatus {
    return StreamStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStatus>): StreamStatus {
    const message = createBaseStreamStatus();
    message.streamId = object.streamId ?? 0;
    message.okay = (object.okay !== undefined && object.okay !== null) ? Okay.fromPartial(object.okay) : undefined;
    message.fail = (object.fail !== undefined && object.fail !== null) ? Fail.fromPartial(object.fail) : undefined;
    return message;
  },
};

function createBaseOpen(): Open {
  return { streamId: 0, service: "" };
}

export const Open: MessageFns<Open> = {
  encode(message: Open, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== 0) {
      writer.uint32(8).int32(message.streamId);
    }
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Open {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.streamId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Open {
    return {
      streamId: isSet(object.streamId) ? globalThis.Number(object.streamId) : 0,
      service: isSet(object.service) ? globalThis.String(object.service) : "",
    };
  },

  toJSON(message: Open): unknown {
    const obj: any = {};
    if (message.streamId !== 0) {
      obj.streamId = Math.round(message.streamId);
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<Open>): Open {
    return Open.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Open>): Open {
    const message = createBaseOpen();
    message.streamId = object.streamId ?? 0;
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseStreamData(): StreamData {
  return { streamId: 0, data: undefined, close: undefined };
}

export const StreamData: MessageFns<StreamData> = {
  encode(message: StreamData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== 0) {
      writer.uint32(8).int32(message.streamId);
    }
    if (message.data !== undefined) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.close !== undefined) {
      Close.encode(message.close, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.streamId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.close = Close.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamData {
    return {
      streamId: isSet(object.streamId) ? globalThis.Number(object.streamId) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : undefined,
      close: isSet(object.close) ? Close.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: StreamData): unknown {
    const obj: any = {};
    if (message.streamId !== 0) {
      obj.streamId = Math.round(message.streamId);
    }
    if (message.data !== undefined) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.close !== undefined) {
      obj.close = Close.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamData>): StreamData {
    return StreamData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamData>): StreamData {
    const message = createBaseStreamData();
    message.streamId = object.streamId ?? 0;
    message.data = object.data ?? undefined;
    message.close = (object.close !== undefined && object.close !== null) ? Close.fromPartial(object.close) : undefined;
    return message;
  },
};

function createBaseOkay(): Okay {
  return {};
}

export const Okay: MessageFns<Okay> = {
  encode(_: Okay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Okay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOkay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Okay {
    return {};
  },

  toJSON(_: Okay): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Okay>): Okay {
    return Okay.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Okay>): Okay {
    const message = createBaseOkay();
    return message;
  },
};

function createBaseFail(): Fail {
  return { reason: "" };
}

export const Fail: MessageFns<Fail> = {
  encode(message: Fail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fail {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: Fail): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<Fail>): Fail {
    return Fail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fail>): Fail {
    const message = createBaseFail();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseClose(): Close {
  return {};
}

export const Close: MessageFns<Close> = {
  encode(_: Close, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Close {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Close {
    return {};
  },

  toJSON(_: Close): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Close>): Close {
    return Close.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Close>): Close {
    const message = createBaseClose();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
