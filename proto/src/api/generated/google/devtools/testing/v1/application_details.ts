// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/testing/v1/application_details.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FileReference } from "./test_execution.js";

export const protobufPackage = "google.devtools.testing.v1";

/**
 * Android application details based on application manifest and archive
 * contents.
 */
export interface ApkDetail {
  apkManifest: ApkManifest | undefined;
}

/**
 * An Android app manifest. See
 * http://developer.android.com/guide/topics/manifest/manifest-intro.html
 */
export interface ApkManifest {
  /**
   * Full Java-style package name for this application, e.g.
   * "com.example.foo".
   */
  packageName: string;
  /** Minimum API level required for the application to run. */
  minSdkVersion: number;
  /** Maximum API level on which the application is designed to run. */
  maxSdkVersion: number;
  /** Specifies the API Level on which the application is designed to run. */
  targetSdkVersion: number;
  /** User-readable name for the application. */
  applicationLabel: string;
  intentFilters: IntentFilter[];
  /** Permissions declared to be used by the application */
  usesPermission: string[];
  /** Version number used internally by the app. */
  versionCode: Long;
  /** Version number shown to users. */
  versionName: string;
  /** Meta-data tags defined in the manifest. */
  metadata: Metadata[];
  /** Feature usage tags defined in the manifest. */
  usesFeature: UsesFeature[];
  /** Services contained in the <application> tag. */
  services: Service[];
}

/**
 * The <service> section of an <application> tag.
 * https://developer.android.com/guide/topics/manifest/service-element
 */
export interface Service {
  /** The android:name value */
  name: string;
  /** Intent filters in the service */
  intentFilter: IntentFilter[];
}

/**
 * The <intent-filter> section of an <activity> tag.
 * https://developer.android.com/guide/topics/manifest/intent-filter-element.html
 */
export interface IntentFilter {
  /** The android:name value of the <action> tag. */
  actionNames: string[];
  /** The android:name value of the <category> tag. */
  categoryNames: string[];
  /** The android:mimeType value of the <data> tag. */
  mimeType: string;
}

/**
 * A <meta-data> tag within a manifest.
 * https://developer.android.com/guide/topics/manifest/meta-data-element.html
 */
export interface Metadata {
  /** The android:name value */
  name: string;
  /** The android:value value */
  value: string;
}

/**
 * A <uses-feature> tag within a manifest.
 * https://developer.android.com/guide/topics/manifest/uses-feature-element.html
 */
export interface UsesFeature {
  /** The android:name value */
  name: string;
  /** The android:required value */
  isRequired: boolean;
}

/** A request to get the details of an Android application. */
export interface GetApkDetailsRequest {
  /** Optional. The APK to be parsed for details. */
  location:
    | FileReference
    | undefined;
  /** Optional. The App Bundle to be parsed for details. */
  bundleLocation: FileReference | undefined;
}

/** Response containing the details of the specified Android application. */
export interface GetApkDetailsResponse {
  /** Details of the Android App. */
  apkDetail: ApkDetail | undefined;
}

function createBaseApkDetail(): ApkDetail {
  return { apkManifest: undefined };
}

export const ApkDetail: MessageFns<ApkDetail> = {
  encode(message: ApkDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apkManifest !== undefined) {
      ApkManifest.encode(message.apkManifest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApkDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApkDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apkManifest = ApkManifest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApkDetail {
    return { apkManifest: isSet(object.apkManifest) ? ApkManifest.fromJSON(object.apkManifest) : undefined };
  },

  toJSON(message: ApkDetail): unknown {
    const obj: any = {};
    if (message.apkManifest !== undefined) {
      obj.apkManifest = ApkManifest.toJSON(message.apkManifest);
    }
    return obj;
  },

  create(base?: DeepPartial<ApkDetail>): ApkDetail {
    return ApkDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApkDetail>): ApkDetail {
    const message = createBaseApkDetail();
    message.apkManifest = (object.apkManifest !== undefined && object.apkManifest !== null)
      ? ApkManifest.fromPartial(object.apkManifest)
      : undefined;
    return message;
  },
};

function createBaseApkManifest(): ApkManifest {
  return {
    packageName: "",
    minSdkVersion: 0,
    maxSdkVersion: 0,
    targetSdkVersion: 0,
    applicationLabel: "",
    intentFilters: [],
    usesPermission: [],
    versionCode: Long.ZERO,
    versionName: "",
    metadata: [],
    usesFeature: [],
    services: [],
  };
}

export const ApkManifest: MessageFns<ApkManifest> = {
  encode(message: ApkManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageName !== "") {
      writer.uint32(10).string(message.packageName);
    }
    if (message.minSdkVersion !== 0) {
      writer.uint32(16).int32(message.minSdkVersion);
    }
    if (message.maxSdkVersion !== 0) {
      writer.uint32(24).int32(message.maxSdkVersion);
    }
    if (message.targetSdkVersion !== 0) {
      writer.uint32(48).int32(message.targetSdkVersion);
    }
    if (message.applicationLabel !== "") {
      writer.uint32(34).string(message.applicationLabel);
    }
    for (const v of message.intentFilters) {
      IntentFilter.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.usesPermission) {
      writer.uint32(58).string(v!);
    }
    if (!message.versionCode.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.versionCode.toString());
    }
    if (message.versionName !== "") {
      writer.uint32(74).string(message.versionName);
    }
    for (const v of message.metadata) {
      Metadata.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.usesFeature) {
      UsesFeature.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApkManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApkManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packageName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minSdkVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxSdkVersion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.targetSdkVersion = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.applicationLabel = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intentFilters.push(IntentFilter.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.usesPermission.push(reader.string());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.versionCode = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.versionName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.metadata.push(Metadata.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.usesFeature.push(UsesFeature.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApkManifest {
    return {
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
      minSdkVersion: isSet(object.minSdkVersion) ? globalThis.Number(object.minSdkVersion) : 0,
      maxSdkVersion: isSet(object.maxSdkVersion) ? globalThis.Number(object.maxSdkVersion) : 0,
      targetSdkVersion: isSet(object.targetSdkVersion) ? globalThis.Number(object.targetSdkVersion) : 0,
      applicationLabel: isSet(object.applicationLabel) ? globalThis.String(object.applicationLabel) : "",
      intentFilters: globalThis.Array.isArray(object?.intentFilters)
        ? object.intentFilters.map((e: any) => IntentFilter.fromJSON(e))
        : [],
      usesPermission: globalThis.Array.isArray(object?.usesPermission)
        ? object.usesPermission.map((e: any) => globalThis.String(e))
        : [],
      versionCode: isSet(object.versionCode) ? Long.fromValue(object.versionCode) : Long.ZERO,
      versionName: isSet(object.versionName) ? globalThis.String(object.versionName) : "",
      metadata: globalThis.Array.isArray(object?.metadata) ? object.metadata.map((e: any) => Metadata.fromJSON(e)) : [],
      usesFeature: globalThis.Array.isArray(object?.usesFeature)
        ? object.usesFeature.map((e: any) => UsesFeature.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
    };
  },

  toJSON(message: ApkManifest): unknown {
    const obj: any = {};
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.minSdkVersion !== 0) {
      obj.minSdkVersion = Math.round(message.minSdkVersion);
    }
    if (message.maxSdkVersion !== 0) {
      obj.maxSdkVersion = Math.round(message.maxSdkVersion);
    }
    if (message.targetSdkVersion !== 0) {
      obj.targetSdkVersion = Math.round(message.targetSdkVersion);
    }
    if (message.applicationLabel !== "") {
      obj.applicationLabel = message.applicationLabel;
    }
    if (message.intentFilters?.length) {
      obj.intentFilters = message.intentFilters.map((e) => IntentFilter.toJSON(e));
    }
    if (message.usesPermission?.length) {
      obj.usesPermission = message.usesPermission;
    }
    if (!message.versionCode.equals(Long.ZERO)) {
      obj.versionCode = (message.versionCode || Long.ZERO).toString();
    }
    if (message.versionName !== "") {
      obj.versionName = message.versionName;
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => Metadata.toJSON(e));
    }
    if (message.usesFeature?.length) {
      obj.usesFeature = message.usesFeature.map((e) => UsesFeature.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ApkManifest>): ApkManifest {
    return ApkManifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApkManifest>): ApkManifest {
    const message = createBaseApkManifest();
    message.packageName = object.packageName ?? "";
    message.minSdkVersion = object.minSdkVersion ?? 0;
    message.maxSdkVersion = object.maxSdkVersion ?? 0;
    message.targetSdkVersion = object.targetSdkVersion ?? 0;
    message.applicationLabel = object.applicationLabel ?? "";
    message.intentFilters = object.intentFilters?.map((e) => IntentFilter.fromPartial(e)) || [];
    message.usesPermission = object.usesPermission?.map((e) => e) || [];
    message.versionCode = (object.versionCode !== undefined && object.versionCode !== null)
      ? Long.fromValue(object.versionCode)
      : Long.ZERO;
    message.versionName = object.versionName ?? "";
    message.metadata = object.metadata?.map((e) => Metadata.fromPartial(e)) || [];
    message.usesFeature = object.usesFeature?.map((e) => UsesFeature.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    return message;
  },
};

function createBaseService(): Service {
  return { name: "", intentFilter: [] };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.intentFilter) {
      IntentFilter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentFilter.push(IntentFilter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      intentFilter: globalThis.Array.isArray(object?.intentFilter)
        ? object.intentFilter.map((e: any) => IntentFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.intentFilter?.length) {
      obj.intentFilter = message.intentFilter.map((e) => IntentFilter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Service>): Service {
    return Service.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service>): Service {
    const message = createBaseService();
    message.name = object.name ?? "";
    message.intentFilter = object.intentFilter?.map((e) => IntentFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntentFilter(): IntentFilter {
  return { actionNames: [], categoryNames: [], mimeType: "" };
}

export const IntentFilter: MessageFns<IntentFilter> = {
  encode(message: IntentFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.categoryNames) {
      writer.uint32(18).string(v!);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.categoryNames.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentFilter {
    return {
      actionNames: globalThis.Array.isArray(object?.actionNames)
        ? object.actionNames.map((e: any) => globalThis.String(e))
        : [],
      categoryNames: globalThis.Array.isArray(object?.categoryNames)
        ? object.categoryNames.map((e: any) => globalThis.String(e))
        : [],
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: IntentFilter): unknown {
    const obj: any = {};
    if (message.actionNames?.length) {
      obj.actionNames = message.actionNames;
    }
    if (message.categoryNames?.length) {
      obj.categoryNames = message.categoryNames;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentFilter>): IntentFilter {
    return IntentFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentFilter>): IntentFilter {
    const message = createBaseIntentFilter();
    message.actionNames = object.actionNames?.map((e) => e) || [];
    message.categoryNames = object.categoryNames?.map((e) => e) || [];
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { name: "", value: "" };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUsesFeature(): UsesFeature {
  return { name: "", isRequired: false };
}

export const UsesFeature: MessageFns<UsesFeature> = {
  encode(message: UsesFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.isRequired !== false) {
      writer.uint32(16).bool(message.isRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsesFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsesFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsesFeature {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isRequired: isSet(object.isRequired) ? globalThis.Boolean(object.isRequired) : false,
    };
  },

  toJSON(message: UsesFeature): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isRequired !== false) {
      obj.isRequired = message.isRequired;
    }
    return obj;
  },

  create(base?: DeepPartial<UsesFeature>): UsesFeature {
    return UsesFeature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UsesFeature>): UsesFeature {
    const message = createBaseUsesFeature();
    message.name = object.name ?? "";
    message.isRequired = object.isRequired ?? false;
    return message;
  },
};

function createBaseGetApkDetailsRequest(): GetApkDetailsRequest {
  return { location: undefined, bundleLocation: undefined };
}

export const GetApkDetailsRequest: MessageFns<GetApkDetailsRequest> = {
  encode(message: GetApkDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      FileReference.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.bundleLocation !== undefined) {
      FileReference.encode(message.bundleLocation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetApkDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetApkDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = FileReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundleLocation = FileReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetApkDetailsRequest {
    return {
      location: isSet(object.location) ? FileReference.fromJSON(object.location) : undefined,
      bundleLocation: isSet(object.bundleLocation) ? FileReference.fromJSON(object.bundleLocation) : undefined,
    };
  },

  toJSON(message: GetApkDetailsRequest): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = FileReference.toJSON(message.location);
    }
    if (message.bundleLocation !== undefined) {
      obj.bundleLocation = FileReference.toJSON(message.bundleLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<GetApkDetailsRequest>): GetApkDetailsRequest {
    return GetApkDetailsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetApkDetailsRequest>): GetApkDetailsRequest {
    const message = createBaseGetApkDetailsRequest();
    message.location = (object.location !== undefined && object.location !== null)
      ? FileReference.fromPartial(object.location)
      : undefined;
    message.bundleLocation = (object.bundleLocation !== undefined && object.bundleLocation !== null)
      ? FileReference.fromPartial(object.bundleLocation)
      : undefined;
    return message;
  },
};

function createBaseGetApkDetailsResponse(): GetApkDetailsResponse {
  return { apkDetail: undefined };
}

export const GetApkDetailsResponse: MessageFns<GetApkDetailsResponse> = {
  encode(message: GetApkDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apkDetail !== undefined) {
      ApkDetail.encode(message.apkDetail, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetApkDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetApkDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apkDetail = ApkDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetApkDetailsResponse {
    return { apkDetail: isSet(object.apkDetail) ? ApkDetail.fromJSON(object.apkDetail) : undefined };
  },

  toJSON(message: GetApkDetailsResponse): unknown {
    const obj: any = {};
    if (message.apkDetail !== undefined) {
      obj.apkDetail = ApkDetail.toJSON(message.apkDetail);
    }
    return obj;
  },

  create(base?: DeepPartial<GetApkDetailsResponse>): GetApkDetailsResponse {
    return GetApkDetailsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetApkDetailsResponse>): GetApkDetailsResponse {
    const message = createBaseGetApkDetailsResponse();
    message.apkDetail = (object.apkDetail !== undefined && object.apkDetail !== null)
      ? ApkDetail.fromPartial(object.apkDetail)
      : undefined;
    return message;
  },
};

/**
 * A service which parses input applications and returns details that can be
 * useful in the context of testing.
 */
export type ApplicationDetailServiceDefinition = typeof ApplicationDetailServiceDefinition;
export const ApplicationDetailServiceDefinition = {
  name: "ApplicationDetailService",
  fullName: "google.devtools.testing.v1.ApplicationDetailService",
  methods: {
    /** Gets the details of an Android application APK. */
    getApkDetails: {
      name: "GetApkDetails",
      requestType: GetApkDetailsRequest,
      requestStream: false,
      responseType: GetApkDetailsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              58,
              8,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              34,
              42,
              47,
              118,
              49,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              68,
              101,
              116,
              97,
              105,
              108,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              47,
              103,
              101,
              116,
              65,
              112,
              107,
              68,
              101,
              116,
              97,
              105,
              108,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ApplicationDetailServiceImplementation<CallContextExt = {}> {
  /** Gets the details of an Android application APK. */
  getApkDetails(
    request: GetApkDetailsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetApkDetailsResponse>>;
}

export interface ApplicationDetailServiceClient<CallOptionsExt = {}> {
  /** Gets the details of an Android application APK. */
  getApkDetails(
    request: DeepPartial<GetApkDetailsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetApkDetailsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
