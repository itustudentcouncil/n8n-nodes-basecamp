// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/resultstore/v2/resultstore_download.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Action } from "./action.js";
import { Configuration } from "./configuration.js";
import { ConfiguredTarget } from "./configured_target.js";
import { DownloadMetadata } from "./download_metadata.js";
import { FileSet } from "./file_set.js";
import { Invocation } from "./invocation.js";
import { Target } from "./target.js";

export const protobufPackage = "google.devtools.resultstore.v2";

/** Request passed into GetInvocation */
export interface GetInvocationRequest {
  /**
   * Required. The name of the invocation to retrieve. It must match this
   * format: invocations/${INVOCATION_ID} where INVOCATION_ID must be an RFC
   * 4122-compliant UUID.
   */
  name: string;
}

/** Request passed into SearchInvocations */
export interface SearchInvocationsRequest {
  /**
   * The maximum number of items to return. Zero means all, but may be capped by
   * the server.
   */
  pageSize: number;
  /**
   * The next_page_token value returned from a previous Search request, if
   * any.
   */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. May be rejected if too high. */
  offset?:
    | Long
    | undefined;
  /**
   * A filtering query string.
   *
   * Only a limited number of fields and operators are supported. Not every
   * field supports every operator.
   *
   * Fields that support equals ("=") restrictions:
   *
   * id.invocation_id
   * name
   * status_attributes.status
   * workspace_info.hostname
   * download_metadata.upload_status
   *
   * Fields that support contains (":") restrictions:
   *
   * invocation_attributes.users
   * invocation_attributes.labels
   *
   * Fields that support comparison ("<", "<=", ">", ">=") restrictions;
   *
   * timing.start_time
   *
   * Supported custom function global restrictions:
   *
   * propertyEquals("key", "value")
   */
  query: string;
  /** The project id to search under. */
  projectId: string;
  /**
   * If true, all equals or contains restrictions on string fields in query will
   * require exact match. Otherwise, a string field restriction may ignore case
   * and punctuation.
   */
  exactMatch: boolean;
}

/** Response from calling SearchInvocations */
export interface SearchInvocationsResponse {
  /**
   * Invocations matching the search, possibly capped at request.page_size or a
   * server limit.
   */
  invocations: Invocation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results.
   */
  nextPageToken: string;
}

/** Request passed into ExportInvocationRequest */
export interface ExportInvocationRequest {
  /**
   * Required. The name of the invocation to retrieve. It must match this
   * format: invocations/${INVOCATION_ID} where INVOCATION_ID must be an RFC
   * 4122-compliant UUID.
   */
  name: string;
  /**
   * The maximum number of items to return. Zero means all, but may be capped by
   * the server.
   */
  pageSize: number;
  /**
   * The next_page_token value returned from a previous export request, if
   * any.
   */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * Filters Targets, ConfiguredTargets, and Actions returned
   *
   * Only id.target_id field with single equals ("=") restriction supported
   */
  targetsFilter: string;
  /**
   * Requires targets_filter to be populated
   * Filters ConfiguredTargets and Actions returned
   *
   * Only id.configuration_id field with single equals ("=") restriction
   * supported
   */
  configuredTargetsFilter: string;
  /**
   * Requires both targets_filter and configured_targets_filter to be populated
   * Filters Actions returned
   *
   * Only id.action_id field with single equals ("=") restriction supported
   */
  actionsFilter: string;
}

/**
 * Response from calling ExportInvocationResponse.
 * Possibly capped at request.page_size or a server limit.
 */
export interface ExportInvocationResponse {
  /** Parent Invocation resource. */
  invocation:
    | Invocation
    | undefined;
  /**
   * download metadata of request invocation
   * download_metadata and invocation count towards page_size once.
   */
  downloadMetadata:
    | DownloadMetadata
    | undefined;
  /** Targets matching the request invocation. */
  targets: Target[];
  /** Configurations matching the request invocation. */
  configurations: Configuration[];
  /** ConfiguredTargets matching the request invocation. */
  configuredTargets: ConfiguredTarget[];
  /** Actions matching the request invocation. */
  actions: Action[];
  /** FileSets matching the request invocation. */
  fileSets: FileSet[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into GetInvocationDownloadMetadata */
export interface GetInvocationDownloadMetadataRequest {
  /**
   * Required. The name of the download metadata to retrieve. It must match this
   * format: invocations/${INVOCATION_ID}/downloadMetadata where INVOCATION_ID
   * must be an RFC 4122-compliant UUID.
   */
  name: string;
}

/** Request passed into GetConfiguration */
export interface GetConfigurationRequest {
  /**
   * Required. The name of the configuration to retrieve. It must match this
   * format: invocations/${INVOCATION_ID}/configs/${CONFIGURATION_ID}
   */
  name: string;
}

/** Request passed into ListConfigurations */
export interface ListConfigurationsRequest {
  /**
   * Required. The invocation name of the configurations to retrieve.
   * It must match this format: invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling ListConfigurations */
export interface ListConfigurationsResponse {
  /**
   * Configurations matching the request invocation,
   * possibly capped at request.page_size or a server limit.
   */
  configurations: Configuration[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into GetTarget */
export interface GetTargetRequest {
  /**
   * Required. The name of the target to retrieve. It must match this format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   */
  name: string;
}

/** Request passed into ListTargets */
export interface ListTargetsRequest {
  /**
   * Required. The invocation name of the targets to retrieve. It must match
   * this format: invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling ListTargetsResponse */
export interface ListTargetsResponse {
  /**
   * Targets matching the request invocation,
   * possibly capped at request.page_size or a server limit.
   */
  targets: Target[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into GetConfiguredTarget */
export interface GetConfiguredTargetRequest {
  /**
   * Required. The name of the configured target to retrieve. It must match this
   * format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
   */
  name: string;
}

/** Request passed into ListConfiguredTargets */
export interface ListConfiguredTargetsRequest {
  /**
   * Required. The invocation and target name of the configured targets to
   * retrieve. It must match this format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
   * Supports '-' for ${TARGET_ID} meaning all targets.
   */
  parent: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling ListConfiguredTargets */
export interface ListConfiguredTargetsResponse {
  /**
   * ConfiguredTargets matching the request,
   * possibly capped at request.page_size or a server limit.
   */
  configuredTargets: ConfiguredTarget[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into SearchConfiguredTargets */
export interface SearchConfiguredTargetsRequest {
  /**
   * Required. Must be set to invocations/-/targets/-
   * This only supports searching all ConfiguredTargets across all Invocations.
   */
  parent: string;
  /**
   * The maximum number of items to return. Zero means all, but may be capped by
   * the server.
   */
  pageSize: number;
  /**
   * The next_page_token value returned from a previous Search request, if
   * any.
   */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. May be rejected if too high. */
  offset?:
    | Long
    | undefined;
  /**
   * A filtering query string.
   *
   * Only a limited number of fields and operators are supported. Not every
   * field supports every operator. Access to parent resources is provided
   * via synthetic fields ‘invocation’, ‘configuration’, and ‘target’.
   *
   * Any search must contain an equals restriction on id.target_id.
   *
   * Fields that support equals ("=") restrictions:
   *
   * id.target_id
   * status_attributes.status
   *
   * target.target_attributes.type
   * target.target_attributes.language
   * target.test_attributes.size
   *
   * configuration.configuration_attributes.cpu
   *
   * invocation.workspace_info.hostname
   *
   * Fields that support contains (":") restrictions:
   *
   * target.target_attributes.tags
   *
   * invocation.invocation_attributes.users
   * invocation.invocation_attributes.labels
   *
   * Fields that support comparison ("<", "<=", ">", ">=") restrictions;
   *
   * timing.start_time
   * coalesced_start_time
   * Supported custom function global restrictions:
   *
   * invocationPropertyEquals("key", "value")
   * targetPropertyEquals("key", "value")
   * configurationPropertyEquals("key", "value")
   * configuredTargetPropertyEquals("key", "value")
   */
  query: string;
  /** The project id to search under. */
  projectId: string;
  /** Unimplemented */
  exactMatch: boolean;
}

/** Response from calling SearchConfiguredTargets */
export interface SearchConfiguredTargetsResponse {
  /**
   * ConfiguredTargets matching the search, possibly capped at request.page_size
   * or a server limit.
   */
  configuredTargets: ConfiguredTarget[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results.
   */
  nextPageToken: string;
}

/** Request passed into GetAction */
export interface GetActionRequest {
  /**
   * Required. The name of the action to retrieve. It must match this format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}/actions/${ACTION_ID}
   */
  name: string;
}

/** Request passed into ListActions */
export interface ListActionsRequest {
  /**
   * Required. The invocation, target, and configuration name of the action to
   * retrieve. It must match this format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
   * Supports '-' for ${CONFIGURATION_ID} to mean all Actions for all
   * Configurations for a Target, or '-' for ${TARGET_ID} and
   * ${CONFIGURATION_ID} to mean all Actions for all Configurations and all
   * Targets. Does not support ${TARGET_ID} '-' with a specified configuration.
   */
  parent: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling ListActions */
export interface ListActionsResponse {
  /**
   * Actions matching the request,
   * possibly capped at request.page_size or a server limit.
   */
  actions: Action[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into BatchListActionsRequest */
export interface BatchListActionsRequest {
  /**
   * Required. The invocation name of the actions to retrieve. It must match
   * this format: invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The names of the configured targets to retrieve.
   * It must match this format:
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
   */
  configuredTargets: string[];
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /**
   * The next_page_token value returned from a previous List request, if any.
   * Page tokens will become larger with every page returned, and if a page
   * token becomes too large, it will no longer be possible to continue to
   * calculate the transitive dependencies. The API will return a 400
   * Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
   * this happens.
   */
  pageToken?:
    | string
    | undefined;
  /**
   * Absolute number of results to skip.
   * Not yet implemented. 0 for default.
   */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling BatchListActionsResponse */
export interface BatchListActionsResponse {
  /**
   * Actions matching the request,
   * possibly capped at request.page_size or a server limit.
   */
  actions: Action[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
  /** Not found configured target names. */
  notFound: string[];
}

/** Request passed into GetFileSet */
export interface GetFileSetRequest {
  /**
   * Required. The name of the file set to retrieve. It must match this format:
   * invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
   */
  name: string;
}

/** Request passed into ListFileSets */
export interface ListFileSetsRequest {
  /**
   * Required. The invocation name of the file sets to retrieve.
   * It must match this format: invocations/${INVOCATION_ID}
   */
  parent: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken?:
    | string
    | undefined;
  /** Absolute number of results to skip. */
  offset?:
    | Long
    | undefined;
  /**
   * A filter to return only resources that match it.
   * Any fields used in the filter must be also specified in the field mask.
   * May cause pages with 0 results and a next_page_token to be returned.
   */
  filter: string;
}

/** Response from calling ListFileSets */
export interface ListFileSetsResponse {
  /**
   * File sets matching the request,
   * possibly capped at request.page_size or a server limit.
   */
  fileSets: FileSet[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/** Request passed into TraverseFileSets */
export interface TraverseFileSetsRequest {
  /**
   * Required. The name of the resource to traverse.
   * It must match one of the following formats:
   *
   * invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
   * This returns the transitive closure of FileSets referenced by the given
   * FileSet, including itself.
   *
   * invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}/actions/${ACTION_ID}
   * This returns the transitive closure of FileSets referenced by the given
   * Action. If ${ACTION_ID} is "-", this returns the transitive closure of
   * FileSets referenced by all Actions under the given ConfiguredTarget.
   */
  name: string;
  /**
   * The maximum number of items to return.
   * Zero means all, but may be capped by the server.
   */
  pageSize: number;
  /**
   * The next_page_token value returned from a previous List request, if any.
   * Page tokens will become larger with every page returned, and if a page
   * token becomes too large, it will no longer be possible to continue to
   * calculate the transitive dependencies. The API will return a 400
   * Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
   * this happens.
   */
  pageToken?:
    | string
    | undefined;
  /**
   * Absolute number of results to skip.
   * Not yet implemented. 0 for default.
   */
  offset?: Long | undefined;
}

/** Response from calling TraverseFileSets */
export interface TraverseFileSetsResponse {
  /**
   * File sets matching the request.
   * The order in which results are returned is undefined, but stable.
   */
  fileSets: FileSet[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

function createBaseGetInvocationRequest(): GetInvocationRequest {
  return { name: "" };
}

export const GetInvocationRequest: MessageFns<GetInvocationRequest> = {
  encode(message: GetInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvocationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvocationRequest>): GetInvocationRequest {
    return GetInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvocationRequest>): GetInvocationRequest {
    const message = createBaseGetInvocationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSearchInvocationsRequest(): SearchInvocationsRequest {
  return { pageSize: 0, pageToken: undefined, offset: undefined, query: "", projectId: "", exactMatch: false };
}

export const SearchInvocationsRequest: MessageFns<SearchInvocationsRequest> = {
  encode(message: SearchInvocationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int64(message.offset.toString());
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.projectId !== "") {
      writer.uint32(42).string(message.projectId);
    }
    if (message.exactMatch !== false) {
      writer.uint32(56).bool(message.exactMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchInvocationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchInvocationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exactMatch = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchInvocationsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      exactMatch: isSet(object.exactMatch) ? globalThis.Boolean(object.exactMatch) : false,
    };
  },

  toJSON(message: SearchInvocationsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.exactMatch !== false) {
      obj.exactMatch = message.exactMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchInvocationsRequest>): SearchInvocationsRequest {
    return SearchInvocationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchInvocationsRequest>): SearchInvocationsRequest {
    const message = createBaseSearchInvocationsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.query = object.query ?? "";
    message.projectId = object.projectId ?? "";
    message.exactMatch = object.exactMatch ?? false;
    return message;
  },
};

function createBaseSearchInvocationsResponse(): SearchInvocationsResponse {
  return { invocations: [], nextPageToken: "" };
}

export const SearchInvocationsResponse: MessageFns<SearchInvocationsResponse> = {
  encode(message: SearchInvocationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invocations) {
      Invocation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchInvocationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchInvocationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocations.push(Invocation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchInvocationsResponse {
    return {
      invocations: globalThis.Array.isArray(object?.invocations)
        ? object.invocations.map((e: any) => Invocation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchInvocationsResponse): unknown {
    const obj: any = {};
    if (message.invocations?.length) {
      obj.invocations = message.invocations.map((e) => Invocation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchInvocationsResponse>): SearchInvocationsResponse {
    return SearchInvocationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchInvocationsResponse>): SearchInvocationsResponse {
    const message = createBaseSearchInvocationsResponse();
    message.invocations = object.invocations?.map((e) => Invocation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseExportInvocationRequest(): ExportInvocationRequest {
  return {
    name: "",
    pageSize: 0,
    pageToken: undefined,
    offset: undefined,
    targetsFilter: "",
    configuredTargetsFilter: "",
    actionsFilter: "",
  };
}

export const ExportInvocationRequest: MessageFns<ExportInvocationRequest> = {
  encode(message: ExportInvocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.targetsFilter !== "") {
      writer.uint32(50).string(message.targetsFilter);
    }
    if (message.configuredTargetsFilter !== "") {
      writer.uint32(58).string(message.configuredTargetsFilter);
    }
    if (message.actionsFilter !== "") {
      writer.uint32(66).string(message.actionsFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportInvocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportInvocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetsFilter = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.configuredTargetsFilter = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.actionsFilter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportInvocationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      targetsFilter: isSet(object.targetsFilter) ? globalThis.String(object.targetsFilter) : "",
      configuredTargetsFilter: isSet(object.configuredTargetsFilter)
        ? globalThis.String(object.configuredTargetsFilter)
        : "",
      actionsFilter: isSet(object.actionsFilter) ? globalThis.String(object.actionsFilter) : "",
    };
  },

  toJSON(message: ExportInvocationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.targetsFilter !== "") {
      obj.targetsFilter = message.targetsFilter;
    }
    if (message.configuredTargetsFilter !== "") {
      obj.configuredTargetsFilter = message.configuredTargetsFilter;
    }
    if (message.actionsFilter !== "") {
      obj.actionsFilter = message.actionsFilter;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportInvocationRequest>): ExportInvocationRequest {
    return ExportInvocationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportInvocationRequest>): ExportInvocationRequest {
    const message = createBaseExportInvocationRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.targetsFilter = object.targetsFilter ?? "";
    message.configuredTargetsFilter = object.configuredTargetsFilter ?? "";
    message.actionsFilter = object.actionsFilter ?? "";
    return message;
  },
};

function createBaseExportInvocationResponse(): ExportInvocationResponse {
  return {
    invocation: undefined,
    downloadMetadata: undefined,
    targets: [],
    configurations: [],
    configuredTargets: [],
    actions: [],
    fileSets: [],
    nextPageToken: "",
  };
}

export const ExportInvocationResponse: MessageFns<ExportInvocationResponse> = {
  encode(message: ExportInvocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invocation !== undefined) {
      Invocation.encode(message.invocation, writer.uint32(10).fork()).join();
    }
    if (message.downloadMetadata !== undefined) {
      DownloadMetadata.encode(message.downloadMetadata, writer.uint32(66).fork()).join();
    }
    for (const v of message.targets) {
      Target.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.configurations) {
      Configuration.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.configuredTargets) {
      ConfiguredTarget.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.fileSets) {
      FileSet.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(58).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportInvocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportInvocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocation = Invocation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.downloadMetadata = DownloadMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targets.push(Target.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.configurations.push(Configuration.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.configuredTargets.push(ConfiguredTarget.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fileSets.push(FileSet.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportInvocationResponse {
    return {
      invocation: isSet(object.invocation) ? Invocation.fromJSON(object.invocation) : undefined,
      downloadMetadata: isSet(object.downloadMetadata) ? DownloadMetadata.fromJSON(object.downloadMetadata) : undefined,
      targets: globalThis.Array.isArray(object?.targets) ? object.targets.map((e: any) => Target.fromJSON(e)) : [],
      configurations: globalThis.Array.isArray(object?.configurations)
        ? object.configurations.map((e: any) => Configuration.fromJSON(e))
        : [],
      configuredTargets: globalThis.Array.isArray(object?.configuredTargets)
        ? object.configuredTargets.map((e: any) => ConfiguredTarget.fromJSON(e))
        : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
      fileSets: globalThis.Array.isArray(object?.fileSets) ? object.fileSets.map((e: any) => FileSet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ExportInvocationResponse): unknown {
    const obj: any = {};
    if (message.invocation !== undefined) {
      obj.invocation = Invocation.toJSON(message.invocation);
    }
    if (message.downloadMetadata !== undefined) {
      obj.downloadMetadata = DownloadMetadata.toJSON(message.downloadMetadata);
    }
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => Target.toJSON(e));
    }
    if (message.configurations?.length) {
      obj.configurations = message.configurations.map((e) => Configuration.toJSON(e));
    }
    if (message.configuredTargets?.length) {
      obj.configuredTargets = message.configuredTargets.map((e) => ConfiguredTarget.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets.map((e) => FileSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportInvocationResponse>): ExportInvocationResponse {
    return ExportInvocationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportInvocationResponse>): ExportInvocationResponse {
    const message = createBaseExportInvocationResponse();
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? Invocation.fromPartial(object.invocation)
      : undefined;
    message.downloadMetadata = (object.downloadMetadata !== undefined && object.downloadMetadata !== null)
      ? DownloadMetadata.fromPartial(object.downloadMetadata)
      : undefined;
    message.targets = object.targets?.map((e) => Target.fromPartial(e)) || [];
    message.configurations = object.configurations?.map((e) => Configuration.fromPartial(e)) || [];
    message.configuredTargets = object.configuredTargets?.map((e) => ConfiguredTarget.fromPartial(e)) || [];
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    message.fileSets = object.fileSets?.map((e) => FileSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetInvocationDownloadMetadataRequest(): GetInvocationDownloadMetadataRequest {
  return { name: "" };
}

export const GetInvocationDownloadMetadataRequest: MessageFns<GetInvocationDownloadMetadataRequest> = {
  encode(message: GetInvocationDownloadMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvocationDownloadMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvocationDownloadMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvocationDownloadMetadataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInvocationDownloadMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInvocationDownloadMetadataRequest>): GetInvocationDownloadMetadataRequest {
    return GetInvocationDownloadMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInvocationDownloadMetadataRequest>): GetInvocationDownloadMetadataRequest {
    const message = createBaseGetInvocationDownloadMetadataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetConfigurationRequest(): GetConfigurationRequest {
  return { name: "" };
}

export const GetConfigurationRequest: MessageFns<GetConfigurationRequest> = {
  encode(message: GetConfigurationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConfigurationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigurationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConfigurationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigurationRequest>): GetConfigurationRequest {
    return GetConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigurationRequest>): GetConfigurationRequest {
    const message = createBaseGetConfigurationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConfigurationsRequest(): ListConfigurationsRequest {
  return { parent: "", pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const ListConfigurationsRequest: MessageFns<ListConfigurationsRequest> = {
  encode(message: ListConfigurationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConfigurationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConfigurationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConfigurationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListConfigurationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConfigurationsRequest>): ListConfigurationsRequest {
    return ListConfigurationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConfigurationsRequest>): ListConfigurationsRequest {
    const message = createBaseListConfigurationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListConfigurationsResponse(): ListConfigurationsResponse {
  return { configurations: [], nextPageToken: "" };
}

export const ListConfigurationsResponse: MessageFns<ListConfigurationsResponse> = {
  encode(message: ListConfigurationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configurations) {
      Configuration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConfigurationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConfigurationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configurations.push(Configuration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConfigurationsResponse {
    return {
      configurations: globalThis.Array.isArray(object?.configurations)
        ? object.configurations.map((e: any) => Configuration.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConfigurationsResponse): unknown {
    const obj: any = {};
    if (message.configurations?.length) {
      obj.configurations = message.configurations.map((e) => Configuration.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConfigurationsResponse>): ListConfigurationsResponse {
    return ListConfigurationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConfigurationsResponse>): ListConfigurationsResponse {
    const message = createBaseListConfigurationsResponse();
    message.configurations = object.configurations?.map((e) => Configuration.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTargetRequest(): GetTargetRequest {
  return { name: "" };
}

export const GetTargetRequest: MessageFns<GetTargetRequest> = {
  encode(message: GetTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTargetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTargetRequest>): GetTargetRequest {
    return GetTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTargetRequest>): GetTargetRequest {
    const message = createBaseGetTargetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTargetsRequest(): ListTargetsRequest {
  return { parent: "", pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const ListTargetsRequest: MessageFns<ListTargetsRequest> = {
  encode(message: ListTargetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListTargetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetsRequest>): ListTargetsRequest {
    return ListTargetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetsRequest>): ListTargetsRequest {
    const message = createBaseListTargetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListTargetsResponse(): ListTargetsResponse {
  return { targets: [], nextPageToken: "" };
}

export const ListTargetsResponse: MessageFns<ListTargetsResponse> = {
  encode(message: ListTargetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.targets) {
      Target.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targets.push(Target.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetsResponse {
    return {
      targets: globalThis.Array.isArray(object?.targets) ? object.targets.map((e: any) => Target.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTargetsResponse): unknown {
    const obj: any = {};
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => Target.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetsResponse>): ListTargetsResponse {
    return ListTargetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetsResponse>): ListTargetsResponse {
    const message = createBaseListTargetsResponse();
    message.targets = object.targets?.map((e) => Target.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetConfiguredTargetRequest(): GetConfiguredTargetRequest {
  return { name: "" };
}

export const GetConfiguredTargetRequest: MessageFns<GetConfiguredTargetRequest> = {
  encode(message: GetConfiguredTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConfiguredTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfiguredTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfiguredTargetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConfiguredTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfiguredTargetRequest>): GetConfiguredTargetRequest {
    return GetConfiguredTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfiguredTargetRequest>): GetConfiguredTargetRequest {
    const message = createBaseGetConfiguredTargetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConfiguredTargetsRequest(): ListConfiguredTargetsRequest {
  return { parent: "", pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const ListConfiguredTargetsRequest: MessageFns<ListConfiguredTargetsRequest> = {
  encode(message: ListConfiguredTargetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConfiguredTargetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConfiguredTargetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConfiguredTargetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListConfiguredTargetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConfiguredTargetsRequest>): ListConfiguredTargetsRequest {
    return ListConfiguredTargetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConfiguredTargetsRequest>): ListConfiguredTargetsRequest {
    const message = createBaseListConfiguredTargetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListConfiguredTargetsResponse(): ListConfiguredTargetsResponse {
  return { configuredTargets: [], nextPageToken: "" };
}

export const ListConfiguredTargetsResponse: MessageFns<ListConfiguredTargetsResponse> = {
  encode(message: ListConfiguredTargetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configuredTargets) {
      ConfiguredTarget.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConfiguredTargetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConfiguredTargetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configuredTargets.push(ConfiguredTarget.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConfiguredTargetsResponse {
    return {
      configuredTargets: globalThis.Array.isArray(object?.configuredTargets)
        ? object.configuredTargets.map((e: any) => ConfiguredTarget.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConfiguredTargetsResponse): unknown {
    const obj: any = {};
    if (message.configuredTargets?.length) {
      obj.configuredTargets = message.configuredTargets.map((e) => ConfiguredTarget.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConfiguredTargetsResponse>): ListConfiguredTargetsResponse {
    return ListConfiguredTargetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConfiguredTargetsResponse>): ListConfiguredTargetsResponse {
    const message = createBaseListConfiguredTargetsResponse();
    message.configuredTargets = object.configuredTargets?.map((e) => ConfiguredTarget.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchConfiguredTargetsRequest(): SearchConfiguredTargetsRequest {
  return {
    parent: "",
    pageSize: 0,
    pageToken: undefined,
    offset: undefined,
    query: "",
    projectId: "",
    exactMatch: false,
  };
}

export const SearchConfiguredTargetsRequest: MessageFns<SearchConfiguredTargetsRequest> = {
  encode(message: SearchConfiguredTargetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.query !== "") {
      writer.uint32(42).string(message.query);
    }
    if (message.projectId !== "") {
      writer.uint32(50).string(message.projectId);
    }
    if (message.exactMatch !== false) {
      writer.uint32(56).bool(message.exactMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConfiguredTargetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConfiguredTargetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exactMatch = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConfiguredTargetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      exactMatch: isSet(object.exactMatch) ? globalThis.Boolean(object.exactMatch) : false,
    };
  },

  toJSON(message: SearchConfiguredTargetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.exactMatch !== false) {
      obj.exactMatch = message.exactMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchConfiguredTargetsRequest>): SearchConfiguredTargetsRequest {
    return SearchConfiguredTargetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchConfiguredTargetsRequest>): SearchConfiguredTargetsRequest {
    const message = createBaseSearchConfiguredTargetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.query = object.query ?? "";
    message.projectId = object.projectId ?? "";
    message.exactMatch = object.exactMatch ?? false;
    return message;
  },
};

function createBaseSearchConfiguredTargetsResponse(): SearchConfiguredTargetsResponse {
  return { configuredTargets: [], nextPageToken: "" };
}

export const SearchConfiguredTargetsResponse: MessageFns<SearchConfiguredTargetsResponse> = {
  encode(message: SearchConfiguredTargetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configuredTargets) {
      ConfiguredTarget.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConfiguredTargetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConfiguredTargetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configuredTargets.push(ConfiguredTarget.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConfiguredTargetsResponse {
    return {
      configuredTargets: globalThis.Array.isArray(object?.configuredTargets)
        ? object.configuredTargets.map((e: any) => ConfiguredTarget.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchConfiguredTargetsResponse): unknown {
    const obj: any = {};
    if (message.configuredTargets?.length) {
      obj.configuredTargets = message.configuredTargets.map((e) => ConfiguredTarget.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchConfiguredTargetsResponse>): SearchConfiguredTargetsResponse {
    return SearchConfiguredTargetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchConfiguredTargetsResponse>): SearchConfiguredTargetsResponse {
    const message = createBaseSearchConfiguredTargetsResponse();
    message.configuredTargets = object.configuredTargets?.map((e) => ConfiguredTarget.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetActionRequest(): GetActionRequest {
  return { name: "" };
}

export const GetActionRequest: MessageFns<GetActionRequest> = {
  encode(message: GetActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetActionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActionRequest>): GetActionRequest {
    return GetActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActionRequest>): GetActionRequest {
    const message = createBaseGetActionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListActionsRequest(): ListActionsRequest {
  return { parent: "", pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const ListActionsRequest: MessageFns<ListActionsRequest> = {
  encode(message: ListActionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListActionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListActionsRequest>): ListActionsRequest {
    return ListActionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActionsRequest>): ListActionsRequest {
    const message = createBaseListActionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListActionsResponse(): ListActionsResponse {
  return { actions: [], nextPageToken: "" };
}

export const ListActionsResponse: MessageFns<ListActionsResponse> = {
  encode(message: ListActionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActionsResponse {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListActionsResponse): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListActionsResponse>): ListActionsResponse {
    return ListActionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListActionsResponse>): ListActionsResponse {
    const message = createBaseListActionsResponse();
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchListActionsRequest(): BatchListActionsRequest {
  return { parent: "", configuredTargets: [], pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const BatchListActionsRequest: MessageFns<BatchListActionsRequest> = {
  encode(message: BatchListActionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.configuredTargets) {
      writer.uint32(18).string(v!);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(40).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(50).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchListActionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchListActionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configuredTargets.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchListActionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      configuredTargets: globalThis.Array.isArray(object?.configuredTargets)
        ? object.configuredTargets.map((e: any) => globalThis.String(e))
        : [],
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: BatchListActionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.configuredTargets?.length) {
      obj.configuredTargets = message.configuredTargets;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchListActionsRequest>): BatchListActionsRequest {
    return BatchListActionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchListActionsRequest>): BatchListActionsRequest {
    const message = createBaseBatchListActionsRequest();
    message.parent = object.parent ?? "";
    message.configuredTargets = object.configuredTargets?.map((e) => e) || [];
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseBatchListActionsResponse(): BatchListActionsResponse {
  return { actions: [], nextPageToken: "", notFound: [] };
}

export const BatchListActionsResponse: MessageFns<BatchListActionsResponse> = {
  encode(message: BatchListActionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.notFound) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchListActionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchListActionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notFound.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchListActionsResponse {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      notFound: globalThis.Array.isArray(object?.notFound) ? object.notFound.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchListActionsResponse): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.notFound?.length) {
      obj.notFound = message.notFound;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchListActionsResponse>): BatchListActionsResponse {
    return BatchListActionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchListActionsResponse>): BatchListActionsResponse {
    const message = createBaseBatchListActionsResponse();
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.notFound = object.notFound?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetFileSetRequest(): GetFileSetRequest {
  return { name: "" };
}

export const GetFileSetRequest: MessageFns<GetFileSetRequest> = {
  encode(message: GetFileSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFileSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFileSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFileSetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFileSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFileSetRequest>): GetFileSetRequest {
    return GetFileSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFileSetRequest>): GetFileSetRequest {
    const message = createBaseGetFileSetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListFileSetsRequest(): ListFileSetsRequest {
  return { parent: "", pageSize: 0, pageToken: undefined, offset: undefined, filter: "" };
}

export const ListFileSetsRequest: MessageFns<ListFileSetsRequest> = {
  encode(message: ListFileSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFileSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFileSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFileSetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListFileSetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFileSetsRequest>): ListFileSetsRequest {
    return ListFileSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFileSetsRequest>): ListFileSetsRequest {
    const message = createBaseListFileSetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListFileSetsResponse(): ListFileSetsResponse {
  return { fileSets: [], nextPageToken: "" };
}

export const ListFileSetsResponse: MessageFns<ListFileSetsResponse> = {
  encode(message: ListFileSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileSets) {
      FileSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFileSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFileSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileSets.push(FileSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFileSetsResponse {
    return {
      fileSets: globalThis.Array.isArray(object?.fileSets) ? object.fileSets.map((e: any) => FileSet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFileSetsResponse): unknown {
    const obj: any = {};
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets.map((e) => FileSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFileSetsResponse>): ListFileSetsResponse {
    return ListFileSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFileSetsResponse>): ListFileSetsResponse {
    const message = createBaseListFileSetsResponse();
    message.fileSets = object.fileSets?.map((e) => FileSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseTraverseFileSetsRequest(): TraverseFileSetsRequest {
  return { name: "", pageSize: 0, pageToken: undefined, offset: undefined };
}

export const TraverseFileSetsRequest: MessageFns<TraverseFileSetsRequest> = {
  encode(message: TraverseFileSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int64(message.offset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraverseFileSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraverseFileSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraverseFileSetsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : undefined,
    };
  },

  toJSON(message: TraverseFileSetsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== undefined) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TraverseFileSetsRequest>): TraverseFileSetsRequest {
    return TraverseFileSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TraverseFileSetsRequest>): TraverseFileSetsRequest {
    const message = createBaseTraverseFileSetsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : undefined;
    return message;
  },
};

function createBaseTraverseFileSetsResponse(): TraverseFileSetsResponse {
  return { fileSets: [], nextPageToken: "" };
}

export const TraverseFileSetsResponse: MessageFns<TraverseFileSetsResponse> = {
  encode(message: TraverseFileSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileSets) {
      FileSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraverseFileSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraverseFileSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileSets.push(FileSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraverseFileSetsResponse {
    return {
      fileSets: globalThis.Array.isArray(object?.fileSets) ? object.fileSets.map((e: any) => FileSet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: TraverseFileSetsResponse): unknown {
    const obj: any = {};
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets.map((e) => FileSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<TraverseFileSetsResponse>): TraverseFileSetsResponse {
    return TraverseFileSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TraverseFileSetsResponse>): TraverseFileSetsResponse {
    const message = createBaseTraverseFileSetsResponse();
    message.fileSets = object.fileSets?.map((e) => FileSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * This is the interface used to download information from the ResultStore
 * database.
 *
 * Clients are encourage to use ExportInvocation for most traffic.
 *
 * Most APIs require setting a response FieldMask via the 'fields' URL query
 * parameter or the X-Goog-FieldMask HTTP/gRPC header.
 */
export type ResultStoreDownloadDefinition = typeof ResultStoreDownloadDefinition;
export const ResultStoreDownloadDefinition = {
  name: "ResultStoreDownload",
  fullName: "google.devtools.resultstore.v2.ResultStoreDownload",
  methods: {
    /**
     * Exports the invocation with the given name and its child resources.
     *
     * The order in which resources are returned is defined as follows,
     * invocation; download_metadata; configurations; targets interleaving
     * configured_targets and actions; file_sets.
     *
     * - Invocation
     * - DownloadMetadata
     * - Configurations
     * - Targets
     *   └─ ConfiguredTargets
     *      └─Actions
     * - FileSets
     *
     * All child resources will be returned before the next parent
     * resource is returned. For example, all actions under a configured_target
     * will be returned before the next configured_target is returned.
     * The order in which results within a given resource type are returned is
     * undefined, but stable.
     *
     * An error will be reported in the following cases:
     * - If the invocation is not found.
     * - If the given invocation name is badly formatted.
     * - If no field mask was given.
     */
    exportInvocation: {
      name: "ExportInvocation",
      requestType: ExportInvocationRequest,
      requestStream: false,
      responseType: ExportInvocationResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the invocation with the given name.
     *
     * An error will be reported in the following cases:
     * - If the invocation is not found.
     * - If the given invocation name is badly formatted.
     * - If no field mask was given.
     */
    getInvocation: {
      name: "GetInvocation",
      requestType: GetInvocationRequest,
      requestStream: false,
      responseType: Invocation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              26,
              18,
              24,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for invocations matching the given query parameters. Results will
     * be ordered by timing.start_time with most recent first, but total ordering
     * of results is not guaranteed when difference in timestamps is very small.
     * Results may be stale. Results may be omitted.
     *
     * An error will be reported in the following cases:
     * - If a query string is not provided
     * - If no field mask was given.
     */
    searchInvocations: {
      name: "SearchInvocations",
      requestType: SearchInvocationsRequest,
      requestStream: false,
      responseType: SearchInvocationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              18,
              22,
              47,
              118,
              50,
              47,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the metadata for an invocation with the given name.
     *
     * An error will be reported in the following cases:
     * - If the invocation is not found.
     * - If the given invocation name is badly formatted.
     */
    getInvocationDownloadMetadata: {
      name: "GetInvocationDownloadMetadata",
      requestType: GetInvocationDownloadMetadataRequest,
      requestStream: false,
      responseType: DownloadMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              111,
              119,
              110,
              108,
              111,
              97,
              100,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the configuration with the given name.
     *
     * An error will be reported in the following cases:
     * - If the configuration or its parent invocation is not found.
     * - If the given configuration name is badly formatted.
     * - If no field mask was given.
     */
    getConfiguration: {
      name: "GetConfiguration",
      requestType: GetConfigurationRequest,
      requestStream: false,
      responseType: Configuration,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves all configurations for a parent invocation.
     * This might be limited by user or server,
     * in which case a continuation token is provided.
     * The order in which results are returned is undefined, but stable.
     *
     * An error will be reported in the following cases:
     * - If the parent invocation is not found.
     * - If the given parent invocation name is badly formatted.
     * - If no field mask was given.
     */
    listConfigurations: {
      name: "ListConfigurations",
      requestType: ListConfigurationsRequest,
      requestStream: false,
      responseType: ListConfigurationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the target with the given name.
     *
     * An error will be reported in the following cases:
     * - If the target or its parent invocation is not found.
     * - If the given target name is badly formatted.
     * - If no field mask was given.
     */
    getTarget: {
      name: "GetTarget",
      requestType: GetTargetRequest,
      requestStream: false,
      responseType: Target,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves all targets for a parent invocation.  This might be limited by
     * user or server, in which case a continuation token is provided.
     * The order in which results are returned is undefined, but stable.
     *
     * An error will be reported in the following cases:
     * - If the parent is not found.
     * - If the given parent name is badly formatted.
     * - If no field mask was given.
     */
    listTargets: {
      name: "ListTargets",
      requestType: ListTargetsRequest,
      requestStream: false,
      responseType: ListTargetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the configured target with the given name.
     *
     * An error will be reported in the following cases:
     * - If the configured target is not found.
     * - If the given name is badly formatted.
     * - If no field mask was given.
     */
    getConfiguredTarget: {
      name: "GetConfiguredTarget",
      requestType: GetConfiguredTargetRequest,
      requestStream: false,
      responseType: ConfiguredTarget,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves all configured targets for a parent invocation/target.
     * This might be limited by user or server, in which case a continuation
     * token is provided. Supports '-' for targetId meaning all targets.
     * The order in which results are returned is undefined, but stable and
     * consistent with ListTargets and ListConfigurations.
     *
     * An error will be reported in the following cases:
     * - If the parent is not found.
     * - If the given parent name is badly formatted.
     * - If no field mask was given.
     */
    listConfiguredTargets: {
      name: "ListConfiguredTargets",
      requestType: ListConfiguredTargetsRequest,
      requestStream: false,
      responseType: ListConfiguredTargetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for ConfiguredTargets matching the given query parameters. Results
     * will be ordered by timing.start_time with most recent first, but total
     * ordering of results is not guaranteed when difference in timestamps is
     * very small. Results may be stale. Results may be omitted.
     *
     * Field masks are supported for only these fields and their subfields:
     * - configured_targets.name
     * - configured_targets.id
     * - configured_targets.status_attributes
     * - configured_targets.timing
     * - next_page_token
     *
     * An error will be reported in the following cases:
     * - If a query string is not provided
     * - If no field mask was given.
     */
    searchConfiguredTargets: {
      name: "SearchConfiguredTargets",
      requestType: SearchConfiguredTargetsRequest,
      requestStream: false,
      responseType: SearchConfiguredTargetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the action with the given name.
     *
     * An error will be reported in the following cases:
     * - If the action is not found.
     * - If the given name is badly formatted.
     * - If no field mask was given.
     */
    getAction: {
      name: "GetAction",
      requestType: GetActionRequest,
      requestStream: false,
      responseType: Action,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves all actions for a parent invocation/target/configuration.
     * This might be limited by user or server, in which case a continuation
     * token is provided. Supports '-' for configurationId to mean all
     * actions for all configurations for a target, or '-' for targetId and
     * configurationId to mean all actions for all configurations and all targets.
     * Does not support targetId '-' with a specified configuration.
     * The order in which results are returned is undefined, but stable and
     * consistent with ListConfiguredTargets.
     *
     * An error will be reported in the following cases:
     * - If the parent is not found.
     * - If the given parent name is badly formatted.
     * - If no field mask was given.
     */
    listActions: {
      name: "ListActions",
      requestType: ListActionsRequest,
      requestStream: false,
      responseType: ListActionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a list of actions for a parent invocation or multiple parents
     * target/configuration. This might be limited by user or server, in which
     * case a continuation token is provided. The order in which results are
     * returned is undefined, but stable and consistent with
     * ListConfiguredTargets.
     *
     * An error will be reported in the following cases:
     * - If the given parent name is badly formatted.
     * - If no field mask was given.
     */
    batchListActions: {
      name: "BatchListActions",
      requestType: BatchListActionsRequest,
      requestStream: false,
      responseType: BatchListActionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              76,
              105,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the file set with the given name.
     *
     * An error will be reported in the following cases:
     * - If the file set or its parent invocation is not found.
     * - If the given file set name is badly formatted.
     * - If no field mask was given.
     */
    getFileSet: {
      name: "GetFileSet",
      requestType: GetFileSetRequest,
      requestStream: false,
      responseType: FileSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              37,
              18,
              35,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves all file sets for a parent invocation.
     * This might be limited by user or server,
     * in which case a continuation token is provided.
     * The order in which results are returned is undefined, but stable.
     *
     * An error will be reported in the following cases:
     * - If the parent invocation is not found.
     * - If the given parent invocation name is badly formatted.
     * - If no field mask was given.
     */
    listFileSets: {
      name: "ListFileSets",
      requestType: ListFileSetsRequest,
      requestStream: false,
      responseType: ListFileSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              37,
              18,
              35,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the transitive closure of FileSets. This might be limited by user
     * or server, in which case a continuation token is provided.
     * The order in which results are returned is undefined, and unstable.
     *
     * An error will be reported in the following cases:
     * - If page_token is too large to continue the calculation.
     * - If the resource is not found.
     * - If the given resource name is badly formatted.
     * - If no field mask was given.
     */
    traverseFileSets: {
      name: "TraverseFileSets",
      requestType: TraverseFileSetsRequest,
      requestStream: false,
      responseType: TraverseFileSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              139,
              1,
              90,
              83,
              18,
              81,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              118,
              101,
              114,
              115,
              101,
              70,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
              18,
              52,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              118,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              118,
              101,
              114,
              115,
              101,
              70,
              105,
              108,
              101,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ResultStoreDownloadServiceImplementation<CallContextExt = {}> {
  /**
   * Exports the invocation with the given name and its child resources.
   *
   * The order in which resources are returned is defined as follows,
   * invocation; download_metadata; configurations; targets interleaving
   * configured_targets and actions; file_sets.
   *
   * - Invocation
   * - DownloadMetadata
   * - Configurations
   * - Targets
   *   └─ ConfiguredTargets
   *      └─Actions
   * - FileSets
   *
   * All child resources will be returned before the next parent
   * resource is returned. For example, all actions under a configured_target
   * will be returned before the next configured_target is returned.
   * The order in which results within a given resource type are returned is
   * undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   * - If no field mask was given.
   */
  exportInvocation(
    request: ExportInvocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExportInvocationResponse>>;
  /**
   * Retrieves the invocation with the given name.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   * - If no field mask was given.
   */
  getInvocation(request: GetInvocationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Invocation>>;
  /**
   * Searches for invocations matching the given query parameters. Results will
   * be ordered by timing.start_time with most recent first, but total ordering
   * of results is not guaranteed when difference in timestamps is very small.
   * Results may be stale. Results may be omitted.
   *
   * An error will be reported in the following cases:
   * - If a query string is not provided
   * - If no field mask was given.
   */
  searchInvocations(
    request: SearchInvocationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchInvocationsResponse>>;
  /**
   * Retrieves the metadata for an invocation with the given name.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   */
  getInvocationDownloadMetadata(
    request: GetInvocationDownloadMetadataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DownloadMetadata>>;
  /**
   * Retrieves the configuration with the given name.
   *
   * An error will be reported in the following cases:
   * - If the configuration or its parent invocation is not found.
   * - If the given configuration name is badly formatted.
   * - If no field mask was given.
   */
  getConfiguration(
    request: GetConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Configuration>>;
  /**
   * Retrieves all configurations for a parent invocation.
   * This might be limited by user or server,
   * in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent invocation is not found.
   * - If the given parent invocation name is badly formatted.
   * - If no field mask was given.
   */
  listConfigurations(
    request: ListConfigurationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConfigurationsResponse>>;
  /**
   * Retrieves the target with the given name.
   *
   * An error will be reported in the following cases:
   * - If the target or its parent invocation is not found.
   * - If the given target name is badly formatted.
   * - If no field mask was given.
   */
  getTarget(request: GetTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Target>>;
  /**
   * Retrieves all targets for a parent invocation.  This might be limited by
   * user or server, in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listTargets(
    request: ListTargetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTargetsResponse>>;
  /**
   * Retrieves the configured target with the given name.
   *
   * An error will be reported in the following cases:
   * - If the configured target is not found.
   * - If the given name is badly formatted.
   * - If no field mask was given.
   */
  getConfiguredTarget(
    request: GetConfiguredTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConfiguredTarget>>;
  /**
   * Retrieves all configured targets for a parent invocation/target.
   * This might be limited by user or server, in which case a continuation
   * token is provided. Supports '-' for targetId meaning all targets.
   * The order in which results are returned is undefined, but stable and
   * consistent with ListTargets and ListConfigurations.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listConfiguredTargets(
    request: ListConfiguredTargetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConfiguredTargetsResponse>>;
  /**
   * Searches for ConfiguredTargets matching the given query parameters. Results
   * will be ordered by timing.start_time with most recent first, but total
   * ordering of results is not guaranteed when difference in timestamps is
   * very small. Results may be stale. Results may be omitted.
   *
   * Field masks are supported for only these fields and their subfields:
   * - configured_targets.name
   * - configured_targets.id
   * - configured_targets.status_attributes
   * - configured_targets.timing
   * - next_page_token
   *
   * An error will be reported in the following cases:
   * - If a query string is not provided
   * - If no field mask was given.
   */
  searchConfiguredTargets(
    request: SearchConfiguredTargetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfiguredTargetsResponse>>;
  /**
   * Retrieves the action with the given name.
   *
   * An error will be reported in the following cases:
   * - If the action is not found.
   * - If the given name is badly formatted.
   * - If no field mask was given.
   */
  getAction(request: GetActionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Action>>;
  /**
   * Retrieves all actions for a parent invocation/target/configuration.
   * This might be limited by user or server, in which case a continuation
   * token is provided. Supports '-' for configurationId to mean all
   * actions for all configurations for a target, or '-' for targetId and
   * configurationId to mean all actions for all configurations and all targets.
   * Does not support targetId '-' with a specified configuration.
   * The order in which results are returned is undefined, but stable and
   * consistent with ListConfiguredTargets.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listActions(
    request: ListActionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListActionsResponse>>;
  /**
   * Retrieves a list of actions for a parent invocation or multiple parents
   * target/configuration. This might be limited by user or server, in which
   * case a continuation token is provided. The order in which results are
   * returned is undefined, but stable and consistent with
   * ListConfiguredTargets.
   *
   * An error will be reported in the following cases:
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  batchListActions(
    request: BatchListActionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchListActionsResponse>>;
  /**
   * Retrieves the file set with the given name.
   *
   * An error will be reported in the following cases:
   * - If the file set or its parent invocation is not found.
   * - If the given file set name is badly formatted.
   * - If no field mask was given.
   */
  getFileSet(request: GetFileSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<FileSet>>;
  /**
   * Retrieves all file sets for a parent invocation.
   * This might be limited by user or server,
   * in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent invocation is not found.
   * - If the given parent invocation name is badly formatted.
   * - If no field mask was given.
   */
  listFileSets(
    request: ListFileSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFileSetsResponse>>;
  /**
   * Returns the transitive closure of FileSets. This might be limited by user
   * or server, in which case a continuation token is provided.
   * The order in which results are returned is undefined, and unstable.
   *
   * An error will be reported in the following cases:
   * - If page_token is too large to continue the calculation.
   * - If the resource is not found.
   * - If the given resource name is badly formatted.
   * - If no field mask was given.
   */
  traverseFileSets(
    request: TraverseFileSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TraverseFileSetsResponse>>;
}

export interface ResultStoreDownloadClient<CallOptionsExt = {}> {
  /**
   * Exports the invocation with the given name and its child resources.
   *
   * The order in which resources are returned is defined as follows,
   * invocation; download_metadata; configurations; targets interleaving
   * configured_targets and actions; file_sets.
   *
   * - Invocation
   * - DownloadMetadata
   * - Configurations
   * - Targets
   *   └─ ConfiguredTargets
   *      └─Actions
   * - FileSets
   *
   * All child resources will be returned before the next parent
   * resource is returned. For example, all actions under a configured_target
   * will be returned before the next configured_target is returned.
   * The order in which results within a given resource type are returned is
   * undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   * - If no field mask was given.
   */
  exportInvocation(
    request: DeepPartial<ExportInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExportInvocationResponse>;
  /**
   * Retrieves the invocation with the given name.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   * - If no field mask was given.
   */
  getInvocation(
    request: DeepPartial<GetInvocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Invocation>;
  /**
   * Searches for invocations matching the given query parameters. Results will
   * be ordered by timing.start_time with most recent first, but total ordering
   * of results is not guaranteed when difference in timestamps is very small.
   * Results may be stale. Results may be omitted.
   *
   * An error will be reported in the following cases:
   * - If a query string is not provided
   * - If no field mask was given.
   */
  searchInvocations(
    request: DeepPartial<SearchInvocationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchInvocationsResponse>;
  /**
   * Retrieves the metadata for an invocation with the given name.
   *
   * An error will be reported in the following cases:
   * - If the invocation is not found.
   * - If the given invocation name is badly formatted.
   */
  getInvocationDownloadMetadata(
    request: DeepPartial<GetInvocationDownloadMetadataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DownloadMetadata>;
  /**
   * Retrieves the configuration with the given name.
   *
   * An error will be reported in the following cases:
   * - If the configuration or its parent invocation is not found.
   * - If the given configuration name is badly formatted.
   * - If no field mask was given.
   */
  getConfiguration(
    request: DeepPartial<GetConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Configuration>;
  /**
   * Retrieves all configurations for a parent invocation.
   * This might be limited by user or server,
   * in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent invocation is not found.
   * - If the given parent invocation name is badly formatted.
   * - If no field mask was given.
   */
  listConfigurations(
    request: DeepPartial<ListConfigurationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConfigurationsResponse>;
  /**
   * Retrieves the target with the given name.
   *
   * An error will be reported in the following cases:
   * - If the target or its parent invocation is not found.
   * - If the given target name is badly formatted.
   * - If no field mask was given.
   */
  getTarget(request: DeepPartial<GetTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Target>;
  /**
   * Retrieves all targets for a parent invocation.  This might be limited by
   * user or server, in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listTargets(
    request: DeepPartial<ListTargetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTargetsResponse>;
  /**
   * Retrieves the configured target with the given name.
   *
   * An error will be reported in the following cases:
   * - If the configured target is not found.
   * - If the given name is badly formatted.
   * - If no field mask was given.
   */
  getConfiguredTarget(
    request: DeepPartial<GetConfiguredTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConfiguredTarget>;
  /**
   * Retrieves all configured targets for a parent invocation/target.
   * This might be limited by user or server, in which case a continuation
   * token is provided. Supports '-' for targetId meaning all targets.
   * The order in which results are returned is undefined, but stable and
   * consistent with ListTargets and ListConfigurations.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listConfiguredTargets(
    request: DeepPartial<ListConfiguredTargetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConfiguredTargetsResponse>;
  /**
   * Searches for ConfiguredTargets matching the given query parameters. Results
   * will be ordered by timing.start_time with most recent first, but total
   * ordering of results is not guaranteed when difference in timestamps is
   * very small. Results may be stale. Results may be omitted.
   *
   * Field masks are supported for only these fields and their subfields:
   * - configured_targets.name
   * - configured_targets.id
   * - configured_targets.status_attributes
   * - configured_targets.timing
   * - next_page_token
   *
   * An error will be reported in the following cases:
   * - If a query string is not provided
   * - If no field mask was given.
   */
  searchConfiguredTargets(
    request: DeepPartial<SearchConfiguredTargetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfiguredTargetsResponse>;
  /**
   * Retrieves the action with the given name.
   *
   * An error will be reported in the following cases:
   * - If the action is not found.
   * - If the given name is badly formatted.
   * - If no field mask was given.
   */
  getAction(request: DeepPartial<GetActionRequest>, options?: CallOptions & CallOptionsExt): Promise<Action>;
  /**
   * Retrieves all actions for a parent invocation/target/configuration.
   * This might be limited by user or server, in which case a continuation
   * token is provided. Supports '-' for configurationId to mean all
   * actions for all configurations for a target, or '-' for targetId and
   * configurationId to mean all actions for all configurations and all targets.
   * Does not support targetId '-' with a specified configuration.
   * The order in which results are returned is undefined, but stable and
   * consistent with ListConfiguredTargets.
   *
   * An error will be reported in the following cases:
   * - If the parent is not found.
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  listActions(
    request: DeepPartial<ListActionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListActionsResponse>;
  /**
   * Retrieves a list of actions for a parent invocation or multiple parents
   * target/configuration. This might be limited by user or server, in which
   * case a continuation token is provided. The order in which results are
   * returned is undefined, but stable and consistent with
   * ListConfiguredTargets.
   *
   * An error will be reported in the following cases:
   * - If the given parent name is badly formatted.
   * - If no field mask was given.
   */
  batchListActions(
    request: DeepPartial<BatchListActionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchListActionsResponse>;
  /**
   * Retrieves the file set with the given name.
   *
   * An error will be reported in the following cases:
   * - If the file set or its parent invocation is not found.
   * - If the given file set name is badly formatted.
   * - If no field mask was given.
   */
  getFileSet(request: DeepPartial<GetFileSetRequest>, options?: CallOptions & CallOptionsExt): Promise<FileSet>;
  /**
   * Retrieves all file sets for a parent invocation.
   * This might be limited by user or server,
   * in which case a continuation token is provided.
   * The order in which results are returned is undefined, but stable.
   *
   * An error will be reported in the following cases:
   * - If the parent invocation is not found.
   * - If the given parent invocation name is badly formatted.
   * - If no field mask was given.
   */
  listFileSets(
    request: DeepPartial<ListFileSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFileSetsResponse>;
  /**
   * Returns the transitive closure of FileSets. This might be limited by user
   * or server, in which case a continuation token is provided.
   * The order in which results are returned is undefined, and unstable.
   *
   * An error will be reported in the following cases:
   * - If page_token is too large to continue the calculation.
   * - If the resource is not found.
   * - If the given resource name is badly formatted.
   * - If no field mask was given.
   */
  traverseFileSets(
    request: DeepPartial<TraverseFileSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TraverseFileSetsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
