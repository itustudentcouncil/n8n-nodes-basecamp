// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/remoteworkers/v1test2/command.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../protobuf/any.js";
import { Duration } from "../../../protobuf/duration.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.devtools.remoteworkers.v1test2";

/**
 * Describes a shell-style task to execute, suitable for providing as the Bots
 * interface's `Lease.payload` field.
 */
export interface CommandTask {
  /** The inputs to the task. */
  inputs:
    | CommandTask_Inputs
    | undefined;
  /** The expected outputs from the task. */
  expectedOutputs:
    | CommandTask_Outputs
    | undefined;
  /** The timeouts of this task. */
  timeouts: CommandTask_Timeouts | undefined;
}

/** Describes the inputs to a shell-style task. */
export interface CommandTask_Inputs {
  /**
   * The command itself to run (e.g., argv).
   *
   * This field should be passed directly to the underlying operating system,
   * and so it must be sensible to that operating system. For example, on
   * Windows, the first argument might be "C:\Windows\System32\ping.exe" -
   * that is, using drive letters and backslashes. A command for a *nix
   * system, on the other hand, would use forward slashes.
   *
   * All other fields in the RWAPI must consistently use forward slashes,
   * since those fields may be interpretted by both the service and the bot.
   */
  arguments: string[];
  /**
   * The input filesystem to be set up prior to the task beginning. The
   * contents should be a repeated set of FileMetadata messages though other
   * formats are allowed if better for the implementation (eg, a LUCI-style
   * .isolated file).
   *
   * This field is repeated since implementations might want to cache the
   * metadata, in which case it may be useful to break up portions of the
   * filesystem that change frequently (eg, specific input files) from those
   * that don't (eg, standard header files).
   */
  files: Digest[];
  /**
   * Inline contents for blobs expected to be needed by the bot to execute the
   * task. For example, contents of entries in `files` or blobs that are
   * indirectly referenced by an entry there.
   *
   * The bot should check against this list before downloading required task
   * inputs to reduce the number of communications between itself and the
   * remote CAS server.
   */
  inlineBlobs: Blob[];
  /** All environment variables required by the task. */
  environmentVariables: CommandTask_Inputs_EnvironmentVariable[];
  /**
   * Directory from which a command is executed. It is a relative directory
   * with respect to the bot's working directory (i.e., "./"). If it is
   * non-empty, then it must exist under "./". Otherwise, "./" will be used.
   */
  workingDirectory: string;
}

/** An environment variable required by this task. */
export interface CommandTask_Inputs_EnvironmentVariable {
  /** The envvar name. */
  name: string;
  /** The envvar value. */
  value: string;
}

/** Describes the expected outputs of the command. */
export interface CommandTask_Outputs {
  /**
   * A list of expected files, relative to the execution root. All paths
   * MUST be delimited by forward slashes.
   */
  files: string[];
  /**
   * A list of expected directories, relative to the execution root. All paths
   * MUST be delimited by forward slashes.
   */
  directories: string[];
  /**
   * The destination to which any stdout should be sent. The method by which
   * the bot should send the stream contents to that destination is not
   * defined in this API. As examples, the destination could be a file
   * referenced in the `files` field in this message, or it could be a URI
   * that must be written via the ByteStream API.
   */
  stdoutDestination: string;
  /**
   * The destination to which any stderr should be sent. The method by which
   * the bot should send the stream contents to that destination is not
   * defined in this API. As examples, the destination could be a file
   * referenced in the `files` field in this message, or it could be a URI
   * that must be written via the ByteStream API.
   */
  stderrDestination: string;
}

/** Describes the timeouts associated with this task. */
export interface CommandTask_Timeouts {
  /**
   * This specifies the maximum time that the task can run, excluding the
   * time required to download inputs or upload outputs. That is, the worker
   * will terminate the task if it runs longer than this.
   */
  execution:
    | Duration
    | undefined;
  /**
   * This specifies the maximum amount of time the task can be idle - that is,
   * go without generating some output in either stdout or stderr. If the
   * process is silent for more than the specified time, the worker will
   * terminate the task.
   */
  idle:
    | Duration
    | undefined;
  /**
   * If the execution or IO timeouts are exceeded, the worker will try to
   * gracefully terminate the task and return any existing logs. However,
   * tasks may be hard-frozen in which case this process will fail. This
   * timeout specifies how long to wait for a terminated task to shut down
   * gracefully (e.g. via SIGTERM) before we bring down the hammer (e.g.
   * SIGKILL on *nix, CTRL_BREAK_EVENT on Windows).
   */
  shutdown: Duration | undefined;
}

/**
 * DEPRECATED - use CommandResult instead.
 * Describes the actual outputs from the task.
 */
export interface CommandOutputs {
  /**
   * exit_code is only fully reliable if the status' code is OK. If the task
   * exceeded its deadline or was cancelled, the process may still produce an
   * exit code as it is cancelled, and this will be populated, but a successful
   * (zero) is unlikely to be correct unless the status code is OK.
   */
  exitCode: number;
  /**
   * The output files. The blob referenced by the digest should contain
   * one of the following (implementation-dependent):
   *    * A marshalled DirectoryMetadata of the returned filesystem
   *    * A LUCI-style .isolated file
   */
  outputs: Digest | undefined;
}

/**
 * DEPRECATED - use CommandResult instead.
 * Can be used as part of CompleteRequest.metadata, or are part of a more
 * sophisticated message.
 */
export interface CommandOverhead {
  /**
   * The elapsed time between calling Accept and Complete. The server will also
   * have its own idea of what this should be, but this excludes the overhead of
   * the RPCs and the bot response time.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The amount of time *not* spent executing the command (ie
   * uploading/downloading files).
   */
  overhead: Duration | undefined;
}

/**
 * All information about the execution of a command, suitable for providing as
 * the Bots interface's `Lease.result` field.
 */
export interface CommandResult {
  /**
   * An overall status for the command. For example, if the command timed out,
   * this might have a code of DEADLINE_EXCEEDED; if it was killed by the OS for
   * memory exhaustion, it might have a code of RESOURCE_EXHAUSTED.
   */
  status:
    | Status
    | undefined;
  /**
   * The exit code of the process. An exit code of "0" should only be trusted if
   * `status` has a code of OK (otherwise it may simply be unset).
   */
  exitCode: number;
  /**
   * The output files. The blob referenced by the digest should contain
   * one of the following (implementation-dependent):
   *    * A marshalled DirectoryMetadata of the returned filesystem
   *    * A LUCI-style .isolated file
   */
  outputs:
    | Digest
    | undefined;
  /**
   * The elapsed time between calling Accept and Complete. The server will also
   * have its own idea of what this should be, but this excludes the overhead of
   * the RPCs and the bot response time.
   *
   * @deprecated
   */
  duration:
    | Duration
    | undefined;
  /**
   * The amount of time *not* spent executing the command (ie
   * uploading/downloading files).
   *
   * @deprecated
   */
  overhead:
    | Duration
    | undefined;
  /**
   * Implementation-dependent metadata about the task. Both servers and bots
   * may define messages which can be encoded here; bots are free to provide
   * metadata in multiple formats, and servers are free to choose one or more
   * of the values to process and ignore others. In particular, it is *not*
   * considered an error for the bot to provide the server with a field that it
   * doesn't know about.
   */
  metadata: Any[];
}

/**
 * The metadata for a file. Similar to the equivalent message in the Remote
 * Execution API.
 */
export interface FileMetadata {
  /**
   * The path of this file. If this message is part of the
   * CommandOutputs.outputs fields, the path is relative to the execution root
   * and must correspond to an entry in CommandTask.outputs.files. If this
   * message is part of a Directory message, then the path is relative to the
   * root of that directory. All paths MUST be delimited by forward slashes.
   */
  path: string;
  /**
   * A pointer to the contents of the file. The method by which a client
   * retrieves the contents from a CAS system is not defined here.
   */
  digest:
    | Digest
    | undefined;
  /**
   * If the file is small enough, its contents may also or alternatively be
   * listed here.
   */
  contents: Buffer;
  /** Properties of the file */
  isExecutable: boolean;
}

/**
 * The metadata for a directory. Similar to the equivalent message in the Remote
 * Execution API.
 */
export interface DirectoryMetadata {
  /**
   * The path of the directory, as in
   * [FileMetadata.path][google.devtools.remoteworkers.v1test2.FileMetadata.path].
   */
  path: string;
  /**
   * A pointer to the contents of the directory, in the form of a marshalled
   * Directory message.
   */
  digest: Digest | undefined;
}

/**
 * The CommandTask and CommandResult messages assume the existence of a service
 * that can serve blobs of content, identified by a hash and size known as a
 * "digest." The method by which these blobs may be retrieved is not specified
 * here, but a model implementation is in the Remote Execution API's
 * "ContentAddressibleStorage" interface.
 *
 * In the context of the RWAPI, a Digest will virtually always refer to the
 * contents of a file or a directory. The latter is represented by the
 * byte-encoded Directory message.
 */
export interface Digest {
  /**
   * A string-encoded hash (eg "1a2b3c", not the byte array [0x1a, 0x2b, 0x3c])
   * using an implementation-defined hash algorithm (eg SHA-256).
   */
  hash: string;
  /**
   * The size of the contents. While this is not strictly required as part of an
   * identifier (after all, any given hash will have exactly one canonical
   * size), it's useful in almost all cases when one might want to send or
   * retrieve blobs of content and is included here for this reason.
   */
  sizeBytes: Long;
}

/** Describes a blob of binary content with its digest. */
export interface Blob {
  /** The digest of the blob. This should be verified by the receiver. */
  digest:
    | Digest
    | undefined;
  /** The contents of the blob. */
  contents: Buffer;
}

/**
 * The contents of a directory. Similar to the equivalent message in the Remote
 * Execution API.
 */
export interface Directory {
  /** The files in this directory */
  files: FileMetadata[];
  /** Any subdirectories */
  directories: DirectoryMetadata[];
}

function createBaseCommandTask(): CommandTask {
  return { inputs: undefined, expectedOutputs: undefined, timeouts: undefined };
}

export const CommandTask: MessageFns<CommandTask> = {
  encode(message: CommandTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== undefined) {
      CommandTask_Inputs.encode(message.inputs, writer.uint32(10).fork()).join();
    }
    if (message.expectedOutputs !== undefined) {
      CommandTask_Outputs.encode(message.expectedOutputs, writer.uint32(34).fork()).join();
    }
    if (message.timeouts !== undefined) {
      CommandTask_Timeouts.encode(message.timeouts, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs = CommandTask_Inputs.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expectedOutputs = CommandTask_Outputs.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeouts = CommandTask_Timeouts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandTask {
    return {
      inputs: isSet(object.inputs) ? CommandTask_Inputs.fromJSON(object.inputs) : undefined,
      expectedOutputs: isSet(object.expectedOutputs) ? CommandTask_Outputs.fromJSON(object.expectedOutputs) : undefined,
      timeouts: isSet(object.timeouts) ? CommandTask_Timeouts.fromJSON(object.timeouts) : undefined,
    };
  },

  toJSON(message: CommandTask): unknown {
    const obj: any = {};
    if (message.inputs !== undefined) {
      obj.inputs = CommandTask_Inputs.toJSON(message.inputs);
    }
    if (message.expectedOutputs !== undefined) {
      obj.expectedOutputs = CommandTask_Outputs.toJSON(message.expectedOutputs);
    }
    if (message.timeouts !== undefined) {
      obj.timeouts = CommandTask_Timeouts.toJSON(message.timeouts);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandTask>): CommandTask {
    return CommandTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandTask>): CommandTask {
    const message = createBaseCommandTask();
    message.inputs = (object.inputs !== undefined && object.inputs !== null)
      ? CommandTask_Inputs.fromPartial(object.inputs)
      : undefined;
    message.expectedOutputs = (object.expectedOutputs !== undefined && object.expectedOutputs !== null)
      ? CommandTask_Outputs.fromPartial(object.expectedOutputs)
      : undefined;
    message.timeouts = (object.timeouts !== undefined && object.timeouts !== null)
      ? CommandTask_Timeouts.fromPartial(object.timeouts)
      : undefined;
    return message;
  },
};

function createBaseCommandTask_Inputs(): CommandTask_Inputs {
  return { arguments: [], files: [], inlineBlobs: [], environmentVariables: [], workingDirectory: "" };
}

export const CommandTask_Inputs: MessageFns<CommandTask_Inputs> = {
  encode(message: CommandTask_Inputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arguments) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.files) {
      Digest.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.inlineBlobs) {
      Blob.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.environmentVariables) {
      CommandTask_Inputs_EnvironmentVariable.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.workingDirectory !== "") {
      writer.uint32(42).string(message.workingDirectory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandTask_Inputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandTask_Inputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.files.push(Digest.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inlineBlobs.push(Blob.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.environmentVariables.push(CommandTask_Inputs_EnvironmentVariable.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandTask_Inputs {
    return {
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => Digest.fromJSON(e)) : [],
      inlineBlobs: globalThis.Array.isArray(object?.inlineBlobs)
        ? object.inlineBlobs.map((e: any) => Blob.fromJSON(e))
        : [],
      environmentVariables: globalThis.Array.isArray(object?.environmentVariables)
        ? object.environmentVariables.map((e: any) => CommandTask_Inputs_EnvironmentVariable.fromJSON(e))
        : [],
      workingDirectory: isSet(object.workingDirectory) ? globalThis.String(object.workingDirectory) : "",
    };
  },

  toJSON(message: CommandTask_Inputs): unknown {
    const obj: any = {};
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => Digest.toJSON(e));
    }
    if (message.inlineBlobs?.length) {
      obj.inlineBlobs = message.inlineBlobs.map((e) => Blob.toJSON(e));
    }
    if (message.environmentVariables?.length) {
      obj.environmentVariables = message.environmentVariables.map((e) =>
        CommandTask_Inputs_EnvironmentVariable.toJSON(e)
      );
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandTask_Inputs>): CommandTask_Inputs {
    return CommandTask_Inputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandTask_Inputs>): CommandTask_Inputs {
    const message = createBaseCommandTask_Inputs();
    message.arguments = object.arguments?.map((e) => e) || [];
    message.files = object.files?.map((e) => Digest.fromPartial(e)) || [];
    message.inlineBlobs = object.inlineBlobs?.map((e) => Blob.fromPartial(e)) || [];
    message.environmentVariables =
      object.environmentVariables?.map((e) => CommandTask_Inputs_EnvironmentVariable.fromPartial(e)) || [];
    message.workingDirectory = object.workingDirectory ?? "";
    return message;
  },
};

function createBaseCommandTask_Inputs_EnvironmentVariable(): CommandTask_Inputs_EnvironmentVariable {
  return { name: "", value: "" };
}

export const CommandTask_Inputs_EnvironmentVariable: MessageFns<CommandTask_Inputs_EnvironmentVariable> = {
  encode(message: CommandTask_Inputs_EnvironmentVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandTask_Inputs_EnvironmentVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandTask_Inputs_EnvironmentVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandTask_Inputs_EnvironmentVariable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CommandTask_Inputs_EnvironmentVariable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandTask_Inputs_EnvironmentVariable>): CommandTask_Inputs_EnvironmentVariable {
    return CommandTask_Inputs_EnvironmentVariable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandTask_Inputs_EnvironmentVariable>): CommandTask_Inputs_EnvironmentVariable {
    const message = createBaseCommandTask_Inputs_EnvironmentVariable();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCommandTask_Outputs(): CommandTask_Outputs {
  return { files: [], directories: [], stdoutDestination: "", stderrDestination: "" };
}

export const CommandTask_Outputs: MessageFns<CommandTask_Outputs> = {
  encode(message: CommandTask_Outputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.directories) {
      writer.uint32(18).string(v!);
    }
    if (message.stdoutDestination !== "") {
      writer.uint32(26).string(message.stdoutDestination);
    }
    if (message.stderrDestination !== "") {
      writer.uint32(34).string(message.stderrDestination);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandTask_Outputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandTask_Outputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.files.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.directories.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stdoutDestination = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stderrDestination = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandTask_Outputs {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      directories: globalThis.Array.isArray(object?.directories)
        ? object.directories.map((e: any) => globalThis.String(e))
        : [],
      stdoutDestination: isSet(object.stdoutDestination) ? globalThis.String(object.stdoutDestination) : "",
      stderrDestination: isSet(object.stderrDestination) ? globalThis.String(object.stderrDestination) : "",
    };
  },

  toJSON(message: CommandTask_Outputs): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.directories?.length) {
      obj.directories = message.directories;
    }
    if (message.stdoutDestination !== "") {
      obj.stdoutDestination = message.stdoutDestination;
    }
    if (message.stderrDestination !== "") {
      obj.stderrDestination = message.stderrDestination;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandTask_Outputs>): CommandTask_Outputs {
    return CommandTask_Outputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandTask_Outputs>): CommandTask_Outputs {
    const message = createBaseCommandTask_Outputs();
    message.files = object.files?.map((e) => e) || [];
    message.directories = object.directories?.map((e) => e) || [];
    message.stdoutDestination = object.stdoutDestination ?? "";
    message.stderrDestination = object.stderrDestination ?? "";
    return message;
  },
};

function createBaseCommandTask_Timeouts(): CommandTask_Timeouts {
  return { execution: undefined, idle: undefined, shutdown: undefined };
}

export const CommandTask_Timeouts: MessageFns<CommandTask_Timeouts> = {
  encode(message: CommandTask_Timeouts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execution !== undefined) {
      Duration.encode(message.execution, writer.uint32(10).fork()).join();
    }
    if (message.idle !== undefined) {
      Duration.encode(message.idle, writer.uint32(18).fork()).join();
    }
    if (message.shutdown !== undefined) {
      Duration.encode(message.shutdown, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandTask_Timeouts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandTask_Timeouts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.execution = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.idle = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shutdown = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandTask_Timeouts {
    return {
      execution: isSet(object.execution) ? Duration.fromJSON(object.execution) : undefined,
      idle: isSet(object.idle) ? Duration.fromJSON(object.idle) : undefined,
      shutdown: isSet(object.shutdown) ? Duration.fromJSON(object.shutdown) : undefined,
    };
  },

  toJSON(message: CommandTask_Timeouts): unknown {
    const obj: any = {};
    if (message.execution !== undefined) {
      obj.execution = Duration.toJSON(message.execution);
    }
    if (message.idle !== undefined) {
      obj.idle = Duration.toJSON(message.idle);
    }
    if (message.shutdown !== undefined) {
      obj.shutdown = Duration.toJSON(message.shutdown);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandTask_Timeouts>): CommandTask_Timeouts {
    return CommandTask_Timeouts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandTask_Timeouts>): CommandTask_Timeouts {
    const message = createBaseCommandTask_Timeouts();
    message.execution = (object.execution !== undefined && object.execution !== null)
      ? Duration.fromPartial(object.execution)
      : undefined;
    message.idle = (object.idle !== undefined && object.idle !== null) ? Duration.fromPartial(object.idle) : undefined;
    message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
      ? Duration.fromPartial(object.shutdown)
      : undefined;
    return message;
  },
};

function createBaseCommandOutputs(): CommandOutputs {
  return { exitCode: 0, outputs: undefined };
}

export const CommandOutputs: MessageFns<CommandOutputs> = {
  encode(message: CommandOutputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.outputs !== undefined) {
      Digest.encode(message.outputs, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandOutputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandOutputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs = Digest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandOutputs {
    return {
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      outputs: isSet(object.outputs) ? Digest.fromJSON(object.outputs) : undefined,
    };
  },

  toJSON(message: CommandOutputs): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.outputs !== undefined) {
      obj.outputs = Digest.toJSON(message.outputs);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandOutputs>): CommandOutputs {
    return CommandOutputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandOutputs>): CommandOutputs {
    const message = createBaseCommandOutputs();
    message.exitCode = object.exitCode ?? 0;
    message.outputs = (object.outputs !== undefined && object.outputs !== null)
      ? Digest.fromPartial(object.outputs)
      : undefined;
    return message;
  },
};

function createBaseCommandOverhead(): CommandOverhead {
  return { duration: undefined, overhead: undefined };
}

export const CommandOverhead: MessageFns<CommandOverhead> = {
  encode(message: CommandOverhead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.overhead !== undefined) {
      Duration.encode(message.overhead, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandOverhead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandOverhead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overhead = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandOverhead {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      overhead: isSet(object.overhead) ? Duration.fromJSON(object.overhead) : undefined,
    };
  },

  toJSON(message: CommandOverhead): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.overhead !== undefined) {
      obj.overhead = Duration.toJSON(message.overhead);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandOverhead>): CommandOverhead {
    return CommandOverhead.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandOverhead>): CommandOverhead {
    const message = createBaseCommandOverhead();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.overhead = (object.overhead !== undefined && object.overhead !== null)
      ? Duration.fromPartial(object.overhead)
      : undefined;
    return message;
  },
};

function createBaseCommandResult(): CommandResult {
  return { status: undefined, exitCode: 0, outputs: undefined, duration: undefined, overhead: undefined, metadata: [] };
}

export const CommandResult: MessageFns<CommandResult> = {
  encode(message: CommandResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.outputs !== undefined) {
      Digest.encode(message.outputs, writer.uint32(26).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(34).fork()).join();
    }
    if (message.overhead !== undefined) {
      Duration.encode(message.overhead, writer.uint32(42).fork()).join();
    }
    for (const v of message.metadata) {
      Any.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputs = Digest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.overhead = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata.push(Any.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandResult {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      outputs: isSet(object.outputs) ? Digest.fromJSON(object.outputs) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      overhead: isSet(object.overhead) ? Duration.fromJSON(object.overhead) : undefined,
      metadata: globalThis.Array.isArray(object?.metadata) ? object.metadata.map((e: any) => Any.fromJSON(e)) : [],
    };
  },

  toJSON(message: CommandResult): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.outputs !== undefined) {
      obj.outputs = Digest.toJSON(message.outputs);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.overhead !== undefined) {
      obj.overhead = Duration.toJSON(message.overhead);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CommandResult>): CommandResult {
    return CommandResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandResult>): CommandResult {
    const message = createBaseCommandResult();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.exitCode = object.exitCode ?? 0;
    message.outputs = (object.outputs !== undefined && object.outputs !== null)
      ? Digest.fromPartial(object.outputs)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.overhead = (object.overhead !== undefined && object.overhead !== null)
      ? Duration.fromPartial(object.overhead)
      : undefined;
    message.metadata = object.metadata?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFileMetadata(): FileMetadata {
  return { path: "", digest: undefined, contents: Buffer.alloc(0), isExecutable: false };
}

export const FileMetadata: MessageFns<FileMetadata> = {
  encode(message: FileMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.digest !== undefined) {
      Digest.encode(message.digest, writer.uint32(18).fork()).join();
    }
    if (message.contents.length !== 0) {
      writer.uint32(26).bytes(message.contents);
    }
    if (message.isExecutable !== false) {
      writer.uint32(32).bool(message.isExecutable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = Digest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isExecutable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileMetadata {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      digest: isSet(object.digest) ? Digest.fromJSON(object.digest) : undefined,
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
      isExecutable: isSet(object.isExecutable) ? globalThis.Boolean(object.isExecutable) : false,
    };
  },

  toJSON(message: FileMetadata): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.digest !== undefined) {
      obj.digest = Digest.toJSON(message.digest);
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.isExecutable !== false) {
      obj.isExecutable = message.isExecutable;
    }
    return obj;
  },

  create(base?: DeepPartial<FileMetadata>): FileMetadata {
    return FileMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileMetadata>): FileMetadata {
    const message = createBaseFileMetadata();
    message.path = object.path ?? "";
    message.digest = (object.digest !== undefined && object.digest !== null)
      ? Digest.fromPartial(object.digest)
      : undefined;
    message.contents = object.contents ?? Buffer.alloc(0);
    message.isExecutable = object.isExecutable ?? false;
    return message;
  },
};

function createBaseDirectoryMetadata(): DirectoryMetadata {
  return { path: "", digest: undefined };
}

export const DirectoryMetadata: MessageFns<DirectoryMetadata> = {
  encode(message: DirectoryMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.digest !== undefined) {
      Digest.encode(message.digest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectoryMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectoryMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = Digest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectoryMetadata {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      digest: isSet(object.digest) ? Digest.fromJSON(object.digest) : undefined,
    };
  },

  toJSON(message: DirectoryMetadata): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.digest !== undefined) {
      obj.digest = Digest.toJSON(message.digest);
    }
    return obj;
  },

  create(base?: DeepPartial<DirectoryMetadata>): DirectoryMetadata {
    return DirectoryMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DirectoryMetadata>): DirectoryMetadata {
    const message = createBaseDirectoryMetadata();
    message.path = object.path ?? "";
    message.digest = (object.digest !== undefined && object.digest !== null)
      ? Digest.fromPartial(object.digest)
      : undefined;
    return message;
  },
};

function createBaseDigest(): Digest {
  return { hash: "", sizeBytes: Long.ZERO };
}

export const Digest: MessageFns<Digest> = {
  encode(message: Digest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Digest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDigest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Digest {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      sizeBytes: isSet(object.sizeBytes) ? Long.fromValue(object.sizeBytes) : Long.ZERO,
    };
  },

  toJSON(message: Digest): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.sizeBytes = (message.sizeBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Digest>): Digest {
    return Digest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Digest>): Digest {
    const message = createBaseDigest();
    message.hash = object.hash ?? "";
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseBlob(): Blob {
  return { digest: undefined, contents: Buffer.alloc(0) };
}

export const Blob: MessageFns<Blob> = {
  encode(message: Blob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digest !== undefined) {
      Digest.encode(message.digest, writer.uint32(10).fork()).join();
    }
    if (message.contents.length !== 0) {
      writer.uint32(18).bytes(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.digest = Digest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blob {
    return {
      digest: isSet(object.digest) ? Digest.fromJSON(object.digest) : undefined,
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Blob): unknown {
    const obj: any = {};
    if (message.digest !== undefined) {
      obj.digest = Digest.toJSON(message.digest);
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    return obj;
  },

  create(base?: DeepPartial<Blob>): Blob {
    return Blob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blob>): Blob {
    const message = createBaseBlob();
    message.digest = (object.digest !== undefined && object.digest !== null)
      ? Digest.fromPartial(object.digest)
      : undefined;
    message.contents = object.contents ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDirectory(): Directory {
  return { files: [], directories: [] };
}

export const Directory: MessageFns<Directory> = {
  encode(message: Directory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.directories) {
      DirectoryMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Directory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.files.push(FileMetadata.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.directories.push(DirectoryMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Directory {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileMetadata.fromJSON(e)) : [],
      directories: globalThis.Array.isArray(object?.directories)
        ? object.directories.map((e: any) => DirectoryMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Directory): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileMetadata.toJSON(e));
    }
    if (message.directories?.length) {
      obj.directories = message.directories.map((e) => DirectoryMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Directory>): Directory {
    return Directory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Directory>): Directory {
    const message = createBaseDirectory();
    message.files = object.files?.map((e) => FileMetadata.fromPartial(e)) || [];
    message.directories = object.directories?.map((e) => DirectoryMetadata.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
