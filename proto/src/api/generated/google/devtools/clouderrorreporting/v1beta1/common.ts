// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/clouderrorreporting/v1beta1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.devtools.clouderrorreporting.v1beta1";

/** Resolution status of an error group. */
export enum ResolutionStatus {
  /**
   * RESOLUTION_STATUS_UNSPECIFIED - Status is unknown. When left unspecified in requests, it is treated like
   * OPEN.
   */
  RESOLUTION_STATUS_UNSPECIFIED = 0,
  /**
   * OPEN - The error group is not being addressed. This is the default for
   * new groups. It is also used for errors re-occurring after marked RESOLVED.
   */
  OPEN = 1,
  /** ACKNOWLEDGED - Error Group manually acknowledged, it can have an issue link attached. */
  ACKNOWLEDGED = 2,
  /**
   * RESOLVED - Error Group manually resolved, more events for this group are not expected
   * to occur.
   */
  RESOLVED = 3,
  /** MUTED - The error group is muted and excluded by default on group stats requests. */
  MUTED = 4,
  UNRECOGNIZED = -1,
}

export function resolutionStatusFromJSON(object: any): ResolutionStatus {
  switch (object) {
    case 0:
    case "RESOLUTION_STATUS_UNSPECIFIED":
      return ResolutionStatus.RESOLUTION_STATUS_UNSPECIFIED;
    case 1:
    case "OPEN":
      return ResolutionStatus.OPEN;
    case 2:
    case "ACKNOWLEDGED":
      return ResolutionStatus.ACKNOWLEDGED;
    case 3:
    case "RESOLVED":
      return ResolutionStatus.RESOLVED;
    case 4:
    case "MUTED":
      return ResolutionStatus.MUTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResolutionStatus.UNRECOGNIZED;
  }
}

export function resolutionStatusToJSON(object: ResolutionStatus): string {
  switch (object) {
    case ResolutionStatus.RESOLUTION_STATUS_UNSPECIFIED:
      return "RESOLUTION_STATUS_UNSPECIFIED";
    case ResolutionStatus.OPEN:
      return "OPEN";
    case ResolutionStatus.ACKNOWLEDGED:
      return "ACKNOWLEDGED";
    case ResolutionStatus.RESOLVED:
      return "RESOLVED";
    case ResolutionStatus.MUTED:
      return "MUTED";
    case ResolutionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Description of a group of similar error events. */
export interface ErrorGroup {
  /**
   * The group resource name.
   * Written as `projects/{projectID}/groups/{group_id}` or
   * `projects/{projectID}/locations/{location}/groups/{group_id}`
   *
   * Examples: `projects/my-project-123/groups/my-group`,
   * `projects/my-project-123/locations/us-central1/groups/my-group`
   *
   * In the group resource name, the `group_id` is a unique identifier for a
   * particular error group. The identifier is derived from key parts of the
   * error-log content and is treated as Service Data. For information about
   * how Service Data is handled, see [Google Cloud Privacy
   * Notice](https://cloud.google.com/terms/cloud-privacy-notice).
   *
   * For a list of supported locations, see [Supported
   * Regions](https://cloud.google.com/logging/docs/region-support). `global` is
   * the default when unspecified.
   */
  name: string;
  /**
   * An opaque identifier of the group. This field is assigned by the Error
   * Reporting system and always populated.
   *
   * In the group resource name, the `group_id` is a unique identifier for a
   * particular error group. The identifier is derived from key parts of the
   * error-log content and is treated as Service Data. For information about
   * how Service Data is handled, see [Google Cloud Privacy
   * Notice](https://cloud.google.com/terms/cloud-privacy-notice).
   */
  groupId: string;
  /** Associated tracking issues. */
  trackingIssues: TrackingIssue[];
  /**
   * Error group's resolution status.
   *
   * An unspecified resolution status will be interpreted as OPEN
   */
  resolutionStatus: ResolutionStatus;
}

/** Information related to tracking the progress on resolving the error. */
export interface TrackingIssue {
  /**
   * A URL pointing to a related entry in an issue tracking system.
   * Example: `https://github.com/user/project/issues/4`
   */
  url: string;
}

/** An error event which is returned by the Error Reporting system. */
export interface ErrorEvent {
  /**
   * Time when the event occurred as provided in the error report.
   * If the report did not contain a timestamp, the time the error was received
   * by the Error Reporting system is used.
   */
  eventTime:
    | Date
    | undefined;
  /** The `ServiceContext` for which this error was reported. */
  serviceContext:
    | ServiceContext
    | undefined;
  /** The stack trace that was reported or logged by the service. */
  message: string;
  /** Data about the context in which the error occurred. */
  context: ErrorContext | undefined;
}

/**
 * Describes a running service that sends errors.
 * Its version changes over time and multiple versions can run in parallel.
 */
export interface ServiceContext {
  /**
   * An identifier of the service, such as the name of the
   * executable, job, or Google App Engine service name. This field is expected
   * to have a low number of values that are relatively stable over time, as
   * opposed to `version`, which can be changed whenever new code is deployed.
   *
   * Contains the service name for error reports extracted from Google
   * App Engine logs or `default` if the App Engine default service is used.
   */
  service: string;
  /**
   * Represents the source code version that the developer provided,
   * which could represent a version label or a Git SHA-1 hash, for example.
   * For App Engine standard environment, the version is set to the version of
   * the app.
   */
  version: string;
  /**
   * Type of the MonitoredResource. List of possible values:
   * https://cloud.google.com/monitoring/api/resources
   *
   * Value is set automatically for incoming errors and must not be set when
   * reporting errors.
   */
  resourceType: string;
}

/**
 * A description of the context in which an error occurred.
 * This data should be provided by the application when reporting an error,
 * unless the
 * error report has been generated automatically from Google App Engine logs.
 */
export interface ErrorContext {
  /**
   * The HTTP request which was processed when the error was
   * triggered.
   */
  httpRequest:
    | HttpRequestContext
    | undefined;
  /**
   * The user who caused or was affected by the crash.
   * This can be a user ID, an email address, or an arbitrary token that
   * uniquely identifies the user.
   * When sending an error report, leave this field empty if the user was not
   * logged in. In this case the
   * Error Reporting system will use other data, such as remote IP address, to
   * distinguish affected users. See `affected_users_count` in
   * `ErrorGroupStats`.
   */
  user: string;
  /**
   * The location in the source code where the decision was made to
   * report the error, usually the place where it was logged.
   * For a logged exception this would be the source line where the
   * exception is logged, usually close to the place where it was
   * caught.
   */
  reportLocation: SourceLocation | undefined;
}

/**
 * HTTP request data that is related to a reported error.
 * This data should be provided by the application when reporting an error,
 * unless the
 * error report has been generated automatically from Google App Engine logs.
 */
export interface HttpRequestContext {
  /** The type of HTTP request, such as `GET`, `POST`, etc. */
  method: string;
  /** The URL of the request. */
  url: string;
  /** The user agent information that is provided with the request. */
  userAgent: string;
  /** The referrer information that is provided with the request. */
  referrer: string;
  /** The HTTP response status code for the request. */
  responseStatusCode: number;
  /**
   * The IP address from which the request originated.
   * This can be IPv4, IPv6, or a token which is derived from the
   * IP address, depending on the data that has been provided
   * in the error report.
   */
  remoteIp: string;
}

/**
 * Indicates a location in the source code of the service for which errors are
 * reported. `functionName` must be provided by the application when reporting
 * an error, unless the error report contains a `message` with a supported
 * exception stack trace. All fields are optional for the later case.
 */
export interface SourceLocation {
  /**
   * The source code filename, which can include a truncated relative
   * path, or a full path from a production machine.
   */
  filePath: string;
  /** 1-based. 0 indicates that the line number is unknown. */
  lineNumber: number;
  /**
   * Human-readable name of a function or method.
   * The value can include optional context like the class or package name.
   * For example, `my.package.MyClass.method` in case of Java.
   */
  functionName: string;
}

function createBaseErrorGroup(): ErrorGroup {
  return { name: "", groupId: "", trackingIssues: [], resolutionStatus: 0 };
}

export const ErrorGroup: MessageFns<ErrorGroup> = {
  encode(message: ErrorGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    for (const v of message.trackingIssues) {
      TrackingIssue.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.resolutionStatus !== 0) {
      writer.uint32(40).int32(message.resolutionStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trackingIssues.push(TrackingIssue.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.resolutionStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      trackingIssues: globalThis.Array.isArray(object?.trackingIssues)
        ? object.trackingIssues.map((e: any) => TrackingIssue.fromJSON(e))
        : [],
      resolutionStatus: isSet(object.resolutionStatus) ? resolutionStatusFromJSON(object.resolutionStatus) : 0,
    };
  },

  toJSON(message: ErrorGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.trackingIssues?.length) {
      obj.trackingIssues = message.trackingIssues.map((e) => TrackingIssue.toJSON(e));
    }
    if (message.resolutionStatus !== 0) {
      obj.resolutionStatus = resolutionStatusToJSON(message.resolutionStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorGroup>): ErrorGroup {
    return ErrorGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorGroup>): ErrorGroup {
    const message = createBaseErrorGroup();
    message.name = object.name ?? "";
    message.groupId = object.groupId ?? "";
    message.trackingIssues = object.trackingIssues?.map((e) => TrackingIssue.fromPartial(e)) || [];
    message.resolutionStatus = object.resolutionStatus ?? 0;
    return message;
  },
};

function createBaseTrackingIssue(): TrackingIssue {
  return { url: "" };
}

export const TrackingIssue: MessageFns<TrackingIssue> = {
  encode(message: TrackingIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackingIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackingIssue {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: TrackingIssue): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<TrackingIssue>): TrackingIssue {
    return TrackingIssue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackingIssue>): TrackingIssue {
    const message = createBaseTrackingIssue();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseErrorEvent(): ErrorEvent {
  return { eventTime: undefined, serviceContext: undefined, message: "", context: undefined };
}

export const ErrorEvent: MessageFns<ErrorEvent> = {
  encode(message: ErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(10).fork()).join();
    }
    if (message.serviceContext !== undefined) {
      ServiceContext.encode(message.serviceContext, writer.uint32(18).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.context !== undefined) {
      ErrorContext.encode(message.context, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceContext = ServiceContext.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.context = ErrorContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorEvent {
    return {
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      serviceContext: isSet(object.serviceContext) ? ServiceContext.fromJSON(object.serviceContext) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      context: isSet(object.context) ? ErrorContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: ErrorEvent): unknown {
    const obj: any = {};
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.serviceContext !== undefined) {
      obj.serviceContext = ServiceContext.toJSON(message.serviceContext);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.context !== undefined) {
      obj.context = ErrorContext.toJSON(message.context);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorEvent>): ErrorEvent {
    return ErrorEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorEvent>): ErrorEvent {
    const message = createBaseErrorEvent();
    message.eventTime = object.eventTime ?? undefined;
    message.serviceContext = (object.serviceContext !== undefined && object.serviceContext !== null)
      ? ServiceContext.fromPartial(object.serviceContext)
      : undefined;
    message.message = object.message ?? "";
    message.context = (object.context !== undefined && object.context !== null)
      ? ErrorContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseServiceContext(): ServiceContext {
  return { service: "", version: "", resourceType: "" };
}

export const ServiceContext: MessageFns<ServiceContext> = {
  encode(message: ServiceContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.resourceType !== "") {
      writer.uint32(34).string(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceContext {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
    };
  },

  toJSON(message: ServiceContext): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceContext>): ServiceContext {
    return ServiceContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceContext>): ServiceContext {
    const message = createBaseServiceContext();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.resourceType = object.resourceType ?? "";
    return message;
  },
};

function createBaseErrorContext(): ErrorContext {
  return { httpRequest: undefined, user: "", reportLocation: undefined };
}

export const ErrorContext: MessageFns<ErrorContext> = {
  encode(message: ErrorContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpRequest !== undefined) {
      HttpRequestContext.encode(message.httpRequest, writer.uint32(10).fork()).join();
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.reportLocation !== undefined) {
      SourceLocation.encode(message.reportLocation, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpRequest = HttpRequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reportLocation = SourceLocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorContext {
    return {
      httpRequest: isSet(object.httpRequest) ? HttpRequestContext.fromJSON(object.httpRequest) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      reportLocation: isSet(object.reportLocation) ? SourceLocation.fromJSON(object.reportLocation) : undefined,
    };
  },

  toJSON(message: ErrorContext): unknown {
    const obj: any = {};
    if (message.httpRequest !== undefined) {
      obj.httpRequest = HttpRequestContext.toJSON(message.httpRequest);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.reportLocation !== undefined) {
      obj.reportLocation = SourceLocation.toJSON(message.reportLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorContext>): ErrorContext {
    return ErrorContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorContext>): ErrorContext {
    const message = createBaseErrorContext();
    message.httpRequest = (object.httpRequest !== undefined && object.httpRequest !== null)
      ? HttpRequestContext.fromPartial(object.httpRequest)
      : undefined;
    message.user = object.user ?? "";
    message.reportLocation = (object.reportLocation !== undefined && object.reportLocation !== null)
      ? SourceLocation.fromPartial(object.reportLocation)
      : undefined;
    return message;
  },
};

function createBaseHttpRequestContext(): HttpRequestContext {
  return { method: "", url: "", userAgent: "", referrer: "", responseStatusCode: 0, remoteIp: "" };
}

export const HttpRequestContext: MessageFns<HttpRequestContext> = {
  encode(message: HttpRequestContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (message.referrer !== "") {
      writer.uint32(34).string(message.referrer);
    }
    if (message.responseStatusCode !== 0) {
      writer.uint32(40).int32(message.responseStatusCode);
    }
    if (message.remoteIp !== "") {
      writer.uint32(50).string(message.remoteIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRequestContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referrer = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.responseStatusCode = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.remoteIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRequestContext {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      referrer: isSet(object.referrer) ? globalThis.String(object.referrer) : "",
      responseStatusCode: isSet(object.responseStatusCode) ? globalThis.Number(object.responseStatusCode) : 0,
      remoteIp: isSet(object.remoteIp) ? globalThis.String(object.remoteIp) : "",
    };
  },

  toJSON(message: HttpRequestContext): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.referrer !== "") {
      obj.referrer = message.referrer;
    }
    if (message.responseStatusCode !== 0) {
      obj.responseStatusCode = Math.round(message.responseStatusCode);
    }
    if (message.remoteIp !== "") {
      obj.remoteIp = message.remoteIp;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRequestContext>): HttpRequestContext {
    return HttpRequestContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRequestContext>): HttpRequestContext {
    const message = createBaseHttpRequestContext();
    message.method = object.method ?? "";
    message.url = object.url ?? "";
    message.userAgent = object.userAgent ?? "";
    message.referrer = object.referrer ?? "";
    message.responseStatusCode = object.responseStatusCode ?? 0;
    message.remoteIp = object.remoteIp ?? "";
    return message;
  },
};

function createBaseSourceLocation(): SourceLocation {
  return { filePath: "", lineNumber: 0, functionName: "" };
}

export const SourceLocation: MessageFns<SourceLocation> = {
  encode(message: SourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.lineNumber !== 0) {
      writer.uint32(16).int32(message.lineNumber);
    }
    if (message.functionName !== "") {
      writer.uint32(34).string(message.functionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lineNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.functionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceLocation {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      lineNumber: isSet(object.lineNumber) ? globalThis.Number(object.lineNumber) : 0,
      functionName: isSet(object.functionName) ? globalThis.String(object.functionName) : "",
    };
  },

  toJSON(message: SourceLocation): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.lineNumber !== 0) {
      obj.lineNumber = Math.round(message.lineNumber);
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceLocation>): SourceLocation {
    return SourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceLocation>): SourceLocation {
    const message = createBaseSourceLocation();
    message.filePath = object.filePath ?? "";
    message.lineNumber = object.lineNumber ?? 0;
    message.functionName = object.functionName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
