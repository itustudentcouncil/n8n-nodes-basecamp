// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/devtools/cloudtrace/v2/trace.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue, Int32Value } from "../../../protobuf/wrappers.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.devtools.cloudtrace.v2";

/**
 * A span represents a single operation within a trace. Spans can be
 * nested to form a trace tree. Often, a trace contains a root span
 * that describes the end-to-end latency, and one or more subspans for
 * its sub-operations.
 *
 * A trace can also contain multiple root spans, or none at all.
 * Spans do not need to be contiguous. There might be
 * gaps or overlaps between spans in a trace.
 */
export interface Span {
  /**
   * Required. The resource name of the span in the following format:
   *
   *  * `projects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]`
   *
   * `[TRACE_ID]` is a unique identifier for a trace within a project;
   * it is a 32-character hexadecimal encoding of a 16-byte array. It should
   * not be zero.
   *
   * `[SPAN_ID]` is a unique identifier for a span within a trace; it
   * is a 16-character hexadecimal encoding of an 8-byte array. It should not
   * be zero.
   * .
   */
  name: string;
  /** Required. The `[SPAN_ID]` portion of the span's resource name. */
  spanId: string;
  /**
   * The `[SPAN_ID]` of this span's parent span. If this is a root span,
   * then this field must be empty.
   */
  parentSpanId: string;
  /**
   * Required. A description of the span's operation (up to 128 bytes).
   * Cloud Trace displays the description in the
   * Cloud console.
   * For example, the display name can be a qualified method name or a file name
   * and a line number where the operation is called. A best practice is to use
   * the same display name within an application and at the same call point.
   * This makes it easier to correlate spans in different traces.
   */
  displayName:
    | TruncatableString
    | undefined;
  /**
   * Required. The start time of the span. On the client side, this is the time
   * kept by the local machine where the span execution starts. On the server
   * side, this is the time when the server's application handler starts
   * running.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Required. The end time of the span. On the client side, this is the time
   * kept by the local machine where the span execution ends. On the server
   * side, this is the time when the server application handler stops running.
   */
  endTime:
    | Date
    | undefined;
  /**
   * A set of attributes on the span. You can have up to 32 attributes per
   * span.
   */
  attributes:
    | Span_Attributes
    | undefined;
  /** Stack trace captured at the start of the span. */
  stackTrace:
    | StackTrace
    | undefined;
  /**
   * A set of time events. You can have up to 32 annotations and 128 message
   * events per span.
   */
  timeEvents:
    | Span_TimeEvents
    | undefined;
  /** Links associated with the span. You can have up to 128 links per Span. */
  links:
    | Span_Links
    | undefined;
  /** Optional. The final status for this span. */
  status:
    | Status
    | undefined;
  /**
   * Optional. Set this parameter to indicate whether this span is in
   * the same process as its parent. If you do not set this parameter,
   * Trace is unable to take advantage of this helpful information.
   */
  sameProcessAsParentSpan:
    | boolean
    | undefined;
  /**
   * Optional. The number of child spans that were generated while this span
   * was active. If set, allows implementation to detect missing child spans.
   */
  childSpanCount:
    | number
    | undefined;
  /**
   * Optional. Distinguishes between spans generated in a particular context.
   * For example, two spans with the same name may be distinguished using
   * `CLIENT` (caller) and `SERVER` (callee) to identify an RPC call.
   */
  spanKind: Span_SpanKind;
}

/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
export enum Span_SpanKind {
  /**
   * SPAN_KIND_UNSPECIFIED - Unspecified. Do NOT use as default.
   * Implementations MAY assume SpanKind.INTERNAL to be default.
   */
  SPAN_KIND_UNSPECIFIED = 0,
  /** INTERNAL - Indicates that the span is used internally. Default value. */
  INTERNAL = 1,
  /**
   * SERVER - Indicates that the span covers server-side handling of an RPC or other
   * remote network request.
   */
  SERVER = 2,
  /**
   * CLIENT - Indicates that the span covers the client-side wrapper around an RPC or
   * other remote request.
   */
  CLIENT = 3,
  /**
   * PRODUCER - Indicates that the span describes producer sending a message to a broker.
   * Unlike client and  server, there is no direct critical path latency
   * relationship between producer and consumer spans (e.g. publishing a
   * message to a pubsub service).
   */
  PRODUCER = 4,
  /**
   * CONSUMER - Indicates that the span describes consumer receiving a message from a
   * broker. Unlike client and  server, there is no direct critical path
   * latency relationship between producer and consumer spans (e.g. receiving
   * a message from a pubsub service subscription).
   */
  CONSUMER = 5,
  UNRECOGNIZED = -1,
}

export function span_SpanKindFromJSON(object: any): Span_SpanKind {
  switch (object) {
    case 0:
    case "SPAN_KIND_UNSPECIFIED":
      return Span_SpanKind.SPAN_KIND_UNSPECIFIED;
    case 1:
    case "INTERNAL":
      return Span_SpanKind.INTERNAL;
    case 2:
    case "SERVER":
      return Span_SpanKind.SERVER;
    case 3:
    case "CLIENT":
      return Span_SpanKind.CLIENT;
    case 4:
    case "PRODUCER":
      return Span_SpanKind.PRODUCER;
    case 5:
    case "CONSUMER":
      return Span_SpanKind.CONSUMER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Span_SpanKind.UNRECOGNIZED;
  }
}

export function span_SpanKindToJSON(object: Span_SpanKind): string {
  switch (object) {
    case Span_SpanKind.SPAN_KIND_UNSPECIFIED:
      return "SPAN_KIND_UNSPECIFIED";
    case Span_SpanKind.INTERNAL:
      return "INTERNAL";
    case Span_SpanKind.SERVER:
      return "SERVER";
    case Span_SpanKind.CLIENT:
      return "CLIENT";
    case Span_SpanKind.PRODUCER:
      return "PRODUCER";
    case Span_SpanKind.CONSUMER:
      return "CONSUMER";
    case Span_SpanKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A set of attributes as key-value pairs. */
export interface Span_Attributes {
  /**
   * A set of attributes. Each attribute's key can be up to 128 bytes
   * long. The value can be a string up to 256 bytes, a signed 64-bit integer,
   * or the boolean values `true` or `false`. For example:
   *
   *     "/instance_id": { "string_value": { "value": "my-instance" } }
   *     "/http/request_bytes": { "int_value": 300 }
   *     "abc.com/myattribute": { "bool_value": false }
   */
  attributeMap: { [key: string]: AttributeValue };
  /**
   * The number of attributes that were discarded. Attributes can be discarded
   * because their keys are too long or because there are too many attributes.
   * If this value is 0 then all attributes are valid.
   */
  droppedAttributesCount: number;
}

export interface Span_Attributes_AttributeMapEntry {
  key: string;
  value: AttributeValue | undefined;
}

/** A time-stamped annotation or message event in the Span. */
export interface Span_TimeEvent {
  /** The timestamp indicating the time the event occurred. */
  time:
    | Date
    | undefined;
  /** Text annotation with a set of attributes. */
  annotation?:
    | Span_TimeEvent_Annotation
    | undefined;
  /** An event describing a message sent/received between Spans. */
  messageEvent?: Span_TimeEvent_MessageEvent | undefined;
}

/** Text annotation with a set of attributes. */
export interface Span_TimeEvent_Annotation {
  /**
   * A user-supplied message describing the event. The maximum length for
   * the description is 256 bytes.
   */
  description:
    | TruncatableString
    | undefined;
  /**
   * A set of attributes on the annotation. You can have up to 4 attributes
   * per Annotation.
   */
  attributes: Span_Attributes | undefined;
}

/** An event describing a message sent/received between Spans. */
export interface Span_TimeEvent_MessageEvent {
  /**
   * Type of MessageEvent. Indicates whether the message was sent or
   * received.
   */
  type: Span_TimeEvent_MessageEvent_Type;
  /**
   * An identifier for the MessageEvent's message that can be used to match
   * `SENT` and `RECEIVED` MessageEvents.
   */
  id: Long;
  /** The number of uncompressed bytes sent or received. */
  uncompressedSizeBytes: Long;
  /**
   * The number of compressed bytes sent or received. If missing, the
   * compressed size is assumed to be the same size as the uncompressed
   * size.
   */
  compressedSizeBytes: Long;
}

/** Indicates whether the message was sent or received. */
export enum Span_TimeEvent_MessageEvent_Type {
  /** TYPE_UNSPECIFIED - Unknown event type. */
  TYPE_UNSPECIFIED = 0,
  /** SENT - Indicates a sent message. */
  SENT = 1,
  /** RECEIVED - Indicates a received message. */
  RECEIVED = 2,
  UNRECOGNIZED = -1,
}

export function span_TimeEvent_MessageEvent_TypeFromJSON(object: any): Span_TimeEvent_MessageEvent_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SENT":
      return Span_TimeEvent_MessageEvent_Type.SENT;
    case 2:
    case "RECEIVED":
      return Span_TimeEvent_MessageEvent_Type.RECEIVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Span_TimeEvent_MessageEvent_Type.UNRECOGNIZED;
  }
}

export function span_TimeEvent_MessageEvent_TypeToJSON(object: Span_TimeEvent_MessageEvent_Type): string {
  switch (object) {
    case Span_TimeEvent_MessageEvent_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Span_TimeEvent_MessageEvent_Type.SENT:
      return "SENT";
    case Span_TimeEvent_MessageEvent_Type.RECEIVED:
      return "RECEIVED";
    case Span_TimeEvent_MessageEvent_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
 * on the span, consisting of either user-supplied key:value pairs, or
 * details of a message sent/received between Spans.
 */
export interface Span_TimeEvents {
  /** A collection of `TimeEvent`s. */
  timeEvent: Span_TimeEvent[];
  /**
   * The number of dropped annotations in all the included time events.
   * If the value is 0, then no annotations were dropped.
   */
  droppedAnnotationsCount: number;
  /**
   * The number of dropped message events in all the included time events.
   * If the value is 0, then no message events were dropped.
   */
  droppedMessageEventsCount: number;
}

/**
 * A pointer from the current span to another span in the same trace or in a
 * different trace. For example, this can be used in batching operations,
 * where a single batch handler processes multiple requests from different
 * traces or when the handler receives a request from a different project.
 */
export interface Span_Link {
  /** The `[TRACE_ID]` for a trace within a project. */
  traceId: string;
  /** The `[SPAN_ID]` for a span within a trace. */
  spanId: string;
  /** The relationship of the current span relative to the linked span. */
  type: Span_Link_Type;
  /**
   * A set of attributes on the link. Up to 32 attributes can be
   * specified per link.
   */
  attributes: Span_Attributes | undefined;
}

/**
 * The relationship of the current span relative to the linked span: child,
 * parent, or unspecified.
 */
export enum Span_Link_Type {
  /** TYPE_UNSPECIFIED - The relationship of the two spans is unknown. */
  TYPE_UNSPECIFIED = 0,
  /** CHILD_LINKED_SPAN - The linked span is a child of the current span. */
  CHILD_LINKED_SPAN = 1,
  /** PARENT_LINKED_SPAN - The linked span is a parent of the current span. */
  PARENT_LINKED_SPAN = 2,
  UNRECOGNIZED = -1,
}

export function span_Link_TypeFromJSON(object: any): Span_Link_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Span_Link_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CHILD_LINKED_SPAN":
      return Span_Link_Type.CHILD_LINKED_SPAN;
    case 2:
    case "PARENT_LINKED_SPAN":
      return Span_Link_Type.PARENT_LINKED_SPAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Span_Link_Type.UNRECOGNIZED;
  }
}

export function span_Link_TypeToJSON(object: Span_Link_Type): string {
  switch (object) {
    case Span_Link_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Span_Link_Type.CHILD_LINKED_SPAN:
      return "CHILD_LINKED_SPAN";
    case Span_Link_Type.PARENT_LINKED_SPAN:
      return "PARENT_LINKED_SPAN";
    case Span_Link_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A collection of links, which are references from this span to a span
 * in the same or different trace.
 */
export interface Span_Links {
  /** A collection of links. */
  link: Span_Link[];
  /**
   * The number of dropped links after the maximum size was enforced. If
   * this value is 0, then no links were dropped.
   */
  droppedLinksCount: number;
}

/** The allowed types for `[VALUE]` in a `[KEY]:[VALUE]` attribute. */
export interface AttributeValue {
  /** A string up to 256 bytes long. */
  stringValue?:
    | TruncatableString
    | undefined;
  /** A 64-bit signed integer. */
  intValue?:
    | Long
    | undefined;
  /** A Boolean value represented by `true` or `false`. */
  boolValue?: boolean | undefined;
}

/** A call stack appearing in a trace. */
export interface StackTrace {
  /** Stack frames in this stack trace. A maximum of 128 frames are allowed. */
  stackFrames:
    | StackTrace_StackFrames
    | undefined;
  /**
   * The hash ID is used to conserve network bandwidth for duplicate
   * stack traces within a single trace.
   *
   * Often multiple spans will have identical stack traces.
   * The first occurrence of a stack trace should contain both the
   * `stackFrame` content and a value in `stackTraceHashId`.
   *
   * Subsequent spans within the same request can refer
   * to that stack trace by only setting `stackTraceHashId`.
   */
  stackTraceHashId: Long;
}

/** Represents a single stack frame in a stack trace. */
export interface StackTrace_StackFrame {
  /**
   * The fully-qualified name that uniquely identifies the function or
   * method that is active in this frame (up to 1024 bytes).
   */
  functionName:
    | TruncatableString
    | undefined;
  /**
   * An un-mangled function name, if `function_name` is mangled.
   * To get information about name mangling, run
   * [this search](https://www.google.com/search?q=cxx+name+mangling).
   * The name can be fully-qualified (up to 1024 bytes).
   */
  originalFunctionName:
    | TruncatableString
    | undefined;
  /**
   * The name of the source file where the function call appears (up to 256
   * bytes).
   */
  fileName:
    | TruncatableString
    | undefined;
  /** The line number in `file_name` where the function call appears. */
  lineNumber: Long;
  /**
   * The column number where the function call appears, if available.
   * This is important in JavaScript because of its anonymous functions.
   */
  columnNumber: Long;
  /** The binary module from where the code was loaded. */
  loadModule:
    | Module
    | undefined;
  /** The version of the deployed source code (up to 128 bytes). */
  sourceVersion: TruncatableString | undefined;
}

/** A collection of stack frames, which can be truncated. */
export interface StackTrace_StackFrames {
  /** Stack frames in this call stack. */
  frame: StackTrace_StackFrame[];
  /**
   * The number of stack frames that were dropped because there
   * were too many stack frames.
   * If this value is 0, then no stack frames were dropped.
   */
  droppedFramesCount: number;
}

/** Binary module. */
export interface Module {
  /**
   * For example: main binary, kernel modules, and dynamic libraries
   * such as libc.so, sharedlib.so (up to 256 bytes).
   */
  module:
    | TruncatableString
    | undefined;
  /**
   * A unique identifier for the module, usually a hash of its
   * contents (up to 128 bytes).
   */
  buildId: TruncatableString | undefined;
}

/** Represents a string that might be shortened to a specified length. */
export interface TruncatableString {
  /**
   * The shortened string. For example, if the original string is 500
   * bytes long and the limit of the string is 128 bytes, then
   * `value` contains the first 128 bytes of the 500-byte string.
   *
   * Truncation always happens on a UTF8 character boundary. If there
   * are multi-byte characters in the string, then the length of the
   * shortened string might be less than the size limit.
   */
  value: string;
  /**
   * The number of bytes removed from the original string. If this
   * value is 0, then the string was not shortened.
   */
  truncatedByteCount: number;
}

function createBaseSpan(): Span {
  return {
    name: "",
    spanId: "",
    parentSpanId: "",
    displayName: undefined,
    startTime: undefined,
    endTime: undefined,
    attributes: undefined,
    stackTrace: undefined,
    timeEvents: undefined,
    links: undefined,
    status: undefined,
    sameProcessAsParentSpan: undefined,
    childSpanCount: undefined,
    spanKind: 0,
  };
}

export const Span: MessageFns<Span> = {
  encode(message: Span, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.spanId !== "") {
      writer.uint32(18).string(message.spanId);
    }
    if (message.parentSpanId !== "") {
      writer.uint32(26).string(message.parentSpanId);
    }
    if (message.displayName !== undefined) {
      TruncatableString.encode(message.displayName, writer.uint32(34).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(58).fork()).join();
    }
    if (message.stackTrace !== undefined) {
      StackTrace.encode(message.stackTrace, writer.uint32(66).fork()).join();
    }
    if (message.timeEvents !== undefined) {
      Span_TimeEvents.encode(message.timeEvents, writer.uint32(74).fork()).join();
    }
    if (message.links !== undefined) {
      Span_Links.encode(message.links, writer.uint32(82).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(90).fork()).join();
    }
    if (message.sameProcessAsParentSpan !== undefined) {
      BoolValue.encode({ value: message.sameProcessAsParentSpan! }, writer.uint32(98).fork()).join();
    }
    if (message.childSpanCount !== undefined) {
      Int32Value.encode({ value: message.childSpanCount! }, writer.uint32(106).fork()).join();
    }
    if (message.spanKind !== 0) {
      writer.uint32(112).int32(message.spanKind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentSpanId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stackTrace = StackTrace.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timeEvents = Span_TimeEvents.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.links = Span_Links.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sameProcessAsParentSpan = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.childSpanCount = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.spanKind = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      parentSpanId: isSet(object.parentSpanId) ? globalThis.String(object.parentSpanId) : "",
      displayName: isSet(object.displayName) ? TruncatableString.fromJSON(object.displayName) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
      stackTrace: isSet(object.stackTrace) ? StackTrace.fromJSON(object.stackTrace) : undefined,
      timeEvents: isSet(object.timeEvents) ? Span_TimeEvents.fromJSON(object.timeEvents) : undefined,
      links: isSet(object.links) ? Span_Links.fromJSON(object.links) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      sameProcessAsParentSpan: isSet(object.sameProcessAsParentSpan)
        ? Boolean(object.sameProcessAsParentSpan)
        : undefined,
      childSpanCount: isSet(object.childSpanCount) ? Number(object.childSpanCount) : undefined,
      spanKind: isSet(object.spanKind) ? span_SpanKindFromJSON(object.spanKind) : 0,
    };
  },

  toJSON(message: Span): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.parentSpanId !== "") {
      obj.parentSpanId = message.parentSpanId;
    }
    if (message.displayName !== undefined) {
      obj.displayName = TruncatableString.toJSON(message.displayName);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    if (message.stackTrace !== undefined) {
      obj.stackTrace = StackTrace.toJSON(message.stackTrace);
    }
    if (message.timeEvents !== undefined) {
      obj.timeEvents = Span_TimeEvents.toJSON(message.timeEvents);
    }
    if (message.links !== undefined) {
      obj.links = Span_Links.toJSON(message.links);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.sameProcessAsParentSpan !== undefined) {
      obj.sameProcessAsParentSpan = message.sameProcessAsParentSpan;
    }
    if (message.childSpanCount !== undefined) {
      obj.childSpanCount = message.childSpanCount;
    }
    if (message.spanKind !== 0) {
      obj.spanKind = span_SpanKindToJSON(message.spanKind);
    }
    return obj;
  },

  create(base?: DeepPartial<Span>): Span {
    return Span.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span>): Span {
    const message = createBaseSpan();
    message.name = object.name ?? "";
    message.spanId = object.spanId ?? "";
    message.parentSpanId = object.parentSpanId ?? "";
    message.displayName = (object.displayName !== undefined && object.displayName !== null)
      ? TruncatableString.fromPartial(object.displayName)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    message.stackTrace = (object.stackTrace !== undefined && object.stackTrace !== null)
      ? StackTrace.fromPartial(object.stackTrace)
      : undefined;
    message.timeEvents = (object.timeEvents !== undefined && object.timeEvents !== null)
      ? Span_TimeEvents.fromPartial(object.timeEvents)
      : undefined;
    message.links = (object.links !== undefined && object.links !== null)
      ? Span_Links.fromPartial(object.links)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.sameProcessAsParentSpan = object.sameProcessAsParentSpan ?? undefined;
    message.childSpanCount = object.childSpanCount ?? undefined;
    message.spanKind = object.spanKind ?? 0;
    return message;
  },
};

function createBaseSpan_Attributes(): Span_Attributes {
  return { attributeMap: {}, droppedAttributesCount: 0 };
}

export const Span_Attributes: MessageFns<Span_Attributes> = {
  encode(message: Span_Attributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.attributeMap).forEach(([key, value]) => {
      Span_Attributes_AttributeMapEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.droppedAttributesCount !== 0) {
      writer.uint32(16).int32(message.droppedAttributesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Attributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Attributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Span_Attributes_AttributeMapEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.attributeMap[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.droppedAttributesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Attributes {
    return {
      attributeMap: isObject(object.attributeMap)
        ? Object.entries(object.attributeMap).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      droppedAttributesCount: isSet(object.droppedAttributesCount)
        ? globalThis.Number(object.droppedAttributesCount)
        : 0,
    };
  },

  toJSON(message: Span_Attributes): unknown {
    const obj: any = {};
    if (message.attributeMap) {
      const entries = Object.entries(message.attributeMap);
      if (entries.length > 0) {
        obj.attributeMap = {};
        entries.forEach(([k, v]) => {
          obj.attributeMap[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.droppedAttributesCount !== 0) {
      obj.droppedAttributesCount = Math.round(message.droppedAttributesCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_Attributes>): Span_Attributes {
    return Span_Attributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_Attributes>): Span_Attributes {
    const message = createBaseSpan_Attributes();
    message.attributeMap = Object.entries(object.attributeMap ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.droppedAttributesCount = object.droppedAttributesCount ?? 0;
    return message;
  },
};

function createBaseSpan_Attributes_AttributeMapEntry(): Span_Attributes_AttributeMapEntry {
  return { key: "", value: undefined };
}

export const Span_Attributes_AttributeMapEntry: MessageFns<Span_Attributes_AttributeMapEntry> = {
  encode(message: Span_Attributes_AttributeMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Attributes_AttributeMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Attributes_AttributeMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Attributes_AttributeMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Span_Attributes_AttributeMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_Attributes_AttributeMapEntry>): Span_Attributes_AttributeMapEntry {
    return Span_Attributes_AttributeMapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_Attributes_AttributeMapEntry>): Span_Attributes_AttributeMapEntry {
    const message = createBaseSpan_Attributes_AttributeMapEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpan_TimeEvent(): Span_TimeEvent {
  return { time: undefined, annotation: undefined, messageEvent: undefined };
}

export const Span_TimeEvent: MessageFns<Span_TimeEvent> = {
  encode(message: Span_TimeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.annotation !== undefined) {
      Span_TimeEvent_Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    if (message.messageEvent !== undefined) {
      Span_TimeEvent_MessageEvent.encode(message.messageEvent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Span_TimeEvent_Annotation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageEvent = Span_TimeEvent_MessageEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      annotation: isSet(object.annotation) ? Span_TimeEvent_Annotation.fromJSON(object.annotation) : undefined,
      messageEvent: isSet(object.messageEvent) ? Span_TimeEvent_MessageEvent.fromJSON(object.messageEvent) : undefined,
    };
  },

  toJSON(message: Span_TimeEvent): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.annotation !== undefined) {
      obj.annotation = Span_TimeEvent_Annotation.toJSON(message.annotation);
    }
    if (message.messageEvent !== undefined) {
      obj.messageEvent = Span_TimeEvent_MessageEvent.toJSON(message.messageEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_TimeEvent>): Span_TimeEvent {
    return Span_TimeEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_TimeEvent>): Span_TimeEvent {
    const message = createBaseSpan_TimeEvent();
    message.time = object.time ?? undefined;
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Span_TimeEvent_Annotation.fromPartial(object.annotation)
      : undefined;
    message.messageEvent = (object.messageEvent !== undefined && object.messageEvent !== null)
      ? Span_TimeEvent_MessageEvent.fromPartial(object.messageEvent)
      : undefined;
    return message;
  },
};

function createBaseSpan_TimeEvent_Annotation(): Span_TimeEvent_Annotation {
  return { description: undefined, attributes: undefined };
}

export const Span_TimeEvent_Annotation: MessageFns<Span_TimeEvent_Annotation> = {
  encode(message: Span_TimeEvent_Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      TruncatableString.encode(message.description, writer.uint32(10).fork()).join();
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent_Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent_Annotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent_Annotation {
    return {
      description: isSet(object.description) ? TruncatableString.fromJSON(object.description) : undefined,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
    };
  },

  toJSON(message: Span_TimeEvent_Annotation): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = TruncatableString.toJSON(message.description);
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_TimeEvent_Annotation>): Span_TimeEvent_Annotation {
    return Span_TimeEvent_Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_TimeEvent_Annotation>): Span_TimeEvent_Annotation {
    const message = createBaseSpan_TimeEvent_Annotation();
    message.description = (object.description !== undefined && object.description !== null)
      ? TruncatableString.fromPartial(object.description)
      : undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

function createBaseSpan_TimeEvent_MessageEvent(): Span_TimeEvent_MessageEvent {
  return { type: 0, id: Long.ZERO, uncompressedSizeBytes: Long.ZERO, compressedSizeBytes: Long.ZERO };
}

export const Span_TimeEvent_MessageEvent: MessageFns<Span_TimeEvent_MessageEvent> = {
  encode(message: Span_TimeEvent_MessageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.id.toString());
    }
    if (!message.uncompressedSizeBytes.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.uncompressedSizeBytes.toString());
    }
    if (!message.compressedSizeBytes.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.compressedSizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvent_MessageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvent_MessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.uncompressedSizeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.compressedSizeBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvent_MessageEvent {
    return {
      type: isSet(object.type) ? span_TimeEvent_MessageEvent_TypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      uncompressedSizeBytes: isSet(object.uncompressedSizeBytes)
        ? Long.fromValue(object.uncompressedSizeBytes)
        : Long.ZERO,
      compressedSizeBytes: isSet(object.compressedSizeBytes) ? Long.fromValue(object.compressedSizeBytes) : Long.ZERO,
    };
  },

  toJSON(message: Span_TimeEvent_MessageEvent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = span_TimeEvent_MessageEvent_TypeToJSON(message.type);
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (!message.uncompressedSizeBytes.equals(Long.ZERO)) {
      obj.uncompressedSizeBytes = (message.uncompressedSizeBytes || Long.ZERO).toString();
    }
    if (!message.compressedSizeBytes.equals(Long.ZERO)) {
      obj.compressedSizeBytes = (message.compressedSizeBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Span_TimeEvent_MessageEvent>): Span_TimeEvent_MessageEvent {
    return Span_TimeEvent_MessageEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_TimeEvent_MessageEvent>): Span_TimeEvent_MessageEvent {
    const message = createBaseSpan_TimeEvent_MessageEvent();
    message.type = object.type ?? 0;
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.uncompressedSizeBytes =
      (object.uncompressedSizeBytes !== undefined && object.uncompressedSizeBytes !== null)
        ? Long.fromValue(object.uncompressedSizeBytes)
        : Long.ZERO;
    message.compressedSizeBytes = (object.compressedSizeBytes !== undefined && object.compressedSizeBytes !== null)
      ? Long.fromValue(object.compressedSizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseSpan_TimeEvents(): Span_TimeEvents {
  return { timeEvent: [], droppedAnnotationsCount: 0, droppedMessageEventsCount: 0 };
}

export const Span_TimeEvents: MessageFns<Span_TimeEvents> = {
  encode(message: Span_TimeEvents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.timeEvent) {
      Span_TimeEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.droppedAnnotationsCount !== 0) {
      writer.uint32(16).int32(message.droppedAnnotationsCount);
    }
    if (message.droppedMessageEventsCount !== 0) {
      writer.uint32(24).int32(message.droppedMessageEventsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_TimeEvents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_TimeEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeEvent.push(Span_TimeEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.droppedAnnotationsCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.droppedMessageEventsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_TimeEvents {
    return {
      timeEvent: globalThis.Array.isArray(object?.timeEvent)
        ? object.timeEvent.map((e: any) => Span_TimeEvent.fromJSON(e))
        : [],
      droppedAnnotationsCount: isSet(object.droppedAnnotationsCount)
        ? globalThis.Number(object.droppedAnnotationsCount)
        : 0,
      droppedMessageEventsCount: isSet(object.droppedMessageEventsCount)
        ? globalThis.Number(object.droppedMessageEventsCount)
        : 0,
    };
  },

  toJSON(message: Span_TimeEvents): unknown {
    const obj: any = {};
    if (message.timeEvent?.length) {
      obj.timeEvent = message.timeEvent.map((e) => Span_TimeEvent.toJSON(e));
    }
    if (message.droppedAnnotationsCount !== 0) {
      obj.droppedAnnotationsCount = Math.round(message.droppedAnnotationsCount);
    }
    if (message.droppedMessageEventsCount !== 0) {
      obj.droppedMessageEventsCount = Math.round(message.droppedMessageEventsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_TimeEvents>): Span_TimeEvents {
    return Span_TimeEvents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_TimeEvents>): Span_TimeEvents {
    const message = createBaseSpan_TimeEvents();
    message.timeEvent = object.timeEvent?.map((e) => Span_TimeEvent.fromPartial(e)) || [];
    message.droppedAnnotationsCount = object.droppedAnnotationsCount ?? 0;
    message.droppedMessageEventsCount = object.droppedMessageEventsCount ?? 0;
    return message;
  },
};

function createBaseSpan_Link(): Span_Link {
  return { traceId: "", spanId: "", type: 0, attributes: undefined };
}

export const Span_Link: MessageFns<Span_Link> = {
  encode(message: Span_Link, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traceId !== "") {
      writer.uint32(10).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(18).string(message.spanId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.attributes !== undefined) {
      Span_Attributes.encode(message.attributes, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Link {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Link();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributes = Span_Attributes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Link {
    return {
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      type: isSet(object.type) ? span_Link_TypeFromJSON(object.type) : 0,
      attributes: isSet(object.attributes) ? Span_Attributes.fromJSON(object.attributes) : undefined,
    };
  },

  toJSON(message: Span_Link): unknown {
    const obj: any = {};
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.type !== 0) {
      obj.type = span_Link_TypeToJSON(message.type);
    }
    if (message.attributes !== undefined) {
      obj.attributes = Span_Attributes.toJSON(message.attributes);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_Link>): Span_Link {
    return Span_Link.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_Link>): Span_Link {
    const message = createBaseSpan_Link();
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.type = object.type ?? 0;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Span_Attributes.fromPartial(object.attributes)
      : undefined;
    return message;
  },
};

function createBaseSpan_Links(): Span_Links {
  return { link: [], droppedLinksCount: 0 };
}

export const Span_Links: MessageFns<Span_Links> = {
  encode(message: Span_Links, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.link) {
      Span_Link.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.droppedLinksCount !== 0) {
      writer.uint32(16).int32(message.droppedLinksCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Span_Links {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpan_Links();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.link.push(Span_Link.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.droppedLinksCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Span_Links {
    return {
      link: globalThis.Array.isArray(object?.link) ? object.link.map((e: any) => Span_Link.fromJSON(e)) : [],
      droppedLinksCount: isSet(object.droppedLinksCount) ? globalThis.Number(object.droppedLinksCount) : 0,
    };
  },

  toJSON(message: Span_Links): unknown {
    const obj: any = {};
    if (message.link?.length) {
      obj.link = message.link.map((e) => Span_Link.toJSON(e));
    }
    if (message.droppedLinksCount !== 0) {
      obj.droppedLinksCount = Math.round(message.droppedLinksCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Span_Links>): Span_Links {
    return Span_Links.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Span_Links>): Span_Links {
    const message = createBaseSpan_Links();
    message.link = object.link?.map((e) => Span_Link.fromPartial(e)) || [];
    message.droppedLinksCount = object.droppedLinksCount ?? 0;
    return message;
  },
};

function createBaseAttributeValue(): AttributeValue {
  return { stringValue: undefined, intValue: undefined, boolValue: undefined };
}

export const AttributeValue: MessageFns<AttributeValue> = {
  encode(message: AttributeValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      TruncatableString.encode(message.stringValue, writer.uint32(10).fork()).join();
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      stringValue: isSet(object.stringValue) ? TruncatableString.fromJSON(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = TruncatableString.toJSON(message.stringValue);
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValue>): AttributeValue {
    return AttributeValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValue>): AttributeValue {
    const message = createBaseAttributeValue();
    message.stringValue = (object.stringValue !== undefined && object.stringValue !== null)
      ? TruncatableString.fromPartial(object.stringValue)
      : undefined;
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    return message;
  },
};

function createBaseStackTrace(): StackTrace {
  return { stackFrames: undefined, stackTraceHashId: Long.ZERO };
}

export const StackTrace: MessageFns<StackTrace> = {
  encode(message: StackTrace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stackFrames !== undefined) {
      StackTrace_StackFrames.encode(message.stackFrames, writer.uint32(10).fork()).join();
    }
    if (!message.stackTraceHashId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.stackTraceHashId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stackFrames = StackTrace_StackFrames.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stackTraceHashId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace {
    return {
      stackFrames: isSet(object.stackFrames) ? StackTrace_StackFrames.fromJSON(object.stackFrames) : undefined,
      stackTraceHashId: isSet(object.stackTraceHashId) ? Long.fromValue(object.stackTraceHashId) : Long.ZERO,
    };
  },

  toJSON(message: StackTrace): unknown {
    const obj: any = {};
    if (message.stackFrames !== undefined) {
      obj.stackFrames = StackTrace_StackFrames.toJSON(message.stackFrames);
    }
    if (!message.stackTraceHashId.equals(Long.ZERO)) {
      obj.stackTraceHashId = (message.stackTraceHashId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StackTrace>): StackTrace {
    return StackTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StackTrace>): StackTrace {
    const message = createBaseStackTrace();
    message.stackFrames = (object.stackFrames !== undefined && object.stackFrames !== null)
      ? StackTrace_StackFrames.fromPartial(object.stackFrames)
      : undefined;
    message.stackTraceHashId = (object.stackTraceHashId !== undefined && object.stackTraceHashId !== null)
      ? Long.fromValue(object.stackTraceHashId)
      : Long.ZERO;
    return message;
  },
};

function createBaseStackTrace_StackFrame(): StackTrace_StackFrame {
  return {
    functionName: undefined,
    originalFunctionName: undefined,
    fileName: undefined,
    lineNumber: Long.ZERO,
    columnNumber: Long.ZERO,
    loadModule: undefined,
    sourceVersion: undefined,
  };
}

export const StackTrace_StackFrame: MessageFns<StackTrace_StackFrame> = {
  encode(message: StackTrace_StackFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionName !== undefined) {
      TruncatableString.encode(message.functionName, writer.uint32(10).fork()).join();
    }
    if (message.originalFunctionName !== undefined) {
      TruncatableString.encode(message.originalFunctionName, writer.uint32(18).fork()).join();
    }
    if (message.fileName !== undefined) {
      TruncatableString.encode(message.fileName, writer.uint32(26).fork()).join();
    }
    if (!message.lineNumber.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lineNumber.toString());
    }
    if (!message.columnNumber.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.columnNumber.toString());
    }
    if (message.loadModule !== undefined) {
      Module.encode(message.loadModule, writer.uint32(50).fork()).join();
    }
    if (message.sourceVersion !== undefined) {
      TruncatableString.encode(message.sourceVersion, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace_StackFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace_StackFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionName = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalFunctionName = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileName = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lineNumber = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.columnNumber = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.loadModule = Module.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sourceVersion = TruncatableString.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace_StackFrame {
    return {
      functionName: isSet(object.functionName) ? TruncatableString.fromJSON(object.functionName) : undefined,
      originalFunctionName: isSet(object.originalFunctionName)
        ? TruncatableString.fromJSON(object.originalFunctionName)
        : undefined,
      fileName: isSet(object.fileName) ? TruncatableString.fromJSON(object.fileName) : undefined,
      lineNumber: isSet(object.lineNumber) ? Long.fromValue(object.lineNumber) : Long.ZERO,
      columnNumber: isSet(object.columnNumber) ? Long.fromValue(object.columnNumber) : Long.ZERO,
      loadModule: isSet(object.loadModule) ? Module.fromJSON(object.loadModule) : undefined,
      sourceVersion: isSet(object.sourceVersion) ? TruncatableString.fromJSON(object.sourceVersion) : undefined,
    };
  },

  toJSON(message: StackTrace_StackFrame): unknown {
    const obj: any = {};
    if (message.functionName !== undefined) {
      obj.functionName = TruncatableString.toJSON(message.functionName);
    }
    if (message.originalFunctionName !== undefined) {
      obj.originalFunctionName = TruncatableString.toJSON(message.originalFunctionName);
    }
    if (message.fileName !== undefined) {
      obj.fileName = TruncatableString.toJSON(message.fileName);
    }
    if (!message.lineNumber.equals(Long.ZERO)) {
      obj.lineNumber = (message.lineNumber || Long.ZERO).toString();
    }
    if (!message.columnNumber.equals(Long.ZERO)) {
      obj.columnNumber = (message.columnNumber || Long.ZERO).toString();
    }
    if (message.loadModule !== undefined) {
      obj.loadModule = Module.toJSON(message.loadModule);
    }
    if (message.sourceVersion !== undefined) {
      obj.sourceVersion = TruncatableString.toJSON(message.sourceVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<StackTrace_StackFrame>): StackTrace_StackFrame {
    return StackTrace_StackFrame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StackTrace_StackFrame>): StackTrace_StackFrame {
    const message = createBaseStackTrace_StackFrame();
    message.functionName = (object.functionName !== undefined && object.functionName !== null)
      ? TruncatableString.fromPartial(object.functionName)
      : undefined;
    message.originalFunctionName = (object.originalFunctionName !== undefined && object.originalFunctionName !== null)
      ? TruncatableString.fromPartial(object.originalFunctionName)
      : undefined;
    message.fileName = (object.fileName !== undefined && object.fileName !== null)
      ? TruncatableString.fromPartial(object.fileName)
      : undefined;
    message.lineNumber = (object.lineNumber !== undefined && object.lineNumber !== null)
      ? Long.fromValue(object.lineNumber)
      : Long.ZERO;
    message.columnNumber = (object.columnNumber !== undefined && object.columnNumber !== null)
      ? Long.fromValue(object.columnNumber)
      : Long.ZERO;
    message.loadModule = (object.loadModule !== undefined && object.loadModule !== null)
      ? Module.fromPartial(object.loadModule)
      : undefined;
    message.sourceVersion = (object.sourceVersion !== undefined && object.sourceVersion !== null)
      ? TruncatableString.fromPartial(object.sourceVersion)
      : undefined;
    return message;
  },
};

function createBaseStackTrace_StackFrames(): StackTrace_StackFrames {
  return { frame: [], droppedFramesCount: 0 };
}

export const StackTrace_StackFrames: MessageFns<StackTrace_StackFrames> = {
  encode(message: StackTrace_StackFrames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.frame) {
      StackTrace_StackFrame.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.droppedFramesCount !== 0) {
      writer.uint32(16).int32(message.droppedFramesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StackTrace_StackFrames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStackTrace_StackFrames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frame.push(StackTrace_StackFrame.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.droppedFramesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StackTrace_StackFrames {
    return {
      frame: globalThis.Array.isArray(object?.frame)
        ? object.frame.map((e: any) => StackTrace_StackFrame.fromJSON(e))
        : [],
      droppedFramesCount: isSet(object.droppedFramesCount) ? globalThis.Number(object.droppedFramesCount) : 0,
    };
  },

  toJSON(message: StackTrace_StackFrames): unknown {
    const obj: any = {};
    if (message.frame?.length) {
      obj.frame = message.frame.map((e) => StackTrace_StackFrame.toJSON(e));
    }
    if (message.droppedFramesCount !== 0) {
      obj.droppedFramesCount = Math.round(message.droppedFramesCount);
    }
    return obj;
  },

  create(base?: DeepPartial<StackTrace_StackFrames>): StackTrace_StackFrames {
    return StackTrace_StackFrames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StackTrace_StackFrames>): StackTrace_StackFrames {
    const message = createBaseStackTrace_StackFrames();
    message.frame = object.frame?.map((e) => StackTrace_StackFrame.fromPartial(e)) || [];
    message.droppedFramesCount = object.droppedFramesCount ?? 0;
    return message;
  },
};

function createBaseModule(): Module {
  return { module: undefined, buildId: undefined };
}

export const Module: MessageFns<Module> = {
  encode(message: Module, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.module !== undefined) {
      TruncatableString.encode(message.module, writer.uint32(10).fork()).join();
    }
    if (message.buildId !== undefined) {
      TruncatableString.encode(message.buildId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Module {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.module = TruncatableString.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buildId = TruncatableString.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Module {
    return {
      module: isSet(object.module) ? TruncatableString.fromJSON(object.module) : undefined,
      buildId: isSet(object.buildId) ? TruncatableString.fromJSON(object.buildId) : undefined,
    };
  },

  toJSON(message: Module): unknown {
    const obj: any = {};
    if (message.module !== undefined) {
      obj.module = TruncatableString.toJSON(message.module);
    }
    if (message.buildId !== undefined) {
      obj.buildId = TruncatableString.toJSON(message.buildId);
    }
    return obj;
  },

  create(base?: DeepPartial<Module>): Module {
    return Module.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Module>): Module {
    const message = createBaseModule();
    message.module = (object.module !== undefined && object.module !== null)
      ? TruncatableString.fromPartial(object.module)
      : undefined;
    message.buildId = (object.buildId !== undefined && object.buildId !== null)
      ? TruncatableString.fromPartial(object.buildId)
      : undefined;
    return message;
  },
};

function createBaseTruncatableString(): TruncatableString {
  return { value: "", truncatedByteCount: 0 };
}

export const TruncatableString: MessageFns<TruncatableString> = {
  encode(message: TruncatableString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.truncatedByteCount !== 0) {
      writer.uint32(16).int32(message.truncatedByteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TruncatableString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTruncatableString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.truncatedByteCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TruncatableString {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      truncatedByteCount: isSet(object.truncatedByteCount) ? globalThis.Number(object.truncatedByteCount) : 0,
    };
  },

  toJSON(message: TruncatableString): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.truncatedByteCount !== 0) {
      obj.truncatedByteCount = Math.round(message.truncatedByteCount);
    }
    return obj;
  },

  create(base?: DeepPartial<TruncatableString>): TruncatableString {
    return TruncatableString.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TruncatableString>): TruncatableString {
    const message = createBaseTruncatableString();
    message.value = object.value ?? "";
    message.truncatedByteCount = object.truncatedByteCount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
