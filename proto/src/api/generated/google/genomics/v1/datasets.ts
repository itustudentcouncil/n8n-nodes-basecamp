// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/datasets.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../iam/v1/iam_policy.js";
import { Policy } from "../../iam/v1/policy.js";
import { Empty } from "../../protobuf/empty.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { Timestamp } from "../../protobuf/timestamp.js";

export const protobufPackage = "google.genomics.v1";

/**
 * A Dataset is a collection of genomic data.
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 */
export interface Dataset {
  /** The server-generated dataset ID, unique across all datasets. */
  id: string;
  /** The Google Cloud project ID that this dataset belongs to. */
  projectId: string;
  /** The dataset name. */
  name: string;
  /** The time this dataset was created, in seconds from the epoch. */
  createTime: Date | undefined;
}

/** The dataset list request. */
export interface ListDatasetsRequest {
  /** Required. The Google Cloud project ID to list datasets for. */
  projectId: string;
  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 50. The maximum value is 1024.
   */
  pageSize: number;
  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   */
  pageToken: string;
}

/** The dataset list response. */
export interface ListDatasetsResponse {
  /** The list of matching Datasets. */
  datasets: Dataset[];
  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   */
  nextPageToken: string;
}

export interface CreateDatasetRequest {
  /** The dataset to be created. Must contain projectId and name. */
  dataset: Dataset | undefined;
}

export interface UpdateDatasetRequest {
  /** The ID of the dataset to be updated. */
  datasetId: string;
  /** The new dataset data. */
  dataset:
    | Dataset
    | undefined;
  /**
   * An optional mask specifying which fields to update. At this time, the only
   * mutable field is [name][google.genomics.v1.Dataset.name]. The only
   * acceptable value is "name". If unspecified, all mutable fields will be
   * updated.
   */
  updateMask: string[] | undefined;
}

export interface DeleteDatasetRequest {
  /** The ID of the dataset to be deleted. */
  datasetId: string;
}

export interface UndeleteDatasetRequest {
  /** The ID of the dataset to be undeleted. */
  datasetId: string;
}

export interface GetDatasetRequest {
  /** The ID of the dataset. */
  datasetId: string;
}

function createBaseDataset(): Dataset {
  return { id: "", projectId: "", name: "", createTime: undefined };
}

export const Dataset: MessageFns<Dataset> = {
  encode(message: Dataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dataset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: Dataset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Dataset>): Dataset {
    return Dataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dataset>): Dataset {
    const message = createBaseDataset();
    message.id = object.id ?? "";
    message.projectId = object.projectId ?? "";
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseListDatasetsRequest(): ListDatasetsRequest {
  return { projectId: "", pageSize: 0, pageToken: "" };
}

export const ListDatasetsRequest: MessageFns<ListDatasetsRequest> = {
  encode(message: ListDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDatasetsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatasetsRequest>): ListDatasetsRequest {
    return ListDatasetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatasetsRequest>): ListDatasetsRequest {
    const message = createBaseListDatasetsRequest();
    message.projectId = object.projectId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDatasetsResponse(): ListDatasetsResponse {
  return { datasets: [], nextPageToken: "" };
}

export const ListDatasetsResponse: MessageFns<ListDatasetsResponse> = {
  encode(message: ListDatasetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datasets) {
      Dataset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasets.push(Dataset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetsResponse {
    return {
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => Dataset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDatasetsResponse): unknown {
    const obj: any = {};
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => Dataset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatasetsResponse>): ListDatasetsResponse {
    return ListDatasetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatasetsResponse>): ListDatasetsResponse {
    const message = createBaseListDatasetsResponse();
    message.datasets = object.datasets?.map((e) => Dataset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateDatasetRequest(): CreateDatasetRequest {
  return { dataset: undefined };
}

export const CreateDatasetRequest: MessageFns<CreateDatasetRequest> = {
  encode(message: CreateDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatasetRequest {
    return { dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined };
  },

  toJSON(message: CreateDatasetRequest): unknown {
    const obj: any = {};
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDatasetRequest>): CreateDatasetRequest {
    return CreateDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDatasetRequest>): CreateDatasetRequest {
    const message = createBaseCreateDatasetRequest();
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    return message;
  },
};

function createBaseUpdateDatasetRequest(): UpdateDatasetRequest {
  return { datasetId: "", dataset: undefined, updateMask: undefined };
}

export const UpdateDatasetRequest: MessageFns<UpdateDatasetRequest> = {
  encode(message: UpdateDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDatasetRequest {
    return {
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDatasetRequest): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDatasetRequest>): UpdateDatasetRequest {
    return UpdateDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDatasetRequest>): UpdateDatasetRequest {
    const message = createBaseUpdateDatasetRequest();
    message.datasetId = object.datasetId ?? "";
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteDatasetRequest(): DeleteDatasetRequest {
  return { datasetId: "" };
}

export const DeleteDatasetRequest: MessageFns<DeleteDatasetRequest> = {
  encode(message: DeleteDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetRequest {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: DeleteDatasetRequest): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDatasetRequest>): DeleteDatasetRequest {
    return DeleteDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDatasetRequest>): DeleteDatasetRequest {
    const message = createBaseDeleteDatasetRequest();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

function createBaseUndeleteDatasetRequest(): UndeleteDatasetRequest {
  return { datasetId: "" };
}

export const UndeleteDatasetRequest: MessageFns<UndeleteDatasetRequest> = {
  encode(message: UndeleteDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteDatasetRequest {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: UndeleteDatasetRequest): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteDatasetRequest>): UndeleteDatasetRequest {
    return UndeleteDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteDatasetRequest>): UndeleteDatasetRequest {
    const message = createBaseUndeleteDatasetRequest();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

function createBaseGetDatasetRequest(): GetDatasetRequest {
  return { datasetId: "" };
}

export const GetDatasetRequest: MessageFns<GetDatasetRequest> = {
  encode(message: GetDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datasetId !== "") {
      writer.uint32(10).string(message.datasetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatasetRequest {
    return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
  },

  toJSON(message: GetDatasetRequest): unknown {
    const obj: any = {};
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatasetRequest>): GetDatasetRequest {
    return GetDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatasetRequest>): GetDatasetRequest {
    const message = createBaseGetDatasetRequest();
    message.datasetId = object.datasetId ?? "";
    return message;
  },
};

/** This service manages datasets, which are collections of genomic data. */
export type DatasetServiceV1Definition = typeof DatasetServiceV1Definition;
export const DatasetServiceV1Definition = {
  name: "DatasetServiceV1",
  fullName: "google.genomics.v1.DatasetServiceV1",
  methods: {
    /**
     * Lists datasets within a project.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    listDatasets: {
      name: "ListDatasets",
      requestType: ListDatasetsRequest,
      requestStream: false,
      responseType: ListDatasetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [Buffer.from([14, 18, 12, 47, 118, 49, 47, 100, 97, 116, 97, 115, 101, 116, 115])],
        },
      },
    },
    /**
     * Creates a new dataset.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    createDataset: {
      name: "CreateDataset",
      requestType: CreateDatasetRequest,
      requestStream: false,
      responseType: Dataset,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              58,
              7,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              34,
              12,
              47,
              118,
              49,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a dataset by ID.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    getDataset: {
      name: "GetDataset",
      requestType: GetDatasetRequest,
      requestStream: false,
      responseType: Dataset,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              18,
              25,
              47,
              118,
              49,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a dataset.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * This method supports patch semantics.
     */
    updateDataset: {
      name: "UpdateDataset",
      requestType: UpdateDatasetRequest,
      requestStream: false,
      responseType: Dataset,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              58,
              7,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              50,
              25,
              47,
              118,
              49,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a dataset and all of its contents (all read group sets,
     * reference sets, variant sets, call sets, annotation sets, etc.)
     * This is reversible (up to one week after the deletion) via
     * the
     * [datasets.undelete][google.genomics.v1.DatasetServiceV1.UndeleteDataset]
     * operation.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    deleteDataset: {
      name: "DeleteDataset",
      requestType: DeleteDatasetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              42,
              25,
              47,
              118,
              49,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Undeletes a dataset by restoring a dataset which was deleted via this API.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * This operation is only possible for a week after the deletion occurred.
     */
    undeleteDataset: {
      name: "UndeleteDataset",
      requestType: UndeleteDatasetRequest,
      requestStream: false,
      responseType: Dataset,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              39,
              58,
              1,
              42,
              34,
              34,
              47,
              118,
              49,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on the specified dataset. Replaces any
     * existing policy.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     *
     * See <a href="/iam/docs/managing-policies#setting_a_policy">Setting a
     * Policy</a> for more information.
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for the dataset. This is empty if the
     * policy or resource does not exist.
     *
     * See <a href="/iam/docs/managing-policies#getting_a_policy">Getting a
     * Policy</a> for more information.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the specified resource.
     * See <a href="/iam/docs/managing-policies#testing_permissions">Testing
     * Permissions</a> for more information.
     *
     * For the definitions of datasets and other genomics resources, see
     * [Fundamentals of Google
     * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DatasetServiceV1ServiceImplementation<CallContextExt = {}> {
  /**
   * Lists datasets within a project.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  listDatasets(
    request: ListDatasetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDatasetsResponse>>;
  /**
   * Creates a new dataset.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createDataset(request: CreateDatasetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Dataset>>;
  /**
   * Gets a dataset by ID.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getDataset(request: GetDatasetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Dataset>>;
  /**
   * Updates a dataset.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics.
   */
  updateDataset(request: UpdateDatasetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Dataset>>;
  /**
   * Deletes a dataset and all of its contents (all read group sets,
   * reference sets, variant sets, call sets, annotation sets, etc.)
   * This is reversible (up to one week after the deletion) via
   * the
   * [datasets.undelete][google.genomics.v1.DatasetServiceV1.UndeleteDataset]
   * operation.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteDataset(request: DeleteDatasetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Undeletes a dataset by restoring a dataset which was deleted via this API.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This operation is only possible for a week after the deletion occurred.
   */
  undeleteDataset(
    request: UndeleteDatasetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Dataset>>;
  /**
   * Sets the access control policy on the specified dataset. Replaces any
   * existing policy.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * See <a href="/iam/docs/managing-policies#setting_a_policy">Setting a
   * Policy</a> for more information.
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Gets the access control policy for the dataset. This is empty if the
   * policy or resource does not exist.
   *
   * See <a href="/iam/docs/managing-policies#getting_a_policy">Getting a
   * Policy</a> for more information.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * See <a href="/iam/docs/managing-policies#testing_permissions">Testing
   * Permissions</a> for more information.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface DatasetServiceV1Client<CallOptionsExt = {}> {
  /**
   * Lists datasets within a project.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  listDatasets(
    request: DeepPartial<ListDatasetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDatasetsResponse>;
  /**
   * Creates a new dataset.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  createDataset(request: DeepPartial<CreateDatasetRequest>, options?: CallOptions & CallOptionsExt): Promise<Dataset>;
  /**
   * Gets a dataset by ID.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getDataset(request: DeepPartial<GetDatasetRequest>, options?: CallOptions & CallOptionsExt): Promise<Dataset>;
  /**
   * Updates a dataset.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This method supports patch semantics.
   */
  updateDataset(request: DeepPartial<UpdateDatasetRequest>, options?: CallOptions & CallOptionsExt): Promise<Dataset>;
  /**
   * Deletes a dataset and all of its contents (all read group sets,
   * reference sets, variant sets, call sets, annotation sets, etc.)
   * This is reversible (up to one week after the deletion) via
   * the
   * [datasets.undelete][google.genomics.v1.DatasetServiceV1.UndeleteDataset]
   * operation.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  deleteDataset(request: DeepPartial<DeleteDatasetRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Undeletes a dataset by restoring a dataset which was deleted via this API.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * This operation is only possible for a week after the deletion occurred.
   */
  undeleteDataset(
    request: DeepPartial<UndeleteDatasetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Dataset>;
  /**
   * Sets the access control policy on the specified dataset. Replaces any
   * existing policy.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   *
   * See <a href="/iam/docs/managing-policies#setting_a_policy">Setting a
   * Policy</a> for more information.
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Gets the access control policy for the dataset. This is empty if the
   * policy or resource does not exist.
   *
   * See <a href="/iam/docs/managing-policies#getting_a_policy">Getting a
   * Policy</a> for more information.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * See <a href="/iam/docs/managing-policies#testing_permissions">Testing
   * Permissions</a> for more information.
   *
   * For the definitions of datasets and other genomics resources, see
   * [Fundamentals of Google
   * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
