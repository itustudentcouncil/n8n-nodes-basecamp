// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/readgroup.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../protobuf/struct.js";

export const protobufPackage = "google.genomics.v1";

/** A read group is all the data that's processed the same way by the sequencer. */
export interface ReadGroup {
  /**
   * The server-generated read group ID, unique for all read groups.
   * Note: This is different than the @RG ID field in the SAM spec. For that
   * value, see [name][google.genomics.v1.ReadGroup.name].
   */
  id: string;
  /** The dataset to which this read group belongs. */
  datasetId: string;
  /** The read group name. This corresponds to the @RG ID field in the SAM spec. */
  name: string;
  /** A free-form text description of this read group. */
  description: string;
  /** A client-supplied sample identifier for the reads in this read group. */
  sampleId: string;
  /** The experiment used to generate this read group. */
  experiment:
    | ReadGroup_Experiment
    | undefined;
  /**
   * The predicted insert size of this read group. The insert size is the length
   * the sequenced DNA fragment from end-to-end, not including the adapters.
   */
  predictedInsertSize: number;
  /**
   * The programs used to generate this read group. Programs are always
   * identical for all read groups within a read group set. For this reason,
   * only the first read group in a returned set will have this field
   * populated.
   */
  programs: ReadGroup_Program[];
  /** The reference set the reads in this read group are aligned to. */
  referenceSetId: string;
  /**
   * A map of additional read group information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface ReadGroup_Experiment {
  /**
   * A client-supplied library identifier; a library is a collection of DNA
   * fragments which have been prepared for sequencing from a sample. This
   * field is important for quality control as error or bias can be introduced
   * during sample preparation.
   */
  libraryId: string;
  /**
   * The platform unit used as part of this experiment, for example
   * flowcell-barcode.lane for Illumina or slide for SOLiD. Corresponds to the
   * @RG PU field in the SAM spec.
   */
  platformUnit: string;
  /** The sequencing center used as part of this experiment. */
  sequencingCenter: string;
  /**
   * The instrument model used as part of this experiment. This maps to
   * sequencing technology in the SAM spec.
   */
  instrumentModel: string;
}

export interface ReadGroup_Program {
  /** The command line used to run this program. */
  commandLine: string;
  /**
   * The user specified locally unique ID of the program. Used along with
   * `prevProgramId` to define an ordering between programs.
   */
  id: string;
  /**
   * The display name of the program. This is typically the colloquial name of
   * the tool used, for example 'bwa' or 'picard'.
   */
  name: string;
  /** The ID of the program run before this one. */
  prevProgramId: string;
  /** The version of the program run. */
  version: string;
}

export interface ReadGroup_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

function createBaseReadGroup(): ReadGroup {
  return {
    id: "",
    datasetId: "",
    name: "",
    description: "",
    sampleId: "",
    experiment: undefined,
    predictedInsertSize: 0,
    programs: [],
    referenceSetId: "",
    info: {},
  };
}

export const ReadGroup: MessageFns<ReadGroup> = {
  encode(message: ReadGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.sampleId !== "") {
      writer.uint32(42).string(message.sampleId);
    }
    if (message.experiment !== undefined) {
      ReadGroup_Experiment.encode(message.experiment, writer.uint32(50).fork()).join();
    }
    if (message.predictedInsertSize !== 0) {
      writer.uint32(56).int32(message.predictedInsertSize);
    }
    for (const v of message.programs) {
      ReadGroup_Program.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.referenceSetId !== "") {
      writer.uint32(90).string(message.referenceSetId);
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        ReadGroup_InfoEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sampleId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.experiment = ReadGroup_Experiment.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.predictedInsertSize = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.programs.push(ReadGroup_Program.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.referenceSetId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = ReadGroup_InfoEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.info[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      sampleId: isSet(object.sampleId) ? globalThis.String(object.sampleId) : "",
      experiment: isSet(object.experiment) ? ReadGroup_Experiment.fromJSON(object.experiment) : undefined,
      predictedInsertSize: isSet(object.predictedInsertSize) ? globalThis.Number(object.predictedInsertSize) : 0,
      programs: globalThis.Array.isArray(object?.programs)
        ? object.programs.map((e: any) => ReadGroup_Program.fromJSON(e))
        : [],
      referenceSetId: isSet(object.referenceSetId) ? globalThis.String(object.referenceSetId) : "",
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ReadGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.sampleId !== "") {
      obj.sampleId = message.sampleId;
    }
    if (message.experiment !== undefined) {
      obj.experiment = ReadGroup_Experiment.toJSON(message.experiment);
    }
    if (message.predictedInsertSize !== 0) {
      obj.predictedInsertSize = Math.round(message.predictedInsertSize);
    }
    if (message.programs?.length) {
      obj.programs = message.programs.map((e) => ReadGroup_Program.toJSON(e));
    }
    if (message.referenceSetId !== "") {
      obj.referenceSetId = message.referenceSetId;
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ReadGroup>): ReadGroup {
    return ReadGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadGroup>): ReadGroup {
    const message = createBaseReadGroup();
    message.id = object.id ?? "";
    message.datasetId = object.datasetId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.sampleId = object.sampleId ?? "";
    message.experiment = (object.experiment !== undefined && object.experiment !== null)
      ? ReadGroup_Experiment.fromPartial(object.experiment)
      : undefined;
    message.predictedInsertSize = object.predictedInsertSize ?? 0;
    message.programs = object.programs?.map((e) => ReadGroup_Program.fromPartial(e)) || [];
    message.referenceSetId = object.referenceSetId ?? "";
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseReadGroup_Experiment(): ReadGroup_Experiment {
  return { libraryId: "", platformUnit: "", sequencingCenter: "", instrumentModel: "" };
}

export const ReadGroup_Experiment: MessageFns<ReadGroup_Experiment> = {
  encode(message: ReadGroup_Experiment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.libraryId !== "") {
      writer.uint32(10).string(message.libraryId);
    }
    if (message.platformUnit !== "") {
      writer.uint32(18).string(message.platformUnit);
    }
    if (message.sequencingCenter !== "") {
      writer.uint32(26).string(message.sequencingCenter);
    }
    if (message.instrumentModel !== "") {
      writer.uint32(34).string(message.instrumentModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadGroup_Experiment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadGroup_Experiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.libraryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.platformUnit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sequencingCenter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instrumentModel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadGroup_Experiment {
    return {
      libraryId: isSet(object.libraryId) ? globalThis.String(object.libraryId) : "",
      platformUnit: isSet(object.platformUnit) ? globalThis.String(object.platformUnit) : "",
      sequencingCenter: isSet(object.sequencingCenter) ? globalThis.String(object.sequencingCenter) : "",
      instrumentModel: isSet(object.instrumentModel) ? globalThis.String(object.instrumentModel) : "",
    };
  },

  toJSON(message: ReadGroup_Experiment): unknown {
    const obj: any = {};
    if (message.libraryId !== "") {
      obj.libraryId = message.libraryId;
    }
    if (message.platformUnit !== "") {
      obj.platformUnit = message.platformUnit;
    }
    if (message.sequencingCenter !== "") {
      obj.sequencingCenter = message.sequencingCenter;
    }
    if (message.instrumentModel !== "") {
      obj.instrumentModel = message.instrumentModel;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadGroup_Experiment>): ReadGroup_Experiment {
    return ReadGroup_Experiment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadGroup_Experiment>): ReadGroup_Experiment {
    const message = createBaseReadGroup_Experiment();
    message.libraryId = object.libraryId ?? "";
    message.platformUnit = object.platformUnit ?? "";
    message.sequencingCenter = object.sequencingCenter ?? "";
    message.instrumentModel = object.instrumentModel ?? "";
    return message;
  },
};

function createBaseReadGroup_Program(): ReadGroup_Program {
  return { commandLine: "", id: "", name: "", prevProgramId: "", version: "" };
}

export const ReadGroup_Program: MessageFns<ReadGroup_Program> = {
  encode(message: ReadGroup_Program, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandLine !== "") {
      writer.uint32(10).string(message.commandLine);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.prevProgramId !== "") {
      writer.uint32(34).string(message.prevProgramId);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadGroup_Program {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadGroup_Program();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commandLine = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prevProgramId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadGroup_Program {
    return {
      commandLine: isSet(object.commandLine) ? globalThis.String(object.commandLine) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      prevProgramId: isSet(object.prevProgramId) ? globalThis.String(object.prevProgramId) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: ReadGroup_Program): unknown {
    const obj: any = {};
    if (message.commandLine !== "") {
      obj.commandLine = message.commandLine;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.prevProgramId !== "") {
      obj.prevProgramId = message.prevProgramId;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadGroup_Program>): ReadGroup_Program {
    return ReadGroup_Program.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadGroup_Program>): ReadGroup_Program {
    const message = createBaseReadGroup_Program();
    message.commandLine = object.commandLine ?? "";
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.prevProgramId = object.prevProgramId ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseReadGroup_InfoEntry(): ReadGroup_InfoEntry {
  return { key: "", value: undefined };
}

export const ReadGroup_InfoEntry: MessageFns<ReadGroup_InfoEntry> = {
  encode(message: ReadGroup_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadGroup_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadGroup_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadGroup_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: ReadGroup_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadGroup_InfoEntry>): ReadGroup_InfoEntry {
    return ReadGroup_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadGroup_InfoEntry>): ReadGroup_InfoEntry {
    const message = createBaseReadGroup_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
