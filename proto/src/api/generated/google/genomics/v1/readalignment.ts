// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/genomics/v1/readalignment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../protobuf/struct.js";
import { CigarUnit } from "./cigar.js";
import { Position } from "./position.js";

export const protobufPackage = "google.genomics.v1";

/**
 * A linear alignment can be represented by one CIGAR string. Describes the
 * mapped position and local alignment of the read to the reference.
 */
export interface LinearAlignment {
  /** The position of this alignment. */
  position:
    | Position
    | undefined;
  /**
   * The mapping quality of this alignment. Represents how likely
   * the read maps to this position as opposed to other locations.
   *
   * Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to
   * the nearest integer.
   */
  mappingQuality: number;
  /**
   * Represents the local alignment of this sequence (alignment matches, indels,
   * etc) against the reference.
   */
  cigar: CigarUnit[];
}

/**
 * A read alignment describes a linear alignment of a string of DNA to a
 * [reference sequence][google.genomics.v1.Reference], in addition to metadata
 * about the fragment (the molecule of DNA sequenced) and the read (the bases
 * which were read by the sequencer). A read is equivalent to a line in a SAM
 * file. A read belongs to exactly one read group and exactly one
 * [read group set][google.genomics.v1.ReadGroupSet].
 *
 * For more genomics resource definitions, see [Fundamentals of Google
 * Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
 *
 * ### Reverse-stranded reads
 *
 * Mapped reads (reads having a non-null `alignment`) can be aligned to either
 * the forward or the reverse strand of their associated reference. Strandedness
 * of a mapped read is encoded by `alignment.position.reverseStrand`.
 *
 * If we consider the reference to be a forward-stranded coordinate space of
 * `[0, reference.length)` with `0` as the left-most position and
 * `reference.length` as the right-most position, reads are always aligned left
 * to right. That is, `alignment.position.position` always refers to the
 * left-most reference coordinate and `alignment.cigar` describes the alignment
 * of this read to the reference from left to right. All per-base fields such as
 * `alignedSequence` and `alignedQuality` share this same left-to-right
 * orientation; this is true of reads which are aligned to either strand. For
 * reverse-stranded reads, this means that `alignedSequence` is the reverse
 * complement of the bases that were originally reported by the sequencing
 * machine.
 *
 * ### Generating a reference-aligned sequence string
 *
 * When interacting with mapped reads, it's often useful to produce a string
 * representing the local alignment of the read to reference. The following
 * pseudocode demonstrates one way of doing this:
 *
 *     out = ""
 *     offset = 0
 *     for c in read.alignment.cigar {
 *       switch c.operation {
 *       case "ALIGNMENT_MATCH", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH":
 *         out += read.alignedSequence[offset:offset+c.operationLength]
 *         offset += c.operationLength
 *         break
 *       case "CLIP_SOFT", "INSERT":
 *         offset += c.operationLength
 *         break
 *       case "PAD":
 *         out += repeat("*", c.operationLength)
 *         break
 *       case "DELETE":
 *         out += repeat("-", c.operationLength)
 *         break
 *       case "SKIP":
 *         out += repeat(" ", c.operationLength)
 *         break
 *       case "CLIP_HARD":
 *         break
 *       }
 *     }
 *     return out
 *
 * ### Converting to SAM's CIGAR string
 *
 * The following pseudocode generates a SAM CIGAR string from the
 * `cigar` field. Note that this is a lossy conversion
 * (`cigar.referenceSequence` is lost).
 *
 *     cigarMap = {
 *       "ALIGNMENT_MATCH": "M",
 *       "INSERT": "I",
 *       "DELETE": "D",
 *       "SKIP": "N",
 *       "CLIP_SOFT": "S",
 *       "CLIP_HARD": "H",
 *       "PAD": "P",
 *       "SEQUENCE_MATCH": "=",
 *       "SEQUENCE_MISMATCH": "X",
 *     }
 *     cigarStr = ""
 *     for c in read.alignment.cigar {
 *       cigarStr += c.operationLength + cigarMap[c.operation]
 *     }
 *     return cigarStr
 */
export interface Read {
  /**
   * The server-generated read ID, unique across all reads. This is different
   * from the `fragmentName`.
   */
  id: string;
  /**
   * The ID of the read group this read belongs to. A read belongs to exactly
   * one read group. This is a server-generated ID which is distinct from SAM's
   * RG tag (for that value, see
   * [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
   */
  readGroupId: string;
  /**
   * The ID of the read group set this read belongs to. A read belongs to
   * exactly one read group set.
   */
  readGroupSetId: string;
  /** The fragment name. Equivalent to QNAME (query template name) in SAM. */
  fragmentName: string;
  /**
   * The orientation and the distance between reads from the fragment are
   * consistent with the sequencing protocol (SAM flag 0x2).
   */
  properPlacement: boolean;
  /** The fragment is a PCR or optical duplicate (SAM flag 0x400). */
  duplicateFragment: boolean;
  /** The observed length of the fragment, equivalent to TLEN in SAM. */
  fragmentLength: number;
  /**
   * The read number in sequencing. 0-based and less than numberReads. This
   * field replaces SAM flag 0x40 and 0x80.
   */
  readNumber: number;
  /** The number of reads in the fragment (extension to SAM flag 0x1). */
  numberReads: number;
  /**
   * Whether this read did not pass filters, such as platform or vendor quality
   * controls (SAM flag 0x200).
   */
  failedVendorQualityChecks: boolean;
  /**
   * The linear alignment for this alignment record. This field is null for
   * unmapped reads.
   */
  alignment:
    | LinearAlignment
    | undefined;
  /**
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
   * A secondary alignment represents an alternative to the primary alignment
   * for this read. Aligners may return secondary alignments if a read can map
   * ambiguously to multiple coordinates in the genome. By convention, each read
   * has one and only one alignment where both `secondaryAlignment`
   * and `supplementaryAlignment` are false.
   */
  secondaryAlignment: boolean;
  /**
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
   * Supplementary alignments are used in the representation of a chimeric
   * alignment. In a chimeric alignment, a read is split into multiple
   * linear alignments that map to different reference contigs. The first
   * linear alignment in the read will be designated as the representative
   * alignment; the remaining linear alignments will be designated as
   * supplementary alignments. These alignments may have different mapping
   * quality scores. In each linear alignment in a chimeric alignment, the read
   * will be hard clipped. The `alignedSequence` and
   * `alignedQuality` fields in the alignment record will only
   * represent the bases for its respective linear alignment.
   */
  supplementaryAlignment: boolean;
  /**
   * The bases of the read sequence contained in this alignment record,
   * **without CIGAR operations applied** (equivalent to SEQ in SAM).
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   */
  alignedSequence: string;
  /**
   * The quality of the read sequence contained in this alignment record
   * (equivalent to QUAL in SAM).
   * `alignedSequence` and `alignedQuality` may be shorter than the full read
   * sequence and quality. This will occur if the alignment is part of a
   * chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
   * for this read will begin/end with a hard clip operator that will indicate
   * the length of the excised sequence.
   */
  alignedQuality: number[];
  /**
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   */
  nextMatePosition:
    | Position
    | undefined;
  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   */
  info: { [key: string]: Array<any> | undefined };
}

export interface Read_InfoEntry {
  key: string;
  value: Array<any> | undefined;
}

function createBaseLinearAlignment(): LinearAlignment {
  return { position: undefined, mappingQuality: 0, cigar: [] };
}

export const LinearAlignment: MessageFns<LinearAlignment> = {
  encode(message: LinearAlignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.mappingQuality !== 0) {
      writer.uint32(16).int32(message.mappingQuality);
    }
    for (const v of message.cigar) {
      CigarUnit.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinearAlignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinearAlignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mappingQuality = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cigar.push(CigarUnit.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinearAlignment {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      mappingQuality: isSet(object.mappingQuality) ? globalThis.Number(object.mappingQuality) : 0,
      cigar: globalThis.Array.isArray(object?.cigar) ? object.cigar.map((e: any) => CigarUnit.fromJSON(e)) : [],
    };
  },

  toJSON(message: LinearAlignment): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.mappingQuality !== 0) {
      obj.mappingQuality = Math.round(message.mappingQuality);
    }
    if (message.cigar?.length) {
      obj.cigar = message.cigar.map((e) => CigarUnit.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LinearAlignment>): LinearAlignment {
    return LinearAlignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinearAlignment>): LinearAlignment {
    const message = createBaseLinearAlignment();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.mappingQuality = object.mappingQuality ?? 0;
    message.cigar = object.cigar?.map((e) => CigarUnit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRead(): Read {
  return {
    id: "",
    readGroupId: "",
    readGroupSetId: "",
    fragmentName: "",
    properPlacement: false,
    duplicateFragment: false,
    fragmentLength: 0,
    readNumber: 0,
    numberReads: 0,
    failedVendorQualityChecks: false,
    alignment: undefined,
    secondaryAlignment: false,
    supplementaryAlignment: false,
    alignedSequence: "",
    alignedQuality: [],
    nextMatePosition: undefined,
    info: {},
  };
}

export const Read: MessageFns<Read> = {
  encode(message: Read, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.readGroupId !== "") {
      writer.uint32(18).string(message.readGroupId);
    }
    if (message.readGroupSetId !== "") {
      writer.uint32(26).string(message.readGroupSetId);
    }
    if (message.fragmentName !== "") {
      writer.uint32(34).string(message.fragmentName);
    }
    if (message.properPlacement !== false) {
      writer.uint32(40).bool(message.properPlacement);
    }
    if (message.duplicateFragment !== false) {
      writer.uint32(48).bool(message.duplicateFragment);
    }
    if (message.fragmentLength !== 0) {
      writer.uint32(56).int32(message.fragmentLength);
    }
    if (message.readNumber !== 0) {
      writer.uint32(64).int32(message.readNumber);
    }
    if (message.numberReads !== 0) {
      writer.uint32(72).int32(message.numberReads);
    }
    if (message.failedVendorQualityChecks !== false) {
      writer.uint32(80).bool(message.failedVendorQualityChecks);
    }
    if (message.alignment !== undefined) {
      LinearAlignment.encode(message.alignment, writer.uint32(90).fork()).join();
    }
    if (message.secondaryAlignment !== false) {
      writer.uint32(96).bool(message.secondaryAlignment);
    }
    if (message.supplementaryAlignment !== false) {
      writer.uint32(104).bool(message.supplementaryAlignment);
    }
    if (message.alignedSequence !== "") {
      writer.uint32(114).string(message.alignedSequence);
    }
    writer.uint32(122).fork();
    for (const v of message.alignedQuality) {
      writer.int32(v);
    }
    writer.join();
    if (message.nextMatePosition !== undefined) {
      Position.encode(message.nextMatePosition, writer.uint32(130).fork()).join();
    }
    Object.entries(message.info).forEach(([key, value]) => {
      if (value !== undefined) {
        Read_InfoEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Read {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readGroupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.readGroupSetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fragmentName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.properPlacement = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.duplicateFragment = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fragmentLength = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.readNumber = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.numberReads = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.failedVendorQualityChecks = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.alignment = LinearAlignment.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.secondaryAlignment = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.supplementaryAlignment = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.alignedSequence = reader.string();
          continue;
        case 15:
          if (tag === 120) {
            message.alignedQuality.push(reader.int32());

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alignedQuality.push(reader.int32());
            }

            continue;
          }

          break;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.nextMatePosition = Position.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = Read_InfoEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.info[entry17.key] = entry17.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Read {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      readGroupId: isSet(object.readGroupId) ? globalThis.String(object.readGroupId) : "",
      readGroupSetId: isSet(object.readGroupSetId) ? globalThis.String(object.readGroupSetId) : "",
      fragmentName: isSet(object.fragmentName) ? globalThis.String(object.fragmentName) : "",
      properPlacement: isSet(object.properPlacement) ? globalThis.Boolean(object.properPlacement) : false,
      duplicateFragment: isSet(object.duplicateFragment) ? globalThis.Boolean(object.duplicateFragment) : false,
      fragmentLength: isSet(object.fragmentLength) ? globalThis.Number(object.fragmentLength) : 0,
      readNumber: isSet(object.readNumber) ? globalThis.Number(object.readNumber) : 0,
      numberReads: isSet(object.numberReads) ? globalThis.Number(object.numberReads) : 0,
      failedVendorQualityChecks: isSet(object.failedVendorQualityChecks)
        ? globalThis.Boolean(object.failedVendorQualityChecks)
        : false,
      alignment: isSet(object.alignment) ? LinearAlignment.fromJSON(object.alignment) : undefined,
      secondaryAlignment: isSet(object.secondaryAlignment) ? globalThis.Boolean(object.secondaryAlignment) : false,
      supplementaryAlignment: isSet(object.supplementaryAlignment)
        ? globalThis.Boolean(object.supplementaryAlignment)
        : false,
      alignedSequence: isSet(object.alignedSequence) ? globalThis.String(object.alignedSequence) : "",
      alignedQuality: globalThis.Array.isArray(object?.alignedQuality)
        ? object.alignedQuality.map((e: any) => globalThis.Number(e))
        : [],
      nextMatePosition: isSet(object.nextMatePosition) ? Position.fromJSON(object.nextMatePosition) : undefined,
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Read): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.readGroupId !== "") {
      obj.readGroupId = message.readGroupId;
    }
    if (message.readGroupSetId !== "") {
      obj.readGroupSetId = message.readGroupSetId;
    }
    if (message.fragmentName !== "") {
      obj.fragmentName = message.fragmentName;
    }
    if (message.properPlacement !== false) {
      obj.properPlacement = message.properPlacement;
    }
    if (message.duplicateFragment !== false) {
      obj.duplicateFragment = message.duplicateFragment;
    }
    if (message.fragmentLength !== 0) {
      obj.fragmentLength = Math.round(message.fragmentLength);
    }
    if (message.readNumber !== 0) {
      obj.readNumber = Math.round(message.readNumber);
    }
    if (message.numberReads !== 0) {
      obj.numberReads = Math.round(message.numberReads);
    }
    if (message.failedVendorQualityChecks !== false) {
      obj.failedVendorQualityChecks = message.failedVendorQualityChecks;
    }
    if (message.alignment !== undefined) {
      obj.alignment = LinearAlignment.toJSON(message.alignment);
    }
    if (message.secondaryAlignment !== false) {
      obj.secondaryAlignment = message.secondaryAlignment;
    }
    if (message.supplementaryAlignment !== false) {
      obj.supplementaryAlignment = message.supplementaryAlignment;
    }
    if (message.alignedSequence !== "") {
      obj.alignedSequence = message.alignedSequence;
    }
    if (message.alignedQuality?.length) {
      obj.alignedQuality = message.alignedQuality.map((e) => Math.round(e));
    }
    if (message.nextMatePosition !== undefined) {
      obj.nextMatePosition = Position.toJSON(message.nextMatePosition);
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Read>): Read {
    return Read.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Read>): Read {
    const message = createBaseRead();
    message.id = object.id ?? "";
    message.readGroupId = object.readGroupId ?? "";
    message.readGroupSetId = object.readGroupSetId ?? "";
    message.fragmentName = object.fragmentName ?? "";
    message.properPlacement = object.properPlacement ?? false;
    message.duplicateFragment = object.duplicateFragment ?? false;
    message.fragmentLength = object.fragmentLength ?? 0;
    message.readNumber = object.readNumber ?? 0;
    message.numberReads = object.numberReads ?? 0;
    message.failedVendorQualityChecks = object.failedVendorQualityChecks ?? false;
    message.alignment = (object.alignment !== undefined && object.alignment !== null)
      ? LinearAlignment.fromPartial(object.alignment)
      : undefined;
    message.secondaryAlignment = object.secondaryAlignment ?? false;
    message.supplementaryAlignment = object.supplementaryAlignment ?? false;
    message.alignedSequence = object.alignedSequence ?? "";
    message.alignedQuality = object.alignedQuality?.map((e) => e) || [];
    message.nextMatePosition = (object.nextMatePosition !== undefined && object.nextMatePosition !== null)
      ? Position.fromPartial(object.nextMatePosition)
      : undefined;
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRead_InfoEntry(): Read_InfoEntry {
  return { key: "", value: undefined };
}

export const Read_InfoEntry: MessageFns<Read_InfoEntry> = {
  encode(message: Read_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Read_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRead_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Read_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: Read_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Read_InfoEntry>): Read_InfoEntry {
    return Read_InfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Read_InfoEntry>): Read_InfoEntry {
    const message = createBaseRead_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
