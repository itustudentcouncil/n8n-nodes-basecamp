// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/appengine/v1beta/appengine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../longrunning/operations.js";
import { Empty } from "../../protobuf/empty.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { Application } from "./application.js";
import { AuthorizedCertificate } from "./certificate.js";
import { AuthorizedDomain } from "./domain.js";
import { DomainMapping } from "./domain_mapping.js";
import { FirewallRule } from "./firewall.js";
import { Instance } from "./instance.js";
import { Service } from "./service.js";
import { Version } from "./version.js";

export const protobufPackage = "google.appengine.v1beta";

/**
 * Fields that should be returned when [Version][google.appengine.v1beta.Version] resources
 * are retrieved.
 */
export enum VersionView {
  /**
   * BASIC - Basic version information including scaling and inbound services,
   * but not detailed deployment information.
   */
  BASIC = 0,
  /**
   * FULL - The information from `BASIC`, plus detailed information about the
   * deployment. This format is required when creating resources, but
   * is not returned in `Get` or `List` by default.
   */
  FULL = 1,
  UNRECOGNIZED = -1,
}

export function versionViewFromJSON(object: any): VersionView {
  switch (object) {
    case 0:
    case "BASIC":
      return VersionView.BASIC;
    case 1:
    case "FULL":
      return VersionView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VersionView.UNRECOGNIZED;
  }
}

export function versionViewToJSON(object: VersionView): string {
  switch (object) {
    case VersionView.BASIC:
      return "BASIC";
    case VersionView.FULL:
      return "FULL";
    case VersionView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Fields that should be returned when an AuthorizedCertificate resource is
 * retrieved.
 */
export enum AuthorizedCertificateView {
  /**
   * BASIC_CERTIFICATE - Basic certificate information, including applicable domains and expiration
   * date.
   */
  BASIC_CERTIFICATE = 0,
  /**
   * FULL_CERTIFICATE - The information from `BASIC_CERTIFICATE`, plus detailed information on the
   * domain mappings that have this certificate mapped.
   */
  FULL_CERTIFICATE = 1,
  UNRECOGNIZED = -1,
}

export function authorizedCertificateViewFromJSON(object: any): AuthorizedCertificateView {
  switch (object) {
    case 0:
    case "BASIC_CERTIFICATE":
      return AuthorizedCertificateView.BASIC_CERTIFICATE;
    case 1:
    case "FULL_CERTIFICATE":
      return AuthorizedCertificateView.FULL_CERTIFICATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthorizedCertificateView.UNRECOGNIZED;
  }
}

export function authorizedCertificateViewToJSON(object: AuthorizedCertificateView): string {
  switch (object) {
    case AuthorizedCertificateView.BASIC_CERTIFICATE:
      return "BASIC_CERTIFICATE";
    case AuthorizedCertificateView.FULL_CERTIFICATE:
      return "FULL_CERTIFICATE";
    case AuthorizedCertificateView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Override strategy for mutating an existing mapping. */
export enum DomainOverrideStrategy {
  /** UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY - Strategy unspecified. Defaults to `STRICT`. */
  UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY = 0,
  /**
   * STRICT - Overrides not allowed. If a mapping already exists for the
   * specified domain, the request will return an ALREADY_EXISTS (409).
   */
  STRICT = 1,
  /**
   * OVERRIDE - Overrides allowed. If a mapping already exists for the specified domain,
   * the request will overwrite it. Note that this might stop another
   * Google product from serving. For example, if the domain is
   * mapped to another App Engine application, that app will no
   * longer serve from that domain.
   */
  OVERRIDE = 2,
  UNRECOGNIZED = -1,
}

export function domainOverrideStrategyFromJSON(object: any): DomainOverrideStrategy {
  switch (object) {
    case 0:
    case "UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY":
      return DomainOverrideStrategy.UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY;
    case 1:
    case "STRICT":
      return DomainOverrideStrategy.STRICT;
    case 2:
    case "OVERRIDE":
      return DomainOverrideStrategy.OVERRIDE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DomainOverrideStrategy.UNRECOGNIZED;
  }
}

export function domainOverrideStrategyToJSON(object: DomainOverrideStrategy): string {
  switch (object) {
    case DomainOverrideStrategy.UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY:
      return "UNSPECIFIED_DOMAIN_OVERRIDE_STRATEGY";
    case DomainOverrideStrategy.STRICT:
      return "STRICT";
    case DomainOverrideStrategy.OVERRIDE:
      return "OVERRIDE";
    case DomainOverrideStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for `Applications.GetApplication`. */
export interface GetApplicationRequest {
  /** Name of the Application resource to get. Example: `apps/myapp`. */
  name: string;
}

/** Request message for `Applications.CreateApplication`. */
export interface CreateApplicationRequest {
  /** Application configuration. */
  application: Application | undefined;
}

/** Request message for `Applications.UpdateApplication`. */
export interface UpdateApplicationRequest {
  /** Name of the Application resource to update. Example: `apps/myapp`. */
  name: string;
  /** An Application containing the updated resource. */
  application:
    | Application
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for 'Applications.RepairApplication'. */
export interface RepairApplicationRequest {
  /** Name of the application to repair. Example: `apps/myapp` */
  name: string;
}

/** Request message for `Services.ListServices`. */
export interface ListServicesRequest {
  /** Name of the parent Application resource. Example: `apps/myapp`. */
  parent: string;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `Services.ListServices`. */
export interface ListServicesResponse {
  /** The services belonging to the requested application. */
  services: Service[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `Services.GetService`. */
export interface GetServiceRequest {
  /** Name of the resource requested. Example: `apps/myapp/services/default`. */
  name: string;
}

/** Request message for `Services.UpdateService`. */
export interface UpdateServiceRequest {
  /** Name of the resource to update. Example: `apps/myapp/services/default`. */
  name: string;
  /**
   * A Service resource containing the updated service. Only fields set in the
   * field mask will be updated.
   */
  service:
    | Service
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Set to `true` to gradually shift traffic to one or more versions that you
   * specify. By default, traffic is shifted immediately.
   * For gradual traffic migration, the target versions
   * must be located within instances that are configured for both
   * [warmup requests](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#InboundServiceType)
   * and
   * [automatic scaling](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#AutomaticScaling).
   * You must specify the
   * [`shardBy`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services#ShardBy)
   * field in the Service resource. Gradual traffic migration is not
   * supported in the App Engine flexible environment. For examples, see
   * [Migrating and Splitting Traffic](https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic).
   */
  migrateTraffic: boolean;
}

/** Request message for `Services.DeleteService`. */
export interface DeleteServiceRequest {
  /** Name of the resource requested. Example: `apps/myapp/services/default`. */
  name: string;
}

/** Request message for `Versions.ListVersions`. */
export interface ListVersionsRequest {
  /**
   * Name of the parent Service resource. Example:
   * `apps/myapp/services/default`.
   */
  parent: string;
  /** Controls the set of fields returned in the `List` response. */
  view: VersionView;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `Versions.ListVersions`. */
export interface ListVersionsResponse {
  /** The versions belonging to the requested service. */
  versions: Version[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `Versions.GetVersion`. */
export interface GetVersionRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/services/default/versions/v1`.
   */
  name: string;
  /** Controls the set of fields returned in the `Get` response. */
  view: VersionView;
}

/** Request message for `Versions.CreateVersion`. */
export interface CreateVersionRequest {
  /**
   * Name of the parent resource to create this version under. Example:
   * `apps/myapp/services/default`.
   */
  parent: string;
  /** Application deployment configuration. */
  version: Version | undefined;
}

/** Request message for `Versions.UpdateVersion`. */
export interface UpdateVersionRequest {
  /**
   * Name of the resource to update. Example:
   * `apps/myapp/services/default/versions/1`.
   */
  name: string;
  /**
   * A Version containing the updated resource. Only fields set in the field
   * mask will be updated.
   */
  version:
    | Version
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for `Versions.DeleteVersion`. */
export interface DeleteVersionRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/services/default/versions/v1`.
   */
  name: string;
}

/** Request message for `Instances.ListInstances`. */
export interface ListInstancesRequest {
  /**
   * Name of the parent Version resource. Example:
   * `apps/myapp/services/default/versions/v1`.
   */
  parent: string;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `Instances.ListInstances`. */
export interface ListInstancesResponse {
  /** The instances belonging to the requested version. */
  instances: Instance[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `Instances.GetInstance`. */
export interface GetInstanceRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/services/default/versions/v1/instances/instance-1`.
   */
  name: string;
}

/** Request message for `Instances.DeleteInstance`. */
export interface DeleteInstanceRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/services/default/versions/v1/instances/instance-1`.
   */
  name: string;
}

/** Request message for `Instances.DebugInstance`. */
export interface DebugInstanceRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/services/default/versions/v1/instances/instance-1`.
   */
  name: string;
  /**
   * Public SSH key to add to the instance. Examples:
   *
   * * `[USERNAME]:ssh-rsa [KEY_VALUE] [USERNAME]`
   * * `[USERNAME]:ssh-rsa [KEY_VALUE] google-ssh {"userName":"[USERNAME]","expireOn":"[EXPIRE_TIME]"}`
   *
   * For more information, see
   * [Adding and Removing SSH Keys](https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys).
   */
  sshKey: string;
}

/** Request message for `Firewall.ListIngressRules`. */
export interface ListIngressRulesRequest {
  /**
   * Name of the Firewall collection to retrieve.
   * Example: `apps/myapp/firewall/ingressRules`.
   */
  parent: string;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
  /**
   * A valid IP Address. If set, only rules matching this address will be
   * returned. The first returned rule will be the rule that fires on requests
   * from this IP.
   */
  matchingAddress: string;
}

/** Response message for `Firewall.ListIngressRules`. */
export interface ListIngressRulesResponse {
  /** The ingress FirewallRules for this application. */
  ingressRules: FirewallRule[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `Firewall.BatchUpdateIngressRules`. */
export interface BatchUpdateIngressRulesRequest {
  /**
   * Name of the Firewall collection to set.
   * Example: `apps/myapp/firewall/ingressRules`.
   */
  name: string;
  /** A list of FirewallRules to replace the existing set. */
  ingressRules: FirewallRule[];
}

/** Response message for `Firewall.UpdateAllIngressRules`. */
export interface BatchUpdateIngressRulesResponse {
  /** The full list of ingress FirewallRules for this application. */
  ingressRules: FirewallRule[];
}

/** Request message for `Firewall.CreateIngressRule`. */
export interface CreateIngressRuleRequest {
  /**
   * Name of the parent Firewall collection in which to create a new rule.
   * Example: `apps/myapp/firewall/ingressRules`.
   */
  parent: string;
  /**
   * A FirewallRule containing the new resource.
   *
   * The user may optionally provide a position at which the new rule will be
   * placed. The positions define a sequential list starting at 1. If a rule
   * already exists at the given position, rules greater than the provided
   * position will be moved forward by one.
   *
   * If no position is provided, the server will place the rule as the second to
   * last rule in the sequence before the required default allow-all or deny-all
   * rule.
   */
  rule: FirewallRule | undefined;
}

/** Request message for `Firewall.GetIngressRule`. */
export interface GetIngressRuleRequest {
  /**
   * Name of the Firewall resource to retrieve.
   * Example: `apps/myapp/firewall/ingressRules/100`.
   */
  name: string;
}

/** Request message for `Firewall.UpdateIngressRule`. */
export interface UpdateIngressRuleRequest {
  /**
   * Name of the Firewall resource to update.
   * Example: `apps/myapp/firewall/ingressRules/100`.
   */
  name: string;
  /** A FirewallRule containing the updated resource */
  rule:
    | FirewallRule
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for `Firewall.DeleteIngressRule`. */
export interface DeleteIngressRuleRequest {
  /**
   * Name of the Firewall resource to delete.
   * Example: `apps/myapp/firewall/ingressRules/100`.
   */
  name: string;
}

/** Request message for `AuthorizedDomains.ListAuthorizedDomains`. */
export interface ListAuthorizedDomainsRequest {
  /** Name of the parent Application resource. Example: `apps/myapp`. */
  parent: string;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `AuthorizedDomains.ListAuthorizedDomains`. */
export interface ListAuthorizedDomainsResponse {
  /** The authorized domains belonging to the user. */
  domains: AuthorizedDomain[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `AuthorizedCertificates.ListAuthorizedCertificates`. */
export interface ListAuthorizedCertificatesRequest {
  /** Name of the parent `Application` resource. Example: `apps/myapp`. */
  parent: string;
  /** Controls the set of fields returned in the `LIST` response. */
  view: AuthorizedCertificateView;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `AuthorizedCertificates.ListAuthorizedCertificates`. */
export interface ListAuthorizedCertificatesResponse {
  /** The SSL certificates the user is authorized to administer. */
  certificates: AuthorizedCertificate[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `AuthorizedCertificates.GetAuthorizedCertificate`. */
export interface GetAuthorizedCertificateRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/authorizedCertificates/12345`.
   */
  name: string;
  /** Controls the set of fields returned in the `GET` response. */
  view: AuthorizedCertificateView;
}

/** Request message for `AuthorizedCertificates.CreateAuthorizedCertificate`. */
export interface CreateAuthorizedCertificateRequest {
  /** Name of the parent `Application` resource. Example: `apps/myapp`. */
  parent: string;
  /** SSL certificate data. */
  certificate: AuthorizedCertificate | undefined;
}

/** Request message for `AuthorizedCertificates.UpdateAuthorizedCertificate`. */
export interface UpdateAuthorizedCertificateRequest {
  /**
   * Name of the resource to update. Example:
   * `apps/myapp/authorizedCertificates/12345`.
   */
  name: string;
  /**
   * An `AuthorizedCertificate` containing the updated resource. Only fields set
   * in the field mask will be updated.
   */
  certificate:
    | AuthorizedCertificate
    | undefined;
  /**
   * Standard field mask for the set of fields to be updated. Updates are only
   * supported on the `certificate_raw_data` and `display_name` fields.
   */
  updateMask: string[] | undefined;
}

/** Request message for `AuthorizedCertificates.DeleteAuthorizedCertificate`. */
export interface DeleteAuthorizedCertificateRequest {
  /**
   * Name of the resource to delete. Example:
   * `apps/myapp/authorizedCertificates/12345`.
   */
  name: string;
}

/** Request message for `DomainMappings.ListDomainMappings`. */
export interface ListDomainMappingsRequest {
  /** Name of the parent Application resource. Example: `apps/myapp`. */
  parent: string;
  /** Maximum results to return per page. */
  pageSize: number;
  /** Continuation token for fetching the next page of results. */
  pageToken: string;
}

/** Response message for `DomainMappings.ListDomainMappings`. */
export interface ListDomainMappingsResponse {
  /** The domain mappings for the application. */
  domainMappings: DomainMapping[];
  /** Continuation token for fetching the next page of results. */
  nextPageToken: string;
}

/** Request message for `DomainMappings.GetDomainMapping`. */
export interface GetDomainMappingRequest {
  /**
   * Name of the resource requested. Example:
   * `apps/myapp/domainMappings/example.com`.
   */
  name: string;
}

/** Request message for `DomainMappings.CreateDomainMapping`. */
export interface CreateDomainMappingRequest {
  /** Name of the parent Application resource. Example: `apps/myapp`. */
  parent: string;
  /** Domain mapping configuration. */
  domainMapping:
    | DomainMapping
    | undefined;
  /**
   * Whether the domain creation should override any existing mappings for this
   * domain. By default, overrides are rejected.
   */
  overrideStrategy: DomainOverrideStrategy;
}

/** Request message for `DomainMappings.UpdateDomainMapping`. */
export interface UpdateDomainMappingRequest {
  /**
   * Name of the resource to update. Example:
   * `apps/myapp/domainMappings/example.com`.
   */
  name: string;
  /**
   * A domain mapping containing the updated resource. Only fields set
   * in the field mask will be updated.
   */
  domainMapping:
    | DomainMapping
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for `DomainMappings.DeleteDomainMapping`. */
export interface DeleteDomainMappingRequest {
  /**
   * Name of the resource to delete. Example:
   * `apps/myapp/domainMappings/example.com`.
   */
  name: string;
}

function createBaseGetApplicationRequest(): GetApplicationRequest {
  return { name: "" };
}

export const GetApplicationRequest: MessageFns<GetApplicationRequest> = {
  encode(message: GetApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetApplicationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetApplicationRequest>): GetApplicationRequest {
    return GetApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetApplicationRequest>): GetApplicationRequest {
    const message = createBaseGetApplicationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateApplicationRequest(): CreateApplicationRequest {
  return { application: undefined };
}

export const CreateApplicationRequest: MessageFns<CreateApplicationRequest> = {
  encode(message: CreateApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateApplicationRequest {
    return { application: isSet(object.application) ? Application.fromJSON(object.application) : undefined };
  },

  toJSON(message: CreateApplicationRequest): unknown {
    const obj: any = {};
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateApplicationRequest>): CreateApplicationRequest {
    return CreateApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateApplicationRequest>): CreateApplicationRequest {
    const message = createBaseCreateApplicationRequest();
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    return message;
  },
};

function createBaseUpdateApplicationRequest(): UpdateApplicationRequest {
  return { name: "", application: undefined, updateMask: undefined };
}

export const UpdateApplicationRequest: MessageFns<UpdateApplicationRequest> = {
  encode(message: UpdateApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      application: isSet(object.application) ? Application.fromJSON(object.application) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationRequest>): UpdateApplicationRequest {
    return UpdateApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateApplicationRequest>): UpdateApplicationRequest {
    const message = createBaseUpdateApplicationRequest();
    message.name = object.name ?? "";
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseRepairApplicationRequest(): RepairApplicationRequest {
  return { name: "" };
}

export const RepairApplicationRequest: MessageFns<RepairApplicationRequest> = {
  encode(message: RepairApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairApplicationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RepairApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RepairApplicationRequest>): RepairApplicationRequest {
    return RepairApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairApplicationRequest>): RepairApplicationRequest {
    const message = createBaseRepairApplicationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListServicesRequest(): ListServicesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListServicesRequest: MessageFns<ListServicesRequest> = {
  encode(message: ListServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListServicesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServicesRequest>): ListServicesRequest {
    return ListServicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServicesRequest>): ListServicesRequest {
    const message = createBaseListServicesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListServicesResponse(): ListServicesResponse {
  return { services: [], nextPageToken: "" };
}

export const ListServicesResponse: MessageFns<ListServicesResponse> = {
  encode(message: ListServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServicesResponse>): ListServicesResponse {
    return ListServicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServicesResponse>): ListServicesResponse {
    const message = createBaseListServicesResponse();
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetServiceRequest(): GetServiceRequest {
  return { name: "" };
}

export const GetServiceRequest: MessageFns<GetServiceRequest> = {
  encode(message: GetServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServiceRequest>): GetServiceRequest {
    return GetServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServiceRequest>): GetServiceRequest {
    const message = createBaseGetServiceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateServiceRequest(): UpdateServiceRequest {
  return { name: "", service: undefined, updateMask: undefined, migrateTraffic: false };
}

export const UpdateServiceRequest: MessageFns<UpdateServiceRequest> = {
  encode(message: UpdateServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.service !== undefined) {
      Service.encode(message.service, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.migrateTraffic !== false) {
      writer.uint32(32).bool(message.migrateTraffic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = Service.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.migrateTraffic = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateServiceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      service: isSet(object.service) ? Service.fromJSON(object.service) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      migrateTraffic: isSet(object.migrateTraffic) ? globalThis.Boolean(object.migrateTraffic) : false,
    };
  },

  toJSON(message: UpdateServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.service !== undefined) {
      obj.service = Service.toJSON(message.service);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.migrateTraffic !== false) {
      obj.migrateTraffic = message.migrateTraffic;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateServiceRequest>): UpdateServiceRequest {
    return UpdateServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateServiceRequest>): UpdateServiceRequest {
    const message = createBaseUpdateServiceRequest();
    message.name = object.name ?? "";
    message.service = (object.service !== undefined && object.service !== null)
      ? Service.fromPartial(object.service)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.migrateTraffic = object.migrateTraffic ?? false;
    return message;
  },
};

function createBaseDeleteServiceRequest(): DeleteServiceRequest {
  return { name: "" };
}

export const DeleteServiceRequest: MessageFns<DeleteServiceRequest> = {
  encode(message: DeleteServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteServiceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteServiceRequest>): DeleteServiceRequest {
    return DeleteServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteServiceRequest>): DeleteServiceRequest {
    const message = createBaseDeleteServiceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListVersionsRequest(): ListVersionsRequest {
  return { parent: "", view: 0, pageSize: 0, pageToken: "" };
}

export const ListVersionsRequest: MessageFns<ListVersionsRequest> = {
  encode(message: ListVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      view: isSet(object.view) ? versionViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.view !== 0) {
      obj.view = versionViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVersionsRequest>): ListVersionsRequest {
    return ListVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVersionsRequest>): ListVersionsRequest {
    const message = createBaseListVersionsRequest();
    message.parent = object.parent ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListVersionsResponse(): ListVersionsResponse {
  return { versions: [], nextPageToken: "" };
}

export const ListVersionsResponse: MessageFns<ListVersionsResponse> = {
  encode(message: ListVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.versions) {
      Version.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.versions.push(Version.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVersionsResponse {
    return {
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e: any) => Version.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListVersionsResponse): unknown {
    const obj: any = {};
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => Version.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVersionsResponse>): ListVersionsResponse {
    return ListVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVersionsResponse>): ListVersionsResponse {
    const message = createBaseListVersionsResponse();
    message.versions = object.versions?.map((e) => Version.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetVersionRequest(): GetVersionRequest {
  return { name: "", view: 0 };
}

export const GetVersionRequest: MessageFns<GetVersionRequest> = {
  encode(message: GetVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVersionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? versionViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = versionViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetVersionRequest>): GetVersionRequest {
    return GetVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVersionRequest>): GetVersionRequest {
    const message = createBaseGetVersionRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseCreateVersionRequest(): CreateVersionRequest {
  return { parent: "", version: undefined };
}

export const CreateVersionRequest: MessageFns<CreateVersionRequest> = {
  encode(message: CreateVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.version !== undefined) {
      Version.encode(message.version, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = Version.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVersionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      version: isSet(object.version) ? Version.fromJSON(object.version) : undefined,
    };
  },

  toJSON(message: CreateVersionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.version !== undefined) {
      obj.version = Version.toJSON(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVersionRequest>): CreateVersionRequest {
    return CreateVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVersionRequest>): CreateVersionRequest {
    const message = createBaseCreateVersionRequest();
    message.parent = object.parent ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? Version.fromPartial(object.version)
      : undefined;
    return message;
  },
};

function createBaseUpdateVersionRequest(): UpdateVersionRequest {
  return { name: "", version: undefined, updateMask: undefined };
}

export const UpdateVersionRequest: MessageFns<UpdateVersionRequest> = {
  encode(message: UpdateVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined) {
      Version.encode(message.version, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = Version.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVersionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? Version.fromJSON(object.version) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined) {
      obj.version = Version.toJSON(message.version);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVersionRequest>): UpdateVersionRequest {
    return UpdateVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVersionRequest>): UpdateVersionRequest {
    const message = createBaseUpdateVersionRequest();
    message.name = object.name ?? "";
    message.version = (object.version !== undefined && object.version !== null)
      ? Version.fromPartial(object.version)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteVersionRequest(): DeleteVersionRequest {
  return { name: "" };
}

export const DeleteVersionRequest: MessageFns<DeleteVersionRequest> = {
  encode(message: DeleteVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteVersionRequest>): DeleteVersionRequest {
    return DeleteVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteVersionRequest>): DeleteVersionRequest {
    const message = createBaseDeleteVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "" };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteInstanceRequest(): DeleteInstanceRequest {
  return { name: "" };
}

export const DeleteInstanceRequest: MessageFns<DeleteInstanceRequest> = {
  encode(message: DeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    return DeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    const message = createBaseDeleteInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDebugInstanceRequest(): DebugInstanceRequest {
  return { name: "", sshKey: "" };
}

export const DebugInstanceRequest: MessageFns<DebugInstanceRequest> = {
  encode(message: DebugInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sshKey !== "") {
      writer.uint32(18).string(message.sshKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sshKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sshKey: isSet(object.sshKey) ? globalThis.String(object.sshKey) : "",
    };
  },

  toJSON(message: DebugInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sshKey !== "") {
      obj.sshKey = message.sshKey;
    }
    return obj;
  },

  create(base?: DeepPartial<DebugInstanceRequest>): DebugInstanceRequest {
    return DebugInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DebugInstanceRequest>): DebugInstanceRequest {
    const message = createBaseDebugInstanceRequest();
    message.name = object.name ?? "";
    message.sshKey = object.sshKey ?? "";
    return message;
  },
};

function createBaseListIngressRulesRequest(): ListIngressRulesRequest {
  return { parent: "", pageSize: 0, pageToken: "", matchingAddress: "" };
}

export const ListIngressRulesRequest: MessageFns<ListIngressRulesRequest> = {
  encode(message: ListIngressRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.matchingAddress !== "") {
      writer.uint32(34).string(message.matchingAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIngressRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIngressRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.matchingAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIngressRulesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      matchingAddress: isSet(object.matchingAddress) ? globalThis.String(object.matchingAddress) : "",
    };
  },

  toJSON(message: ListIngressRulesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.matchingAddress !== "") {
      obj.matchingAddress = message.matchingAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIngressRulesRequest>): ListIngressRulesRequest {
    return ListIngressRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIngressRulesRequest>): ListIngressRulesRequest {
    const message = createBaseListIngressRulesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.matchingAddress = object.matchingAddress ?? "";
    return message;
  },
};

function createBaseListIngressRulesResponse(): ListIngressRulesResponse {
  return { ingressRules: [], nextPageToken: "" };
}

export const ListIngressRulesResponse: MessageFns<ListIngressRulesResponse> = {
  encode(message: ListIngressRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ingressRules) {
      FirewallRule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIngressRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIngressRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingressRules.push(FirewallRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIngressRulesResponse {
    return {
      ingressRules: globalThis.Array.isArray(object?.ingressRules)
        ? object.ingressRules.map((e: any) => FirewallRule.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIngressRulesResponse): unknown {
    const obj: any = {};
    if (message.ingressRules?.length) {
      obj.ingressRules = message.ingressRules.map((e) => FirewallRule.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIngressRulesResponse>): ListIngressRulesResponse {
    return ListIngressRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIngressRulesResponse>): ListIngressRulesResponse {
    const message = createBaseListIngressRulesResponse();
    message.ingressRules = object.ingressRules?.map((e) => FirewallRule.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchUpdateIngressRulesRequest(): BatchUpdateIngressRulesRequest {
  return { name: "", ingressRules: [] };
}

export const BatchUpdateIngressRulesRequest: MessageFns<BatchUpdateIngressRulesRequest> = {
  encode(message: BatchUpdateIngressRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ingressRules) {
      FirewallRule.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateIngressRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateIngressRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ingressRules.push(FirewallRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateIngressRulesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ingressRules: globalThis.Array.isArray(object?.ingressRules)
        ? object.ingressRules.map((e: any) => FirewallRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateIngressRulesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ingressRules?.length) {
      obj.ingressRules = message.ingressRules.map((e) => FirewallRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateIngressRulesRequest>): BatchUpdateIngressRulesRequest {
    return BatchUpdateIngressRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateIngressRulesRequest>): BatchUpdateIngressRulesRequest {
    const message = createBaseBatchUpdateIngressRulesRequest();
    message.name = object.name ?? "";
    message.ingressRules = object.ingressRules?.map((e) => FirewallRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateIngressRulesResponse(): BatchUpdateIngressRulesResponse {
  return { ingressRules: [] };
}

export const BatchUpdateIngressRulesResponse: MessageFns<BatchUpdateIngressRulesResponse> = {
  encode(message: BatchUpdateIngressRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ingressRules) {
      FirewallRule.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateIngressRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateIngressRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingressRules.push(FirewallRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateIngressRulesResponse {
    return {
      ingressRules: globalThis.Array.isArray(object?.ingressRules)
        ? object.ingressRules.map((e: any) => FirewallRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateIngressRulesResponse): unknown {
    const obj: any = {};
    if (message.ingressRules?.length) {
      obj.ingressRules = message.ingressRules.map((e) => FirewallRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateIngressRulesResponse>): BatchUpdateIngressRulesResponse {
    return BatchUpdateIngressRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateIngressRulesResponse>): BatchUpdateIngressRulesResponse {
    const message = createBaseBatchUpdateIngressRulesResponse();
    message.ingressRules = object.ingressRules?.map((e) => FirewallRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateIngressRuleRequest(): CreateIngressRuleRequest {
  return { parent: "", rule: undefined };
}

export const CreateIngressRuleRequest: MessageFns<CreateIngressRuleRequest> = {
  encode(message: CreateIngressRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.rule !== undefined) {
      FirewallRule.encode(message.rule, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIngressRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIngressRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rule = FirewallRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIngressRuleRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      rule: isSet(object.rule) ? FirewallRule.fromJSON(object.rule) : undefined,
    };
  },

  toJSON(message: CreateIngressRuleRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.rule !== undefined) {
      obj.rule = FirewallRule.toJSON(message.rule);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIngressRuleRequest>): CreateIngressRuleRequest {
    return CreateIngressRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIngressRuleRequest>): CreateIngressRuleRequest {
    const message = createBaseCreateIngressRuleRequest();
    message.parent = object.parent ?? "";
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? FirewallRule.fromPartial(object.rule)
      : undefined;
    return message;
  },
};

function createBaseGetIngressRuleRequest(): GetIngressRuleRequest {
  return { name: "" };
}

export const GetIngressRuleRequest: MessageFns<GetIngressRuleRequest> = {
  encode(message: GetIngressRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIngressRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIngressRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIngressRuleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIngressRuleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIngressRuleRequest>): GetIngressRuleRequest {
    return GetIngressRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIngressRuleRequest>): GetIngressRuleRequest {
    const message = createBaseGetIngressRuleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateIngressRuleRequest(): UpdateIngressRuleRequest {
  return { name: "", rule: undefined, updateMask: undefined };
}

export const UpdateIngressRuleRequest: MessageFns<UpdateIngressRuleRequest> = {
  encode(message: UpdateIngressRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.rule !== undefined) {
      FirewallRule.encode(message.rule, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIngressRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIngressRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rule = FirewallRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIngressRuleRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rule: isSet(object.rule) ? FirewallRule.fromJSON(object.rule) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIngressRuleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rule !== undefined) {
      obj.rule = FirewallRule.toJSON(message.rule);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIngressRuleRequest>): UpdateIngressRuleRequest {
    return UpdateIngressRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIngressRuleRequest>): UpdateIngressRuleRequest {
    const message = createBaseUpdateIngressRuleRequest();
    message.name = object.name ?? "";
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? FirewallRule.fromPartial(object.rule)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteIngressRuleRequest(): DeleteIngressRuleRequest {
  return { name: "" };
}

export const DeleteIngressRuleRequest: MessageFns<DeleteIngressRuleRequest> = {
  encode(message: DeleteIngressRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIngressRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIngressRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIngressRuleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIngressRuleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIngressRuleRequest>): DeleteIngressRuleRequest {
    return DeleteIngressRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIngressRuleRequest>): DeleteIngressRuleRequest {
    const message = createBaseDeleteIngressRuleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAuthorizedDomainsRequest(): ListAuthorizedDomainsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAuthorizedDomainsRequest: MessageFns<ListAuthorizedDomainsRequest> = {
  encode(message: ListAuthorizedDomainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuthorizedDomainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuthorizedDomainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuthorizedDomainsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAuthorizedDomainsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAuthorizedDomainsRequest>): ListAuthorizedDomainsRequest {
    return ListAuthorizedDomainsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAuthorizedDomainsRequest>): ListAuthorizedDomainsRequest {
    const message = createBaseListAuthorizedDomainsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAuthorizedDomainsResponse(): ListAuthorizedDomainsResponse {
  return { domains: [], nextPageToken: "" };
}

export const ListAuthorizedDomainsResponse: MessageFns<ListAuthorizedDomainsResponse> = {
  encode(message: ListAuthorizedDomainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.domains) {
      AuthorizedDomain.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuthorizedDomainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuthorizedDomainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domains.push(AuthorizedDomain.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuthorizedDomainsResponse {
    return {
      domains: globalThis.Array.isArray(object?.domains)
        ? object.domains.map((e: any) => AuthorizedDomain.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAuthorizedDomainsResponse): unknown {
    const obj: any = {};
    if (message.domains?.length) {
      obj.domains = message.domains.map((e) => AuthorizedDomain.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAuthorizedDomainsResponse>): ListAuthorizedDomainsResponse {
    return ListAuthorizedDomainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAuthorizedDomainsResponse>): ListAuthorizedDomainsResponse {
    const message = createBaseListAuthorizedDomainsResponse();
    message.domains = object.domains?.map((e) => AuthorizedDomain.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListAuthorizedCertificatesRequest(): ListAuthorizedCertificatesRequest {
  return { parent: "", view: 0, pageSize: 0, pageToken: "" };
}

export const ListAuthorizedCertificatesRequest: MessageFns<ListAuthorizedCertificatesRequest> = {
  encode(message: ListAuthorizedCertificatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuthorizedCertificatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuthorizedCertificatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuthorizedCertificatesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      view: isSet(object.view) ? authorizedCertificateViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAuthorizedCertificatesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.view !== 0) {
      obj.view = authorizedCertificateViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAuthorizedCertificatesRequest>): ListAuthorizedCertificatesRequest {
    return ListAuthorizedCertificatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAuthorizedCertificatesRequest>): ListAuthorizedCertificatesRequest {
    const message = createBaseListAuthorizedCertificatesRequest();
    message.parent = object.parent ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAuthorizedCertificatesResponse(): ListAuthorizedCertificatesResponse {
  return { certificates: [], nextPageToken: "" };
}

export const ListAuthorizedCertificatesResponse: MessageFns<ListAuthorizedCertificatesResponse> = {
  encode(message: ListAuthorizedCertificatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.certificates) {
      AuthorizedCertificate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuthorizedCertificatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuthorizedCertificatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificates.push(AuthorizedCertificate.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuthorizedCertificatesResponse {
    return {
      certificates: globalThis.Array.isArray(object?.certificates)
        ? object.certificates.map((e: any) => AuthorizedCertificate.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAuthorizedCertificatesResponse): unknown {
    const obj: any = {};
    if (message.certificates?.length) {
      obj.certificates = message.certificates.map((e) => AuthorizedCertificate.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAuthorizedCertificatesResponse>): ListAuthorizedCertificatesResponse {
    return ListAuthorizedCertificatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAuthorizedCertificatesResponse>): ListAuthorizedCertificatesResponse {
    const message = createBaseListAuthorizedCertificatesResponse();
    message.certificates = object.certificates?.map((e) => AuthorizedCertificate.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetAuthorizedCertificateRequest(): GetAuthorizedCertificateRequest {
  return { name: "", view: 0 };
}

export const GetAuthorizedCertificateRequest: MessageFns<GetAuthorizedCertificateRequest> = {
  encode(message: GetAuthorizedCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthorizedCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthorizedCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuthorizedCertificateRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? authorizedCertificateViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetAuthorizedCertificateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = authorizedCertificateViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAuthorizedCertificateRequest>): GetAuthorizedCertificateRequest {
    return GetAuthorizedCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAuthorizedCertificateRequest>): GetAuthorizedCertificateRequest {
    const message = createBaseGetAuthorizedCertificateRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseCreateAuthorizedCertificateRequest(): CreateAuthorizedCertificateRequest {
  return { parent: "", certificate: undefined };
}

export const CreateAuthorizedCertificateRequest: MessageFns<CreateAuthorizedCertificateRequest> = {
  encode(message: CreateAuthorizedCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.certificate !== undefined) {
      AuthorizedCertificate.encode(message.certificate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAuthorizedCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAuthorizedCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificate = AuthorizedCertificate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAuthorizedCertificateRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      certificate: isSet(object.certificate) ? AuthorizedCertificate.fromJSON(object.certificate) : undefined,
    };
  },

  toJSON(message: CreateAuthorizedCertificateRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.certificate !== undefined) {
      obj.certificate = AuthorizedCertificate.toJSON(message.certificate);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAuthorizedCertificateRequest>): CreateAuthorizedCertificateRequest {
    return CreateAuthorizedCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAuthorizedCertificateRequest>): CreateAuthorizedCertificateRequest {
    const message = createBaseCreateAuthorizedCertificateRequest();
    message.parent = object.parent ?? "";
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? AuthorizedCertificate.fromPartial(object.certificate)
      : undefined;
    return message;
  },
};

function createBaseUpdateAuthorizedCertificateRequest(): UpdateAuthorizedCertificateRequest {
  return { name: "", certificate: undefined, updateMask: undefined };
}

export const UpdateAuthorizedCertificateRequest: MessageFns<UpdateAuthorizedCertificateRequest> = {
  encode(message: UpdateAuthorizedCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.certificate !== undefined) {
      AuthorizedCertificate.encode(message.certificate, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAuthorizedCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAuthorizedCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificate = AuthorizedCertificate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAuthorizedCertificateRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      certificate: isSet(object.certificate) ? AuthorizedCertificate.fromJSON(object.certificate) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAuthorizedCertificateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.certificate !== undefined) {
      obj.certificate = AuthorizedCertificate.toJSON(message.certificate);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAuthorizedCertificateRequest>): UpdateAuthorizedCertificateRequest {
    return UpdateAuthorizedCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAuthorizedCertificateRequest>): UpdateAuthorizedCertificateRequest {
    const message = createBaseUpdateAuthorizedCertificateRequest();
    message.name = object.name ?? "";
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? AuthorizedCertificate.fromPartial(object.certificate)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAuthorizedCertificateRequest(): DeleteAuthorizedCertificateRequest {
  return { name: "" };
}

export const DeleteAuthorizedCertificateRequest: MessageFns<DeleteAuthorizedCertificateRequest> = {
  encode(message: DeleteAuthorizedCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAuthorizedCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAuthorizedCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAuthorizedCertificateRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAuthorizedCertificateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAuthorizedCertificateRequest>): DeleteAuthorizedCertificateRequest {
    return DeleteAuthorizedCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAuthorizedCertificateRequest>): DeleteAuthorizedCertificateRequest {
    const message = createBaseDeleteAuthorizedCertificateRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDomainMappingsRequest(): ListDomainMappingsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDomainMappingsRequest: MessageFns<ListDomainMappingsRequest> = {
  encode(message: ListDomainMappingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDomainMappingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDomainMappingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDomainMappingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDomainMappingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDomainMappingsRequest>): ListDomainMappingsRequest {
    return ListDomainMappingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDomainMappingsRequest>): ListDomainMappingsRequest {
    const message = createBaseListDomainMappingsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDomainMappingsResponse(): ListDomainMappingsResponse {
  return { domainMappings: [], nextPageToken: "" };
}

export const ListDomainMappingsResponse: MessageFns<ListDomainMappingsResponse> = {
  encode(message: ListDomainMappingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.domainMappings) {
      DomainMapping.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDomainMappingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDomainMappingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainMappings.push(DomainMapping.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDomainMappingsResponse {
    return {
      domainMappings: globalThis.Array.isArray(object?.domainMappings)
        ? object.domainMappings.map((e: any) => DomainMapping.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDomainMappingsResponse): unknown {
    const obj: any = {};
    if (message.domainMappings?.length) {
      obj.domainMappings = message.domainMappings.map((e) => DomainMapping.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDomainMappingsResponse>): ListDomainMappingsResponse {
    return ListDomainMappingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDomainMappingsResponse>): ListDomainMappingsResponse {
    const message = createBaseListDomainMappingsResponse();
    message.domainMappings = object.domainMappings?.map((e) => DomainMapping.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetDomainMappingRequest(): GetDomainMappingRequest {
  return { name: "" };
}

export const GetDomainMappingRequest: MessageFns<GetDomainMappingRequest> = {
  encode(message: GetDomainMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDomainMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDomainMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDomainMappingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDomainMappingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDomainMappingRequest>): GetDomainMappingRequest {
    return GetDomainMappingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDomainMappingRequest>): GetDomainMappingRequest {
    const message = createBaseGetDomainMappingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDomainMappingRequest(): CreateDomainMappingRequest {
  return { parent: "", domainMapping: undefined, overrideStrategy: 0 };
}

export const CreateDomainMappingRequest: MessageFns<CreateDomainMappingRequest> = {
  encode(message: CreateDomainMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.domainMapping !== undefined) {
      DomainMapping.encode(message.domainMapping, writer.uint32(18).fork()).join();
    }
    if (message.overrideStrategy !== 0) {
      writer.uint32(32).int32(message.overrideStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDomainMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDomainMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domainMapping = DomainMapping.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.overrideStrategy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDomainMappingRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      domainMapping: isSet(object.domainMapping) ? DomainMapping.fromJSON(object.domainMapping) : undefined,
      overrideStrategy: isSet(object.overrideStrategy) ? domainOverrideStrategyFromJSON(object.overrideStrategy) : 0,
    };
  },

  toJSON(message: CreateDomainMappingRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.domainMapping !== undefined) {
      obj.domainMapping = DomainMapping.toJSON(message.domainMapping);
    }
    if (message.overrideStrategy !== 0) {
      obj.overrideStrategy = domainOverrideStrategyToJSON(message.overrideStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDomainMappingRequest>): CreateDomainMappingRequest {
    return CreateDomainMappingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDomainMappingRequest>): CreateDomainMappingRequest {
    const message = createBaseCreateDomainMappingRequest();
    message.parent = object.parent ?? "";
    message.domainMapping = (object.domainMapping !== undefined && object.domainMapping !== null)
      ? DomainMapping.fromPartial(object.domainMapping)
      : undefined;
    message.overrideStrategy = object.overrideStrategy ?? 0;
    return message;
  },
};

function createBaseUpdateDomainMappingRequest(): UpdateDomainMappingRequest {
  return { name: "", domainMapping: undefined, updateMask: undefined };
}

export const UpdateDomainMappingRequest: MessageFns<UpdateDomainMappingRequest> = {
  encode(message: UpdateDomainMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.domainMapping !== undefined) {
      DomainMapping.encode(message.domainMapping, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDomainMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDomainMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domainMapping = DomainMapping.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDomainMappingRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      domainMapping: isSet(object.domainMapping) ? DomainMapping.fromJSON(object.domainMapping) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDomainMappingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.domainMapping !== undefined) {
      obj.domainMapping = DomainMapping.toJSON(message.domainMapping);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDomainMappingRequest>): UpdateDomainMappingRequest {
    return UpdateDomainMappingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDomainMappingRequest>): UpdateDomainMappingRequest {
    const message = createBaseUpdateDomainMappingRequest();
    message.name = object.name ?? "";
    message.domainMapping = (object.domainMapping !== undefined && object.domainMapping !== null)
      ? DomainMapping.fromPartial(object.domainMapping)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteDomainMappingRequest(): DeleteDomainMappingRequest {
  return { name: "" };
}

export const DeleteDomainMappingRequest: MessageFns<DeleteDomainMappingRequest> = {
  encode(message: DeleteDomainMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDomainMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDomainMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDomainMappingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDomainMappingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDomainMappingRequest>): DeleteDomainMappingRequest {
    return DeleteDomainMappingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDomainMappingRequest>): DeleteDomainMappingRequest {
    const message = createBaseDeleteDomainMappingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/** Manages App Engine applications. */
export type ApplicationsDefinition = typeof ApplicationsDefinition;
export const ApplicationsDefinition = {
  name: "Applications",
  fullName: "google.appengine.v1beta.Applications",
  methods: {
    /** Gets information about an application. */
    getApplication: {
      name: "GetApplication",
      requestType: GetApplicationRequest,
      requestStream: false,
      responseType: Application,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              23,
              18,
              21,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an App Engine application for a Google Cloud Platform project.
     * Required fields:
     *
     * * `id` - The ID of the target Cloud Platform project.
     * * *location* - The [region](https://cloud.google.com/appengine/docs/locations) where you want the App Engine application located.
     *
     * For more information about App Engine applications, see [Managing Projects, Applications, and Billing](https://cloud.google.com/appengine/docs/standard/python/console/).
     */
    createApplication: {
      name: "CreateApplication",
      requestType: CreateApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              11,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              27,
              58,
              11,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              34,
              12,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              97,
              112,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified Application resource.
     * You can update the following fields:
     *
     * * `auth_domain` - Google authentication domain for controlling user access to the application.
     * * `default_cookie_expiration` - Cookie expiration policy for the application.
     */
    updateApplication: {
      name: "UpdateApplication",
      requestType: UpdateApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              11,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              36,
              58,
              11,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              50,
              21,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Recreates the required App Engine features for the specified App Engine
     * application, for example a Cloud Storage bucket or App Engine service
     * account.
     * Use this method if you receive an error message about a missing feature,
     * for example, *Error retrieving the App Engine service account*.
     * If you have deleted your App Engine service account, this will
     * not be able to recreate it. Instead, you should attempt to use the
     * IAM undelete API if possible at https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/undelete?apix_params=%7B"name"%3A"projects%2F-%2FserviceAccounts%2Funique_id"%2C"resource"%3A%7B%7D%7D .
     * If the deletion was recent, the numeric ID can be found in the Cloud
     * Console Activity Log.
     */
    repairApplication: {
      name: "RepairApplication",
      requestType: RepairApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              11,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              33,
              58,
              1,
              42,
              34,
              28,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              112,
              97,
              105,
              114,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ApplicationsServiceImplementation<CallContextExt = {}> {
  /** Gets information about an application. */
  getApplication(
    request: GetApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Application>>;
  /**
   * Creates an App Engine application for a Google Cloud Platform project.
   * Required fields:
   *
   * * `id` - The ID of the target Cloud Platform project.
   * * *location* - The [region](https://cloud.google.com/appengine/docs/locations) where you want the App Engine application located.
   *
   * For more information about App Engine applications, see [Managing Projects, Applications, and Billing](https://cloud.google.com/appengine/docs/standard/python/console/).
   */
  createApplication(
    request: CreateApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the specified Application resource.
   * You can update the following fields:
   *
   * * `auth_domain` - Google authentication domain for controlling user access to the application.
   * * `default_cookie_expiration` - Cookie expiration policy for the application.
   */
  updateApplication(
    request: UpdateApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Recreates the required App Engine features for the specified App Engine
   * application, for example a Cloud Storage bucket or App Engine service
   * account.
   * Use this method if you receive an error message about a missing feature,
   * for example, *Error retrieving the App Engine service account*.
   * If you have deleted your App Engine service account, this will
   * not be able to recreate it. Instead, you should attempt to use the
   * IAM undelete API if possible at https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/undelete?apix_params=%7B"name"%3A"projects%2F-%2FserviceAccounts%2Funique_id"%2C"resource"%3A%7B%7D%7D .
   * If the deletion was recent, the numeric ID can be found in the Cloud
   * Console Activity Log.
   */
  repairApplication(
    request: RepairApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface ApplicationsClient<CallOptionsExt = {}> {
  /** Gets information about an application. */
  getApplication(
    request: DeepPartial<GetApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Application>;
  /**
   * Creates an App Engine application for a Google Cloud Platform project.
   * Required fields:
   *
   * * `id` - The ID of the target Cloud Platform project.
   * * *location* - The [region](https://cloud.google.com/appengine/docs/locations) where you want the App Engine application located.
   *
   * For more information about App Engine applications, see [Managing Projects, Applications, and Billing](https://cloud.google.com/appengine/docs/standard/python/console/).
   */
  createApplication(
    request: DeepPartial<CreateApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the specified Application resource.
   * You can update the following fields:
   *
   * * `auth_domain` - Google authentication domain for controlling user access to the application.
   * * `default_cookie_expiration` - Cookie expiration policy for the application.
   */
  updateApplication(
    request: DeepPartial<UpdateApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Recreates the required App Engine features for the specified App Engine
   * application, for example a Cloud Storage bucket or App Engine service
   * account.
   * Use this method if you receive an error message about a missing feature,
   * for example, *Error retrieving the App Engine service account*.
   * If you have deleted your App Engine service account, this will
   * not be able to recreate it. Instead, you should attempt to use the
   * IAM undelete API if possible at https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/undelete?apix_params=%7B"name"%3A"projects%2F-%2FserviceAccounts%2Funique_id"%2C"resource"%3A%7B%7D%7D .
   * If the deletion was recent, the numeric ID can be found in the Cloud
   * Console Activity Log.
   */
  repairApplication(
    request: DeepPartial<RepairApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

/** Manages services of an application. */
export type ServicesDefinition = typeof ServicesDefinition;
export const ServicesDefinition = {
  name: "Services",
  fullName: "google.appengine.v1beta.Services",
  methods: {
    /** Lists all the services in the application. */
    listServices: {
      name: "ListServices",
      requestType: ListServicesRequest,
      requestStream: false,
      responseType: ListServicesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the current configuration of the specified service. */
    getService: {
      name: "GetService",
      requestType: GetServiceRequest,
      requestStream: false,
      responseType: Service,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the configuration of the specified service. */
    updateService: {
      name: "UpdateService",
      requestType: UpdateServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              7,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              43,
              58,
              7,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              50,
              32,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified service and all enclosed versions. */
    deleteService: {
      name: "DeleteService",
      requestType: DeleteServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              34,
              42,
              32,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ServicesServiceImplementation<CallContextExt = {}> {
  /** Lists all the services in the application. */
  listServices(
    request: ListServicesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListServicesResponse>>;
  /** Gets the current configuration of the specified service. */
  getService(request: GetServiceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Service>>;
  /** Updates the configuration of the specified service. */
  updateService(request: UpdateServiceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes the specified service and all enclosed versions. */
  deleteService(request: DeleteServiceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface ServicesClient<CallOptionsExt = {}> {
  /** Lists all the services in the application. */
  listServices(
    request: DeepPartial<ListServicesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListServicesResponse>;
  /** Gets the current configuration of the specified service. */
  getService(request: DeepPartial<GetServiceRequest>, options?: CallOptions & CallOptionsExt): Promise<Service>;
  /** Updates the configuration of the specified service. */
  updateService(request: DeepPartial<UpdateServiceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes the specified service and all enclosed versions. */
  deleteService(request: DeepPartial<DeleteServiceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

/** Manages versions of a service. */
export type VersionsDefinition = typeof VersionsDefinition;
export const VersionsDefinition = {
  name: "Versions",
  fullName: "google.appengine.v1beta.Versions",
  methods: {
    /** Lists the versions of a service. */
    listVersions: {
      name: "ListVersions",
      requestType: ListVersionsRequest,
      requestStream: false,
      responseType: ListVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the specified Version resource.
     * By default, only a `BASIC_VIEW` will be returned.
     * Specify the `FULL_VIEW` parameter to get the full resource.
     */
    getVersion: {
      name: "GetVersion",
      requestType: GetVersionRequest,
      requestStream: false,
      responseType: Version,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deploys code and resource files to a new version. */
    createVersion: {
      name: "CreateVersion",
      requestType: CreateVersionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              7,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              18,
              27,
              67,
              114,
              101,
              97,
              116,
              101,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              54,
              58,
              7,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              34,
              43,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified Version resource.
     * You can specify the following fields depending on the App Engine
     * environment and type of scaling that the version resource uses:
     *
     * **Standard environment**
     *
     * * [`instance_class`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.instance_class)
     *
     * *automatic scaling* in the standard environment:
     *
     * * [`automatic_scaling.min_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     * * [`automatic_scaling.max_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     * * [`automaticScaling.standard_scheduler_settings.max_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
     * * [`automaticScaling.standard_scheduler_settings.min_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
     * * [`automaticScaling.standard_scheduler_settings.target_cpu_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
     * * [`automaticScaling.standard_scheduler_settings.target_throughput_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
     *
     * *basic scaling* or *manual scaling* in the standard environment:
     *
     * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
     * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
     *
     * **Flexible environment**
     *
     * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
     *
     * *automatic scaling* in the flexible environment:
     *
     * * [`automatic_scaling.min_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     * * [`automatic_scaling.max_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     * * [`automatic_scaling.cool_down_period_sec`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     * * [`automatic_scaling.cpu_utilization.target_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
     *
     * *manual scaling* in the flexible environment:
     *
     * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
     */
    updateVersion: {
      name: "UpdateVersion",
      requestType: UpdateVersionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              7,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              54,
              58,
              7,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              50,
              43,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes an existing Version resource. */
    deleteVersion: {
      name: "DeleteVersion",
      requestType: DeleteVersionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface VersionsServiceImplementation<CallContextExt = {}> {
  /** Lists the versions of a service. */
  listVersions(
    request: ListVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListVersionsResponse>>;
  /**
   * Gets the specified Version resource.
   * By default, only a `BASIC_VIEW` will be returned.
   * Specify the `FULL_VIEW` parameter to get the full resource.
   */
  getVersion(request: GetVersionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Version>>;
  /** Deploys code and resource files to a new version. */
  createVersion(request: CreateVersionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Updates the specified Version resource.
   * You can specify the following fields depending on the App Engine
   * environment and type of scaling that the version resource uses:
   *
   * **Standard environment**
   *
   * * [`instance_class`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.instance_class)
   *
   * *automatic scaling* in the standard environment:
   *
   * * [`automatic_scaling.min_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.max_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automaticScaling.standard_scheduler_settings.max_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.min_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.target_cpu_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.target_throughput_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   *
   * *basic scaling* or *manual scaling* in the standard environment:
   *
   * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
   * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
   *
   * **Flexible environment**
   *
   * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
   *
   * *automatic scaling* in the flexible environment:
   *
   * * [`automatic_scaling.min_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.max_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.cool_down_period_sec`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.cpu_utilization.target_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   *
   * *manual scaling* in the flexible environment:
   *
   * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
   */
  updateVersion(request: UpdateVersionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes an existing Version resource. */
  deleteVersion(request: DeleteVersionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface VersionsClient<CallOptionsExt = {}> {
  /** Lists the versions of a service. */
  listVersions(
    request: DeepPartial<ListVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListVersionsResponse>;
  /**
   * Gets the specified Version resource.
   * By default, only a `BASIC_VIEW` will be returned.
   * Specify the `FULL_VIEW` parameter to get the full resource.
   */
  getVersion(request: DeepPartial<GetVersionRequest>, options?: CallOptions & CallOptionsExt): Promise<Version>;
  /** Deploys code and resource files to a new version. */
  createVersion(request: DeepPartial<CreateVersionRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Updates the specified Version resource.
   * You can specify the following fields depending on the App Engine
   * environment and type of scaling that the version resource uses:
   *
   * **Standard environment**
   *
   * * [`instance_class`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.instance_class)
   *
   * *automatic scaling* in the standard environment:
   *
   * * [`automatic_scaling.min_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.max_idle_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automaticScaling.standard_scheduler_settings.max_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.min_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.target_cpu_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   * * [`automaticScaling.standard_scheduler_settings.target_throughput_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StandardSchedulerSettings)
   *
   * *basic scaling* or *manual scaling* in the standard environment:
   *
   * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
   * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
   *
   * **Flexible environment**
   *
   * * [`serving_status`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.serving_status)
   *
   * *automatic scaling* in the flexible environment:
   *
   * * [`automatic_scaling.min_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.max_total_instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.cool_down_period_sec`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   * * [`automatic_scaling.cpu_utilization.target_utilization`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#Version.FIELDS.automatic_scaling)
   *
   * *manual scaling* in the flexible environment:
   *
   * * [`manual_scaling.instances`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#manualscaling)
   */
  updateVersion(request: DeepPartial<UpdateVersionRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes an existing Version resource. */
  deleteVersion(request: DeepPartial<DeleteVersionRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

/** Manages instances of a version. */
export type InstancesDefinition = typeof InstancesDefinition;
export const InstancesDefinition = {
  name: "Instances",
  fullName: "google.appengine.v1beta.Instances",
  methods: {
    /**
     * Lists the instances of a version.
     *
     * Tip: To aggregate details about instances over time, see the
     * [Stackdriver Monitoring API](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
     */
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets instance information. */
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Stops a running instance.
     *
     * The instance might be automatically recreated based on the scaling settings
     * of the version. For more information, see "How Instances are Managed"
     * ([standard environment](https://cloud.google.com/appengine/docs/standard/python/how-instances-are-managed) |
     * [flexible environment](https://cloud.google.com/appengine/docs/flexible/python/how-instances-are-managed)).
     *
     * To ensure that instances are not re-created and avoid getting billed, you
     * can stop all instances within the target version by changing the serving
     * status of the version to `STOPPED` with the
     * [`apps.services.versions.patch`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions/patch)
     * method.
     */
    deleteInstance: {
      name: "DeleteInstance",
      requestType: DeleteInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              42,
              55,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Enables debugging on a VM instance. This allows you to use the SSH
     * command to connect to the virtual machine where the instance lives.
     * While in "debug mode", the instance continues to serve live traffic.
     * You should delete the instance when you are done debugging and then
     * allow the system to take over and determine if another instance
     * should be started.
     *
     * Only applicable for instances in App Engine flexible environment.
     */
    debugInstance: {
      name: "DebugInstance",
      requestType: DebugInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              47,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              98,
              117,
              103,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface InstancesServiceImplementation<CallContextExt = {}> {
  /**
   * Lists the instances of a version.
   *
   * Tip: To aggregate details about instances over time, see the
   * [Stackdriver Monitoring API](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   */
  listInstances(
    request: ListInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancesResponse>>;
  /** Gets instance information. */
  getInstance(request: GetInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Instance>>;
  /**
   * Stops a running instance.
   *
   * The instance might be automatically recreated based on the scaling settings
   * of the version. For more information, see "How Instances are Managed"
   * ([standard environment](https://cloud.google.com/appengine/docs/standard/python/how-instances-are-managed) |
   * [flexible environment](https://cloud.google.com/appengine/docs/flexible/python/how-instances-are-managed)).
   *
   * To ensure that instances are not re-created and avoid getting billed, you
   * can stop all instances within the target version by changing the serving
   * status of the version to `STOPPED` with the
   * [`apps.services.versions.patch`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions/patch)
   * method.
   */
  deleteInstance(
    request: DeleteInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Enables debugging on a VM instance. This allows you to use the SSH
   * command to connect to the virtual machine where the instance lives.
   * While in "debug mode", the instance continues to serve live traffic.
   * You should delete the instance when you are done debugging and then
   * allow the system to take over and determine if another instance
   * should be started.
   *
   * Only applicable for instances in App Engine flexible environment.
   */
  debugInstance(request: DebugInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface InstancesClient<CallOptionsExt = {}> {
  /**
   * Lists the instances of a version.
   *
   * Tip: To aggregate details about instances over time, see the
   * [Stackdriver Monitoring API](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   */
  listInstances(
    request: DeepPartial<ListInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancesResponse>;
  /** Gets instance information. */
  getInstance(request: DeepPartial<GetInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Instance>;
  /**
   * Stops a running instance.
   *
   * The instance might be automatically recreated based on the scaling settings
   * of the version. For more information, see "How Instances are Managed"
   * ([standard environment](https://cloud.google.com/appengine/docs/standard/python/how-instances-are-managed) |
   * [flexible environment](https://cloud.google.com/appengine/docs/flexible/python/how-instances-are-managed)).
   *
   * To ensure that instances are not re-created and avoid getting billed, you
   * can stop all instances within the target version by changing the serving
   * status of the version to `STOPPED` with the
   * [`apps.services.versions.patch`](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions/patch)
   * method.
   */
  deleteInstance(
    request: DeepPartial<DeleteInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Enables debugging on a VM instance. This allows you to use the SSH
   * command to connect to the virtual machine where the instance lives.
   * While in "debug mode", the instance continues to serve live traffic.
   * You should delete the instance when you are done debugging and then
   * allow the system to take over and determine if another instance
   * should be started.
   *
   * Only applicable for instances in App Engine flexible environment.
   */
  debugInstance(request: DeepPartial<DebugInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

/**
 * Firewall resources are used to define a collection of access control rules
 * for an Application. Each rule is defined with a position which specifies
 * the rule's order in the sequence of rules, an IP range to be matched against
 * requests, and an action to take upon matching requests.
 *
 * Every request is evaluated against the Firewall rules in priority order.
 * Processesing stops at the first rule which matches the request's IP address.
 * A final rule always specifies an action that applies to all remaining
 * IP addresses. The default final rule for a newly-created application will be
 * set to "allow" if not otherwise specified by the user.
 */
export type FirewallDefinition = typeof FirewallDefinition;
export const FirewallDefinition = {
  name: "Firewall",
  fullName: "google.appengine.v1beta.Firewall",
  methods: {
    /** Lists the firewall rules of an application. */
    listIngressRules: {
      name: "ListIngressRules",
      requestType: ListIngressRulesRequest,
      requestStream: false,
      responseType: ListIngressRulesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Replaces the entire firewall ruleset in one bulk operation. This overrides
     * and replaces the rules of an existing firewall with the new rules.
     *
     * If the final rule does not match traffic with the '*' wildcard IP range,
     * then an "allow all" rule is explicitly added to the end of the list.
     */
    batchUpdateIngressRules: {
      name: "BatchUpdateIngressRules",
      requestType: BatchUpdateIngressRulesRequest,
      requestStream: false,
      responseType: BatchUpdateIngressRulesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a firewall rule for the application. */
    createIngressRule: {
      name: "CreateIngressRule",
      requestType: CreateIngressRuleRequest,
      requestStream: false,
      responseType: FirewallRule,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              58,
              4,
              114,
              117,
              108,
              101,
              34,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified firewall rule. */
    getIngressRule: {
      name: "GetIngressRule",
      requestType: GetIngressRuleRequest,
      requestStream: false,
      responseType: FirewallRule,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified firewall rule. */
    updateIngressRule: {
      name: "UpdateIngressRule",
      requestType: UpdateIngressRuleRequest,
      requestStream: false,
      responseType: FirewallRule,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              58,
              4,
              114,
              117,
              108,
              101,
              50,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified firewall rule. */
    deleteIngressRule: {
      name: "DeleteIngressRule",
      requestType: DeleteIngressRuleRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              42,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              47,
              105,
              110,
              103,
              114,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FirewallServiceImplementation<CallContextExt = {}> {
  /** Lists the firewall rules of an application. */
  listIngressRules(
    request: ListIngressRulesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIngressRulesResponse>>;
  /**
   * Replaces the entire firewall ruleset in one bulk operation. This overrides
   * and replaces the rules of an existing firewall with the new rules.
   *
   * If the final rule does not match traffic with the '*' wildcard IP range,
   * then an "allow all" rule is explicitly added to the end of the list.
   */
  batchUpdateIngressRules(
    request: BatchUpdateIngressRulesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchUpdateIngressRulesResponse>>;
  /** Creates a firewall rule for the application. */
  createIngressRule(
    request: CreateIngressRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallRule>>;
  /** Gets the specified firewall rule. */
  getIngressRule(
    request: GetIngressRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallRule>>;
  /** Updates the specified firewall rule. */
  updateIngressRule(
    request: UpdateIngressRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallRule>>;
  /** Deletes the specified firewall rule. */
  deleteIngressRule(
    request: DeleteIngressRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface FirewallClient<CallOptionsExt = {}> {
  /** Lists the firewall rules of an application. */
  listIngressRules(
    request: DeepPartial<ListIngressRulesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIngressRulesResponse>;
  /**
   * Replaces the entire firewall ruleset in one bulk operation. This overrides
   * and replaces the rules of an existing firewall with the new rules.
   *
   * If the final rule does not match traffic with the '*' wildcard IP range,
   * then an "allow all" rule is explicitly added to the end of the list.
   */
  batchUpdateIngressRules(
    request: DeepPartial<BatchUpdateIngressRulesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchUpdateIngressRulesResponse>;
  /** Creates a firewall rule for the application. */
  createIngressRule(
    request: DeepPartial<CreateIngressRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallRule>;
  /** Gets the specified firewall rule. */
  getIngressRule(
    request: DeepPartial<GetIngressRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallRule>;
  /** Updates the specified firewall rule. */
  updateIngressRule(
    request: DeepPartial<UpdateIngressRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallRule>;
  /** Deletes the specified firewall rule. */
  deleteIngressRule(
    request: DeepPartial<DeleteIngressRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

/**
 * Manages domains a user is authorized to administer. To authorize use of a
 * domain, verify ownership via
 * [Webmaster Central](https://www.google.com/webmasters/verification/home).
 */
export type AuthorizedDomainsDefinition = typeof AuthorizedDomainsDefinition;
export const AuthorizedDomainsDefinition = {
  name: "AuthorizedDomains",
  fullName: "google.appengine.v1beta.AuthorizedDomains",
  methods: {
    /** Lists all domains the user is authorized to administer. */
    listAuthorizedDomains: {
      name: "ListAuthorizedDomains",
      requestType: ListAuthorizedDomainsRequest,
      requestStream: false,
      responseType: ListAuthorizedDomainsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              68,
              111,
              109,
              97,
              105,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AuthorizedDomainsServiceImplementation<CallContextExt = {}> {
  /** Lists all domains the user is authorized to administer. */
  listAuthorizedDomains(
    request: ListAuthorizedDomainsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAuthorizedDomainsResponse>>;
}

export interface AuthorizedDomainsClient<CallOptionsExt = {}> {
  /** Lists all domains the user is authorized to administer. */
  listAuthorizedDomains(
    request: DeepPartial<ListAuthorizedDomainsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAuthorizedDomainsResponse>;
}

/**
 * Manages SSL certificates a user is authorized to administer. A user can
 * administer any SSL certificates applicable to their authorized domains.
 */
export type AuthorizedCertificatesDefinition = typeof AuthorizedCertificatesDefinition;
export const AuthorizedCertificatesDefinition = {
  name: "AuthorizedCertificates",
  fullName: "google.appengine.v1beta.AuthorizedCertificates",
  methods: {
    /** Lists all SSL certificates the user is authorized to administer. */
    listAuthorizedCertificates: {
      name: "ListAuthorizedCertificates",
      requestType: ListAuthorizedCertificatesRequest,
      requestStream: false,
      responseType: ListAuthorizedCertificatesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified SSL certificate. */
    getAuthorizedCertificate: {
      name: "GetAuthorizedCertificate",
      requestType: GetAuthorizedCertificateRequest,
      requestStream: false,
      responseType: AuthorizedCertificate,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Uploads the specified SSL certificate. */
    createAuthorizedCertificate: {
      name: "CreateAuthorizedCertificate",
      requestType: CreateAuthorizedCertificateRequest,
      requestStream: false,
      responseType: AuthorizedCertificate,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              58,
              11,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              34,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified SSL certificate. To renew a certificate and maintain
     * its existing domain mappings, update `certificate_data` with a new
     * certificate. The new certificate must be applicable to the same domains as
     * the original certificate. The certificate `display_name` may also be
     * updated.
     */
    updateAuthorizedCertificate: {
      name: "UpdateAuthorizedCertificate",
      requestType: UpdateAuthorizedCertificateRequest,
      requestStream: false,
      responseType: AuthorizedCertificate,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              58,
              11,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              50,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified SSL certificate. */
    deleteAuthorizedCertificate: {
      name: "DeleteAuthorizedCertificate",
      requestType: DeleteAuthorizedCertificateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              100,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AuthorizedCertificatesServiceImplementation<CallContextExt = {}> {
  /** Lists all SSL certificates the user is authorized to administer. */
  listAuthorizedCertificates(
    request: ListAuthorizedCertificatesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAuthorizedCertificatesResponse>>;
  /** Gets the specified SSL certificate. */
  getAuthorizedCertificate(
    request: GetAuthorizedCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthorizedCertificate>>;
  /** Uploads the specified SSL certificate. */
  createAuthorizedCertificate(
    request: CreateAuthorizedCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthorizedCertificate>>;
  /**
   * Updates the specified SSL certificate. To renew a certificate and maintain
   * its existing domain mappings, update `certificate_data` with a new
   * certificate. The new certificate must be applicable to the same domains as
   * the original certificate. The certificate `display_name` may also be
   * updated.
   */
  updateAuthorizedCertificate(
    request: UpdateAuthorizedCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthorizedCertificate>>;
  /** Deletes the specified SSL certificate. */
  deleteAuthorizedCertificate(
    request: DeleteAuthorizedCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface AuthorizedCertificatesClient<CallOptionsExt = {}> {
  /** Lists all SSL certificates the user is authorized to administer. */
  listAuthorizedCertificates(
    request: DeepPartial<ListAuthorizedCertificatesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAuthorizedCertificatesResponse>;
  /** Gets the specified SSL certificate. */
  getAuthorizedCertificate(
    request: DeepPartial<GetAuthorizedCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthorizedCertificate>;
  /** Uploads the specified SSL certificate. */
  createAuthorizedCertificate(
    request: DeepPartial<CreateAuthorizedCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthorizedCertificate>;
  /**
   * Updates the specified SSL certificate. To renew a certificate and maintain
   * its existing domain mappings, update `certificate_data` with a new
   * certificate. The new certificate must be applicable to the same domains as
   * the original certificate. The certificate `display_name` may also be
   * updated.
   */
  updateAuthorizedCertificate(
    request: DeepPartial<UpdateAuthorizedCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthorizedCertificate>;
  /** Deletes the specified SSL certificate. */
  deleteAuthorizedCertificate(
    request: DeepPartial<DeleteAuthorizedCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

/** Manages domains serving an application. */
export type DomainMappingsDefinition = typeof DomainMappingsDefinition;
export const DomainMappingsDefinition = {
  name: "DomainMappings",
  fullName: "google.appengine.v1beta.DomainMappings",
  methods: {
    /** Lists the domain mappings on an application. */
    listDomainMappings: {
      name: "ListDomainMappings",
      requestType: ListDomainMappingsRequest,
      requestStream: false,
      responseType: ListDomainMappingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              100,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified domain mapping. */
    getDomainMapping: {
      name: "GetDomainMapping",
      requestType: GetDomainMappingRequest,
      requestStream: false,
      responseType: DomainMapping,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              100,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Maps a domain to an application. A user must be authorized to administer a
     * domain in order to map it to an application. For a list of available
     * authorized domains, see [`AuthorizedDomains.ListAuthorizedDomains`]().
     */
    createDomainMapping: {
      name: "CreateDomainMapping",
      requestType: CreateDomainMappingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              13,
              68,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              14,
              100,
              111,
              109,
              97,
              105,
              110,
              95,
              109,
              97,
              112,
              112,
              105,
              110,
              103,
              34,
              38,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              125,
              47,
              100,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified domain mapping. To map an SSL certificate to a
     * domain mapping, update `certificate_id` to point to an `AuthorizedCertificate`
     * resource. A user must be authorized to administer the associated domain
     * in order to update a `DomainMapping` resource.
     */
    updateDomainMapping: {
      name: "UpdateDomainMapping",
      requestType: UpdateDomainMappingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              13,
              68,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              14,
              100,
              111,
              109,
              97,
              105,
              110,
              95,
              109,
              97,
              112,
              112,
              105,
              110,
              103,
              50,
              38,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              100,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified domain mapping. A user must be authorized to
     * administer the associated domain in order to delete a `DomainMapping`
     * resource.
     */
    deleteDomainMapping: {
      name: "DeleteDomainMapping",
      requestType: DeleteDomainMappingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              23,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              86,
              49,
              66,
              101,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              40,
              42,
              38,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              112,
              112,
              115,
              47,
              42,
              47,
              100,
              111,
              109,
              97,
              105,
              110,
              77,
              97,
              112,
              112,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DomainMappingsServiceImplementation<CallContextExt = {}> {
  /** Lists the domain mappings on an application. */
  listDomainMappings(
    request: ListDomainMappingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDomainMappingsResponse>>;
  /** Gets the specified domain mapping. */
  getDomainMapping(
    request: GetDomainMappingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DomainMapping>>;
  /**
   * Maps a domain to an application. A user must be authorized to administer a
   * domain in order to map it to an application. For a list of available
   * authorized domains, see [`AuthorizedDomains.ListAuthorizedDomains`]().
   */
  createDomainMapping(
    request: CreateDomainMappingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the specified domain mapping. To map an SSL certificate to a
   * domain mapping, update `certificate_id` to point to an `AuthorizedCertificate`
   * resource. A user must be authorized to administer the associated domain
   * in order to update a `DomainMapping` resource.
   */
  updateDomainMapping(
    request: UpdateDomainMappingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the specified domain mapping. A user must be authorized to
   * administer the associated domain in order to delete a `DomainMapping`
   * resource.
   */
  deleteDomainMapping(
    request: DeleteDomainMappingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface DomainMappingsClient<CallOptionsExt = {}> {
  /** Lists the domain mappings on an application. */
  listDomainMappings(
    request: DeepPartial<ListDomainMappingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDomainMappingsResponse>;
  /** Gets the specified domain mapping. */
  getDomainMapping(
    request: DeepPartial<GetDomainMappingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DomainMapping>;
  /**
   * Maps a domain to an application. A user must be authorized to administer a
   * domain in order to map it to an application. For a list of available
   * authorized domains, see [`AuthorizedDomains.ListAuthorizedDomains`]().
   */
  createDomainMapping(
    request: DeepPartial<CreateDomainMappingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the specified domain mapping. To map an SSL certificate to a
   * domain mapping, update `certificate_id` to point to an `AuthorizedCertificate`
   * resource. A user must be authorized to administer the associated domain
   * in order to update a `DomainMapping` resource.
   */
  updateDomainMapping(
    request: DeepPartial<UpdateDomainMappingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes the specified domain mapping. A user must be authorized to
   * administer the associated domain in order to delete a `DomainMapping`
   * resource.
   */
  deleteDomainMapping(
    request: DeepPartial<DeleteDomainMappingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
