// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/appengine/v1beta/app_yaml.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../protobuf/duration.js";

export const protobufPackage = "google.appengine.v1beta";

/** Actions to take when the user is not logged in. */
export enum AuthFailAction {
  /** AUTH_FAIL_ACTION_UNSPECIFIED - Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed. */
  AUTH_FAIL_ACTION_UNSPECIFIED = 0,
  /**
   * AUTH_FAIL_ACTION_REDIRECT - Redirects user to "accounts.google.com". The user is redirected back to the
   * application URL after signing in or creating an account.
   */
  AUTH_FAIL_ACTION_REDIRECT = 1,
  /**
   * AUTH_FAIL_ACTION_UNAUTHORIZED - Rejects request with a `401` HTTP status code and an error
   * message.
   */
  AUTH_FAIL_ACTION_UNAUTHORIZED = 2,
  UNRECOGNIZED = -1,
}

export function authFailActionFromJSON(object: any): AuthFailAction {
  switch (object) {
    case 0:
    case "AUTH_FAIL_ACTION_UNSPECIFIED":
      return AuthFailAction.AUTH_FAIL_ACTION_UNSPECIFIED;
    case 1:
    case "AUTH_FAIL_ACTION_REDIRECT":
      return AuthFailAction.AUTH_FAIL_ACTION_REDIRECT;
    case 2:
    case "AUTH_FAIL_ACTION_UNAUTHORIZED":
      return AuthFailAction.AUTH_FAIL_ACTION_UNAUTHORIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthFailAction.UNRECOGNIZED;
  }
}

export function authFailActionToJSON(object: AuthFailAction): string {
  switch (object) {
    case AuthFailAction.AUTH_FAIL_ACTION_UNSPECIFIED:
      return "AUTH_FAIL_ACTION_UNSPECIFIED";
    case AuthFailAction.AUTH_FAIL_ACTION_REDIRECT:
      return "AUTH_FAIL_ACTION_REDIRECT";
    case AuthFailAction.AUTH_FAIL_ACTION_UNAUTHORIZED:
      return "AUTH_FAIL_ACTION_UNAUTHORIZED";
    case AuthFailAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Methods to restrict access to a URL based on login status. */
export enum LoginRequirement {
  /** LOGIN_UNSPECIFIED - Not specified. `LOGIN_OPTIONAL` is assumed. */
  LOGIN_UNSPECIFIED = 0,
  /** LOGIN_OPTIONAL - Does not require that the user is signed in. */
  LOGIN_OPTIONAL = 1,
  /**
   * LOGIN_ADMIN - If the user is not signed in, the `auth_fail_action` is taken.
   * In addition, if the user is not an administrator for the
   * application, they are given an error message regardless of
   * `auth_fail_action`. If the user is an administrator, the handler
   * proceeds.
   */
  LOGIN_ADMIN = 2,
  /**
   * LOGIN_REQUIRED - If the user has signed in, the handler proceeds normally. Otherwise, the
   * auth_fail_action is taken.
   */
  LOGIN_REQUIRED = 3,
  UNRECOGNIZED = -1,
}

export function loginRequirementFromJSON(object: any): LoginRequirement {
  switch (object) {
    case 0:
    case "LOGIN_UNSPECIFIED":
      return LoginRequirement.LOGIN_UNSPECIFIED;
    case 1:
    case "LOGIN_OPTIONAL":
      return LoginRequirement.LOGIN_OPTIONAL;
    case 2:
    case "LOGIN_ADMIN":
      return LoginRequirement.LOGIN_ADMIN;
    case 3:
    case "LOGIN_REQUIRED":
      return LoginRequirement.LOGIN_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoginRequirement.UNRECOGNIZED;
  }
}

export function loginRequirementToJSON(object: LoginRequirement): string {
  switch (object) {
    case LoginRequirement.LOGIN_UNSPECIFIED:
      return "LOGIN_UNSPECIFIED";
    case LoginRequirement.LOGIN_OPTIONAL:
      return "LOGIN_OPTIONAL";
    case LoginRequirement.LOGIN_ADMIN:
      return "LOGIN_ADMIN";
    case LoginRequirement.LOGIN_REQUIRED:
      return "LOGIN_REQUIRED";
    case LoginRequirement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Methods to enforce security (HTTPS) on a URL. */
export enum SecurityLevel {
  /** SECURE_UNSPECIFIED - Not specified. */
  SECURE_UNSPECIFIED = 0,
  /**
   * SECURE_DEFAULT - Both HTTP and HTTPS requests with URLs that match the handler succeed
   * without redirects. The application can examine the request to determine
   * which protocol was used, and respond accordingly.
   */
  SECURE_DEFAULT = 0,
  /**
   * SECURE_NEVER - Requests for a URL that match this handler that use HTTPS are automatically
   * redirected to the HTTP equivalent URL.
   */
  SECURE_NEVER = 1,
  /**
   * SECURE_OPTIONAL - Both HTTP and HTTPS requests with URLs that match the handler succeed
   * without redirects. The application can examine the request to determine
   * which protocol was used and respond accordingly.
   */
  SECURE_OPTIONAL = 2,
  /**
   * SECURE_ALWAYS - Requests for a URL that match this handler that do not use HTTPS are
   * automatically redirected to the HTTPS URL with the same path. Query
   * parameters are reserved for the redirect.
   */
  SECURE_ALWAYS = 3,
  UNRECOGNIZED = -1,
}

export function securityLevelFromJSON(object: any): SecurityLevel {
  switch (object) {
    case 0:
    case "SECURE_UNSPECIFIED":
      return SecurityLevel.SECURE_UNSPECIFIED;
    case 0:
    case "SECURE_DEFAULT":
      return SecurityLevel.SECURE_DEFAULT;
    case 1:
    case "SECURE_NEVER":
      return SecurityLevel.SECURE_NEVER;
    case 2:
    case "SECURE_OPTIONAL":
      return SecurityLevel.SECURE_OPTIONAL;
    case 3:
    case "SECURE_ALWAYS":
      return SecurityLevel.SECURE_ALWAYS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityLevel.UNRECOGNIZED;
  }
}

export function securityLevelToJSON(object: SecurityLevel): string {
  switch (object) {
    case SecurityLevel.SECURE_UNSPECIFIED:
      return "SECURE_UNSPECIFIED";
    case SecurityLevel.SECURE_DEFAULT:
      return "SECURE_DEFAULT";
    case SecurityLevel.SECURE_NEVER:
      return "SECURE_NEVER";
    case SecurityLevel.SECURE_OPTIONAL:
      return "SECURE_OPTIONAL";
    case SecurityLevel.SECURE_ALWAYS:
      return "SECURE_ALWAYS";
    case SecurityLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
 * configuration for API handlers.
 */
export interface ApiConfigHandler {
  /**
   * Action to take when users access resources that require
   * authentication. Defaults to `redirect`.
   */
  authFailAction: AuthFailAction;
  /**
   * Level of login required to access this resource. Defaults to
   * `optional`.
   */
  login: LoginRequirement;
  /** Path to the script from the application root directory. */
  script: string;
  /** Security (HTTPS) enforcement for this URL. */
  securityLevel: SecurityLevel;
  /** URL to serve the endpoint at. */
  url: string;
}

/** Custom static error page to be served when an error occurs. */
export interface ErrorHandler {
  /** Error condition this handler applies to. */
  errorCode: ErrorHandler_ErrorCode;
  /** Static file content to be served for this error. */
  staticFile: string;
  /** MIME type of file. Defaults to `text/html`. */
  mimeType: string;
}

/** Error codes. */
export enum ErrorHandler_ErrorCode {
  /** ERROR_CODE_UNSPECIFIED - Not specified. ERROR_CODE_DEFAULT is assumed. */
  ERROR_CODE_UNSPECIFIED = 0,
  /** ERROR_CODE_DEFAULT - All other error types. */
  ERROR_CODE_DEFAULT = 0,
  /** ERROR_CODE_OVER_QUOTA - Application has exceeded a resource quota. */
  ERROR_CODE_OVER_QUOTA = 1,
  /**
   * ERROR_CODE_DOS_API_DENIAL - Client blocked by the application's Denial of Service protection
   * configuration.
   */
  ERROR_CODE_DOS_API_DENIAL = 2,
  /** ERROR_CODE_TIMEOUT - Deadline reached before the application responds. */
  ERROR_CODE_TIMEOUT = 3,
  UNRECOGNIZED = -1,
}

export function errorHandler_ErrorCodeFromJSON(object: any): ErrorHandler_ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorHandler_ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 0:
    case "ERROR_CODE_DEFAULT":
      return ErrorHandler_ErrorCode.ERROR_CODE_DEFAULT;
    case 1:
    case "ERROR_CODE_OVER_QUOTA":
      return ErrorHandler_ErrorCode.ERROR_CODE_OVER_QUOTA;
    case 2:
    case "ERROR_CODE_DOS_API_DENIAL":
      return ErrorHandler_ErrorCode.ERROR_CODE_DOS_API_DENIAL;
    case 3:
    case "ERROR_CODE_TIMEOUT":
      return ErrorHandler_ErrorCode.ERROR_CODE_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorHandler_ErrorCode.UNRECOGNIZED;
  }
}

export function errorHandler_ErrorCodeToJSON(object: ErrorHandler_ErrorCode): string {
  switch (object) {
    case ErrorHandler_ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorHandler_ErrorCode.ERROR_CODE_DEFAULT:
      return "ERROR_CODE_DEFAULT";
    case ErrorHandler_ErrorCode.ERROR_CODE_OVER_QUOTA:
      return "ERROR_CODE_OVER_QUOTA";
    case ErrorHandler_ErrorCode.ERROR_CODE_DOS_API_DENIAL:
      return "ERROR_CODE_DOS_API_DENIAL";
    case ErrorHandler_ErrorCode.ERROR_CODE_TIMEOUT:
      return "ERROR_CODE_TIMEOUT";
    case ErrorHandler_ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * URL pattern and description of how the URL should be handled. App Engine can
 * handle URLs by executing application code or by serving static files
 * uploaded with the version, such as images, CSS, or JavaScript.
 */
export interface UrlMap {
  /**
   * URL prefix. Uses regular expression syntax, which means regexp
   * special characters must be escaped, but should not contain groupings.
   * All URLs that begin with this prefix are handled by this handler, using the
   * portion of the URL after the prefix as part of the file path.
   */
  urlRegex: string;
  /** Returns the contents of a file, such as an image, as the response. */
  staticFiles?:
    | StaticFilesHandler
    | undefined;
  /**
   * Executes a script to handle the requests that match this URL
   * pattern. Only the `auto` value is supported for Node.js in the
   * App Engine standard environment, for example `"script": "auto"`.
   */
  script?:
    | ScriptHandler
    | undefined;
  /** Uses API Endpoints to handle requests. */
  apiEndpoint?:
    | ApiEndpointHandler
    | undefined;
  /** Security (HTTPS) enforcement for this URL. */
  securityLevel: SecurityLevel;
  /**
   * Level of login required to access this resource. Not supported for Node.js
   * in the App Engine standard environment.
   */
  login: LoginRequirement;
  /**
   * Action to take when users access resources that require
   * authentication. Defaults to `redirect`.
   */
  authFailAction: AuthFailAction;
  /**
   * `30x` code to use when performing redirects for the `secure` field.
   * Defaults to `302`.
   */
  redirectHttpResponseCode: UrlMap_RedirectHttpResponseCode;
}

/** Redirect codes. */
export enum UrlMap_RedirectHttpResponseCode {
  /** REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED - Not specified. `302` is assumed. */
  REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED = 0,
  /** REDIRECT_HTTP_RESPONSE_CODE_301 - `301 Moved Permanently` code. */
  REDIRECT_HTTP_RESPONSE_CODE_301 = 1,
  /** REDIRECT_HTTP_RESPONSE_CODE_302 - `302 Moved Temporarily` code. */
  REDIRECT_HTTP_RESPONSE_CODE_302 = 2,
  /** REDIRECT_HTTP_RESPONSE_CODE_303 - `303 See Other` code. */
  REDIRECT_HTTP_RESPONSE_CODE_303 = 3,
  /** REDIRECT_HTTP_RESPONSE_CODE_307 - `307 Temporary Redirect` code. */
  REDIRECT_HTTP_RESPONSE_CODE_307 = 4,
  UNRECOGNIZED = -1,
}

export function urlMap_RedirectHttpResponseCodeFromJSON(object: any): UrlMap_RedirectHttpResponseCode {
  switch (object) {
    case 0:
    case "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED":
      return UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED;
    case 1:
    case "REDIRECT_HTTP_RESPONSE_CODE_301":
      return UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_301;
    case 2:
    case "REDIRECT_HTTP_RESPONSE_CODE_302":
      return UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_302;
    case 3:
    case "REDIRECT_HTTP_RESPONSE_CODE_303":
      return UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_303;
    case 4:
    case "REDIRECT_HTTP_RESPONSE_CODE_307":
      return UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_307;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UrlMap_RedirectHttpResponseCode.UNRECOGNIZED;
  }
}

export function urlMap_RedirectHttpResponseCodeToJSON(object: UrlMap_RedirectHttpResponseCode): string {
  switch (object) {
    case UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED:
      return "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED";
    case UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_301:
      return "REDIRECT_HTTP_RESPONSE_CODE_301";
    case UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_302:
      return "REDIRECT_HTTP_RESPONSE_CODE_302";
    case UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_303:
      return "REDIRECT_HTTP_RESPONSE_CODE_303";
    case UrlMap_RedirectHttpResponseCode.REDIRECT_HTTP_RESPONSE_CODE_307:
      return "REDIRECT_HTTP_RESPONSE_CODE_307";
    case UrlMap_RedirectHttpResponseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Files served directly to the user for a given URL, such as images, CSS
 * stylesheets, or JavaScript source files. Static file handlers describe which
 * files in the application directory are static files, and which URLs serve
 * them.
 */
export interface StaticFilesHandler {
  /**
   * Path to the static files matched by the URL pattern, from the
   * application root directory. The path can refer to text matched in groupings
   * in the URL pattern.
   */
  path: string;
  /**
   * Regular expression that matches the file paths for all files that should be
   * referenced by this handler.
   */
  uploadPathRegex: string;
  /** HTTP headers to use for all responses from these URLs. */
  httpHeaders: { [key: string]: string };
  /**
   * MIME type used to serve all files served by this handler.
   *
   * Defaults to file-specific MIME types, which are derived from each file's
   * filename extension.
   */
  mimeType: string;
  /**
   * Time a static file served by this handler should be cached
   * by web proxies and browsers.
   */
  expiration:
    | Duration
    | undefined;
  /**
   * Whether this handler should match the request if the file
   * referenced by the handler does not exist.
   */
  requireMatchingFile: boolean;
  /**
   * Whether files should also be uploaded as code data. By default, files
   * declared in static file handlers are uploaded as static
   * data and are only served to end users; they cannot be read by the
   * application. If enabled, uploads are charged against both your code and
   * static data storage resource quotas.
   */
  applicationReadable: boolean;
}

export interface StaticFilesHandler_HttpHeadersEntry {
  key: string;
  value: string;
}

/** Executes a script to handle the request that matches the URL pattern. */
export interface ScriptHandler {
  /** Path to the script from the application root directory. */
  scriptPath: string;
}

/** Uses Google Cloud Endpoints to handle requests. */
export interface ApiEndpointHandler {
  /** Path to the script from the application root directory. */
  scriptPath: string;
}

/**
 * Health checking configuration for VM instances. Unhealthy instances
 * are killed and replaced with new instances. Only applicable for
 * instances in App Engine flexible environment.
 */
export interface HealthCheck {
  /** Whether to explicitly disable health checks for this instance. */
  disableHealthCheck: boolean;
  /**
   * Host header to send when performing an HTTP health check.
   * Example: "myapp.appspot.com"
   */
  host: string;
  /**
   * Number of consecutive successful health checks required before receiving
   * traffic.
   */
  healthyThreshold: number;
  /**
   * Number of consecutive failed health checks required before removing
   * traffic.
   */
  unhealthyThreshold: number;
  /**
   * Number of consecutive failed health checks required before an instance is
   * restarted.
   */
  restartThreshold: number;
  /** Interval between health checks. */
  checkInterval:
    | Duration
    | undefined;
  /** Time before the health check is considered failed. */
  timeout: Duration | undefined;
}

/**
 * Readiness checking configuration for VM instances. Unhealthy instances
 * are removed from traffic rotation.
 */
export interface ReadinessCheck {
  /** The request path. */
  path: string;
  /**
   * Host header to send when performing a HTTP Readiness check.
   * Example: "myapp.appspot.com"
   */
  host: string;
  /**
   * Number of consecutive failed checks required before removing
   * traffic.
   */
  failureThreshold: number;
  /**
   * Number of consecutive successful checks required before receiving
   * traffic.
   */
  successThreshold: number;
  /** Interval between health checks. */
  checkInterval:
    | Duration
    | undefined;
  /** Time before the check is considered failed. */
  timeout:
    | Duration
    | undefined;
  /**
   * A maximum time limit on application initialization, measured from moment
   * the application successfully replies to a healthcheck until it is ready to
   * serve traffic.
   */
  appStartTimeout: Duration | undefined;
}

/**
 * Health checking configuration for VM instances. Unhealthy instances
 * are killed and replaced with new instances.
 */
export interface LivenessCheck {
  /** The request path. */
  path: string;
  /**
   * Host header to send when performing a HTTP Liveness check.
   * Example: "myapp.appspot.com"
   */
  host: string;
  /**
   * Number of consecutive failed checks required before considering the
   * VM unhealthy.
   */
  failureThreshold: number;
  /**
   * Number of consecutive successful checks required before considering
   * the VM healthy.
   */
  successThreshold: number;
  /** Interval between health checks. */
  checkInterval:
    | Duration
    | undefined;
  /** Time before the check is considered failed. */
  timeout:
    | Duration
    | undefined;
  /** The initial delay before starting to execute the checks. */
  initialDelay: Duration | undefined;
}

/** Third-party Python runtime library that is required by the application. */
export interface Library {
  /** Name of the library. Example: "django". */
  name: string;
  /** Version of the library to select, or "latest". */
  version: string;
}

function createBaseApiConfigHandler(): ApiConfigHandler {
  return { authFailAction: 0, login: 0, script: "", securityLevel: 0, url: "" };
}

export const ApiConfigHandler: MessageFns<ApiConfigHandler> = {
  encode(message: ApiConfigHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authFailAction !== 0) {
      writer.uint32(8).int32(message.authFailAction);
    }
    if (message.login !== 0) {
      writer.uint32(16).int32(message.login);
    }
    if (message.script !== "") {
      writer.uint32(26).string(message.script);
    }
    if (message.securityLevel !== 0) {
      writer.uint32(32).int32(message.securityLevel);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiConfigHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiConfigHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authFailAction = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.login = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.script = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.securityLevel = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiConfigHandler {
    return {
      authFailAction: isSet(object.authFailAction) ? authFailActionFromJSON(object.authFailAction) : 0,
      login: isSet(object.login) ? loginRequirementFromJSON(object.login) : 0,
      script: isSet(object.script) ? globalThis.String(object.script) : "",
      securityLevel: isSet(object.securityLevel) ? securityLevelFromJSON(object.securityLevel) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ApiConfigHandler): unknown {
    const obj: any = {};
    if (message.authFailAction !== 0) {
      obj.authFailAction = authFailActionToJSON(message.authFailAction);
    }
    if (message.login !== 0) {
      obj.login = loginRequirementToJSON(message.login);
    }
    if (message.script !== "") {
      obj.script = message.script;
    }
    if (message.securityLevel !== 0) {
      obj.securityLevel = securityLevelToJSON(message.securityLevel);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiConfigHandler>): ApiConfigHandler {
    return ApiConfigHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiConfigHandler>): ApiConfigHandler {
    const message = createBaseApiConfigHandler();
    message.authFailAction = object.authFailAction ?? 0;
    message.login = object.login ?? 0;
    message.script = object.script ?? "";
    message.securityLevel = object.securityLevel ?? 0;
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseErrorHandler(): ErrorHandler {
  return { errorCode: 0, staticFile: "", mimeType: "" };
}

export const ErrorHandler: MessageFns<ErrorHandler> = {
  encode(message: ErrorHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.staticFile !== "") {
      writer.uint32(18).string(message.staticFile);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.staticFile = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorHandler {
    return {
      errorCode: isSet(object.errorCode) ? errorHandler_ErrorCodeFromJSON(object.errorCode) : 0,
      staticFile: isSet(object.staticFile) ? globalThis.String(object.staticFile) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: ErrorHandler): unknown {
    const obj: any = {};
    if (message.errorCode !== 0) {
      obj.errorCode = errorHandler_ErrorCodeToJSON(message.errorCode);
    }
    if (message.staticFile !== "") {
      obj.staticFile = message.staticFile;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorHandler>): ErrorHandler {
    return ErrorHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorHandler>): ErrorHandler {
    const message = createBaseErrorHandler();
    message.errorCode = object.errorCode ?? 0;
    message.staticFile = object.staticFile ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseUrlMap(): UrlMap {
  return {
    urlRegex: "",
    staticFiles: undefined,
    script: undefined,
    apiEndpoint: undefined,
    securityLevel: 0,
    login: 0,
    authFailAction: 0,
    redirectHttpResponseCode: 0,
  };
}

export const UrlMap: MessageFns<UrlMap> = {
  encode(message: UrlMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.urlRegex !== "") {
      writer.uint32(10).string(message.urlRegex);
    }
    if (message.staticFiles !== undefined) {
      StaticFilesHandler.encode(message.staticFiles, writer.uint32(18).fork()).join();
    }
    if (message.script !== undefined) {
      ScriptHandler.encode(message.script, writer.uint32(26).fork()).join();
    }
    if (message.apiEndpoint !== undefined) {
      ApiEndpointHandler.encode(message.apiEndpoint, writer.uint32(34).fork()).join();
    }
    if (message.securityLevel !== 0) {
      writer.uint32(40).int32(message.securityLevel);
    }
    if (message.login !== 0) {
      writer.uint32(48).int32(message.login);
    }
    if (message.authFailAction !== 0) {
      writer.uint32(56).int32(message.authFailAction);
    }
    if (message.redirectHttpResponseCode !== 0) {
      writer.uint32(64).int32(message.redirectHttpResponseCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UrlMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUrlMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.urlRegex = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.staticFiles = StaticFilesHandler.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.script = ScriptHandler.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.apiEndpoint = ApiEndpointHandler.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.securityLevel = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.login = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.authFailAction = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.redirectHttpResponseCode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UrlMap {
    return {
      urlRegex: isSet(object.urlRegex) ? globalThis.String(object.urlRegex) : "",
      staticFiles: isSet(object.staticFiles) ? StaticFilesHandler.fromJSON(object.staticFiles) : undefined,
      script: isSet(object.script) ? ScriptHandler.fromJSON(object.script) : undefined,
      apiEndpoint: isSet(object.apiEndpoint) ? ApiEndpointHandler.fromJSON(object.apiEndpoint) : undefined,
      securityLevel: isSet(object.securityLevel) ? securityLevelFromJSON(object.securityLevel) : 0,
      login: isSet(object.login) ? loginRequirementFromJSON(object.login) : 0,
      authFailAction: isSet(object.authFailAction) ? authFailActionFromJSON(object.authFailAction) : 0,
      redirectHttpResponseCode: isSet(object.redirectHttpResponseCode)
        ? urlMap_RedirectHttpResponseCodeFromJSON(object.redirectHttpResponseCode)
        : 0,
    };
  },

  toJSON(message: UrlMap): unknown {
    const obj: any = {};
    if (message.urlRegex !== "") {
      obj.urlRegex = message.urlRegex;
    }
    if (message.staticFiles !== undefined) {
      obj.staticFiles = StaticFilesHandler.toJSON(message.staticFiles);
    }
    if (message.script !== undefined) {
      obj.script = ScriptHandler.toJSON(message.script);
    }
    if (message.apiEndpoint !== undefined) {
      obj.apiEndpoint = ApiEndpointHandler.toJSON(message.apiEndpoint);
    }
    if (message.securityLevel !== 0) {
      obj.securityLevel = securityLevelToJSON(message.securityLevel);
    }
    if (message.login !== 0) {
      obj.login = loginRequirementToJSON(message.login);
    }
    if (message.authFailAction !== 0) {
      obj.authFailAction = authFailActionToJSON(message.authFailAction);
    }
    if (message.redirectHttpResponseCode !== 0) {
      obj.redirectHttpResponseCode = urlMap_RedirectHttpResponseCodeToJSON(message.redirectHttpResponseCode);
    }
    return obj;
  },

  create(base?: DeepPartial<UrlMap>): UrlMap {
    return UrlMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UrlMap>): UrlMap {
    const message = createBaseUrlMap();
    message.urlRegex = object.urlRegex ?? "";
    message.staticFiles = (object.staticFiles !== undefined && object.staticFiles !== null)
      ? StaticFilesHandler.fromPartial(object.staticFiles)
      : undefined;
    message.script = (object.script !== undefined && object.script !== null)
      ? ScriptHandler.fromPartial(object.script)
      : undefined;
    message.apiEndpoint = (object.apiEndpoint !== undefined && object.apiEndpoint !== null)
      ? ApiEndpointHandler.fromPartial(object.apiEndpoint)
      : undefined;
    message.securityLevel = object.securityLevel ?? 0;
    message.login = object.login ?? 0;
    message.authFailAction = object.authFailAction ?? 0;
    message.redirectHttpResponseCode = object.redirectHttpResponseCode ?? 0;
    return message;
  },
};

function createBaseStaticFilesHandler(): StaticFilesHandler {
  return {
    path: "",
    uploadPathRegex: "",
    httpHeaders: {},
    mimeType: "",
    expiration: undefined,
    requireMatchingFile: false,
    applicationReadable: false,
  };
}

export const StaticFilesHandler: MessageFns<StaticFilesHandler> = {
  encode(message: StaticFilesHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.uploadPathRegex !== "") {
      writer.uint32(18).string(message.uploadPathRegex);
    }
    Object.entries(message.httpHeaders).forEach(([key, value]) => {
      StaticFilesHandler_HttpHeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    if (message.expiration !== undefined) {
      Duration.encode(message.expiration, writer.uint32(42).fork()).join();
    }
    if (message.requireMatchingFile !== false) {
      writer.uint32(48).bool(message.requireMatchingFile);
    }
    if (message.applicationReadable !== false) {
      writer.uint32(56).bool(message.applicationReadable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticFilesHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticFilesHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uploadPathRegex = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = StaticFilesHandler_HttpHeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.httpHeaders[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requireMatchingFile = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.applicationReadable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticFilesHandler {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      uploadPathRegex: isSet(object.uploadPathRegex) ? globalThis.String(object.uploadPathRegex) : "",
      httpHeaders: isObject(object.httpHeaders)
        ? Object.entries(object.httpHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      expiration: isSet(object.expiration) ? Duration.fromJSON(object.expiration) : undefined,
      requireMatchingFile: isSet(object.requireMatchingFile) ? globalThis.Boolean(object.requireMatchingFile) : false,
      applicationReadable: isSet(object.applicationReadable) ? globalThis.Boolean(object.applicationReadable) : false,
    };
  },

  toJSON(message: StaticFilesHandler): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.uploadPathRegex !== "") {
      obj.uploadPathRegex = message.uploadPathRegex;
    }
    if (message.httpHeaders) {
      const entries = Object.entries(message.httpHeaders);
      if (entries.length > 0) {
        obj.httpHeaders = {};
        entries.forEach(([k, v]) => {
          obj.httpHeaders[k] = v;
        });
      }
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.expiration !== undefined) {
      obj.expiration = Duration.toJSON(message.expiration);
    }
    if (message.requireMatchingFile !== false) {
      obj.requireMatchingFile = message.requireMatchingFile;
    }
    if (message.applicationReadable !== false) {
      obj.applicationReadable = message.applicationReadable;
    }
    return obj;
  },

  create(base?: DeepPartial<StaticFilesHandler>): StaticFilesHandler {
    return StaticFilesHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StaticFilesHandler>): StaticFilesHandler {
    const message = createBaseStaticFilesHandler();
    message.path = object.path ?? "";
    message.uploadPathRegex = object.uploadPathRegex ?? "";
    message.httpHeaders = Object.entries(object.httpHeaders ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.mimeType = object.mimeType ?? "";
    message.expiration = (object.expiration !== undefined && object.expiration !== null)
      ? Duration.fromPartial(object.expiration)
      : undefined;
    message.requireMatchingFile = object.requireMatchingFile ?? false;
    message.applicationReadable = object.applicationReadable ?? false;
    return message;
  },
};

function createBaseStaticFilesHandler_HttpHeadersEntry(): StaticFilesHandler_HttpHeadersEntry {
  return { key: "", value: "" };
}

export const StaticFilesHandler_HttpHeadersEntry: MessageFns<StaticFilesHandler_HttpHeadersEntry> = {
  encode(message: StaticFilesHandler_HttpHeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticFilesHandler_HttpHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticFilesHandler_HttpHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticFilesHandler_HttpHeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StaticFilesHandler_HttpHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StaticFilesHandler_HttpHeadersEntry>): StaticFilesHandler_HttpHeadersEntry {
    return StaticFilesHandler_HttpHeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StaticFilesHandler_HttpHeadersEntry>): StaticFilesHandler_HttpHeadersEntry {
    const message = createBaseStaticFilesHandler_HttpHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseScriptHandler(): ScriptHandler {
  return { scriptPath: "" };
}

export const ScriptHandler: MessageFns<ScriptHandler> = {
  encode(message: ScriptHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scriptPath !== "") {
      writer.uint32(10).string(message.scriptPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScriptHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScriptHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scriptPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScriptHandler {
    return { scriptPath: isSet(object.scriptPath) ? globalThis.String(object.scriptPath) : "" };
  },

  toJSON(message: ScriptHandler): unknown {
    const obj: any = {};
    if (message.scriptPath !== "") {
      obj.scriptPath = message.scriptPath;
    }
    return obj;
  },

  create(base?: DeepPartial<ScriptHandler>): ScriptHandler {
    return ScriptHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScriptHandler>): ScriptHandler {
    const message = createBaseScriptHandler();
    message.scriptPath = object.scriptPath ?? "";
    return message;
  },
};

function createBaseApiEndpointHandler(): ApiEndpointHandler {
  return { scriptPath: "" };
}

export const ApiEndpointHandler: MessageFns<ApiEndpointHandler> = {
  encode(message: ApiEndpointHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scriptPath !== "") {
      writer.uint32(10).string(message.scriptPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiEndpointHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiEndpointHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scriptPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiEndpointHandler {
    return { scriptPath: isSet(object.scriptPath) ? globalThis.String(object.scriptPath) : "" };
  },

  toJSON(message: ApiEndpointHandler): unknown {
    const obj: any = {};
    if (message.scriptPath !== "") {
      obj.scriptPath = message.scriptPath;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiEndpointHandler>): ApiEndpointHandler {
    return ApiEndpointHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiEndpointHandler>): ApiEndpointHandler {
    const message = createBaseApiEndpointHandler();
    message.scriptPath = object.scriptPath ?? "";
    return message;
  },
};

function createBaseHealthCheck(): HealthCheck {
  return {
    disableHealthCheck: false,
    host: "",
    healthyThreshold: 0,
    unhealthyThreshold: 0,
    restartThreshold: 0,
    checkInterval: undefined,
    timeout: undefined,
  };
}

export const HealthCheck: MessageFns<HealthCheck> = {
  encode(message: HealthCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disableHealthCheck !== false) {
      writer.uint32(8).bool(message.disableHealthCheck);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.healthyThreshold !== 0) {
      writer.uint32(24).uint32(message.healthyThreshold);
    }
    if (message.unhealthyThreshold !== 0) {
      writer.uint32(32).uint32(message.unhealthyThreshold);
    }
    if (message.restartThreshold !== 0) {
      writer.uint32(40).uint32(message.restartThreshold);
    }
    if (message.checkInterval !== undefined) {
      Duration.encode(message.checkInterval, writer.uint32(50).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disableHealthCheck = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.healthyThreshold = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unhealthyThreshold = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.restartThreshold = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.checkInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      disableHealthCheck: isSet(object.disableHealthCheck) ? globalThis.Boolean(object.disableHealthCheck) : false,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      healthyThreshold: isSet(object.healthyThreshold) ? globalThis.Number(object.healthyThreshold) : 0,
      unhealthyThreshold: isSet(object.unhealthyThreshold) ? globalThis.Number(object.unhealthyThreshold) : 0,
      restartThreshold: isSet(object.restartThreshold) ? globalThis.Number(object.restartThreshold) : 0,
      checkInterval: isSet(object.checkInterval) ? Duration.fromJSON(object.checkInterval) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.disableHealthCheck !== false) {
      obj.disableHealthCheck = message.disableHealthCheck;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.healthyThreshold !== 0) {
      obj.healthyThreshold = Math.round(message.healthyThreshold);
    }
    if (message.unhealthyThreshold !== 0) {
      obj.unhealthyThreshold = Math.round(message.unhealthyThreshold);
    }
    if (message.restartThreshold !== 0) {
      obj.restartThreshold = Math.round(message.restartThreshold);
    }
    if (message.checkInterval !== undefined) {
      obj.checkInterval = Duration.toJSON(message.checkInterval);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheck>): HealthCheck {
    return HealthCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheck>): HealthCheck {
    const message = createBaseHealthCheck();
    message.disableHealthCheck = object.disableHealthCheck ?? false;
    message.host = object.host ?? "";
    message.healthyThreshold = object.healthyThreshold ?? 0;
    message.unhealthyThreshold = object.unhealthyThreshold ?? 0;
    message.restartThreshold = object.restartThreshold ?? 0;
    message.checkInterval = (object.checkInterval !== undefined && object.checkInterval !== null)
      ? Duration.fromPartial(object.checkInterval)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

function createBaseReadinessCheck(): ReadinessCheck {
  return {
    path: "",
    host: "",
    failureThreshold: 0,
    successThreshold: 0,
    checkInterval: undefined,
    timeout: undefined,
    appStartTimeout: undefined,
  };
}

export const ReadinessCheck: MessageFns<ReadinessCheck> = {
  encode(message: ReadinessCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.failureThreshold !== 0) {
      writer.uint32(24).uint32(message.failureThreshold);
    }
    if (message.successThreshold !== 0) {
      writer.uint32(32).uint32(message.successThreshold);
    }
    if (message.checkInterval !== undefined) {
      Duration.encode(message.checkInterval, writer.uint32(42).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(50).fork()).join();
    }
    if (message.appStartTimeout !== undefined) {
      Duration.encode(message.appStartTimeout, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadinessCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadinessCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failureThreshold = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.successThreshold = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.checkInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.appStartTimeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadinessCheck {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      failureThreshold: isSet(object.failureThreshold) ? globalThis.Number(object.failureThreshold) : 0,
      successThreshold: isSet(object.successThreshold) ? globalThis.Number(object.successThreshold) : 0,
      checkInterval: isSet(object.checkInterval) ? Duration.fromJSON(object.checkInterval) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      appStartTimeout: isSet(object.appStartTimeout) ? Duration.fromJSON(object.appStartTimeout) : undefined,
    };
  },

  toJSON(message: ReadinessCheck): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.failureThreshold !== 0) {
      obj.failureThreshold = Math.round(message.failureThreshold);
    }
    if (message.successThreshold !== 0) {
      obj.successThreshold = Math.round(message.successThreshold);
    }
    if (message.checkInterval !== undefined) {
      obj.checkInterval = Duration.toJSON(message.checkInterval);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.appStartTimeout !== undefined) {
      obj.appStartTimeout = Duration.toJSON(message.appStartTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<ReadinessCheck>): ReadinessCheck {
    return ReadinessCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadinessCheck>): ReadinessCheck {
    const message = createBaseReadinessCheck();
    message.path = object.path ?? "";
    message.host = object.host ?? "";
    message.failureThreshold = object.failureThreshold ?? 0;
    message.successThreshold = object.successThreshold ?? 0;
    message.checkInterval = (object.checkInterval !== undefined && object.checkInterval !== null)
      ? Duration.fromPartial(object.checkInterval)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.appStartTimeout = (object.appStartTimeout !== undefined && object.appStartTimeout !== null)
      ? Duration.fromPartial(object.appStartTimeout)
      : undefined;
    return message;
  },
};

function createBaseLivenessCheck(): LivenessCheck {
  return {
    path: "",
    host: "",
    failureThreshold: 0,
    successThreshold: 0,
    checkInterval: undefined,
    timeout: undefined,
    initialDelay: undefined,
  };
}

export const LivenessCheck: MessageFns<LivenessCheck> = {
  encode(message: LivenessCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.failureThreshold !== 0) {
      writer.uint32(24).uint32(message.failureThreshold);
    }
    if (message.successThreshold !== 0) {
      writer.uint32(32).uint32(message.successThreshold);
    }
    if (message.checkInterval !== undefined) {
      Duration.encode(message.checkInterval, writer.uint32(42).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(50).fork()).join();
    }
    if (message.initialDelay !== undefined) {
      Duration.encode(message.initialDelay, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LivenessCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLivenessCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failureThreshold = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.successThreshold = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.checkInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.initialDelay = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LivenessCheck {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      failureThreshold: isSet(object.failureThreshold) ? globalThis.Number(object.failureThreshold) : 0,
      successThreshold: isSet(object.successThreshold) ? globalThis.Number(object.successThreshold) : 0,
      checkInterval: isSet(object.checkInterval) ? Duration.fromJSON(object.checkInterval) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      initialDelay: isSet(object.initialDelay) ? Duration.fromJSON(object.initialDelay) : undefined,
    };
  },

  toJSON(message: LivenessCheck): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.failureThreshold !== 0) {
      obj.failureThreshold = Math.round(message.failureThreshold);
    }
    if (message.successThreshold !== 0) {
      obj.successThreshold = Math.round(message.successThreshold);
    }
    if (message.checkInterval !== undefined) {
      obj.checkInterval = Duration.toJSON(message.checkInterval);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.initialDelay !== undefined) {
      obj.initialDelay = Duration.toJSON(message.initialDelay);
    }
    return obj;
  },

  create(base?: DeepPartial<LivenessCheck>): LivenessCheck {
    return LivenessCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LivenessCheck>): LivenessCheck {
    const message = createBaseLivenessCheck();
    message.path = object.path ?? "";
    message.host = object.host ?? "";
    message.failureThreshold = object.failureThreshold ?? 0;
    message.successThreshold = object.successThreshold ?? 0;
    message.checkInterval = (object.checkInterval !== undefined && object.checkInterval !== null)
      ? Duration.fromPartial(object.checkInterval)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.initialDelay = (object.initialDelay !== undefined && object.initialDelay !== null)
      ? Duration.fromPartial(object.initialDelay)
      : undefined;
    return message;
  },
};

function createBaseLibrary(): Library {
  return { name: "", version: "" };
}

export const Library: MessageFns<Library> = {
  encode(message: Library, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Library {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLibrary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Library {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: Library): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<Library>): Library {
    return Library.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Library>): Library {
    const message = createBaseLibrary();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
