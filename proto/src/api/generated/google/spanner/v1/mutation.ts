// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/spanner/v1/mutation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../protobuf/struct.js";
import { KeySet } from "./keys.js";

export const protobufPackage = "google.spanner.v1";

/**
 * A modification to one or more Cloud Spanner rows.  Mutations can be
 * applied to a Cloud Spanner database by sending them in a
 * [Commit][google.spanner.v1.Spanner.Commit] call.
 */
export interface Mutation {
  /**
   * Insert new rows in a table. If any of the rows already exist,
   * the write or transaction fails with error `ALREADY_EXISTS`.
   */
  insert?:
    | Mutation_Write
    | undefined;
  /**
   * Update existing rows in a table. If any of the rows does not
   * already exist, the transaction fails with error `NOT_FOUND`.
   */
  update?:
    | Mutation_Write
    | undefined;
  /**
   * Like [insert][google.spanner.v1.Mutation.insert], except that if the row already exists, then
   * its column values are overwritten with the ones provided. Any
   * column values not explicitly written are preserved.
   *
   * When using [insert_or_update][google.spanner.v1.Mutation.insert_or_update], just as when using [insert][google.spanner.v1.Mutation.insert], all `NOT
   * NULL` columns in the table must be given a value. This holds true
   * even when the row already exists and will therefore actually be updated.
   */
  insertOrUpdate?:
    | Mutation_Write
    | undefined;
  /**
   * Like [insert][google.spanner.v1.Mutation.insert], except that if the row already exists, it is
   * deleted, and the column values provided are inserted
   * instead. Unlike [insert_or_update][google.spanner.v1.Mutation.insert_or_update], this means any values not
   * explicitly written become `NULL`.
   *
   * In an interleaved table, if you create the child table with the
   * `ON DELETE CASCADE` annotation, then replacing a parent row
   * also deletes the child rows. Otherwise, you must delete the
   * child rows before you replace the parent row.
   */
  replace?:
    | Mutation_Write
    | undefined;
  /**
   * Delete rows from a table. Succeeds whether or not the named
   * rows were present.
   */
  delete?: Mutation_Delete | undefined;
}

/**
 * Arguments to [insert][google.spanner.v1.Mutation.insert], [update][google.spanner.v1.Mutation.update], [insert_or_update][google.spanner.v1.Mutation.insert_or_update], and
 * [replace][google.spanner.v1.Mutation.replace] operations.
 */
export interface Mutation_Write {
  /** Required. The table whose rows will be written. */
  table: string;
  /**
   * The names of the columns in [table][google.spanner.v1.Mutation.Write.table] to be written.
   *
   * The list of columns must contain enough columns to allow
   * Cloud Spanner to derive values for all primary key columns in the
   * row(s) to be modified.
   */
  columns: string[];
  /**
   * The values to be written. `values` can contain more than one
   * list of values. If it does, then multiple rows are written, one
   * for each entry in `values`. Each list in `values` must have
   * exactly as many entries as there are entries in [columns][google.spanner.v1.Mutation.Write.columns]
   * above. Sending multiple lists is equivalent to sending multiple
   * `Mutation`s, each containing one `values` entry and repeating
   * [table][google.spanner.v1.Mutation.Write.table] and [columns][google.spanner.v1.Mutation.Write.columns]. Individual values in each list are
   * encoded as described [here][google.spanner.v1.TypeCode].
   */
  values: Array<any>[];
}

/** Arguments to [delete][google.spanner.v1.Mutation.delete] operations. */
export interface Mutation_Delete {
  /** Required. The table whose rows will be deleted. */
  table: string;
  /**
   * Required. The primary keys of the rows within [table][google.spanner.v1.Mutation.Delete.table] to delete.  The
   * primary keys must be specified in the order in which they appear in the
   * `PRIMARY KEY()` clause of the table's equivalent DDL statement (the DDL
   * statement used to create the table).
   * Delete is idempotent. The transaction will succeed even if some or all
   * rows do not exist.
   */
  keySet: KeySet | undefined;
}

function createBaseMutation(): Mutation {
  return { insert: undefined, update: undefined, insertOrUpdate: undefined, replace: undefined, delete: undefined };
}

export const Mutation: MessageFns<Mutation> = {
  encode(message: Mutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.insert !== undefined) {
      Mutation_Write.encode(message.insert, writer.uint32(10).fork()).join();
    }
    if (message.update !== undefined) {
      Mutation_Write.encode(message.update, writer.uint32(18).fork()).join();
    }
    if (message.insertOrUpdate !== undefined) {
      Mutation_Write.encode(message.insertOrUpdate, writer.uint32(26).fork()).join();
    }
    if (message.replace !== undefined) {
      Mutation_Write.encode(message.replace, writer.uint32(34).fork()).join();
    }
    if (message.delete !== undefined) {
      Mutation_Delete.encode(message.delete, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.insert = Mutation_Write.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.update = Mutation_Write.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.insertOrUpdate = Mutation_Write.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.replace = Mutation_Write.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.delete = Mutation_Delete.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation {
    return {
      insert: isSet(object.insert) ? Mutation_Write.fromJSON(object.insert) : undefined,
      update: isSet(object.update) ? Mutation_Write.fromJSON(object.update) : undefined,
      insertOrUpdate: isSet(object.insertOrUpdate) ? Mutation_Write.fromJSON(object.insertOrUpdate) : undefined,
      replace: isSet(object.replace) ? Mutation_Write.fromJSON(object.replace) : undefined,
      delete: isSet(object.delete) ? Mutation_Delete.fromJSON(object.delete) : undefined,
    };
  },

  toJSON(message: Mutation): unknown {
    const obj: any = {};
    if (message.insert !== undefined) {
      obj.insert = Mutation_Write.toJSON(message.insert);
    }
    if (message.update !== undefined) {
      obj.update = Mutation_Write.toJSON(message.update);
    }
    if (message.insertOrUpdate !== undefined) {
      obj.insertOrUpdate = Mutation_Write.toJSON(message.insertOrUpdate);
    }
    if (message.replace !== undefined) {
      obj.replace = Mutation_Write.toJSON(message.replace);
    }
    if (message.delete !== undefined) {
      obj.delete = Mutation_Delete.toJSON(message.delete);
    }
    return obj;
  },

  create(base?: DeepPartial<Mutation>): Mutation {
    return Mutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mutation>): Mutation {
    const message = createBaseMutation();
    message.insert = (object.insert !== undefined && object.insert !== null)
      ? Mutation_Write.fromPartial(object.insert)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? Mutation_Write.fromPartial(object.update)
      : undefined;
    message.insertOrUpdate = (object.insertOrUpdate !== undefined && object.insertOrUpdate !== null)
      ? Mutation_Write.fromPartial(object.insertOrUpdate)
      : undefined;
    message.replace = (object.replace !== undefined && object.replace !== null)
      ? Mutation_Write.fromPartial(object.replace)
      : undefined;
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? Mutation_Delete.fromPartial(object.delete)
      : undefined;
    return message;
  },
};

function createBaseMutation_Write(): Mutation_Write {
  return { table: "", columns: [], values: [] };
}

export const Mutation_Write: MessageFns<Mutation_Write> = {
  encode(message: Mutation_Write, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.values) {
      ListValue.encode(ListValue.wrap(v!), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mutation_Write {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation_Write();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation_Write {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => [...e]) : [],
    };
  },

  toJSON(message: Mutation_Write): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<Mutation_Write>): Mutation_Write {
    return Mutation_Write.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mutation_Write>): Mutation_Write {
    const message = createBaseMutation_Write();
    message.table = object.table ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseMutation_Delete(): Mutation_Delete {
  return { table: "", keySet: undefined };
}

export const Mutation_Delete: MessageFns<Mutation_Delete> = {
  encode(message: Mutation_Delete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.keySet !== undefined) {
      KeySet.encode(message.keySet, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mutation_Delete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation_Delete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keySet = KeySet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation_Delete {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      keySet: isSet(object.keySet) ? KeySet.fromJSON(object.keySet) : undefined,
    };
  },

  toJSON(message: Mutation_Delete): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.keySet !== undefined) {
      obj.keySet = KeySet.toJSON(message.keySet);
    }
    return obj;
  },

  create(base?: DeepPartial<Mutation_Delete>): Mutation_Delete {
    return Mutation_Delete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Mutation_Delete>): Mutation_Delete {
    const message = createBaseMutation_Delete();
    message.table = object.table ?? "";
    message.keySet = (object.keySet !== undefined && object.keySet !== null)
      ? KeySet.fromPartial(object.keySet)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
