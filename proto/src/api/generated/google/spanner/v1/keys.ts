// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/spanner/v1/keys.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../protobuf/struct.js";

export const protobufPackage = "google.spanner.v1";

/**
 * KeyRange represents a range of rows in a table or index.
 *
 * A range has a start key and an end key. These keys can be open or
 * closed, indicating if the range includes rows with that key.
 *
 * Keys are represented by lists, where the ith value in the list
 * corresponds to the ith component of the table or index primary key.
 * Individual values are encoded as described
 * [here][google.spanner.v1.TypeCode].
 *
 * For example, consider the following table definition:
 *
 *     CREATE TABLE UserEvents (
 *       UserName STRING(MAX),
 *       EventDate STRING(10)
 *     ) PRIMARY KEY(UserName, EventDate);
 *
 * The following keys name rows in this table:
 *
 *     ["Bob", "2014-09-23"]
 *     ["Alfred", "2015-06-12"]
 *
 * Since the `UserEvents` table's `PRIMARY KEY` clause names two
 * columns, each `UserEvents` key has two elements; the first is the
 * `UserName`, and the second is the `EventDate`.
 *
 * Key ranges with multiple components are interpreted
 * lexicographically by component using the table or index key's declared
 * sort order. For example, the following range returns all events for
 * user `"Bob"` that occurred in the year 2015:
 *
 *     "start_closed": ["Bob", "2015-01-01"]
 *     "end_closed": ["Bob", "2015-12-31"]
 *
 * Start and end keys can omit trailing key components. This affects the
 * inclusion and exclusion of rows that exactly match the provided key
 * components: if the key is closed, then rows that exactly match the
 * provided components are included; if the key is open, then rows
 * that exactly match are not included.
 *
 * For example, the following range includes all events for `"Bob"` that
 * occurred during and after the year 2000:
 *
 *     "start_closed": ["Bob", "2000-01-01"]
 *     "end_closed": ["Bob"]
 *
 * The next example retrieves all events for `"Bob"`:
 *
 *     "start_closed": ["Bob"]
 *     "end_closed": ["Bob"]
 *
 * To retrieve events before the year 2000:
 *
 *     "start_closed": ["Bob"]
 *     "end_open": ["Bob", "2000-01-01"]
 *
 * The following range includes all rows in the table:
 *
 *     "start_closed": []
 *     "end_closed": []
 *
 * This range returns all users whose `UserName` begins with any
 * character from A to C:
 *
 *     "start_closed": ["A"]
 *     "end_open": ["D"]
 *
 * This range returns all users whose `UserName` begins with B:
 *
 *     "start_closed": ["B"]
 *     "end_open": ["C"]
 *
 * Key ranges honor column sort order. For example, suppose a table is
 * defined as follows:
 *
 *     CREATE TABLE DescendingSortedTable {
 *       Key INT64,
 *       ...
 *     ) PRIMARY KEY(Key DESC);
 *
 * The following range retrieves all rows with key values between 1
 * and 100 inclusive:
 *
 *     "start_closed": ["100"]
 *     "end_closed": ["1"]
 *
 * Note that 100 is passed as the start, and 1 is passed as the end,
 * because `Key` is a descending column in the schema.
 */
export interface KeyRange {
  /**
   * If the start is closed, then the range includes all rows whose
   * first `len(start_closed)` key columns exactly match `start_closed`.
   */
  startClosed?:
    | Array<any>
    | undefined;
  /**
   * If the start is open, then the range excludes rows whose first
   * `len(start_open)` key columns exactly match `start_open`.
   */
  startOpen?:
    | Array<any>
    | undefined;
  /**
   * If the end is closed, then the range includes all rows whose
   * first `len(end_closed)` key columns exactly match `end_closed`.
   */
  endClosed?:
    | Array<any>
    | undefined;
  /**
   * If the end is open, then the range excludes rows whose first
   * `len(end_open)` key columns exactly match `end_open`.
   */
  endOpen?: Array<any> | undefined;
}

/**
 * `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All
 * the keys are expected to be in the same table or index. The keys need
 * not be sorted in any particular way.
 *
 * If the same key is specified multiple times in the set (for example
 * if two ranges, two keys, or a key and a range overlap), Cloud Spanner
 * behaves as if the key were only specified once.
 */
export interface KeySet {
  /**
   * A list of specific keys. Entries in `keys` should have exactly as
   * many elements as there are columns in the primary or index key
   * with which this `KeySet` is used.  Individual key values are
   * encoded as described [here][google.spanner.v1.TypeCode].
   */
  keys: Array<any>[];
  /**
   * A list of key ranges. See [KeyRange][google.spanner.v1.KeyRange] for more information about
   * key range specifications.
   */
  ranges: KeyRange[];
  /**
   * For convenience `all` can be set to `true` to indicate that this
   * `KeySet` matches all keys in the table or index. Note that any keys
   * specified in `keys` or `ranges` are only yielded once.
   */
  all: boolean;
}

function createBaseKeyRange(): KeyRange {
  return { startClosed: undefined, startOpen: undefined, endClosed: undefined, endOpen: undefined };
}

export const KeyRange: MessageFns<KeyRange> = {
  encode(message: KeyRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startClosed !== undefined) {
      ListValue.encode(ListValue.wrap(message.startClosed), writer.uint32(10).fork()).join();
    }
    if (message.startOpen !== undefined) {
      ListValue.encode(ListValue.wrap(message.startOpen), writer.uint32(18).fork()).join();
    }
    if (message.endClosed !== undefined) {
      ListValue.encode(ListValue.wrap(message.endClosed), writer.uint32(26).fork()).join();
    }
    if (message.endOpen !== undefined) {
      ListValue.encode(ListValue.wrap(message.endOpen), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startClosed = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startOpen = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endClosed = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endOpen = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRange {
    return {
      startClosed: globalThis.Array.isArray(object.startClosed) ? [...object.startClosed] : undefined,
      startOpen: globalThis.Array.isArray(object.startOpen) ? [...object.startOpen] : undefined,
      endClosed: globalThis.Array.isArray(object.endClosed) ? [...object.endClosed] : undefined,
      endOpen: globalThis.Array.isArray(object.endOpen) ? [...object.endOpen] : undefined,
    };
  },

  toJSON(message: KeyRange): unknown {
    const obj: any = {};
    if (message.startClosed !== undefined) {
      obj.startClosed = message.startClosed;
    }
    if (message.startOpen !== undefined) {
      obj.startOpen = message.startOpen;
    }
    if (message.endClosed !== undefined) {
      obj.endClosed = message.endClosed;
    }
    if (message.endOpen !== undefined) {
      obj.endOpen = message.endOpen;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyRange>): KeyRange {
    return KeyRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyRange>): KeyRange {
    const message = createBaseKeyRange();
    message.startClosed = object.startClosed ?? undefined;
    message.startOpen = object.startOpen ?? undefined;
    message.endClosed = object.endClosed ?? undefined;
    message.endOpen = object.endOpen ?? undefined;
    return message;
  },
};

function createBaseKeySet(): KeySet {
  return { keys: [], ranges: [], all: false };
}

export const KeySet: MessageFns<KeySet> = {
  encode(message: KeySet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      ListValue.encode(ListValue.wrap(v!), writer.uint32(10).fork()).join();
    }
    for (const v of message.ranges) {
      KeyRange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.all !== false) {
      writer.uint32(24).bool(message.all);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeySet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeySet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ranges.push(KeyRange.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.all = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeySet {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => [...e]) : [],
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => KeyRange.fromJSON(e)) : [],
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
    };
  },

  toJSON(message: KeySet): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => KeyRange.toJSON(e));
    }
    if (message.all !== false) {
      obj.all = message.all;
    }
    return obj;
  },

  create(base?: DeepPartial<KeySet>): KeySet {
    return KeySet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeySet>): KeySet {
    const message = createBaseKeySet();
    message.keys = object.keys?.map((e) => e) || [];
    message.ranges = object.ranges?.map((e) => KeyRange.fromPartial(e)) || [];
    message.all = object.all ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
