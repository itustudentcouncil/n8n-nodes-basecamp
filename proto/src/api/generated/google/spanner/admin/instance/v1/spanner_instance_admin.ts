// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/spanner/admin/instance/v1/spanner_instance_admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../../iam/v1/iam_policy.js";
import { Policy } from "../../../../iam/v1/policy.js";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { FulfillmentPeriod, fulfillmentPeriodFromJSON, fulfillmentPeriodToJSON, OperationProgress } from "./common.js";

export const protobufPackage = "google.spanner.admin.instance.v1";

export interface ReplicaInfo {
  /** The location of the serving resources, e.g. "us-central1". */
  location: string;
  /** The type of replica. */
  type: ReplicaInfo_ReplicaType;
  /**
   * If true, this location is designated as the default leader location where
   * leader replicas are placed. See the [region types
   * documentation](https://cloud.google.com/spanner/docs/instances#region_types)
   * for more details.
   */
  defaultLeaderLocation: boolean;
}

/**
 * Indicates the type of replica.  See the [replica types
 * documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
 * for more details.
 */
export enum ReplicaInfo_ReplicaType {
  /** TYPE_UNSPECIFIED - Not specified. */
  TYPE_UNSPECIFIED = 0,
  /**
   * READ_WRITE - Read-write replicas support both reads and writes. These replicas:
   *
   * * Maintain a full copy of your data.
   * * Serve reads.
   * * Can vote whether to commit a write.
   * * Participate in leadership election.
   * * Are eligible to become a leader.
   */
  READ_WRITE = 1,
  /**
   * READ_ONLY - Read-only replicas only support reads (not writes). Read-only replicas:
   *
   * * Maintain a full copy of your data.
   * * Serve reads.
   * * Do not participate in voting to commit writes.
   * * Are not eligible to become a leader.
   */
  READ_ONLY = 2,
  /**
   * WITNESS - Witness replicas don't support reads but do participate in voting to
   * commit writes. Witness replicas:
   *
   * * Do not maintain a full copy of data.
   * * Do not serve reads.
   * * Vote whether to commit writes.
   * * Participate in leader election but are not eligible to become leader.
   */
  WITNESS = 3,
  UNRECOGNIZED = -1,
}

export function replicaInfo_ReplicaTypeFromJSON(object: any): ReplicaInfo_ReplicaType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ReplicaInfo_ReplicaType.TYPE_UNSPECIFIED;
    case 1:
    case "READ_WRITE":
      return ReplicaInfo_ReplicaType.READ_WRITE;
    case 2:
    case "READ_ONLY":
      return ReplicaInfo_ReplicaType.READ_ONLY;
    case 3:
    case "WITNESS":
      return ReplicaInfo_ReplicaType.WITNESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReplicaInfo_ReplicaType.UNRECOGNIZED;
  }
}

export function replicaInfo_ReplicaTypeToJSON(object: ReplicaInfo_ReplicaType): string {
  switch (object) {
    case ReplicaInfo_ReplicaType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ReplicaInfo_ReplicaType.READ_WRITE:
      return "READ_WRITE";
    case ReplicaInfo_ReplicaType.READ_ONLY:
      return "READ_ONLY";
    case ReplicaInfo_ReplicaType.WITNESS:
      return "WITNESS";
    case ReplicaInfo_ReplicaType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A possible configuration for a Cloud Spanner instance. Configurations
 * define the geographic placement of nodes and their replication.
 */
export interface InstanceConfig {
  /**
   * A unique identifier for the instance configuration.  Values
   * are of the form
   * `projects/<project>/instanceConfigs/[a-z][-a-z0-9]*`.
   *
   * User instance configuration must start with `custom-`.
   */
  name: string;
  /** The name of this instance configuration as it appears in UIs. */
  displayName: string;
  /**
   * Output only. Whether this instance configuration is a Google-managed or
   * user-managed configuration.
   */
  configType: InstanceConfig_Type;
  /**
   * The geographic placement of nodes in this instance configuration and their
   * replication properties.
   */
  replicas: ReplicaInfo[];
  /**
   * Output only. The available optional replicas to choose from for user
   * managed configurations. Populated for Google managed configurations.
   */
  optionalReplicas: ReplicaInfo[];
  /**
   * Base configuration name, e.g. projects/<project_name>/instanceConfigs/nam3,
   * based on which this configuration is created. Only set for user managed
   * configurations. `base_config` must refer to a configuration of type
   * GOOGLE_MANAGED in the same project as this configuration.
   */
  baseConfig: string;
  /**
   * Cloud Labels are a flexible and lightweight mechanism for organizing cloud
   * resources into groups that reflect a customer's organizational needs and
   * deployment strategies. Cloud Labels can be used to filter collections of
   * resources. They can be used to control how resource metrics are aggregated.
   * And they can be used as arguments to policy management rules (e.g. route,
   * firewall, load balancing, etc.).
   *
   *  * Label keys must be between 1 and 63 characters long and must conform to
   *    the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
   *  * Label values must be between 0 and 63 characters long and must conform
   *    to the regular expression `[a-z0-9_-]{0,63}`.
   *  * No more than 64 labels can be associated with a given resource.
   *
   * See https://goo.gl/xmQnxf for more information on and examples of labels.
   *
   * If you plan to use labels in your own code, please note that additional
   * characters may be allowed in the future. Therefore, you are advised to use
   * an internal label representation, such as JSON, which doesn't rely upon
   * specific characters being disallowed.  For example, representing labels
   * as the string:  name + "_" + value  would prove problematic if we were to
   * allow "_" in a future release.
   */
  labels: { [key: string]: string };
  /**
   * etag is used for optimistic concurrency control as a way
   * to help prevent simultaneous updates of a instance configuration from
   * overwriting each other. It is strongly suggested that systems make use of
   * the etag in the read-modify-write cycle to perform instance configuration
   * updates in order to avoid race conditions: An etag is returned in the
   * response which contains instance configurations, and systems are expected
   * to put that etag in the request to update instance configuration to ensure
   * that their change is applied to the same version of the instance
   * configuration. If no etag is provided in the call to update the instance
   * configuration, then the existing instance configuration is overwritten
   * blindly.
   */
  etag: string;
  /**
   * Allowed values of the "default_leader" schema option for databases in
   * instances that use this instance configuration.
   */
  leaderOptions: string[];
  /**
   * Output only. If true, the instance configuration is being created or
   * updated. If false, there are no ongoing operations for the instance
   * configuration.
   */
  reconciling: boolean;
  /**
   * Output only. The current instance configuration state. Applicable only for
   * `USER_MANAGED` configurations.
   */
  state: InstanceConfig_State;
}

/** The type of this configuration. */
export enum InstanceConfig_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** GOOGLE_MANAGED - Google managed configuration. */
  GOOGLE_MANAGED = 1,
  /** USER_MANAGED - User managed configuration. */
  USER_MANAGED = 2,
  UNRECOGNIZED = -1,
}

export function instanceConfig_TypeFromJSON(object: any): InstanceConfig_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return InstanceConfig_Type.TYPE_UNSPECIFIED;
    case 1:
    case "GOOGLE_MANAGED":
      return InstanceConfig_Type.GOOGLE_MANAGED;
    case 2:
    case "USER_MANAGED":
      return InstanceConfig_Type.USER_MANAGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceConfig_Type.UNRECOGNIZED;
  }
}

export function instanceConfig_TypeToJSON(object: InstanceConfig_Type): string {
  switch (object) {
    case InstanceConfig_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case InstanceConfig_Type.GOOGLE_MANAGED:
      return "GOOGLE_MANAGED";
    case InstanceConfig_Type.USER_MANAGED:
      return "USER_MANAGED";
    case InstanceConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates the current state of the instance configuration. */
export enum InstanceConfig_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The instance configuration is still being created. */
  CREATING = 1,
  /**
   * READY - The instance configuration is fully created and ready to be used to
   * create instances.
   */
  READY = 2,
  UNRECOGNIZED = -1,
}

export function instanceConfig_StateFromJSON(object: any): InstanceConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return InstanceConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return InstanceConfig_State.CREATING;
    case 2:
    case "READY":
      return InstanceConfig_State.READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceConfig_State.UNRECOGNIZED;
  }
}

export function instanceConfig_StateToJSON(object: InstanceConfig_State): string {
  switch (object) {
    case InstanceConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case InstanceConfig_State.CREATING:
      return "CREATING";
    case InstanceConfig_State.READY:
      return "READY";
    case InstanceConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InstanceConfig_LabelsEntry {
  key: string;
  value: string;
}

/** Autoscaling configuration for an instance. */
export interface AutoscalingConfig {
  /** Required. Autoscaling limits for an instance. */
  autoscalingLimits:
    | AutoscalingConfig_AutoscalingLimits
    | undefined;
  /** Required. The autoscaling targets for an instance. */
  autoscalingTargets: AutoscalingConfig_AutoscalingTargets | undefined;
}

/**
 * The autoscaling limits for the instance. Users can define the minimum and
 * maximum compute capacity allocated to the instance, and the autoscaler will
 * only scale within that range. Users can either use nodes or processing
 * units to specify the limits, but should use the same unit to set both the
 * min_limit and max_limit.
 */
export interface AutoscalingConfig_AutoscalingLimits {
  /**
   * Minimum number of nodes allocated to the instance. If set, this number
   * should be greater than or equal to 1.
   */
  minNodes?:
    | number
    | undefined;
  /**
   * Minimum number of processing units allocated to the instance. If set,
   * this number should be multiples of 1000.
   */
  minProcessingUnits?:
    | number
    | undefined;
  /**
   * Maximum number of nodes allocated to the instance. If set, this number
   * should be greater than or equal to min_nodes.
   */
  maxNodes?:
    | number
    | undefined;
  /**
   * Maximum number of processing units allocated to the instance. If set,
   * this number should be multiples of 1000 and be greater than or equal to
   * min_processing_units.
   */
  maxProcessingUnits?: number | undefined;
}

/** The autoscaling targets for an instance. */
export interface AutoscalingConfig_AutoscalingTargets {
  /**
   * Required. The target high priority cpu utilization percentage that the
   * autoscaler should be trying to achieve for the instance. This number is
   * on a scale from 0 (no utilization) to 100 (full utilization). The valid
   * range is [10, 90] inclusive.
   */
  highPriorityCpuUtilizationPercent: number;
  /**
   * Required. The target storage utilization percentage that the autoscaler
   * should be trying to achieve for the instance. This number is on a scale
   * from 0 (no utilization) to 100 (full utilization). The valid range is
   * [10, 100] inclusive.
   */
  storageUtilizationPercent: number;
}

/** An isolated set of Cloud Spanner resources on which databases can be hosted. */
export interface Instance {
  /**
   * Required. A unique identifier for the instance, which cannot be changed
   * after the instance is created. Values are of the form
   * `projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]`. The final
   * segment of the name must be between 2 and 64 characters in length.
   */
  name: string;
  /**
   * Required. The name of the instance's configuration. Values are of the form
   * `projects/<project>/instanceConfigs/<configuration>`. See
   * also [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
   * [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
   */
  config: string;
  /**
   * Required. The descriptive name for this instance as it appears in UIs.
   * Must be unique per project and between 4 and 30 characters in length.
   */
  displayName: string;
  /**
   * The number of nodes allocated to this instance. At most one of either
   * node_count or processing_units should be present in the message.
   *
   * Users can set the node_count field to specify the target number of nodes
   * allocated to the instance.
   *
   * This may be zero in API responses for instances that are not yet in state
   * `READY`.
   *
   * See [the
   * documentation](https://cloud.google.com/spanner/docs/compute-capacity)
   * for more information about nodes and processing units.
   */
  nodeCount: number;
  /**
   * The number of processing units allocated to this instance. At most one of
   * processing_units or node_count should be present in the message.
   *
   * Users can set the processing_units field to specify the target number of
   * processing units allocated to the instance.
   *
   * This may be zero in API responses for instances that are not yet in state
   * `READY`.
   *
   * See [the
   * documentation](https://cloud.google.com/spanner/docs/compute-capacity)
   * for more information about nodes and processing units.
   */
  processingUnits: number;
  /**
   * Optional. The autoscaling configuration. Autoscaling is enabled if this
   * field is set. When autoscaling is enabled, node_count and processing_units
   * are treated as OUTPUT_ONLY fields and reflect the current compute capacity
   * allocated to the instance.
   */
  autoscalingConfig:
    | AutoscalingConfig
    | undefined;
  /**
   * Output only. The current instance state. For
   * [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance],
   * the state must be either omitted or set to `CREATING`. For
   * [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance],
   * the state must be either omitted or set to `READY`.
   */
  state: Instance_State;
  /**
   * Cloud Labels are a flexible and lightweight mechanism for organizing cloud
   * resources into groups that reflect a customer's organizational needs and
   * deployment strategies. Cloud Labels can be used to filter collections of
   * resources. They can be used to control how resource metrics are aggregated.
   * And they can be used as arguments to policy management rules (e.g. route,
   * firewall, load balancing, etc.).
   *
   *  * Label keys must be between 1 and 63 characters long and must conform to
   *    the following regular expression: `[a-z][a-z0-9_-]{0,62}`.
   *  * Label values must be between 0 and 63 characters long and must conform
   *    to the regular expression `[a-z0-9_-]{0,63}`.
   *  * No more than 64 labels can be associated with a given resource.
   *
   * See https://goo.gl/xmQnxf for more information on and examples of labels.
   *
   * If you plan to use labels in your own code, please note that additional
   * characters may be allowed in the future. And so you are advised to use an
   * internal label representation, such as JSON, which doesn't rely upon
   * specific characters being disallowed.  For example, representing labels
   * as the string:  name + "_" + value  would prove problematic if we were to
   * allow "_" in a future release.
   */
  labels: { [key: string]: string };
  /** Deprecated. This field is not populated. */
  endpointUris: string[];
  /** Output only. The time at which the instance was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the instance was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. The `Edition` of the current instance. */
  edition: Instance_Edition;
}

/** Indicates the current state of the instance. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The instance is still being created. Resources may not be
   * available yet, and operations such as database creation may not
   * work.
   */
  CREATING = 1,
  /**
   * READY - The instance is fully created and ready to do work such as
   * creating databases.
   */
  READY = 2,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Instance_State.CREATING;
    case 2:
    case "READY":
      return Instance_State.READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.READY:
      return "READY";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The edition selected for this instance. Different editions provide
 * different capabilities at different price points.
 */
export enum Instance_Edition {
  /** EDITION_UNSPECIFIED - Edition not specified. */
  EDITION_UNSPECIFIED = 0,
  /** STANDARD - Standard edition. */
  STANDARD = 1,
  /** ENTERPRISE - Enterprise edition. */
  ENTERPRISE = 2,
  /** ENTERPRISE_PLUS - Enterprise Plus edition. */
  ENTERPRISE_PLUS = 3,
  UNRECOGNIZED = -1,
}

export function instance_EditionFromJSON(object: any): Instance_Edition {
  switch (object) {
    case 0:
    case "EDITION_UNSPECIFIED":
      return Instance_Edition.EDITION_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return Instance_Edition.STANDARD;
    case 2:
    case "ENTERPRISE":
      return Instance_Edition.ENTERPRISE;
    case 3:
    case "ENTERPRISE_PLUS":
      return Instance_Edition.ENTERPRISE_PLUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_Edition.UNRECOGNIZED;
  }
}

export function instance_EditionToJSON(object: Instance_Edition): string {
  switch (object) {
    case Instance_Edition.EDITION_UNSPECIFIED:
      return "EDITION_UNSPECIFIED";
    case Instance_Edition.STANDARD:
      return "STANDARD";
    case Instance_Edition.ENTERPRISE:
      return "ENTERPRISE";
    case Instance_Edition.ENTERPRISE_PLUS:
      return "ENTERPRISE_PLUS";
    case Instance_Edition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The request for
 * [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
 */
export interface ListInstanceConfigsRequest {
  /**
   * Required. The name of the project for which a list of supported instance
   * configurations is requested. Values are of the form
   * `projects/<project>`.
   */
  parent: string;
  /**
   * Number of instance configurations to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]
   * from a previous
   * [ListInstanceConfigsResponse][google.spanner.admin.instance.v1.ListInstanceConfigsResponse].
   */
  pageToken: string;
}

/**
 * The response for
 * [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
 */
export interface ListInstanceConfigsResponse {
  /** The list of requested instance configurations. */
  instanceConfigs: InstanceConfig[];
  /**
   * `next_page_token` can be sent in a subsequent
   * [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs]
   * call to fetch more of the matching instance configurations.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [GetInstanceConfigRequest][google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig].
 */
export interface GetInstanceConfigRequest {
  /**
   * Required. The name of the requested instance configuration. Values are of
   * the form `projects/<project>/instanceConfigs/<config>`.
   */
  name: string;
}

/**
 * The request for
 * [CreateInstanceConfigRequest][InstanceAdmin.CreateInstanceConfigRequest].
 */
export interface CreateInstanceConfigRequest {
  /**
   * Required. The name of the project in which to create the instance
   * configuration. Values are of the form `projects/<project>`.
   */
  parent: string;
  /**
   * Required. The ID of the instance configuration to create. Valid identifiers
   * are of the form `custom-[-a-z0-9]*[a-z0-9]` and must be between 2 and 64
   * characters in length. The `custom-` prefix is required to avoid name
   * conflicts with Google-managed configurations.
   */
  instanceConfigId: string;
  /**
   * Required. The InstanceConfig proto of the configuration to create.
   * instance_config.name must be
   * `<parent>/instanceConfigs/<instance_config_id>`.
   * instance_config.base_config must be a Google managed configuration name,
   * e.g. <parent>/instanceConfigs/us-east1, <parent>/instanceConfigs/nam3.
   */
  instanceConfig:
    | InstanceConfig
    | undefined;
  /**
   * An option to validate, but not actually execute, a request,
   * and provide the same response.
   */
  validateOnly: boolean;
}

/**
 * The request for
 * [UpdateInstanceConfigRequest][InstanceAdmin.UpdateInstanceConfigRequest].
 */
export interface UpdateInstanceConfigRequest {
  /**
   * Required. The user instance configuration to update, which must always
   * include the instance configuration name. Otherwise, only fields mentioned
   * in
   * [update_mask][google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask]
   * need be included. To prevent conflicts of concurrent updates,
   * [etag][google.spanner.admin.instance.v1.InstanceConfig.reconciling] can
   * be used.
   */
  instanceConfig:
    | InstanceConfig
    | undefined;
  /**
   * Required. A mask specifying which fields in
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] should be
   * updated. The field mask must always be specified; this prevents any future
   * fields in [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig]
   * from being erased accidentally by clients that do not know about them. Only
   * display_name and labels can be updated.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * An option to validate, but not actually execute, a request,
   * and provide the same response.
   */
  validateOnly: boolean;
}

/**
 * The request for
 * [DeleteInstanceConfigRequest][InstanceAdmin.DeleteInstanceConfigRequest].
 */
export interface DeleteInstanceConfigRequest {
  /**
   * Required. The name of the instance configuration to be deleted.
   * Values are of the form
   * `projects/<project>/instanceConfigs/<instance_config>`
   */
  name: string;
  /**
   * Used for optimistic concurrency control as a way to help prevent
   * simultaneous deletes of an instance configuration from overwriting each
   * other. If not empty, the API
   * only deletes the instance configuration when the etag provided matches the
   * current status of the requested instance configuration. Otherwise, deletes
   * the instance configuration without checking the current status of the
   * requested instance configuration.
   */
  etag: string;
  /**
   * An option to validate, but not actually execute, a request,
   * and provide the same response.
   */
  validateOnly: boolean;
}

/**
 * The request for
 * [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
 */
export interface ListInstanceConfigOperationsRequest {
  /**
   * Required. The project of the instance configuration operations.
   * Values are of the form `projects/<project>`.
   */
  parent: string;
  /**
   * An expression that filters the list of returned operations.
   *
   * A filter expression consists of a field name, a
   * comparison operator, and a value for filtering.
   * The value must be a string, a number, or a boolean. The comparison operator
   * must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
   * Colon `:` is the contains operator. Filter rules are not case sensitive.
   *
   * The following fields in the [Operation][google.longrunning.Operation]
   * are eligible for filtering:
   *
   *   * `name` - The name of the long-running operation
   *   * `done` - False if the operation is in progress, else true.
   *   * `metadata.@type` - the type of metadata. For example, the type string
   *      for
   *      [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata]
   *      is
   *      `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata`.
   *   * `metadata.<field_name>` - any field in metadata.value.
   *      `metadata.@type` must be specified first, if filtering on metadata
   *      fields.
   *   * `error` - Error associated with the long-running operation.
   *   * `response.@type` - the type of response.
   *   * `response.<field_name>` - any field in response.value.
   *
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. By default, expressions are combined with AND logic. However,
   * you can specify AND, OR, and NOT logic explicitly.
   *
   * Here are a few examples:
   *
   *   * `done:true` - The operation is complete.
   *   * `(metadata.@type=` \
   *     `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstanceConfigMetadata)
   *     AND` \
   *     `(metadata.instance_config.name:custom-config) AND` \
   *     `(metadata.progress.start_time < \"2021-03-28T14:50:00Z\") AND` \
   *     `(error:*)` - Return operations where:
   *     * The operation's metadata type is
   *     [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
   *     * The instance configuration name contains "custom-config".
   *     * The operation started before 2021-03-28T14:50:00Z.
   *     * The operation resulted in an error.
   */
  filter: string;
  /**
   * Number of operations to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token]
   * from a previous
   * [ListInstanceConfigOperationsResponse][google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse]
   * to the same `parent` and with the same `filter`.
   */
  pageToken: string;
}

/**
 * The response for
 * [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations].
 */
export interface ListInstanceConfigOperationsResponse {
  /**
   * The list of matching instance configuration [long-running
   * operations][google.longrunning.Operation]. Each operation's name will be
   * prefixed by the name of the instance configuration. The operation's
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata.
   */
  operations: Operation[];
  /**
   * `next_page_token` can be sent in a subsequent
   * [ListInstanceConfigOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigOperations]
   * call to fetch more of the matching metadata.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [GetInstance][google.spanner.admin.instance.v1.InstanceAdmin.GetInstance].
 */
export interface GetInstanceRequest {
  /**
   * Required. The name of the requested instance. Values are of the form
   * `projects/<project>/instances/<instance>`.
   */
  name: string;
  /**
   * If field_mask is present, specifies the subset of
   * [Instance][google.spanner.admin.instance.v1.Instance] fields that should be
   * returned. If absent, all
   * [Instance][google.spanner.admin.instance.v1.Instance] fields are returned.
   */
  fieldMask: string[] | undefined;
}

/**
 * The request for
 * [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
 */
export interface CreateInstanceRequest {
  /**
   * Required. The name of the project in which to create the instance. Values
   * are of the form `projects/<project>`.
   */
  parent: string;
  /**
   * Required. The ID of the instance to create.  Valid identifiers are of the
   * form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters in
   * length.
   */
  instanceId: string;
  /**
   * Required. The instance to create.  The name may be omitted, but if
   * specified must be `<parent>/instances/<instance_id>`.
   */
  instance: Instance | undefined;
}

/**
 * The request for
 * [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
 */
export interface ListInstancesRequest {
  /**
   * Required. The name of the project for which a list of instances is
   * requested. Values are of the form `projects/<project>`.
   */
  parent: string;
  /**
   * Number of instances to be returned in the response. If 0 or less, defaults
   * to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token]
   * from a previous
   * [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
   */
  pageToken: string;
  /**
   * An expression for filtering the results of the request. Filter rules are
   * case insensitive. The fields eligible for filtering are:
   *
   *   * `name`
   *   * `display_name`
   *   * `labels.key` where key is the name of a label
   *
   * Some examples of using filters are:
   *
   *   * `name:*` --> The instance has a name.
   *   * `name:Howl` --> The instance's name contains the string "howl".
   *   * `name:HOWL` --> Equivalent to above.
   *   * `NAME:howl` --> Equivalent to above.
   *   * `labels.env:*` --> The instance has the label "env".
   *   * `labels.env:dev` --> The instance has the label "env" and the value of
   *                        the label contains the string "dev".
   *   * `name:howl labels.env:dev` --> The instance's name contains "howl" and
   *                                  it has the label "env" with its value
   *                                  containing "dev".
   */
  filter: string;
  /**
   * Deadline used while retrieving metadata for instances.
   * Instances whose metadata cannot be retrieved within this deadline will be
   * added to
   * [unreachable][google.spanner.admin.instance.v1.ListInstancesResponse.unreachable]
   * in
   * [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
   */
  instanceDeadline: Date | undefined;
}

/**
 * The response for
 * [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
 */
export interface ListInstancesResponse {
  /** The list of requested instances. */
  instances: Instance[];
  /**
   * `next_page_token` can be sent in a subsequent
   * [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances]
   * call to fetch more of the matching instances.
   */
  nextPageToken: string;
  /**
   * The list of unreachable instances.
   * It includes the names of instances whose metadata could not be retrieved
   * within
   * [instance_deadline][google.spanner.admin.instance.v1.ListInstancesRequest.instance_deadline].
   */
  unreachable: string[];
}

/**
 * The request for
 * [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
 */
export interface UpdateInstanceRequest {
  /**
   * Required. The instance to update, which must always include the instance
   * name.  Otherwise, only fields mentioned in
   * [field_mask][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask]
   * need be included.
   */
  instance:
    | Instance
    | undefined;
  /**
   * Required. A mask specifying which fields in
   * [Instance][google.spanner.admin.instance.v1.Instance] should be updated.
   * The field mask must always be specified; this prevents any future fields in
   * [Instance][google.spanner.admin.instance.v1.Instance] from being erased
   * accidentally by clients that do not know about them.
   */
  fieldMask: string[] | undefined;
}

/**
 * The request for
 * [DeleteInstance][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance].
 */
export interface DeleteInstanceRequest {
  /**
   * Required. The name of the instance to be deleted. Values are of the form
   * `projects/<project>/instances/<instance>`
   */
  name: string;
}

/**
 * Metadata type for the operation returned by
 * [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
 */
export interface CreateInstanceMetadata {
  /** The instance being created. */
  instance:
    | Instance
    | undefined;
  /**
   * The time at which the
   * [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance]
   * request was received.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The time at which this operation was cancelled. If set, this operation is
   * in the process of undoing itself (which is guaranteed to succeed) and
   * cannot be cancelled again.
   */
  cancelTime:
    | Date
    | undefined;
  /** The time at which this operation failed or was completed successfully. */
  endTime:
    | Date
    | undefined;
  /** The expected fulfillment period of this create operation. */
  expectedFulfillmentPeriod: FulfillmentPeriod;
}

/**
 * Metadata type for the operation returned by
 * [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
 */
export interface UpdateInstanceMetadata {
  /** The desired end state of the update. */
  instance:
    | Instance
    | undefined;
  /**
   * The time at which
   * [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]
   * request was received.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The time at which this operation was cancelled. If set, this operation is
   * in the process of undoing itself (which is guaranteed to succeed) and
   * cannot be cancelled again.
   */
  cancelTime:
    | Date
    | undefined;
  /** The time at which this operation failed or was completed successfully. */
  endTime:
    | Date
    | undefined;
  /** The expected fulfillment period of this update operation. */
  expectedFulfillmentPeriod: FulfillmentPeriod;
}

/**
 * Metadata type for the operation returned by
 * [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig].
 */
export interface CreateInstanceConfigMetadata {
  /** The target instance configuration end state. */
  instanceConfig:
    | InstanceConfig
    | undefined;
  /**
   * The progress of the
   * [CreateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstanceConfig]
   * operation.
   */
  progress:
    | OperationProgress
    | undefined;
  /** The time at which this operation was cancelled. */
  cancelTime: Date | undefined;
}

/**
 * Metadata type for the operation returned by
 * [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig].
 */
export interface UpdateInstanceConfigMetadata {
  /** The desired instance configuration after updating. */
  instanceConfig:
    | InstanceConfig
    | undefined;
  /**
   * The progress of the
   * [UpdateInstanceConfig][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstanceConfig]
   * operation.
   */
  progress:
    | OperationProgress
    | undefined;
  /** The time at which this operation was cancelled. */
  cancelTime: Date | undefined;
}

/**
 * An isolated set of Cloud Spanner resources that databases can define
 * placements on.
 */
export interface InstancePartition {
  /**
   * Required. A unique identifier for the instance partition. Values are of the
   * form
   * `projects/<project>/instances/<instance>/instancePartitions/[a-z][-a-z0-9]*[a-z0-9]`.
   * The final segment of the name must be between 2 and 64 characters in
   * length. An instance partition's name cannot be changed after the instance
   * partition is created.
   */
  name: string;
  /**
   * Required. The name of the instance partition's configuration. Values are of
   * the form `projects/<project>/instanceConfigs/<configuration>`. See also
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
   * [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
   */
  config: string;
  /**
   * Required. The descriptive name for this instance partition as it appears in
   * UIs. Must be unique per project and between 4 and 30 characters in length.
   */
  displayName: string;
  /**
   * The number of nodes allocated to this instance partition.
   *
   * Users can set the node_count field to specify the target number of nodes
   * allocated to the instance partition.
   *
   * This may be zero in API responses for instance partitions that are not
   * yet in state `READY`.
   */
  nodeCount?:
    | number
    | undefined;
  /**
   * The number of processing units allocated to this instance partition.
   *
   * Users can set the processing_units field to specify the target number of
   * processing units allocated to the instance partition.
   *
   * This may be zero in API responses for instance partitions that are not
   * yet in state `READY`.
   */
  processingUnits?:
    | number
    | undefined;
  /** Output only. The current instance partition state. */
  state: InstancePartition_State;
  /** Output only. The time at which the instance partition was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the instance partition was most recently
   * updated.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The names of the databases that reference this
   * instance partition. Referencing databases should share the parent instance.
   * The existence of any referencing database prevents the instance partition
   * from being deleted.
   */
  referencingDatabases: string[];
  /**
   * Output only. The names of the backups that reference this instance
   * partition. Referencing backups should share the parent instance. The
   * existence of any referencing backup prevents the instance partition from
   * being deleted.
   */
  referencingBackups: string[];
  /**
   * Used for optimistic concurrency control as a way
   * to help prevent simultaneous updates of a instance partition from
   * overwriting each other. It is strongly suggested that systems make use of
   * the etag in the read-modify-write cycle to perform instance partition
   * updates in order to avoid race conditions: An etag is returned in the
   * response which contains instance partitions, and systems are expected to
   * put that etag in the request to update instance partitions to ensure that
   * their change will be applied to the same version of the instance partition.
   * If no etag is provided in the call to update instance partition, then the
   * existing instance partition is overwritten blindly.
   */
  etag: string;
}

/** Indicates the current state of the instance partition. */
export enum InstancePartition_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The instance partition is still being created. Resources may not be
   * available yet, and operations such as creating placements using this
   * instance partition may not work.
   */
  CREATING = 1,
  /**
   * READY - The instance partition is fully created and ready to do work such as
   * creating placements and using in databases.
   */
  READY = 2,
  UNRECOGNIZED = -1,
}

export function instancePartition_StateFromJSON(object: any): InstancePartition_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return InstancePartition_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return InstancePartition_State.CREATING;
    case 2:
    case "READY":
      return InstancePartition_State.READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstancePartition_State.UNRECOGNIZED;
  }
}

export function instancePartition_StateToJSON(object: InstancePartition_State): string {
  switch (object) {
    case InstancePartition_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case InstancePartition_State.CREATING:
      return "CREATING";
    case InstancePartition_State.READY:
      return "READY";
    case InstancePartition_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Metadata type for the operation returned by
 * [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
 */
export interface CreateInstancePartitionMetadata {
  /** The instance partition being created. */
  instancePartition:
    | InstancePartition
    | undefined;
  /**
   * The time at which the
   * [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition]
   * request was received.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The time at which this operation was cancelled. If set, this operation is
   * in the process of undoing itself (which is guaranteed to succeed) and
   * cannot be cancelled again.
   */
  cancelTime:
    | Date
    | undefined;
  /** The time at which this operation failed or was completed successfully. */
  endTime: Date | undefined;
}

/**
 * The request for
 * [CreateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstancePartition].
 */
export interface CreateInstancePartitionRequest {
  /**
   * Required. The name of the instance in which to create the instance
   * partition. Values are of the form
   * `projects/<project>/instances/<instance>`.
   */
  parent: string;
  /**
   * Required. The ID of the instance partition to create. Valid identifiers are
   * of the form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64
   * characters in length.
   */
  instancePartitionId: string;
  /**
   * Required. The instance partition to create. The instance_partition.name may
   * be omitted, but if specified must be
   * `<parent>/instancePartitions/<instance_partition_id>`.
   */
  instancePartition: InstancePartition | undefined;
}

/**
 * The request for
 * [DeleteInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstancePartition].
 */
export interface DeleteInstancePartitionRequest {
  /**
   * Required. The name of the instance partition to be deleted.
   * Values are of the form
   * `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`
   */
  name: string;
  /**
   * Optional. If not empty, the API only deletes the instance partition when
   * the etag provided matches the current status of the requested instance
   * partition. Otherwise, deletes the instance partition without checking the
   * current status of the requested instance partition.
   */
  etag: string;
}

/**
 * The request for
 * [GetInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.GetInstancePartition].
 */
export interface GetInstancePartitionRequest {
  /**
   * Required. The name of the requested instance partition. Values are of
   * the form
   * `projects/{project}/instances/{instance}/instancePartitions/{instance_partition}`.
   */
  name: string;
}

/**
 * The request for
 * [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
 */
export interface UpdateInstancePartitionRequest {
  /**
   * Required. The instance partition to update, which must always include the
   * instance partition name. Otherwise, only fields mentioned in
   * [field_mask][google.spanner.admin.instance.v1.UpdateInstancePartitionRequest.field_mask]
   * need be included.
   */
  instancePartition:
    | InstancePartition
    | undefined;
  /**
   * Required. A mask specifying which fields in
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
   * should be updated. The field mask must always be specified; this prevents
   * any future fields in
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition]
   * from being erased accidentally by clients that do not know about them.
   */
  fieldMask: string[] | undefined;
}

/**
 * Metadata type for the operation returned by
 * [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition].
 */
export interface UpdateInstancePartitionMetadata {
  /** The desired end state of the update. */
  instancePartition:
    | InstancePartition
    | undefined;
  /**
   * The time at which
   * [UpdateInstancePartition][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstancePartition]
   * request was received.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The time at which this operation was cancelled. If set, this operation is
   * in the process of undoing itself (which is guaranteed to succeed) and
   * cannot be cancelled again.
   */
  cancelTime:
    | Date
    | undefined;
  /** The time at which this operation failed or was completed successfully. */
  endTime: Date | undefined;
}

/**
 * The request for
 * [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
 */
export interface ListInstancePartitionsRequest {
  /**
   * Required. The instance whose instance partitions should be listed. Values
   * are of the form `projects/<project>/instances/<instance>`.
   */
  parent: string;
  /**
   * Number of instance partitions to be returned in the response. If 0 or less,
   * defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.next_page_token]
   * from a previous
   * [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
   */
  pageToken: string;
  /**
   * Optional. Deadline used while retrieving metadata for instance partitions.
   * Instance partitions whose metadata cannot be retrieved within this deadline
   * will be added to
   * [unreachable][google.spanner.admin.instance.v1.ListInstancePartitionsResponse.unreachable]
   * in
   * [ListInstancePartitionsResponse][google.spanner.admin.instance.v1.ListInstancePartitionsResponse].
   */
  instancePartitionDeadline: Date | undefined;
}

/**
 * The response for
 * [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions].
 */
export interface ListInstancePartitionsResponse {
  /** The list of requested instancePartitions. */
  instancePartitions: InstancePartition[];
  /**
   * `next_page_token` can be sent in a subsequent
   * [ListInstancePartitions][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitions]
   * call to fetch more of the matching instance partitions.
   */
  nextPageToken: string;
  /**
   * The list of unreachable instance partitions.
   * It includes the names of instance partitions whose metadata could
   * not be retrieved within
   * [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionsRequest.instance_partition_deadline].
   */
  unreachable: string[];
}

/**
 * The request for
 * [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
 */
export interface ListInstancePartitionOperationsRequest {
  /**
   * Required. The parent instance of the instance partition operations.
   * Values are of the form `projects/<project>/instances/<instance>`.
   */
  parent: string;
  /**
   * Optional. An expression that filters the list of returned operations.
   *
   * A filter expression consists of a field name, a
   * comparison operator, and a value for filtering.
   * The value must be a string, a number, or a boolean. The comparison operator
   * must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
   * Colon `:` is the contains operator. Filter rules are not case sensitive.
   *
   * The following fields in the [Operation][google.longrunning.Operation]
   * are eligible for filtering:
   *
   *   * `name` - The name of the long-running operation
   *   * `done` - False if the operation is in progress, else true.
   *   * `metadata.@type` - the type of metadata. For example, the type string
   *      for
   *      [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata]
   *      is
   *      `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata`.
   *   * `metadata.<field_name>` - any field in metadata.value.
   *      `metadata.@type` must be specified first, if filtering on metadata
   *      fields.
   *   * `error` - Error associated with the long-running operation.
   *   * `response.@type` - the type of response.
   *   * `response.<field_name>` - any field in response.value.
   *
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. By default, expressions are combined with AND logic. However,
   * you can specify AND, OR, and NOT logic explicitly.
   *
   * Here are a few examples:
   *
   *   * `done:true` - The operation is complete.
   *   * `(metadata.@type=` \
   *     `type.googleapis.com/google.spanner.admin.instance.v1.CreateInstancePartitionMetadata)
   *     AND` \
   *     `(metadata.instance_partition.name:custom-instance-partition) AND` \
   *     `(metadata.start_time < \"2021-03-28T14:50:00Z\") AND` \
   *     `(error:*)` - Return operations where:
   *     * The operation's metadata type is
   *     [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
   *     * The instance partition name contains "custom-instance-partition".
   *     * The operation started before 2021-03-28T14:50:00Z.
   *     * The operation resulted in an error.
   */
  filter: string;
  /**
   * Optional. Number of operations to be returned in the response. If 0 or
   * less, defaults to the server's maximum allowed page size.
   */
  pageSize: number;
  /**
   * Optional. If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse.next_page_token]
   * from a previous
   * [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse]
   * to the same `parent` and with the same `filter`.
   */
  pageToken: string;
  /**
   * Optional. Deadline used while retrieving metadata for instance partition
   * operations. Instance partitions whose operation metadata cannot be
   * retrieved within this deadline will be added to
   * [unreachable][ListInstancePartitionOperationsResponse.unreachable] in
   * [ListInstancePartitionOperationsResponse][google.spanner.admin.instance.v1.ListInstancePartitionOperationsResponse].
   */
  instancePartitionDeadline: Date | undefined;
}

/**
 * The response for
 * [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations].
 */
export interface ListInstancePartitionOperationsResponse {
  /**
   * The list of matching instance partition [long-running
   * operations][google.longrunning.Operation]. Each operation's name will be
   * prefixed by the instance partition's name. The operation's
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata.
   */
  operations: Operation[];
  /**
   * `next_page_token` can be sent in a subsequent
   * [ListInstancePartitionOperations][google.spanner.admin.instance.v1.InstanceAdmin.ListInstancePartitionOperations]
   * call to fetch more of the matching metadata.
   */
  nextPageToken: string;
  /**
   * The list of unreachable instance partitions.
   * It includes the names of instance partitions whose operation metadata could
   * not be retrieved within
   * [instance_partition_deadline][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.instance_partition_deadline].
   */
  unreachableInstancePartitions: string[];
}

/**
 * The request for
 * [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
 */
export interface MoveInstanceRequest {
  /**
   * Required. The instance to move.
   * Values are of the form `projects/<project>/instances/<instance>`.
   */
  name: string;
  /**
   * Required. The target instance configuration where to move the instance.
   * Values are of the form `projects/<project>/instanceConfigs/<config>`.
   */
  targetConfig: string;
}

/**
 * The response for
 * [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
 */
export interface MoveInstanceResponse {
}

/**
 * Metadata type for the operation returned by
 * [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance].
 */
export interface MoveInstanceMetadata {
  /**
   * The target instance configuration where to move the instance.
   * Values are of the form `projects/<project>/instanceConfigs/<config>`.
   */
  targetConfig: string;
  /**
   * The progress of the
   * [MoveInstance][google.spanner.admin.instance.v1.InstanceAdmin.MoveInstance]
   * operation.
   * [progress_percent][google.spanner.admin.instance.v1.OperationProgress.progress_percent]
   * is reset when cancellation is requested.
   */
  progress:
    | OperationProgress
    | undefined;
  /** The time at which this operation was cancelled. */
  cancelTime: Date | undefined;
}

function createBaseReplicaInfo(): ReplicaInfo {
  return { location: "", type: 0, defaultLeaderLocation: false };
}

export const ReplicaInfo: MessageFns<ReplicaInfo> = {
  encode(message: ReplicaInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.defaultLeaderLocation !== false) {
      writer.uint32(24).bool(message.defaultLeaderLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplicaInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplicaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultLeaderLocation = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplicaInfo {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      type: isSet(object.type) ? replicaInfo_ReplicaTypeFromJSON(object.type) : 0,
      defaultLeaderLocation: isSet(object.defaultLeaderLocation)
        ? globalThis.Boolean(object.defaultLeaderLocation)
        : false,
    };
  },

  toJSON(message: ReplicaInfo): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.type !== 0) {
      obj.type = replicaInfo_ReplicaTypeToJSON(message.type);
    }
    if (message.defaultLeaderLocation !== false) {
      obj.defaultLeaderLocation = message.defaultLeaderLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplicaInfo>): ReplicaInfo {
    return ReplicaInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplicaInfo>): ReplicaInfo {
    const message = createBaseReplicaInfo();
    message.location = object.location ?? "";
    message.type = object.type ?? 0;
    message.defaultLeaderLocation = object.defaultLeaderLocation ?? false;
    return message;
  },
};

function createBaseInstanceConfig(): InstanceConfig {
  return {
    name: "",
    displayName: "",
    configType: 0,
    replicas: [],
    optionalReplicas: [],
    baseConfig: "",
    labels: {},
    etag: "",
    leaderOptions: [],
    reconciling: false,
    state: 0,
  };
}

export const InstanceConfig: MessageFns<InstanceConfig> = {
  encode(message: InstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.configType !== 0) {
      writer.uint32(40).int32(message.configType);
    }
    for (const v of message.replicas) {
      ReplicaInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.optionalReplicas) {
      ReplicaInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.baseConfig !== "") {
      writer.uint32(58).string(message.baseConfig);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      InstanceConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    for (const v of message.leaderOptions) {
      writer.uint32(34).string(v!);
    }
    if (message.reconciling !== false) {
      writer.uint32(80).bool(message.reconciling);
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.configType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.replicas.push(ReplicaInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.optionalReplicas.push(ReplicaInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.baseConfig = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = InstanceConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.leaderOptions.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      configType: isSet(object.configType) ? instanceConfig_TypeFromJSON(object.configType) : 0,
      replicas: globalThis.Array.isArray(object?.replicas)
        ? object.replicas.map((e: any) => ReplicaInfo.fromJSON(e))
        : [],
      optionalReplicas: globalThis.Array.isArray(object?.optionalReplicas)
        ? object.optionalReplicas.map((e: any) => ReplicaInfo.fromJSON(e))
        : [],
      baseConfig: isSet(object.baseConfig) ? globalThis.String(object.baseConfig) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      leaderOptions: globalThis.Array.isArray(object?.leaderOptions)
        ? object.leaderOptions.map((e: any) => globalThis.String(e))
        : [],
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      state: isSet(object.state) ? instanceConfig_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: InstanceConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.configType !== 0) {
      obj.configType = instanceConfig_TypeToJSON(message.configType);
    }
    if (message.replicas?.length) {
      obj.replicas = message.replicas.map((e) => ReplicaInfo.toJSON(e));
    }
    if (message.optionalReplicas?.length) {
      obj.optionalReplicas = message.optionalReplicas.map((e) => ReplicaInfo.toJSON(e));
    }
    if (message.baseConfig !== "") {
      obj.baseConfig = message.baseConfig;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.leaderOptions?.length) {
      obj.leaderOptions = message.leaderOptions;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.state !== 0) {
      obj.state = instanceConfig_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceConfig>): InstanceConfig {
    return InstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceConfig>): InstanceConfig {
    const message = createBaseInstanceConfig();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.configType = object.configType ?? 0;
    message.replicas = object.replicas?.map((e) => ReplicaInfo.fromPartial(e)) || [];
    message.optionalReplicas = object.optionalReplicas?.map((e) => ReplicaInfo.fromPartial(e)) || [];
    message.baseConfig = object.baseConfig ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.leaderOptions = object.leaderOptions?.map((e) => e) || [];
    message.reconciling = object.reconciling ?? false;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseInstanceConfig_LabelsEntry(): InstanceConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const InstanceConfig_LabelsEntry: MessageFns<InstanceConfig_LabelsEntry> = {
  encode(message: InstanceConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InstanceConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceConfig_LabelsEntry>): InstanceConfig_LabelsEntry {
    return InstanceConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceConfig_LabelsEntry>): InstanceConfig_LabelsEntry {
    const message = createBaseInstanceConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAutoscalingConfig(): AutoscalingConfig {
  return { autoscalingLimits: undefined, autoscalingTargets: undefined };
}

export const AutoscalingConfig: MessageFns<AutoscalingConfig> = {
  encode(message: AutoscalingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoscalingLimits !== undefined) {
      AutoscalingConfig_AutoscalingLimits.encode(message.autoscalingLimits, writer.uint32(10).fork()).join();
    }
    if (message.autoscalingTargets !== undefined) {
      AutoscalingConfig_AutoscalingTargets.encode(message.autoscalingTargets, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.autoscalingLimits = AutoscalingConfig_AutoscalingLimits.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.autoscalingTargets = AutoscalingConfig_AutoscalingTargets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingConfig {
    return {
      autoscalingLimits: isSet(object.autoscalingLimits)
        ? AutoscalingConfig_AutoscalingLimits.fromJSON(object.autoscalingLimits)
        : undefined,
      autoscalingTargets: isSet(object.autoscalingTargets)
        ? AutoscalingConfig_AutoscalingTargets.fromJSON(object.autoscalingTargets)
        : undefined,
    };
  },

  toJSON(message: AutoscalingConfig): unknown {
    const obj: any = {};
    if (message.autoscalingLimits !== undefined) {
      obj.autoscalingLimits = AutoscalingConfig_AutoscalingLimits.toJSON(message.autoscalingLimits);
    }
    if (message.autoscalingTargets !== undefined) {
      obj.autoscalingTargets = AutoscalingConfig_AutoscalingTargets.toJSON(message.autoscalingTargets);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingConfig>): AutoscalingConfig {
    return AutoscalingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingConfig>): AutoscalingConfig {
    const message = createBaseAutoscalingConfig();
    message.autoscalingLimits = (object.autoscalingLimits !== undefined && object.autoscalingLimits !== null)
      ? AutoscalingConfig_AutoscalingLimits.fromPartial(object.autoscalingLimits)
      : undefined;
    message.autoscalingTargets = (object.autoscalingTargets !== undefined && object.autoscalingTargets !== null)
      ? AutoscalingConfig_AutoscalingTargets.fromPartial(object.autoscalingTargets)
      : undefined;
    return message;
  },
};

function createBaseAutoscalingConfig_AutoscalingLimits(): AutoscalingConfig_AutoscalingLimits {
  return { minNodes: undefined, minProcessingUnits: undefined, maxNodes: undefined, maxProcessingUnits: undefined };
}

export const AutoscalingConfig_AutoscalingLimits: MessageFns<AutoscalingConfig_AutoscalingLimits> = {
  encode(message: AutoscalingConfig_AutoscalingLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minNodes !== undefined) {
      writer.uint32(8).int32(message.minNodes);
    }
    if (message.minProcessingUnits !== undefined) {
      writer.uint32(16).int32(message.minProcessingUnits);
    }
    if (message.maxNodes !== undefined) {
      writer.uint32(24).int32(message.maxNodes);
    }
    if (message.maxProcessingUnits !== undefined) {
      writer.uint32(32).int32(message.maxProcessingUnits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingConfig_AutoscalingLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingConfig_AutoscalingLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minNodes = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minProcessingUnits = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNodes = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxProcessingUnits = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingConfig_AutoscalingLimits {
    return {
      minNodes: isSet(object.minNodes) ? globalThis.Number(object.minNodes) : undefined,
      minProcessingUnits: isSet(object.minProcessingUnits) ? globalThis.Number(object.minProcessingUnits) : undefined,
      maxNodes: isSet(object.maxNodes) ? globalThis.Number(object.maxNodes) : undefined,
      maxProcessingUnits: isSet(object.maxProcessingUnits) ? globalThis.Number(object.maxProcessingUnits) : undefined,
    };
  },

  toJSON(message: AutoscalingConfig_AutoscalingLimits): unknown {
    const obj: any = {};
    if (message.minNodes !== undefined) {
      obj.minNodes = Math.round(message.minNodes);
    }
    if (message.minProcessingUnits !== undefined) {
      obj.minProcessingUnits = Math.round(message.minProcessingUnits);
    }
    if (message.maxNodes !== undefined) {
      obj.maxNodes = Math.round(message.maxNodes);
    }
    if (message.maxProcessingUnits !== undefined) {
      obj.maxProcessingUnits = Math.round(message.maxProcessingUnits);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingConfig_AutoscalingLimits>): AutoscalingConfig_AutoscalingLimits {
    return AutoscalingConfig_AutoscalingLimits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingConfig_AutoscalingLimits>): AutoscalingConfig_AutoscalingLimits {
    const message = createBaseAutoscalingConfig_AutoscalingLimits();
    message.minNodes = object.minNodes ?? undefined;
    message.minProcessingUnits = object.minProcessingUnits ?? undefined;
    message.maxNodes = object.maxNodes ?? undefined;
    message.maxProcessingUnits = object.maxProcessingUnits ?? undefined;
    return message;
  },
};

function createBaseAutoscalingConfig_AutoscalingTargets(): AutoscalingConfig_AutoscalingTargets {
  return { highPriorityCpuUtilizationPercent: 0, storageUtilizationPercent: 0 };
}

export const AutoscalingConfig_AutoscalingTargets: MessageFns<AutoscalingConfig_AutoscalingTargets> = {
  encode(message: AutoscalingConfig_AutoscalingTargets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.highPriorityCpuUtilizationPercent !== 0) {
      writer.uint32(8).int32(message.highPriorityCpuUtilizationPercent);
    }
    if (message.storageUtilizationPercent !== 0) {
      writer.uint32(16).int32(message.storageUtilizationPercent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingConfig_AutoscalingTargets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingConfig_AutoscalingTargets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.highPriorityCpuUtilizationPercent = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.storageUtilizationPercent = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingConfig_AutoscalingTargets {
    return {
      highPriorityCpuUtilizationPercent: isSet(object.highPriorityCpuUtilizationPercent)
        ? globalThis.Number(object.highPriorityCpuUtilizationPercent)
        : 0,
      storageUtilizationPercent: isSet(object.storageUtilizationPercent)
        ? globalThis.Number(object.storageUtilizationPercent)
        : 0,
    };
  },

  toJSON(message: AutoscalingConfig_AutoscalingTargets): unknown {
    const obj: any = {};
    if (message.highPriorityCpuUtilizationPercent !== 0) {
      obj.highPriorityCpuUtilizationPercent = Math.round(message.highPriorityCpuUtilizationPercent);
    }
    if (message.storageUtilizationPercent !== 0) {
      obj.storageUtilizationPercent = Math.round(message.storageUtilizationPercent);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingConfig_AutoscalingTargets>): AutoscalingConfig_AutoscalingTargets {
    return AutoscalingConfig_AutoscalingTargets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingConfig_AutoscalingTargets>): AutoscalingConfig_AutoscalingTargets {
    const message = createBaseAutoscalingConfig_AutoscalingTargets();
    message.highPriorityCpuUtilizationPercent = object.highPriorityCpuUtilizationPercent ?? 0;
    message.storageUtilizationPercent = object.storageUtilizationPercent ?? 0;
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    config: "",
    displayName: "",
    nodeCount: 0,
    processingUnits: 0,
    autoscalingConfig: undefined,
    state: 0,
    labels: {},
    endpointUris: [],
    createTime: undefined,
    updateTime: undefined,
    edition: 0,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== "") {
      writer.uint32(18).string(message.config);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(40).int32(message.nodeCount);
    }
    if (message.processingUnits !== 0) {
      writer.uint32(72).int32(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      AutoscalingConfig.encode(message.autoscalingConfig, writer.uint32(138).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.endpointUris) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.edition !== 0) {
      writer.uint32(160).int32(message.edition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.processingUnits = reader.int32();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.autoscalingConfig = AutoscalingConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endpointUris.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.edition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? globalThis.String(object.config) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      processingUnits: isSet(object.processingUnits) ? globalThis.Number(object.processingUnits) : 0,
      autoscalingConfig: isSet(object.autoscalingConfig)
        ? AutoscalingConfig.fromJSON(object.autoscalingConfig)
        : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      endpointUris: globalThis.Array.isArray(object?.endpointUris)
        ? object.endpointUris.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      edition: isSet(object.edition) ? instance_EditionFromJSON(object.edition) : 0,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== "") {
      obj.config = message.config;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.processingUnits !== 0) {
      obj.processingUnits = Math.round(message.processingUnits);
    }
    if (message.autoscalingConfig !== undefined) {
      obj.autoscalingConfig = AutoscalingConfig.toJSON(message.autoscalingConfig);
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.endpointUris?.length) {
      obj.endpointUris = message.endpointUris;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.edition !== 0) {
      obj.edition = instance_EditionToJSON(message.edition);
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.config = object.config ?? "";
    message.displayName = object.displayName ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.processingUnits = object.processingUnits ?? 0;
    message.autoscalingConfig = (object.autoscalingConfig !== undefined && object.autoscalingConfig !== null)
      ? AutoscalingConfig.fromPartial(object.autoscalingConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.endpointUris = object.endpointUris?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.edition = object.edition ?? 0;
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListInstanceConfigsRequest(): ListInstanceConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListInstanceConfigsRequest: MessageFns<ListInstanceConfigsRequest> = {
  encode(message: ListInstanceConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListInstanceConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceConfigsRequest>): ListInstanceConfigsRequest {
    return ListInstanceConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceConfigsRequest>): ListInstanceConfigsRequest {
    const message = createBaseListInstanceConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListInstanceConfigsResponse(): ListInstanceConfigsResponse {
  return { instanceConfigs: [], nextPageToken: "" };
}

export const ListInstanceConfigsResponse: MessageFns<ListInstanceConfigsResponse> = {
  encode(message: ListInstanceConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instanceConfigs) {
      InstanceConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceConfigs.push(InstanceConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceConfigsResponse {
    return {
      instanceConfigs: globalThis.Array.isArray(object?.instanceConfigs)
        ? object.instanceConfigs.map((e: any) => InstanceConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListInstanceConfigsResponse): unknown {
    const obj: any = {};
    if (message.instanceConfigs?.length) {
      obj.instanceConfigs = message.instanceConfigs.map((e) => InstanceConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceConfigsResponse>): ListInstanceConfigsResponse {
    return ListInstanceConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceConfigsResponse>): ListInstanceConfigsResponse {
    const message = createBaseListInstanceConfigsResponse();
    message.instanceConfigs = object.instanceConfigs?.map((e) => InstanceConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetInstanceConfigRequest(): GetInstanceConfigRequest {
  return { name: "" };
}

export const GetInstanceConfigRequest: MessageFns<GetInstanceConfigRequest> = {
  encode(message: GetInstanceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceConfigRequest>): GetInstanceConfigRequest {
    return GetInstanceConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceConfigRequest>): GetInstanceConfigRequest {
    const message = createBaseGetInstanceConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateInstanceConfigRequest(): CreateInstanceConfigRequest {
  return { parent: "", instanceConfigId: "", instanceConfig: undefined, validateOnly: false };
}

export const CreateInstanceConfigRequest: MessageFns<CreateInstanceConfigRequest> = {
  encode(message: CreateInstanceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.instanceConfigId !== "") {
      writer.uint32(18).string(message.instanceConfigId);
    }
    if (message.instanceConfig !== undefined) {
      InstanceConfig.encode(message.instanceConfig, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceConfigId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceConfig = InstanceConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      instanceConfigId: isSet(object.instanceConfigId) ? globalThis.String(object.instanceConfigId) : "",
      instanceConfig: isSet(object.instanceConfig) ? InstanceConfig.fromJSON(object.instanceConfig) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateInstanceConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.instanceConfigId !== "") {
      obj.instanceConfigId = message.instanceConfigId;
    }
    if (message.instanceConfig !== undefined) {
      obj.instanceConfig = InstanceConfig.toJSON(message.instanceConfig);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceConfigRequest>): CreateInstanceConfigRequest {
    return CreateInstanceConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceConfigRequest>): CreateInstanceConfigRequest {
    const message = createBaseCreateInstanceConfigRequest();
    message.parent = object.parent ?? "";
    message.instanceConfigId = object.instanceConfigId ?? "";
    message.instanceConfig = (object.instanceConfig !== undefined && object.instanceConfig !== null)
      ? InstanceConfig.fromPartial(object.instanceConfig)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateInstanceConfigRequest(): UpdateInstanceConfigRequest {
  return { instanceConfig: undefined, updateMask: undefined, validateOnly: false };
}

export const UpdateInstanceConfigRequest: MessageFns<UpdateInstanceConfigRequest> = {
  encode(message: UpdateInstanceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceConfig !== undefined) {
      InstanceConfig.encode(message.instanceConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceConfig = InstanceConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceConfigRequest {
    return {
      instanceConfig: isSet(object.instanceConfig) ? InstanceConfig.fromJSON(object.instanceConfig) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateInstanceConfigRequest): unknown {
    const obj: any = {};
    if (message.instanceConfig !== undefined) {
      obj.instanceConfig = InstanceConfig.toJSON(message.instanceConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceConfigRequest>): UpdateInstanceConfigRequest {
    return UpdateInstanceConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceConfigRequest>): UpdateInstanceConfigRequest {
    const message = createBaseUpdateInstanceConfigRequest();
    message.instanceConfig = (object.instanceConfig !== undefined && object.instanceConfig !== null)
      ? InstanceConfig.fromPartial(object.instanceConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteInstanceConfigRequest(): DeleteInstanceConfigRequest {
  return { name: "", etag: "", validateOnly: false };
}

export const DeleteInstanceConfigRequest: MessageFns<DeleteInstanceConfigRequest> = {
  encode(message: DeleteInstanceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceConfigRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: DeleteInstanceConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceConfigRequest>): DeleteInstanceConfigRequest {
    return DeleteInstanceConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceConfigRequest>): DeleteInstanceConfigRequest {
    const message = createBaseDeleteInstanceConfigRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseListInstanceConfigOperationsRequest(): ListInstanceConfigOperationsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListInstanceConfigOperationsRequest: MessageFns<ListInstanceConfigOperationsRequest> = {
  encode(message: ListInstanceConfigOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceConfigOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceConfigOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceConfigOperationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListInstanceConfigOperationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceConfigOperationsRequest>): ListInstanceConfigOperationsRequest {
    return ListInstanceConfigOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceConfigOperationsRequest>): ListInstanceConfigOperationsRequest {
    const message = createBaseListInstanceConfigOperationsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListInstanceConfigOperationsResponse(): ListInstanceConfigOperationsResponse {
  return { operations: [], nextPageToken: "" };
}

export const ListInstanceConfigOperationsResponse: MessageFns<ListInstanceConfigOperationsResponse> = {
  encode(message: ListInstanceConfigOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceConfigOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceConfigOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceConfigOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListInstanceConfigOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceConfigOperationsResponse>): ListInstanceConfigOperationsResponse {
    return ListInstanceConfigOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceConfigOperationsResponse>): ListInstanceConfigOperationsResponse {
    const message = createBaseListInstanceConfigOperationsResponse();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "", fieldMask: undefined };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
    };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    message.fieldMask = object.fieldMask ?? undefined;
    return message;
  },
};

function createBaseCreateInstanceRequest(): CreateInstanceRequest {
  return { parent: "", instanceId: "", instance: undefined };
}

export const CreateInstanceRequest: MessageFns<CreateInstanceRequest> = {
  encode(message: CreateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: CreateInstanceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    return CreateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    const message = createBaseCreateInstanceRequest();
    message.parent = object.parent ?? "";
    message.instanceId = object.instanceId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", instanceDeadline: undefined };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.instanceDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.instanceDeadline), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instanceDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      instanceDeadline: isSet(object.instanceDeadline) ? fromJsonTimestamp(object.instanceDeadline) : undefined,
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.instanceDeadline !== undefined) {
      obj.instanceDeadline = message.instanceDeadline.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.instanceDeadline = object.instanceDeadline ?? undefined;
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateInstanceRequest(): UpdateInstanceRequest {
  return { instance: undefined, fieldMask: undefined };
}

export const UpdateInstanceRequest: MessageFns<UpdateInstanceRequest> = {
  encode(message: UpdateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceRequest {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
    };
  },

  toJSON(message: UpdateInstanceRequest): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    return UpdateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    const message = createBaseUpdateInstanceRequest();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.fieldMask = object.fieldMask ?? undefined;
    return message;
  },
};

function createBaseDeleteInstanceRequest(): DeleteInstanceRequest {
  return { name: "" };
}

export const DeleteInstanceRequest: MessageFns<DeleteInstanceRequest> = {
  encode(message: DeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    return DeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    const message = createBaseDeleteInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateInstanceMetadata(): CreateInstanceMetadata {
  return {
    instance: undefined,
    startTime: undefined,
    cancelTime: undefined,
    endTime: undefined,
    expectedFulfillmentPeriod: 0,
  };
}

export const CreateInstanceMetadata: MessageFns<CreateInstanceMetadata> = {
  encode(message: CreateInstanceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    if (message.expectedFulfillmentPeriod !== 0) {
      writer.uint32(40).int32(message.expectedFulfillmentPeriod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expectedFulfillmentPeriod = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceMetadata {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      expectedFulfillmentPeriod: isSet(object.expectedFulfillmentPeriod)
        ? fulfillmentPeriodFromJSON(object.expectedFulfillmentPeriod)
        : 0,
    };
  },

  toJSON(message: CreateInstanceMetadata): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.expectedFulfillmentPeriod !== 0) {
      obj.expectedFulfillmentPeriod = fulfillmentPeriodToJSON(message.expectedFulfillmentPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceMetadata>): CreateInstanceMetadata {
    return CreateInstanceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceMetadata>): CreateInstanceMetadata {
    const message = createBaseCreateInstanceMetadata();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.expectedFulfillmentPeriod = object.expectedFulfillmentPeriod ?? 0;
    return message;
  },
};

function createBaseUpdateInstanceMetadata(): UpdateInstanceMetadata {
  return {
    instance: undefined,
    startTime: undefined,
    cancelTime: undefined,
    endTime: undefined,
    expectedFulfillmentPeriod: 0,
  };
}

export const UpdateInstanceMetadata: MessageFns<UpdateInstanceMetadata> = {
  encode(message: UpdateInstanceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    if (message.expectedFulfillmentPeriod !== 0) {
      writer.uint32(40).int32(message.expectedFulfillmentPeriod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expectedFulfillmentPeriod = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceMetadata {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      expectedFulfillmentPeriod: isSet(object.expectedFulfillmentPeriod)
        ? fulfillmentPeriodFromJSON(object.expectedFulfillmentPeriod)
        : 0,
    };
  },

  toJSON(message: UpdateInstanceMetadata): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.expectedFulfillmentPeriod !== 0) {
      obj.expectedFulfillmentPeriod = fulfillmentPeriodToJSON(message.expectedFulfillmentPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceMetadata>): UpdateInstanceMetadata {
    return UpdateInstanceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceMetadata>): UpdateInstanceMetadata {
    const message = createBaseUpdateInstanceMetadata();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.expectedFulfillmentPeriod = object.expectedFulfillmentPeriod ?? 0;
    return message;
  },
};

function createBaseCreateInstanceConfigMetadata(): CreateInstanceConfigMetadata {
  return { instanceConfig: undefined, progress: undefined, cancelTime: undefined };
}

export const CreateInstanceConfigMetadata: MessageFns<CreateInstanceConfigMetadata> = {
  encode(message: CreateInstanceConfigMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceConfig !== undefined) {
      InstanceConfig.encode(message.instanceConfig, writer.uint32(10).fork()).join();
    }
    if (message.progress !== undefined) {
      OperationProgress.encode(message.progress, writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceConfigMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceConfigMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceConfig = InstanceConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.progress = OperationProgress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceConfigMetadata {
    return {
      instanceConfig: isSet(object.instanceConfig) ? InstanceConfig.fromJSON(object.instanceConfig) : undefined,
      progress: isSet(object.progress) ? OperationProgress.fromJSON(object.progress) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
    };
  },

  toJSON(message: CreateInstanceConfigMetadata): unknown {
    const obj: any = {};
    if (message.instanceConfig !== undefined) {
      obj.instanceConfig = InstanceConfig.toJSON(message.instanceConfig);
    }
    if (message.progress !== undefined) {
      obj.progress = OperationProgress.toJSON(message.progress);
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceConfigMetadata>): CreateInstanceConfigMetadata {
    return CreateInstanceConfigMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceConfigMetadata>): CreateInstanceConfigMetadata {
    const message = createBaseCreateInstanceConfigMetadata();
    message.instanceConfig = (object.instanceConfig !== undefined && object.instanceConfig !== null)
      ? InstanceConfig.fromPartial(object.instanceConfig)
      : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? OperationProgress.fromPartial(object.progress)
      : undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    return message;
  },
};

function createBaseUpdateInstanceConfigMetadata(): UpdateInstanceConfigMetadata {
  return { instanceConfig: undefined, progress: undefined, cancelTime: undefined };
}

export const UpdateInstanceConfigMetadata: MessageFns<UpdateInstanceConfigMetadata> = {
  encode(message: UpdateInstanceConfigMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceConfig !== undefined) {
      InstanceConfig.encode(message.instanceConfig, writer.uint32(10).fork()).join();
    }
    if (message.progress !== undefined) {
      OperationProgress.encode(message.progress, writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceConfigMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceConfigMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceConfig = InstanceConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.progress = OperationProgress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceConfigMetadata {
    return {
      instanceConfig: isSet(object.instanceConfig) ? InstanceConfig.fromJSON(object.instanceConfig) : undefined,
      progress: isSet(object.progress) ? OperationProgress.fromJSON(object.progress) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
    };
  },

  toJSON(message: UpdateInstanceConfigMetadata): unknown {
    const obj: any = {};
    if (message.instanceConfig !== undefined) {
      obj.instanceConfig = InstanceConfig.toJSON(message.instanceConfig);
    }
    if (message.progress !== undefined) {
      obj.progress = OperationProgress.toJSON(message.progress);
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceConfigMetadata>): UpdateInstanceConfigMetadata {
    return UpdateInstanceConfigMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceConfigMetadata>): UpdateInstanceConfigMetadata {
    const message = createBaseUpdateInstanceConfigMetadata();
    message.instanceConfig = (object.instanceConfig !== undefined && object.instanceConfig !== null)
      ? InstanceConfig.fromPartial(object.instanceConfig)
      : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? OperationProgress.fromPartial(object.progress)
      : undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    return message;
  },
};

function createBaseInstancePartition(): InstancePartition {
  return {
    name: "",
    config: "",
    displayName: "",
    nodeCount: undefined,
    processingUnits: undefined,
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    referencingDatabases: [],
    referencingBackups: [],
    etag: "",
  };
}

export const InstancePartition: MessageFns<InstancePartition> = {
  encode(message: InstancePartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== "") {
      writer.uint32(18).string(message.config);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.nodeCount !== undefined) {
      writer.uint32(40).int32(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      writer.uint32(48).int32(message.processingUnits);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    for (const v of message.referencingDatabases) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.referencingBackups) {
      writer.uint32(90).string(v!);
    }
    if (message.etag !== "") {
      writer.uint32(98).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstancePartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstancePartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.processingUnits = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.referencingDatabases.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.referencingBackups.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstancePartition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? globalThis.String(object.config) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : undefined,
      processingUnits: isSet(object.processingUnits) ? globalThis.Number(object.processingUnits) : undefined,
      state: isSet(object.state) ? instancePartition_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      referencingDatabases: globalThis.Array.isArray(object?.referencingDatabases)
        ? object.referencingDatabases.map((e: any) => globalThis.String(e))
        : [],
      referencingBackups: globalThis.Array.isArray(object?.referencingBackups)
        ? object.referencingBackups.map((e: any) => globalThis.String(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: InstancePartition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== "") {
      obj.config = message.config;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.nodeCount !== undefined) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.processingUnits !== undefined) {
      obj.processingUnits = Math.round(message.processingUnits);
    }
    if (message.state !== 0) {
      obj.state = instancePartition_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.referencingDatabases?.length) {
      obj.referencingDatabases = message.referencingDatabases;
    }
    if (message.referencingBackups?.length) {
      obj.referencingBackups = message.referencingBackups;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<InstancePartition>): InstancePartition {
    return InstancePartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstancePartition>): InstancePartition {
    const message = createBaseInstancePartition();
    message.name = object.name ?? "";
    message.config = object.config ?? "";
    message.displayName = object.displayName ?? "";
    message.nodeCount = object.nodeCount ?? undefined;
    message.processingUnits = object.processingUnits ?? undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.referencingDatabases = object.referencingDatabases?.map((e) => e) || [];
    message.referencingBackups = object.referencingBackups?.map((e) => e) || [];
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseCreateInstancePartitionMetadata(): CreateInstancePartitionMetadata {
  return { instancePartition: undefined, startTime: undefined, cancelTime: undefined, endTime: undefined };
}

export const CreateInstancePartitionMetadata: MessageFns<CreateInstancePartitionMetadata> = {
  encode(message: CreateInstancePartitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instancePartition !== undefined) {
      InstancePartition.encode(message.instancePartition, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstancePartitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstancePartitionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instancePartition = InstancePartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstancePartitionMetadata {
    return {
      instancePartition: isSet(object.instancePartition)
        ? InstancePartition.fromJSON(object.instancePartition)
        : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: CreateInstancePartitionMetadata): unknown {
    const obj: any = {};
    if (message.instancePartition !== undefined) {
      obj.instancePartition = InstancePartition.toJSON(message.instancePartition);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstancePartitionMetadata>): CreateInstancePartitionMetadata {
    return CreateInstancePartitionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstancePartitionMetadata>): CreateInstancePartitionMetadata {
    const message = createBaseCreateInstancePartitionMetadata();
    message.instancePartition = (object.instancePartition !== undefined && object.instancePartition !== null)
      ? InstancePartition.fromPartial(object.instancePartition)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseCreateInstancePartitionRequest(): CreateInstancePartitionRequest {
  return { parent: "", instancePartitionId: "", instancePartition: undefined };
}

export const CreateInstancePartitionRequest: MessageFns<CreateInstancePartitionRequest> = {
  encode(message: CreateInstancePartitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.instancePartitionId !== "") {
      writer.uint32(18).string(message.instancePartitionId);
    }
    if (message.instancePartition !== undefined) {
      InstancePartition.encode(message.instancePartition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstancePartitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstancePartitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instancePartitionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instancePartition = InstancePartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstancePartitionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      instancePartitionId: isSet(object.instancePartitionId) ? globalThis.String(object.instancePartitionId) : "",
      instancePartition: isSet(object.instancePartition)
        ? InstancePartition.fromJSON(object.instancePartition)
        : undefined,
    };
  },

  toJSON(message: CreateInstancePartitionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.instancePartitionId !== "") {
      obj.instancePartitionId = message.instancePartitionId;
    }
    if (message.instancePartition !== undefined) {
      obj.instancePartition = InstancePartition.toJSON(message.instancePartition);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstancePartitionRequest>): CreateInstancePartitionRequest {
    return CreateInstancePartitionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstancePartitionRequest>): CreateInstancePartitionRequest {
    const message = createBaseCreateInstancePartitionRequest();
    message.parent = object.parent ?? "";
    message.instancePartitionId = object.instancePartitionId ?? "";
    message.instancePartition = (object.instancePartition !== undefined && object.instancePartition !== null)
      ? InstancePartition.fromPartial(object.instancePartition)
      : undefined;
    return message;
  },
};

function createBaseDeleteInstancePartitionRequest(): DeleteInstancePartitionRequest {
  return { name: "", etag: "" };
}

export const DeleteInstancePartitionRequest: MessageFns<DeleteInstancePartitionRequest> = {
  encode(message: DeleteInstancePartitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstancePartitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstancePartitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstancePartitionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteInstancePartitionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstancePartitionRequest>): DeleteInstancePartitionRequest {
    return DeleteInstancePartitionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstancePartitionRequest>): DeleteInstancePartitionRequest {
    const message = createBaseDeleteInstancePartitionRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGetInstancePartitionRequest(): GetInstancePartitionRequest {
  return { name: "" };
}

export const GetInstancePartitionRequest: MessageFns<GetInstancePartitionRequest> = {
  encode(message: GetInstancePartitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstancePartitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstancePartitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstancePartitionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstancePartitionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstancePartitionRequest>): GetInstancePartitionRequest {
    return GetInstancePartitionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstancePartitionRequest>): GetInstancePartitionRequest {
    const message = createBaseGetInstancePartitionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateInstancePartitionRequest(): UpdateInstancePartitionRequest {
  return { instancePartition: undefined, fieldMask: undefined };
}

export const UpdateInstancePartitionRequest: MessageFns<UpdateInstancePartitionRequest> = {
  encode(message: UpdateInstancePartitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instancePartition !== undefined) {
      InstancePartition.encode(message.instancePartition, writer.uint32(10).fork()).join();
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstancePartitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstancePartitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instancePartition = InstancePartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstancePartitionRequest {
    return {
      instancePartition: isSet(object.instancePartition)
        ? InstancePartition.fromJSON(object.instancePartition)
        : undefined,
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
    };
  },

  toJSON(message: UpdateInstancePartitionRequest): unknown {
    const obj: any = {};
    if (message.instancePartition !== undefined) {
      obj.instancePartition = InstancePartition.toJSON(message.instancePartition);
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstancePartitionRequest>): UpdateInstancePartitionRequest {
    return UpdateInstancePartitionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstancePartitionRequest>): UpdateInstancePartitionRequest {
    const message = createBaseUpdateInstancePartitionRequest();
    message.instancePartition = (object.instancePartition !== undefined && object.instancePartition !== null)
      ? InstancePartition.fromPartial(object.instancePartition)
      : undefined;
    message.fieldMask = object.fieldMask ?? undefined;
    return message;
  },
};

function createBaseUpdateInstancePartitionMetadata(): UpdateInstancePartitionMetadata {
  return { instancePartition: undefined, startTime: undefined, cancelTime: undefined, endTime: undefined };
}

export const UpdateInstancePartitionMetadata: MessageFns<UpdateInstancePartitionMetadata> = {
  encode(message: UpdateInstancePartitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instancePartition !== undefined) {
      InstancePartition.encode(message.instancePartition, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstancePartitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstancePartitionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instancePartition = InstancePartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstancePartitionMetadata {
    return {
      instancePartition: isSet(object.instancePartition)
        ? InstancePartition.fromJSON(object.instancePartition)
        : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: UpdateInstancePartitionMetadata): unknown {
    const obj: any = {};
    if (message.instancePartition !== undefined) {
      obj.instancePartition = InstancePartition.toJSON(message.instancePartition);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstancePartitionMetadata>): UpdateInstancePartitionMetadata {
    return UpdateInstancePartitionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstancePartitionMetadata>): UpdateInstancePartitionMetadata {
    const message = createBaseUpdateInstancePartitionMetadata();
    message.instancePartition = (object.instancePartition !== undefined && object.instancePartition !== null)
      ? InstancePartition.fromPartial(object.instancePartition)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseListInstancePartitionsRequest(): ListInstancePartitionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", instancePartitionDeadline: undefined };
}

export const ListInstancePartitionsRequest: MessageFns<ListInstancePartitionsRequest> = {
  encode(message: ListInstancePartitionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.instancePartitionDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.instancePartitionDeadline), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancePartitionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancePartitionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instancePartitionDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancePartitionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      instancePartitionDeadline: isSet(object.instancePartitionDeadline)
        ? fromJsonTimestamp(object.instancePartitionDeadline)
        : undefined,
    };
  },

  toJSON(message: ListInstancePartitionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.instancePartitionDeadline !== undefined) {
      obj.instancePartitionDeadline = message.instancePartitionDeadline.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancePartitionsRequest>): ListInstancePartitionsRequest {
    return ListInstancePartitionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancePartitionsRequest>): ListInstancePartitionsRequest {
    const message = createBaseListInstancePartitionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.instancePartitionDeadline = object.instancePartitionDeadline ?? undefined;
    return message;
  },
};

function createBaseListInstancePartitionsResponse(): ListInstancePartitionsResponse {
  return { instancePartitions: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancePartitionsResponse: MessageFns<ListInstancePartitionsResponse> = {
  encode(message: ListInstancePartitionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instancePartitions) {
      InstancePartition.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancePartitionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancePartitionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instancePartitions.push(InstancePartition.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancePartitionsResponse {
    return {
      instancePartitions: globalThis.Array.isArray(object?.instancePartitions)
        ? object.instancePartitions.map((e: any) => InstancePartition.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancePartitionsResponse): unknown {
    const obj: any = {};
    if (message.instancePartitions?.length) {
      obj.instancePartitions = message.instancePartitions.map((e) => InstancePartition.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancePartitionsResponse>): ListInstancePartitionsResponse {
    return ListInstancePartitionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancePartitionsResponse>): ListInstancePartitionsResponse {
    const message = createBaseListInstancePartitionsResponse();
    message.instancePartitions = object.instancePartitions?.map((e) => InstancePartition.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListInstancePartitionOperationsRequest(): ListInstancePartitionOperationsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "", instancePartitionDeadline: undefined };
}

export const ListInstancePartitionOperationsRequest: MessageFns<ListInstancePartitionOperationsRequest> = {
  encode(message: ListInstancePartitionOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.instancePartitionDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.instancePartitionDeadline), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancePartitionOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancePartitionOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instancePartitionDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancePartitionOperationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      instancePartitionDeadline: isSet(object.instancePartitionDeadline)
        ? fromJsonTimestamp(object.instancePartitionDeadline)
        : undefined,
    };
  },

  toJSON(message: ListInstancePartitionOperationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.instancePartitionDeadline !== undefined) {
      obj.instancePartitionDeadline = message.instancePartitionDeadline.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancePartitionOperationsRequest>): ListInstancePartitionOperationsRequest {
    return ListInstancePartitionOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancePartitionOperationsRequest>): ListInstancePartitionOperationsRequest {
    const message = createBaseListInstancePartitionOperationsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.instancePartitionDeadline = object.instancePartitionDeadline ?? undefined;
    return message;
  },
};

function createBaseListInstancePartitionOperationsResponse(): ListInstancePartitionOperationsResponse {
  return { operations: [], nextPageToken: "", unreachableInstancePartitions: [] };
}

export const ListInstancePartitionOperationsResponse: MessageFns<ListInstancePartitionOperationsResponse> = {
  encode(message: ListInstancePartitionOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachableInstancePartitions) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancePartitionOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancePartitionOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachableInstancePartitions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancePartitionOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachableInstancePartitions: globalThis.Array.isArray(object?.unreachableInstancePartitions)
        ? object.unreachableInstancePartitions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancePartitionOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachableInstancePartitions?.length) {
      obj.unreachableInstancePartitions = message.unreachableInstancePartitions;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancePartitionOperationsResponse>): ListInstancePartitionOperationsResponse {
    return ListInstancePartitionOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancePartitionOperationsResponse>): ListInstancePartitionOperationsResponse {
    const message = createBaseListInstancePartitionOperationsResponse();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachableInstancePartitions = object.unreachableInstancePartitions?.map((e) => e) || [];
    return message;
  },
};

function createBaseMoveInstanceRequest(): MoveInstanceRequest {
  return { name: "", targetConfig: "" };
}

export const MoveInstanceRequest: MessageFns<MoveInstanceRequest> = {
  encode(message: MoveInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.targetConfig !== "") {
      writer.uint32(18).string(message.targetConfig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetConfig = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetConfig: isSet(object.targetConfig) ? globalThis.String(object.targetConfig) : "",
    };
  },

  toJSON(message: MoveInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.targetConfig !== "") {
      obj.targetConfig = message.targetConfig;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveInstanceRequest>): MoveInstanceRequest {
    return MoveInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveInstanceRequest>): MoveInstanceRequest {
    const message = createBaseMoveInstanceRequest();
    message.name = object.name ?? "";
    message.targetConfig = object.targetConfig ?? "";
    return message;
  },
};

function createBaseMoveInstanceResponse(): MoveInstanceResponse {
  return {};
}

export const MoveInstanceResponse: MessageFns<MoveInstanceResponse> = {
  encode(_: MoveInstanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveInstanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveInstanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MoveInstanceResponse {
    return {};
  },

  toJSON(_: MoveInstanceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MoveInstanceResponse>): MoveInstanceResponse {
    return MoveInstanceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MoveInstanceResponse>): MoveInstanceResponse {
    const message = createBaseMoveInstanceResponse();
    return message;
  },
};

function createBaseMoveInstanceMetadata(): MoveInstanceMetadata {
  return { targetConfig: "", progress: undefined, cancelTime: undefined };
}

export const MoveInstanceMetadata: MessageFns<MoveInstanceMetadata> = {
  encode(message: MoveInstanceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetConfig !== "") {
      writer.uint32(10).string(message.targetConfig);
    }
    if (message.progress !== undefined) {
      OperationProgress.encode(message.progress, writer.uint32(18).fork()).join();
    }
    if (message.cancelTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveInstanceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveInstanceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.progress = OperationProgress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancelTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveInstanceMetadata {
    return {
      targetConfig: isSet(object.targetConfig) ? globalThis.String(object.targetConfig) : "",
      progress: isSet(object.progress) ? OperationProgress.fromJSON(object.progress) : undefined,
      cancelTime: isSet(object.cancelTime) ? fromJsonTimestamp(object.cancelTime) : undefined,
    };
  },

  toJSON(message: MoveInstanceMetadata): unknown {
    const obj: any = {};
    if (message.targetConfig !== "") {
      obj.targetConfig = message.targetConfig;
    }
    if (message.progress !== undefined) {
      obj.progress = OperationProgress.toJSON(message.progress);
    }
    if (message.cancelTime !== undefined) {
      obj.cancelTime = message.cancelTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<MoveInstanceMetadata>): MoveInstanceMetadata {
    return MoveInstanceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveInstanceMetadata>): MoveInstanceMetadata {
    const message = createBaseMoveInstanceMetadata();
    message.targetConfig = object.targetConfig ?? "";
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? OperationProgress.fromPartial(object.progress)
      : undefined;
    message.cancelTime = object.cancelTime ?? undefined;
    return message;
  },
};

/**
 * Cloud Spanner Instance Admin API
 *
 * The Cloud Spanner Instance Admin API can be used to create, delete,
 * modify and list instances. Instances are dedicated Cloud Spanner serving
 * and storage resources to be used by Cloud Spanner databases.
 *
 * Each instance has a "configuration", which dictates where the
 * serving resources for the Cloud Spanner instance are located (e.g.,
 * US-central, Europe). Configurations are created by Google based on
 * resource availability.
 *
 * Cloud Spanner billing is based on the instances that exist and their
 * sizes. After an instance exists, there are no additional
 * per-database or per-operation charges for use of the instance
 * (though there may be additional network bandwidth charges).
 * Instances offer isolation: problems with databases in one instance
 * will not affect other instances. However, within an instance
 * databases can affect each other. For example, if one database in an
 * instance receives a lot of requests and consumes most of the
 * instance resources, fewer resources are available for other
 * databases in that instance, and their performance may suffer.
 */
export type InstanceAdminDefinition = typeof InstanceAdminDefinition;
export const InstanceAdminDefinition = {
  name: "InstanceAdmin",
  fullName: "google.spanner.admin.instance.v1.InstanceAdmin",
  methods: {
    /** Lists the supported instance configurations for a given project. */
    listInstanceConfigs: {
      name: "ListInstanceConfigs",
      requestType: ListInstanceConfigsRequest,
      requestStream: false,
      responseType: ListInstanceConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets information about a particular instance configuration. */
    getInstanceConfig: {
      name: "GetInstanceConfig",
      requestType: GetInstanceConfigRequest,
      requestStream: false,
      responseType: InstanceConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an instance configuration and begins preparing it to be used. The
     * returned [long-running operation][google.longrunning.Operation]
     * can be used to track the progress of preparing the new
     * instance configuration. The instance configuration name is assigned by the
     * caller. If the named instance configuration already exists,
     * `CreateInstanceConfig` returns `ALREADY_EXISTS`.
     *
     * Immediately after the request returns:
     *
     *   * The instance configuration is readable via the API, with all requested
     *     attributes. The instance configuration's
     *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
     *     field is set to true. Its state is `CREATING`.
     *
     * While the operation is pending:
     *
     *   * Cancelling the operation renders the instance configuration immediately
     *     unreadable via the API.
     *   * Except for deleting the creating resource, all other attempts to modify
     *     the instance configuration are rejected.
     *
     * Upon completion of the returned operation:
     *
     *   * Instances can be created using the instance configuration.
     *   * The instance configuration's
     *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
     *   field becomes false. Its state becomes `READY`.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format
     * `<instance_config_name>/operations/<operation_id>` and can be used to track
     * creation of the instance configuration. The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
     * successful.
     *
     * Authorization requires `spanner.instanceConfigs.create` permission on
     * the resource
     * [parent][google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent].
     */
    createInstanceConfig: {
      name: "CreateInstanceConfig",
      requestType: CreateInstanceConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              112,
              10,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              61,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an instance configuration. The returned
     * [long-running operation][google.longrunning.Operation] can be used to track
     * the progress of updating the instance. If the named instance configuration
     * does not exist, returns `NOT_FOUND`.
     *
     * Only user-managed configurations can be updated.
     *
     * Immediately after the request returns:
     *
     *   * The instance configuration's
     *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
     *     field is set to true.
     *
     * While the operation is pending:
     *
     *   * Cancelling the operation sets its metadata's
     *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time].
     *     The operation is guaranteed to succeed at undoing all changes, after
     *     which point it terminates with a `CANCELLED` status.
     *   * All other attempts to modify the instance configuration are rejected.
     *   * Reading the instance configuration via the API continues to give the
     *     pre-request values.
     *
     * Upon completion of the returned operation:
     *
     *   * Creating instances using the instance configuration uses the new
     *     values.
     *   * The new values of the instance configuration are readable via the API.
     *   * The instance configuration's
     *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
     *   field becomes false.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format
     * `<instance_config_name>/operations/<operation_id>` and can be used to track
     * the instance configuration modification.  The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [UpdateInstanceConfigMetadata][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
     * successful.
     *
     * Authorization requires `spanner.instanceConfigs.update` permission on
     * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
     */
    updateInstanceConfig: {
      name: "UpdateInstanceConfig",
      requestType: UpdateInstanceConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              112,
              10,
              47,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              61,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              50,
              55,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the instance configuration. Deletion is only allowed when no
     * instances are using the configuration. If any instances are using
     * the configuration, returns `FAILED_PRECONDITION`.
     *
     * Only user-managed configurations can be deleted.
     *
     * Authorization requires `spanner.instanceConfigs.delete` permission on
     * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
     */
    deleteInstanceConfig: {
      name: "DeleteInstanceConfig",
      requestType: DeleteInstanceConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              41,
              42,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the user-managed instance configuration [long-running
     * operations][google.longrunning.Operation] in the given project. An instance
     * configuration operation has a name of the form
     * `projects/<project>/instanceConfigs/<instance_config>/operations/<operation>`.
     * The long-running operation
     * [metadata][google.longrunning.Operation.metadata] field type
     * `metadata.type_url` describes the type of the metadata. Operations returned
     * include those that have completed/failed/canceled within the last 7 days,
     * and pending operations. Operations returned are ordered by
     * `operation.metadata.value.start_time` in descending order starting
     * from the most recently started operation.
     */
    listInstanceConfigOperations: {
      name: "ListInstanceConfigOperations",
      requestType: ListInstanceConfigOperationsRequest,
      requestStream: false,
      responseType: ListInstanceConfigOperationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all instances in the given project. */
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all instance partitions for the given instance. */
    listInstancePartitions: {
      name: "ListInstancePartitions",
      requestType: ListInstancePartitionsRequest,
      requestStream: false,
      responseType: ListInstancePartitionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets information about a particular instance. */
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an instance and begins preparing it to begin serving. The
     * returned [long-running operation][google.longrunning.Operation]
     * can be used to track the progress of preparing the new
     * instance. The instance name is assigned by the caller. If the
     * named instance already exists, `CreateInstance` returns
     * `ALREADY_EXISTS`.
     *
     * Immediately upon completion of this request:
     *
     *   * The instance is readable via the API, with all requested attributes
     *     but no allocated resources. Its state is `CREATING`.
     *
     * Until completion of the returned operation:
     *
     *   * Cancelling the operation renders the instance immediately unreadable
     *     via the API.
     *   * The instance can be deleted.
     *   * All other attempts to modify the instance are rejected.
     *
     * Upon completion of the returned operation:
     *
     *   * Billing for all successfully-allocated resources begins (some types
     *     may have lower than the requested levels).
     *   * Databases can be created in the instance.
     *   * The instance's allocated resource levels are readable via the API.
     *   * The instance's state becomes `READY`.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format `<instance_name>/operations/<operation_id>` and
     * can be used to track creation of the instance.  The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
     */
    createInstance: {
      name: "CreateInstance",
      requestType: CreateInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              100,
              10,
              41,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              55,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              105,
              100,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              38,
              58,
              1,
              42,
              34,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an instance, and begins allocating or releasing resources
     * as requested. The returned [long-running
     * operation][google.longrunning.Operation] can be used to track the
     * progress of updating the instance. If the named instance does not
     * exist, returns `NOT_FOUND`.
     *
     * Immediately upon completion of this request:
     *
     *   * For resource types for which a decrease in the instance's allocation
     *     has been requested, billing is based on the newly-requested level.
     *
     * Until completion of the returned operation:
     *
     *   * Cancelling the operation sets its metadata's
     *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time],
     *     and begins restoring resources to their pre-request values. The
     *     operation is guaranteed to succeed at undoing all resource changes,
     *     after which point it terminates with a `CANCELLED` status.
     *   * All other attempts to modify the instance are rejected.
     *   * Reading the instance via the API continues to give the pre-request
     *     resource levels.
     *
     * Upon completion of the returned operation:
     *
     *   * Billing begins for all successfully-allocated resources (some types
     *     may have lower than the requested levels).
     *   * All newly-reserved resources are available for serving the instance's
     *     tables.
     *   * The instance's new resource levels are readable via the API.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format `<instance_name>/operations/<operation_id>` and
     * can be used to track the instance modification.  The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
     *
     * Authorization requires `spanner.instances.update` permission on
     * the resource [name][google.spanner.admin.instance.v1.Instance.name].
     */
    updateInstance: {
      name: "UpdateInstance",
      requestType: UpdateInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              100,
              10,
              41,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              55,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([19, 105, 110, 115, 116, 97, 110, 99, 101, 44, 102, 105, 101, 108, 100, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              47,
              58,
              1,
              42,
              50,
              42,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an instance.
     *
     * Immediately upon completion of the request:
     *
     *   * Billing ceases for all of the instance's reserved resources.
     *
     * Soon afterward:
     *
     *   * The instance and *all of its databases* immediately and
     *     irrevocably disappear from the API. All data in the databases
     *     is permanently deleted.
     */
    deleteInstance: {
      name: "DeleteInstance",
      requestType: DeleteInstanceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              35,
              42,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on an instance resource. Replaces any
     * existing policy.
     *
     * Authorization requires `spanner.instances.setIamPolicy` on
     * [resource][google.iam.v1.SetIamPolicyRequest.resource].
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for an instance resource. Returns an empty
     * policy if an instance exists but does not have a policy set.
     *
     * Authorization requires `spanner.instances.getIamPolicy` on
     * [resource][google.iam.v1.GetIamPolicyRequest.resource].
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that the caller has on the specified instance resource.
     *
     * Attempting this RPC on a non-existent Cloud Spanner instance resource will
     * result in a NOT_FOUND error if the user has `spanner.instances.list`
     * permission on the containing Google Cloud Project. Otherwise returns an
     * empty set of permissions.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets information about a particular instance partition. */
    getInstancePartition: {
      name: "GetInstancePartition",
      requestType: GetInstancePartitionRequest,
      requestStream: false,
      responseType: InstancePartition,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an instance partition and begins preparing it to be used. The
     * returned [long-running operation][google.longrunning.Operation]
     * can be used to track the progress of preparing the new instance partition.
     * The instance partition name is assigned by the caller. If the named
     * instance partition already exists, `CreateInstancePartition` returns
     * `ALREADY_EXISTS`.
     *
     * Immediately upon completion of this request:
     *
     *   * The instance partition is readable via the API, with all requested
     *     attributes but no allocated resources. Its state is `CREATING`.
     *
     * Until completion of the returned operation:
     *
     *   * Cancelling the operation renders the instance partition immediately
     *     unreadable via the API.
     *   * The instance partition can be deleted.
     *   * All other attempts to modify the instance partition are rejected.
     *
     * Upon completion of the returned operation:
     *
     *   * Billing for all successfully-allocated resources begins (some types
     *     may have lower than the requested levels).
     *   * Databases can start using this instance partition.
     *   * The instance partition's allocated resource levels are readable via the
     *     API.
     *   * The instance partition's state becomes `READY`.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format
     * `<instance_partition_name>/operations/<operation_id>` and can be used to
     * track creation of the instance partition.  The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
     * successful.
     */
    createInstancePartition: {
      name: "CreateInstancePartition",
      requestType: CreateInstancePartitionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              118,
              10,
              50,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              18,
              64,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              112,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              112,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an existing instance partition. Requires that the
     * instance partition is not used by any database or backup and is not the
     * default instance partition of an instance.
     *
     * Authorization requires `spanner.instancePartitions.delete` permission on
     * the resource
     * [name][google.spanner.admin.instance.v1.InstancePartition.name].
     */
    deleteInstancePartition: {
      name: "DeleteInstancePartition",
      requestType: DeleteInstancePartitionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              42,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an instance partition, and begins allocating or releasing resources
     * as requested. The returned [long-running
     * operation][google.longrunning.Operation] can be used to track the
     * progress of updating the instance partition. If the named instance
     * partition does not exist, returns `NOT_FOUND`.
     *
     * Immediately upon completion of this request:
     *
     *   * For resource types for which a decrease in the instance partition's
     *   allocation has been requested, billing is based on the newly-requested
     *   level.
     *
     * Until completion of the returned operation:
     *
     *   * Cancelling the operation sets its metadata's
     *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata.cancel_time],
     *     and begins restoring resources to their pre-request values. The
     *     operation is guaranteed to succeed at undoing all resource changes,
     *     after which point it terminates with a `CANCELLED` status.
     *   * All other attempts to modify the instance partition are rejected.
     *   * Reading the instance partition via the API continues to give the
     *     pre-request resource levels.
     *
     * Upon completion of the returned operation:
     *
     *   * Billing begins for all successfully-allocated resources (some types
     *     may have lower than the requested levels).
     *   * All newly-reserved resources are available for serving the instance
     *     partition's tables.
     *   * The instance partition's new resource levels are readable via the API.
     *
     * The returned [long-running operation][google.longrunning.Operation] will
     * have a name of the format
     * `<instance_partition_name>/operations/<operation_id>` and can be used to
     * track the instance partition modification. The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [UpdateInstancePartitionMetadata][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
     * successful.
     *
     * Authorization requires `spanner.instancePartitions.update` permission on
     * the resource
     * [name][google.spanner.admin.instance.v1.InstancePartition.name].
     */
    updateInstancePartition: {
      name: "UpdateInstancePartition",
      requestType: UpdateInstancePartitionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              118,
              10,
              50,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              18,
              64,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              112,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              44,
              102,
              105,
              101,
              108,
              100,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              50,
              73,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              112,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists instance partition [long-running
     * operations][google.longrunning.Operation] in the given instance.
     * An instance partition operation has a name of the form
     * `projects/<project>/instances/<instance>/instancePartitions/<instance_partition>/operations/<operation>`.
     * The long-running operation
     * [metadata][google.longrunning.Operation.metadata] field type
     * `metadata.type_url` describes the type of the metadata. Operations returned
     * include those that have completed/failed/canceled within the last 7 days,
     * and pending operations. Operations returned are ordered by
     * `operation.metadata.value.start_time` in descending order starting from the
     * most recently started operation.
     *
     * Authorization requires `spanner.instancePartitionOperations.list`
     * permission on the resource
     * [parent][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.parent].
     */
    listInstancePartitionOperations: {
      name: "ListInstancePartitionOperations",
      requestType: ListInstancePartitionOperationsRequest,
      requestStream: false,
      responseType: ListInstancePartitionOperationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              80,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Moves an instance to the target instance configuration. You can use the
     * returned [long-running operation][google.longrunning.Operation] to track
     * the progress of moving the instance.
     *
     * `MoveInstance` returns `FAILED_PRECONDITION` if the instance meets any of
     * the following criteria:
     *
     *   * Is undergoing a move to a different instance configuration
     *   * Has backups
     *   * Has an ongoing update
     *   * Contains any CMEK-enabled databases
     *   * Is a free trial instance
     *
     * While the operation is pending:
     *
     *   * All other attempts to modify the instance, including changes to its
     *     compute capacity, are rejected.
     *   * The following database and backup admin operations are rejected:
     *
     *     * `DatabaseAdmin.CreateDatabase`
     *     * `DatabaseAdmin.UpdateDatabaseDdl` (disabled if default_leader is
     *        specified in the request.)
     *     * `DatabaseAdmin.RestoreDatabase`
     *     * `DatabaseAdmin.CreateBackup`
     *     * `DatabaseAdmin.CopyBackup`
     *
     *   * Both the source and target instance configurations are subject to
     *     hourly compute and storage charges.
     *   * The instance might experience higher read-write latencies and a higher
     *     transaction abort rate. However, moving an instance doesn't cause any
     *     downtime.
     *
     * The returned [long-running operation][google.longrunning.Operation] has
     * a name of the format
     * `<instance_name>/operations/<operation_id>` and can be used to track
     * the move instance operation. The
     * [metadata][google.longrunning.Operation.metadata] field type is
     * [MoveInstanceMetadata][google.spanner.admin.instance.v1.MoveInstanceMetadata].
     * The [response][google.longrunning.Operation.response] field type is
     * [Instance][google.spanner.admin.instance.v1.Instance],
     * if successful.
     * Cancelling the operation sets its metadata's
     * [cancel_time][google.spanner.admin.instance.v1.MoveInstanceMetadata.cancel_time].
     * Cancellation is not immediate because it involves moving any data
     * previously moved to the target instance configuration back to the original
     * instance configuration. You can use this operation to track the progress of
     * the cancellation. Upon successful completion of the cancellation, the
     * operation terminates with `CANCELLED` status.
     *
     * If not cancelled, upon completion of the returned operation:
     *
     *   * The instance successfully moves to the target instance
     *     configuration.
     *   * You are billed for compute and storage in target instance
     *   configuration.
     *
     * Authorization requires the `spanner.instances.update` permission on
     * the resource [instance][google.spanner.admin.instance.v1.Instance].
     *
     * For more details, see
     * [Move an instance](https://cloud.google.com/spanner/docs/move-instance).
     */
    moveInstance: {
      name: "MoveInstance",
      requestType: MoveInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              110,
              10,
              53,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              77,
              111,
              118,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              53,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              115,
              112,
              97,
              110,
              110,
              101,
              114,
              46,
              97,
              100,
              109,
              105,
              110,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              118,
              49,
              46,
              77,
              111,
              118,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              43,
              58,
              1,
              42,
              34,
              38,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface InstanceAdminServiceImplementation<CallContextExt = {}> {
  /** Lists the supported instance configurations for a given project. */
  listInstanceConfigs(
    request: ListInstanceConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstanceConfigsResponse>>;
  /** Gets information about a particular instance configuration. */
  getInstanceConfig(
    request: GetInstanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InstanceConfig>>;
  /**
   * Creates an instance configuration and begins preparing it to be used. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new
   * instance configuration. The instance configuration name is assigned by the
   * caller. If the named instance configuration already exists,
   * `CreateInstanceConfig` returns `ALREADY_EXISTS`.
   *
   * Immediately after the request returns:
   *
   *   * The instance configuration is readable via the API, with all requested
   *     attributes. The instance configuration's
   *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *     field is set to true. Its state is `CREATING`.
   *
   * While the operation is pending:
   *
   *   * Cancelling the operation renders the instance configuration immediately
   *     unreadable via the API.
   *   * Except for deleting the creating resource, all other attempts to modify
   *     the instance configuration are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Instances can be created using the instance configuration.
   *   * The instance configuration's
   *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *   field becomes false. Its state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_config_name>/operations/<operation_id>` and can be used to track
   * creation of the instance configuration. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
   * successful.
   *
   * Authorization requires `spanner.instanceConfigs.create` permission on
   * the resource
   * [parent][google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent].
   */
  createInstanceConfig(
    request: CreateInstanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates an instance configuration. The returned
   * [long-running operation][google.longrunning.Operation] can be used to track
   * the progress of updating the instance. If the named instance configuration
   * does not exist, returns `NOT_FOUND`.
   *
   * Only user-managed configurations can be updated.
   *
   * Immediately after the request returns:
   *
   *   * The instance configuration's
   *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *     field is set to true.
   *
   * While the operation is pending:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time].
   *     The operation is guaranteed to succeed at undoing all changes, after
   *     which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance configuration are rejected.
   *   * Reading the instance configuration via the API continues to give the
   *     pre-request values.
   *
   * Upon completion of the returned operation:
   *
   *   * Creating instances using the instance configuration uses the new
   *     values.
   *   * The new values of the instance configuration are readable via the API.
   *   * The instance configuration's
   *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *   field becomes false.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_config_name>/operations/<operation_id>` and can be used to track
   * the instance configuration modification.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstanceConfigMetadata][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
   * successful.
   *
   * Authorization requires `spanner.instanceConfigs.update` permission on
   * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
   */
  updateInstanceConfig(
    request: UpdateInstanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the instance configuration. Deletion is only allowed when no
   * instances are using the configuration. If any instances are using
   * the configuration, returns `FAILED_PRECONDITION`.
   *
   * Only user-managed configurations can be deleted.
   *
   * Authorization requires `spanner.instanceConfigs.delete` permission on
   * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
   */
  deleteInstanceConfig(
    request: DeleteInstanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Lists the user-managed instance configuration [long-running
   * operations][google.longrunning.Operation] in the given project. An instance
   * configuration operation has a name of the form
   * `projects/<project>/instanceConfigs/<instance_config>/operations/<operation>`.
   * The long-running operation
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata. Operations returned
   * include those that have completed/failed/canceled within the last 7 days,
   * and pending operations. Operations returned are ordered by
   * `operation.metadata.value.start_time` in descending order starting
   * from the most recently started operation.
   */
  listInstanceConfigOperations(
    request: ListInstanceConfigOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstanceConfigOperationsResponse>>;
  /** Lists all instances in the given project. */
  listInstances(
    request: ListInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancesResponse>>;
  /** Lists all instance partitions for the given instance. */
  listInstancePartitions(
    request: ListInstancePartitionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancePartitionsResponse>>;
  /** Gets information about a particular instance. */
  getInstance(request: GetInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Instance>>;
  /**
   * Creates an instance and begins preparing it to begin serving. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new
   * instance. The instance name is assigned by the caller. If the
   * named instance already exists, `CreateInstance` returns
   * `ALREADY_EXISTS`.
   *
   * Immediately upon completion of this request:
   *
   *   * The instance is readable via the API, with all requested attributes
   *     but no allocated resources. Its state is `CREATING`.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation renders the instance immediately unreadable
   *     via the API.
   *   * The instance can be deleted.
   *   * All other attempts to modify the instance are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing for all successfully-allocated resources begins (some types
   *     may have lower than the requested levels).
   *   * Databases can be created in the instance.
   *   * The instance's allocated resource levels are readable via the API.
   *   * The instance's state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format `<instance_name>/operations/<operation_id>` and
   * can be used to track creation of the instance.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
   */
  createInstance(
    request: CreateInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates an instance, and begins allocating or releasing resources
   * as requested. The returned [long-running
   * operation][google.longrunning.Operation] can be used to track the
   * progress of updating the instance. If the named instance does not
   * exist, returns `NOT_FOUND`.
   *
   * Immediately upon completion of this request:
   *
   *   * For resource types for which a decrease in the instance's allocation
   *     has been requested, billing is based on the newly-requested level.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time],
   *     and begins restoring resources to their pre-request values. The
   *     operation is guaranteed to succeed at undoing all resource changes,
   *     after which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance are rejected.
   *   * Reading the instance via the API continues to give the pre-request
   *     resource levels.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing begins for all successfully-allocated resources (some types
   *     may have lower than the requested levels).
   *   * All newly-reserved resources are available for serving the instance's
   *     tables.
   *   * The instance's new resource levels are readable via the API.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format `<instance_name>/operations/<operation_id>` and
   * can be used to track the instance modification.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
   *
   * Authorization requires `spanner.instances.update` permission on
   * the resource [name][google.spanner.admin.instance.v1.Instance.name].
   */
  updateInstance(
    request: UpdateInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes an instance.
   *
   * Immediately upon completion of the request:
   *
   *   * Billing ceases for all of the instance's reserved resources.
   *
   * Soon afterward:
   *
   *   * The instance and *all of its databases* immediately and
   *     irrevocably disappear from the API. All data in the databases
   *     is permanently deleted.
   */
  deleteInstance(request: DeleteInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Sets the access control policy on an instance resource. Replaces any
   * existing policy.
   *
   * Authorization requires `spanner.instances.setIamPolicy` on
   * [resource][google.iam.v1.SetIamPolicyRequest.resource].
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Gets the access control policy for an instance resource. Returns an empty
   * policy if an instance exists but does not have a policy set.
   *
   * Authorization requires `spanner.instances.getIamPolicy` on
   * [resource][google.iam.v1.GetIamPolicyRequest.resource].
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that the caller has on the specified instance resource.
   *
   * Attempting this RPC on a non-existent Cloud Spanner instance resource will
   * result in a NOT_FOUND error if the user has `spanner.instances.list`
   * permission on the containing Google Cloud Project. Otherwise returns an
   * empty set of permissions.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /** Gets information about a particular instance partition. */
  getInstancePartition(
    request: GetInstancePartitionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InstancePartition>>;
  /**
   * Creates an instance partition and begins preparing it to be used. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new instance partition.
   * The instance partition name is assigned by the caller. If the named
   * instance partition already exists, `CreateInstancePartition` returns
   * `ALREADY_EXISTS`.
   *
   * Immediately upon completion of this request:
   *
   *   * The instance partition is readable via the API, with all requested
   *     attributes but no allocated resources. Its state is `CREATING`.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation renders the instance partition immediately
   *     unreadable via the API.
   *   * The instance partition can be deleted.
   *   * All other attempts to modify the instance partition are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing for all successfully-allocated resources begins (some types
   *     may have lower than the requested levels).
   *   * Databases can start using this instance partition.
   *   * The instance partition's allocated resource levels are readable via the
   *     API.
   *   * The instance partition's state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_partition_name>/operations/<operation_id>` and can be used to
   * track creation of the instance partition.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
   * successful.
   */
  createInstancePartition(
    request: CreateInstancePartitionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes an existing instance partition. Requires that the
   * instance partition is not used by any database or backup and is not the
   * default instance partition of an instance.
   *
   * Authorization requires `spanner.instancePartitions.delete` permission on
   * the resource
   * [name][google.spanner.admin.instance.v1.InstancePartition.name].
   */
  deleteInstancePartition(
    request: DeleteInstancePartitionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Updates an instance partition, and begins allocating or releasing resources
   * as requested. The returned [long-running
   * operation][google.longrunning.Operation] can be used to track the
   * progress of updating the instance partition. If the named instance
   * partition does not exist, returns `NOT_FOUND`.
   *
   * Immediately upon completion of this request:
   *
   *   * For resource types for which a decrease in the instance partition's
   *   allocation has been requested, billing is based on the newly-requested
   *   level.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata.cancel_time],
   *     and begins restoring resources to their pre-request values. The
   *     operation is guaranteed to succeed at undoing all resource changes,
   *     after which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance partition are rejected.
   *   * Reading the instance partition via the API continues to give the
   *     pre-request resource levels.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing begins for all successfully-allocated resources (some types
   *     may have lower than the requested levels).
   *   * All newly-reserved resources are available for serving the instance
   *     partition's tables.
   *   * The instance partition's new resource levels are readable via the API.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_partition_name>/operations/<operation_id>` and can be used to
   * track the instance partition modification. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstancePartitionMetadata][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
   * successful.
   *
   * Authorization requires `spanner.instancePartitions.update` permission on
   * the resource
   * [name][google.spanner.admin.instance.v1.InstancePartition.name].
   */
  updateInstancePartition(
    request: UpdateInstancePartitionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists instance partition [long-running
   * operations][google.longrunning.Operation] in the given instance.
   * An instance partition operation has a name of the form
   * `projects/<project>/instances/<instance>/instancePartitions/<instance_partition>/operations/<operation>`.
   * The long-running operation
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata. Operations returned
   * include those that have completed/failed/canceled within the last 7 days,
   * and pending operations. Operations returned are ordered by
   * `operation.metadata.value.start_time` in descending order starting from the
   * most recently started operation.
   *
   * Authorization requires `spanner.instancePartitionOperations.list`
   * permission on the resource
   * [parent][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.parent].
   */
  listInstancePartitionOperations(
    request: ListInstancePartitionOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancePartitionOperationsResponse>>;
  /**
   * Moves an instance to the target instance configuration. You can use the
   * returned [long-running operation][google.longrunning.Operation] to track
   * the progress of moving the instance.
   *
   * `MoveInstance` returns `FAILED_PRECONDITION` if the instance meets any of
   * the following criteria:
   *
   *   * Is undergoing a move to a different instance configuration
   *   * Has backups
   *   * Has an ongoing update
   *   * Contains any CMEK-enabled databases
   *   * Is a free trial instance
   *
   * While the operation is pending:
   *
   *   * All other attempts to modify the instance, including changes to its
   *     compute capacity, are rejected.
   *   * The following database and backup admin operations are rejected:
   *
   *     * `DatabaseAdmin.CreateDatabase`
   *     * `DatabaseAdmin.UpdateDatabaseDdl` (disabled if default_leader is
   *        specified in the request.)
   *     * `DatabaseAdmin.RestoreDatabase`
   *     * `DatabaseAdmin.CreateBackup`
   *     * `DatabaseAdmin.CopyBackup`
   *
   *   * Both the source and target instance configurations are subject to
   *     hourly compute and storage charges.
   *   * The instance might experience higher read-write latencies and a higher
   *     transaction abort rate. However, moving an instance doesn't cause any
   *     downtime.
   *
   * The returned [long-running operation][google.longrunning.Operation] has
   * a name of the format
   * `<instance_name>/operations/<operation_id>` and can be used to track
   * the move instance operation. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [MoveInstanceMetadata][google.spanner.admin.instance.v1.MoveInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance],
   * if successful.
   * Cancelling the operation sets its metadata's
   * [cancel_time][google.spanner.admin.instance.v1.MoveInstanceMetadata.cancel_time].
   * Cancellation is not immediate because it involves moving any data
   * previously moved to the target instance configuration back to the original
   * instance configuration. You can use this operation to track the progress of
   * the cancellation. Upon successful completion of the cancellation, the
   * operation terminates with `CANCELLED` status.
   *
   * If not cancelled, upon completion of the returned operation:
   *
   *   * The instance successfully moves to the target instance
   *     configuration.
   *   * You are billed for compute and storage in target instance
   *   configuration.
   *
   * Authorization requires the `spanner.instances.update` permission on
   * the resource [instance][google.spanner.admin.instance.v1.Instance].
   *
   * For more details, see
   * [Move an instance](https://cloud.google.com/spanner/docs/move-instance).
   */
  moveInstance(request: MoveInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface InstanceAdminClient<CallOptionsExt = {}> {
  /** Lists the supported instance configurations for a given project. */
  listInstanceConfigs(
    request: DeepPartial<ListInstanceConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstanceConfigsResponse>;
  /** Gets information about a particular instance configuration. */
  getInstanceConfig(
    request: DeepPartial<GetInstanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InstanceConfig>;
  /**
   * Creates an instance configuration and begins preparing it to be used. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new
   * instance configuration. The instance configuration name is assigned by the
   * caller. If the named instance configuration already exists,
   * `CreateInstanceConfig` returns `ALREADY_EXISTS`.
   *
   * Immediately after the request returns:
   *
   *   * The instance configuration is readable via the API, with all requested
   *     attributes. The instance configuration's
   *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *     field is set to true. Its state is `CREATING`.
   *
   * While the operation is pending:
   *
   *   * Cancelling the operation renders the instance configuration immediately
   *     unreadable via the API.
   *   * Except for deleting the creating resource, all other attempts to modify
   *     the instance configuration are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Instances can be created using the instance configuration.
   *   * The instance configuration's
   *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *   field becomes false. Its state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_config_name>/operations/<operation_id>` and can be used to track
   * creation of the instance configuration. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstanceConfigMetadata][google.spanner.admin.instance.v1.CreateInstanceConfigMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
   * successful.
   *
   * Authorization requires `spanner.instanceConfigs.create` permission on
   * the resource
   * [parent][google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent].
   */
  createInstanceConfig(
    request: DeepPartial<CreateInstanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates an instance configuration. The returned
   * [long-running operation][google.longrunning.Operation] can be used to track
   * the progress of updating the instance. If the named instance configuration
   * does not exist, returns `NOT_FOUND`.
   *
   * Only user-managed configurations can be updated.
   *
   * Immediately after the request returns:
   *
   *   * The instance configuration's
   *     [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *     field is set to true.
   *
   * While the operation is pending:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time].
   *     The operation is guaranteed to succeed at undoing all changes, after
   *     which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance configuration are rejected.
   *   * Reading the instance configuration via the API continues to give the
   *     pre-request values.
   *
   * Upon completion of the returned operation:
   *
   *   * Creating instances using the instance configuration uses the new
   *     values.
   *   * The new values of the instance configuration are readable via the API.
   *   * The instance configuration's
   *   [reconciling][google.spanner.admin.instance.v1.InstanceConfig.reconciling]
   *   field becomes false.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_config_name>/operations/<operation_id>` and can be used to track
   * the instance configuration modification.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstanceConfigMetadata][google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig], if
   * successful.
   *
   * Authorization requires `spanner.instanceConfigs.update` permission on
   * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
   */
  updateInstanceConfig(
    request: DeepPartial<UpdateInstanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes the instance configuration. Deletion is only allowed when no
   * instances are using the configuration. If any instances are using
   * the configuration, returns `FAILED_PRECONDITION`.
   *
   * Only user-managed configurations can be deleted.
   *
   * Authorization requires `spanner.instanceConfigs.delete` permission on
   * the resource [name][google.spanner.admin.instance.v1.InstanceConfig.name].
   */
  deleteInstanceConfig(
    request: DeepPartial<DeleteInstanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Lists the user-managed instance configuration [long-running
   * operations][google.longrunning.Operation] in the given project. An instance
   * configuration operation has a name of the form
   * `projects/<project>/instanceConfigs/<instance_config>/operations/<operation>`.
   * The long-running operation
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata. Operations returned
   * include those that have completed/failed/canceled within the last 7 days,
   * and pending operations. Operations returned are ordered by
   * `operation.metadata.value.start_time` in descending order starting
   * from the most recently started operation.
   */
  listInstanceConfigOperations(
    request: DeepPartial<ListInstanceConfigOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstanceConfigOperationsResponse>;
  /** Lists all instances in the given project. */
  listInstances(
    request: DeepPartial<ListInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancesResponse>;
  /** Lists all instance partitions for the given instance. */
  listInstancePartitions(
    request: DeepPartial<ListInstancePartitionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancePartitionsResponse>;
  /** Gets information about a particular instance. */
  getInstance(request: DeepPartial<GetInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Instance>;
  /**
   * Creates an instance and begins preparing it to begin serving. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new
   * instance. The instance name is assigned by the caller. If the
   * named instance already exists, `CreateInstance` returns
   * `ALREADY_EXISTS`.
   *
   * Immediately upon completion of this request:
   *
   *   * The instance is readable via the API, with all requested attributes
   *     but no allocated resources. Its state is `CREATING`.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation renders the instance immediately unreadable
   *     via the API.
   *   * The instance can be deleted.
   *   * All other attempts to modify the instance are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing for all successfully-allocated resources begins (some types
   *     may have lower than the requested levels).
   *   * Databases can be created in the instance.
   *   * The instance's allocated resource levels are readable via the API.
   *   * The instance's state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format `<instance_name>/operations/<operation_id>` and
   * can be used to track creation of the instance.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
   */
  createInstance(
    request: DeepPartial<CreateInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates an instance, and begins allocating or releasing resources
   * as requested. The returned [long-running
   * operation][google.longrunning.Operation] can be used to track the
   * progress of updating the instance. If the named instance does not
   * exist, returns `NOT_FOUND`.
   *
   * Immediately upon completion of this request:
   *
   *   * For resource types for which a decrease in the instance's allocation
   *     has been requested, billing is based on the newly-requested level.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time],
   *     and begins restoring resources to their pre-request values. The
   *     operation is guaranteed to succeed at undoing all resource changes,
   *     after which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance are rejected.
   *   * Reading the instance via the API continues to give the pre-request
   *     resource levels.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing begins for all successfully-allocated resources (some types
   *     may have lower than the requested levels).
   *   * All newly-reserved resources are available for serving the instance's
   *     tables.
   *   * The instance's new resource levels are readable via the API.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format `<instance_name>/operations/<operation_id>` and
   * can be used to track the instance modification.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance], if successful.
   *
   * Authorization requires `spanner.instances.update` permission on
   * the resource [name][google.spanner.admin.instance.v1.Instance.name].
   */
  updateInstance(
    request: DeepPartial<UpdateInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes an instance.
   *
   * Immediately upon completion of the request:
   *
   *   * Billing ceases for all of the instance's reserved resources.
   *
   * Soon afterward:
   *
   *   * The instance and *all of its databases* immediately and
   *     irrevocably disappear from the API. All data in the databases
   *     is permanently deleted.
   */
  deleteInstance(request: DeepPartial<DeleteInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Sets the access control policy on an instance resource. Replaces any
   * existing policy.
   *
   * Authorization requires `spanner.instances.setIamPolicy` on
   * [resource][google.iam.v1.SetIamPolicyRequest.resource].
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Gets the access control policy for an instance resource. Returns an empty
   * policy if an instance exists but does not have a policy set.
   *
   * Authorization requires `spanner.instances.getIamPolicy` on
   * [resource][google.iam.v1.GetIamPolicyRequest.resource].
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that the caller has on the specified instance resource.
   *
   * Attempting this RPC on a non-existent Cloud Spanner instance resource will
   * result in a NOT_FOUND error if the user has `spanner.instances.list`
   * permission on the containing Google Cloud Project. Otherwise returns an
   * empty set of permissions.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /** Gets information about a particular instance partition. */
  getInstancePartition(
    request: DeepPartial<GetInstancePartitionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InstancePartition>;
  /**
   * Creates an instance partition and begins preparing it to be used. The
   * returned [long-running operation][google.longrunning.Operation]
   * can be used to track the progress of preparing the new instance partition.
   * The instance partition name is assigned by the caller. If the named
   * instance partition already exists, `CreateInstancePartition` returns
   * `ALREADY_EXISTS`.
   *
   * Immediately upon completion of this request:
   *
   *   * The instance partition is readable via the API, with all requested
   *     attributes but no allocated resources. Its state is `CREATING`.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation renders the instance partition immediately
   *     unreadable via the API.
   *   * The instance partition can be deleted.
   *   * All other attempts to modify the instance partition are rejected.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing for all successfully-allocated resources begins (some types
   *     may have lower than the requested levels).
   *   * Databases can start using this instance partition.
   *   * The instance partition's allocated resource levels are readable via the
   *     API.
   *   * The instance partition's state becomes `READY`.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_partition_name>/operations/<operation_id>` and can be used to
   * track creation of the instance partition.  The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [CreateInstancePartitionMetadata][google.spanner.admin.instance.v1.CreateInstancePartitionMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
   * successful.
   */
  createInstancePartition(
    request: DeepPartial<CreateInstancePartitionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes an existing instance partition. Requires that the
   * instance partition is not used by any database or backup and is not the
   * default instance partition of an instance.
   *
   * Authorization requires `spanner.instancePartitions.delete` permission on
   * the resource
   * [name][google.spanner.admin.instance.v1.InstancePartition.name].
   */
  deleteInstancePartition(
    request: DeepPartial<DeleteInstancePartitionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Updates an instance partition, and begins allocating or releasing resources
   * as requested. The returned [long-running
   * operation][google.longrunning.Operation] can be used to track the
   * progress of updating the instance partition. If the named instance
   * partition does not exist, returns `NOT_FOUND`.
   *
   * Immediately upon completion of this request:
   *
   *   * For resource types for which a decrease in the instance partition's
   *   allocation has been requested, billing is based on the newly-requested
   *   level.
   *
   * Until completion of the returned operation:
   *
   *   * Cancelling the operation sets its metadata's
   *     [cancel_time][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata.cancel_time],
   *     and begins restoring resources to their pre-request values. The
   *     operation is guaranteed to succeed at undoing all resource changes,
   *     after which point it terminates with a `CANCELLED` status.
   *   * All other attempts to modify the instance partition are rejected.
   *   * Reading the instance partition via the API continues to give the
   *     pre-request resource levels.
   *
   * Upon completion of the returned operation:
   *
   *   * Billing begins for all successfully-allocated resources (some types
   *     may have lower than the requested levels).
   *   * All newly-reserved resources are available for serving the instance
   *     partition's tables.
   *   * The instance partition's new resource levels are readable via the API.
   *
   * The returned [long-running operation][google.longrunning.Operation] will
   * have a name of the format
   * `<instance_partition_name>/operations/<operation_id>` and can be used to
   * track the instance partition modification. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [UpdateInstancePartitionMetadata][google.spanner.admin.instance.v1.UpdateInstancePartitionMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [InstancePartition][google.spanner.admin.instance.v1.InstancePartition], if
   * successful.
   *
   * Authorization requires `spanner.instancePartitions.update` permission on
   * the resource
   * [name][google.spanner.admin.instance.v1.InstancePartition.name].
   */
  updateInstancePartition(
    request: DeepPartial<UpdateInstancePartitionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists instance partition [long-running
   * operations][google.longrunning.Operation] in the given instance.
   * An instance partition operation has a name of the form
   * `projects/<project>/instances/<instance>/instancePartitions/<instance_partition>/operations/<operation>`.
   * The long-running operation
   * [metadata][google.longrunning.Operation.metadata] field type
   * `metadata.type_url` describes the type of the metadata. Operations returned
   * include those that have completed/failed/canceled within the last 7 days,
   * and pending operations. Operations returned are ordered by
   * `operation.metadata.value.start_time` in descending order starting from the
   * most recently started operation.
   *
   * Authorization requires `spanner.instancePartitionOperations.list`
   * permission on the resource
   * [parent][google.spanner.admin.instance.v1.ListInstancePartitionOperationsRequest.parent].
   */
  listInstancePartitionOperations(
    request: DeepPartial<ListInstancePartitionOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancePartitionOperationsResponse>;
  /**
   * Moves an instance to the target instance configuration. You can use the
   * returned [long-running operation][google.longrunning.Operation] to track
   * the progress of moving the instance.
   *
   * `MoveInstance` returns `FAILED_PRECONDITION` if the instance meets any of
   * the following criteria:
   *
   *   * Is undergoing a move to a different instance configuration
   *   * Has backups
   *   * Has an ongoing update
   *   * Contains any CMEK-enabled databases
   *   * Is a free trial instance
   *
   * While the operation is pending:
   *
   *   * All other attempts to modify the instance, including changes to its
   *     compute capacity, are rejected.
   *   * The following database and backup admin operations are rejected:
   *
   *     * `DatabaseAdmin.CreateDatabase`
   *     * `DatabaseAdmin.UpdateDatabaseDdl` (disabled if default_leader is
   *        specified in the request.)
   *     * `DatabaseAdmin.RestoreDatabase`
   *     * `DatabaseAdmin.CreateBackup`
   *     * `DatabaseAdmin.CopyBackup`
   *
   *   * Both the source and target instance configurations are subject to
   *     hourly compute and storage charges.
   *   * The instance might experience higher read-write latencies and a higher
   *     transaction abort rate. However, moving an instance doesn't cause any
   *     downtime.
   *
   * The returned [long-running operation][google.longrunning.Operation] has
   * a name of the format
   * `<instance_name>/operations/<operation_id>` and can be used to track
   * the move instance operation. The
   * [metadata][google.longrunning.Operation.metadata] field type is
   * [MoveInstanceMetadata][google.spanner.admin.instance.v1.MoveInstanceMetadata].
   * The [response][google.longrunning.Operation.response] field type is
   * [Instance][google.spanner.admin.instance.v1.Instance],
   * if successful.
   * Cancelling the operation sets its metadata's
   * [cancel_time][google.spanner.admin.instance.v1.MoveInstanceMetadata.cancel_time].
   * Cancellation is not immediate because it involves moving any data
   * previously moved to the target instance configuration back to the original
   * instance configuration. You can use this operation to track the progress of
   * the cancellation. Upon successful completion of the cancellation, the
   * operation terminates with `CANCELLED` status.
   *
   * If not cancelled, upon completion of the returned operation:
   *
   *   * The instance successfully moves to the target instance
   *     configuration.
   *   * You are billed for compute and storage in target instance
   *   configuration.
   *
   * Authorization requires the `spanner.instances.update` permission on
   * the resource [instance][google.spanner.admin.instance.v1.Instance].
   *
   * For more details, see
   * [Move an instance](https://cloud.google.com/spanner/docs/move-instance).
   */
  moveInstance(request: DeepPartial<MoveInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
