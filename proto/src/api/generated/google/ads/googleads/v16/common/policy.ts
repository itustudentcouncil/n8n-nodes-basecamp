// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/common/policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  PolicyTopicEntryTypeEnum_PolicyTopicEntryType,
  policyTopicEntryTypeEnum_PolicyTopicEntryTypeFromJSON,
  policyTopicEntryTypeEnum_PolicyTopicEntryTypeToJSON,
} from "../enums/policy_topic_entry_type.js";
import {
  PolicyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlType,
  policyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlTypeFromJSON,
  policyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlTypeToJSON,
} from "../enums/policy_topic_evidence_destination_mismatch_url_type.js";
import {
  PolicyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDevice,
  policyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDeviceFromJSON,
  policyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDeviceToJSON,
} from "../enums/policy_topic_evidence_destination_not_working_device.js";
import {
  PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorType,
  policyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeFromJSON,
  policyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeToJSON,
} from "../enums/policy_topic_evidence_destination_not_working_dns_error_type.js";

export const protobufPackage = "google.ads.googleads.v16.common";

/**
 * Key of the violation. The key is used for referring to a violation
 * when filing an exemption request.
 */
export interface PolicyViolationKey {
  /** Unique ID of the violated policy. */
  policyName?:
    | string
    | undefined;
  /**
   * The text that violates the policy if specified.
   * Otherwise, refers to the policy in general
   * (for example, when requesting to be exempt from the whole policy).
   * If not specified for criterion exemptions, the whole policy is implied.
   * Must be specified for ad exemptions.
   */
  violatingText?: string | undefined;
}

/** Parameter for controlling how policy exemption is done. */
export interface PolicyValidationParameter {
  /**
   * The list of policy topics that should not cause a PolicyFindingError to
   * be reported. This field is currently only compatible with Enhanced Text Ad.
   * It corresponds to the PolicyTopicEntry.topic field.
   *
   * Resources violating these policies will be saved, but will not be eligible
   * to serve. They may begin serving at a later time due to a change in
   * policies, re-review of the resource, or a change in advertiser
   * certificates.
   */
  ignorablePolicyTopics: string[];
  /**
   * The list of policy violation keys that should not cause a
   * PolicyViolationError to be reported. Not all policy violations are
   * exemptable, refer to the is_exemptible field in the returned
   * PolicyViolationError.
   *
   * Resources violating these polices will be saved, but will not be eligible
   * to serve. They may begin serving at a later time due to a change in
   * policies, re-review of the resource, or a change in advertiser
   * certificates.
   */
  exemptPolicyViolationKeys: PolicyViolationKey[];
}

/**
 * Policy finding attached to a resource (for example, alcohol policy associated
 * with a site that sells alcohol).
 *
 * Each PolicyTopicEntry has a topic that indicates the specific ads policy
 * the entry is about and a type to indicate the effect that the entry will have
 * on serving. It may optionally have one or more evidences that indicate the
 * reason for the finding. It may also optionally have one or more constraints
 * that provide details about how serving may be restricted.
 */
export interface PolicyTopicEntry {
  /**
   * Policy topic this finding refers to. For example, "ALCOHOL",
   * "TRADEMARKS_IN_AD_TEXT", or "DESTINATION_NOT_WORKING". The set of possible
   * policy topics is not fixed for a particular API version and may change
   * at any time.
   */
  topic?:
    | string
    | undefined;
  /** Describes the negative or positive effect this policy will have on serving. */
  type: PolicyTopicEntryTypeEnum_PolicyTopicEntryType;
  /**
   * Additional information that explains policy finding
   * (for example, the brand name for a trademark finding).
   */
  evidences: PolicyTopicEvidence[];
  /**
   * Indicates how serving of this resource may be affected (for example, not
   * serving in a country).
   */
  constraints: PolicyTopicConstraint[];
}

/** Additional information that explains a policy finding. */
export interface PolicyTopicEvidence {
  /** List of websites linked with this resource. */
  websiteList?:
    | PolicyTopicEvidence_WebsiteList
    | undefined;
  /** List of evidence found in the text of a resource. */
  textList?:
    | PolicyTopicEvidence_TextList
    | undefined;
  /**
   * The language the resource was detected to be written in.
   * This is an IETF language tag such as "en-US".
   */
  languageCode?:
    | string
    | undefined;
  /**
   * The text in the destination of the resource that is causing a policy
   * finding.
   */
  destinationTextList?:
    | PolicyTopicEvidence_DestinationTextList
    | undefined;
  /** Mismatch between the destinations of a resource's URLs. */
  destinationMismatch?:
    | PolicyTopicEvidence_DestinationMismatch
    | undefined;
  /**
   * Details when the destination is returning an HTTP error code or isn't
   * functional in all locations for commonly used devices.
   */
  destinationNotWorking?: PolicyTopicEvidence_DestinationNotWorking | undefined;
}

/** A list of fragments of text that violated a policy. */
export interface PolicyTopicEvidence_TextList {
  /** The fragments of text from the resource that caused the policy finding. */
  texts: string[];
}

/**
 * A list of websites that caused a policy finding. Used for
 * ONE_WEBSITE_PER_AD_GROUP policy topic, for example. In case there are more
 * than five websites, only the top five (those that appear in resources the
 * most) will be listed here.
 */
export interface PolicyTopicEvidence_WebsiteList {
  /** Websites that caused the policy finding. */
  websites: string[];
}

/**
 * A list of strings found in a destination page that caused a policy
 * finding.
 */
export interface PolicyTopicEvidence_DestinationTextList {
  /** List of text found in the resource's destination page. */
  destinationTexts: string[];
}

/** Evidence of mismatches between the URLs of a resource. */
export interface PolicyTopicEvidence_DestinationMismatch {
  /** The set of URLs that did not match each other. */
  urlTypes: PolicyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlType[];
}

/**
 * Evidence details when the destination is returning an HTTP error
 * code or isn't functional in all locations for commonly used devices.
 */
export interface PolicyTopicEvidence_DestinationNotWorking {
  /** The full URL that didn't work. */
  expandedUrl?:
    | string
    | undefined;
  /** The type of device that failed to load the URL. */
  device: PolicyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDevice;
  /**
   * The time the URL was last checked.
   * The format is "YYYY-MM-DD HH:MM:SS".
   * Examples: "2018-03-05 09:15:00" or "2018-02-01 14:34:30"
   */
  lastCheckedDateTime?:
    | string
    | undefined;
  /** The type of DNS error. */
  dnsErrorType?:
    | PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorType
    | undefined;
  /** The HTTP error code. */
  httpErrorCode?: Long | undefined;
}

/** Describes the effect on serving that a policy topic entry will have. */
export interface PolicyTopicConstraint {
  /** Countries where the resource cannot serve. */
  countryConstraintList?:
    | PolicyTopicConstraint_CountryConstraintList
    | undefined;
  /** Reseller constraint. */
  resellerConstraint?:
    | PolicyTopicConstraint_ResellerConstraint
    | undefined;
  /** Countries where a certificate is required for serving. */
  certificateMissingInCountryList?:
    | PolicyTopicConstraint_CountryConstraintList
    | undefined;
  /**
   * Countries where the resource's domain is not covered by the
   * certificates associated with it.
   */
  certificateDomainMismatchInCountryList?: PolicyTopicConstraint_CountryConstraintList | undefined;
}

/** A list of countries where a resource's serving is constrained. */
export interface PolicyTopicConstraint_CountryConstraintList {
  /** Total number of countries targeted by the resource. */
  totalTargetedCountries?:
    | number
    | undefined;
  /** Countries in which serving is restricted. */
  countries: PolicyTopicConstraint_CountryConstraint[];
}

/**
 * Indicates that a policy topic was constrained due to disapproval of the
 * website for reseller purposes.
 */
export interface PolicyTopicConstraint_ResellerConstraint {
}

/**
 * Indicates that a resource's ability to serve in a particular country is
 * constrained.
 */
export interface PolicyTopicConstraint_CountryConstraint {
  /**
   * Geo target constant resource name of the country in which serving is
   * constrained.
   */
  countryCriterion?: string | undefined;
}

function createBasePolicyViolationKey(): PolicyViolationKey {
  return { policyName: undefined, violatingText: undefined };
}

export const PolicyViolationKey: MessageFns<PolicyViolationKey> = {
  encode(message: PolicyViolationKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyName !== undefined) {
      writer.uint32(26).string(message.policyName);
    }
    if (message.violatingText !== undefined) {
      writer.uint32(34).string(message.violatingText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyViolationKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyViolationKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.violatingText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyViolationKey {
    return {
      policyName: isSet(object.policyName) ? globalThis.String(object.policyName) : undefined,
      violatingText: isSet(object.violatingText) ? globalThis.String(object.violatingText) : undefined,
    };
  },

  toJSON(message: PolicyViolationKey): unknown {
    const obj: any = {};
    if (message.policyName !== undefined) {
      obj.policyName = message.policyName;
    }
    if (message.violatingText !== undefined) {
      obj.violatingText = message.violatingText;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyViolationKey>): PolicyViolationKey {
    return PolicyViolationKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyViolationKey>): PolicyViolationKey {
    const message = createBasePolicyViolationKey();
    message.policyName = object.policyName ?? undefined;
    message.violatingText = object.violatingText ?? undefined;
    return message;
  },
};

function createBasePolicyValidationParameter(): PolicyValidationParameter {
  return { ignorablePolicyTopics: [], exemptPolicyViolationKeys: [] };
}

export const PolicyValidationParameter: MessageFns<PolicyValidationParameter> = {
  encode(message: PolicyValidationParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ignorablePolicyTopics) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.exemptPolicyViolationKeys) {
      PolicyViolationKey.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyValidationParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyValidationParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ignorablePolicyTopics.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exemptPolicyViolationKeys.push(PolicyViolationKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyValidationParameter {
    return {
      ignorablePolicyTopics: globalThis.Array.isArray(object?.ignorablePolicyTopics)
        ? object.ignorablePolicyTopics.map((e: any) => globalThis.String(e))
        : [],
      exemptPolicyViolationKeys: globalThis.Array.isArray(object?.exemptPolicyViolationKeys)
        ? object.exemptPolicyViolationKeys.map((e: any) => PolicyViolationKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyValidationParameter): unknown {
    const obj: any = {};
    if (message.ignorablePolicyTopics?.length) {
      obj.ignorablePolicyTopics = message.ignorablePolicyTopics;
    }
    if (message.exemptPolicyViolationKeys?.length) {
      obj.exemptPolicyViolationKeys = message.exemptPolicyViolationKeys.map((e) => PolicyViolationKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyValidationParameter>): PolicyValidationParameter {
    return PolicyValidationParameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyValidationParameter>): PolicyValidationParameter {
    const message = createBasePolicyValidationParameter();
    message.ignorablePolicyTopics = object.ignorablePolicyTopics?.map((e) => e) || [];
    message.exemptPolicyViolationKeys =
      object.exemptPolicyViolationKeys?.map((e) => PolicyViolationKey.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolicyTopicEntry(): PolicyTopicEntry {
  return { topic: undefined, type: 0, evidences: [], constraints: [] };
}

export const PolicyTopicEntry: MessageFns<PolicyTopicEntry> = {
  encode(message: PolicyTopicEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== undefined) {
      writer.uint32(42).string(message.topic);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.evidences) {
      PolicyTopicEvidence.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.constraints) {
      PolicyTopicConstraint.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.evidences.push(PolicyTopicEvidence.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.constraints.push(PolicyTopicConstraint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEntry {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : undefined,
      type: isSet(object.type) ? policyTopicEntryTypeEnum_PolicyTopicEntryTypeFromJSON(object.type) : 0,
      evidences: globalThis.Array.isArray(object?.evidences)
        ? object.evidences.map((e: any) => PolicyTopicEvidence.fromJSON(e))
        : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => PolicyTopicConstraint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyTopicEntry): unknown {
    const obj: any = {};
    if (message.topic !== undefined) {
      obj.topic = message.topic;
    }
    if (message.type !== 0) {
      obj.type = policyTopicEntryTypeEnum_PolicyTopicEntryTypeToJSON(message.type);
    }
    if (message.evidences?.length) {
      obj.evidences = message.evidences.map((e) => PolicyTopicEvidence.toJSON(e));
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => PolicyTopicConstraint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEntry>): PolicyTopicEntry {
    return PolicyTopicEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEntry>): PolicyTopicEntry {
    const message = createBasePolicyTopicEntry();
    message.topic = object.topic ?? undefined;
    message.type = object.type ?? 0;
    message.evidences = object.evidences?.map((e) => PolicyTopicEvidence.fromPartial(e)) || [];
    message.constraints = object.constraints?.map((e) => PolicyTopicConstraint.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolicyTopicEvidence(): PolicyTopicEvidence {
  return {
    websiteList: undefined,
    textList: undefined,
    languageCode: undefined,
    destinationTextList: undefined,
    destinationMismatch: undefined,
    destinationNotWorking: undefined,
  };
}

export const PolicyTopicEvidence: MessageFns<PolicyTopicEvidence> = {
  encode(message: PolicyTopicEvidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.websiteList !== undefined) {
      PolicyTopicEvidence_WebsiteList.encode(message.websiteList, writer.uint32(26).fork()).join();
    }
    if (message.textList !== undefined) {
      PolicyTopicEvidence_TextList.encode(message.textList, writer.uint32(34).fork()).join();
    }
    if (message.languageCode !== undefined) {
      writer.uint32(74).string(message.languageCode);
    }
    if (message.destinationTextList !== undefined) {
      PolicyTopicEvidence_DestinationTextList.encode(message.destinationTextList, writer.uint32(50).fork()).join();
    }
    if (message.destinationMismatch !== undefined) {
      PolicyTopicEvidence_DestinationMismatch.encode(message.destinationMismatch, writer.uint32(58).fork()).join();
    }
    if (message.destinationNotWorking !== undefined) {
      PolicyTopicEvidence_DestinationNotWorking.encode(message.destinationNotWorking, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.websiteList = PolicyTopicEvidence_WebsiteList.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textList = PolicyTopicEvidence_TextList.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.destinationTextList = PolicyTopicEvidence_DestinationTextList.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.destinationMismatch = PolicyTopicEvidence_DestinationMismatch.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.destinationNotWorking = PolicyTopicEvidence_DestinationNotWorking.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence {
    return {
      websiteList: isSet(object.websiteList) ? PolicyTopicEvidence_WebsiteList.fromJSON(object.websiteList) : undefined,
      textList: isSet(object.textList) ? PolicyTopicEvidence_TextList.fromJSON(object.textList) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : undefined,
      destinationTextList: isSet(object.destinationTextList)
        ? PolicyTopicEvidence_DestinationTextList.fromJSON(object.destinationTextList)
        : undefined,
      destinationMismatch: isSet(object.destinationMismatch)
        ? PolicyTopicEvidence_DestinationMismatch.fromJSON(object.destinationMismatch)
        : undefined,
      destinationNotWorking: isSet(object.destinationNotWorking)
        ? PolicyTopicEvidence_DestinationNotWorking.fromJSON(object.destinationNotWorking)
        : undefined,
    };
  },

  toJSON(message: PolicyTopicEvidence): unknown {
    const obj: any = {};
    if (message.websiteList !== undefined) {
      obj.websiteList = PolicyTopicEvidence_WebsiteList.toJSON(message.websiteList);
    }
    if (message.textList !== undefined) {
      obj.textList = PolicyTopicEvidence_TextList.toJSON(message.textList);
    }
    if (message.languageCode !== undefined) {
      obj.languageCode = message.languageCode;
    }
    if (message.destinationTextList !== undefined) {
      obj.destinationTextList = PolicyTopicEvidence_DestinationTextList.toJSON(message.destinationTextList);
    }
    if (message.destinationMismatch !== undefined) {
      obj.destinationMismatch = PolicyTopicEvidence_DestinationMismatch.toJSON(message.destinationMismatch);
    }
    if (message.destinationNotWorking !== undefined) {
      obj.destinationNotWorking = PolicyTopicEvidence_DestinationNotWorking.toJSON(message.destinationNotWorking);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence>): PolicyTopicEvidence {
    return PolicyTopicEvidence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEvidence>): PolicyTopicEvidence {
    const message = createBasePolicyTopicEvidence();
    message.websiteList = (object.websiteList !== undefined && object.websiteList !== null)
      ? PolicyTopicEvidence_WebsiteList.fromPartial(object.websiteList)
      : undefined;
    message.textList = (object.textList !== undefined && object.textList !== null)
      ? PolicyTopicEvidence_TextList.fromPartial(object.textList)
      : undefined;
    message.languageCode = object.languageCode ?? undefined;
    message.destinationTextList = (object.destinationTextList !== undefined && object.destinationTextList !== null)
      ? PolicyTopicEvidence_DestinationTextList.fromPartial(object.destinationTextList)
      : undefined;
    message.destinationMismatch = (object.destinationMismatch !== undefined && object.destinationMismatch !== null)
      ? PolicyTopicEvidence_DestinationMismatch.fromPartial(object.destinationMismatch)
      : undefined;
    message.destinationNotWorking =
      (object.destinationNotWorking !== undefined && object.destinationNotWorking !== null)
        ? PolicyTopicEvidence_DestinationNotWorking.fromPartial(object.destinationNotWorking)
        : undefined;
    return message;
  },
};

function createBasePolicyTopicEvidence_TextList(): PolicyTopicEvidence_TextList {
  return { texts: [] };
}

export const PolicyTopicEvidence_TextList: MessageFns<PolicyTopicEvidence_TextList> = {
  encode(message: PolicyTopicEvidence_TextList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.texts) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence_TextList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence_TextList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.texts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence_TextList {
    return { texts: globalThis.Array.isArray(object?.texts) ? object.texts.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: PolicyTopicEvidence_TextList): unknown {
    const obj: any = {};
    if (message.texts?.length) {
      obj.texts = message.texts;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence_TextList>): PolicyTopicEvidence_TextList {
    return PolicyTopicEvidence_TextList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEvidence_TextList>): PolicyTopicEvidence_TextList {
    const message = createBasePolicyTopicEvidence_TextList();
    message.texts = object.texts?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicyTopicEvidence_WebsiteList(): PolicyTopicEvidence_WebsiteList {
  return { websites: [] };
}

export const PolicyTopicEvidence_WebsiteList: MessageFns<PolicyTopicEvidence_WebsiteList> = {
  encode(message: PolicyTopicEvidence_WebsiteList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.websites) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence_WebsiteList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence_WebsiteList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.websites.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence_WebsiteList {
    return {
      websites: globalThis.Array.isArray(object?.websites) ? object.websites.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PolicyTopicEvidence_WebsiteList): unknown {
    const obj: any = {};
    if (message.websites?.length) {
      obj.websites = message.websites;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence_WebsiteList>): PolicyTopicEvidence_WebsiteList {
    return PolicyTopicEvidence_WebsiteList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEvidence_WebsiteList>): PolicyTopicEvidence_WebsiteList {
    const message = createBasePolicyTopicEvidence_WebsiteList();
    message.websites = object.websites?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicyTopicEvidence_DestinationTextList(): PolicyTopicEvidence_DestinationTextList {
  return { destinationTexts: [] };
}

export const PolicyTopicEvidence_DestinationTextList: MessageFns<PolicyTopicEvidence_DestinationTextList> = {
  encode(message: PolicyTopicEvidence_DestinationTextList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinationTexts) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence_DestinationTextList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence_DestinationTextList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationTexts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence_DestinationTextList {
    return {
      destinationTexts: globalThis.Array.isArray(object?.destinationTexts)
        ? object.destinationTexts.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PolicyTopicEvidence_DestinationTextList): unknown {
    const obj: any = {};
    if (message.destinationTexts?.length) {
      obj.destinationTexts = message.destinationTexts;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence_DestinationTextList>): PolicyTopicEvidence_DestinationTextList {
    return PolicyTopicEvidence_DestinationTextList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEvidence_DestinationTextList>): PolicyTopicEvidence_DestinationTextList {
    const message = createBasePolicyTopicEvidence_DestinationTextList();
    message.destinationTexts = object.destinationTexts?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicyTopicEvidence_DestinationMismatch(): PolicyTopicEvidence_DestinationMismatch {
  return { urlTypes: [] };
}

export const PolicyTopicEvidence_DestinationMismatch: MessageFns<PolicyTopicEvidence_DestinationMismatch> = {
  encode(message: PolicyTopicEvidence_DestinationMismatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.urlTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence_DestinationMismatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence_DestinationMismatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.urlTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.urlTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence_DestinationMismatch {
    return {
      urlTypes: globalThis.Array.isArray(object?.urlTypes)
        ? object.urlTypes.map((e: any) =>
          policyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlTypeFromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: PolicyTopicEvidence_DestinationMismatch): unknown {
    const obj: any = {};
    if (message.urlTypes?.length) {
      obj.urlTypes = message.urlTypes.map((e) =>
        policyTopicEvidenceDestinationMismatchUrlTypeEnum_PolicyTopicEvidenceDestinationMismatchUrlTypeToJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence_DestinationMismatch>): PolicyTopicEvidence_DestinationMismatch {
    return PolicyTopicEvidence_DestinationMismatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicEvidence_DestinationMismatch>): PolicyTopicEvidence_DestinationMismatch {
    const message = createBasePolicyTopicEvidence_DestinationMismatch();
    message.urlTypes = object.urlTypes?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicyTopicEvidence_DestinationNotWorking(): PolicyTopicEvidence_DestinationNotWorking {
  return {
    expandedUrl: undefined,
    device: 0,
    lastCheckedDateTime: undefined,
    dnsErrorType: undefined,
    httpErrorCode: undefined,
  };
}

export const PolicyTopicEvidence_DestinationNotWorking: MessageFns<PolicyTopicEvidence_DestinationNotWorking> = {
  encode(message: PolicyTopicEvidence_DestinationNotWorking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expandedUrl !== undefined) {
      writer.uint32(58).string(message.expandedUrl);
    }
    if (message.device !== 0) {
      writer.uint32(32).int32(message.device);
    }
    if (message.lastCheckedDateTime !== undefined) {
      writer.uint32(66).string(message.lastCheckedDateTime);
    }
    if (message.dnsErrorType !== undefined) {
      writer.uint32(8).int32(message.dnsErrorType);
    }
    if (message.httpErrorCode !== undefined) {
      writer.uint32(48).int64(message.httpErrorCode.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicEvidence_DestinationNotWorking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicEvidence_DestinationNotWorking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expandedUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.device = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastCheckedDateTime = reader.string();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dnsErrorType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.httpErrorCode = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicEvidence_DestinationNotWorking {
    return {
      expandedUrl: isSet(object.expandedUrl) ? globalThis.String(object.expandedUrl) : undefined,
      device: isSet(object.device)
        ? policyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDeviceFromJSON(
          object.device,
        )
        : 0,
      lastCheckedDateTime: isSet(object.lastCheckedDateTime)
        ? globalThis.String(object.lastCheckedDateTime)
        : undefined,
      dnsErrorType: isSet(object.dnsErrorType)
        ? policyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeFromJSON(
          object.dnsErrorType,
        )
        : undefined,
      httpErrorCode: isSet(object.httpErrorCode) ? Long.fromValue(object.httpErrorCode) : undefined,
    };
  },

  toJSON(message: PolicyTopicEvidence_DestinationNotWorking): unknown {
    const obj: any = {};
    if (message.expandedUrl !== undefined) {
      obj.expandedUrl = message.expandedUrl;
    }
    if (message.device !== 0) {
      obj.device =
        policyTopicEvidenceDestinationNotWorkingDeviceEnum_PolicyTopicEvidenceDestinationNotWorkingDeviceToJSON(
          message.device,
        );
    }
    if (message.lastCheckedDateTime !== undefined) {
      obj.lastCheckedDateTime = message.lastCheckedDateTime;
    }
    if (message.dnsErrorType !== undefined) {
      obj.dnsErrorType =
        policyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum_PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeToJSON(
          message.dnsErrorType,
        );
    }
    if (message.httpErrorCode !== undefined) {
      obj.httpErrorCode = (message.httpErrorCode || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicEvidence_DestinationNotWorking>): PolicyTopicEvidence_DestinationNotWorking {
    return PolicyTopicEvidence_DestinationNotWorking.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PolicyTopicEvidence_DestinationNotWorking>,
  ): PolicyTopicEvidence_DestinationNotWorking {
    const message = createBasePolicyTopicEvidence_DestinationNotWorking();
    message.expandedUrl = object.expandedUrl ?? undefined;
    message.device = object.device ?? 0;
    message.lastCheckedDateTime = object.lastCheckedDateTime ?? undefined;
    message.dnsErrorType = object.dnsErrorType ?? undefined;
    message.httpErrorCode = (object.httpErrorCode !== undefined && object.httpErrorCode !== null)
      ? Long.fromValue(object.httpErrorCode)
      : undefined;
    return message;
  },
};

function createBasePolicyTopicConstraint(): PolicyTopicConstraint {
  return {
    countryConstraintList: undefined,
    resellerConstraint: undefined,
    certificateMissingInCountryList: undefined,
    certificateDomainMismatchInCountryList: undefined,
  };
}

export const PolicyTopicConstraint: MessageFns<PolicyTopicConstraint> = {
  encode(message: PolicyTopicConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryConstraintList !== undefined) {
      PolicyTopicConstraint_CountryConstraintList.encode(message.countryConstraintList, writer.uint32(10).fork())
        .join();
    }
    if (message.resellerConstraint !== undefined) {
      PolicyTopicConstraint_ResellerConstraint.encode(message.resellerConstraint, writer.uint32(18).fork()).join();
    }
    if (message.certificateMissingInCountryList !== undefined) {
      PolicyTopicConstraint_CountryConstraintList.encode(
        message.certificateMissingInCountryList,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.certificateDomainMismatchInCountryList !== undefined) {
      PolicyTopicConstraint_CountryConstraintList.encode(
        message.certificateDomainMismatchInCountryList,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryConstraintList = PolicyTopicConstraint_CountryConstraintList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resellerConstraint = PolicyTopicConstraint_ResellerConstraint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.certificateMissingInCountryList = PolicyTopicConstraint_CountryConstraintList.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.certificateDomainMismatchInCountryList = PolicyTopicConstraint_CountryConstraintList.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicConstraint {
    return {
      countryConstraintList: isSet(object.countryConstraintList)
        ? PolicyTopicConstraint_CountryConstraintList.fromJSON(object.countryConstraintList)
        : undefined,
      resellerConstraint: isSet(object.resellerConstraint)
        ? PolicyTopicConstraint_ResellerConstraint.fromJSON(object.resellerConstraint)
        : undefined,
      certificateMissingInCountryList: isSet(object.certificateMissingInCountryList)
        ? PolicyTopicConstraint_CountryConstraintList.fromJSON(object.certificateMissingInCountryList)
        : undefined,
      certificateDomainMismatchInCountryList: isSet(object.certificateDomainMismatchInCountryList)
        ? PolicyTopicConstraint_CountryConstraintList.fromJSON(object.certificateDomainMismatchInCountryList)
        : undefined,
    };
  },

  toJSON(message: PolicyTopicConstraint): unknown {
    const obj: any = {};
    if (message.countryConstraintList !== undefined) {
      obj.countryConstraintList = PolicyTopicConstraint_CountryConstraintList.toJSON(message.countryConstraintList);
    }
    if (message.resellerConstraint !== undefined) {
      obj.resellerConstraint = PolicyTopicConstraint_ResellerConstraint.toJSON(message.resellerConstraint);
    }
    if (message.certificateMissingInCountryList !== undefined) {
      obj.certificateMissingInCountryList = PolicyTopicConstraint_CountryConstraintList.toJSON(
        message.certificateMissingInCountryList,
      );
    }
    if (message.certificateDomainMismatchInCountryList !== undefined) {
      obj.certificateDomainMismatchInCountryList = PolicyTopicConstraint_CountryConstraintList.toJSON(
        message.certificateDomainMismatchInCountryList,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicConstraint>): PolicyTopicConstraint {
    return PolicyTopicConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicConstraint>): PolicyTopicConstraint {
    const message = createBasePolicyTopicConstraint();
    message.countryConstraintList =
      (object.countryConstraintList !== undefined && object.countryConstraintList !== null)
        ? PolicyTopicConstraint_CountryConstraintList.fromPartial(object.countryConstraintList)
        : undefined;
    message.resellerConstraint = (object.resellerConstraint !== undefined && object.resellerConstraint !== null)
      ? PolicyTopicConstraint_ResellerConstraint.fromPartial(object.resellerConstraint)
      : undefined;
    message.certificateMissingInCountryList =
      (object.certificateMissingInCountryList !== undefined && object.certificateMissingInCountryList !== null)
        ? PolicyTopicConstraint_CountryConstraintList.fromPartial(object.certificateMissingInCountryList)
        : undefined;
    message.certificateDomainMismatchInCountryList =
      (object.certificateDomainMismatchInCountryList !== undefined &&
          object.certificateDomainMismatchInCountryList !== null)
        ? PolicyTopicConstraint_CountryConstraintList.fromPartial(object.certificateDomainMismatchInCountryList)
        : undefined;
    return message;
  },
};

function createBasePolicyTopicConstraint_CountryConstraintList(): PolicyTopicConstraint_CountryConstraintList {
  return { totalTargetedCountries: undefined, countries: [] };
}

export const PolicyTopicConstraint_CountryConstraintList: MessageFns<PolicyTopicConstraint_CountryConstraintList> = {
  encode(
    message: PolicyTopicConstraint_CountryConstraintList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.totalTargetedCountries !== undefined) {
      writer.uint32(24).int32(message.totalTargetedCountries);
    }
    for (const v of message.countries) {
      PolicyTopicConstraint_CountryConstraint.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicConstraint_CountryConstraintList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicConstraint_CountryConstraintList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTargetedCountries = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.countries.push(PolicyTopicConstraint_CountryConstraint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicConstraint_CountryConstraintList {
    return {
      totalTargetedCountries: isSet(object.totalTargetedCountries)
        ? globalThis.Number(object.totalTargetedCountries)
        : undefined,
      countries: globalThis.Array.isArray(object?.countries)
        ? object.countries.map((e: any) => PolicyTopicConstraint_CountryConstraint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyTopicConstraint_CountryConstraintList): unknown {
    const obj: any = {};
    if (message.totalTargetedCountries !== undefined) {
      obj.totalTargetedCountries = Math.round(message.totalTargetedCountries);
    }
    if (message.countries?.length) {
      obj.countries = message.countries.map((e) => PolicyTopicConstraint_CountryConstraint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicConstraint_CountryConstraintList>): PolicyTopicConstraint_CountryConstraintList {
    return PolicyTopicConstraint_CountryConstraintList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PolicyTopicConstraint_CountryConstraintList>,
  ): PolicyTopicConstraint_CountryConstraintList {
    const message = createBasePolicyTopicConstraint_CountryConstraintList();
    message.totalTargetedCountries = object.totalTargetedCountries ?? undefined;
    message.countries = object.countries?.map((e) => PolicyTopicConstraint_CountryConstraint.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolicyTopicConstraint_ResellerConstraint(): PolicyTopicConstraint_ResellerConstraint {
  return {};
}

export const PolicyTopicConstraint_ResellerConstraint: MessageFns<PolicyTopicConstraint_ResellerConstraint> = {
  encode(_: PolicyTopicConstraint_ResellerConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicConstraint_ResellerConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicConstraint_ResellerConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PolicyTopicConstraint_ResellerConstraint {
    return {};
  },

  toJSON(_: PolicyTopicConstraint_ResellerConstraint): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicConstraint_ResellerConstraint>): PolicyTopicConstraint_ResellerConstraint {
    return PolicyTopicConstraint_ResellerConstraint.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PolicyTopicConstraint_ResellerConstraint>): PolicyTopicConstraint_ResellerConstraint {
    const message = createBasePolicyTopicConstraint_ResellerConstraint();
    return message;
  },
};

function createBasePolicyTopicConstraint_CountryConstraint(): PolicyTopicConstraint_CountryConstraint {
  return { countryCriterion: undefined };
}

export const PolicyTopicConstraint_CountryConstraint: MessageFns<PolicyTopicConstraint_CountryConstraint> = {
  encode(message: PolicyTopicConstraint_CountryConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCriterion !== undefined) {
      writer.uint32(18).string(message.countryCriterion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTopicConstraint_CountryConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTopicConstraint_CountryConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.countryCriterion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTopicConstraint_CountryConstraint {
    return {
      countryCriterion: isSet(object.countryCriterion) ? globalThis.String(object.countryCriterion) : undefined,
    };
  },

  toJSON(message: PolicyTopicConstraint_CountryConstraint): unknown {
    const obj: any = {};
    if (message.countryCriterion !== undefined) {
      obj.countryCriterion = message.countryCriterion;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyTopicConstraint_CountryConstraint>): PolicyTopicConstraint_CountryConstraint {
    return PolicyTopicConstraint_CountryConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyTopicConstraint_CountryConstraint>): PolicyTopicConstraint_CountryConstraint {
    const message = createBasePolicyTopicConstraint_CountryConstraint();
    message.countryCriterion = object.countryCriterion ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
