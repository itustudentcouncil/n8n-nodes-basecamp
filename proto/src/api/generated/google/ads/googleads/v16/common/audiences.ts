// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/common/audiences.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  GenderTypeEnum_GenderType,
  genderTypeEnum_GenderTypeFromJSON,
  genderTypeEnum_GenderTypeToJSON,
} from "../enums/gender_type.js";
import {
  IncomeRangeTypeEnum_IncomeRangeType,
  incomeRangeTypeEnum_IncomeRangeTypeFromJSON,
  incomeRangeTypeEnum_IncomeRangeTypeToJSON,
} from "../enums/income_range_type.js";
import {
  ParentalStatusTypeEnum_ParentalStatusType,
  parentalStatusTypeEnum_ParentalStatusTypeFromJSON,
  parentalStatusTypeEnum_ParentalStatusTypeToJSON,
} from "../enums/parental_status_type.js";

export const protobufPackage = "google.ads.googleads.v16.common";

/** Positive dimension specifying user's audience. */
export interface AudienceDimension {
  /** Dimension specifying users by their age. */
  age?:
    | AgeDimension
    | undefined;
  /** Dimension specifying users by their gender. */
  gender?:
    | GenderDimension
    | undefined;
  /** Dimension specifying users by their household income. */
  householdIncome?:
    | HouseholdIncomeDimension
    | undefined;
  /** Dimension specifying users by their parental status. */
  parentalStatus?:
    | ParentalStatusDimension
    | undefined;
  /**
   * Dimension specifying users by their membership in other audience
   * segments.
   */
  audienceSegments?: AudienceSegmentDimension | undefined;
}

/** Negative dimension specifying users to exclude from the audience. */
export interface AudienceExclusionDimension {
  /** Audience segment to be excluded. */
  exclusions: ExclusionSegment[];
}

/** An audience segment to be excluded from an audience. */
export interface ExclusionSegment {
  /** User list segment to be excluded. */
  userList?: UserListSegment | undefined;
}

/** Dimension specifying users by their age. */
export interface AgeDimension {
  /** Contiguous age range to be included in the dimension. */
  ageRanges: AgeSegment[];
  /** Include users whose age is not determined. */
  includeUndetermined?: boolean | undefined;
}

/** Contiguous age range. */
export interface AgeSegment {
  /**
   * Minimum age to include. A minimum age must be specified and must be at
   * least 18. Allowed values are 18, 25, 35, 45, 55, and 65.
   */
  minAge?:
    | number
    | undefined;
  /**
   * Maximum age to include. A maximum age need not be specified. If specified,
   * max_age must be greater than min_age, and allowed values are 24, 34, 44,
   * 54, and 64.
   */
  maxAge?: number | undefined;
}

/** Dimension specifying users by their gender. */
export interface GenderDimension {
  /** Included gender demographic segments. */
  genders: GenderTypeEnum_GenderType[];
  /** Include users whose gender is not determined. */
  includeUndetermined?: boolean | undefined;
}

/** Dimension specifying users by their household income. */
export interface HouseholdIncomeDimension {
  /** Included household income demographic segments. */
  incomeRanges: IncomeRangeTypeEnum_IncomeRangeType[];
  /** Include users whose household income is not determined. */
  includeUndetermined?: boolean | undefined;
}

/** Dimension specifying users by their parental status. */
export interface ParentalStatusDimension {
  /** Included parental status demographic segments. */
  parentalStatuses: ParentalStatusTypeEnum_ParentalStatusType[];
  /** Include users whose parental status is undetermined. */
  includeUndetermined?: boolean | undefined;
}

/** Dimension specifying users by their membership in other audience segments. */
export interface AudienceSegmentDimension {
  /**
   * Included audience segments. Users are included if they belong to at least
   * one segment.
   */
  segments: AudienceSegment[];
}

/** Positive audience segment. */
export interface AudienceSegment {
  /** User list segment. */
  userList?:
    | UserListSegment
    | undefined;
  /** Affinity or In-market segment. */
  userInterest?:
    | UserInterestSegment
    | undefined;
  /** Live-event audience segment. */
  lifeEvent?:
    | LifeEventSegment
    | undefined;
  /** Detailed demographic segment. */
  detailedDemographic?:
    | DetailedDemographicSegment
    | undefined;
  /** Custom audience segment. */
  customAudience?: CustomAudienceSegment | undefined;
}

/**
 * User list segment.
 * The Similar Audiences sunset starts May 2023. Refer to
 * https://ads-developers.googleblog.com/2022/11/announcing-deprecation-and-sunset-of.html
 * for other options.
 */
export interface UserListSegment {
  /** The user list resource. */
  userList?: string | undefined;
}

/** User interest segment. */
export interface UserInterestSegment {
  /** The user interest resource. */
  userInterestCategory?: string | undefined;
}

/** Live event segment. */
export interface LifeEventSegment {
  /** The life event resource. */
  lifeEvent?: string | undefined;
}

/** Detailed demographic segment. */
export interface DetailedDemographicSegment {
  /** The detailed demographic resource. */
  detailedDemographic?: string | undefined;
}

/** Custom audience segment. */
export interface CustomAudienceSegment {
  /** The custom audience resource. */
  customAudience?: string | undefined;
}

function createBaseAudienceDimension(): AudienceDimension {
  return {
    age: undefined,
    gender: undefined,
    householdIncome: undefined,
    parentalStatus: undefined,
    audienceSegments: undefined,
  };
}

export const AudienceDimension: MessageFns<AudienceDimension> = {
  encode(message: AudienceDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.age !== undefined) {
      AgeDimension.encode(message.age, writer.uint32(10).fork()).join();
    }
    if (message.gender !== undefined) {
      GenderDimension.encode(message.gender, writer.uint32(18).fork()).join();
    }
    if (message.householdIncome !== undefined) {
      HouseholdIncomeDimension.encode(message.householdIncome, writer.uint32(26).fork()).join();
    }
    if (message.parentalStatus !== undefined) {
      ParentalStatusDimension.encode(message.parentalStatus, writer.uint32(34).fork()).join();
    }
    if (message.audienceSegments !== undefined) {
      AudienceSegmentDimension.encode(message.audienceSegments, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.age = AgeDimension.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gender = GenderDimension.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.householdIncome = HouseholdIncomeDimension.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parentalStatus = ParentalStatusDimension.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.audienceSegments = AudienceSegmentDimension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimension {
    return {
      age: isSet(object.age) ? AgeDimension.fromJSON(object.age) : undefined,
      gender: isSet(object.gender) ? GenderDimension.fromJSON(object.gender) : undefined,
      householdIncome: isSet(object.householdIncome)
        ? HouseholdIncomeDimension.fromJSON(object.householdIncome)
        : undefined,
      parentalStatus: isSet(object.parentalStatus)
        ? ParentalStatusDimension.fromJSON(object.parentalStatus)
        : undefined,
      audienceSegments: isSet(object.audienceSegments)
        ? AudienceSegmentDimension.fromJSON(object.audienceSegments)
        : undefined,
    };
  },

  toJSON(message: AudienceDimension): unknown {
    const obj: any = {};
    if (message.age !== undefined) {
      obj.age = AgeDimension.toJSON(message.age);
    }
    if (message.gender !== undefined) {
      obj.gender = GenderDimension.toJSON(message.gender);
    }
    if (message.householdIncome !== undefined) {
      obj.householdIncome = HouseholdIncomeDimension.toJSON(message.householdIncome);
    }
    if (message.parentalStatus !== undefined) {
      obj.parentalStatus = ParentalStatusDimension.toJSON(message.parentalStatus);
    }
    if (message.audienceSegments !== undefined) {
      obj.audienceSegments = AudienceSegmentDimension.toJSON(message.audienceSegments);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimension>): AudienceDimension {
    return AudienceDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimension>): AudienceDimension {
    const message = createBaseAudienceDimension();
    message.age = (object.age !== undefined && object.age !== null) ? AgeDimension.fromPartial(object.age) : undefined;
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenderDimension.fromPartial(object.gender)
      : undefined;
    message.householdIncome = (object.householdIncome !== undefined && object.householdIncome !== null)
      ? HouseholdIncomeDimension.fromPartial(object.householdIncome)
      : undefined;
    message.parentalStatus = (object.parentalStatus !== undefined && object.parentalStatus !== null)
      ? ParentalStatusDimension.fromPartial(object.parentalStatus)
      : undefined;
    message.audienceSegments = (object.audienceSegments !== undefined && object.audienceSegments !== null)
      ? AudienceSegmentDimension.fromPartial(object.audienceSegments)
      : undefined;
    return message;
  },
};

function createBaseAudienceExclusionDimension(): AudienceExclusionDimension {
  return { exclusions: [] };
}

export const AudienceExclusionDimension: MessageFns<AudienceExclusionDimension> = {
  encode(message: AudienceExclusionDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.exclusions) {
      ExclusionSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceExclusionDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceExclusionDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exclusions.push(ExclusionSegment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceExclusionDimension {
    return {
      exclusions: globalThis.Array.isArray(object?.exclusions)
        ? object.exclusions.map((e: any) => ExclusionSegment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceExclusionDimension): unknown {
    const obj: any = {};
    if (message.exclusions?.length) {
      obj.exclusions = message.exclusions.map((e) => ExclusionSegment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceExclusionDimension>): AudienceExclusionDimension {
    return AudienceExclusionDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceExclusionDimension>): AudienceExclusionDimension {
    const message = createBaseAudienceExclusionDimension();
    message.exclusions = object.exclusions?.map((e) => ExclusionSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExclusionSegment(): ExclusionSegment {
  return { userList: undefined };
}

export const ExclusionSegment: MessageFns<ExclusionSegment> = {
  encode(message: ExclusionSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      UserListSegment.encode(message.userList, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExclusionSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExclusionSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userList = UserListSegment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExclusionSegment {
    return { userList: isSet(object.userList) ? UserListSegment.fromJSON(object.userList) : undefined };
  },

  toJSON(message: ExclusionSegment): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = UserListSegment.toJSON(message.userList);
    }
    return obj;
  },

  create(base?: DeepPartial<ExclusionSegment>): ExclusionSegment {
    return ExclusionSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExclusionSegment>): ExclusionSegment {
    const message = createBaseExclusionSegment();
    message.userList = (object.userList !== undefined && object.userList !== null)
      ? UserListSegment.fromPartial(object.userList)
      : undefined;
    return message;
  },
};

function createBaseAgeDimension(): AgeDimension {
  return { ageRanges: [], includeUndetermined: undefined };
}

export const AgeDimension: MessageFns<AgeDimension> = {
  encode(message: AgeDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageRanges) {
      AgeSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.includeUndetermined !== undefined) {
      writer.uint32(16).bool(message.includeUndetermined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ageRanges.push(AgeSegment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeUndetermined = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeDimension {
    return {
      ageRanges: globalThis.Array.isArray(object?.ageRanges)
        ? object.ageRanges.map((e: any) => AgeSegment.fromJSON(e))
        : [],
      includeUndetermined: isSet(object.includeUndetermined)
        ? globalThis.Boolean(object.includeUndetermined)
        : undefined,
    };
  },

  toJSON(message: AgeDimension): unknown {
    const obj: any = {};
    if (message.ageRanges?.length) {
      obj.ageRanges = message.ageRanges.map((e) => AgeSegment.toJSON(e));
    }
    if (message.includeUndetermined !== undefined) {
      obj.includeUndetermined = message.includeUndetermined;
    }
    return obj;
  },

  create(base?: DeepPartial<AgeDimension>): AgeDimension {
    return AgeDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeDimension>): AgeDimension {
    const message = createBaseAgeDimension();
    message.ageRanges = object.ageRanges?.map((e) => AgeSegment.fromPartial(e)) || [];
    message.includeUndetermined = object.includeUndetermined ?? undefined;
    return message;
  },
};

function createBaseAgeSegment(): AgeSegment {
  return { minAge: undefined, maxAge: undefined };
}

export const AgeSegment: MessageFns<AgeSegment> = {
  encode(message: AgeSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minAge !== undefined) {
      writer.uint32(8).int32(message.minAge);
    }
    if (message.maxAge !== undefined) {
      writer.uint32(16).int32(message.maxAge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minAge = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxAge = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeSegment {
    return {
      minAge: isSet(object.minAge) ? globalThis.Number(object.minAge) : undefined,
      maxAge: isSet(object.maxAge) ? globalThis.Number(object.maxAge) : undefined,
    };
  },

  toJSON(message: AgeSegment): unknown {
    const obj: any = {};
    if (message.minAge !== undefined) {
      obj.minAge = Math.round(message.minAge);
    }
    if (message.maxAge !== undefined) {
      obj.maxAge = Math.round(message.maxAge);
    }
    return obj;
  },

  create(base?: DeepPartial<AgeSegment>): AgeSegment {
    return AgeSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeSegment>): AgeSegment {
    const message = createBaseAgeSegment();
    message.minAge = object.minAge ?? undefined;
    message.maxAge = object.maxAge ?? undefined;
    return message;
  },
};

function createBaseGenderDimension(): GenderDimension {
  return { genders: [], includeUndetermined: undefined };
}

export const GenderDimension: MessageFns<GenderDimension> = {
  encode(message: GenderDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.genders) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeUndetermined !== undefined) {
      writer.uint32(16).bool(message.includeUndetermined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenderDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenderDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.genders.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.genders.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeUndetermined = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenderDimension {
    return {
      genders: globalThis.Array.isArray(object?.genders)
        ? object.genders.map((e: any) => genderTypeEnum_GenderTypeFromJSON(e))
        : [],
      includeUndetermined: isSet(object.includeUndetermined)
        ? globalThis.Boolean(object.includeUndetermined)
        : undefined,
    };
  },

  toJSON(message: GenderDimension): unknown {
    const obj: any = {};
    if (message.genders?.length) {
      obj.genders = message.genders.map((e) => genderTypeEnum_GenderTypeToJSON(e));
    }
    if (message.includeUndetermined !== undefined) {
      obj.includeUndetermined = message.includeUndetermined;
    }
    return obj;
  },

  create(base?: DeepPartial<GenderDimension>): GenderDimension {
    return GenderDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenderDimension>): GenderDimension {
    const message = createBaseGenderDimension();
    message.genders = object.genders?.map((e) => e) || [];
    message.includeUndetermined = object.includeUndetermined ?? undefined;
    return message;
  },
};

function createBaseHouseholdIncomeDimension(): HouseholdIncomeDimension {
  return { incomeRanges: [], includeUndetermined: undefined };
}

export const HouseholdIncomeDimension: MessageFns<HouseholdIncomeDimension> = {
  encode(message: HouseholdIncomeDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.incomeRanges) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeUndetermined !== undefined) {
      writer.uint32(16).bool(message.includeUndetermined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HouseholdIncomeDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHouseholdIncomeDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.incomeRanges.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.incomeRanges.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeUndetermined = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HouseholdIncomeDimension {
    return {
      incomeRanges: globalThis.Array.isArray(object?.incomeRanges)
        ? object.incomeRanges.map((e: any) => incomeRangeTypeEnum_IncomeRangeTypeFromJSON(e))
        : [],
      includeUndetermined: isSet(object.includeUndetermined)
        ? globalThis.Boolean(object.includeUndetermined)
        : undefined,
    };
  },

  toJSON(message: HouseholdIncomeDimension): unknown {
    const obj: any = {};
    if (message.incomeRanges?.length) {
      obj.incomeRanges = message.incomeRanges.map((e) => incomeRangeTypeEnum_IncomeRangeTypeToJSON(e));
    }
    if (message.includeUndetermined !== undefined) {
      obj.includeUndetermined = message.includeUndetermined;
    }
    return obj;
  },

  create(base?: DeepPartial<HouseholdIncomeDimension>): HouseholdIncomeDimension {
    return HouseholdIncomeDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HouseholdIncomeDimension>): HouseholdIncomeDimension {
    const message = createBaseHouseholdIncomeDimension();
    message.incomeRanges = object.incomeRanges?.map((e) => e) || [];
    message.includeUndetermined = object.includeUndetermined ?? undefined;
    return message;
  },
};

function createBaseParentalStatusDimension(): ParentalStatusDimension {
  return { parentalStatuses: [], includeUndetermined: undefined };
}

export const ParentalStatusDimension: MessageFns<ParentalStatusDimension> = {
  encode(message: ParentalStatusDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.parentalStatuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeUndetermined !== undefined) {
      writer.uint32(16).bool(message.includeUndetermined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParentalStatusDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParentalStatusDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.parentalStatuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.parentalStatuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeUndetermined = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParentalStatusDimension {
    return {
      parentalStatuses: globalThis.Array.isArray(object?.parentalStatuses)
        ? object.parentalStatuses.map((e: any) => parentalStatusTypeEnum_ParentalStatusTypeFromJSON(e))
        : [],
      includeUndetermined: isSet(object.includeUndetermined)
        ? globalThis.Boolean(object.includeUndetermined)
        : undefined,
    };
  },

  toJSON(message: ParentalStatusDimension): unknown {
    const obj: any = {};
    if (message.parentalStatuses?.length) {
      obj.parentalStatuses = message.parentalStatuses.map((e) => parentalStatusTypeEnum_ParentalStatusTypeToJSON(e));
    }
    if (message.includeUndetermined !== undefined) {
      obj.includeUndetermined = message.includeUndetermined;
    }
    return obj;
  },

  create(base?: DeepPartial<ParentalStatusDimension>): ParentalStatusDimension {
    return ParentalStatusDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParentalStatusDimension>): ParentalStatusDimension {
    const message = createBaseParentalStatusDimension();
    message.parentalStatuses = object.parentalStatuses?.map((e) => e) || [];
    message.includeUndetermined = object.includeUndetermined ?? undefined;
    return message;
  },
};

function createBaseAudienceSegmentDimension(): AudienceSegmentDimension {
  return { segments: [] };
}

export const AudienceSegmentDimension: MessageFns<AudienceSegmentDimension> = {
  encode(message: AudienceSegmentDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.segments) {
      AudienceSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceSegmentDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceSegmentDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segments.push(AudienceSegment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceSegmentDimension {
    return {
      segments: globalThis.Array.isArray(object?.segments)
        ? object.segments.map((e: any) => AudienceSegment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceSegmentDimension): unknown {
    const obj: any = {};
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => AudienceSegment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceSegmentDimension>): AudienceSegmentDimension {
    return AudienceSegmentDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceSegmentDimension>): AudienceSegmentDimension {
    const message = createBaseAudienceSegmentDimension();
    message.segments = object.segments?.map((e) => AudienceSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceSegment(): AudienceSegment {
  return {
    userList: undefined,
    userInterest: undefined,
    lifeEvent: undefined,
    detailedDemographic: undefined,
    customAudience: undefined,
  };
}

export const AudienceSegment: MessageFns<AudienceSegment> = {
  encode(message: AudienceSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      UserListSegment.encode(message.userList, writer.uint32(10).fork()).join();
    }
    if (message.userInterest !== undefined) {
      UserInterestSegment.encode(message.userInterest, writer.uint32(18).fork()).join();
    }
    if (message.lifeEvent !== undefined) {
      LifeEventSegment.encode(message.lifeEvent, writer.uint32(26).fork()).join();
    }
    if (message.detailedDemographic !== undefined) {
      DetailedDemographicSegment.encode(message.detailedDemographic, writer.uint32(34).fork()).join();
    }
    if (message.customAudience !== undefined) {
      CustomAudienceSegment.encode(message.customAudience, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userList = UserListSegment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userInterest = UserInterestSegment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lifeEvent = LifeEventSegment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detailedDemographic = DetailedDemographicSegment.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customAudience = CustomAudienceSegment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceSegment {
    return {
      userList: isSet(object.userList) ? UserListSegment.fromJSON(object.userList) : undefined,
      userInterest: isSet(object.userInterest) ? UserInterestSegment.fromJSON(object.userInterest) : undefined,
      lifeEvent: isSet(object.lifeEvent) ? LifeEventSegment.fromJSON(object.lifeEvent) : undefined,
      detailedDemographic: isSet(object.detailedDemographic)
        ? DetailedDemographicSegment.fromJSON(object.detailedDemographic)
        : undefined,
      customAudience: isSet(object.customAudience) ? CustomAudienceSegment.fromJSON(object.customAudience) : undefined,
    };
  },

  toJSON(message: AudienceSegment): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = UserListSegment.toJSON(message.userList);
    }
    if (message.userInterest !== undefined) {
      obj.userInterest = UserInterestSegment.toJSON(message.userInterest);
    }
    if (message.lifeEvent !== undefined) {
      obj.lifeEvent = LifeEventSegment.toJSON(message.lifeEvent);
    }
    if (message.detailedDemographic !== undefined) {
      obj.detailedDemographic = DetailedDemographicSegment.toJSON(message.detailedDemographic);
    }
    if (message.customAudience !== undefined) {
      obj.customAudience = CustomAudienceSegment.toJSON(message.customAudience);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceSegment>): AudienceSegment {
    return AudienceSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceSegment>): AudienceSegment {
    const message = createBaseAudienceSegment();
    message.userList = (object.userList !== undefined && object.userList !== null)
      ? UserListSegment.fromPartial(object.userList)
      : undefined;
    message.userInterest = (object.userInterest !== undefined && object.userInterest !== null)
      ? UserInterestSegment.fromPartial(object.userInterest)
      : undefined;
    message.lifeEvent = (object.lifeEvent !== undefined && object.lifeEvent !== null)
      ? LifeEventSegment.fromPartial(object.lifeEvent)
      : undefined;
    message.detailedDemographic = (object.detailedDemographic !== undefined && object.detailedDemographic !== null)
      ? DetailedDemographicSegment.fromPartial(object.detailedDemographic)
      : undefined;
    message.customAudience = (object.customAudience !== undefined && object.customAudience !== null)
      ? CustomAudienceSegment.fromPartial(object.customAudience)
      : undefined;
    return message;
  },
};

function createBaseUserListSegment(): UserListSegment {
  return { userList: undefined };
}

export const UserListSegment: MessageFns<UserListSegment> = {
  encode(message: UserListSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      writer.uint32(10).string(message.userList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userList = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListSegment {
    return { userList: isSet(object.userList) ? globalThis.String(object.userList) : undefined };
  },

  toJSON(message: UserListSegment): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = message.userList;
    }
    return obj;
  },

  create(base?: DeepPartial<UserListSegment>): UserListSegment {
    return UserListSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListSegment>): UserListSegment {
    const message = createBaseUserListSegment();
    message.userList = object.userList ?? undefined;
    return message;
  },
};

function createBaseUserInterestSegment(): UserInterestSegment {
  return { userInterestCategory: undefined };
}

export const UserInterestSegment: MessageFns<UserInterestSegment> = {
  encode(message: UserInterestSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userInterestCategory !== undefined) {
      writer.uint32(10).string(message.userInterestCategory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInterestSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInterestSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userInterestCategory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInterestSegment {
    return {
      userInterestCategory: isSet(object.userInterestCategory)
        ? globalThis.String(object.userInterestCategory)
        : undefined,
    };
  },

  toJSON(message: UserInterestSegment): unknown {
    const obj: any = {};
    if (message.userInterestCategory !== undefined) {
      obj.userInterestCategory = message.userInterestCategory;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInterestSegment>): UserInterestSegment {
    return UserInterestSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInterestSegment>): UserInterestSegment {
    const message = createBaseUserInterestSegment();
    message.userInterestCategory = object.userInterestCategory ?? undefined;
    return message;
  },
};

function createBaseLifeEventSegment(): LifeEventSegment {
  return { lifeEvent: undefined };
}

export const LifeEventSegment: MessageFns<LifeEventSegment> = {
  encode(message: LifeEventSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lifeEvent !== undefined) {
      writer.uint32(10).string(message.lifeEvent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LifeEventSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifeEventSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lifeEvent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LifeEventSegment {
    return { lifeEvent: isSet(object.lifeEvent) ? globalThis.String(object.lifeEvent) : undefined };
  },

  toJSON(message: LifeEventSegment): unknown {
    const obj: any = {};
    if (message.lifeEvent !== undefined) {
      obj.lifeEvent = message.lifeEvent;
    }
    return obj;
  },

  create(base?: DeepPartial<LifeEventSegment>): LifeEventSegment {
    return LifeEventSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LifeEventSegment>): LifeEventSegment {
    const message = createBaseLifeEventSegment();
    message.lifeEvent = object.lifeEvent ?? undefined;
    return message;
  },
};

function createBaseDetailedDemographicSegment(): DetailedDemographicSegment {
  return { detailedDemographic: undefined };
}

export const DetailedDemographicSegment: MessageFns<DetailedDemographicSegment> = {
  encode(message: DetailedDemographicSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detailedDemographic !== undefined) {
      writer.uint32(10).string(message.detailedDemographic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedDemographicSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedDemographicSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.detailedDemographic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedDemographicSegment {
    return {
      detailedDemographic: isSet(object.detailedDemographic)
        ? globalThis.String(object.detailedDemographic)
        : undefined,
    };
  },

  toJSON(message: DetailedDemographicSegment): unknown {
    const obj: any = {};
    if (message.detailedDemographic !== undefined) {
      obj.detailedDemographic = message.detailedDemographic;
    }
    return obj;
  },

  create(base?: DeepPartial<DetailedDemographicSegment>): DetailedDemographicSegment {
    return DetailedDemographicSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetailedDemographicSegment>): DetailedDemographicSegment {
    const message = createBaseDetailedDemographicSegment();
    message.detailedDemographic = object.detailedDemographic ?? undefined;
    return message;
  },
};

function createBaseCustomAudienceSegment(): CustomAudienceSegment {
  return { customAudience: undefined };
}

export const CustomAudienceSegment: MessageFns<CustomAudienceSegment> = {
  encode(message: CustomAudienceSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customAudience !== undefined) {
      writer.uint32(10).string(message.customAudience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAudienceSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAudienceSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customAudience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAudienceSegment {
    return { customAudience: isSet(object.customAudience) ? globalThis.String(object.customAudience) : undefined };
  },

  toJSON(message: CustomAudienceSegment): unknown {
    const obj: any = {};
    if (message.customAudience !== undefined) {
      obj.customAudience = message.customAudience;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAudienceSegment>): CustomAudienceSegment {
    return CustomAudienceSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAudienceSegment>): CustomAudienceSegment {
    const message = createBaseCustomAudienceSegment();
    message.customAudience = object.customAudience ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
