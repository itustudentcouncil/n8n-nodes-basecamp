// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/resources/account_budget_proposal.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  AccountBudgetProposalStatusEnum_AccountBudgetProposalStatus,
  accountBudgetProposalStatusEnum_AccountBudgetProposalStatusFromJSON,
  accountBudgetProposalStatusEnum_AccountBudgetProposalStatusToJSON,
} from "../enums/account_budget_proposal_status.js";
import {
  AccountBudgetProposalTypeEnum_AccountBudgetProposalType,
  accountBudgetProposalTypeEnum_AccountBudgetProposalTypeFromJSON,
  accountBudgetProposalTypeEnum_AccountBudgetProposalTypeToJSON,
} from "../enums/account_budget_proposal_type.js";
import {
  SpendingLimitTypeEnum_SpendingLimitType,
  spendingLimitTypeEnum_SpendingLimitTypeFromJSON,
  spendingLimitTypeEnum_SpendingLimitTypeToJSON,
} from "../enums/spending_limit_type.js";
import {
  TimeTypeEnum_TimeType,
  timeTypeEnum_TimeTypeFromJSON,
  timeTypeEnum_TimeTypeToJSON,
} from "../enums/time_type.js";

export const protobufPackage = "google.ads.googleads.v16.resources";

/**
 * An account-level budget proposal.
 *
 * All fields prefixed with 'proposed' may not necessarily be applied directly.
 * For example, proposed spending limits may be adjusted before their
 * application.  This is true if the 'proposed' field has an 'approved'
 * counterpart, for example, spending limits.
 *
 * Note that the proposal type (proposal_type) changes which fields are
 * required and which must remain empty.
 */
export interface AccountBudgetProposal {
  /**
   * Immutable. The resource name of the proposal.
   * AccountBudgetProposal resource names have the form:
   *
   * `customers/{customer_id}/accountBudgetProposals/{account_budget_proposal_id}`
   */
  resourceName: string;
  /** Output only. The ID of the proposal. */
  id?:
    | Long
    | undefined;
  /**
   * Immutable. The resource name of the billing setup associated with this
   * proposal.
   */
  billingSetup?:
    | string
    | undefined;
  /**
   * Immutable. The resource name of the account-level budget associated with
   * this proposal.
   */
  accountBudget?:
    | string
    | undefined;
  /**
   * Immutable. The type of this proposal, for example, END to end the budget
   * associated with this proposal.
   */
  proposalType: AccountBudgetProposalTypeEnum_AccountBudgetProposalType;
  /**
   * Output only. The status of this proposal.
   * When a new proposal is created, the status defaults to PENDING.
   */
  status: AccountBudgetProposalStatusEnum_AccountBudgetProposalStatus;
  /** Immutable. The name to assign to the account-level budget. */
  proposedName?:
    | string
    | undefined;
  /** Output only. The approved start date time in yyyy-mm-dd hh:mm:ss format. */
  approvedStartDateTime?:
    | string
    | undefined;
  /**
   * Immutable. A purchase order number is a value that enables the user to help
   * them reference this budget in their monthly invoices.
   */
  proposedPurchaseOrderNumber?:
    | string
    | undefined;
  /** Immutable. Notes associated with this budget. */
  proposedNotes?:
    | string
    | undefined;
  /**
   * Output only. The date time when this account-level budget proposal was
   * created, which is not the same as its approval date time, if applicable.
   */
  creationDateTime?:
    | string
    | undefined;
  /**
   * Output only. The date time when this account-level budget was approved, if
   * applicable.
   */
  approvalDateTime?:
    | string
    | undefined;
  /** Immutable. The proposed start date time in yyyy-mm-dd hh:mm:ss format. */
  proposedStartDateTime?:
    | string
    | undefined;
  /**
   * Immutable. The proposed start date time as a well-defined type, for
   * example, NOW.
   */
  proposedStartTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /** Immutable. The proposed end date time in yyyy-mm-dd hh:mm:ss format. */
  proposedEndDateTime?:
    | string
    | undefined;
  /**
   * Immutable. The proposed end date time as a well-defined type, for
   * example, FOREVER.
   */
  proposedEndTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /** Output only. The approved end date time in yyyy-mm-dd hh:mm:ss format. */
  approvedEndDateTime?:
    | string
    | undefined;
  /**
   * Output only. The approved end date time as a well-defined type, for
   * example, FOREVER.
   */
  approvedEndTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /**
   * Immutable. The proposed spending limit in micros.  One million is
   * equivalent to one unit.
   */
  proposedSpendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Immutable. The proposed spending limit as a well-defined type, for
   * example, INFINITE.
   */
  proposedSpendingLimitType?:
    | SpendingLimitTypeEnum_SpendingLimitType
    | undefined;
  /**
   * Output only. The approved spending limit in micros.  One million is
   * equivalent to one unit.
   */
  approvedSpendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Output only. The approved spending limit as a well-defined type, for
   * example, INFINITE.
   */
  approvedSpendingLimitType?: SpendingLimitTypeEnum_SpendingLimitType | undefined;
}

function createBaseAccountBudgetProposal(): AccountBudgetProposal {
  return {
    resourceName: "",
    id: undefined,
    billingSetup: undefined,
    accountBudget: undefined,
    proposalType: 0,
    status: 0,
    proposedName: undefined,
    approvedStartDateTime: undefined,
    proposedPurchaseOrderNumber: undefined,
    proposedNotes: undefined,
    creationDateTime: undefined,
    approvalDateTime: undefined,
    proposedStartDateTime: undefined,
    proposedStartTimeType: undefined,
    proposedEndDateTime: undefined,
    proposedEndTimeType: undefined,
    approvedEndDateTime: undefined,
    approvedEndTimeType: undefined,
    proposedSpendingLimitMicros: undefined,
    proposedSpendingLimitType: undefined,
    approvedSpendingLimitMicros: undefined,
    approvedSpendingLimitType: undefined,
  };
}

export const AccountBudgetProposal: MessageFns<AccountBudgetProposal> = {
  encode(message: AccountBudgetProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.id !== undefined) {
      writer.uint32(200).int64(message.id.toString());
    }
    if (message.billingSetup !== undefined) {
      writer.uint32(210).string(message.billingSetup);
    }
    if (message.accountBudget !== undefined) {
      writer.uint32(218).string(message.accountBudget);
    }
    if (message.proposalType !== 0) {
      writer.uint32(32).int32(message.proposalType);
    }
    if (message.status !== 0) {
      writer.uint32(120).int32(message.status);
    }
    if (message.proposedName !== undefined) {
      writer.uint32(226).string(message.proposedName);
    }
    if (message.approvedStartDateTime !== undefined) {
      writer.uint32(242).string(message.approvedStartDateTime);
    }
    if (message.proposedPurchaseOrderNumber !== undefined) {
      writer.uint32(282).string(message.proposedPurchaseOrderNumber);
    }
    if (message.proposedNotes !== undefined) {
      writer.uint32(290).string(message.proposedNotes);
    }
    if (message.creationDateTime !== undefined) {
      writer.uint32(298).string(message.creationDateTime);
    }
    if (message.approvalDateTime !== undefined) {
      writer.uint32(306).string(message.approvalDateTime);
    }
    if (message.proposedStartDateTime !== undefined) {
      writer.uint32(234).string(message.proposedStartDateTime);
    }
    if (message.proposedStartTimeType !== undefined) {
      writer.uint32(56).int32(message.proposedStartTimeType);
    }
    if (message.proposedEndDateTime !== undefined) {
      writer.uint32(250).string(message.proposedEndDateTime);
    }
    if (message.proposedEndTimeType !== undefined) {
      writer.uint32(72).int32(message.proposedEndTimeType);
    }
    if (message.approvedEndDateTime !== undefined) {
      writer.uint32(258).string(message.approvedEndDateTime);
    }
    if (message.approvedEndTimeType !== undefined) {
      writer.uint32(176).int32(message.approvedEndTimeType);
    }
    if (message.proposedSpendingLimitMicros !== undefined) {
      writer.uint32(264).int64(message.proposedSpendingLimitMicros.toString());
    }
    if (message.proposedSpendingLimitType !== undefined) {
      writer.uint32(88).int32(message.proposedSpendingLimitType);
    }
    if (message.approvedSpendingLimitMicros !== undefined) {
      writer.uint32(272).int64(message.approvedSpendingLimitMicros.toString());
    }
    if (message.approvedSpendingLimitType !== undefined) {
      writer.uint32(192).int32(message.approvedSpendingLimitType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountBudgetProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountBudgetProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.billingSetup = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.accountBudget = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.proposalType = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.proposedName = reader.string();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.approvedStartDateTime = reader.string();
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.proposedPurchaseOrderNumber = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.proposedNotes = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.creationDateTime = reader.string();
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.approvalDateTime = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.proposedStartDateTime = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.proposedStartTimeType = reader.int32() as any;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.proposedEndDateTime = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.proposedEndTimeType = reader.int32() as any;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.approvedEndDateTime = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.approvedEndTimeType = reader.int32() as any;
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.proposedSpendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.proposedSpendingLimitType = reader.int32() as any;
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.approvedSpendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.approvedSpendingLimitType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountBudgetProposal {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : undefined,
      billingSetup: isSet(object.billingSetup) ? globalThis.String(object.billingSetup) : undefined,
      accountBudget: isSet(object.accountBudget) ? globalThis.String(object.accountBudget) : undefined,
      proposalType: isSet(object.proposalType)
        ? accountBudgetProposalTypeEnum_AccountBudgetProposalTypeFromJSON(object.proposalType)
        : 0,
      status: isSet(object.status)
        ? accountBudgetProposalStatusEnum_AccountBudgetProposalStatusFromJSON(object.status)
        : 0,
      proposedName: isSet(object.proposedName) ? globalThis.String(object.proposedName) : undefined,
      approvedStartDateTime: isSet(object.approvedStartDateTime)
        ? globalThis.String(object.approvedStartDateTime)
        : undefined,
      proposedPurchaseOrderNumber: isSet(object.proposedPurchaseOrderNumber)
        ? globalThis.String(object.proposedPurchaseOrderNumber)
        : undefined,
      proposedNotes: isSet(object.proposedNotes) ? globalThis.String(object.proposedNotes) : undefined,
      creationDateTime: isSet(object.creationDateTime) ? globalThis.String(object.creationDateTime) : undefined,
      approvalDateTime: isSet(object.approvalDateTime) ? globalThis.String(object.approvalDateTime) : undefined,
      proposedStartDateTime: isSet(object.proposedStartDateTime)
        ? globalThis.String(object.proposedStartDateTime)
        : undefined,
      proposedStartTimeType: isSet(object.proposedStartTimeType)
        ? timeTypeEnum_TimeTypeFromJSON(object.proposedStartTimeType)
        : undefined,
      proposedEndDateTime: isSet(object.proposedEndDateTime)
        ? globalThis.String(object.proposedEndDateTime)
        : undefined,
      proposedEndTimeType: isSet(object.proposedEndTimeType)
        ? timeTypeEnum_TimeTypeFromJSON(object.proposedEndTimeType)
        : undefined,
      approvedEndDateTime: isSet(object.approvedEndDateTime)
        ? globalThis.String(object.approvedEndDateTime)
        : undefined,
      approvedEndTimeType: isSet(object.approvedEndTimeType)
        ? timeTypeEnum_TimeTypeFromJSON(object.approvedEndTimeType)
        : undefined,
      proposedSpendingLimitMicros: isSet(object.proposedSpendingLimitMicros)
        ? Long.fromValue(object.proposedSpendingLimitMicros)
        : undefined,
      proposedSpendingLimitType: isSet(object.proposedSpendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.proposedSpendingLimitType)
        : undefined,
      approvedSpendingLimitMicros: isSet(object.approvedSpendingLimitMicros)
        ? Long.fromValue(object.approvedSpendingLimitMicros)
        : undefined,
      approvedSpendingLimitType: isSet(object.approvedSpendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.approvedSpendingLimitType)
        : undefined,
    };
  },

  toJSON(message: AccountBudgetProposal): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.id !== undefined) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.billingSetup !== undefined) {
      obj.billingSetup = message.billingSetup;
    }
    if (message.accountBudget !== undefined) {
      obj.accountBudget = message.accountBudget;
    }
    if (message.proposalType !== 0) {
      obj.proposalType = accountBudgetProposalTypeEnum_AccountBudgetProposalTypeToJSON(message.proposalType);
    }
    if (message.status !== 0) {
      obj.status = accountBudgetProposalStatusEnum_AccountBudgetProposalStatusToJSON(message.status);
    }
    if (message.proposedName !== undefined) {
      obj.proposedName = message.proposedName;
    }
    if (message.approvedStartDateTime !== undefined) {
      obj.approvedStartDateTime = message.approvedStartDateTime;
    }
    if (message.proposedPurchaseOrderNumber !== undefined) {
      obj.proposedPurchaseOrderNumber = message.proposedPurchaseOrderNumber;
    }
    if (message.proposedNotes !== undefined) {
      obj.proposedNotes = message.proposedNotes;
    }
    if (message.creationDateTime !== undefined) {
      obj.creationDateTime = message.creationDateTime;
    }
    if (message.approvalDateTime !== undefined) {
      obj.approvalDateTime = message.approvalDateTime;
    }
    if (message.proposedStartDateTime !== undefined) {
      obj.proposedStartDateTime = message.proposedStartDateTime;
    }
    if (message.proposedStartTimeType !== undefined) {
      obj.proposedStartTimeType = timeTypeEnum_TimeTypeToJSON(message.proposedStartTimeType);
    }
    if (message.proposedEndDateTime !== undefined) {
      obj.proposedEndDateTime = message.proposedEndDateTime;
    }
    if (message.proposedEndTimeType !== undefined) {
      obj.proposedEndTimeType = timeTypeEnum_TimeTypeToJSON(message.proposedEndTimeType);
    }
    if (message.approvedEndDateTime !== undefined) {
      obj.approvedEndDateTime = message.approvedEndDateTime;
    }
    if (message.approvedEndTimeType !== undefined) {
      obj.approvedEndTimeType = timeTypeEnum_TimeTypeToJSON(message.approvedEndTimeType);
    }
    if (message.proposedSpendingLimitMicros !== undefined) {
      obj.proposedSpendingLimitMicros = (message.proposedSpendingLimitMicros || Long.ZERO).toString();
    }
    if (message.proposedSpendingLimitType !== undefined) {
      obj.proposedSpendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.proposedSpendingLimitType);
    }
    if (message.approvedSpendingLimitMicros !== undefined) {
      obj.approvedSpendingLimitMicros = (message.approvedSpendingLimitMicros || Long.ZERO).toString();
    }
    if (message.approvedSpendingLimitType !== undefined) {
      obj.approvedSpendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.approvedSpendingLimitType);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountBudgetProposal>): AccountBudgetProposal {
    return AccountBudgetProposal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountBudgetProposal>): AccountBudgetProposal {
    const message = createBaseAccountBudgetProposal();
    message.resourceName = object.resourceName ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : undefined;
    message.billingSetup = object.billingSetup ?? undefined;
    message.accountBudget = object.accountBudget ?? undefined;
    message.proposalType = object.proposalType ?? 0;
    message.status = object.status ?? 0;
    message.proposedName = object.proposedName ?? undefined;
    message.approvedStartDateTime = object.approvedStartDateTime ?? undefined;
    message.proposedPurchaseOrderNumber = object.proposedPurchaseOrderNumber ?? undefined;
    message.proposedNotes = object.proposedNotes ?? undefined;
    message.creationDateTime = object.creationDateTime ?? undefined;
    message.approvalDateTime = object.approvalDateTime ?? undefined;
    message.proposedStartDateTime = object.proposedStartDateTime ?? undefined;
    message.proposedStartTimeType = object.proposedStartTimeType ?? undefined;
    message.proposedEndDateTime = object.proposedEndDateTime ?? undefined;
    message.proposedEndTimeType = object.proposedEndTimeType ?? undefined;
    message.approvedEndDateTime = object.approvedEndDateTime ?? undefined;
    message.approvedEndTimeType = object.approvedEndTimeType ?? undefined;
    message.proposedSpendingLimitMicros =
      (object.proposedSpendingLimitMicros !== undefined && object.proposedSpendingLimitMicros !== null)
        ? Long.fromValue(object.proposedSpendingLimitMicros)
        : undefined;
    message.proposedSpendingLimitType = object.proposedSpendingLimitType ?? undefined;
    message.approvedSpendingLimitMicros =
      (object.approvedSpendingLimitMicros !== undefined && object.approvedSpendingLimitMicros !== null)
        ? Long.fromValue(object.approvedSpendingLimitMicros)
        : undefined;
    message.approvedSpendingLimitType = object.approvedSpendingLimitType ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
