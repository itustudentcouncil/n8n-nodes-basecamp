// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/services/conversion_adjustment_upload_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Status } from "../../../../rpc/status.js";
import { UserIdentifier } from "../common/offline_user_data.js";
import {
  ConversionAdjustmentTypeEnum_ConversionAdjustmentType,
  conversionAdjustmentTypeEnum_ConversionAdjustmentTypeFromJSON,
  conversionAdjustmentTypeEnum_ConversionAdjustmentTypeToJSON,
} from "../enums/conversion_adjustment_type.js";

export const protobufPackage = "google.ads.googleads.v17.services";

/**
 * Request message for
 * [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v17.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
 */
export interface UploadConversionAdjustmentsRequest {
  /** Required. The ID of the customer performing the upload. */
  customerId: string;
  /** Required. The conversion adjustments that are being uploaded. */
  conversionAdjustments: ConversionAdjustment[];
  /**
   * Required. If true, successful operations will be carried out and invalid
   * operations will return errors. If false, all operations will be carried out
   * in one transaction if and only if they are all valid. This should always be
   * set to true.
   * See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailure: boolean;
  /**
   * If true, the request is validated but not executed. Only errors are
   * returned, not results.
   */
  validateOnly: boolean;
  /**
   * Optional. Optional input to set job ID. Must be a non-negative number that
   * is less than 2^31 if provided. If this field is not provided, the API will
   * generate a job ID in the range [2^31, (2^63)-1]. The API will return the
   * value for this request in the `job_id` field of the
   * `UploadConversionAdjustmentsResponse`.
   */
  jobId?: number | undefined;
}

/**
 * Response message for
 * [ConversionAdjustmentUploadService.UploadConversionAdjustments][google.ads.googleads.v17.services.ConversionAdjustmentUploadService.UploadConversionAdjustments].
 */
export interface UploadConversionAdjustmentsResponse {
  /**
   * Errors that pertain to conversion adjustment failures in the partial
   * failure mode. Returned when all errors occur inside the adjustments. If any
   * errors occur outside the adjustments (for example, auth errors), we return
   * an RPC level error. See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailureError:
    | Status
    | undefined;
  /**
   * Returned for successfully processed conversion adjustments. Proto will be
   * empty for rows that received an error. Results are not returned when
   * validate_only is true.
   */
  results: ConversionAdjustmentResult[];
  /** Job ID for the upload batch. */
  jobId: Long;
}

/** A conversion adjustment. */
export interface ConversionAdjustment {
  /**
   * For adjustments, uniquely identifies a conversion that was reported
   * without an order ID specified. If the adjustment_type is ENHANCEMENT, this
   * value is optional but may be set in addition to the order_id.
   */
  gclidDateTimePair:
    | GclidDateTimePair
    | undefined;
  /**
   * The order ID of the conversion to be adjusted. If the conversion was
   * reported with an order ID specified, that order ID must be used as the
   * identifier here. The order ID is required for enhancements.
   */
  orderId?:
    | string
    | undefined;
  /**
   * Resource name of the conversion action associated with this conversion
   * adjustment. Note: Although this resource name consists of a customer id and
   * a conversion action id, validation will ignore the customer id and use the
   * conversion action id as the sole identifier of the conversion action.
   */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the adjustment occurred. Must be after the
   * conversion_date_time. The timezone must be specified. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  adjustmentDateTime?:
    | string
    | undefined;
  /** The adjustment type. */
  adjustmentType: ConversionAdjustmentTypeEnum_ConversionAdjustmentType;
  /**
   * Information needed to restate the conversion's value.
   * Required for restatements. Should not be supplied for retractions. An error
   * will be returned if provided for a retraction.
   * NOTE: If you want to upload a second restatement with a different adjusted
   * value, it must have a new, more recent, adjustment occurrence time.
   * Otherwise, it will be treated as a duplicate of the previous restatement
   * and ignored.
   */
  restatementValue:
    | RestatementValue
    | undefined;
  /**
   * The user identifiers to enhance the original conversion.
   * ConversionAdjustmentUploadService only accepts user identifiers in
   * enhancements. The maximum number of user identifiers for each
   * enhancement is 5.
   */
  userIdentifiers: UserIdentifier[];
  /**
   * The user agent to enhance the original conversion. This can be found in
   * your user's HTTP request header when they convert on your web page.
   * Example, "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X)". User
   * agent can only be specified in enhancements with user identifiers. This
   * should match the user agent of the request that sent the original
   * conversion so the conversion and its enhancement are either both attributed
   * as same-device or both attributed as cross-device.
   */
  userAgent?: string | undefined;
}

/** Contains information needed to restate a conversion's value. */
export interface RestatementValue {
  /**
   * The restated conversion value. This is the value of the conversion after
   * restatement. For example, to change the value of a conversion from 100 to
   * 70, an adjusted value of 70 should be reported.
   * NOTE: If you want to upload a second restatement with a different adjusted
   * value, it must have a new, more recent, adjustment occurrence time.
   * Otherwise, it will be treated as a duplicate of the previous restatement
   * and ignored.
   */
  adjustedValue?:
    | number
    | undefined;
  /**
   * The currency of the restated value. If not provided, then the default
   * currency from the conversion action is used, and if that is not set then
   * the account currency is used. This is the ISO 4217 3-character currency
   * code for example, USD or EUR.
   */
  currencyCode?: string | undefined;
}

/**
 * Uniquely identifies a conversion that was reported without an order ID
 * specified.
 */
export interface GclidDateTimePair {
  /**
   * Google click ID (gclid) associated with the original conversion for this
   * adjustment.
   */
  gclid?:
    | string
    | undefined;
  /**
   * The date time at which the original conversion for this adjustment
   * occurred. The timezone must be specified. The format is "yyyy-mm-dd
   * hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  conversionDateTime?: string | undefined;
}

/** Information identifying a successfully processed ConversionAdjustment. */
export interface ConversionAdjustmentResult {
  /** The gclid and conversion date time of the conversion. */
  gclidDateTimePair:
    | GclidDateTimePair
    | undefined;
  /** The order ID of the conversion to be adjusted. */
  orderId: string;
  /**
   * Resource name of the conversion action associated with this conversion
   * adjustment.
   */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the adjustment occurred. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  adjustmentDateTime?:
    | string
    | undefined;
  /** The adjustment type. */
  adjustmentType: ConversionAdjustmentTypeEnum_ConversionAdjustmentType;
}

function createBaseUploadConversionAdjustmentsRequest(): UploadConversionAdjustmentsRequest {
  return { customerId: "", conversionAdjustments: [], partialFailure: false, validateOnly: false, jobId: undefined };
}

export const UploadConversionAdjustmentsRequest: MessageFns<UploadConversionAdjustmentsRequest> = {
  encode(message: UploadConversionAdjustmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.conversionAdjustments) {
      ConversionAdjustment.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.partialFailure !== false) {
      writer.uint32(24).bool(message.partialFailure);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.jobId !== undefined) {
      writer.uint32(40).int32(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadConversionAdjustmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadConversionAdjustmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversionAdjustments.push(ConversionAdjustment.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.partialFailure = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.jobId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadConversionAdjustmentsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      conversionAdjustments: globalThis.Array.isArray(object?.conversionAdjustments)
        ? object.conversionAdjustments.map((e: any) => ConversionAdjustment.fromJSON(e))
        : [],
      partialFailure: isSet(object.partialFailure) ? globalThis.Boolean(object.partialFailure) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      jobId: isSet(object.jobId) ? globalThis.Number(object.jobId) : undefined,
    };
  },

  toJSON(message: UploadConversionAdjustmentsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.conversionAdjustments?.length) {
      obj.conversionAdjustments = message.conversionAdjustments.map((e) => ConversionAdjustment.toJSON(e));
    }
    if (message.partialFailure !== false) {
      obj.partialFailure = message.partialFailure;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.jobId !== undefined) {
      obj.jobId = Math.round(message.jobId);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadConversionAdjustmentsRequest>): UploadConversionAdjustmentsRequest {
    return UploadConversionAdjustmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadConversionAdjustmentsRequest>): UploadConversionAdjustmentsRequest {
    const message = createBaseUploadConversionAdjustmentsRequest();
    message.customerId = object.customerId ?? "";
    message.conversionAdjustments = object.conversionAdjustments?.map((e) => ConversionAdjustment.fromPartial(e)) || [];
    message.partialFailure = object.partialFailure ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.jobId = object.jobId ?? undefined;
    return message;
  },
};

function createBaseUploadConversionAdjustmentsResponse(): UploadConversionAdjustmentsResponse {
  return { partialFailureError: undefined, results: [], jobId: Long.ZERO };
}

export const UploadConversionAdjustmentsResponse: MessageFns<UploadConversionAdjustmentsResponse> = {
  encode(message: UploadConversionAdjustmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partialFailureError !== undefined) {
      Status.encode(message.partialFailureError, writer.uint32(10).fork()).join();
    }
    for (const v of message.results) {
      ConversionAdjustmentResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (!message.jobId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.jobId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadConversionAdjustmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadConversionAdjustmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partialFailureError = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(ConversionAdjustmentResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.jobId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadConversionAdjustmentsResponse {
    return {
      partialFailureError: isSet(object.partialFailureError) ? Status.fromJSON(object.partialFailureError) : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ConversionAdjustmentResult.fromJSON(e))
        : [],
      jobId: isSet(object.jobId) ? Long.fromValue(object.jobId) : Long.ZERO,
    };
  },

  toJSON(message: UploadConversionAdjustmentsResponse): unknown {
    const obj: any = {};
    if (message.partialFailureError !== undefined) {
      obj.partialFailureError = Status.toJSON(message.partialFailureError);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ConversionAdjustmentResult.toJSON(e));
    }
    if (!message.jobId.equals(Long.ZERO)) {
      obj.jobId = (message.jobId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UploadConversionAdjustmentsResponse>): UploadConversionAdjustmentsResponse {
    return UploadConversionAdjustmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadConversionAdjustmentsResponse>): UploadConversionAdjustmentsResponse {
    const message = createBaseUploadConversionAdjustmentsResponse();
    message.partialFailureError = (object.partialFailureError !== undefined && object.partialFailureError !== null)
      ? Status.fromPartial(object.partialFailureError)
      : undefined;
    message.results = object.results?.map((e) => ConversionAdjustmentResult.fromPartial(e)) || [];
    message.jobId = (object.jobId !== undefined && object.jobId !== null) ? Long.fromValue(object.jobId) : Long.ZERO;
    return message;
  },
};

function createBaseConversionAdjustment(): ConversionAdjustment {
  return {
    gclidDateTimePair: undefined,
    orderId: undefined,
    conversionAction: undefined,
    adjustmentDateTime: undefined,
    adjustmentType: 0,
    restatementValue: undefined,
    userIdentifiers: [],
    userAgent: undefined,
  };
}

export const ConversionAdjustment: MessageFns<ConversionAdjustment> = {
  encode(message: ConversionAdjustment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclidDateTimePair !== undefined) {
      GclidDateTimePair.encode(message.gclidDateTimePair, writer.uint32(98).fork()).join();
    }
    if (message.orderId !== undefined) {
      writer.uint32(106).string(message.orderId);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(66).string(message.conversionAction);
    }
    if (message.adjustmentDateTime !== undefined) {
      writer.uint32(74).string(message.adjustmentDateTime);
    }
    if (message.adjustmentType !== 0) {
      writer.uint32(40).int32(message.adjustmentType);
    }
    if (message.restatementValue !== undefined) {
      RestatementValue.encode(message.restatementValue, writer.uint32(50).fork()).join();
    }
    for (const v of message.userIdentifiers) {
      UserIdentifier.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.userAgent !== undefined) {
      writer.uint32(90).string(message.userAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAdjustment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAdjustment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.gclidDateTimePair = GclidDateTimePair.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.adjustmentDateTime = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.adjustmentType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.restatementValue = RestatementValue.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.userIdentifiers.push(UserIdentifier.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.userAgent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAdjustment {
    return {
      gclidDateTimePair: isSet(object.gclidDateTimePair)
        ? GclidDateTimePair.fromJSON(object.gclidDateTimePair)
        : undefined,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : undefined,
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      adjustmentDateTime: isSet(object.adjustmentDateTime) ? globalThis.String(object.adjustmentDateTime) : undefined,
      adjustmentType: isSet(object.adjustmentType)
        ? conversionAdjustmentTypeEnum_ConversionAdjustmentTypeFromJSON(object.adjustmentType)
        : 0,
      restatementValue: isSet(object.restatementValue) ? RestatementValue.fromJSON(object.restatementValue) : undefined,
      userIdentifiers: globalThis.Array.isArray(object?.userIdentifiers)
        ? object.userIdentifiers.map((e: any) => UserIdentifier.fromJSON(e))
        : [],
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : undefined,
    };
  },

  toJSON(message: ConversionAdjustment): unknown {
    const obj: any = {};
    if (message.gclidDateTimePair !== undefined) {
      obj.gclidDateTimePair = GclidDateTimePair.toJSON(message.gclidDateTimePair);
    }
    if (message.orderId !== undefined) {
      obj.orderId = message.orderId;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.adjustmentDateTime !== undefined) {
      obj.adjustmentDateTime = message.adjustmentDateTime;
    }
    if (message.adjustmentType !== 0) {
      obj.adjustmentType = conversionAdjustmentTypeEnum_ConversionAdjustmentTypeToJSON(message.adjustmentType);
    }
    if (message.restatementValue !== undefined) {
      obj.restatementValue = RestatementValue.toJSON(message.restatementValue);
    }
    if (message.userIdentifiers?.length) {
      obj.userIdentifiers = message.userIdentifiers.map((e) => UserIdentifier.toJSON(e));
    }
    if (message.userAgent !== undefined) {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAdjustment>): ConversionAdjustment {
    return ConversionAdjustment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionAdjustment>): ConversionAdjustment {
    const message = createBaseConversionAdjustment();
    message.gclidDateTimePair = (object.gclidDateTimePair !== undefined && object.gclidDateTimePair !== null)
      ? GclidDateTimePair.fromPartial(object.gclidDateTimePair)
      : undefined;
    message.orderId = object.orderId ?? undefined;
    message.conversionAction = object.conversionAction ?? undefined;
    message.adjustmentDateTime = object.adjustmentDateTime ?? undefined;
    message.adjustmentType = object.adjustmentType ?? 0;
    message.restatementValue = (object.restatementValue !== undefined && object.restatementValue !== null)
      ? RestatementValue.fromPartial(object.restatementValue)
      : undefined;
    message.userIdentifiers = object.userIdentifiers?.map((e) => UserIdentifier.fromPartial(e)) || [];
    message.userAgent = object.userAgent ?? undefined;
    return message;
  },
};

function createBaseRestatementValue(): RestatementValue {
  return { adjustedValue: undefined, currencyCode: undefined };
}

export const RestatementValue: MessageFns<RestatementValue> = {
  encode(message: RestatementValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adjustedValue !== undefined) {
      writer.uint32(25).double(message.adjustedValue);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(34).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestatementValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestatementValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 25) {
            break;
          }

          message.adjustedValue = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestatementValue {
    return {
      adjustedValue: isSet(object.adjustedValue) ? globalThis.Number(object.adjustedValue) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
    };
  },

  toJSON(message: RestatementValue): unknown {
    const obj: any = {};
    if (message.adjustedValue !== undefined) {
      obj.adjustedValue = message.adjustedValue;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<RestatementValue>): RestatementValue {
    return RestatementValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestatementValue>): RestatementValue {
    const message = createBaseRestatementValue();
    message.adjustedValue = object.adjustedValue ?? undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    return message;
  },
};

function createBaseGclidDateTimePair(): GclidDateTimePair {
  return { gclid: undefined, conversionDateTime: undefined };
}

export const GclidDateTimePair: MessageFns<GclidDateTimePair> = {
  encode(message: GclidDateTimePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclid !== undefined) {
      writer.uint32(26).string(message.gclid);
    }
    if (message.conversionDateTime !== undefined) {
      writer.uint32(34).string(message.conversionDateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GclidDateTimePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGclidDateTimePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gclid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.conversionDateTime = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GclidDateTimePair {
    return {
      gclid: isSet(object.gclid) ? globalThis.String(object.gclid) : undefined,
      conversionDateTime: isSet(object.conversionDateTime) ? globalThis.String(object.conversionDateTime) : undefined,
    };
  },

  toJSON(message: GclidDateTimePair): unknown {
    const obj: any = {};
    if (message.gclid !== undefined) {
      obj.gclid = message.gclid;
    }
    if (message.conversionDateTime !== undefined) {
      obj.conversionDateTime = message.conversionDateTime;
    }
    return obj;
  },

  create(base?: DeepPartial<GclidDateTimePair>): GclidDateTimePair {
    return GclidDateTimePair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GclidDateTimePair>): GclidDateTimePair {
    const message = createBaseGclidDateTimePair();
    message.gclid = object.gclid ?? undefined;
    message.conversionDateTime = object.conversionDateTime ?? undefined;
    return message;
  },
};

function createBaseConversionAdjustmentResult(): ConversionAdjustmentResult {
  return {
    gclidDateTimePair: undefined,
    orderId: "",
    conversionAction: undefined,
    adjustmentDateTime: undefined,
    adjustmentType: 0,
  };
}

export const ConversionAdjustmentResult: MessageFns<ConversionAdjustmentResult> = {
  encode(message: ConversionAdjustmentResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclidDateTimePair !== undefined) {
      GclidDateTimePair.encode(message.gclidDateTimePair, writer.uint32(74).fork()).join();
    }
    if (message.orderId !== "") {
      writer.uint32(82).string(message.orderId);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(58).string(message.conversionAction);
    }
    if (message.adjustmentDateTime !== undefined) {
      writer.uint32(66).string(message.adjustmentDateTime);
    }
    if (message.adjustmentType !== 0) {
      writer.uint32(40).int32(message.adjustmentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAdjustmentResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAdjustmentResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gclidDateTimePair = GclidDateTimePair.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.adjustmentDateTime = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.adjustmentType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAdjustmentResult {
    return {
      gclidDateTimePair: isSet(object.gclidDateTimePair)
        ? GclidDateTimePair.fromJSON(object.gclidDateTimePair)
        : undefined,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      adjustmentDateTime: isSet(object.adjustmentDateTime) ? globalThis.String(object.adjustmentDateTime) : undefined,
      adjustmentType: isSet(object.adjustmentType)
        ? conversionAdjustmentTypeEnum_ConversionAdjustmentTypeFromJSON(object.adjustmentType)
        : 0,
    };
  },

  toJSON(message: ConversionAdjustmentResult): unknown {
    const obj: any = {};
    if (message.gclidDateTimePair !== undefined) {
      obj.gclidDateTimePair = GclidDateTimePair.toJSON(message.gclidDateTimePair);
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.adjustmentDateTime !== undefined) {
      obj.adjustmentDateTime = message.adjustmentDateTime;
    }
    if (message.adjustmentType !== 0) {
      obj.adjustmentType = conversionAdjustmentTypeEnum_ConversionAdjustmentTypeToJSON(message.adjustmentType);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAdjustmentResult>): ConversionAdjustmentResult {
    return ConversionAdjustmentResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionAdjustmentResult>): ConversionAdjustmentResult {
    const message = createBaseConversionAdjustmentResult();
    message.gclidDateTimePair = (object.gclidDateTimePair !== undefined && object.gclidDateTimePair !== null)
      ? GclidDateTimePair.fromPartial(object.gclidDateTimePair)
      : undefined;
    message.orderId = object.orderId ?? "";
    message.conversionAction = object.conversionAction ?? undefined;
    message.adjustmentDateTime = object.adjustmentDateTime ?? undefined;
    message.adjustmentType = object.adjustmentType ?? 0;
    return message;
  },
};

/** Service to upload conversion adjustments. */
export type ConversionAdjustmentUploadServiceDefinition = typeof ConversionAdjustmentUploadServiceDefinition;
export const ConversionAdjustmentUploadServiceDefinition = {
  name: "ConversionAdjustmentUploadService",
  fullName: "google.ads.googleads.v17.services.ConversionAdjustmentUploadService",
  methods: {
    /**
     * Processes the given conversion adjustments.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [PartialFailureError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    uploadConversionAdjustments: {
      name: "UploadConversionAdjustments",
      requestType: UploadConversionAdjustmentsRequest,
      requestStream: false,
      responseType: UploadConversionAdjustmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              50,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              95,
              97,
              100,
              106,
              117,
              115,
              116,
              109,
              101,
              110,
              116,
              115,
              44,
              112,
              97,
              114,
              116,
              105,
              97,
              108,
              95,
              102,
              97,
              105,
              108,
              117,
              114,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
              67,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              65,
              100,
              106,
              117,
              115,
              116,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConversionAdjustmentUploadServiceImplementation<CallContextExt = {}> {
  /**
   * Processes the given conversion adjustments.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadConversionAdjustments(
    request: UploadConversionAdjustmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadConversionAdjustmentsResponse>>;
}

export interface ConversionAdjustmentUploadServiceClient<CallOptionsExt = {}> {
  /**
   * Processes the given conversion adjustments.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadConversionAdjustments(
    request: DeepPartial<UploadConversionAdjustmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadConversionAdjustmentsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
