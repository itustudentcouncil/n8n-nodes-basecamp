// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/common/criteria.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  AgeRangeTypeEnum_AgeRangeType,
  ageRangeTypeEnum_AgeRangeTypeFromJSON,
  ageRangeTypeEnum_AgeRangeTypeToJSON,
} from "../enums/age_range_type.js";
import {
  AppPaymentModelTypeEnum_AppPaymentModelType,
  appPaymentModelTypeEnum_AppPaymentModelTypeFromJSON,
  appPaymentModelTypeEnum_AppPaymentModelTypeToJSON,
} from "../enums/app_payment_model_type.js";
import {
  BrandRequestRejectionReasonEnum_BrandRequestRejectionReason,
  brandRequestRejectionReasonEnum_BrandRequestRejectionReasonFromJSON,
  brandRequestRejectionReasonEnum_BrandRequestRejectionReasonToJSON,
} from "../enums/brand_request_rejection_reason.js";
import {
  BrandStateEnum_BrandState,
  brandStateEnum_BrandStateFromJSON,
  brandStateEnum_BrandStateToJSON,
} from "../enums/brand_state.js";
import {
  ContentLabelTypeEnum_ContentLabelType,
  contentLabelTypeEnum_ContentLabelTypeFromJSON,
  contentLabelTypeEnum_ContentLabelTypeToJSON,
} from "../enums/content_label_type.js";
import {
  DayOfWeekEnum_DayOfWeek,
  dayOfWeekEnum_DayOfWeekFromJSON,
  dayOfWeekEnum_DayOfWeekToJSON,
} from "../enums/day_of_week.js";
import { DeviceEnum_Device, deviceEnum_DeviceFromJSON, deviceEnum_DeviceToJSON } from "../enums/device.js";
import {
  GenderTypeEnum_GenderType,
  genderTypeEnum_GenderTypeFromJSON,
  genderTypeEnum_GenderTypeToJSON,
} from "../enums/gender_type.js";
import {
  HotelDateSelectionTypeEnum_HotelDateSelectionType,
  hotelDateSelectionTypeEnum_HotelDateSelectionTypeFromJSON,
  hotelDateSelectionTypeEnum_HotelDateSelectionTypeToJSON,
} from "../enums/hotel_date_selection_type.js";
import {
  IncomeRangeTypeEnum_IncomeRangeType,
  incomeRangeTypeEnum_IncomeRangeTypeFromJSON,
  incomeRangeTypeEnum_IncomeRangeTypeToJSON,
} from "../enums/income_range_type.js";
import {
  InteractionTypeEnum_InteractionType,
  interactionTypeEnum_InteractionTypeFromJSON,
  interactionTypeEnum_InteractionTypeToJSON,
} from "../enums/interaction_type.js";
import {
  KeywordMatchTypeEnum_KeywordMatchType,
  keywordMatchTypeEnum_KeywordMatchTypeFromJSON,
  keywordMatchTypeEnum_KeywordMatchTypeToJSON,
} from "../enums/keyword_match_type.js";
import {
  ListingGroupTypeEnum_ListingGroupType,
  listingGroupTypeEnum_ListingGroupTypeFromJSON,
  listingGroupTypeEnum_ListingGroupTypeToJSON,
} from "../enums/listing_group_type.js";
import {
  LocationGroupRadiusUnitsEnum_LocationGroupRadiusUnits,
  locationGroupRadiusUnitsEnum_LocationGroupRadiusUnitsFromJSON,
  locationGroupRadiusUnitsEnum_LocationGroupRadiusUnitsToJSON,
} from "../enums/location_group_radius_units.js";
import {
  MinuteOfHourEnum_MinuteOfHour,
  minuteOfHourEnum_MinuteOfHourFromJSON,
  minuteOfHourEnum_MinuteOfHourToJSON,
} from "../enums/minute_of_hour.js";
import {
  ParentalStatusTypeEnum_ParentalStatusType,
  parentalStatusTypeEnum_ParentalStatusTypeFromJSON,
  parentalStatusTypeEnum_ParentalStatusTypeToJSON,
} from "../enums/parental_status_type.js";
import {
  ProductCategoryLevelEnum_ProductCategoryLevel,
  productCategoryLevelEnum_ProductCategoryLevelFromJSON,
  productCategoryLevelEnum_ProductCategoryLevelToJSON,
} from "../enums/product_category_level.js";
import {
  ProductChannelEnum_ProductChannel,
  productChannelEnum_ProductChannelFromJSON,
  productChannelEnum_ProductChannelToJSON,
} from "../enums/product_channel.js";
import {
  ProductChannelExclusivityEnum_ProductChannelExclusivity,
  productChannelExclusivityEnum_ProductChannelExclusivityFromJSON,
  productChannelExclusivityEnum_ProductChannelExclusivityToJSON,
} from "../enums/product_channel_exclusivity.js";
import {
  ProductConditionEnum_ProductCondition,
  productConditionEnum_ProductConditionFromJSON,
  productConditionEnum_ProductConditionToJSON,
} from "../enums/product_condition.js";
import {
  ProductCustomAttributeIndexEnum_ProductCustomAttributeIndex,
  productCustomAttributeIndexEnum_ProductCustomAttributeIndexFromJSON,
  productCustomAttributeIndexEnum_ProductCustomAttributeIndexToJSON,
} from "../enums/product_custom_attribute_index.js";
import {
  ProductTypeLevelEnum_ProductTypeLevel,
  productTypeLevelEnum_ProductTypeLevelFromJSON,
  productTypeLevelEnum_ProductTypeLevelToJSON,
} from "../enums/product_type_level.js";
import {
  ProximityRadiusUnitsEnum_ProximityRadiusUnits,
  proximityRadiusUnitsEnum_ProximityRadiusUnitsFromJSON,
  proximityRadiusUnitsEnum_ProximityRadiusUnitsToJSON,
} from "../enums/proximity_radius_units.js";
import {
  WebpageConditionOperandEnum_WebpageConditionOperand,
  webpageConditionOperandEnum_WebpageConditionOperandFromJSON,
  webpageConditionOperandEnum_WebpageConditionOperandToJSON,
} from "../enums/webpage_condition_operand.js";
import {
  WebpageConditionOperatorEnum_WebpageConditionOperator,
  webpageConditionOperatorEnum_WebpageConditionOperatorFromJSON,
  webpageConditionOperatorEnum_WebpageConditionOperatorToJSON,
} from "../enums/webpage_condition_operator.js";

export const protobufPackage = "google.ads.googleads.v17.common";

/** A keyword criterion. */
export interface KeywordInfo {
  /** The text of the keyword (at most 80 characters and 10 words). */
  text?:
    | string
    | undefined;
  /** The match type of the keyword. */
  matchType: KeywordMatchTypeEnum_KeywordMatchType;
}

/**
 * A placement criterion. This can be used to modify bids for sites when
 * targeting the content network.
 */
export interface PlacementInfo {
  /**
   * URL of the placement.
   *
   * For example, "http://www.domain.com".
   */
  url?: string | undefined;
}

/**
 * A Negative Keyword List criterion. Represents a shared set
 * of negative keywords that can be excluded at the account-level.
 * Only one negative keyword list criterion can be attached per account.
 */
export interface NegativeKeywordListInfo {
  /** The NegativeKeywordListInfo shared set resource name. */
  sharedSet?: string | undefined;
}

/** A mobile app category criterion. */
export interface MobileAppCategoryInfo {
  /** The mobile app category constant resource name. */
  mobileAppCategoryConstant?: string | undefined;
}

/** A mobile application criterion. */
export interface MobileApplicationInfo {
  /**
   * A string that uniquely identifies a mobile application to Google Ads API.
   * The format of this string is "{platform}-{platform_native_id}", where
   * platform is "1" for iOS apps and "2" for Android apps, and where
   * platform_native_id is the mobile application identifier native to the
   * corresponding platform.
   * For iOS, this native identifier is the 9 digit string that appears at the
   * end of an App Store URL (for example, "476943146" for "Flood-It! 2" whose
   * App Store link is
   * "http://itunes.apple.com/us/app/flood-it!-2/id476943146"). For Android,
   * this native identifier is the application's package name (for example,
   * "com.labpixies.colordrips" for "Color Drips" given Google Play link
   * "https://play.google.com/store/apps/details?id=com.labpixies.colordrips").
   * A well formed app id for Google Ads API would thus be "1-476943146" for iOS
   * and "2-com.labpixies.colordrips" for Android.
   * This field is required and must be set in CREATE operations.
   */
  appId?:
    | string
    | undefined;
  /** Name of this mobile application. */
  name?: string | undefined;
}

/** A location criterion. */
export interface LocationInfo {
  /** The geo target constant resource name. */
  geoTargetConstant?: string | undefined;
}

/** A device criterion. */
export interface DeviceInfo {
  /** Type of the device. */
  type: DeviceEnum_Device;
}

/** A listing group criterion. */
export interface ListingGroupInfo {
  /** Type of the listing group. */
  type: ListingGroupTypeEnum_ListingGroupType;
  /**
   * Dimension value with which this listing group is refining its parent.
   * Undefined for the root group.
   */
  caseValue:
    | ListingDimensionInfo
    | undefined;
  /**
   * Resource name of ad group criterion which is the parent listing group
   * subdivision. Null for the root group.
   */
  parentAdGroupCriterion?:
    | string
    | undefined;
  /** The path of dimensions defining this listing group. */
  path?: ListingDimensionPath | undefined;
}

/** The path of dimensions defining a listing group. */
export interface ListingDimensionPath {
  /**
   * The complete path of dimensions through the listing group hierarchy, from
   * the root (excluding the root itself) to this listing group.
   */
  dimensions: ListingDimensionInfo[];
}

/** A listing scope criterion. */
export interface ListingScopeInfo {
  /** Scope of the campaign criterion. */
  dimensions: ListingDimensionInfo[];
}

/** Listing dimensions for listing group criterion. */
export interface ListingDimensionInfo {
  /** Advertiser-specific hotel ID. */
  hotelId?:
    | HotelIdInfo
    | undefined;
  /** Class of the hotel as a number of stars 1 to 5. */
  hotelClass?:
    | HotelClassInfo
    | undefined;
  /** Country or Region the hotel is located in. */
  hotelCountryRegion?:
    | HotelCountryRegionInfo
    | undefined;
  /** State the hotel is located in. */
  hotelState?:
    | HotelStateInfo
    | undefined;
  /** City the hotel is located in. */
  hotelCity?:
    | HotelCityInfo
    | undefined;
  /** Category of a product offer. */
  productCategory?:
    | ProductCategoryInfo
    | undefined;
  /** Brand of a product offer. */
  productBrand?:
    | ProductBrandInfo
    | undefined;
  /** Locality of a product offer. */
  productChannel?:
    | ProductChannelInfo
    | undefined;
  /** Availability of a product offer. */
  productChannelExclusivity?:
    | ProductChannelExclusivityInfo
    | undefined;
  /** Condition of a product offer. */
  productCondition?:
    | ProductConditionInfo
    | undefined;
  /** Custom attribute of a product offer. */
  productCustomAttribute?:
    | ProductCustomAttributeInfo
    | undefined;
  /** Item id of a product offer. */
  productItemId?:
    | ProductItemIdInfo
    | undefined;
  /** Type of a product offer. */
  productType?:
    | ProductTypeInfo
    | undefined;
  /**
   * Grouping of a product offer. This listing dimension is deprecated and it
   * is supported only in Display campaigns.
   */
  productGrouping?:
    | ProductGroupingInfo
    | undefined;
  /**
   * Labels of a product offer. This listing dimension is deprecated and it is
   * supported only in Display campaigns.
   */
  productLabels?:
    | ProductLabelsInfo
    | undefined;
  /**
   * Legacy condition of a product offer. This listing dimension is deprecated
   * and it is supported only in Display campaigns.
   */
  productLegacyCondition?:
    | ProductLegacyConditionInfo
    | undefined;
  /**
   * Full type of a product offer. This listing dimension is deprecated and it
   * is supported only in Display campaigns.
   */
  productTypeFull?:
    | ProductTypeFullInfo
    | undefined;
  /** Advertiser-specific activity ID. */
  activityId?:
    | ActivityIdInfo
    | undefined;
  /** Rating of the activity as a number 1 to 5, where 5 is the best. */
  activityRating?:
    | ActivityRatingInfo
    | undefined;
  /** The country where the travel activity is available. */
  activityCountry?:
    | ActivityCountryInfo
    | undefined;
  /** The state where the travel activity is available. */
  activityState?:
    | ActivityStateInfo
    | undefined;
  /** The city where the travel activity is available. */
  activityCity?:
    | ActivityCityInfo
    | undefined;
  /** Unknown dimension. Set when no other listing dimension is set. */
  unknownListingDimension?: UnknownListingDimensionInfo | undefined;
}

/** Advertiser-specific hotel ID. */
export interface HotelIdInfo {
  /** String value of the hotel ID. */
  value?: string | undefined;
}

/** Class of the hotel as a number of stars 1 to 5. */
export interface HotelClassInfo {
  /** Long value of the hotel class. */
  value?: Long | undefined;
}

/** Country or Region the hotel is located in. */
export interface HotelCountryRegionInfo {
  /** The Geo Target Constant resource name. */
  countryRegionCriterion?: string | undefined;
}

/** State the hotel is located in. */
export interface HotelStateInfo {
  /** The Geo Target Constant resource name. */
  stateCriterion?: string | undefined;
}

/** City the hotel is located in. */
export interface HotelCityInfo {
  /** The Geo Target Constant resource name. */
  cityCriterion?: string | undefined;
}

/** Category of a product offer. */
export interface ProductCategoryInfo {
  /**
   * ID of the product category.
   *
   * This ID is equivalent to the google_product_category ID as described in
   * this article: https://support.google.com/merchants/answer/6324436
   */
  categoryId?:
    | Long
    | undefined;
  /** Level of the product category. */
  level: ProductCategoryLevelEnum_ProductCategoryLevel;
}

/** Brand of the product. */
export interface ProductBrandInfo {
  /** String value of the product brand. */
  value?: string | undefined;
}

/** Locality of a product offer. */
export interface ProductChannelInfo {
  /** Value of the locality. */
  channel: ProductChannelEnum_ProductChannel;
}

/** Availability of a product offer. */
export interface ProductChannelExclusivityInfo {
  /** Value of the availability. */
  channelExclusivity: ProductChannelExclusivityEnum_ProductChannelExclusivity;
}

/** Condition of a product offer. */
export interface ProductConditionInfo {
  /** Value of the condition. */
  condition: ProductConditionEnum_ProductCondition;
}

/** Custom attribute of a product offer. */
export interface ProductCustomAttributeInfo {
  /** String value of the product custom attribute. */
  value?:
    | string
    | undefined;
  /** Indicates the index of the custom attribute. */
  index: ProductCustomAttributeIndexEnum_ProductCustomAttributeIndex;
}

/** Item id of a product offer. */
export interface ProductItemIdInfo {
  /** Value of the id. */
  value?: string | undefined;
}

/** Type of a product offer. */
export interface ProductTypeInfo {
  /** Value of the type. */
  value?:
    | string
    | undefined;
  /** Level of the type. */
  level: ProductTypeLevelEnum_ProductTypeLevel;
}

/**
 * Grouping of a product offer. This listing dimension is deprecated and it is
 * supported only in Display campaigns.
 */
export interface ProductGroupingInfo {
  /** String value of the product grouping. */
  value?: string | undefined;
}

/**
 * Labels of a product offer. This listing dimension is deprecated and it is
 * supported only in Display campaigns.
 */
export interface ProductLabelsInfo {
  /** String value of the product labels. */
  value?: string | undefined;
}

/**
 * Legacy condition of a product offer. This listing dimension is deprecated and
 * it is supported only in Display campaigns.
 */
export interface ProductLegacyConditionInfo {
  /** String value of the product legacy condition. */
  value?: string | undefined;
}

/**
 * Full type of a product offer. This listing dimension is deprecated and it is
 * supported only in Display campaigns.
 */
export interface ProductTypeFullInfo {
  /** String value of the product full type. */
  value?: string | undefined;
}

/** Unknown listing dimension. */
export interface UnknownListingDimensionInfo {
}

/** Criterion for hotel date selection (default dates versus user selected). */
export interface HotelDateSelectionTypeInfo {
  /** Type of the hotel date selection */
  type: HotelDateSelectionTypeEnum_HotelDateSelectionType;
}

/** Criterion for number of days prior to the stay the booking is being made. */
export interface HotelAdvanceBookingWindowInfo {
  /** Low end of the number of days prior to the stay. */
  minDays?:
    | Long
    | undefined;
  /** High end of the number of days prior to the stay. */
  maxDays?: Long | undefined;
}

/** Criterion for length of hotel stay in nights. */
export interface HotelLengthOfStayInfo {
  /** Low end of the number of nights in the stay. */
  minNights?:
    | Long
    | undefined;
  /** High end of the number of nights in the stay. */
  maxNights?: Long | undefined;
}

/** Criterion for a check-in date range. */
export interface HotelCheckInDateRangeInfo {
  /** Start date in the YYYY-MM-DD format. */
  startDate: string;
  /** End date in the YYYY-MM-DD format. */
  endDate: string;
}

/** Criterion for day of the week the booking is for. */
export interface HotelCheckInDayInfo {
  /** The day of the week. */
  dayOfWeek: DayOfWeekEnum_DayOfWeek;
}

/** Advertiser-specific activity ID. */
export interface ActivityIdInfo {
  /** String value of the activity ID. */
  value?: string | undefined;
}

/** Rating of the activity as a number 1 to 5, where 5 is the best. */
export interface ActivityRatingInfo {
  /** Long value of the activity rating. */
  value?: Long | undefined;
}

/** The country where the travel activity is available. */
export interface ActivityCountryInfo {
  /**
   * String value of the activity country. The Geo Target Constant resource
   * name.
   */
  value?: string | undefined;
}

/** The state where the travel activity is available. */
export interface ActivityStateInfo {
  /**
   * String value of the activity state. The Geo Target Constant resource
   * name.
   */
  value?: string | undefined;
}

/** The city where the travel activity is available. */
export interface ActivityCityInfo {
  /**
   * String value of the activity city. The Geo Target Constant resource
   * name.
   */
  value?: string | undefined;
}

/** Criterion for Interaction Type. */
export interface InteractionTypeInfo {
  /** The interaction type. */
  type: InteractionTypeEnum_InteractionType;
}

/**
 * Represents an AdSchedule criterion.
 *
 * AdSchedule is specified as the day of the week and a time interval
 * within which ads will be shown.
 *
 * No more than six AdSchedules can be added for the same day.
 */
export interface AdScheduleInfo {
  /**
   * Minutes after the start hour at which this schedule starts.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  startMinute: MinuteOfHourEnum_MinuteOfHour;
  /**
   * Minutes after the end hour at which this schedule ends. The schedule is
   * exclusive of the end minute.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  endMinute: MinuteOfHourEnum_MinuteOfHour;
  /**
   * Starting hour in 24 hour time.
   * This field must be between 0 and 23, inclusive.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  startHour?:
    | number
    | undefined;
  /**
   * Ending hour in 24 hour time; 24 signifies end of the day.
   * This field must be between 0 and 24, inclusive.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  endHour?:
    | number
    | undefined;
  /**
   * Day of the week the schedule applies to.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  dayOfWeek: DayOfWeekEnum_DayOfWeek;
}

/** An age range criterion. */
export interface AgeRangeInfo {
  /** Type of the age range. */
  type: AgeRangeTypeEnum_AgeRangeType;
}

/** A gender criterion. */
export interface GenderInfo {
  /** Type of the gender. */
  type: GenderTypeEnum_GenderType;
}

/** An income range criterion. */
export interface IncomeRangeInfo {
  /** Type of the income range. */
  type: IncomeRangeTypeEnum_IncomeRangeType;
}

/** A parental status criterion. */
export interface ParentalStatusInfo {
  /** Type of the parental status. */
  type: ParentalStatusTypeEnum_ParentalStatusType;
}

/** A YouTube Video criterion. */
export interface YouTubeVideoInfo {
  /** YouTube video id as it appears on the YouTube watch page. */
  videoId?: string | undefined;
}

/** A YouTube Channel criterion. */
export interface YouTubeChannelInfo {
  /** The YouTube uploader channel id or the channel code of a YouTube channel. */
  channelId?: string | undefined;
}

/**
 * A User List criterion. Represents a user list that is defined by the
 * advertiser to be targeted.
 */
export interface UserListInfo {
  /** The User List resource name. */
  userList?: string | undefined;
}

/**
 * A Proximity criterion. The geo point and radius determine what geographical
 * area is included. The address is a description of the geo point that does
 * not affect ad serving.
 *
 * There are two ways to create a proximity. First, by setting an address
 * and radius. The geo point will be automatically computed. Second, by
 * setting a geo point and radius. The address is an optional label that won't
 * be validated.
 */
export interface ProximityInfo {
  /** Latitude and longitude. */
  geoPoint:
    | GeoPointInfo
    | undefined;
  /** The radius of the proximity. */
  radius?:
    | number
    | undefined;
  /** The unit of measurement of the radius. Default is KILOMETERS. */
  radiusUnits: ProximityRadiusUnitsEnum_ProximityRadiusUnits;
  /** Full address. */
  address: AddressInfo | undefined;
}

/** Geo point for proximity criterion. */
export interface GeoPointInfo {
  /** Micro degrees for the longitude. */
  longitudeInMicroDegrees?:
    | number
    | undefined;
  /** Micro degrees for the latitude. */
  latitudeInMicroDegrees?: number | undefined;
}

/** Address for proximity criterion. */
export interface AddressInfo {
  /** Postal code. */
  postalCode?:
    | string
    | undefined;
  /** Province or state code. */
  provinceCode?:
    | string
    | undefined;
  /** Country code. */
  countryCode?:
    | string
    | undefined;
  /** Province or state name. */
  provinceName?:
    | string
    | undefined;
  /** Street address line 1. */
  streetAddress?:
    | string
    | undefined;
  /**
   * Street address line 2. This field is write-only. It is only used for
   * calculating the longitude and latitude of an address when geo_point is
   * empty.
   */
  streetAddress2?:
    | string
    | undefined;
  /** Name of the city. */
  cityName?: string | undefined;
}

/**
 * A topic criterion. Use topics to target or exclude placements in the
 * Google Display Network based on the category into which the placement falls
 * (for example, "Pets & Animals/Pets/Dogs").
 */
export interface TopicInfo {
  /** The Topic Constant resource name. */
  topicConstant?:
    | string
    | undefined;
  /**
   * The category to target or exclude. Each subsequent element in the array
   * describes a more specific sub-category. For example,
   * "Pets & Animals", "Pets", "Dogs" represents the "Pets & Animals/Pets/Dogs"
   * category.
   */
  path: string[];
}

/** A language criterion. */
export interface LanguageInfo {
  /** The language constant resource name. */
  languageConstant?: string | undefined;
}

/**
 * An IpBlock criterion used for IP exclusions. We allow:
 *  - IPv4 and IPv6 addresses
 *  - individual addresses (192.168.0.1)
 *  - masks for individual addresses (192.168.0.1/32)
 *  - masks for Class C networks (192.168.0.1/24)
 */
export interface IpBlockInfo {
  /** The IP address of this IP block. */
  ipAddress?: string | undefined;
}

/** Content Label for category exclusion. */
export interface ContentLabelInfo {
  /** Content label type, required for CREATE operations. */
  type: ContentLabelTypeEnum_ContentLabelType;
}

/** Represents a Carrier Criterion. */
export interface CarrierInfo {
  /** The Carrier constant resource name. */
  carrierConstant?: string | undefined;
}

/** Represents a particular interest-based topic to be targeted. */
export interface UserInterestInfo {
  /** The UserInterest resource name. */
  userInterestCategory?: string | undefined;
}

/** Represents a criterion for targeting webpages of an advertiser's website. */
export interface WebpageInfo {
  /**
   * The name of the criterion that is defined by this parameter. The name value
   * will be used for identifying, sorting and filtering criteria with this type
   * of parameters.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  criterionName?:
    | string
    | undefined;
  /**
   * Conditions, or logical expressions, for webpage targeting. The list of
   * webpage targeting conditions are and-ed together when evaluated
   * for targeting. An empty list of conditions indicates all pages of the
   * campaign's website are targeted.
   *
   * This field is required for CREATE operations and is prohibited on UPDATE
   * operations.
   */
  conditions: WebpageConditionInfo[];
  /**
   * Website criteria coverage percentage. This is the computed percentage
   * of website coverage based on the website target, negative website target
   * and negative keywords in the ad group and campaign. For instance, when
   * coverage returns as 1, it indicates it has 100% coverage. This field is
   * read-only.
   */
  coveragePercentage: number;
  /** List of sample urls that match the website target. This field is read-only. */
  sample: WebpageSampleInfo | undefined;
}

/** Logical expression for targeting webpages of an advertiser's website. */
export interface WebpageConditionInfo {
  /** Operand of webpage targeting condition. */
  operand: WebpageConditionOperandEnum_WebpageConditionOperand;
  /** Operator of webpage targeting condition. */
  operator: WebpageConditionOperatorEnum_WebpageConditionOperator;
  /** Argument of webpage targeting condition. */
  argument?: string | undefined;
}

/** List of sample urls that match the website target */
export interface WebpageSampleInfo {
  /** Webpage sample urls */
  sampleUrls: string[];
}

/** Represents an operating system version to be targeted. */
export interface OperatingSystemVersionInfo {
  /** The operating system version constant resource name. */
  operatingSystemVersionConstant?: string | undefined;
}

/** An app payment model criterion. */
export interface AppPaymentModelInfo {
  /** Type of the app payment model. */
  type: AppPaymentModelTypeEnum_AppPaymentModelType;
}

/** A mobile device criterion. */
export interface MobileDeviceInfo {
  /** The mobile device constant resource name. */
  mobileDeviceConstant?: string | undefined;
}

/**
 * A custom affinity criterion.
 * A criterion of this type is only targetable.
 */
export interface CustomAffinityInfo {
  /** The CustomInterest resource name. */
  customAffinity?: string | undefined;
}

/**
 * A custom intent criterion.
 * A criterion of this type is only targetable.
 */
export interface CustomIntentInfo {
  /** The CustomInterest resource name. */
  customIntent?: string | undefined;
}

/** A radius around a list of locations specified through a feed or assetSet. */
export interface LocationGroupInfo {
  /**
   * Feed specifying locations for targeting. Cannot be set with AssetSet
   * fields. This is required and must be set in CREATE operations.
   */
  feed?:
    | string
    | undefined;
  /**
   * Geo target constant(s) restricting the scope of the geographic area within
   * the feed. Currently only one geo target constant is allowed. Cannot be set
   * with AssetSet fields.
   */
  geoTargetConstants: string[];
  /**
   * Distance in units specifying the radius around targeted locations.
   * This is required and must be set in CREATE operations.
   */
  radius?:
    | Long
    | undefined;
  /**
   * Unit of the radius. Miles and meters are supported for geo target
   * constants. Milli miles and meters are supported for feed item sets and
   * asset sets. This is required and must be set in CREATE operations.
   */
  radiusUnits: LocationGroupRadiusUnitsEnum_LocationGroupRadiusUnits;
  /**
   * FeedItemSets whose FeedItems are targeted. If multiple IDs are specified,
   * then all items that appear in at least one set are targeted. This field
   * cannot be used with geo_target_constants. This is optional and can only be
   * set in CREATE operations. Cannot be set with AssetSet fields.
   */
  feedItemSets: string[];
  /**
   * Denotes that the latest customer level asset set is used for targeting.
   * Used with radius and radius_units. Cannot be used with
   * feed, geo target constants or feed item sets. When using asset sets, either
   * this field or location_group_asset_sets should be specified. Both cannot be
   * used at the same time. This can only be set in CREATE operations.
   */
  enableCustomerLevelLocationAssetSet?:
    | boolean
    | undefined;
  /**
   * AssetSets whose Assets are targeted. If multiple IDs are specified, then
   * all items that appear in at least one set are targeted. This field cannot
   * be used with feed, geo target constants or feed item sets. When using asset
   * sets, either this field or enable_customer_level_location_asset_set should
   * be specified. Both cannot be used at the same time. This can only be set
   * in CREATE operations.
   */
  locationGroupAssetSets: string[];
}

/** A custom audience criterion. */
export interface CustomAudienceInfo {
  /** The CustomAudience resource name. */
  customAudience: string;
}

/** A combined audience criterion. */
export interface CombinedAudienceInfo {
  /** The CombinedAudience resource name. */
  combinedAudience: string;
}

/** An audience criterion. */
export interface AudienceInfo {
  /** The Audience resource name. */
  audience: string;
}

/** A Smart Campaign keyword theme. */
export interface KeywordThemeInfo {
  /**
   * The resource name of a Smart Campaign keyword theme constant.
   * `keywordThemeConstants/{keyword_theme_id}~{sub_keyword_theme_id}`
   */
  keywordThemeConstant?:
    | string
    | undefined;
  /**
   * Free-form text to be matched to a Smart Campaign keyword theme constant
   * on a best-effort basis.
   */
  freeFormKeywordTheme?: string | undefined;
}

/**
 * A Local Services Ads service ID. Represents a service type
 * (such as install_faucet) that a Local Services Campaign can target.
 */
export interface LocalServiceIdInfo {
  /** The criterion resource name. */
  serviceId: string;
}

/**
 * A Search Theme criterion only on Performance Max campaign. Represents a
 * keyword-like advertiser input.
 */
export interface SearchThemeInfo {
  /**
   * Each Search Theme has a value of a simple string, like keywords.
   * There are limits on overall length, allowed characters, and number
   * of words.
   */
  text: string;
}

/**
 * Represents a Brand Criterion used for targeting based on commercial knowledge
 * graph.
 */
export interface BrandInfo {
  /** Output only. A text representation of a brand. */
  displayName?:
    | string
    | undefined;
  /** The Commercial KG MID for the brand. */
  entityId?:
    | string
    | undefined;
  /** Output only. The primary url of a brand. */
  primaryUrl?:
    | string
    | undefined;
  /** Output only. The rejection reason when a brand status is REJECTED. */
  rejectionReason?:
    | BrandRequestRejectionReasonEnum_BrandRequestRejectionReason
    | undefined;
  /** Output only. The status of a brand. */
  status?: BrandStateEnum_BrandState | undefined;
}

/**
 * A Brand List Criterion is used to specify a list of brands.  The list is
 * represented as a SharedSet id type BRAND_HINT. A criterion of this type can
 * be either targeted or excluded.
 */
export interface BrandListInfo {
  /** Shared set resource name of the brand list. */
  sharedSet?: string | undefined;
}

function createBaseKeywordInfo(): KeywordInfo {
  return { text: undefined, matchType: 0 };
}

export const KeywordInfo: MessageFns<KeywordInfo> = {
  encode(message: KeywordInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(26).string(message.text);
    }
    if (message.matchType !== 0) {
      writer.uint32(16).int32(message.matchType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordInfo {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      matchType: isSet(object.matchType) ? keywordMatchTypeEnum_KeywordMatchTypeFromJSON(object.matchType) : 0,
    };
  },

  toJSON(message: KeywordInfo): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.matchType !== 0) {
      obj.matchType = keywordMatchTypeEnum_KeywordMatchTypeToJSON(message.matchType);
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordInfo>): KeywordInfo {
    return KeywordInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordInfo>): KeywordInfo {
    const message = createBaseKeywordInfo();
    message.text = object.text ?? undefined;
    message.matchType = object.matchType ?? 0;
    return message;
  },
};

function createBasePlacementInfo(): PlacementInfo {
  return { url: undefined };
}

export const PlacementInfo: MessageFns<PlacementInfo> = {
  encode(message: PlacementInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlacementInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlacementInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlacementInfo {
    return { url: isSet(object.url) ? globalThis.String(object.url) : undefined };
  },

  toJSON(message: PlacementInfo): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<PlacementInfo>): PlacementInfo {
    return PlacementInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlacementInfo>): PlacementInfo {
    const message = createBasePlacementInfo();
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseNegativeKeywordListInfo(): NegativeKeywordListInfo {
  return { sharedSet: undefined };
}

export const NegativeKeywordListInfo: MessageFns<NegativeKeywordListInfo> = {
  encode(message: NegativeKeywordListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sharedSet !== undefined) {
      writer.uint32(10).string(message.sharedSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NegativeKeywordListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNegativeKeywordListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sharedSet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NegativeKeywordListInfo {
    return { sharedSet: isSet(object.sharedSet) ? globalThis.String(object.sharedSet) : undefined };
  },

  toJSON(message: NegativeKeywordListInfo): unknown {
    const obj: any = {};
    if (message.sharedSet !== undefined) {
      obj.sharedSet = message.sharedSet;
    }
    return obj;
  },

  create(base?: DeepPartial<NegativeKeywordListInfo>): NegativeKeywordListInfo {
    return NegativeKeywordListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NegativeKeywordListInfo>): NegativeKeywordListInfo {
    const message = createBaseNegativeKeywordListInfo();
    message.sharedSet = object.sharedSet ?? undefined;
    return message;
  },
};

function createBaseMobileAppCategoryInfo(): MobileAppCategoryInfo {
  return { mobileAppCategoryConstant: undefined };
}

export const MobileAppCategoryInfo: MessageFns<MobileAppCategoryInfo> = {
  encode(message: MobileAppCategoryInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mobileAppCategoryConstant !== undefined) {
      writer.uint32(18).string(message.mobileAppCategoryConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileAppCategoryInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileAppCategoryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mobileAppCategoryConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileAppCategoryInfo {
    return {
      mobileAppCategoryConstant: isSet(object.mobileAppCategoryConstant)
        ? globalThis.String(object.mobileAppCategoryConstant)
        : undefined,
    };
  },

  toJSON(message: MobileAppCategoryInfo): unknown {
    const obj: any = {};
    if (message.mobileAppCategoryConstant !== undefined) {
      obj.mobileAppCategoryConstant = message.mobileAppCategoryConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<MobileAppCategoryInfo>): MobileAppCategoryInfo {
    return MobileAppCategoryInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileAppCategoryInfo>): MobileAppCategoryInfo {
    const message = createBaseMobileAppCategoryInfo();
    message.mobileAppCategoryConstant = object.mobileAppCategoryConstant ?? undefined;
    return message;
  },
};

function createBaseMobileApplicationInfo(): MobileApplicationInfo {
  return { appId: undefined, name: undefined };
}

export const MobileApplicationInfo: MessageFns<MobileApplicationInfo> = {
  encode(message: MobileApplicationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== undefined) {
      writer.uint32(34).string(message.appId);
    }
    if (message.name !== undefined) {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileApplicationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileApplicationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileApplicationInfo {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: MobileApplicationInfo): unknown {
    const obj: any = {};
    if (message.appId !== undefined) {
      obj.appId = message.appId;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<MobileApplicationInfo>): MobileApplicationInfo {
    return MobileApplicationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileApplicationInfo>): MobileApplicationInfo {
    const message = createBaseMobileApplicationInfo();
    message.appId = object.appId ?? undefined;
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseLocationInfo(): LocationInfo {
  return { geoTargetConstant: undefined };
}

export const LocationInfo: MessageFns<LocationInfo> = {
  encode(message: LocationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geoTargetConstant !== undefined) {
      writer.uint32(18).string(message.geoTargetConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.geoTargetConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationInfo {
    return {
      geoTargetConstant: isSet(object.geoTargetConstant) ? globalThis.String(object.geoTargetConstant) : undefined,
    };
  },

  toJSON(message: LocationInfo): unknown {
    const obj: any = {};
    if (message.geoTargetConstant !== undefined) {
      obj.geoTargetConstant = message.geoTargetConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationInfo>): LocationInfo {
    return LocationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationInfo>): LocationInfo {
    const message = createBaseLocationInfo();
    message.geoTargetConstant = object.geoTargetConstant ?? undefined;
    return message;
  },
};

function createBaseDeviceInfo(): DeviceInfo {
  return { type: 0 };
}

export const DeviceInfo: MessageFns<DeviceInfo> = {
  encode(message: DeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceInfo {
    return { type: isSet(object.type) ? deviceEnum_DeviceFromJSON(object.type) : 0 };
  },

  toJSON(message: DeviceInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = deviceEnum_DeviceToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceInfo>): DeviceInfo {
    return DeviceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceInfo>): DeviceInfo {
    const message = createBaseDeviceInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseListingGroupInfo(): ListingGroupInfo {
  return { type: 0, caseValue: undefined, parentAdGroupCriterion: undefined, path: undefined };
}

export const ListingGroupInfo: MessageFns<ListingGroupInfo> = {
  encode(message: ListingGroupInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.caseValue !== undefined) {
      ListingDimensionInfo.encode(message.caseValue, writer.uint32(18).fork()).join();
    }
    if (message.parentAdGroupCriterion !== undefined) {
      writer.uint32(34).string(message.parentAdGroupCriterion);
    }
    if (message.path !== undefined) {
      ListingDimensionPath.encode(message.path, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListingGroupInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListingGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.caseValue = ListingDimensionInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parentAdGroupCriterion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.path = ListingDimensionPath.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListingGroupInfo {
    return {
      type: isSet(object.type) ? listingGroupTypeEnum_ListingGroupTypeFromJSON(object.type) : 0,
      caseValue: isSet(object.caseValue) ? ListingDimensionInfo.fromJSON(object.caseValue) : undefined,
      parentAdGroupCriterion: isSet(object.parentAdGroupCriterion)
        ? globalThis.String(object.parentAdGroupCriterion)
        : undefined,
      path: isSet(object.path) ? ListingDimensionPath.fromJSON(object.path) : undefined,
    };
  },

  toJSON(message: ListingGroupInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = listingGroupTypeEnum_ListingGroupTypeToJSON(message.type);
    }
    if (message.caseValue !== undefined) {
      obj.caseValue = ListingDimensionInfo.toJSON(message.caseValue);
    }
    if (message.parentAdGroupCriterion !== undefined) {
      obj.parentAdGroupCriterion = message.parentAdGroupCriterion;
    }
    if (message.path !== undefined) {
      obj.path = ListingDimensionPath.toJSON(message.path);
    }
    return obj;
  },

  create(base?: DeepPartial<ListingGroupInfo>): ListingGroupInfo {
    return ListingGroupInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListingGroupInfo>): ListingGroupInfo {
    const message = createBaseListingGroupInfo();
    message.type = object.type ?? 0;
    message.caseValue = (object.caseValue !== undefined && object.caseValue !== null)
      ? ListingDimensionInfo.fromPartial(object.caseValue)
      : undefined;
    message.parentAdGroupCriterion = object.parentAdGroupCriterion ?? undefined;
    message.path = (object.path !== undefined && object.path !== null)
      ? ListingDimensionPath.fromPartial(object.path)
      : undefined;
    return message;
  },
};

function createBaseListingDimensionPath(): ListingDimensionPath {
  return { dimensions: [] };
}

export const ListingDimensionPath: MessageFns<ListingDimensionPath> = {
  encode(message: ListingDimensionPath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensions) {
      ListingDimensionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListingDimensionPath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListingDimensionPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensions.push(ListingDimensionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListingDimensionPath {
    return {
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => ListingDimensionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListingDimensionPath): unknown {
    const obj: any = {};
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => ListingDimensionInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListingDimensionPath>): ListingDimensionPath {
    return ListingDimensionPath.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListingDimensionPath>): ListingDimensionPath {
    const message = createBaseListingDimensionPath();
    message.dimensions = object.dimensions?.map((e) => ListingDimensionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListingScopeInfo(): ListingScopeInfo {
  return { dimensions: [] };
}

export const ListingScopeInfo: MessageFns<ListingScopeInfo> = {
  encode(message: ListingScopeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensions) {
      ListingDimensionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListingScopeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListingScopeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(ListingDimensionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListingScopeInfo {
    return {
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => ListingDimensionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListingScopeInfo): unknown {
    const obj: any = {};
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => ListingDimensionInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListingScopeInfo>): ListingScopeInfo {
    return ListingScopeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListingScopeInfo>): ListingScopeInfo {
    const message = createBaseListingScopeInfo();
    message.dimensions = object.dimensions?.map((e) => ListingDimensionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListingDimensionInfo(): ListingDimensionInfo {
  return {
    hotelId: undefined,
    hotelClass: undefined,
    hotelCountryRegion: undefined,
    hotelState: undefined,
    hotelCity: undefined,
    productCategory: undefined,
    productBrand: undefined,
    productChannel: undefined,
    productChannelExclusivity: undefined,
    productCondition: undefined,
    productCustomAttribute: undefined,
    productItemId: undefined,
    productType: undefined,
    productGrouping: undefined,
    productLabels: undefined,
    productLegacyCondition: undefined,
    productTypeFull: undefined,
    activityId: undefined,
    activityRating: undefined,
    activityCountry: undefined,
    activityState: undefined,
    activityCity: undefined,
    unknownListingDimension: undefined,
  };
}

export const ListingDimensionInfo: MessageFns<ListingDimensionInfo> = {
  encode(message: ListingDimensionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hotelId !== undefined) {
      HotelIdInfo.encode(message.hotelId, writer.uint32(18).fork()).join();
    }
    if (message.hotelClass !== undefined) {
      HotelClassInfo.encode(message.hotelClass, writer.uint32(26).fork()).join();
    }
    if (message.hotelCountryRegion !== undefined) {
      HotelCountryRegionInfo.encode(message.hotelCountryRegion, writer.uint32(34).fork()).join();
    }
    if (message.hotelState !== undefined) {
      HotelStateInfo.encode(message.hotelState, writer.uint32(42).fork()).join();
    }
    if (message.hotelCity !== undefined) {
      HotelCityInfo.encode(message.hotelCity, writer.uint32(50).fork()).join();
    }
    if (message.productCategory !== undefined) {
      ProductCategoryInfo.encode(message.productCategory, writer.uint32(194).fork()).join();
    }
    if (message.productBrand !== undefined) {
      ProductBrandInfo.encode(message.productBrand, writer.uint32(122).fork()).join();
    }
    if (message.productChannel !== undefined) {
      ProductChannelInfo.encode(message.productChannel, writer.uint32(66).fork()).join();
    }
    if (message.productChannelExclusivity !== undefined) {
      ProductChannelExclusivityInfo.encode(message.productChannelExclusivity, writer.uint32(74).fork()).join();
    }
    if (message.productCondition !== undefined) {
      ProductConditionInfo.encode(message.productCondition, writer.uint32(82).fork()).join();
    }
    if (message.productCustomAttribute !== undefined) {
      ProductCustomAttributeInfo.encode(message.productCustomAttribute, writer.uint32(130).fork()).join();
    }
    if (message.productItemId !== undefined) {
      ProductItemIdInfo.encode(message.productItemId, writer.uint32(90).fork()).join();
    }
    if (message.productType !== undefined) {
      ProductTypeInfo.encode(message.productType, writer.uint32(98).fork()).join();
    }
    if (message.productGrouping !== undefined) {
      ProductGroupingInfo.encode(message.productGrouping, writer.uint32(138).fork()).join();
    }
    if (message.productLabels !== undefined) {
      ProductLabelsInfo.encode(message.productLabels, writer.uint32(146).fork()).join();
    }
    if (message.productLegacyCondition !== undefined) {
      ProductLegacyConditionInfo.encode(message.productLegacyCondition, writer.uint32(154).fork()).join();
    }
    if (message.productTypeFull !== undefined) {
      ProductTypeFullInfo.encode(message.productTypeFull, writer.uint32(162).fork()).join();
    }
    if (message.activityId !== undefined) {
      ActivityIdInfo.encode(message.activityId, writer.uint32(170).fork()).join();
    }
    if (message.activityRating !== undefined) {
      ActivityRatingInfo.encode(message.activityRating, writer.uint32(178).fork()).join();
    }
    if (message.activityCountry !== undefined) {
      ActivityCountryInfo.encode(message.activityCountry, writer.uint32(186).fork()).join();
    }
    if (message.activityState !== undefined) {
      ActivityStateInfo.encode(message.activityState, writer.uint32(202).fork()).join();
    }
    if (message.activityCity !== undefined) {
      ActivityCityInfo.encode(message.activityCity, writer.uint32(210).fork()).join();
    }
    if (message.unknownListingDimension !== undefined) {
      UnknownListingDimensionInfo.encode(message.unknownListingDimension, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListingDimensionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListingDimensionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hotelId = HotelIdInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hotelClass = HotelClassInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hotelCountryRegion = HotelCountryRegionInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hotelState = HotelStateInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hotelCity = HotelCityInfo.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.productCategory = ProductCategoryInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.productBrand = ProductBrandInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.productChannel = ProductChannelInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.productChannelExclusivity = ProductChannelExclusivityInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.productCondition = ProductConditionInfo.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.productCustomAttribute = ProductCustomAttributeInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.productItemId = ProductItemIdInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.productType = ProductTypeInfo.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.productGrouping = ProductGroupingInfo.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.productLabels = ProductLabelsInfo.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.productLegacyCondition = ProductLegacyConditionInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.productTypeFull = ProductTypeFullInfo.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.activityId = ActivityIdInfo.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.activityRating = ActivityRatingInfo.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.activityCountry = ActivityCountryInfo.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.activityState = ActivityStateInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.activityCity = ActivityCityInfo.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.unknownListingDimension = UnknownListingDimensionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListingDimensionInfo {
    return {
      hotelId: isSet(object.hotelId) ? HotelIdInfo.fromJSON(object.hotelId) : undefined,
      hotelClass: isSet(object.hotelClass) ? HotelClassInfo.fromJSON(object.hotelClass) : undefined,
      hotelCountryRegion: isSet(object.hotelCountryRegion)
        ? HotelCountryRegionInfo.fromJSON(object.hotelCountryRegion)
        : undefined,
      hotelState: isSet(object.hotelState) ? HotelStateInfo.fromJSON(object.hotelState) : undefined,
      hotelCity: isSet(object.hotelCity) ? HotelCityInfo.fromJSON(object.hotelCity) : undefined,
      productCategory: isSet(object.productCategory) ? ProductCategoryInfo.fromJSON(object.productCategory) : undefined,
      productBrand: isSet(object.productBrand) ? ProductBrandInfo.fromJSON(object.productBrand) : undefined,
      productChannel: isSet(object.productChannel) ? ProductChannelInfo.fromJSON(object.productChannel) : undefined,
      productChannelExclusivity: isSet(object.productChannelExclusivity)
        ? ProductChannelExclusivityInfo.fromJSON(object.productChannelExclusivity)
        : undefined,
      productCondition: isSet(object.productCondition)
        ? ProductConditionInfo.fromJSON(object.productCondition)
        : undefined,
      productCustomAttribute: isSet(object.productCustomAttribute)
        ? ProductCustomAttributeInfo.fromJSON(object.productCustomAttribute)
        : undefined,
      productItemId: isSet(object.productItemId) ? ProductItemIdInfo.fromJSON(object.productItemId) : undefined,
      productType: isSet(object.productType) ? ProductTypeInfo.fromJSON(object.productType) : undefined,
      productGrouping: isSet(object.productGrouping) ? ProductGroupingInfo.fromJSON(object.productGrouping) : undefined,
      productLabels: isSet(object.productLabels) ? ProductLabelsInfo.fromJSON(object.productLabels) : undefined,
      productLegacyCondition: isSet(object.productLegacyCondition)
        ? ProductLegacyConditionInfo.fromJSON(object.productLegacyCondition)
        : undefined,
      productTypeFull: isSet(object.productTypeFull) ? ProductTypeFullInfo.fromJSON(object.productTypeFull) : undefined,
      activityId: isSet(object.activityId) ? ActivityIdInfo.fromJSON(object.activityId) : undefined,
      activityRating: isSet(object.activityRating) ? ActivityRatingInfo.fromJSON(object.activityRating) : undefined,
      activityCountry: isSet(object.activityCountry) ? ActivityCountryInfo.fromJSON(object.activityCountry) : undefined,
      activityState: isSet(object.activityState) ? ActivityStateInfo.fromJSON(object.activityState) : undefined,
      activityCity: isSet(object.activityCity) ? ActivityCityInfo.fromJSON(object.activityCity) : undefined,
      unknownListingDimension: isSet(object.unknownListingDimension)
        ? UnknownListingDimensionInfo.fromJSON(object.unknownListingDimension)
        : undefined,
    };
  },

  toJSON(message: ListingDimensionInfo): unknown {
    const obj: any = {};
    if (message.hotelId !== undefined) {
      obj.hotelId = HotelIdInfo.toJSON(message.hotelId);
    }
    if (message.hotelClass !== undefined) {
      obj.hotelClass = HotelClassInfo.toJSON(message.hotelClass);
    }
    if (message.hotelCountryRegion !== undefined) {
      obj.hotelCountryRegion = HotelCountryRegionInfo.toJSON(message.hotelCountryRegion);
    }
    if (message.hotelState !== undefined) {
      obj.hotelState = HotelStateInfo.toJSON(message.hotelState);
    }
    if (message.hotelCity !== undefined) {
      obj.hotelCity = HotelCityInfo.toJSON(message.hotelCity);
    }
    if (message.productCategory !== undefined) {
      obj.productCategory = ProductCategoryInfo.toJSON(message.productCategory);
    }
    if (message.productBrand !== undefined) {
      obj.productBrand = ProductBrandInfo.toJSON(message.productBrand);
    }
    if (message.productChannel !== undefined) {
      obj.productChannel = ProductChannelInfo.toJSON(message.productChannel);
    }
    if (message.productChannelExclusivity !== undefined) {
      obj.productChannelExclusivity = ProductChannelExclusivityInfo.toJSON(message.productChannelExclusivity);
    }
    if (message.productCondition !== undefined) {
      obj.productCondition = ProductConditionInfo.toJSON(message.productCondition);
    }
    if (message.productCustomAttribute !== undefined) {
      obj.productCustomAttribute = ProductCustomAttributeInfo.toJSON(message.productCustomAttribute);
    }
    if (message.productItemId !== undefined) {
      obj.productItemId = ProductItemIdInfo.toJSON(message.productItemId);
    }
    if (message.productType !== undefined) {
      obj.productType = ProductTypeInfo.toJSON(message.productType);
    }
    if (message.productGrouping !== undefined) {
      obj.productGrouping = ProductGroupingInfo.toJSON(message.productGrouping);
    }
    if (message.productLabels !== undefined) {
      obj.productLabels = ProductLabelsInfo.toJSON(message.productLabels);
    }
    if (message.productLegacyCondition !== undefined) {
      obj.productLegacyCondition = ProductLegacyConditionInfo.toJSON(message.productLegacyCondition);
    }
    if (message.productTypeFull !== undefined) {
      obj.productTypeFull = ProductTypeFullInfo.toJSON(message.productTypeFull);
    }
    if (message.activityId !== undefined) {
      obj.activityId = ActivityIdInfo.toJSON(message.activityId);
    }
    if (message.activityRating !== undefined) {
      obj.activityRating = ActivityRatingInfo.toJSON(message.activityRating);
    }
    if (message.activityCountry !== undefined) {
      obj.activityCountry = ActivityCountryInfo.toJSON(message.activityCountry);
    }
    if (message.activityState !== undefined) {
      obj.activityState = ActivityStateInfo.toJSON(message.activityState);
    }
    if (message.activityCity !== undefined) {
      obj.activityCity = ActivityCityInfo.toJSON(message.activityCity);
    }
    if (message.unknownListingDimension !== undefined) {
      obj.unknownListingDimension = UnknownListingDimensionInfo.toJSON(message.unknownListingDimension);
    }
    return obj;
  },

  create(base?: DeepPartial<ListingDimensionInfo>): ListingDimensionInfo {
    return ListingDimensionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListingDimensionInfo>): ListingDimensionInfo {
    const message = createBaseListingDimensionInfo();
    message.hotelId = (object.hotelId !== undefined && object.hotelId !== null)
      ? HotelIdInfo.fromPartial(object.hotelId)
      : undefined;
    message.hotelClass = (object.hotelClass !== undefined && object.hotelClass !== null)
      ? HotelClassInfo.fromPartial(object.hotelClass)
      : undefined;
    message.hotelCountryRegion = (object.hotelCountryRegion !== undefined && object.hotelCountryRegion !== null)
      ? HotelCountryRegionInfo.fromPartial(object.hotelCountryRegion)
      : undefined;
    message.hotelState = (object.hotelState !== undefined && object.hotelState !== null)
      ? HotelStateInfo.fromPartial(object.hotelState)
      : undefined;
    message.hotelCity = (object.hotelCity !== undefined && object.hotelCity !== null)
      ? HotelCityInfo.fromPartial(object.hotelCity)
      : undefined;
    message.productCategory = (object.productCategory !== undefined && object.productCategory !== null)
      ? ProductCategoryInfo.fromPartial(object.productCategory)
      : undefined;
    message.productBrand = (object.productBrand !== undefined && object.productBrand !== null)
      ? ProductBrandInfo.fromPartial(object.productBrand)
      : undefined;
    message.productChannel = (object.productChannel !== undefined && object.productChannel !== null)
      ? ProductChannelInfo.fromPartial(object.productChannel)
      : undefined;
    message.productChannelExclusivity =
      (object.productChannelExclusivity !== undefined && object.productChannelExclusivity !== null)
        ? ProductChannelExclusivityInfo.fromPartial(object.productChannelExclusivity)
        : undefined;
    message.productCondition = (object.productCondition !== undefined && object.productCondition !== null)
      ? ProductConditionInfo.fromPartial(object.productCondition)
      : undefined;
    message.productCustomAttribute =
      (object.productCustomAttribute !== undefined && object.productCustomAttribute !== null)
        ? ProductCustomAttributeInfo.fromPartial(object.productCustomAttribute)
        : undefined;
    message.productItemId = (object.productItemId !== undefined && object.productItemId !== null)
      ? ProductItemIdInfo.fromPartial(object.productItemId)
      : undefined;
    message.productType = (object.productType !== undefined && object.productType !== null)
      ? ProductTypeInfo.fromPartial(object.productType)
      : undefined;
    message.productGrouping = (object.productGrouping !== undefined && object.productGrouping !== null)
      ? ProductGroupingInfo.fromPartial(object.productGrouping)
      : undefined;
    message.productLabels = (object.productLabels !== undefined && object.productLabels !== null)
      ? ProductLabelsInfo.fromPartial(object.productLabels)
      : undefined;
    message.productLegacyCondition =
      (object.productLegacyCondition !== undefined && object.productLegacyCondition !== null)
        ? ProductLegacyConditionInfo.fromPartial(object.productLegacyCondition)
        : undefined;
    message.productTypeFull = (object.productTypeFull !== undefined && object.productTypeFull !== null)
      ? ProductTypeFullInfo.fromPartial(object.productTypeFull)
      : undefined;
    message.activityId = (object.activityId !== undefined && object.activityId !== null)
      ? ActivityIdInfo.fromPartial(object.activityId)
      : undefined;
    message.activityRating = (object.activityRating !== undefined && object.activityRating !== null)
      ? ActivityRatingInfo.fromPartial(object.activityRating)
      : undefined;
    message.activityCountry = (object.activityCountry !== undefined && object.activityCountry !== null)
      ? ActivityCountryInfo.fromPartial(object.activityCountry)
      : undefined;
    message.activityState = (object.activityState !== undefined && object.activityState !== null)
      ? ActivityStateInfo.fromPartial(object.activityState)
      : undefined;
    message.activityCity = (object.activityCity !== undefined && object.activityCity !== null)
      ? ActivityCityInfo.fromPartial(object.activityCity)
      : undefined;
    message.unknownListingDimension =
      (object.unknownListingDimension !== undefined && object.unknownListingDimension !== null)
        ? UnknownListingDimensionInfo.fromPartial(object.unknownListingDimension)
        : undefined;
    return message;
  },
};

function createBaseHotelIdInfo(): HotelIdInfo {
  return { value: undefined };
}

export const HotelIdInfo: MessageFns<HotelIdInfo> = {
  encode(message: HotelIdInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelIdInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelIdInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelIdInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: HotelIdInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HotelIdInfo>): HotelIdInfo {
    return HotelIdInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelIdInfo>): HotelIdInfo {
    const message = createBaseHotelIdInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseHotelClassInfo(): HotelClassInfo {
  return { value: undefined };
}

export const HotelClassInfo: MessageFns<HotelClassInfo> = {
  encode(message: HotelClassInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelClassInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelClassInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelClassInfo {
    return { value: isSet(object.value) ? Long.fromValue(object.value) : undefined };
  },

  toJSON(message: HotelClassInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<HotelClassInfo>): HotelClassInfo {
    return HotelClassInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelClassInfo>): HotelClassInfo {
    const message = createBaseHotelClassInfo();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : undefined;
    return message;
  },
};

function createBaseHotelCountryRegionInfo(): HotelCountryRegionInfo {
  return { countryRegionCriterion: undefined };
}

export const HotelCountryRegionInfo: MessageFns<HotelCountryRegionInfo> = {
  encode(message: HotelCountryRegionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryRegionCriterion !== undefined) {
      writer.uint32(18).string(message.countryRegionCriterion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelCountryRegionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelCountryRegionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.countryRegionCriterion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelCountryRegionInfo {
    return {
      countryRegionCriterion: isSet(object.countryRegionCriterion)
        ? globalThis.String(object.countryRegionCriterion)
        : undefined,
    };
  },

  toJSON(message: HotelCountryRegionInfo): unknown {
    const obj: any = {};
    if (message.countryRegionCriterion !== undefined) {
      obj.countryRegionCriterion = message.countryRegionCriterion;
    }
    return obj;
  },

  create(base?: DeepPartial<HotelCountryRegionInfo>): HotelCountryRegionInfo {
    return HotelCountryRegionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelCountryRegionInfo>): HotelCountryRegionInfo {
    const message = createBaseHotelCountryRegionInfo();
    message.countryRegionCriterion = object.countryRegionCriterion ?? undefined;
    return message;
  },
};

function createBaseHotelStateInfo(): HotelStateInfo {
  return { stateCriterion: undefined };
}

export const HotelStateInfo: MessageFns<HotelStateInfo> = {
  encode(message: HotelStateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stateCriterion !== undefined) {
      writer.uint32(18).string(message.stateCriterion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelStateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelStateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateCriterion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelStateInfo {
    return { stateCriterion: isSet(object.stateCriterion) ? globalThis.String(object.stateCriterion) : undefined };
  },

  toJSON(message: HotelStateInfo): unknown {
    const obj: any = {};
    if (message.stateCriterion !== undefined) {
      obj.stateCriterion = message.stateCriterion;
    }
    return obj;
  },

  create(base?: DeepPartial<HotelStateInfo>): HotelStateInfo {
    return HotelStateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelStateInfo>): HotelStateInfo {
    const message = createBaseHotelStateInfo();
    message.stateCriterion = object.stateCriterion ?? undefined;
    return message;
  },
};

function createBaseHotelCityInfo(): HotelCityInfo {
  return { cityCriterion: undefined };
}

export const HotelCityInfo: MessageFns<HotelCityInfo> = {
  encode(message: HotelCityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cityCriterion !== undefined) {
      writer.uint32(18).string(message.cityCriterion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelCityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelCityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cityCriterion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelCityInfo {
    return { cityCriterion: isSet(object.cityCriterion) ? globalThis.String(object.cityCriterion) : undefined };
  },

  toJSON(message: HotelCityInfo): unknown {
    const obj: any = {};
    if (message.cityCriterion !== undefined) {
      obj.cityCriterion = message.cityCriterion;
    }
    return obj;
  },

  create(base?: DeepPartial<HotelCityInfo>): HotelCityInfo {
    return HotelCityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelCityInfo>): HotelCityInfo {
    const message = createBaseHotelCityInfo();
    message.cityCriterion = object.cityCriterion ?? undefined;
    return message;
  },
};

function createBaseProductCategoryInfo(): ProductCategoryInfo {
  return { categoryId: undefined, level: 0 };
}

export const ProductCategoryInfo: MessageFns<ProductCategoryInfo> = {
  encode(message: ProductCategoryInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== undefined) {
      writer.uint32(8).int64(message.categoryId.toString());
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCategoryInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCategoryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.categoryId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCategoryInfo {
    return {
      categoryId: isSet(object.categoryId) ? Long.fromValue(object.categoryId) : undefined,
      level: isSet(object.level) ? productCategoryLevelEnum_ProductCategoryLevelFromJSON(object.level) : 0,
    };
  },

  toJSON(message: ProductCategoryInfo): unknown {
    const obj: any = {};
    if (message.categoryId !== undefined) {
      obj.categoryId = (message.categoryId || Long.ZERO).toString();
    }
    if (message.level !== 0) {
      obj.level = productCategoryLevelEnum_ProductCategoryLevelToJSON(message.level);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCategoryInfo>): ProductCategoryInfo {
    return ProductCategoryInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCategoryInfo>): ProductCategoryInfo {
    const message = createBaseProductCategoryInfo();
    message.categoryId = (object.categoryId !== undefined && object.categoryId !== null)
      ? Long.fromValue(object.categoryId)
      : undefined;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseProductBrandInfo(): ProductBrandInfo {
  return { value: undefined };
}

export const ProductBrandInfo: MessageFns<ProductBrandInfo> = {
  encode(message: ProductBrandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductBrandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductBrandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductBrandInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductBrandInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductBrandInfo>): ProductBrandInfo {
    return ProductBrandInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductBrandInfo>): ProductBrandInfo {
    const message = createBaseProductBrandInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProductChannelInfo(): ProductChannelInfo {
  return { channel: 0 };
}

export const ProductChannelInfo: MessageFns<ProductChannelInfo> = {
  encode(message: ProductChannelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChannelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChannelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChannelInfo {
    return { channel: isSet(object.channel) ? productChannelEnum_ProductChannelFromJSON(object.channel) : 0 };
  },

  toJSON(message: ProductChannelInfo): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = productChannelEnum_ProductChannelToJSON(message.channel);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductChannelInfo>): ProductChannelInfo {
    return ProductChannelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductChannelInfo>): ProductChannelInfo {
    const message = createBaseProductChannelInfo();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseProductChannelExclusivityInfo(): ProductChannelExclusivityInfo {
  return { channelExclusivity: 0 };
}

export const ProductChannelExclusivityInfo: MessageFns<ProductChannelExclusivityInfo> = {
  encode(message: ProductChannelExclusivityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelExclusivity !== 0) {
      writer.uint32(8).int32(message.channelExclusivity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductChannelExclusivityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductChannelExclusivityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelExclusivity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductChannelExclusivityInfo {
    return {
      channelExclusivity: isSet(object.channelExclusivity)
        ? productChannelExclusivityEnum_ProductChannelExclusivityFromJSON(object.channelExclusivity)
        : 0,
    };
  },

  toJSON(message: ProductChannelExclusivityInfo): unknown {
    const obj: any = {};
    if (message.channelExclusivity !== 0) {
      obj.channelExclusivity = productChannelExclusivityEnum_ProductChannelExclusivityToJSON(
        message.channelExclusivity,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ProductChannelExclusivityInfo>): ProductChannelExclusivityInfo {
    return ProductChannelExclusivityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductChannelExclusivityInfo>): ProductChannelExclusivityInfo {
    const message = createBaseProductChannelExclusivityInfo();
    message.channelExclusivity = object.channelExclusivity ?? 0;
    return message;
  },
};

function createBaseProductConditionInfo(): ProductConditionInfo {
  return { condition: 0 };
}

export const ProductConditionInfo: MessageFns<ProductConditionInfo> = {
  encode(message: ProductConditionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductConditionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductConditionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductConditionInfo {
    return { condition: isSet(object.condition) ? productConditionEnum_ProductConditionFromJSON(object.condition) : 0 };
  },

  toJSON(message: ProductConditionInfo): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = productConditionEnum_ProductConditionToJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductConditionInfo>): ProductConditionInfo {
    return ProductConditionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductConditionInfo>): ProductConditionInfo {
    const message = createBaseProductConditionInfo();
    message.condition = object.condition ?? 0;
    return message;
  },
};

function createBaseProductCustomAttributeInfo(): ProductCustomAttributeInfo {
  return { value: undefined, index: 0 };
}

export const ProductCustomAttributeInfo: MessageFns<ProductCustomAttributeInfo> = {
  encode(message: ProductCustomAttributeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCustomAttributeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCustomAttributeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCustomAttributeInfo {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      index: isSet(object.index)
        ? productCustomAttributeIndexEnum_ProductCustomAttributeIndexFromJSON(object.index)
        : 0,
    };
  },

  toJSON(message: ProductCustomAttributeInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.index !== 0) {
      obj.index = productCustomAttributeIndexEnum_ProductCustomAttributeIndexToJSON(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCustomAttributeInfo>): ProductCustomAttributeInfo {
    return ProductCustomAttributeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCustomAttributeInfo>): ProductCustomAttributeInfo {
    const message = createBaseProductCustomAttributeInfo();
    message.value = object.value ?? undefined;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseProductItemIdInfo(): ProductItemIdInfo {
  return { value: undefined };
}

export const ProductItemIdInfo: MessageFns<ProductItemIdInfo> = {
  encode(message: ProductItemIdInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductItemIdInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductItemIdInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductItemIdInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductItemIdInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductItemIdInfo>): ProductItemIdInfo {
    return ProductItemIdInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductItemIdInfo>): ProductItemIdInfo {
    const message = createBaseProductItemIdInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProductTypeInfo(): ProductTypeInfo {
  return { value: undefined, level: 0 };
}

export const ProductTypeInfo: MessageFns<ProductTypeInfo> = {
  encode(message: ProductTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductTypeInfo {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      level: isSet(object.level) ? productTypeLevelEnum_ProductTypeLevelFromJSON(object.level) : 0,
    };
  },

  toJSON(message: ProductTypeInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.level !== 0) {
      obj.level = productTypeLevelEnum_ProductTypeLevelToJSON(message.level);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductTypeInfo>): ProductTypeInfo {
    return ProductTypeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductTypeInfo>): ProductTypeInfo {
    const message = createBaseProductTypeInfo();
    message.value = object.value ?? undefined;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseProductGroupingInfo(): ProductGroupingInfo {
  return { value: undefined };
}

export const ProductGroupingInfo: MessageFns<ProductGroupingInfo> = {
  encode(message: ProductGroupingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductGroupingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductGroupingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductGroupingInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductGroupingInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductGroupingInfo>): ProductGroupingInfo {
    return ProductGroupingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductGroupingInfo>): ProductGroupingInfo {
    const message = createBaseProductGroupingInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProductLabelsInfo(): ProductLabelsInfo {
  return { value: undefined };
}

export const ProductLabelsInfo: MessageFns<ProductLabelsInfo> = {
  encode(message: ProductLabelsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductLabelsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductLabelsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductLabelsInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductLabelsInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductLabelsInfo>): ProductLabelsInfo {
    return ProductLabelsInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductLabelsInfo>): ProductLabelsInfo {
    const message = createBaseProductLabelsInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProductLegacyConditionInfo(): ProductLegacyConditionInfo {
  return { value: undefined };
}

export const ProductLegacyConditionInfo: MessageFns<ProductLegacyConditionInfo> = {
  encode(message: ProductLegacyConditionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductLegacyConditionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductLegacyConditionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductLegacyConditionInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductLegacyConditionInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductLegacyConditionInfo>): ProductLegacyConditionInfo {
    return ProductLegacyConditionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductLegacyConditionInfo>): ProductLegacyConditionInfo {
    const message = createBaseProductLegacyConditionInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProductTypeFullInfo(): ProductTypeFullInfo {
  return { value: undefined };
}

export const ProductTypeFullInfo: MessageFns<ProductTypeFullInfo> = {
  encode(message: ProductTypeFullInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductTypeFullInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductTypeFullInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductTypeFullInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ProductTypeFullInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductTypeFullInfo>): ProductTypeFullInfo {
    return ProductTypeFullInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductTypeFullInfo>): ProductTypeFullInfo {
    const message = createBaseProductTypeFullInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseUnknownListingDimensionInfo(): UnknownListingDimensionInfo {
  return {};
}

export const UnknownListingDimensionInfo: MessageFns<UnknownListingDimensionInfo> = {
  encode(_: UnknownListingDimensionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnknownListingDimensionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnknownListingDimensionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UnknownListingDimensionInfo {
    return {};
  },

  toJSON(_: UnknownListingDimensionInfo): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UnknownListingDimensionInfo>): UnknownListingDimensionInfo {
    return UnknownListingDimensionInfo.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UnknownListingDimensionInfo>): UnknownListingDimensionInfo {
    const message = createBaseUnknownListingDimensionInfo();
    return message;
  },
};

function createBaseHotelDateSelectionTypeInfo(): HotelDateSelectionTypeInfo {
  return { type: 0 };
}

export const HotelDateSelectionTypeInfo: MessageFns<HotelDateSelectionTypeInfo> = {
  encode(message: HotelDateSelectionTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelDateSelectionTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelDateSelectionTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelDateSelectionTypeInfo {
    return { type: isSet(object.type) ? hotelDateSelectionTypeEnum_HotelDateSelectionTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: HotelDateSelectionTypeInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = hotelDateSelectionTypeEnum_HotelDateSelectionTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<HotelDateSelectionTypeInfo>): HotelDateSelectionTypeInfo {
    return HotelDateSelectionTypeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelDateSelectionTypeInfo>): HotelDateSelectionTypeInfo {
    const message = createBaseHotelDateSelectionTypeInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseHotelAdvanceBookingWindowInfo(): HotelAdvanceBookingWindowInfo {
  return { minDays: undefined, maxDays: undefined };
}

export const HotelAdvanceBookingWindowInfo: MessageFns<HotelAdvanceBookingWindowInfo> = {
  encode(message: HotelAdvanceBookingWindowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minDays !== undefined) {
      writer.uint32(24).int64(message.minDays.toString());
    }
    if (message.maxDays !== undefined) {
      writer.uint32(32).int64(message.maxDays.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelAdvanceBookingWindowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelAdvanceBookingWindowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minDays = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxDays = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelAdvanceBookingWindowInfo {
    return {
      minDays: isSet(object.minDays) ? Long.fromValue(object.minDays) : undefined,
      maxDays: isSet(object.maxDays) ? Long.fromValue(object.maxDays) : undefined,
    };
  },

  toJSON(message: HotelAdvanceBookingWindowInfo): unknown {
    const obj: any = {};
    if (message.minDays !== undefined) {
      obj.minDays = (message.minDays || Long.ZERO).toString();
    }
    if (message.maxDays !== undefined) {
      obj.maxDays = (message.maxDays || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<HotelAdvanceBookingWindowInfo>): HotelAdvanceBookingWindowInfo {
    return HotelAdvanceBookingWindowInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelAdvanceBookingWindowInfo>): HotelAdvanceBookingWindowInfo {
    const message = createBaseHotelAdvanceBookingWindowInfo();
    message.minDays = (object.minDays !== undefined && object.minDays !== null)
      ? Long.fromValue(object.minDays)
      : undefined;
    message.maxDays = (object.maxDays !== undefined && object.maxDays !== null)
      ? Long.fromValue(object.maxDays)
      : undefined;
    return message;
  },
};

function createBaseHotelLengthOfStayInfo(): HotelLengthOfStayInfo {
  return { minNights: undefined, maxNights: undefined };
}

export const HotelLengthOfStayInfo: MessageFns<HotelLengthOfStayInfo> = {
  encode(message: HotelLengthOfStayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minNights !== undefined) {
      writer.uint32(24).int64(message.minNights.toString());
    }
    if (message.maxNights !== undefined) {
      writer.uint32(32).int64(message.maxNights.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelLengthOfStayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelLengthOfStayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minNights = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxNights = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelLengthOfStayInfo {
    return {
      minNights: isSet(object.minNights) ? Long.fromValue(object.minNights) : undefined,
      maxNights: isSet(object.maxNights) ? Long.fromValue(object.maxNights) : undefined,
    };
  },

  toJSON(message: HotelLengthOfStayInfo): unknown {
    const obj: any = {};
    if (message.minNights !== undefined) {
      obj.minNights = (message.minNights || Long.ZERO).toString();
    }
    if (message.maxNights !== undefined) {
      obj.maxNights = (message.maxNights || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<HotelLengthOfStayInfo>): HotelLengthOfStayInfo {
    return HotelLengthOfStayInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelLengthOfStayInfo>): HotelLengthOfStayInfo {
    const message = createBaseHotelLengthOfStayInfo();
    message.minNights = (object.minNights !== undefined && object.minNights !== null)
      ? Long.fromValue(object.minNights)
      : undefined;
    message.maxNights = (object.maxNights !== undefined && object.maxNights !== null)
      ? Long.fromValue(object.maxNights)
      : undefined;
    return message;
  },
};

function createBaseHotelCheckInDateRangeInfo(): HotelCheckInDateRangeInfo {
  return { startDate: "", endDate: "" };
}

export const HotelCheckInDateRangeInfo: MessageFns<HotelCheckInDateRangeInfo> = {
  encode(message: HotelCheckInDateRangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== "") {
      writer.uint32(10).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(18).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelCheckInDateRangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelCheckInDateRangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelCheckInDateRangeInfo {
    return {
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: HotelCheckInDateRangeInfo): unknown {
    const obj: any = {};
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create(base?: DeepPartial<HotelCheckInDateRangeInfo>): HotelCheckInDateRangeInfo {
    return HotelCheckInDateRangeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelCheckInDateRangeInfo>): HotelCheckInDateRangeInfo {
    const message = createBaseHotelCheckInDateRangeInfo();
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseHotelCheckInDayInfo(): HotelCheckInDayInfo {
  return { dayOfWeek: 0 };
}

export const HotelCheckInDayInfo: MessageFns<HotelCheckInDayInfo> = {
  encode(message: HotelCheckInDayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dayOfWeek !== 0) {
      writer.uint32(8).int32(message.dayOfWeek);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotelCheckInDayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotelCheckInDayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotelCheckInDayInfo {
    return { dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekEnum_DayOfWeekFromJSON(object.dayOfWeek) : 0 };
  },

  toJSON(message: HotelCheckInDayInfo): unknown {
    const obj: any = {};
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekEnum_DayOfWeekToJSON(message.dayOfWeek);
    }
    return obj;
  },

  create(base?: DeepPartial<HotelCheckInDayInfo>): HotelCheckInDayInfo {
    return HotelCheckInDayInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HotelCheckInDayInfo>): HotelCheckInDayInfo {
    const message = createBaseHotelCheckInDayInfo();
    message.dayOfWeek = object.dayOfWeek ?? 0;
    return message;
  },
};

function createBaseActivityIdInfo(): ActivityIdInfo {
  return { value: undefined };
}

export const ActivityIdInfo: MessageFns<ActivityIdInfo> = {
  encode(message: ActivityIdInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityIdInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityIdInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityIdInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ActivityIdInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ActivityIdInfo>): ActivityIdInfo {
    return ActivityIdInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivityIdInfo>): ActivityIdInfo {
    const message = createBaseActivityIdInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseActivityRatingInfo(): ActivityRatingInfo {
  return { value: undefined };
}

export const ActivityRatingInfo: MessageFns<ActivityRatingInfo> = {
  encode(message: ActivityRatingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(8).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityRatingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityRatingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityRatingInfo {
    return { value: isSet(object.value) ? Long.fromValue(object.value) : undefined };
  },

  toJSON(message: ActivityRatingInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ActivityRatingInfo>): ActivityRatingInfo {
    return ActivityRatingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivityRatingInfo>): ActivityRatingInfo {
    const message = createBaseActivityRatingInfo();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : undefined;
    return message;
  },
};

function createBaseActivityCountryInfo(): ActivityCountryInfo {
  return { value: undefined };
}

export const ActivityCountryInfo: MessageFns<ActivityCountryInfo> = {
  encode(message: ActivityCountryInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityCountryInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityCountryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityCountryInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ActivityCountryInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ActivityCountryInfo>): ActivityCountryInfo {
    return ActivityCountryInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivityCountryInfo>): ActivityCountryInfo {
    const message = createBaseActivityCountryInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseActivityStateInfo(): ActivityStateInfo {
  return { value: undefined };
}

export const ActivityStateInfo: MessageFns<ActivityStateInfo> = {
  encode(message: ActivityStateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityStateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityStateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityStateInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ActivityStateInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ActivityStateInfo>): ActivityStateInfo {
    return ActivityStateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivityStateInfo>): ActivityStateInfo {
    const message = createBaseActivityStateInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseActivityCityInfo(): ActivityCityInfo {
  return { value: undefined };
}

export const ActivityCityInfo: MessageFns<ActivityCityInfo> = {
  encode(message: ActivityCityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityCityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityCityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityCityInfo {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: ActivityCityInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ActivityCityInfo>): ActivityCityInfo {
    return ActivityCityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivityCityInfo>): ActivityCityInfo {
    const message = createBaseActivityCityInfo();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseInteractionTypeInfo(): InteractionTypeInfo {
  return { type: 0 };
}

export const InteractionTypeInfo: MessageFns<InteractionTypeInfo> = {
  encode(message: InteractionTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InteractionTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteractionTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InteractionTypeInfo {
    return { type: isSet(object.type) ? interactionTypeEnum_InteractionTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: InteractionTypeInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = interactionTypeEnum_InteractionTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<InteractionTypeInfo>): InteractionTypeInfo {
    return InteractionTypeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InteractionTypeInfo>): InteractionTypeInfo {
    const message = createBaseInteractionTypeInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseAdScheduleInfo(): AdScheduleInfo {
  return { startMinute: 0, endMinute: 0, startHour: undefined, endHour: undefined, dayOfWeek: 0 };
}

export const AdScheduleInfo: MessageFns<AdScheduleInfo> = {
  encode(message: AdScheduleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startMinute !== 0) {
      writer.uint32(8).int32(message.startMinute);
    }
    if (message.endMinute !== 0) {
      writer.uint32(16).int32(message.endMinute);
    }
    if (message.startHour !== undefined) {
      writer.uint32(48).int32(message.startHour);
    }
    if (message.endHour !== undefined) {
      writer.uint32(56).int32(message.endHour);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(40).int32(message.dayOfWeek);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdScheduleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdScheduleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startMinute = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endMinute = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.startHour = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.endHour = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdScheduleInfo {
    return {
      startMinute: isSet(object.startMinute) ? minuteOfHourEnum_MinuteOfHourFromJSON(object.startMinute) : 0,
      endMinute: isSet(object.endMinute) ? minuteOfHourEnum_MinuteOfHourFromJSON(object.endMinute) : 0,
      startHour: isSet(object.startHour) ? globalThis.Number(object.startHour) : undefined,
      endHour: isSet(object.endHour) ? globalThis.Number(object.endHour) : undefined,
      dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekEnum_DayOfWeekFromJSON(object.dayOfWeek) : 0,
    };
  },

  toJSON(message: AdScheduleInfo): unknown {
    const obj: any = {};
    if (message.startMinute !== 0) {
      obj.startMinute = minuteOfHourEnum_MinuteOfHourToJSON(message.startMinute);
    }
    if (message.endMinute !== 0) {
      obj.endMinute = minuteOfHourEnum_MinuteOfHourToJSON(message.endMinute);
    }
    if (message.startHour !== undefined) {
      obj.startHour = Math.round(message.startHour);
    }
    if (message.endHour !== undefined) {
      obj.endHour = Math.round(message.endHour);
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekEnum_DayOfWeekToJSON(message.dayOfWeek);
    }
    return obj;
  },

  create(base?: DeepPartial<AdScheduleInfo>): AdScheduleInfo {
    return AdScheduleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdScheduleInfo>): AdScheduleInfo {
    const message = createBaseAdScheduleInfo();
    message.startMinute = object.startMinute ?? 0;
    message.endMinute = object.endMinute ?? 0;
    message.startHour = object.startHour ?? undefined;
    message.endHour = object.endHour ?? undefined;
    message.dayOfWeek = object.dayOfWeek ?? 0;
    return message;
  },
};

function createBaseAgeRangeInfo(): AgeRangeInfo {
  return { type: 0 };
}

export const AgeRangeInfo: MessageFns<AgeRangeInfo> = {
  encode(message: AgeRangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRangeInfo {
    return { type: isSet(object.type) ? ageRangeTypeEnum_AgeRangeTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: AgeRangeInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ageRangeTypeEnum_AgeRangeTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRangeInfo>): AgeRangeInfo {
    return AgeRangeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRangeInfo>): AgeRangeInfo {
    const message = createBaseAgeRangeInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGenderInfo(): GenderInfo {
  return { type: 0 };
}

export const GenderInfo: MessageFns<GenderInfo> = {
  encode(message: GenderInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenderInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenderInfo {
    return { type: isSet(object.type) ? genderTypeEnum_GenderTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: GenderInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = genderTypeEnum_GenderTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<GenderInfo>): GenderInfo {
    return GenderInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenderInfo>): GenderInfo {
    const message = createBaseGenderInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseIncomeRangeInfo(): IncomeRangeInfo {
  return { type: 0 };
}

export const IncomeRangeInfo: MessageFns<IncomeRangeInfo> = {
  encode(message: IncomeRangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncomeRangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncomeRangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncomeRangeInfo {
    return { type: isSet(object.type) ? incomeRangeTypeEnum_IncomeRangeTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: IncomeRangeInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = incomeRangeTypeEnum_IncomeRangeTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<IncomeRangeInfo>): IncomeRangeInfo {
    return IncomeRangeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IncomeRangeInfo>): IncomeRangeInfo {
    const message = createBaseIncomeRangeInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseParentalStatusInfo(): ParentalStatusInfo {
  return { type: 0 };
}

export const ParentalStatusInfo: MessageFns<ParentalStatusInfo> = {
  encode(message: ParentalStatusInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParentalStatusInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParentalStatusInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParentalStatusInfo {
    return { type: isSet(object.type) ? parentalStatusTypeEnum_ParentalStatusTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: ParentalStatusInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = parentalStatusTypeEnum_ParentalStatusTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ParentalStatusInfo>): ParentalStatusInfo {
    return ParentalStatusInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParentalStatusInfo>): ParentalStatusInfo {
    const message = createBaseParentalStatusInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseYouTubeVideoInfo(): YouTubeVideoInfo {
  return { videoId: undefined };
}

export const YouTubeVideoInfo: MessageFns<YouTubeVideoInfo> = {
  encode(message: YouTubeVideoInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== undefined) {
      writer.uint32(18).string(message.videoId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeVideoInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeVideoInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeVideoInfo {
    return { videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : undefined };
  },

  toJSON(message: YouTubeVideoInfo): unknown {
    const obj: any = {};
    if (message.videoId !== undefined) {
      obj.videoId = message.videoId;
    }
    return obj;
  },

  create(base?: DeepPartial<YouTubeVideoInfo>): YouTubeVideoInfo {
    return YouTubeVideoInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YouTubeVideoInfo>): YouTubeVideoInfo {
    const message = createBaseYouTubeVideoInfo();
    message.videoId = object.videoId ?? undefined;
    return message;
  },
};

function createBaseYouTubeChannelInfo(): YouTubeChannelInfo {
  return { channelId: undefined };
}

export const YouTubeChannelInfo: MessageFns<YouTubeChannelInfo> = {
  encode(message: YouTubeChannelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== undefined) {
      writer.uint32(18).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeChannelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeChannelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channelId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeChannelInfo {
    return { channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : undefined };
  },

  toJSON(message: YouTubeChannelInfo): unknown {
    const obj: any = {};
    if (message.channelId !== undefined) {
      obj.channelId = message.channelId;
    }
    return obj;
  },

  create(base?: DeepPartial<YouTubeChannelInfo>): YouTubeChannelInfo {
    return YouTubeChannelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YouTubeChannelInfo>): YouTubeChannelInfo {
    const message = createBaseYouTubeChannelInfo();
    message.channelId = object.channelId ?? undefined;
    return message;
  },
};

function createBaseUserListInfo(): UserListInfo {
  return { userList: undefined };
}

export const UserListInfo: MessageFns<UserListInfo> = {
  encode(message: UserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      writer.uint32(18).string(message.userList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userList = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListInfo {
    return { userList: isSet(object.userList) ? globalThis.String(object.userList) : undefined };
  },

  toJSON(message: UserListInfo): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = message.userList;
    }
    return obj;
  },

  create(base?: DeepPartial<UserListInfo>): UserListInfo {
    return UserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListInfo>): UserListInfo {
    const message = createBaseUserListInfo();
    message.userList = object.userList ?? undefined;
    return message;
  },
};

function createBaseProximityInfo(): ProximityInfo {
  return { geoPoint: undefined, radius: undefined, radiusUnits: 0, address: undefined };
}

export const ProximityInfo: MessageFns<ProximityInfo> = {
  encode(message: ProximityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geoPoint !== undefined) {
      GeoPointInfo.encode(message.geoPoint, writer.uint32(10).fork()).join();
    }
    if (message.radius !== undefined) {
      writer.uint32(41).double(message.radius);
    }
    if (message.radiusUnits !== 0) {
      writer.uint32(24).int32(message.radiusUnits);
    }
    if (message.address !== undefined) {
      AddressInfo.encode(message.address, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProximityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProximityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.geoPoint = GeoPointInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.radius = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.radiusUnits = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.address = AddressInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProximityInfo {
    return {
      geoPoint: isSet(object.geoPoint) ? GeoPointInfo.fromJSON(object.geoPoint) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : undefined,
      radiusUnits: isSet(object.radiusUnits)
        ? proximityRadiusUnitsEnum_ProximityRadiusUnitsFromJSON(object.radiusUnits)
        : 0,
      address: isSet(object.address) ? AddressInfo.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: ProximityInfo): unknown {
    const obj: any = {};
    if (message.geoPoint !== undefined) {
      obj.geoPoint = GeoPointInfo.toJSON(message.geoPoint);
    }
    if (message.radius !== undefined) {
      obj.radius = message.radius;
    }
    if (message.radiusUnits !== 0) {
      obj.radiusUnits = proximityRadiusUnitsEnum_ProximityRadiusUnitsToJSON(message.radiusUnits);
    }
    if (message.address !== undefined) {
      obj.address = AddressInfo.toJSON(message.address);
    }
    return obj;
  },

  create(base?: DeepPartial<ProximityInfo>): ProximityInfo {
    return ProximityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProximityInfo>): ProximityInfo {
    const message = createBaseProximityInfo();
    message.geoPoint = (object.geoPoint !== undefined && object.geoPoint !== null)
      ? GeoPointInfo.fromPartial(object.geoPoint)
      : undefined;
    message.radius = object.radius ?? undefined;
    message.radiusUnits = object.radiusUnits ?? 0;
    message.address = (object.address !== undefined && object.address !== null)
      ? AddressInfo.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseGeoPointInfo(): GeoPointInfo {
  return { longitudeInMicroDegrees: undefined, latitudeInMicroDegrees: undefined };
}

export const GeoPointInfo: MessageFns<GeoPointInfo> = {
  encode(message: GeoPointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longitudeInMicroDegrees !== undefined) {
      writer.uint32(24).int32(message.longitudeInMicroDegrees);
    }
    if (message.latitudeInMicroDegrees !== undefined) {
      writer.uint32(32).int32(message.latitudeInMicroDegrees);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoPointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoPointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.longitudeInMicroDegrees = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.latitudeInMicroDegrees = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoPointInfo {
    return {
      longitudeInMicroDegrees: isSet(object.longitudeInMicroDegrees)
        ? globalThis.Number(object.longitudeInMicroDegrees)
        : undefined,
      latitudeInMicroDegrees: isSet(object.latitudeInMicroDegrees)
        ? globalThis.Number(object.latitudeInMicroDegrees)
        : undefined,
    };
  },

  toJSON(message: GeoPointInfo): unknown {
    const obj: any = {};
    if (message.longitudeInMicroDegrees !== undefined) {
      obj.longitudeInMicroDegrees = Math.round(message.longitudeInMicroDegrees);
    }
    if (message.latitudeInMicroDegrees !== undefined) {
      obj.latitudeInMicroDegrees = Math.round(message.latitudeInMicroDegrees);
    }
    return obj;
  },

  create(base?: DeepPartial<GeoPointInfo>): GeoPointInfo {
    return GeoPointInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoPointInfo>): GeoPointInfo {
    const message = createBaseGeoPointInfo();
    message.longitudeInMicroDegrees = object.longitudeInMicroDegrees ?? undefined;
    message.latitudeInMicroDegrees = object.latitudeInMicroDegrees ?? undefined;
    return message;
  },
};

function createBaseAddressInfo(): AddressInfo {
  return {
    postalCode: undefined,
    provinceCode: undefined,
    countryCode: undefined,
    provinceName: undefined,
    streetAddress: undefined,
    streetAddress2: undefined,
    cityName: undefined,
  };
}

export const AddressInfo: MessageFns<AddressInfo> = {
  encode(message: AddressInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.postalCode !== undefined) {
      writer.uint32(66).string(message.postalCode);
    }
    if (message.provinceCode !== undefined) {
      writer.uint32(74).string(message.provinceCode);
    }
    if (message.countryCode !== undefined) {
      writer.uint32(82).string(message.countryCode);
    }
    if (message.provinceName !== undefined) {
      writer.uint32(90).string(message.provinceName);
    }
    if (message.streetAddress !== undefined) {
      writer.uint32(98).string(message.streetAddress);
    }
    if (message.streetAddress2 !== undefined) {
      writer.uint32(106).string(message.streetAddress2);
    }
    if (message.cityName !== undefined) {
      writer.uint32(114).string(message.cityName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.provinceCode = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.provinceName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.streetAddress2 = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.cityName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressInfo {
    return {
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : undefined,
      provinceCode: isSet(object.provinceCode) ? globalThis.String(object.provinceCode) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : undefined,
      provinceName: isSet(object.provinceName) ? globalThis.String(object.provinceName) : undefined,
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : undefined,
      streetAddress2: isSet(object.streetAddress2) ? globalThis.String(object.streetAddress2) : undefined,
      cityName: isSet(object.cityName) ? globalThis.String(object.cityName) : undefined,
    };
  },

  toJSON(message: AddressInfo): unknown {
    const obj: any = {};
    if (message.postalCode !== undefined) {
      obj.postalCode = message.postalCode;
    }
    if (message.provinceCode !== undefined) {
      obj.provinceCode = message.provinceCode;
    }
    if (message.countryCode !== undefined) {
      obj.countryCode = message.countryCode;
    }
    if (message.provinceName !== undefined) {
      obj.provinceName = message.provinceName;
    }
    if (message.streetAddress !== undefined) {
      obj.streetAddress = message.streetAddress;
    }
    if (message.streetAddress2 !== undefined) {
      obj.streetAddress2 = message.streetAddress2;
    }
    if (message.cityName !== undefined) {
      obj.cityName = message.cityName;
    }
    return obj;
  },

  create(base?: DeepPartial<AddressInfo>): AddressInfo {
    return AddressInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressInfo>): AddressInfo {
    const message = createBaseAddressInfo();
    message.postalCode = object.postalCode ?? undefined;
    message.provinceCode = object.provinceCode ?? undefined;
    message.countryCode = object.countryCode ?? undefined;
    message.provinceName = object.provinceName ?? undefined;
    message.streetAddress = object.streetAddress ?? undefined;
    message.streetAddress2 = object.streetAddress2 ?? undefined;
    message.cityName = object.cityName ?? undefined;
    return message;
  },
};

function createBaseTopicInfo(): TopicInfo {
  return { topicConstant: undefined, path: [] };
}

export const TopicInfo: MessageFns<TopicInfo> = {
  encode(message: TopicInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicConstant !== undefined) {
      writer.uint32(26).string(message.topicConstant);
    }
    for (const v of message.path) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topicConstant = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicInfo {
    return {
      topicConstant: isSet(object.topicConstant) ? globalThis.String(object.topicConstant) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TopicInfo): unknown {
    const obj: any = {};
    if (message.topicConstant !== undefined) {
      obj.topicConstant = message.topicConstant;
    }
    if (message.path?.length) {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicInfo>): TopicInfo {
    return TopicInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicInfo>): TopicInfo {
    const message = createBaseTopicInfo();
    message.topicConstant = object.topicConstant ?? undefined;
    message.path = object.path?.map((e) => e) || [];
    return message;
  },
};

function createBaseLanguageInfo(): LanguageInfo {
  return { languageConstant: undefined };
}

export const LanguageInfo: MessageFns<LanguageInfo> = {
  encode(message: LanguageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageConstant !== undefined) {
      writer.uint32(18).string(message.languageConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageInfo {
    return {
      languageConstant: isSet(object.languageConstant) ? globalThis.String(object.languageConstant) : undefined,
    };
  },

  toJSON(message: LanguageInfo): unknown {
    const obj: any = {};
    if (message.languageConstant !== undefined) {
      obj.languageConstant = message.languageConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageInfo>): LanguageInfo {
    return LanguageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageInfo>): LanguageInfo {
    const message = createBaseLanguageInfo();
    message.languageConstant = object.languageConstant ?? undefined;
    return message;
  },
};

function createBaseIpBlockInfo(): IpBlockInfo {
  return { ipAddress: undefined };
}

export const IpBlockInfo: MessageFns<IpBlockInfo> = {
  encode(message: IpBlockInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== undefined) {
      writer.uint32(18).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpBlockInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpBlockInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpBlockInfo {
    return { ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined };
  },

  toJSON(message: IpBlockInfo): unknown {
    const obj: any = {};
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<IpBlockInfo>): IpBlockInfo {
    return IpBlockInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IpBlockInfo>): IpBlockInfo {
    const message = createBaseIpBlockInfo();
    message.ipAddress = object.ipAddress ?? undefined;
    return message;
  },
};

function createBaseContentLabelInfo(): ContentLabelInfo {
  return { type: 0 };
}

export const ContentLabelInfo: MessageFns<ContentLabelInfo> = {
  encode(message: ContentLabelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentLabelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentLabelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentLabelInfo {
    return { type: isSet(object.type) ? contentLabelTypeEnum_ContentLabelTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: ContentLabelInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = contentLabelTypeEnum_ContentLabelTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ContentLabelInfo>): ContentLabelInfo {
    return ContentLabelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContentLabelInfo>): ContentLabelInfo {
    const message = createBaseContentLabelInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseCarrierInfo(): CarrierInfo {
  return { carrierConstant: undefined };
}

export const CarrierInfo: MessageFns<CarrierInfo> = {
  encode(message: CarrierInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carrierConstant !== undefined) {
      writer.uint32(18).string(message.carrierConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CarrierInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCarrierInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.carrierConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CarrierInfo {
    return { carrierConstant: isSet(object.carrierConstant) ? globalThis.String(object.carrierConstant) : undefined };
  },

  toJSON(message: CarrierInfo): unknown {
    const obj: any = {};
    if (message.carrierConstant !== undefined) {
      obj.carrierConstant = message.carrierConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<CarrierInfo>): CarrierInfo {
    return CarrierInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CarrierInfo>): CarrierInfo {
    const message = createBaseCarrierInfo();
    message.carrierConstant = object.carrierConstant ?? undefined;
    return message;
  },
};

function createBaseUserInterestInfo(): UserInterestInfo {
  return { userInterestCategory: undefined };
}

export const UserInterestInfo: MessageFns<UserInterestInfo> = {
  encode(message: UserInterestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userInterestCategory !== undefined) {
      writer.uint32(18).string(message.userInterestCategory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInterestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInterestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userInterestCategory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInterestInfo {
    return {
      userInterestCategory: isSet(object.userInterestCategory)
        ? globalThis.String(object.userInterestCategory)
        : undefined,
    };
  },

  toJSON(message: UserInterestInfo): unknown {
    const obj: any = {};
    if (message.userInterestCategory !== undefined) {
      obj.userInterestCategory = message.userInterestCategory;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInterestInfo>): UserInterestInfo {
    return UserInterestInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInterestInfo>): UserInterestInfo {
    const message = createBaseUserInterestInfo();
    message.userInterestCategory = object.userInterestCategory ?? undefined;
    return message;
  },
};

function createBaseWebpageInfo(): WebpageInfo {
  return { criterionName: undefined, conditions: [], coveragePercentage: 0, sample: undefined };
}

export const WebpageInfo: MessageFns<WebpageInfo> = {
  encode(message: WebpageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criterionName !== undefined) {
      writer.uint32(26).string(message.criterionName);
    }
    for (const v of message.conditions) {
      WebpageConditionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.coveragePercentage !== 0) {
      writer.uint32(33).double(message.coveragePercentage);
    }
    if (message.sample !== undefined) {
      WebpageSampleInfo.encode(message.sample, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebpageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebpageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.criterionName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conditions.push(WebpageConditionInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.coveragePercentage = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sample = WebpageSampleInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebpageInfo {
    return {
      criterionName: isSet(object.criterionName) ? globalThis.String(object.criterionName) : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => WebpageConditionInfo.fromJSON(e))
        : [],
      coveragePercentage: isSet(object.coveragePercentage) ? globalThis.Number(object.coveragePercentage) : 0,
      sample: isSet(object.sample) ? WebpageSampleInfo.fromJSON(object.sample) : undefined,
    };
  },

  toJSON(message: WebpageInfo): unknown {
    const obj: any = {};
    if (message.criterionName !== undefined) {
      obj.criterionName = message.criterionName;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => WebpageConditionInfo.toJSON(e));
    }
    if (message.coveragePercentage !== 0) {
      obj.coveragePercentage = message.coveragePercentage;
    }
    if (message.sample !== undefined) {
      obj.sample = WebpageSampleInfo.toJSON(message.sample);
    }
    return obj;
  },

  create(base?: DeepPartial<WebpageInfo>): WebpageInfo {
    return WebpageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebpageInfo>): WebpageInfo {
    const message = createBaseWebpageInfo();
    message.criterionName = object.criterionName ?? undefined;
    message.conditions = object.conditions?.map((e) => WebpageConditionInfo.fromPartial(e)) || [];
    message.coveragePercentage = object.coveragePercentage ?? 0;
    message.sample = (object.sample !== undefined && object.sample !== null)
      ? WebpageSampleInfo.fromPartial(object.sample)
      : undefined;
    return message;
  },
};

function createBaseWebpageConditionInfo(): WebpageConditionInfo {
  return { operand: 0, operator: 0, argument: undefined };
}

export const WebpageConditionInfo: MessageFns<WebpageConditionInfo> = {
  encode(message: WebpageConditionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operand !== 0) {
      writer.uint32(8).int32(message.operand);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.argument !== undefined) {
      writer.uint32(34).string(message.argument);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebpageConditionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebpageConditionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operand = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.argument = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebpageConditionInfo {
    return {
      operand: isSet(object.operand) ? webpageConditionOperandEnum_WebpageConditionOperandFromJSON(object.operand) : 0,
      operator: isSet(object.operator)
        ? webpageConditionOperatorEnum_WebpageConditionOperatorFromJSON(object.operator)
        : 0,
      argument: isSet(object.argument) ? globalThis.String(object.argument) : undefined,
    };
  },

  toJSON(message: WebpageConditionInfo): unknown {
    const obj: any = {};
    if (message.operand !== 0) {
      obj.operand = webpageConditionOperandEnum_WebpageConditionOperandToJSON(message.operand);
    }
    if (message.operator !== 0) {
      obj.operator = webpageConditionOperatorEnum_WebpageConditionOperatorToJSON(message.operator);
    }
    if (message.argument !== undefined) {
      obj.argument = message.argument;
    }
    return obj;
  },

  create(base?: DeepPartial<WebpageConditionInfo>): WebpageConditionInfo {
    return WebpageConditionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebpageConditionInfo>): WebpageConditionInfo {
    const message = createBaseWebpageConditionInfo();
    message.operand = object.operand ?? 0;
    message.operator = object.operator ?? 0;
    message.argument = object.argument ?? undefined;
    return message;
  },
};

function createBaseWebpageSampleInfo(): WebpageSampleInfo {
  return { sampleUrls: [] };
}

export const WebpageSampleInfo: MessageFns<WebpageSampleInfo> = {
  encode(message: WebpageSampleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sampleUrls) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebpageSampleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebpageSampleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sampleUrls.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebpageSampleInfo {
    return {
      sampleUrls: globalThis.Array.isArray(object?.sampleUrls)
        ? object.sampleUrls.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WebpageSampleInfo): unknown {
    const obj: any = {};
    if (message.sampleUrls?.length) {
      obj.sampleUrls = message.sampleUrls;
    }
    return obj;
  },

  create(base?: DeepPartial<WebpageSampleInfo>): WebpageSampleInfo {
    return WebpageSampleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebpageSampleInfo>): WebpageSampleInfo {
    const message = createBaseWebpageSampleInfo();
    message.sampleUrls = object.sampleUrls?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperatingSystemVersionInfo(): OperatingSystemVersionInfo {
  return { operatingSystemVersionConstant: undefined };
}

export const OperatingSystemVersionInfo: MessageFns<OperatingSystemVersionInfo> = {
  encode(message: OperatingSystemVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operatingSystemVersionConstant !== undefined) {
      writer.uint32(18).string(message.operatingSystemVersionConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatingSystemVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatingSystemVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operatingSystemVersionConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatingSystemVersionInfo {
    return {
      operatingSystemVersionConstant: isSet(object.operatingSystemVersionConstant)
        ? globalThis.String(object.operatingSystemVersionConstant)
        : undefined,
    };
  },

  toJSON(message: OperatingSystemVersionInfo): unknown {
    const obj: any = {};
    if (message.operatingSystemVersionConstant !== undefined) {
      obj.operatingSystemVersionConstant = message.operatingSystemVersionConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<OperatingSystemVersionInfo>): OperatingSystemVersionInfo {
    return OperatingSystemVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatingSystemVersionInfo>): OperatingSystemVersionInfo {
    const message = createBaseOperatingSystemVersionInfo();
    message.operatingSystemVersionConstant = object.operatingSystemVersionConstant ?? undefined;
    return message;
  },
};

function createBaseAppPaymentModelInfo(): AppPaymentModelInfo {
  return { type: 0 };
}

export const AppPaymentModelInfo: MessageFns<AppPaymentModelInfo> = {
  encode(message: AppPaymentModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPaymentModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPaymentModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPaymentModelInfo {
    return { type: isSet(object.type) ? appPaymentModelTypeEnum_AppPaymentModelTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: AppPaymentModelInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = appPaymentModelTypeEnum_AppPaymentModelTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<AppPaymentModelInfo>): AppPaymentModelInfo {
    return AppPaymentModelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppPaymentModelInfo>): AppPaymentModelInfo {
    const message = createBaseAppPaymentModelInfo();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseMobileDeviceInfo(): MobileDeviceInfo {
  return { mobileDeviceConstant: undefined };
}

export const MobileDeviceInfo: MessageFns<MobileDeviceInfo> = {
  encode(message: MobileDeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mobileDeviceConstant !== undefined) {
      writer.uint32(18).string(message.mobileDeviceConstant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileDeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mobileDeviceConstant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileDeviceInfo {
    return {
      mobileDeviceConstant: isSet(object.mobileDeviceConstant)
        ? globalThis.String(object.mobileDeviceConstant)
        : undefined,
    };
  },

  toJSON(message: MobileDeviceInfo): unknown {
    const obj: any = {};
    if (message.mobileDeviceConstant !== undefined) {
      obj.mobileDeviceConstant = message.mobileDeviceConstant;
    }
    return obj;
  },

  create(base?: DeepPartial<MobileDeviceInfo>): MobileDeviceInfo {
    return MobileDeviceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileDeviceInfo>): MobileDeviceInfo {
    const message = createBaseMobileDeviceInfo();
    message.mobileDeviceConstant = object.mobileDeviceConstant ?? undefined;
    return message;
  },
};

function createBaseCustomAffinityInfo(): CustomAffinityInfo {
  return { customAffinity: undefined };
}

export const CustomAffinityInfo: MessageFns<CustomAffinityInfo> = {
  encode(message: CustomAffinityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customAffinity !== undefined) {
      writer.uint32(18).string(message.customAffinity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAffinityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAffinityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customAffinity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAffinityInfo {
    return { customAffinity: isSet(object.customAffinity) ? globalThis.String(object.customAffinity) : undefined };
  },

  toJSON(message: CustomAffinityInfo): unknown {
    const obj: any = {};
    if (message.customAffinity !== undefined) {
      obj.customAffinity = message.customAffinity;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAffinityInfo>): CustomAffinityInfo {
    return CustomAffinityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAffinityInfo>): CustomAffinityInfo {
    const message = createBaseCustomAffinityInfo();
    message.customAffinity = object.customAffinity ?? undefined;
    return message;
  },
};

function createBaseCustomIntentInfo(): CustomIntentInfo {
  return { customIntent: undefined };
}

export const CustomIntentInfo: MessageFns<CustomIntentInfo> = {
  encode(message: CustomIntentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customIntent !== undefined) {
      writer.uint32(18).string(message.customIntent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomIntentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomIntentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customIntent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomIntentInfo {
    return { customIntent: isSet(object.customIntent) ? globalThis.String(object.customIntent) : undefined };
  },

  toJSON(message: CustomIntentInfo): unknown {
    const obj: any = {};
    if (message.customIntent !== undefined) {
      obj.customIntent = message.customIntent;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomIntentInfo>): CustomIntentInfo {
    return CustomIntentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomIntentInfo>): CustomIntentInfo {
    const message = createBaseCustomIntentInfo();
    message.customIntent = object.customIntent ?? undefined;
    return message;
  },
};

function createBaseLocationGroupInfo(): LocationGroupInfo {
  return {
    feed: undefined,
    geoTargetConstants: [],
    radius: undefined,
    radiusUnits: 0,
    feedItemSets: [],
    enableCustomerLevelLocationAssetSet: undefined,
    locationGroupAssetSets: [],
  };
}

export const LocationGroupInfo: MessageFns<LocationGroupInfo> = {
  encode(message: LocationGroupInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feed !== undefined) {
      writer.uint32(42).string(message.feed);
    }
    for (const v of message.geoTargetConstants) {
      writer.uint32(50).string(v!);
    }
    if (message.radius !== undefined) {
      writer.uint32(56).int64(message.radius.toString());
    }
    if (message.radiusUnits !== 0) {
      writer.uint32(32).int32(message.radiusUnits);
    }
    for (const v of message.feedItemSets) {
      writer.uint32(66).string(v!);
    }
    if (message.enableCustomerLevelLocationAssetSet !== undefined) {
      writer.uint32(72).bool(message.enableCustomerLevelLocationAssetSet);
    }
    for (const v of message.locationGroupAssetSets) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationGroupInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feed = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.geoTargetConstants.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.radius = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.radiusUnits = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.feedItemSets.push(reader.string());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enableCustomerLevelLocationAssetSet = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.locationGroupAssetSets.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationGroupInfo {
    return {
      feed: isSet(object.feed) ? globalThis.String(object.feed) : undefined,
      geoTargetConstants: globalThis.Array.isArray(object?.geoTargetConstants)
        ? object.geoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
      radius: isSet(object.radius) ? Long.fromValue(object.radius) : undefined,
      radiusUnits: isSet(object.radiusUnits)
        ? locationGroupRadiusUnitsEnum_LocationGroupRadiusUnitsFromJSON(object.radiusUnits)
        : 0,
      feedItemSets: globalThis.Array.isArray(object?.feedItemSets)
        ? object.feedItemSets.map((e: any) => globalThis.String(e))
        : [],
      enableCustomerLevelLocationAssetSet: isSet(object.enableCustomerLevelLocationAssetSet)
        ? globalThis.Boolean(object.enableCustomerLevelLocationAssetSet)
        : undefined,
      locationGroupAssetSets: globalThis.Array.isArray(object?.locationGroupAssetSets)
        ? object.locationGroupAssetSets.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LocationGroupInfo): unknown {
    const obj: any = {};
    if (message.feed !== undefined) {
      obj.feed = message.feed;
    }
    if (message.geoTargetConstants?.length) {
      obj.geoTargetConstants = message.geoTargetConstants;
    }
    if (message.radius !== undefined) {
      obj.radius = (message.radius || Long.ZERO).toString();
    }
    if (message.radiusUnits !== 0) {
      obj.radiusUnits = locationGroupRadiusUnitsEnum_LocationGroupRadiusUnitsToJSON(message.radiusUnits);
    }
    if (message.feedItemSets?.length) {
      obj.feedItemSets = message.feedItemSets;
    }
    if (message.enableCustomerLevelLocationAssetSet !== undefined) {
      obj.enableCustomerLevelLocationAssetSet = message.enableCustomerLevelLocationAssetSet;
    }
    if (message.locationGroupAssetSets?.length) {
      obj.locationGroupAssetSets = message.locationGroupAssetSets;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationGroupInfo>): LocationGroupInfo {
    return LocationGroupInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationGroupInfo>): LocationGroupInfo {
    const message = createBaseLocationGroupInfo();
    message.feed = object.feed ?? undefined;
    message.geoTargetConstants = object.geoTargetConstants?.map((e) => e) || [];
    message.radius = (object.radius !== undefined && object.radius !== null)
      ? Long.fromValue(object.radius)
      : undefined;
    message.radiusUnits = object.radiusUnits ?? 0;
    message.feedItemSets = object.feedItemSets?.map((e) => e) || [];
    message.enableCustomerLevelLocationAssetSet = object.enableCustomerLevelLocationAssetSet ?? undefined;
    message.locationGroupAssetSets = object.locationGroupAssetSets?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomAudienceInfo(): CustomAudienceInfo {
  return { customAudience: "" };
}

export const CustomAudienceInfo: MessageFns<CustomAudienceInfo> = {
  encode(message: CustomAudienceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customAudience !== "") {
      writer.uint32(10).string(message.customAudience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAudienceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAudienceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customAudience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAudienceInfo {
    return { customAudience: isSet(object.customAudience) ? globalThis.String(object.customAudience) : "" };
  },

  toJSON(message: CustomAudienceInfo): unknown {
    const obj: any = {};
    if (message.customAudience !== "") {
      obj.customAudience = message.customAudience;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAudienceInfo>): CustomAudienceInfo {
    return CustomAudienceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAudienceInfo>): CustomAudienceInfo {
    const message = createBaseCustomAudienceInfo();
    message.customAudience = object.customAudience ?? "";
    return message;
  },
};

function createBaseCombinedAudienceInfo(): CombinedAudienceInfo {
  return { combinedAudience: "" };
}

export const CombinedAudienceInfo: MessageFns<CombinedAudienceInfo> = {
  encode(message: CombinedAudienceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.combinedAudience !== "") {
      writer.uint32(10).string(message.combinedAudience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CombinedAudienceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCombinedAudienceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.combinedAudience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CombinedAudienceInfo {
    return { combinedAudience: isSet(object.combinedAudience) ? globalThis.String(object.combinedAudience) : "" };
  },

  toJSON(message: CombinedAudienceInfo): unknown {
    const obj: any = {};
    if (message.combinedAudience !== "") {
      obj.combinedAudience = message.combinedAudience;
    }
    return obj;
  },

  create(base?: DeepPartial<CombinedAudienceInfo>): CombinedAudienceInfo {
    return CombinedAudienceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CombinedAudienceInfo>): CombinedAudienceInfo {
    const message = createBaseCombinedAudienceInfo();
    message.combinedAudience = object.combinedAudience ?? "";
    return message;
  },
};

function createBaseAudienceInfo(): AudienceInfo {
  return { audience: "" };
}

export const AudienceInfo: MessageFns<AudienceInfo> = {
  encode(message: AudienceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audience !== "") {
      writer.uint32(10).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInfo {
    return { audience: isSet(object.audience) ? globalThis.String(object.audience) : "" };
  },

  toJSON(message: AudienceInfo): unknown {
    const obj: any = {};
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInfo>): AudienceInfo {
    return AudienceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInfo>): AudienceInfo {
    const message = createBaseAudienceInfo();
    message.audience = object.audience ?? "";
    return message;
  },
};

function createBaseKeywordThemeInfo(): KeywordThemeInfo {
  return { keywordThemeConstant: undefined, freeFormKeywordTheme: undefined };
}

export const KeywordThemeInfo: MessageFns<KeywordThemeInfo> = {
  encode(message: KeywordThemeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keywordThemeConstant !== undefined) {
      writer.uint32(10).string(message.keywordThemeConstant);
    }
    if (message.freeFormKeywordTheme !== undefined) {
      writer.uint32(18).string(message.freeFormKeywordTheme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordThemeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordThemeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keywordThemeConstant = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.freeFormKeywordTheme = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordThemeInfo {
    return {
      keywordThemeConstant: isSet(object.keywordThemeConstant)
        ? globalThis.String(object.keywordThemeConstant)
        : undefined,
      freeFormKeywordTheme: isSet(object.freeFormKeywordTheme)
        ? globalThis.String(object.freeFormKeywordTheme)
        : undefined,
    };
  },

  toJSON(message: KeywordThemeInfo): unknown {
    const obj: any = {};
    if (message.keywordThemeConstant !== undefined) {
      obj.keywordThemeConstant = message.keywordThemeConstant;
    }
    if (message.freeFormKeywordTheme !== undefined) {
      obj.freeFormKeywordTheme = message.freeFormKeywordTheme;
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordThemeInfo>): KeywordThemeInfo {
    return KeywordThemeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordThemeInfo>): KeywordThemeInfo {
    const message = createBaseKeywordThemeInfo();
    message.keywordThemeConstant = object.keywordThemeConstant ?? undefined;
    message.freeFormKeywordTheme = object.freeFormKeywordTheme ?? undefined;
    return message;
  },
};

function createBaseLocalServiceIdInfo(): LocalServiceIdInfo {
  return { serviceId: "" };
}

export const LocalServiceIdInfo: MessageFns<LocalServiceIdInfo> = {
  encode(message: LocalServiceIdInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalServiceIdInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalServiceIdInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalServiceIdInfo {
    return { serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "" };
  },

  toJSON(message: LocalServiceIdInfo): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    return obj;
  },

  create(base?: DeepPartial<LocalServiceIdInfo>): LocalServiceIdInfo {
    return LocalServiceIdInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalServiceIdInfo>): LocalServiceIdInfo {
    const message = createBaseLocalServiceIdInfo();
    message.serviceId = object.serviceId ?? "";
    return message;
  },
};

function createBaseSearchThemeInfo(): SearchThemeInfo {
  return { text: "" };
}

export const SearchThemeInfo: MessageFns<SearchThemeInfo> = {
  encode(message: SearchThemeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchThemeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchThemeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchThemeInfo {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: SearchThemeInfo): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchThemeInfo>): SearchThemeInfo {
    return SearchThemeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchThemeInfo>): SearchThemeInfo {
    const message = createBaseSearchThemeInfo();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseBrandInfo(): BrandInfo {
  return {
    displayName: undefined,
    entityId: undefined,
    primaryUrl: undefined,
    rejectionReason: undefined,
    status: undefined,
  };
}

export const BrandInfo: MessageFns<BrandInfo> = {
  encode(message: BrandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== undefined) {
      writer.uint32(18).string(message.displayName);
    }
    if (message.entityId !== undefined) {
      writer.uint32(10).string(message.entityId);
    }
    if (message.primaryUrl !== undefined) {
      writer.uint32(26).string(message.primaryUrl);
    }
    if (message.rejectionReason !== undefined) {
      writer.uint32(32).int32(message.rejectionReason);
    }
    if (message.status !== undefined) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.primaryUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rejectionReason = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrandInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : undefined,
      primaryUrl: isSet(object.primaryUrl) ? globalThis.String(object.primaryUrl) : undefined,
      rejectionReason: isSet(object.rejectionReason)
        ? brandRequestRejectionReasonEnum_BrandRequestRejectionReasonFromJSON(object.rejectionReason)
        : undefined,
      status: isSet(object.status) ? brandStateEnum_BrandStateFromJSON(object.status) : undefined,
    };
  },

  toJSON(message: BrandInfo): unknown {
    const obj: any = {};
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.entityId !== undefined) {
      obj.entityId = message.entityId;
    }
    if (message.primaryUrl !== undefined) {
      obj.primaryUrl = message.primaryUrl;
    }
    if (message.rejectionReason !== undefined) {
      obj.rejectionReason = brandRequestRejectionReasonEnum_BrandRequestRejectionReasonToJSON(message.rejectionReason);
    }
    if (message.status !== undefined) {
      obj.status = brandStateEnum_BrandStateToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<BrandInfo>): BrandInfo {
    return BrandInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrandInfo>): BrandInfo {
    const message = createBaseBrandInfo();
    message.displayName = object.displayName ?? undefined;
    message.entityId = object.entityId ?? undefined;
    message.primaryUrl = object.primaryUrl ?? undefined;
    message.rejectionReason = object.rejectionReason ?? undefined;
    message.status = object.status ?? undefined;
    return message;
  },
};

function createBaseBrandListInfo(): BrandListInfo {
  return { sharedSet: undefined };
}

export const BrandListInfo: MessageFns<BrandListInfo> = {
  encode(message: BrandListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sharedSet !== undefined) {
      writer.uint32(10).string(message.sharedSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrandListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrandListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sharedSet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrandListInfo {
    return { sharedSet: isSet(object.sharedSet) ? globalThis.String(object.sharedSet) : undefined };
  },

  toJSON(message: BrandListInfo): unknown {
    const obj: any = {};
    if (message.sharedSet !== undefined) {
      obj.sharedSet = message.sharedSet;
    }
    return obj;
  },

  create(base?: DeepPartial<BrandListInfo>): BrandListInfo {
    return BrandListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrandListInfo>): BrandListInfo {
    const message = createBaseBrandListInfo();
    message.sharedSet = object.sharedSet ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
