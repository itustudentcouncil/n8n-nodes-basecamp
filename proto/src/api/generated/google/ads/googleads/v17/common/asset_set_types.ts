// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/common/asset_set_types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  ChainRelationshipTypeEnum_ChainRelationshipType,
  chainRelationshipTypeEnum_ChainRelationshipTypeFromJSON,
  chainRelationshipTypeEnum_ChainRelationshipTypeToJSON,
} from "../enums/chain_relationship_type.js";
import {
  LocationOwnershipTypeEnum_LocationOwnershipType,
  locationOwnershipTypeEnum_LocationOwnershipTypeFromJSON,
  locationOwnershipTypeEnum_LocationOwnershipTypeToJSON,
} from "../enums/location_ownership_type.js";
import {
  LocationStringFilterTypeEnum_LocationStringFilterType,
  locationStringFilterTypeEnum_LocationStringFilterTypeFromJSON,
  locationStringFilterTypeEnum_LocationStringFilterTypeToJSON,
} from "../enums/location_string_filter_type.js";

export const protobufPackage = "google.ads.googleads.v17.common";

/**
 * Data related to location set. One of the Google Business Profile (previously
 * known as Google My Business) data, Chain data, and map location data need to
 * be specified.
 */
export interface LocationSet {
  /**
   * Required. Immutable. Location Ownership Type (owned location or affiliate
   * location).
   */
  locationOwnershipType: LocationOwnershipTypeEnum_LocationOwnershipType;
  /**
   * Data used to configure a location set populated from Google Business
   * Profile locations.
   */
  businessProfileLocationSet?:
    | BusinessProfileLocationSet
    | undefined;
  /**
   * Data used to configure a location on chain set populated with the
   * specified chains.
   */
  chainLocationSet?:
    | ChainSet
    | undefined;
  /** Only set if locations are synced based on selected maps locations */
  mapsLocationSet?: MapsLocationSet | undefined;
}

/**
 * Data used to configure a location set populated from Google Business Profile
 * locations.
 * Different types of filters are AND'ed together, if they are specified.
 */
export interface BusinessProfileLocationSet {
  /**
   * Required. Immutable. The HTTP authorization token used to obtain
   * authorization.
   */
  httpAuthorizationToken: string;
  /**
   * Required. Immutable. Email address of a Google Business Profile account or
   * email address of a manager of the Google Business Profile account.
   */
  emailAddress: string;
  /**
   * Used to filter Google Business Profile listings by business name. If
   * businessNameFilter is set, only listings with a matching business name are
   * candidates to be sync'd into Assets.
   */
  businessNameFilter: string;
  /**
   * Used to filter Google Business Profile listings by labels. If entries exist
   * in labelFilters, only listings that have any of the labels set are
   * candidates to be synchronized into Assets. If no entries exist in
   * labelFilters, then all listings are candidates for syncing.
   * Label filters are OR'ed together.
   */
  labelFilters: string[];
  /**
   * Used to filter Google Business Profile listings by listing id. If entries
   * exist in listingIdFilters, only listings specified by the filters are
   * candidates to be synchronized into Assets. If no entries exist in
   * listingIdFilters, then all listings are candidates for syncing.
   * Listing ID filters are OR'ed together.
   */
  listingIdFilters: Long[];
  /**
   * Immutable. The account ID of the managed business whose locations are to be
   * used. If this field is not set, then all businesses accessible by the user
   * (specified by the emailAddress) are used.
   */
  businessAccountId: string;
}

/** Data used to configure a location set populated with the specified chains. */
export interface ChainSet {
  /**
   * Required. Immutable. Relationship type the specified chains have with this
   * advertiser.
   */
  relationshipType: ChainRelationshipTypeEnum_ChainRelationshipType;
  /** Required. A list of chain level filters, all filters are OR'ed together. */
  chains: ChainFilter[];
}

/**
 * One chain level filter on location in a feed item set.
 * The filtering logic among all the fields is AND.
 */
export interface ChainFilter {
  /**
   * Required. Used to filter chain locations by chain id. Only chain locations
   * that belong to the specified chain will be in the asset set.
   */
  chainId: Long;
  /**
   * Used to filter chain locations by location attributes.
   * Only chain locations that belong to all of the specified attribute(s) will
   * be in the asset set. If this field is empty, it means no filtering on this
   * field.
   */
  locationAttributes: string[];
}

/** Wrapper for multiple maps location sync data */
export interface MapsLocationSet {
  /** Required. A list of maps location info that user manually synced in. */
  mapsLocations: MapsLocationInfo[];
}

/** Wrapper for place ids */
export interface MapsLocationInfo {
  /** Place ID of the Maps location. */
  placeId: string;
}

/**
 * Information about a Business Profile dynamic location group.
 * Only applicable if the sync level AssetSet's type is LOCATION_SYNC and
 * sync source is Business Profile.
 */
export interface BusinessProfileLocationGroup {
  /** Filter for dynamic Business Profile location sets. */
  dynamicBusinessProfileLocationGroupFilter: DynamicBusinessProfileLocationGroupFilter | undefined;
}

/**
 * Represents a filter on Business Profile locations in an asset set. If
 * multiple filters are provided, they are AND'ed together.
 */
export interface DynamicBusinessProfileLocationGroupFilter {
  /**
   * Used to filter Business Profile locations by label. Only locations that
   * have any of the listed labels will be in the asset set.
   * Label filters are OR'ed together.
   */
  labelFilters: string[];
  /** Used to filter Business Profile locations by business name. */
  businessNameFilter?:
    | BusinessProfileBusinessNameFilter
    | undefined;
  /** Used to filter Business Profile locations by listing ids. */
  listingIdFilters: Long[];
}

/** Business Profile location group business name filter. */
export interface BusinessProfileBusinessNameFilter {
  /** Business name string to use for filtering. */
  businessName: string;
  /** The type of string matching to use when filtering with business_name. */
  filterType: LocationStringFilterTypeEnum_LocationStringFilterType;
}

/**
 * Represents information about a Chain dynamic location group.
 * Only applicable if the sync level AssetSet's type is LOCATION_SYNC and
 * sync source is chain.
 */
export interface ChainLocationGroup {
  /**
   * Used to filter chain locations by chain ids.
   * Only Locations that belong to the specified chain(s) will be in the asset
   * set.
   */
  dynamicChainLocationGroupFilters: ChainFilter[];
}

function createBaseLocationSet(): LocationSet {
  return {
    locationOwnershipType: 0,
    businessProfileLocationSet: undefined,
    chainLocationSet: undefined,
    mapsLocationSet: undefined,
  };
}

export const LocationSet: MessageFns<LocationSet> = {
  encode(message: LocationSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locationOwnershipType !== 0) {
      writer.uint32(24).int32(message.locationOwnershipType);
    }
    if (message.businessProfileLocationSet !== undefined) {
      BusinessProfileLocationSet.encode(message.businessProfileLocationSet, writer.uint32(10).fork()).join();
    }
    if (message.chainLocationSet !== undefined) {
      ChainSet.encode(message.chainLocationSet, writer.uint32(18).fork()).join();
    }
    if (message.mapsLocationSet !== undefined) {
      MapsLocationSet.encode(message.mapsLocationSet, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.locationOwnershipType = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.businessProfileLocationSet = BusinessProfileLocationSet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainLocationSet = ChainSet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mapsLocationSet = MapsLocationSet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationSet {
    return {
      locationOwnershipType: isSet(object.locationOwnershipType)
        ? locationOwnershipTypeEnum_LocationOwnershipTypeFromJSON(object.locationOwnershipType)
        : 0,
      businessProfileLocationSet: isSet(object.businessProfileLocationSet)
        ? BusinessProfileLocationSet.fromJSON(object.businessProfileLocationSet)
        : undefined,
      chainLocationSet: isSet(object.chainLocationSet) ? ChainSet.fromJSON(object.chainLocationSet) : undefined,
      mapsLocationSet: isSet(object.mapsLocationSet) ? MapsLocationSet.fromJSON(object.mapsLocationSet) : undefined,
    };
  },

  toJSON(message: LocationSet): unknown {
    const obj: any = {};
    if (message.locationOwnershipType !== 0) {
      obj.locationOwnershipType = locationOwnershipTypeEnum_LocationOwnershipTypeToJSON(message.locationOwnershipType);
    }
    if (message.businessProfileLocationSet !== undefined) {
      obj.businessProfileLocationSet = BusinessProfileLocationSet.toJSON(message.businessProfileLocationSet);
    }
    if (message.chainLocationSet !== undefined) {
      obj.chainLocationSet = ChainSet.toJSON(message.chainLocationSet);
    }
    if (message.mapsLocationSet !== undefined) {
      obj.mapsLocationSet = MapsLocationSet.toJSON(message.mapsLocationSet);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationSet>): LocationSet {
    return LocationSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationSet>): LocationSet {
    const message = createBaseLocationSet();
    message.locationOwnershipType = object.locationOwnershipType ?? 0;
    message.businessProfileLocationSet =
      (object.businessProfileLocationSet !== undefined && object.businessProfileLocationSet !== null)
        ? BusinessProfileLocationSet.fromPartial(object.businessProfileLocationSet)
        : undefined;
    message.chainLocationSet = (object.chainLocationSet !== undefined && object.chainLocationSet !== null)
      ? ChainSet.fromPartial(object.chainLocationSet)
      : undefined;
    message.mapsLocationSet = (object.mapsLocationSet !== undefined && object.mapsLocationSet !== null)
      ? MapsLocationSet.fromPartial(object.mapsLocationSet)
      : undefined;
    return message;
  },
};

function createBaseBusinessProfileLocationSet(): BusinessProfileLocationSet {
  return {
    httpAuthorizationToken: "",
    emailAddress: "",
    businessNameFilter: "",
    labelFilters: [],
    listingIdFilters: [],
    businessAccountId: "",
  };
}

export const BusinessProfileLocationSet: MessageFns<BusinessProfileLocationSet> = {
  encode(message: BusinessProfileLocationSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpAuthorizationToken !== "") {
      writer.uint32(10).string(message.httpAuthorizationToken);
    }
    if (message.emailAddress !== "") {
      writer.uint32(18).string(message.emailAddress);
    }
    if (message.businessNameFilter !== "") {
      writer.uint32(26).string(message.businessNameFilter);
    }
    for (const v of message.labelFilters) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.listingIdFilters) {
      writer.int64(v.toString());
    }
    writer.join();
    if (message.businessAccountId !== "") {
      writer.uint32(50).string(message.businessAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessProfileLocationSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessProfileLocationSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpAuthorizationToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.businessNameFilter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.labelFilters.push(reader.string());
          continue;
        case 5:
          if (tag === 40) {
            message.listingIdFilters.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.listingIdFilters.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.businessAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessProfileLocationSet {
    return {
      httpAuthorizationToken: isSet(object.httpAuthorizationToken)
        ? globalThis.String(object.httpAuthorizationToken)
        : "",
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : "",
      businessNameFilter: isSet(object.businessNameFilter) ? globalThis.String(object.businessNameFilter) : "",
      labelFilters: globalThis.Array.isArray(object?.labelFilters)
        ? object.labelFilters.map((e: any) => globalThis.String(e))
        : [],
      listingIdFilters: globalThis.Array.isArray(object?.listingIdFilters)
        ? object.listingIdFilters.map((e: any) => Long.fromValue(e))
        : [],
      businessAccountId: isSet(object.businessAccountId) ? globalThis.String(object.businessAccountId) : "",
    };
  },

  toJSON(message: BusinessProfileLocationSet): unknown {
    const obj: any = {};
    if (message.httpAuthorizationToken !== "") {
      obj.httpAuthorizationToken = message.httpAuthorizationToken;
    }
    if (message.emailAddress !== "") {
      obj.emailAddress = message.emailAddress;
    }
    if (message.businessNameFilter !== "") {
      obj.businessNameFilter = message.businessNameFilter;
    }
    if (message.labelFilters?.length) {
      obj.labelFilters = message.labelFilters;
    }
    if (message.listingIdFilters?.length) {
      obj.listingIdFilters = message.listingIdFilters.map((e) => (e || Long.ZERO).toString());
    }
    if (message.businessAccountId !== "") {
      obj.businessAccountId = message.businessAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessProfileLocationSet>): BusinessProfileLocationSet {
    return BusinessProfileLocationSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessProfileLocationSet>): BusinessProfileLocationSet {
    const message = createBaseBusinessProfileLocationSet();
    message.httpAuthorizationToken = object.httpAuthorizationToken ?? "";
    message.emailAddress = object.emailAddress ?? "";
    message.businessNameFilter = object.businessNameFilter ?? "";
    message.labelFilters = object.labelFilters?.map((e) => e) || [];
    message.listingIdFilters = object.listingIdFilters?.map((e) => Long.fromValue(e)) || [];
    message.businessAccountId = object.businessAccountId ?? "";
    return message;
  },
};

function createBaseChainSet(): ChainSet {
  return { relationshipType: 0, chains: [] };
}

export const ChainSet: MessageFns<ChainSet> = {
  encode(message: ChainSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relationshipType !== 0) {
      writer.uint32(8).int32(message.relationshipType);
    }
    for (const v of message.chains) {
      ChainFilter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.relationshipType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chains.push(ChainFilter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainSet {
    return {
      relationshipType: isSet(object.relationshipType)
        ? chainRelationshipTypeEnum_ChainRelationshipTypeFromJSON(object.relationshipType)
        : 0,
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => ChainFilter.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChainSet): unknown {
    const obj: any = {};
    if (message.relationshipType !== 0) {
      obj.relationshipType = chainRelationshipTypeEnum_ChainRelationshipTypeToJSON(message.relationshipType);
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => ChainFilter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChainSet>): ChainSet {
    return ChainSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainSet>): ChainSet {
    const message = createBaseChainSet();
    message.relationshipType = object.relationshipType ?? 0;
    message.chains = object.chains?.map((e) => ChainFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChainFilter(): ChainFilter {
  return { chainId: Long.ZERO, locationAttributes: [] };
}

export const ChainFilter: MessageFns<ChainFilter> = {
  encode(message: ChainFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.chainId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.chainId.toString());
    }
    for (const v of message.locationAttributes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chainId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.locationAttributes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainFilter {
    return {
      chainId: isSet(object.chainId) ? Long.fromValue(object.chainId) : Long.ZERO,
      locationAttributes: globalThis.Array.isArray(object?.locationAttributes)
        ? object.locationAttributes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ChainFilter): unknown {
    const obj: any = {};
    if (!message.chainId.equals(Long.ZERO)) {
      obj.chainId = (message.chainId || Long.ZERO).toString();
    }
    if (message.locationAttributes?.length) {
      obj.locationAttributes = message.locationAttributes;
    }
    return obj;
  },

  create(base?: DeepPartial<ChainFilter>): ChainFilter {
    return ChainFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainFilter>): ChainFilter {
    const message = createBaseChainFilter();
    message.chainId = (object.chainId !== undefined && object.chainId !== null)
      ? Long.fromValue(object.chainId)
      : Long.ZERO;
    message.locationAttributes = object.locationAttributes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMapsLocationSet(): MapsLocationSet {
  return { mapsLocations: [] };
}

export const MapsLocationSet: MessageFns<MapsLocationSet> = {
  encode(message: MapsLocationSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mapsLocations) {
      MapsLocationInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapsLocationSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapsLocationSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mapsLocations.push(MapsLocationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapsLocationSet {
    return {
      mapsLocations: globalThis.Array.isArray(object?.mapsLocations)
        ? object.mapsLocations.map((e: any) => MapsLocationInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MapsLocationSet): unknown {
    const obj: any = {};
    if (message.mapsLocations?.length) {
      obj.mapsLocations = message.mapsLocations.map((e) => MapsLocationInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MapsLocationSet>): MapsLocationSet {
    return MapsLocationSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapsLocationSet>): MapsLocationSet {
    const message = createBaseMapsLocationSet();
    message.mapsLocations = object.mapsLocations?.map((e) => MapsLocationInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMapsLocationInfo(): MapsLocationInfo {
  return { placeId: "" };
}

export const MapsLocationInfo: MessageFns<MapsLocationInfo> = {
  encode(message: MapsLocationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== "") {
      writer.uint32(10).string(message.placeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapsLocationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapsLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapsLocationInfo {
    return { placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "" };
  },

  toJSON(message: MapsLocationInfo): unknown {
    const obj: any = {};
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    return obj;
  },

  create(base?: DeepPartial<MapsLocationInfo>): MapsLocationInfo {
    return MapsLocationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapsLocationInfo>): MapsLocationInfo {
    const message = createBaseMapsLocationInfo();
    message.placeId = object.placeId ?? "";
    return message;
  },
};

function createBaseBusinessProfileLocationGroup(): BusinessProfileLocationGroup {
  return { dynamicBusinessProfileLocationGroupFilter: undefined };
}

export const BusinessProfileLocationGroup: MessageFns<BusinessProfileLocationGroup> = {
  encode(message: BusinessProfileLocationGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dynamicBusinessProfileLocationGroupFilter !== undefined) {
      DynamicBusinessProfileLocationGroupFilter.encode(
        message.dynamicBusinessProfileLocationGroupFilter,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessProfileLocationGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessProfileLocationGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dynamicBusinessProfileLocationGroupFilter = DynamicBusinessProfileLocationGroupFilter.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessProfileLocationGroup {
    return {
      dynamicBusinessProfileLocationGroupFilter: isSet(object.dynamicBusinessProfileLocationGroupFilter)
        ? DynamicBusinessProfileLocationGroupFilter.fromJSON(object.dynamicBusinessProfileLocationGroupFilter)
        : undefined,
    };
  },

  toJSON(message: BusinessProfileLocationGroup): unknown {
    const obj: any = {};
    if (message.dynamicBusinessProfileLocationGroupFilter !== undefined) {
      obj.dynamicBusinessProfileLocationGroupFilter = DynamicBusinessProfileLocationGroupFilter.toJSON(
        message.dynamicBusinessProfileLocationGroupFilter,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessProfileLocationGroup>): BusinessProfileLocationGroup {
    return BusinessProfileLocationGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessProfileLocationGroup>): BusinessProfileLocationGroup {
    const message = createBaseBusinessProfileLocationGroup();
    message.dynamicBusinessProfileLocationGroupFilter =
      (object.dynamicBusinessProfileLocationGroupFilter !== undefined &&
          object.dynamicBusinessProfileLocationGroupFilter !== null)
        ? DynamicBusinessProfileLocationGroupFilter.fromPartial(object.dynamicBusinessProfileLocationGroupFilter)
        : undefined;
    return message;
  },
};

function createBaseDynamicBusinessProfileLocationGroupFilter(): DynamicBusinessProfileLocationGroupFilter {
  return { labelFilters: [], businessNameFilter: undefined, listingIdFilters: [] };
}

export const DynamicBusinessProfileLocationGroupFilter: MessageFns<DynamicBusinessProfileLocationGroupFilter> = {
  encode(message: DynamicBusinessProfileLocationGroupFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labelFilters) {
      writer.uint32(10).string(v!);
    }
    if (message.businessNameFilter !== undefined) {
      BusinessProfileBusinessNameFilter.encode(message.businessNameFilter, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.listingIdFilters) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicBusinessProfileLocationGroupFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicBusinessProfileLocationGroupFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.labelFilters.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.businessNameFilter = BusinessProfileBusinessNameFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.listingIdFilters.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.listingIdFilters.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicBusinessProfileLocationGroupFilter {
    return {
      labelFilters: globalThis.Array.isArray(object?.labelFilters)
        ? object.labelFilters.map((e: any) => globalThis.String(e))
        : [],
      businessNameFilter: isSet(object.businessNameFilter)
        ? BusinessProfileBusinessNameFilter.fromJSON(object.businessNameFilter)
        : undefined,
      listingIdFilters: globalThis.Array.isArray(object?.listingIdFilters)
        ? object.listingIdFilters.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: DynamicBusinessProfileLocationGroupFilter): unknown {
    const obj: any = {};
    if (message.labelFilters?.length) {
      obj.labelFilters = message.labelFilters;
    }
    if (message.businessNameFilter !== undefined) {
      obj.businessNameFilter = BusinessProfileBusinessNameFilter.toJSON(message.businessNameFilter);
    }
    if (message.listingIdFilters?.length) {
      obj.listingIdFilters = message.listingIdFilters.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(base?: DeepPartial<DynamicBusinessProfileLocationGroupFilter>): DynamicBusinessProfileLocationGroupFilter {
    return DynamicBusinessProfileLocationGroupFilter.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DynamicBusinessProfileLocationGroupFilter>,
  ): DynamicBusinessProfileLocationGroupFilter {
    const message = createBaseDynamicBusinessProfileLocationGroupFilter();
    message.labelFilters = object.labelFilters?.map((e) => e) || [];
    message.businessNameFilter = (object.businessNameFilter !== undefined && object.businessNameFilter !== null)
      ? BusinessProfileBusinessNameFilter.fromPartial(object.businessNameFilter)
      : undefined;
    message.listingIdFilters = object.listingIdFilters?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseBusinessProfileBusinessNameFilter(): BusinessProfileBusinessNameFilter {
  return { businessName: "", filterType: 0 };
}

export const BusinessProfileBusinessNameFilter: MessageFns<BusinessProfileBusinessNameFilter> = {
  encode(message: BusinessProfileBusinessNameFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.businessName !== "") {
      writer.uint32(10).string(message.businessName);
    }
    if (message.filterType !== 0) {
      writer.uint32(16).int32(message.filterType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessProfileBusinessNameFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessProfileBusinessNameFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.businessName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.filterType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessProfileBusinessNameFilter {
    return {
      businessName: isSet(object.businessName) ? globalThis.String(object.businessName) : "",
      filterType: isSet(object.filterType)
        ? locationStringFilterTypeEnum_LocationStringFilterTypeFromJSON(object.filterType)
        : 0,
    };
  },

  toJSON(message: BusinessProfileBusinessNameFilter): unknown {
    const obj: any = {};
    if (message.businessName !== "") {
      obj.businessName = message.businessName;
    }
    if (message.filterType !== 0) {
      obj.filterType = locationStringFilterTypeEnum_LocationStringFilterTypeToJSON(message.filterType);
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessProfileBusinessNameFilter>): BusinessProfileBusinessNameFilter {
    return BusinessProfileBusinessNameFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessProfileBusinessNameFilter>): BusinessProfileBusinessNameFilter {
    const message = createBaseBusinessProfileBusinessNameFilter();
    message.businessName = object.businessName ?? "";
    message.filterType = object.filterType ?? 0;
    return message;
  },
};

function createBaseChainLocationGroup(): ChainLocationGroup {
  return { dynamicChainLocationGroupFilters: [] };
}

export const ChainLocationGroup: MessageFns<ChainLocationGroup> = {
  encode(message: ChainLocationGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dynamicChainLocationGroupFilters) {
      ChainFilter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainLocationGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainLocationGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dynamicChainLocationGroupFilters.push(ChainFilter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainLocationGroup {
    return {
      dynamicChainLocationGroupFilters: globalThis.Array.isArray(object?.dynamicChainLocationGroupFilters)
        ? object.dynamicChainLocationGroupFilters.map((e: any) => ChainFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChainLocationGroup): unknown {
    const obj: any = {};
    if (message.dynamicChainLocationGroupFilters?.length) {
      obj.dynamicChainLocationGroupFilters = message.dynamicChainLocationGroupFilters.map((e) => ChainFilter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChainLocationGroup>): ChainLocationGroup {
    return ChainLocationGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChainLocationGroup>): ChainLocationGroup {
    const message = createBaseChainLocationGroup();
    message.dynamicChainLocationGroupFilters =
      object.dynamicChainLocationGroupFilters?.map((e) => ChainFilter.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
