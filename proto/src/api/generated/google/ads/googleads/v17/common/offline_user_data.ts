// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/common/offline_user_data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  UserIdentifierSourceEnum_UserIdentifierSource,
  userIdentifierSourceEnum_UserIdentifierSourceFromJSON,
  userIdentifierSourceEnum_UserIdentifierSourceToJSON,
} from "../enums/user_identifier_source.js";
import { Consent } from "./consent.js";

export const protobufPackage = "google.ads.googleads.v17.common";

/** Address identifier of offline data. */
export interface OfflineUserAddressInfo {
  /**
   * First name of the user, which is hashed as SHA-256 after normalized
   * (Lowercase all characters; Remove any extra spaces before, after, and in
   * between).
   */
  hashedFirstName?:
    | string
    | undefined;
  /**
   * Last name of the user, which is hashed as SHA-256 after normalized (lower
   * case only and no punctuation).
   */
  hashedLastName?:
    | string
    | undefined;
  /**
   * City of the address. Only accepted for Store Sales and
   * ConversionAdjustmentUploadService.
   */
  city?:
    | string
    | undefined;
  /**
   * State code of the address. Only accepted for Store Sales and
   * ConversionAdjustmentUploadService.
   */
  state?:
    | string
    | undefined;
  /** 2-letter country code in ISO-3166-1 alpha-2 of the user's address. */
  countryCode?:
    | string
    | undefined;
  /** Postal code of the user's address. */
  postalCode?:
    | string
    | undefined;
  /**
   * The street address of the user hashed using SHA-256 hash function after
   * normalization (lower case only). Only accepted for
   * ConversionAdjustmentUploadService.
   */
  hashedStreetAddress?: string | undefined;
}

/** User identifying information. */
export interface UserIdentifier {
  /**
   * Source of the user identifier when the upload is from Store Sales,
   * ConversionUploadService, or ConversionAdjustmentUploadService.
   */
  userIdentifierSource: UserIdentifierSourceEnum_UserIdentifierSource;
  /**
   * Hashed email address using SHA-256 hash function after normalization.
   * Accepted for Customer Match, Store Sales, ConversionUploadService, and
   * ConversionAdjustmentUploadService.
   */
  hashedEmail?:
    | string
    | undefined;
  /**
   * Hashed phone number using SHA-256 hash function after normalization
   * (E164 standard). Accepted for Customer Match, Store Sales,
   * ConversionUploadService, and ConversionAdjustmentUploadService.
   */
  hashedPhoneNumber?:
    | string
    | undefined;
  /** Mobile device ID (advertising ID/IDFA). Accepted only for Customer Match. */
  mobileId?:
    | string
    | undefined;
  /**
   * Advertiser-assigned user ID for Customer Match upload, or
   * third-party-assigned user ID for Store Sales. Accepted only for Customer
   * Match and Store Sales.
   */
  thirdPartyUserId?:
    | string
    | undefined;
  /**
   * Address information. Accepted only for Customer Match, Store Sales, and
   * ConversionAdjustmentUploadService.
   */
  addressInfo?: OfflineUserAddressInfo | undefined;
}

/** Attribute of the store sales transaction. */
export interface TransactionAttribute {
  /**
   * Timestamp when transaction occurred. Required.
   * The format is "YYYY-MM-DD HH:MM:SS[+/-HH:MM]", where [+/-HH:MM] is an
   * optional timezone offset from UTC. If the offset is absent, the API will
   * use the account's timezone as default.
   * Examples: "2018-03-05 09:15:00" or "2018-02-01 14:34:30+03:00"
   */
  transactionDateTime?:
    | string
    | undefined;
  /**
   * Transaction amount in micros. Required.
   * Transaction amount in micros needs to be greater than 1000.
   * If item Attributes are provided, it represents the total value of the
   * items, after multiplying the unit price per item by the quantity provided
   * in the ItemAttributes.
   */
  transactionAmountMicros?:
    | number
    | undefined;
  /** Transaction currency code. ISO 4217 three-letter code is used. Required. */
  currencyCode?:
    | string
    | undefined;
  /**
   * The resource name of conversion action to report conversions to.
   * Required.
   */
  conversionAction?:
    | string
    | undefined;
  /**
   * Transaction order id.
   * Accessible only to customers on the allow-list.
   */
  orderId?:
    | string
    | undefined;
  /**
   * Store attributes of the transaction.
   * Accessible only to customers on the allow-list.
   */
  storeAttribute:
    | StoreAttribute
    | undefined;
  /**
   * Value of the custom variable for each transaction.
   * Accessible only to customers on the allow-list.
   */
  customValue?:
    | string
    | undefined;
  /** Item attributes of the transaction. */
  itemAttribute: ItemAttribute | undefined;
}

/** Store attributes of the transaction. */
export interface StoreAttribute {
  /**
   * Store code from
   * https://support.google.com/business/answer/3370250#storecode
   */
  storeCode?: string | undefined;
}

/** Item attributes of the transaction. */
export interface ItemAttribute {
  /**
   * A unique identifier of a product. It can be either the Merchant Center Item
   * ID or GTIN (Global Trade Item Number).
   */
  itemId: string;
  /** ID of the Merchant Center Account. */
  merchantId?:
    | Long
    | undefined;
  /**
   * Common Locale Data Repository (CLDR) territory code of the country
   * associated with the feed where your items are uploaded. See
   * https://developers.google.com/google-ads/api/reference/data/codes-formats#country-codes
   * for more information.
   */
  countryCode: string;
  /**
   * ISO 639-1 code of the language associated with the feed where your items
   * are uploaded
   */
  languageCode: string;
  /** The number of items sold. Defaults to 1 if not set. */
  quantity: Long;
}

/** User data holding user identifiers and attributes. */
export interface UserData {
  /** User identification info. Required. */
  userIdentifiers: UserIdentifier[];
  /**
   * Additional transactions/attributes associated with the user.
   * Required when updating store sales data.
   */
  transactionAttribute:
    | TransactionAttribute
    | undefined;
  /**
   * Additional attributes associated with the user. Required when updating
   * customer match attributes. These have an expiration of 540 days.
   */
  userAttribute:
    | UserAttribute
    | undefined;
  /**
   * The consent setting for the user. Customer match will ignore this field
   * and return a warning.
   */
  consent?: Consent | undefined;
}

/**
 * User attribute, can only be used with CUSTOMER_MATCH_WITH_ATTRIBUTES job
 * type.
 */
export interface UserAttribute {
  /** Advertiser defined lifetime value for the user. */
  lifetimeValueMicros?:
    | Long
    | undefined;
  /**
   * Advertiser defined lifetime value bucket for the user. The valid range for
   * a lifetime value bucket is from 1 (low) to 10 (high), except for remove
   * operation where 0 will also be accepted.
   */
  lifetimeValueBucket?:
    | number
    | undefined;
  /**
   * Timestamp of the last purchase made by the user.
   * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
   * optional timezone offset from UTC. If the offset is absent, the API will
   * use the account's timezone as default.
   */
  lastPurchaseDateTime: string;
  /**
   * Advertiser defined average number of purchases that are made by the user in
   * a 30 day period.
   */
  averagePurchaseCount: number;
  /** Advertiser defined average purchase value in micros for the user. */
  averagePurchaseValueMicros: Long;
  /**
   * Timestamp when the user was acquired.
   * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
   * optional timezone offset from UTC. If the offset is absent, the API will
   * use the account's timezone as default.
   */
  acquisitionDateTime: string;
  /**
   * The shopping loyalty related data. Shopping utilizes this data to provide
   * users with a better experience. Accessible only to merchants on the
   * allow-list with the user's consent.
   */
  shoppingLoyalty?:
    | ShoppingLoyalty
    | undefined;
  /**
   * Optional. Advertiser defined lifecycle stage for the user. The accepted
   * values are "Lead", "Active" and "Churned".
   */
  lifecycleStage: string;
  /**
   * Optional. Timestamp of the first purchase made by the user.
   * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
   * optional timezone offset from UTC. If the offset is absent, the API will
   * use the account's timezone as default.
   */
  firstPurchaseDateTime: string;
  /**
   * Optional. Advertiser defined events and their attributes. All the values in
   * the nested fields are required. Currently this field is in beta.
   */
  eventAttribute: EventAttribute[];
}

/**
 * Advertiser defined events and their attributes. All the values in the
 * nested fields are required.
 */
export interface EventAttribute {
  /**
   * Required. Advertiser defined event to be used for remarketing. The accepted
   * values are "Viewed", "Cart", "Purchased" and "Recommended".
   */
  event: string;
  /**
   * Required. Timestamp at which the event happened.
   * The format is YYYY-MM-DD HH:MM:SS[+/-HH:MM], where [+/-HH:MM] is an
   * optional timezone offset from UTC. If the offset is absent, the API will
   * use the account's timezone as default.
   */
  eventDateTime: string;
  /** Required. Item attributes of the event. */
  itemAttribute: EventItemAttribute[];
}

/** Event Item attributes of the Customer Match. */
export interface EventItemAttribute {
  /**
   * Optional. A unique identifier of a product. It can be either the Merchant
   * Center Item ID or GTIN (Global Trade Item Number).
   */
  itemId: string;
}

/**
 * The shopping loyalty related data. Shopping utilizes this data to provide
 * users with a better experience.
 * Accessible only to merchants on the allow-list.
 */
export interface ShoppingLoyalty {
  /**
   * The membership tier. It is a free-form string as each merchant may have
   * their own loyalty system. For example, it could be a number from 1 to 10,
   * or a string such as "Golden" or "Silver", or even empty string "".
   */
  loyaltyTier?: string | undefined;
}

/** Metadata for customer match user list. */
export interface CustomerMatchUserListMetadata {
  /**
   * The resource name of remarketing list to update data.
   * Required for job of CUSTOMER_MATCH_USER_LIST type.
   */
  userList?:
    | string
    | undefined;
  /** The consent setting for all the users in this job. */
  consent?: Consent | undefined;
}

/** Metadata for Store Sales Direct. */
export interface StoreSalesMetadata {
  /**
   * This is the fraction of all transactions that are identifiable (for
   * example, associated with any form of customer information). Required. The
   * fraction needs to be between 0 and 1 (excluding 0).
   */
  loyaltyFraction?:
    | number
    | undefined;
  /**
   * This is the ratio of sales being uploaded compared to the overall sales
   * that can be associated with a customer. Required.
   * The fraction needs to be between 0 and 1 (excluding 0). For example, if you
   * upload half the sales that you are able to associate with a customer, this
   * would be 0.5.
   */
  transactionUploadFraction?:
    | number
    | undefined;
  /**
   * Name of the store sales custom variable key. A predefined key that
   * can be applied to the transaction and then later used for custom
   * segmentation in reporting.
   * Accessible only to customers on the allow-list.
   */
  customKey?:
    | string
    | undefined;
  /** Metadata for a third party Store Sales upload. */
  thirdPartyMetadata: StoreSalesThirdPartyMetadata | undefined;
}

/**
 * Metadata for a third party Store Sales.
 * This product is only for customers on the allow-list. Contact your
 * Google business development representative for details on the upload
 * configuration.
 */
export interface StoreSalesThirdPartyMetadata {
  /**
   * Time the advertiser uploaded the data to the partner. Required.
   * The format is "YYYY-MM-DD HH:MM:SS".
   * Examples: "2018-03-05 09:15:00" or "2018-02-01 14:34:30"
   */
  advertiserUploadDateTime?:
    | string
    | undefined;
  /**
   * The fraction of transactions that are valid. Invalid transactions may
   * include invalid formats or values.
   * Required.
   * The fraction needs to be between 0 and 1 (excluding 0).
   */
  validTransactionFraction?:
    | number
    | undefined;
  /**
   * The fraction of valid transactions that are matched to a third party
   * assigned user ID on the partner side.
   * Required.
   * The fraction needs to be between 0 and 1 (excluding 0).
   */
  partnerMatchFraction?:
    | number
    | undefined;
  /**
   * The fraction of valid transactions that are uploaded by the partner to
   * Google.
   * Required.
   * The fraction needs to be between 0 and 1 (excluding 0).
   */
  partnerUploadFraction?:
    | number
    | undefined;
  /** Version of partner IDs to be used for uploads. Required. */
  bridgeMapVersionId?:
    | string
    | undefined;
  /** ID of the third party partner updating the transaction feed. */
  partnerId?: Long | undefined;
}

function createBaseOfflineUserAddressInfo(): OfflineUserAddressInfo {
  return {
    hashedFirstName: undefined,
    hashedLastName: undefined,
    city: undefined,
    state: undefined,
    countryCode: undefined,
    postalCode: undefined,
    hashedStreetAddress: undefined,
  };
}

export const OfflineUserAddressInfo: MessageFns<OfflineUserAddressInfo> = {
  encode(message: OfflineUserAddressInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashedFirstName !== undefined) {
      writer.uint32(58).string(message.hashedFirstName);
    }
    if (message.hashedLastName !== undefined) {
      writer.uint32(66).string(message.hashedLastName);
    }
    if (message.city !== undefined) {
      writer.uint32(74).string(message.city);
    }
    if (message.state !== undefined) {
      writer.uint32(82).string(message.state);
    }
    if (message.countryCode !== undefined) {
      writer.uint32(90).string(message.countryCode);
    }
    if (message.postalCode !== undefined) {
      writer.uint32(98).string(message.postalCode);
    }
    if (message.hashedStreetAddress !== undefined) {
      writer.uint32(106).string(message.hashedStreetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OfflineUserAddressInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOfflineUserAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hashedFirstName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.hashedLastName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.city = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.state = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.hashedStreetAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OfflineUserAddressInfo {
    return {
      hashedFirstName: isSet(object.hashedFirstName) ? globalThis.String(object.hashedFirstName) : undefined,
      hashedLastName: isSet(object.hashedLastName) ? globalThis.String(object.hashedLastName) : undefined,
      city: isSet(object.city) ? globalThis.String(object.city) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : undefined,
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : undefined,
      hashedStreetAddress: isSet(object.hashedStreetAddress)
        ? globalThis.String(object.hashedStreetAddress)
        : undefined,
    };
  },

  toJSON(message: OfflineUserAddressInfo): unknown {
    const obj: any = {};
    if (message.hashedFirstName !== undefined) {
      obj.hashedFirstName = message.hashedFirstName;
    }
    if (message.hashedLastName !== undefined) {
      obj.hashedLastName = message.hashedLastName;
    }
    if (message.city !== undefined) {
      obj.city = message.city;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.countryCode !== undefined) {
      obj.countryCode = message.countryCode;
    }
    if (message.postalCode !== undefined) {
      obj.postalCode = message.postalCode;
    }
    if (message.hashedStreetAddress !== undefined) {
      obj.hashedStreetAddress = message.hashedStreetAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<OfflineUserAddressInfo>): OfflineUserAddressInfo {
    return OfflineUserAddressInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OfflineUserAddressInfo>): OfflineUserAddressInfo {
    const message = createBaseOfflineUserAddressInfo();
    message.hashedFirstName = object.hashedFirstName ?? undefined;
    message.hashedLastName = object.hashedLastName ?? undefined;
    message.city = object.city ?? undefined;
    message.state = object.state ?? undefined;
    message.countryCode = object.countryCode ?? undefined;
    message.postalCode = object.postalCode ?? undefined;
    message.hashedStreetAddress = object.hashedStreetAddress ?? undefined;
    return message;
  },
};

function createBaseUserIdentifier(): UserIdentifier {
  return {
    userIdentifierSource: 0,
    hashedEmail: undefined,
    hashedPhoneNumber: undefined,
    mobileId: undefined,
    thirdPartyUserId: undefined,
    addressInfo: undefined,
  };
}

export const UserIdentifier: MessageFns<UserIdentifier> = {
  encode(message: UserIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userIdentifierSource !== 0) {
      writer.uint32(48).int32(message.userIdentifierSource);
    }
    if (message.hashedEmail !== undefined) {
      writer.uint32(58).string(message.hashedEmail);
    }
    if (message.hashedPhoneNumber !== undefined) {
      writer.uint32(66).string(message.hashedPhoneNumber);
    }
    if (message.mobileId !== undefined) {
      writer.uint32(74).string(message.mobileId);
    }
    if (message.thirdPartyUserId !== undefined) {
      writer.uint32(82).string(message.thirdPartyUserId);
    }
    if (message.addressInfo !== undefined) {
      OfflineUserAddressInfo.encode(message.addressInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.userIdentifierSource = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hashedEmail = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.hashedPhoneNumber = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.mobileId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.thirdPartyUserId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addressInfo = OfflineUserAddressInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserIdentifier {
    return {
      userIdentifierSource: isSet(object.userIdentifierSource)
        ? userIdentifierSourceEnum_UserIdentifierSourceFromJSON(object.userIdentifierSource)
        : 0,
      hashedEmail: isSet(object.hashedEmail) ? globalThis.String(object.hashedEmail) : undefined,
      hashedPhoneNumber: isSet(object.hashedPhoneNumber) ? globalThis.String(object.hashedPhoneNumber) : undefined,
      mobileId: isSet(object.mobileId) ? globalThis.String(object.mobileId) : undefined,
      thirdPartyUserId: isSet(object.thirdPartyUserId) ? globalThis.String(object.thirdPartyUserId) : undefined,
      addressInfo: isSet(object.addressInfo) ? OfflineUserAddressInfo.fromJSON(object.addressInfo) : undefined,
    };
  },

  toJSON(message: UserIdentifier): unknown {
    const obj: any = {};
    if (message.userIdentifierSource !== 0) {
      obj.userIdentifierSource = userIdentifierSourceEnum_UserIdentifierSourceToJSON(message.userIdentifierSource);
    }
    if (message.hashedEmail !== undefined) {
      obj.hashedEmail = message.hashedEmail;
    }
    if (message.hashedPhoneNumber !== undefined) {
      obj.hashedPhoneNumber = message.hashedPhoneNumber;
    }
    if (message.mobileId !== undefined) {
      obj.mobileId = message.mobileId;
    }
    if (message.thirdPartyUserId !== undefined) {
      obj.thirdPartyUserId = message.thirdPartyUserId;
    }
    if (message.addressInfo !== undefined) {
      obj.addressInfo = OfflineUserAddressInfo.toJSON(message.addressInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<UserIdentifier>): UserIdentifier {
    return UserIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserIdentifier>): UserIdentifier {
    const message = createBaseUserIdentifier();
    message.userIdentifierSource = object.userIdentifierSource ?? 0;
    message.hashedEmail = object.hashedEmail ?? undefined;
    message.hashedPhoneNumber = object.hashedPhoneNumber ?? undefined;
    message.mobileId = object.mobileId ?? undefined;
    message.thirdPartyUserId = object.thirdPartyUserId ?? undefined;
    message.addressInfo = (object.addressInfo !== undefined && object.addressInfo !== null)
      ? OfflineUserAddressInfo.fromPartial(object.addressInfo)
      : undefined;
    return message;
  },
};

function createBaseTransactionAttribute(): TransactionAttribute {
  return {
    transactionDateTime: undefined,
    transactionAmountMicros: undefined,
    currencyCode: undefined,
    conversionAction: undefined,
    orderId: undefined,
    storeAttribute: undefined,
    customValue: undefined,
    itemAttribute: undefined,
  };
}

export const TransactionAttribute: MessageFns<TransactionAttribute> = {
  encode(message: TransactionAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionDateTime !== undefined) {
      writer.uint32(66).string(message.transactionDateTime);
    }
    if (message.transactionAmountMicros !== undefined) {
      writer.uint32(73).double(message.transactionAmountMicros);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(82).string(message.currencyCode);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(90).string(message.conversionAction);
    }
    if (message.orderId !== undefined) {
      writer.uint32(98).string(message.orderId);
    }
    if (message.storeAttribute !== undefined) {
      StoreAttribute.encode(message.storeAttribute, writer.uint32(50).fork()).join();
    }
    if (message.customValue !== undefined) {
      writer.uint32(106).string(message.customValue);
    }
    if (message.itemAttribute !== undefined) {
      ItemAttribute.encode(message.itemAttribute, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transactionDateTime = reader.string();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.transactionAmountMicros = reader.double();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.storeAttribute = StoreAttribute.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customValue = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.itemAttribute = ItemAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionAttribute {
    return {
      transactionDateTime: isSet(object.transactionDateTime)
        ? globalThis.String(object.transactionDateTime)
        : undefined,
      transactionAmountMicros: isSet(object.transactionAmountMicros)
        ? globalThis.Number(object.transactionAmountMicros)
        : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : undefined,
      storeAttribute: isSet(object.storeAttribute) ? StoreAttribute.fromJSON(object.storeAttribute) : undefined,
      customValue: isSet(object.customValue) ? globalThis.String(object.customValue) : undefined,
      itemAttribute: isSet(object.itemAttribute) ? ItemAttribute.fromJSON(object.itemAttribute) : undefined,
    };
  },

  toJSON(message: TransactionAttribute): unknown {
    const obj: any = {};
    if (message.transactionDateTime !== undefined) {
      obj.transactionDateTime = message.transactionDateTime;
    }
    if (message.transactionAmountMicros !== undefined) {
      obj.transactionAmountMicros = message.transactionAmountMicros;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.orderId !== undefined) {
      obj.orderId = message.orderId;
    }
    if (message.storeAttribute !== undefined) {
      obj.storeAttribute = StoreAttribute.toJSON(message.storeAttribute);
    }
    if (message.customValue !== undefined) {
      obj.customValue = message.customValue;
    }
    if (message.itemAttribute !== undefined) {
      obj.itemAttribute = ItemAttribute.toJSON(message.itemAttribute);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionAttribute>): TransactionAttribute {
    return TransactionAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionAttribute>): TransactionAttribute {
    const message = createBaseTransactionAttribute();
    message.transactionDateTime = object.transactionDateTime ?? undefined;
    message.transactionAmountMicros = object.transactionAmountMicros ?? undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    message.conversionAction = object.conversionAction ?? undefined;
    message.orderId = object.orderId ?? undefined;
    message.storeAttribute = (object.storeAttribute !== undefined && object.storeAttribute !== null)
      ? StoreAttribute.fromPartial(object.storeAttribute)
      : undefined;
    message.customValue = object.customValue ?? undefined;
    message.itemAttribute = (object.itemAttribute !== undefined && object.itemAttribute !== null)
      ? ItemAttribute.fromPartial(object.itemAttribute)
      : undefined;
    return message;
  },
};

function createBaseStoreAttribute(): StoreAttribute {
  return { storeCode: undefined };
}

export const StoreAttribute: MessageFns<StoreAttribute> = {
  encode(message: StoreAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.storeCode !== undefined) {
      writer.uint32(18).string(message.storeCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storeCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreAttribute {
    return { storeCode: isSet(object.storeCode) ? globalThis.String(object.storeCode) : undefined };
  },

  toJSON(message: StoreAttribute): unknown {
    const obj: any = {};
    if (message.storeCode !== undefined) {
      obj.storeCode = message.storeCode;
    }
    return obj;
  },

  create(base?: DeepPartial<StoreAttribute>): StoreAttribute {
    return StoreAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoreAttribute>): StoreAttribute {
    const message = createBaseStoreAttribute();
    message.storeCode = object.storeCode ?? undefined;
    return message;
  },
};

function createBaseItemAttribute(): ItemAttribute {
  return { itemId: "", merchantId: undefined, countryCode: "", languageCode: "", quantity: Long.ZERO };
}

export const ItemAttribute: MessageFns<ItemAttribute> = {
  encode(message: ItemAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    if (message.merchantId !== undefined) {
      writer.uint32(16).int64(message.merchantId.toString());
    }
    if (message.countryCode !== "") {
      writer.uint32(26).string(message.countryCode);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (!message.quantity.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.quantity.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.merchantId = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.quantity = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemAttribute {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      merchantId: isSet(object.merchantId) ? Long.fromValue(object.merchantId) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      quantity: isSet(object.quantity) ? Long.fromValue(object.quantity) : Long.ZERO,
    };
  },

  toJSON(message: ItemAttribute): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.merchantId !== undefined) {
      obj.merchantId = (message.merchantId || Long.ZERO).toString();
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (!message.quantity.equals(Long.ZERO)) {
      obj.quantity = (message.quantity || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ItemAttribute>): ItemAttribute {
    return ItemAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ItemAttribute>): ItemAttribute {
    const message = createBaseItemAttribute();
    message.itemId = object.itemId ?? "";
    message.merchantId = (object.merchantId !== undefined && object.merchantId !== null)
      ? Long.fromValue(object.merchantId)
      : undefined;
    message.countryCode = object.countryCode ?? "";
    message.languageCode = object.languageCode ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Long.fromValue(object.quantity)
      : Long.ZERO;
    return message;
  },
};

function createBaseUserData(): UserData {
  return { userIdentifiers: [], transactionAttribute: undefined, userAttribute: undefined, consent: undefined };
}

export const UserData: MessageFns<UserData> = {
  encode(message: UserData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userIdentifiers) {
      UserIdentifier.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.transactionAttribute !== undefined) {
      TransactionAttribute.encode(message.transactionAttribute, writer.uint32(18).fork()).join();
    }
    if (message.userAttribute !== undefined) {
      UserAttribute.encode(message.userAttribute, writer.uint32(26).fork()).join();
    }
    if (message.consent !== undefined) {
      Consent.encode(message.consent, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userIdentifiers.push(UserIdentifier.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionAttribute = TransactionAttribute.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAttribute = UserAttribute.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.consent = Consent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserData {
    return {
      userIdentifiers: globalThis.Array.isArray(object?.userIdentifiers)
        ? object.userIdentifiers.map((e: any) => UserIdentifier.fromJSON(e))
        : [],
      transactionAttribute: isSet(object.transactionAttribute)
        ? TransactionAttribute.fromJSON(object.transactionAttribute)
        : undefined,
      userAttribute: isSet(object.userAttribute) ? UserAttribute.fromJSON(object.userAttribute) : undefined,
      consent: isSet(object.consent) ? Consent.fromJSON(object.consent) : undefined,
    };
  },

  toJSON(message: UserData): unknown {
    const obj: any = {};
    if (message.userIdentifiers?.length) {
      obj.userIdentifiers = message.userIdentifiers.map((e) => UserIdentifier.toJSON(e));
    }
    if (message.transactionAttribute !== undefined) {
      obj.transactionAttribute = TransactionAttribute.toJSON(message.transactionAttribute);
    }
    if (message.userAttribute !== undefined) {
      obj.userAttribute = UserAttribute.toJSON(message.userAttribute);
    }
    if (message.consent !== undefined) {
      obj.consent = Consent.toJSON(message.consent);
    }
    return obj;
  },

  create(base?: DeepPartial<UserData>): UserData {
    return UserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserData>): UserData {
    const message = createBaseUserData();
    message.userIdentifiers = object.userIdentifiers?.map((e) => UserIdentifier.fromPartial(e)) || [];
    message.transactionAttribute = (object.transactionAttribute !== undefined && object.transactionAttribute !== null)
      ? TransactionAttribute.fromPartial(object.transactionAttribute)
      : undefined;
    message.userAttribute = (object.userAttribute !== undefined && object.userAttribute !== null)
      ? UserAttribute.fromPartial(object.userAttribute)
      : undefined;
    message.consent = (object.consent !== undefined && object.consent !== null)
      ? Consent.fromPartial(object.consent)
      : undefined;
    return message;
  },
};

function createBaseUserAttribute(): UserAttribute {
  return {
    lifetimeValueMicros: undefined,
    lifetimeValueBucket: undefined,
    lastPurchaseDateTime: "",
    averagePurchaseCount: 0,
    averagePurchaseValueMicros: Long.ZERO,
    acquisitionDateTime: "",
    shoppingLoyalty: undefined,
    lifecycleStage: "",
    firstPurchaseDateTime: "",
    eventAttribute: [],
  };
}

export const UserAttribute: MessageFns<UserAttribute> = {
  encode(message: UserAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lifetimeValueMicros !== undefined) {
      writer.uint32(8).int64(message.lifetimeValueMicros.toString());
    }
    if (message.lifetimeValueBucket !== undefined) {
      writer.uint32(16).int32(message.lifetimeValueBucket);
    }
    if (message.lastPurchaseDateTime !== "") {
      writer.uint32(26).string(message.lastPurchaseDateTime);
    }
    if (message.averagePurchaseCount !== 0) {
      writer.uint32(32).int32(message.averagePurchaseCount);
    }
    if (!message.averagePurchaseValueMicros.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.averagePurchaseValueMicros.toString());
    }
    if (message.acquisitionDateTime !== "") {
      writer.uint32(50).string(message.acquisitionDateTime);
    }
    if (message.shoppingLoyalty !== undefined) {
      ShoppingLoyalty.encode(message.shoppingLoyalty, writer.uint32(58).fork()).join();
    }
    if (message.lifecycleStage !== "") {
      writer.uint32(66).string(message.lifecycleStage);
    }
    if (message.firstPurchaseDateTime !== "") {
      writer.uint32(74).string(message.firstPurchaseDateTime);
    }
    for (const v of message.eventAttribute) {
      EventAttribute.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lifetimeValueMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lifetimeValueBucket = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastPurchaseDateTime = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.averagePurchaseCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.averagePurchaseValueMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.acquisitionDateTime = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shoppingLoyalty = ShoppingLoyalty.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lifecycleStage = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.firstPurchaseDateTime = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.eventAttribute.push(EventAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserAttribute {
    return {
      lifetimeValueMicros: isSet(object.lifetimeValueMicros) ? Long.fromValue(object.lifetimeValueMicros) : undefined,
      lifetimeValueBucket: isSet(object.lifetimeValueBucket)
        ? globalThis.Number(object.lifetimeValueBucket)
        : undefined,
      lastPurchaseDateTime: isSet(object.lastPurchaseDateTime) ? globalThis.String(object.lastPurchaseDateTime) : "",
      averagePurchaseCount: isSet(object.averagePurchaseCount) ? globalThis.Number(object.averagePurchaseCount) : 0,
      averagePurchaseValueMicros: isSet(object.averagePurchaseValueMicros)
        ? Long.fromValue(object.averagePurchaseValueMicros)
        : Long.ZERO,
      acquisitionDateTime: isSet(object.acquisitionDateTime) ? globalThis.String(object.acquisitionDateTime) : "",
      shoppingLoyalty: isSet(object.shoppingLoyalty) ? ShoppingLoyalty.fromJSON(object.shoppingLoyalty) : undefined,
      lifecycleStage: isSet(object.lifecycleStage) ? globalThis.String(object.lifecycleStage) : "",
      firstPurchaseDateTime: isSet(object.firstPurchaseDateTime) ? globalThis.String(object.firstPurchaseDateTime) : "",
      eventAttribute: globalThis.Array.isArray(object?.eventAttribute)
        ? object.eventAttribute.map((e: any) => EventAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserAttribute): unknown {
    const obj: any = {};
    if (message.lifetimeValueMicros !== undefined) {
      obj.lifetimeValueMicros = (message.lifetimeValueMicros || Long.ZERO).toString();
    }
    if (message.lifetimeValueBucket !== undefined) {
      obj.lifetimeValueBucket = Math.round(message.lifetimeValueBucket);
    }
    if (message.lastPurchaseDateTime !== "") {
      obj.lastPurchaseDateTime = message.lastPurchaseDateTime;
    }
    if (message.averagePurchaseCount !== 0) {
      obj.averagePurchaseCount = Math.round(message.averagePurchaseCount);
    }
    if (!message.averagePurchaseValueMicros.equals(Long.ZERO)) {
      obj.averagePurchaseValueMicros = (message.averagePurchaseValueMicros || Long.ZERO).toString();
    }
    if (message.acquisitionDateTime !== "") {
      obj.acquisitionDateTime = message.acquisitionDateTime;
    }
    if (message.shoppingLoyalty !== undefined) {
      obj.shoppingLoyalty = ShoppingLoyalty.toJSON(message.shoppingLoyalty);
    }
    if (message.lifecycleStage !== "") {
      obj.lifecycleStage = message.lifecycleStage;
    }
    if (message.firstPurchaseDateTime !== "") {
      obj.firstPurchaseDateTime = message.firstPurchaseDateTime;
    }
    if (message.eventAttribute?.length) {
      obj.eventAttribute = message.eventAttribute.map((e) => EventAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserAttribute>): UserAttribute {
    return UserAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserAttribute>): UserAttribute {
    const message = createBaseUserAttribute();
    message.lifetimeValueMicros = (object.lifetimeValueMicros !== undefined && object.lifetimeValueMicros !== null)
      ? Long.fromValue(object.lifetimeValueMicros)
      : undefined;
    message.lifetimeValueBucket = object.lifetimeValueBucket ?? undefined;
    message.lastPurchaseDateTime = object.lastPurchaseDateTime ?? "";
    message.averagePurchaseCount = object.averagePurchaseCount ?? 0;
    message.averagePurchaseValueMicros =
      (object.averagePurchaseValueMicros !== undefined && object.averagePurchaseValueMicros !== null)
        ? Long.fromValue(object.averagePurchaseValueMicros)
        : Long.ZERO;
    message.acquisitionDateTime = object.acquisitionDateTime ?? "";
    message.shoppingLoyalty = (object.shoppingLoyalty !== undefined && object.shoppingLoyalty !== null)
      ? ShoppingLoyalty.fromPartial(object.shoppingLoyalty)
      : undefined;
    message.lifecycleStage = object.lifecycleStage ?? "";
    message.firstPurchaseDateTime = object.firstPurchaseDateTime ?? "";
    message.eventAttribute = object.eventAttribute?.map((e) => EventAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventAttribute(): EventAttribute {
  return { event: "", eventDateTime: "", itemAttribute: [] };
}

export const EventAttribute: MessageFns<EventAttribute> = {
  encode(message: EventAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    if (message.eventDateTime !== "") {
      writer.uint32(18).string(message.eventDateTime);
    }
    for (const v of message.itemAttribute) {
      EventItemAttribute.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventDateTime = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemAttribute.push(EventItemAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAttribute {
    return {
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      eventDateTime: isSet(object.eventDateTime) ? globalThis.String(object.eventDateTime) : "",
      itemAttribute: globalThis.Array.isArray(object?.itemAttribute)
        ? object.itemAttribute.map((e: any) => EventItemAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventAttribute): unknown {
    const obj: any = {};
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.eventDateTime !== "") {
      obj.eventDateTime = message.eventDateTime;
    }
    if (message.itemAttribute?.length) {
      obj.itemAttribute = message.itemAttribute.map((e) => EventItemAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventAttribute>): EventAttribute {
    return EventAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventAttribute>): EventAttribute {
    const message = createBaseEventAttribute();
    message.event = object.event ?? "";
    message.eventDateTime = object.eventDateTime ?? "";
    message.itemAttribute = object.itemAttribute?.map((e) => EventItemAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventItemAttribute(): EventItemAttribute {
  return { itemId: "" };
}

export const EventItemAttribute: MessageFns<EventItemAttribute> = {
  encode(message: EventItemAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventItemAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventItemAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventItemAttribute {
    return { itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "" };
  },

  toJSON(message: EventItemAttribute): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<EventItemAttribute>): EventItemAttribute {
    return EventItemAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventItemAttribute>): EventItemAttribute {
    const message = createBaseEventItemAttribute();
    message.itemId = object.itemId ?? "";
    return message;
  },
};

function createBaseShoppingLoyalty(): ShoppingLoyalty {
  return { loyaltyTier: undefined };
}

export const ShoppingLoyalty: MessageFns<ShoppingLoyalty> = {
  encode(message: ShoppingLoyalty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loyaltyTier !== undefined) {
      writer.uint32(10).string(message.loyaltyTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShoppingLoyalty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShoppingLoyalty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.loyaltyTier = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShoppingLoyalty {
    return { loyaltyTier: isSet(object.loyaltyTier) ? globalThis.String(object.loyaltyTier) : undefined };
  },

  toJSON(message: ShoppingLoyalty): unknown {
    const obj: any = {};
    if (message.loyaltyTier !== undefined) {
      obj.loyaltyTier = message.loyaltyTier;
    }
    return obj;
  },

  create(base?: DeepPartial<ShoppingLoyalty>): ShoppingLoyalty {
    return ShoppingLoyalty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShoppingLoyalty>): ShoppingLoyalty {
    const message = createBaseShoppingLoyalty();
    message.loyaltyTier = object.loyaltyTier ?? undefined;
    return message;
  },
};

function createBaseCustomerMatchUserListMetadata(): CustomerMatchUserListMetadata {
  return { userList: undefined, consent: undefined };
}

export const CustomerMatchUserListMetadata: MessageFns<CustomerMatchUserListMetadata> = {
  encode(message: CustomerMatchUserListMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      writer.uint32(18).string(message.userList);
    }
    if (message.consent !== undefined) {
      Consent.encode(message.consent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerMatchUserListMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerMatchUserListMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userList = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.consent = Consent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerMatchUserListMetadata {
    return {
      userList: isSet(object.userList) ? globalThis.String(object.userList) : undefined,
      consent: isSet(object.consent) ? Consent.fromJSON(object.consent) : undefined,
    };
  },

  toJSON(message: CustomerMatchUserListMetadata): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = message.userList;
    }
    if (message.consent !== undefined) {
      obj.consent = Consent.toJSON(message.consent);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomerMatchUserListMetadata>): CustomerMatchUserListMetadata {
    return CustomerMatchUserListMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomerMatchUserListMetadata>): CustomerMatchUserListMetadata {
    const message = createBaseCustomerMatchUserListMetadata();
    message.userList = object.userList ?? undefined;
    message.consent = (object.consent !== undefined && object.consent !== null)
      ? Consent.fromPartial(object.consent)
      : undefined;
    return message;
  },
};

function createBaseStoreSalesMetadata(): StoreSalesMetadata {
  return {
    loyaltyFraction: undefined,
    transactionUploadFraction: undefined,
    customKey: undefined,
    thirdPartyMetadata: undefined,
  };
}

export const StoreSalesMetadata: MessageFns<StoreSalesMetadata> = {
  encode(message: StoreSalesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loyaltyFraction !== undefined) {
      writer.uint32(41).double(message.loyaltyFraction);
    }
    if (message.transactionUploadFraction !== undefined) {
      writer.uint32(49).double(message.transactionUploadFraction);
    }
    if (message.customKey !== undefined) {
      writer.uint32(58).string(message.customKey);
    }
    if (message.thirdPartyMetadata !== undefined) {
      StoreSalesThirdPartyMetadata.encode(message.thirdPartyMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreSalesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreSalesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 41) {
            break;
          }

          message.loyaltyFraction = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.transactionUploadFraction = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thirdPartyMetadata = StoreSalesThirdPartyMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreSalesMetadata {
    return {
      loyaltyFraction: isSet(object.loyaltyFraction) ? globalThis.Number(object.loyaltyFraction) : undefined,
      transactionUploadFraction: isSet(object.transactionUploadFraction)
        ? globalThis.Number(object.transactionUploadFraction)
        : undefined,
      customKey: isSet(object.customKey) ? globalThis.String(object.customKey) : undefined,
      thirdPartyMetadata: isSet(object.thirdPartyMetadata)
        ? StoreSalesThirdPartyMetadata.fromJSON(object.thirdPartyMetadata)
        : undefined,
    };
  },

  toJSON(message: StoreSalesMetadata): unknown {
    const obj: any = {};
    if (message.loyaltyFraction !== undefined) {
      obj.loyaltyFraction = message.loyaltyFraction;
    }
    if (message.transactionUploadFraction !== undefined) {
      obj.transactionUploadFraction = message.transactionUploadFraction;
    }
    if (message.customKey !== undefined) {
      obj.customKey = message.customKey;
    }
    if (message.thirdPartyMetadata !== undefined) {
      obj.thirdPartyMetadata = StoreSalesThirdPartyMetadata.toJSON(message.thirdPartyMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<StoreSalesMetadata>): StoreSalesMetadata {
    return StoreSalesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoreSalesMetadata>): StoreSalesMetadata {
    const message = createBaseStoreSalesMetadata();
    message.loyaltyFraction = object.loyaltyFraction ?? undefined;
    message.transactionUploadFraction = object.transactionUploadFraction ?? undefined;
    message.customKey = object.customKey ?? undefined;
    message.thirdPartyMetadata = (object.thirdPartyMetadata !== undefined && object.thirdPartyMetadata !== null)
      ? StoreSalesThirdPartyMetadata.fromPartial(object.thirdPartyMetadata)
      : undefined;
    return message;
  },
};

function createBaseStoreSalesThirdPartyMetadata(): StoreSalesThirdPartyMetadata {
  return {
    advertiserUploadDateTime: undefined,
    validTransactionFraction: undefined,
    partnerMatchFraction: undefined,
    partnerUploadFraction: undefined,
    bridgeMapVersionId: undefined,
    partnerId: undefined,
  };
}

export const StoreSalesThirdPartyMetadata: MessageFns<StoreSalesThirdPartyMetadata> = {
  encode(message: StoreSalesThirdPartyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.advertiserUploadDateTime !== undefined) {
      writer.uint32(58).string(message.advertiserUploadDateTime);
    }
    if (message.validTransactionFraction !== undefined) {
      writer.uint32(65).double(message.validTransactionFraction);
    }
    if (message.partnerMatchFraction !== undefined) {
      writer.uint32(73).double(message.partnerMatchFraction);
    }
    if (message.partnerUploadFraction !== undefined) {
      writer.uint32(81).double(message.partnerUploadFraction);
    }
    if (message.bridgeMapVersionId !== undefined) {
      writer.uint32(90).string(message.bridgeMapVersionId);
    }
    if (message.partnerId !== undefined) {
      writer.uint32(96).int64(message.partnerId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreSalesThirdPartyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreSalesThirdPartyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.advertiserUploadDateTime = reader.string();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.validTransactionFraction = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.partnerMatchFraction = reader.double();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.partnerUploadFraction = reader.double();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.bridgeMapVersionId = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.partnerId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreSalesThirdPartyMetadata {
    return {
      advertiserUploadDateTime: isSet(object.advertiserUploadDateTime)
        ? globalThis.String(object.advertiserUploadDateTime)
        : undefined,
      validTransactionFraction: isSet(object.validTransactionFraction)
        ? globalThis.Number(object.validTransactionFraction)
        : undefined,
      partnerMatchFraction: isSet(object.partnerMatchFraction)
        ? globalThis.Number(object.partnerMatchFraction)
        : undefined,
      partnerUploadFraction: isSet(object.partnerUploadFraction)
        ? globalThis.Number(object.partnerUploadFraction)
        : undefined,
      bridgeMapVersionId: isSet(object.bridgeMapVersionId) ? globalThis.String(object.bridgeMapVersionId) : undefined,
      partnerId: isSet(object.partnerId) ? Long.fromValue(object.partnerId) : undefined,
    };
  },

  toJSON(message: StoreSalesThirdPartyMetadata): unknown {
    const obj: any = {};
    if (message.advertiserUploadDateTime !== undefined) {
      obj.advertiserUploadDateTime = message.advertiserUploadDateTime;
    }
    if (message.validTransactionFraction !== undefined) {
      obj.validTransactionFraction = message.validTransactionFraction;
    }
    if (message.partnerMatchFraction !== undefined) {
      obj.partnerMatchFraction = message.partnerMatchFraction;
    }
    if (message.partnerUploadFraction !== undefined) {
      obj.partnerUploadFraction = message.partnerUploadFraction;
    }
    if (message.bridgeMapVersionId !== undefined) {
      obj.bridgeMapVersionId = message.bridgeMapVersionId;
    }
    if (message.partnerId !== undefined) {
      obj.partnerId = (message.partnerId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StoreSalesThirdPartyMetadata>): StoreSalesThirdPartyMetadata {
    return StoreSalesThirdPartyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoreSalesThirdPartyMetadata>): StoreSalesThirdPartyMetadata {
    const message = createBaseStoreSalesThirdPartyMetadata();
    message.advertiserUploadDateTime = object.advertiserUploadDateTime ?? undefined;
    message.validTransactionFraction = object.validTransactionFraction ?? undefined;
    message.partnerMatchFraction = object.partnerMatchFraction ?? undefined;
    message.partnerUploadFraction = object.partnerUploadFraction ?? undefined;
    message.bridgeMapVersionId = object.bridgeMapVersionId ?? undefined;
    message.partnerId = (object.partnerId !== undefined && object.partnerId !== null)
      ? Long.fromValue(object.partnerId)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
