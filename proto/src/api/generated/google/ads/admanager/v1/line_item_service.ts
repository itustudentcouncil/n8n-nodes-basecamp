// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/admanager/v1/line_item_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";
import {
  ComputedStatusEnum_ComputedStatus,
  computedStatusEnum_ComputedStatusFromJSON,
  computedStatusEnum_ComputedStatusToJSON,
} from "./computed_status_enum.js";
import { CreativePlaceholder } from "./creative_placeholder.js";
import {
  EnvironmentTypeEnum_EnvironmentType,
  environmentTypeEnum_EnvironmentTypeFromJSON,
  environmentTypeEnum_EnvironmentTypeToJSON,
} from "./environment_type_enum.js";
import { Goal } from "./goal.js";
import {
  CreativeRotationTypeEnum_CreativeRotationType,
  creativeRotationTypeEnum_CreativeRotationTypeFromJSON,
  creativeRotationTypeEnum_CreativeRotationTypeToJSON,
  DeliveryRateTypeEnum_DeliveryRateType,
  deliveryRateTypeEnum_DeliveryRateTypeFromJSON,
  deliveryRateTypeEnum_DeliveryRateTypeToJSON,
  LineItemCostTypeEnum_LineItemCostType,
  lineItemCostTypeEnum_LineItemCostTypeFromJSON,
  lineItemCostTypeEnum_LineItemCostTypeToJSON,
  LineItemDiscountTypeEnum_LineItemDiscountType,
  lineItemDiscountTypeEnum_LineItemDiscountTypeFromJSON,
  lineItemDiscountTypeEnum_LineItemDiscountTypeToJSON,
  LineItemTypeEnum_LineItemType,
  lineItemTypeEnum_LineItemTypeFromJSON,
  lineItemTypeEnum_LineItemTypeToJSON,
  ReservationStatusEnum_ReservationStatus,
  reservationStatusEnum_ReservationStatusFromJSON,
  reservationStatusEnum_ReservationStatusToJSON,
} from "./line_item_enums.js";

export const protobufPackage = "google.ads.admanager.v1";

/** The LineItem resource. */
export interface LineItem {
  /**
   * Identifier. The resource name of the LineItem.
   * Format:
   * `networks/{network_code}/orders/{order_id}/lineItems/{line_item_id}`
   */
  name: string;
  /**
   * Optional. Display name of the LineItem. This attribute has a maximum length
   * of 255 characters.
   */
  displayName: string;
  /** Output only. The archival status of the LineItem. */
  archived: boolean;
  /**
   * Optional. This attribute is only applicable for certain
   * [line item types][LineItemType] and acts as an "FYI" or note, which does
   * not impact ad-serving or other backend systems.
   *
   * For [SPONSORSHIP][LineItemType.SPONSORSHIP] line items, this represents
   * the minimum quantity, which is a lifetime impression volume goal for
   * reporting purposes.
   *
   * For [STANDARD][LineItemType.STANDARD] line items, this represents the
   * contracted quantity, which is the number of units specified in the contract
   * that the advertiser has bought for this line item. This attribute is only
   * available if you have this feature enabled on your network.
   */
  contractedUnitsBought: Long;
  /** Required. The amount of money to spend per impression or click. */
  costPerUnit:
    | Money
    | undefined;
  /** Required. The method used for billing this line item. */
  costType: LineItemCostTypeEnum_LineItemCostType;
  /**
   * Output only. The instant at which the LineItem was created. This attribute
   * may be null for line items created before this feature was introduced.
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The instant at which the LineItem was last updated */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The strategy used for displaying multiple
   * [creatives][google.ads.admanager.v1.Creative] that are associated with the
   * line item.
   */
  creativeRotationType: CreativeRotationTypeEnum_CreativeRotationType;
  /**
   * Non-empty default. The strategy for delivering ads over the duration of the
   * line item. Defaults to [EVENLY][DeliveryRateType.EVENLY] or
   * [FRONTLOADED][DeliveryRatetype.FRONTLOADED] depending on the network's
   * configuration.
   */
  deliveryRateType: DeliveryRateTypeEnum_DeliveryRateType;
  /**
   * Optional. The number here is either a percentage or an absolute value
   * depending on the
   * [discount_type][google.ads.admanager.v1.LineItem.discount_type]. If it is
   * [PERCENTAGE][LineItemDiscountType.PERCENTAGE], then only non-fractional
   * values are supported.
   */
  discount: number;
  /**
   * Non-empty default. The type of discount applied to the line item. Defaults
   * to [PERCENTAGE][LineItemDiscountType.PERCENTAGE].
   */
  discountType: LineItemDiscountTypeEnum_LineItemDiscountType;
  /**
   * Non-empty default. The environment that the line item is targeting. The
   * default value is [BROWSER][EnvironmentType.BROWSER]. If this value is
   * [VIDEO_PLAYER][EnvironmentType.VIDEO_PLAYER], then this line item can only
   * target [AdUnits][google.ads.admanager.v1.AdUnit] that have `AdUnitSizes`
   * whose `environment_type` is also `VIDEO_PLAYER`.
   */
  environmentType: EnvironmentTypeEnum_EnvironmentType;
  /**
   * Optional. Identifier for the LineItem that is meaningful to the publisher.
   * This attribute has a maximum length of 255 characters.
   */
  externalId: string;
  /**
   * Required. Time at which the LineItem will begin serving. This attribute
   * must be in the future when creating a LineItem.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Optional. Time at which the LineItem will stop serving. This attribute is
   * ignored when
   * [unlimited_end_time][google.ads.admanager.v1.LineItem.unlimited_end_time]
   * is `true`. If specified, it must be after
   * [start_time][google.ads.admanager.v1.LineItem.start_time]. This end time
   * does not include
   * [auto_extension_days][google.ads.admanager.v1.LineItem.auto_extension_days].
   */
  endTime:
    | Date
    | undefined;
  /**
   * Optional. Number of days to allow a LineItem to deliver past its
   * [end_time][google.ads.admanager.v1.LineItem.end_time]. A maximum of 7 days
   * is allowed. This feature is only available for Ad Manager 360 accounts.
   */
  autoExtensionDays: number;
  /**
   * Optional. Whether the LineItem has an
   * [end_time][google.ads.admanager.v1.LineItem.end_time]. This attribute can
   * be set to `true` for only LineItems with
   * [line_item_type][google.ads.admanager.v1.LineItem.line_item_type]
   * [SPONSORSHIP][LineItemType.SPONSORSHIP], [NETWORK][LineItemType.NETWORK],
   * [PRICE_PRIORITY][LineItemType.PRICE_PRIORITY] and
   * [HOUSE][LineItemType.HOUSE].
   */
  unlimitedEndTime: boolean;
  /** Output only. The application that last modified this line item. */
  lastModifiedByApp: string;
  /**
   * Required. Determines the default priority of the LineItem for delivery.
   * More information can be found on the [Ad Manager Help
   * Center](https://support.google.com/dfp_premium/answer/177279).
   */
  lineItemType: LineItemTypeEnum_LineItemType;
  /**
   * Output only. Indicates if a line item is missing any
   * [creatives][google.ads.admanager.v1.Creative] for the
   * [creative_placeholders][google.ads.admanager.v1.LineItem.creative_placeholders]
   * specified.
   *
   * [Creatives][google.ads.admanager.v1.Creative] can be considered missing for
   * several reasons:
   *
   * * Not enough [creatives][google.ads.admanager.v1.Creative] of a certain
   * size have been uploaded,
   *   as determined by
   *   [expectedCreativeCount][google.ads.admanager.v1.CreativePlaceholder.expected_creative_count].
   *   For example a line item specifies 750x350, 400x200, but only a 750x350
   *   was uploaded. Or line item specifies 750x350 with an expected count of 2,
   *   but only one was uploaded.
   * * The [appliedLabels][Creative.applied_labels] of an associated
   * [Creative][google.ads.admanager.v1.Creative]
   *   do not match the
   *   [effectiveAppliedLabels][CreativePlaceholder.effective_applied_labels] of
   *   the line item. For example if a line item specifies 750x350 with a foo
   *   applied label, but a 750x350 creative without an applied label was
   *   uploaded.
   */
  missingCreatives: boolean;
  /**
   * Optional. Provides any additional notes that may annotate LineItem. This
   * field has a maximum length of 65,535 characters.
   */
  notes: string;
  /**
   * Optional. Priority of the LineItem for delivery. Valid values range from 1
   * to 16. This field can only be changed by certain networks, otherwise a
   * `PERMISSION_DENIED` error will occur.
   *
   * The following list shows the default, minimum, and maximum priority values
   * for each [LineItemType][LineItemType]: formatted as `LineItemType`: default
   * priority (minimum priority, maximum priority):
   *
   * * `SPONSORSHIP`: 4 (2,5)
   * * `STANDARD`: 8 (6,10)
   * * `NETWORK`: 12 (11, 14)
   * * `BULK`: 12 (11, 14)
   * * `PRICE_PRIORITY`: 12 (11, 14)
   * * `HOUSE`: 16 (15, 16)
   * * `CLICK_TRACKING`: 16 (1, 16)
   * * `AD_EXCHANGE`: 12 (1, 16)
   * * `ADSENSE`: 12 (1, 16)
   * * `BUMPER`: 16 (15, 16)
   */
  priority: Long;
  /**
   * Output only. Describes whether or not inventory has been reserved for the
   * line item.
   */
  reservationStatus: ReservationStatusEnum_ReservationStatus;
  /**
   * Optional. The web property code used for dynamic allocation line items.
   * This web property is only required with line item types
   * [AD_EXCHANGE][LineItemType.AD_EXCHANGE] and
   * [ADSENSE][LineItemType.ADSENSE].
   */
  webPropertyCode: string;
  /**
   * Required. Details about the creatives that are expected to serve through
   * this LineItem.
   */
  creativePlaceholders: CreativePlaceholder[];
  /** Output only. The status of the LineItem. */
  status: ComputedStatusEnum_ComputedStatus;
  /**
   * Required. The primary goal that this LineItem is associated with, which is
   * used in its pacing and budgeting.
   */
  primaryGoal:
    | Goal
    | undefined;
  /**
   * Optional. The impression limit for the LineItem. This field is meaningful
   * only if the
   * [LineItem.line_item_type][google.ads.admanager.v1.LineItem.line_item_type]
   * is [LineItemType.SPONSORSHIP][] and
   * [LineItem.cost_type][google.ads.admanager.v1.LineItem.cost_type] is
   * [CostType.CPM][].
   */
  impressionLimit: Goal | undefined;
}

/** Request object for GetLineItem method. */
export interface GetLineItemRequest {
  /**
   * Required. The resource name of the LineItem.
   * Format:
   * `networks/{network_code}/orders/{order_id}/lineItems/{line_item_id}`
   */
  name: string;
}

/** Request object for ListLineItems method. */
export interface ListLineItemsRequest {
  /**
   * Required. The parent, which owns this collection of LineItems.
   * Format: networks/{network_code}/orders/{order_id}
   */
  parent: string;
  /**
   * Optional. The maximum number of LineItems to return. The service may return
   * fewer than this value. If unspecified, at most 50 line items will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListLineItems` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListLineItems` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Expression to filter the response.
   * See syntax details at
   * https://developers.google.com/ad-manager/api/beta/filters
   */
  filter: string;
  /**
   * Optional. Expression to specify sorting order.
   * See syntax details at
   * https://developers.google.com/ad-manager/api/beta/filters#order
   */
  orderBy: string;
  /** Optional. Number of individual resources to skip while paginating. */
  skip: number;
}

/**
 * Response object for ListLineItemsRequest containing matching LineItem
 * resources.
 */
export interface ListLineItemsResponse {
  /** The LineItem from the specified network. */
  lineItems: LineItem[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Total number of LineItems.
   * If a filter was included in the request, this reflects the total number
   * after the filtering is applied.
   *
   * `total_size` will not be calculated in the response unless it has been
   * included in a response field mask. The response field mask can be provided
   * to the method by using the URL parameter `$fields` or `fields`, or by using
   * the HTTP/gRPC header `X-Goog-FieldMask`.
   *
   * For more information, see
   * https://developers.google.com/ad-manager/api/beta/field-masks
   */
  totalSize: number;
}

function createBaseLineItem(): LineItem {
  return {
    name: "",
    displayName: "",
    archived: false,
    contractedUnitsBought: Long.ZERO,
    costPerUnit: undefined,
    costType: 0,
    createTime: undefined,
    updateTime: undefined,
    creativeRotationType: 0,
    deliveryRateType: 0,
    discount: 0,
    discountType: 0,
    environmentType: 0,
    externalId: "",
    startTime: undefined,
    endTime: undefined,
    autoExtensionDays: 0,
    unlimitedEndTime: false,
    lastModifiedByApp: "",
    lineItemType: 0,
    missingCreatives: false,
    notes: "",
    priority: Long.ZERO,
    reservationStatus: 0,
    webPropertyCode: "",
    creativePlaceholders: [],
    status: 0,
    primaryGoal: undefined,
    impressionLimit: undefined,
  };
}

export const LineItem: MessageFns<LineItem> = {
  encode(message: LineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.archived !== false) {
      writer.uint32(112).bool(message.archived);
    }
    if (!message.contractedUnitsBought.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.contractedUnitsBought.toString());
    }
    if (message.costPerUnit !== undefined) {
      Money.encode(message.costPerUnit, writer.uint32(122).fork()).join();
    }
    if (message.costType !== 0) {
      writer.uint32(152).int32(message.costType);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(98).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(250).fork()).join();
    }
    if (message.creativeRotationType !== 0) {
      writer.uint32(176).int32(message.creativeRotationType);
    }
    if (message.deliveryRateType !== 0) {
      writer.uint32(184).int32(message.deliveryRateType);
    }
    if (message.discount !== 0) {
      writer.uint32(105).double(message.discount);
    }
    if (message.discountType !== 0) {
      writer.uint32(192).int32(message.discountType);
    }
    if (message.environmentType !== 0) {
      writer.uint32(200).int32(message.environmentType);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    if (message.autoExtensionDays !== 0) {
      writer.uint32(64).int32(message.autoExtensionDays);
    }
    if (message.unlimitedEndTime !== false) {
      writer.uint32(72).bool(message.unlimitedEndTime);
    }
    if (message.lastModifiedByApp !== "") {
      writer.uint32(138).string(message.lastModifiedByApp);
    }
    if (message.lineItemType !== 0) {
      writer.uint32(80).int32(message.lineItemType);
    }
    if (message.missingCreatives !== false) {
      writer.uint32(128).bool(message.missingCreatives);
    }
    if (message.notes !== "") {
      writer.uint32(162).string(message.notes);
    }
    if (!message.priority.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.priority.toString());
    }
    if (message.reservationStatus !== 0) {
      writer.uint32(208).int32(message.reservationStatus);
    }
    if (message.webPropertyCode !== "") {
      writer.uint32(170).string(message.webPropertyCode);
    }
    for (const v of message.creativePlaceholders) {
      CreativePlaceholder.encode(v!, writer.uint32(218).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(224).int32(message.status);
    }
    if (message.primaryGoal !== undefined) {
      Goal.encode(message.primaryGoal, writer.uint32(234).fork()).join();
    }
    if (message.impressionLimit !== undefined) {
      Goal.encode(message.impressionLimit, writer.uint32(242).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.archived = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.contractedUnitsBought = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.costPerUnit = Money.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.costType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.creativeRotationType = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.deliveryRateType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.discount = reader.double();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.discountType = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.environmentType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.autoExtensionDays = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.unlimitedEndTime = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.lastModifiedByApp = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lineItemType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.missingCreatives = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.priority = Long.fromString(reader.int64().toString());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.reservationStatus = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.webPropertyCode = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.creativePlaceholders.push(CreativePlaceholder.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.primaryGoal = Goal.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.impressionLimit = Goal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      archived: isSet(object.archived) ? globalThis.Boolean(object.archived) : false,
      contractedUnitsBought: isSet(object.contractedUnitsBought)
        ? Long.fromValue(object.contractedUnitsBought)
        : Long.ZERO,
      costPerUnit: isSet(object.costPerUnit) ? Money.fromJSON(object.costPerUnit) : undefined,
      costType: isSet(object.costType) ? lineItemCostTypeEnum_LineItemCostTypeFromJSON(object.costType) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      creativeRotationType: isSet(object.creativeRotationType)
        ? creativeRotationTypeEnum_CreativeRotationTypeFromJSON(object.creativeRotationType)
        : 0,
      deliveryRateType: isSet(object.deliveryRateType)
        ? deliveryRateTypeEnum_DeliveryRateTypeFromJSON(object.deliveryRateType)
        : 0,
      discount: isSet(object.discount) ? globalThis.Number(object.discount) : 0,
      discountType: isSet(object.discountType)
        ? lineItemDiscountTypeEnum_LineItemDiscountTypeFromJSON(object.discountType)
        : 0,
      environmentType: isSet(object.environmentType)
        ? environmentTypeEnum_EnvironmentTypeFromJSON(object.environmentType)
        : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      autoExtensionDays: isSet(object.autoExtensionDays) ? globalThis.Number(object.autoExtensionDays) : 0,
      unlimitedEndTime: isSet(object.unlimitedEndTime) ? globalThis.Boolean(object.unlimitedEndTime) : false,
      lastModifiedByApp: isSet(object.lastModifiedByApp) ? globalThis.String(object.lastModifiedByApp) : "",
      lineItemType: isSet(object.lineItemType) ? lineItemTypeEnum_LineItemTypeFromJSON(object.lineItemType) : 0,
      missingCreatives: isSet(object.missingCreatives) ? globalThis.Boolean(object.missingCreatives) : false,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      priority: isSet(object.priority) ? Long.fromValue(object.priority) : Long.ZERO,
      reservationStatus: isSet(object.reservationStatus)
        ? reservationStatusEnum_ReservationStatusFromJSON(object.reservationStatus)
        : 0,
      webPropertyCode: isSet(object.webPropertyCode) ? globalThis.String(object.webPropertyCode) : "",
      creativePlaceholders: globalThis.Array.isArray(object?.creativePlaceholders)
        ? object.creativePlaceholders.map((e: any) => CreativePlaceholder.fromJSON(e))
        : [],
      status: isSet(object.status) ? computedStatusEnum_ComputedStatusFromJSON(object.status) : 0,
      primaryGoal: isSet(object.primaryGoal) ? Goal.fromJSON(object.primaryGoal) : undefined,
      impressionLimit: isSet(object.impressionLimit) ? Goal.fromJSON(object.impressionLimit) : undefined,
    };
  },

  toJSON(message: LineItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.archived !== false) {
      obj.archived = message.archived;
    }
    if (!message.contractedUnitsBought.equals(Long.ZERO)) {
      obj.contractedUnitsBought = (message.contractedUnitsBought || Long.ZERO).toString();
    }
    if (message.costPerUnit !== undefined) {
      obj.costPerUnit = Money.toJSON(message.costPerUnit);
    }
    if (message.costType !== 0) {
      obj.costType = lineItemCostTypeEnum_LineItemCostTypeToJSON(message.costType);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.creativeRotationType !== 0) {
      obj.creativeRotationType = creativeRotationTypeEnum_CreativeRotationTypeToJSON(message.creativeRotationType);
    }
    if (message.deliveryRateType !== 0) {
      obj.deliveryRateType = deliveryRateTypeEnum_DeliveryRateTypeToJSON(message.deliveryRateType);
    }
    if (message.discount !== 0) {
      obj.discount = message.discount;
    }
    if (message.discountType !== 0) {
      obj.discountType = lineItemDiscountTypeEnum_LineItemDiscountTypeToJSON(message.discountType);
    }
    if (message.environmentType !== 0) {
      obj.environmentType = environmentTypeEnum_EnvironmentTypeToJSON(message.environmentType);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.autoExtensionDays !== 0) {
      obj.autoExtensionDays = Math.round(message.autoExtensionDays);
    }
    if (message.unlimitedEndTime !== false) {
      obj.unlimitedEndTime = message.unlimitedEndTime;
    }
    if (message.lastModifiedByApp !== "") {
      obj.lastModifiedByApp = message.lastModifiedByApp;
    }
    if (message.lineItemType !== 0) {
      obj.lineItemType = lineItemTypeEnum_LineItemTypeToJSON(message.lineItemType);
    }
    if (message.missingCreatives !== false) {
      obj.missingCreatives = message.missingCreatives;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (!message.priority.equals(Long.ZERO)) {
      obj.priority = (message.priority || Long.ZERO).toString();
    }
    if (message.reservationStatus !== 0) {
      obj.reservationStatus = reservationStatusEnum_ReservationStatusToJSON(message.reservationStatus);
    }
    if (message.webPropertyCode !== "") {
      obj.webPropertyCode = message.webPropertyCode;
    }
    if (message.creativePlaceholders?.length) {
      obj.creativePlaceholders = message.creativePlaceholders.map((e) => CreativePlaceholder.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = computedStatusEnum_ComputedStatusToJSON(message.status);
    }
    if (message.primaryGoal !== undefined) {
      obj.primaryGoal = Goal.toJSON(message.primaryGoal);
    }
    if (message.impressionLimit !== undefined) {
      obj.impressionLimit = Goal.toJSON(message.impressionLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<LineItem>): LineItem {
    return LineItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LineItem>): LineItem {
    const message = createBaseLineItem();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.archived = object.archived ?? false;
    message.contractedUnitsBought =
      (object.contractedUnitsBought !== undefined && object.contractedUnitsBought !== null)
        ? Long.fromValue(object.contractedUnitsBought)
        : Long.ZERO;
    message.costPerUnit = (object.costPerUnit !== undefined && object.costPerUnit !== null)
      ? Money.fromPartial(object.costPerUnit)
      : undefined;
    message.costType = object.costType ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.creativeRotationType = object.creativeRotationType ?? 0;
    message.deliveryRateType = object.deliveryRateType ?? 0;
    message.discount = object.discount ?? 0;
    message.discountType = object.discountType ?? 0;
    message.environmentType = object.environmentType ?? 0;
    message.externalId = object.externalId ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.autoExtensionDays = object.autoExtensionDays ?? 0;
    message.unlimitedEndTime = object.unlimitedEndTime ?? false;
    message.lastModifiedByApp = object.lastModifiedByApp ?? "";
    message.lineItemType = object.lineItemType ?? 0;
    message.missingCreatives = object.missingCreatives ?? false;
    message.notes = object.notes ?? "";
    message.priority = (object.priority !== undefined && object.priority !== null)
      ? Long.fromValue(object.priority)
      : Long.ZERO;
    message.reservationStatus = object.reservationStatus ?? 0;
    message.webPropertyCode = object.webPropertyCode ?? "";
    message.creativePlaceholders = object.creativePlaceholders?.map((e) => CreativePlaceholder.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    message.primaryGoal = (object.primaryGoal !== undefined && object.primaryGoal !== null)
      ? Goal.fromPartial(object.primaryGoal)
      : undefined;
    message.impressionLimit = (object.impressionLimit !== undefined && object.impressionLimit !== null)
      ? Goal.fromPartial(object.impressionLimit)
      : undefined;
    return message;
  },
};

function createBaseGetLineItemRequest(): GetLineItemRequest {
  return { name: "" };
}

export const GetLineItemRequest: MessageFns<GetLineItemRequest> = {
  encode(message: GetLineItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLineItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineItemRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetLineItemRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLineItemRequest>): GetLineItemRequest {
    return GetLineItemRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLineItemRequest>): GetLineItemRequest {
    const message = createBaseGetLineItemRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListLineItemsRequest(): ListLineItemsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", skip: 0 };
}

export const ListLineItemsRequest: MessageFns<ListLineItemsRequest> = {
  encode(message: ListLineItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.skip !== 0) {
      writer.uint32(48).int32(message.skip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLineItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLineItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.skip = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLineItemsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      skip: isSet(object.skip) ? globalThis.Number(object.skip) : 0,
    };
  },

  toJSON(message: ListLineItemsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.skip !== 0) {
      obj.skip = Math.round(message.skip);
    }
    return obj;
  },

  create(base?: DeepPartial<ListLineItemsRequest>): ListLineItemsRequest {
    return ListLineItemsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLineItemsRequest>): ListLineItemsRequest {
    const message = createBaseListLineItemsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.skip = object.skip ?? 0;
    return message;
  },
};

function createBaseListLineItemsResponse(): ListLineItemsResponse {
  return { lineItems: [], nextPageToken: "", totalSize: 0 };
}

export const ListLineItemsResponse: MessageFns<ListLineItemsResponse> = {
  encode(message: ListLineItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLineItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLineItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLineItemsResponse {
    return {
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => LineItem.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListLineItemsResponse): unknown {
    const obj: any = {};
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => LineItem.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListLineItemsResponse>): ListLineItemsResponse {
    return ListLineItemsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLineItemsResponse>): ListLineItemsResponse {
    const message = createBaseListLineItemsResponse();
    message.lineItems = object.lineItems?.map((e) => LineItem.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

/** Provides methods for handling LineItem objects. */
export type LineItemServiceDefinition = typeof LineItemServiceDefinition;
export const LineItemServiceDefinition = {
  name: "LineItemService",
  fullName: "google.ads.admanager.v1.LineItemService",
  methods: {
    /** API to retrieve a LineItem object. */
    getLineItem: {
      name: "GetLineItem",
      requestType: GetLineItemRequest,
      requestStream: false,
      responseType: LineItem,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              47,
              111,
              114,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              108,
              105,
              110,
              101,
              73,
              116,
              101,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** API to retrieve a list of LineItem objects. */
    listLineItems: {
      name: "ListLineItems",
      requestType: ListLineItemsRequest,
      requestStream: false,
      responseType: ListLineItemsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              47,
              111,
              114,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              108,
              105,
              110,
              101,
              73,
              116,
              101,
              109,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface LineItemServiceImplementation<CallContextExt = {}> {
  /** API to retrieve a LineItem object. */
  getLineItem(request: GetLineItemRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LineItem>>;
  /** API to retrieve a list of LineItem objects. */
  listLineItems(
    request: ListLineItemsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListLineItemsResponse>>;
}

export interface LineItemServiceClient<CallOptionsExt = {}> {
  /** API to retrieve a LineItem object. */
  getLineItem(request: DeepPartial<GetLineItemRequest>, options?: CallOptions & CallOptionsExt): Promise<LineItem>;
  /** API to retrieve a list of LineItem objects. */
  listLineItems(
    request: DeepPartial<ListLineItemsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListLineItemsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
