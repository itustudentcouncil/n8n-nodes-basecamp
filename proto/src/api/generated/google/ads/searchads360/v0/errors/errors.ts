// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/searchads360/v0/errors/errors.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Value } from "../common/value.js";
import {
  AuthenticationErrorEnum_AuthenticationError,
  authenticationErrorEnum_AuthenticationErrorFromJSON,
  authenticationErrorEnum_AuthenticationErrorToJSON,
} from "./authentication_error.js";
import {
  AuthorizationErrorEnum_AuthorizationError,
  authorizationErrorEnum_AuthorizationErrorFromJSON,
  authorizationErrorEnum_AuthorizationErrorToJSON,
} from "./authorization_error.js";
import {
  CustomColumnErrorEnum_CustomColumnError,
  customColumnErrorEnum_CustomColumnErrorFromJSON,
  customColumnErrorEnum_CustomColumnErrorToJSON,
} from "./custom_column_error.js";
import {
  DateErrorEnum_DateError,
  dateErrorEnum_DateErrorFromJSON,
  dateErrorEnum_DateErrorToJSON,
} from "./date_error.js";
import {
  DateRangeErrorEnum_DateRangeError,
  dateRangeErrorEnum_DateRangeErrorFromJSON,
  dateRangeErrorEnum_DateRangeErrorToJSON,
} from "./date_range_error.js";
import {
  DistinctErrorEnum_DistinctError,
  distinctErrorEnum_DistinctErrorFromJSON,
  distinctErrorEnum_DistinctErrorToJSON,
} from "./distinct_error.js";
import {
  HeaderErrorEnum_HeaderError,
  headerErrorEnum_HeaderErrorFromJSON,
  headerErrorEnum_HeaderErrorToJSON,
} from "./header_error.js";
import {
  InternalErrorEnum_InternalError,
  internalErrorEnum_InternalErrorFromJSON,
  internalErrorEnum_InternalErrorToJSON,
} from "./internal_error.js";
import {
  InvalidParameterErrorEnum_InvalidParameterError,
  invalidParameterErrorEnum_InvalidParameterErrorFromJSON,
  invalidParameterErrorEnum_InvalidParameterErrorToJSON,
} from "./invalid_parameter_error.js";
import {
  QueryErrorEnum_QueryError,
  queryErrorEnum_QueryErrorFromJSON,
  queryErrorEnum_QueryErrorToJSON,
} from "./query_error.js";
import {
  QuotaErrorEnum_QuotaError,
  quotaErrorEnum_QuotaErrorFromJSON,
  quotaErrorEnum_QuotaErrorToJSON,
} from "./quota_error.js";
import {
  RequestErrorEnum_RequestError,
  requestErrorEnum_RequestErrorFromJSON,
  requestErrorEnum_RequestErrorToJSON,
} from "./request_error.js";
import {
  SizeLimitErrorEnum_SizeLimitError,
  sizeLimitErrorEnum_SizeLimitErrorFromJSON,
  sizeLimitErrorEnum_SizeLimitErrorToJSON,
} from "./size_limit_error.js";

export const protobufPackage = "google.ads.searchads360.v0.errors";

/**
 * Describes how a Search Ads 360 API call failed. It's returned inside
 * google.rpc.Status.details when a call fails.
 */
export interface SearchAds360Failure {
  /** The list of errors that occurred. */
  errors: SearchAds360Error[];
  /** The unique ID of the request that is used for debugging purposes. */
  requestId: string;
}

/** Search Ads 360-specific error. */
export interface SearchAds360Error {
  /** An enum value that indicates which error occurred. */
  errorCode:
    | ErrorCode
    | undefined;
  /** A human-readable description of the error. */
  message: string;
  /** The value that triggered the error. */
  trigger:
    | Value
    | undefined;
  /** Describes the part of the request proto that caused the error. */
  location:
    | ErrorLocation
    | undefined;
  /**
   * Additional error details, which are returned by certain error codes. Most
   * error codes do not include details.
   */
  details: ErrorDetails | undefined;
}

/** The error reason represented by type and enum. */
export interface ErrorCode {
  /** An error caused by the request */
  requestError?:
    | RequestErrorEnum_RequestError
    | undefined;
  /** An error with the query */
  queryError?:
    | QueryErrorEnum_QueryError
    | undefined;
  /** An error encountered when trying to authorize a user. */
  authorizationError?:
    | AuthorizationErrorEnum_AuthorizationError
    | undefined;
  /** An unexpected server-side error. */
  internalError?:
    | InternalErrorEnum_InternalError
    | undefined;
  /** An error with the amount of quota remaining. */
  quotaError?:
    | QuotaErrorEnum_QuotaError
    | undefined;
  /** Indicates failure to properly authenticate user. */
  authenticationError?:
    | AuthenticationErrorEnum_AuthenticationError
    | undefined;
  /** The reasons for the date error */
  dateError?:
    | DateErrorEnum_DateError
    | undefined;
  /** The reasons for the date range error */
  dateRangeError?:
    | DateRangeErrorEnum_DateRangeError
    | undefined;
  /** The reasons for the distinct error */
  distinctError?:
    | DistinctErrorEnum_DistinctError
    | undefined;
  /** The reasons for the header error. */
  headerError?:
    | HeaderErrorEnum_HeaderError
    | undefined;
  /** The reasons for the size limit error */
  sizeLimitError?:
    | SizeLimitErrorEnum_SizeLimitError
    | undefined;
  /** The reasons for the custom column error */
  customColumnError?:
    | CustomColumnErrorEnum_CustomColumnError
    | undefined;
  /** The reasons for invalid parameter errors. */
  invalidParameterError?: InvalidParameterErrorEnum_InvalidParameterError | undefined;
}

/** Describes the part of the request proto that caused the error. */
export interface ErrorLocation {
  /** A field path that indicates which field was invalid in the request. */
  fieldPathElements: ErrorLocation_FieldPathElement[];
}

/** A part of a field path. */
export interface ErrorLocation_FieldPathElement {
  /** The name of a field or a oneof */
  fieldName: string;
  /** If field_name is a repeated field, this is the element that failed */
  index?: number | undefined;
}

/** Additional error details. */
export interface ErrorDetails {
  /**
   * The error code that should have been returned, but wasn't. This is used
   * when the error code is not published in the client specified version.
   */
  unpublishedErrorCode: string;
  /**
   * Details on the quota error, including the scope (account or developer), the
   * rate bucket name and the retry delay.
   */
  quotaErrorDetails: QuotaErrorDetails | undefined;
}

/** Additional quota error details when there is QuotaError. */
export interface QuotaErrorDetails {
  /** The rate scope of the quota limit. */
  rateScope: QuotaErrorDetails_QuotaRateScope;
  /**
   * The high level description of the quota bucket.
   * Examples are "Get requests for standard access" or "Requests per account".
   */
  rateName: string;
  /** Backoff period that customers should wait before sending next request. */
  retryDelay: Duration | undefined;
}

/** Enum of possible scopes that quota buckets belong to. */
export enum QuotaErrorDetails_QuotaRateScope {
  /** UNSPECIFIED - Unspecified enum */
  UNSPECIFIED = 0,
  /** UNKNOWN - Used for return value only. Represents value unknown in this version. */
  UNKNOWN = 1,
  /** ACCOUNT - Per customer account quota */
  ACCOUNT = 2,
  /** DEVELOPER - Per project quota */
  DEVELOPER = 3,
  UNRECOGNIZED = -1,
}

export function quotaErrorDetails_QuotaRateScopeFromJSON(object: any): QuotaErrorDetails_QuotaRateScope {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return QuotaErrorDetails_QuotaRateScope.UNSPECIFIED;
    case 1:
    case "UNKNOWN":
      return QuotaErrorDetails_QuotaRateScope.UNKNOWN;
    case 2:
    case "ACCOUNT":
      return QuotaErrorDetails_QuotaRateScope.ACCOUNT;
    case 3:
    case "DEVELOPER":
      return QuotaErrorDetails_QuotaRateScope.DEVELOPER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuotaErrorDetails_QuotaRateScope.UNRECOGNIZED;
  }
}

export function quotaErrorDetails_QuotaRateScopeToJSON(object: QuotaErrorDetails_QuotaRateScope): string {
  switch (object) {
    case QuotaErrorDetails_QuotaRateScope.UNSPECIFIED:
      return "UNSPECIFIED";
    case QuotaErrorDetails_QuotaRateScope.UNKNOWN:
      return "UNKNOWN";
    case QuotaErrorDetails_QuotaRateScope.ACCOUNT:
      return "ACCOUNT";
    case QuotaErrorDetails_QuotaRateScope.DEVELOPER:
      return "DEVELOPER";
    case QuotaErrorDetails_QuotaRateScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSearchAds360Failure(): SearchAds360Failure {
  return { errors: [], requestId: "" };
}

export const SearchAds360Failure: MessageFns<SearchAds360Failure> = {
  encode(message: SearchAds360Failure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      SearchAds360Error.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAds360Failure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAds360Failure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errors.push(SearchAds360Error.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAds360Failure {
    return {
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => SearchAds360Error.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: SearchAds360Failure): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => SearchAds360Error.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAds360Failure>): SearchAds360Failure {
    return SearchAds360Failure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAds360Failure>): SearchAds360Failure {
    const message = createBaseSearchAds360Failure();
    message.errors = object.errors?.map((e) => SearchAds360Error.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseSearchAds360Error(): SearchAds360Error {
  return { errorCode: undefined, message: "", trigger: undefined, location: undefined, details: undefined };
}

export const SearchAds360Error: MessageFns<SearchAds360Error> = {
  encode(message: SearchAds360Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== undefined) {
      ErrorCode.encode(message.errorCode, writer.uint32(10).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.trigger !== undefined) {
      Value.encode(message.trigger, writer.uint32(26).fork()).join();
    }
    if (message.location !== undefined) {
      ErrorLocation.encode(message.location, writer.uint32(34).fork()).join();
    }
    if (message.details !== undefined) {
      ErrorDetails.encode(message.details, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAds360Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAds360Error();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = ErrorCode.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trigger = Value.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = ErrorLocation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.details = ErrorDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAds360Error {
    return {
      errorCode: isSet(object.errorCode) ? ErrorCode.fromJSON(object.errorCode) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      trigger: isSet(object.trigger) ? Value.fromJSON(object.trigger) : undefined,
      location: isSet(object.location) ? ErrorLocation.fromJSON(object.location) : undefined,
      details: isSet(object.details) ? ErrorDetails.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: SearchAds360Error): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined) {
      obj.errorCode = ErrorCode.toJSON(message.errorCode);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.trigger !== undefined) {
      obj.trigger = Value.toJSON(message.trigger);
    }
    if (message.location !== undefined) {
      obj.location = ErrorLocation.toJSON(message.location);
    }
    if (message.details !== undefined) {
      obj.details = ErrorDetails.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAds360Error>): SearchAds360Error {
    return SearchAds360Error.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAds360Error>): SearchAds360Error {
    const message = createBaseSearchAds360Error();
    message.errorCode = (object.errorCode !== undefined && object.errorCode !== null)
      ? ErrorCode.fromPartial(object.errorCode)
      : undefined;
    message.message = object.message ?? "";
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? Value.fromPartial(object.trigger)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? ErrorLocation.fromPartial(object.location)
      : undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? ErrorDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseErrorCode(): ErrorCode {
  return {
    requestError: undefined,
    queryError: undefined,
    authorizationError: undefined,
    internalError: undefined,
    quotaError: undefined,
    authenticationError: undefined,
    dateError: undefined,
    dateRangeError: undefined,
    distinctError: undefined,
    headerError: undefined,
    sizeLimitError: undefined,
    customColumnError: undefined,
    invalidParameterError: undefined,
  };
}

export const ErrorCode: MessageFns<ErrorCode> = {
  encode(message: ErrorCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestError !== undefined) {
      writer.uint32(8).int32(message.requestError);
    }
    if (message.queryError !== undefined) {
      writer.uint32(40).int32(message.queryError);
    }
    if (message.authorizationError !== undefined) {
      writer.uint32(72).int32(message.authorizationError);
    }
    if (message.internalError !== undefined) {
      writer.uint32(80).int32(message.internalError);
    }
    if (message.quotaError !== undefined) {
      writer.uint32(88).int32(message.quotaError);
    }
    if (message.authenticationError !== undefined) {
      writer.uint32(136).int32(message.authenticationError);
    }
    if (message.dateError !== undefined) {
      writer.uint32(264).int32(message.dateError);
    }
    if (message.dateRangeError !== undefined) {
      writer.uint32(272).int32(message.dateRangeError);
    }
    if (message.distinctError !== undefined) {
      writer.uint32(280).int32(message.distinctError);
    }
    if (message.headerError !== undefined) {
      writer.uint32(528).int32(message.headerError);
    }
    if (message.sizeLimitError !== undefined) {
      writer.uint32(944).int32(message.sizeLimitError);
    }
    if (message.customColumnError !== undefined) {
      writer.uint32(1152).int32(message.customColumnError);
    }
    if (message.invalidParameterError !== undefined) {
      writer.uint32(1400).int32(message.invalidParameterError);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestError = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.queryError = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.authorizationError = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.internalError = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.quotaError = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.authenticationError = reader.int32() as any;
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.dateError = reader.int32() as any;
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.dateRangeError = reader.int32() as any;
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.distinctError = reader.int32() as any;
          continue;
        case 66:
          if (tag !== 528) {
            break;
          }

          message.headerError = reader.int32() as any;
          continue;
        case 118:
          if (tag !== 944) {
            break;
          }

          message.sizeLimitError = reader.int32() as any;
          continue;
        case 144:
          if (tag !== 1152) {
            break;
          }

          message.customColumnError = reader.int32() as any;
          continue;
        case 175:
          if (tag !== 1400) {
            break;
          }

          message.invalidParameterError = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorCode {
    return {
      requestError: isSet(object.requestError) ? requestErrorEnum_RequestErrorFromJSON(object.requestError) : undefined,
      queryError: isSet(object.queryError) ? queryErrorEnum_QueryErrorFromJSON(object.queryError) : undefined,
      authorizationError: isSet(object.authorizationError)
        ? authorizationErrorEnum_AuthorizationErrorFromJSON(object.authorizationError)
        : undefined,
      internalError: isSet(object.internalError)
        ? internalErrorEnum_InternalErrorFromJSON(object.internalError)
        : undefined,
      quotaError: isSet(object.quotaError) ? quotaErrorEnum_QuotaErrorFromJSON(object.quotaError) : undefined,
      authenticationError: isSet(object.authenticationError)
        ? authenticationErrorEnum_AuthenticationErrorFromJSON(object.authenticationError)
        : undefined,
      dateError: isSet(object.dateError) ? dateErrorEnum_DateErrorFromJSON(object.dateError) : undefined,
      dateRangeError: isSet(object.dateRangeError)
        ? dateRangeErrorEnum_DateRangeErrorFromJSON(object.dateRangeError)
        : undefined,
      distinctError: isSet(object.distinctError)
        ? distinctErrorEnum_DistinctErrorFromJSON(object.distinctError)
        : undefined,
      headerError: isSet(object.headerError) ? headerErrorEnum_HeaderErrorFromJSON(object.headerError) : undefined,
      sizeLimitError: isSet(object.sizeLimitError)
        ? sizeLimitErrorEnum_SizeLimitErrorFromJSON(object.sizeLimitError)
        : undefined,
      customColumnError: isSet(object.customColumnError)
        ? customColumnErrorEnum_CustomColumnErrorFromJSON(object.customColumnError)
        : undefined,
      invalidParameterError: isSet(object.invalidParameterError)
        ? invalidParameterErrorEnum_InvalidParameterErrorFromJSON(object.invalidParameterError)
        : undefined,
    };
  },

  toJSON(message: ErrorCode): unknown {
    const obj: any = {};
    if (message.requestError !== undefined) {
      obj.requestError = requestErrorEnum_RequestErrorToJSON(message.requestError);
    }
    if (message.queryError !== undefined) {
      obj.queryError = queryErrorEnum_QueryErrorToJSON(message.queryError);
    }
    if (message.authorizationError !== undefined) {
      obj.authorizationError = authorizationErrorEnum_AuthorizationErrorToJSON(message.authorizationError);
    }
    if (message.internalError !== undefined) {
      obj.internalError = internalErrorEnum_InternalErrorToJSON(message.internalError);
    }
    if (message.quotaError !== undefined) {
      obj.quotaError = quotaErrorEnum_QuotaErrorToJSON(message.quotaError);
    }
    if (message.authenticationError !== undefined) {
      obj.authenticationError = authenticationErrorEnum_AuthenticationErrorToJSON(message.authenticationError);
    }
    if (message.dateError !== undefined) {
      obj.dateError = dateErrorEnum_DateErrorToJSON(message.dateError);
    }
    if (message.dateRangeError !== undefined) {
      obj.dateRangeError = dateRangeErrorEnum_DateRangeErrorToJSON(message.dateRangeError);
    }
    if (message.distinctError !== undefined) {
      obj.distinctError = distinctErrorEnum_DistinctErrorToJSON(message.distinctError);
    }
    if (message.headerError !== undefined) {
      obj.headerError = headerErrorEnum_HeaderErrorToJSON(message.headerError);
    }
    if (message.sizeLimitError !== undefined) {
      obj.sizeLimitError = sizeLimitErrorEnum_SizeLimitErrorToJSON(message.sizeLimitError);
    }
    if (message.customColumnError !== undefined) {
      obj.customColumnError = customColumnErrorEnum_CustomColumnErrorToJSON(message.customColumnError);
    }
    if (message.invalidParameterError !== undefined) {
      obj.invalidParameterError = invalidParameterErrorEnum_InvalidParameterErrorToJSON(message.invalidParameterError);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorCode>): ErrorCode {
    return ErrorCode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorCode>): ErrorCode {
    const message = createBaseErrorCode();
    message.requestError = object.requestError ?? undefined;
    message.queryError = object.queryError ?? undefined;
    message.authorizationError = object.authorizationError ?? undefined;
    message.internalError = object.internalError ?? undefined;
    message.quotaError = object.quotaError ?? undefined;
    message.authenticationError = object.authenticationError ?? undefined;
    message.dateError = object.dateError ?? undefined;
    message.dateRangeError = object.dateRangeError ?? undefined;
    message.distinctError = object.distinctError ?? undefined;
    message.headerError = object.headerError ?? undefined;
    message.sizeLimitError = object.sizeLimitError ?? undefined;
    message.customColumnError = object.customColumnError ?? undefined;
    message.invalidParameterError = object.invalidParameterError ?? undefined;
    return message;
  },
};

function createBaseErrorLocation(): ErrorLocation {
  return { fieldPathElements: [] };
}

export const ErrorLocation: MessageFns<ErrorLocation> = {
  encode(message: ErrorLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fieldPathElements) {
      ErrorLocation_FieldPathElement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldPathElements.push(ErrorLocation_FieldPathElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorLocation {
    return {
      fieldPathElements: globalThis.Array.isArray(object?.fieldPathElements)
        ? object.fieldPathElements.map((e: any) => ErrorLocation_FieldPathElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ErrorLocation): unknown {
    const obj: any = {};
    if (message.fieldPathElements?.length) {
      obj.fieldPathElements = message.fieldPathElements.map((e) => ErrorLocation_FieldPathElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorLocation>): ErrorLocation {
    return ErrorLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorLocation>): ErrorLocation {
    const message = createBaseErrorLocation();
    message.fieldPathElements = object.fieldPathElements?.map((e) => ErrorLocation_FieldPathElement.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseErrorLocation_FieldPathElement(): ErrorLocation_FieldPathElement {
  return { fieldName: "", index: undefined };
}

export const ErrorLocation_FieldPathElement: MessageFns<ErrorLocation_FieldPathElement> = {
  encode(message: ErrorLocation_FieldPathElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.index !== undefined) {
      writer.uint32(24).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorLocation_FieldPathElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorLocation_FieldPathElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorLocation_FieldPathElement {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
    };
  },

  toJSON(message: ErrorLocation_FieldPathElement): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorLocation_FieldPathElement>): ErrorLocation_FieldPathElement {
    return ErrorLocation_FieldPathElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorLocation_FieldPathElement>): ErrorLocation_FieldPathElement {
    const message = createBaseErrorLocation_FieldPathElement();
    message.fieldName = object.fieldName ?? "";
    message.index = object.index ?? undefined;
    return message;
  },
};

function createBaseErrorDetails(): ErrorDetails {
  return { unpublishedErrorCode: "", quotaErrorDetails: undefined };
}

export const ErrorDetails: MessageFns<ErrorDetails> = {
  encode(message: ErrorDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unpublishedErrorCode !== "") {
      writer.uint32(10).string(message.unpublishedErrorCode);
    }
    if (message.quotaErrorDetails !== undefined) {
      QuotaErrorDetails.encode(message.quotaErrorDetails, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unpublishedErrorCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quotaErrorDetails = QuotaErrorDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetails {
    return {
      unpublishedErrorCode: isSet(object.unpublishedErrorCode) ? globalThis.String(object.unpublishedErrorCode) : "",
      quotaErrorDetails: isSet(object.quotaErrorDetails)
        ? QuotaErrorDetails.fromJSON(object.quotaErrorDetails)
        : undefined,
    };
  },

  toJSON(message: ErrorDetails): unknown {
    const obj: any = {};
    if (message.unpublishedErrorCode !== "") {
      obj.unpublishedErrorCode = message.unpublishedErrorCode;
    }
    if (message.quotaErrorDetails !== undefined) {
      obj.quotaErrorDetails = QuotaErrorDetails.toJSON(message.quotaErrorDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorDetails>): ErrorDetails {
    return ErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorDetails>): ErrorDetails {
    const message = createBaseErrorDetails();
    message.unpublishedErrorCode = object.unpublishedErrorCode ?? "";
    message.quotaErrorDetails = (object.quotaErrorDetails !== undefined && object.quotaErrorDetails !== null)
      ? QuotaErrorDetails.fromPartial(object.quotaErrorDetails)
      : undefined;
    return message;
  },
};

function createBaseQuotaErrorDetails(): QuotaErrorDetails {
  return { rateScope: 0, rateName: "", retryDelay: undefined };
}

export const QuotaErrorDetails: MessageFns<QuotaErrorDetails> = {
  encode(message: QuotaErrorDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rateScope !== 0) {
      writer.uint32(8).int32(message.rateScope);
    }
    if (message.rateName !== "") {
      writer.uint32(18).string(message.rateName);
    }
    if (message.retryDelay !== undefined) {
      Duration.encode(message.retryDelay, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotaErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotaErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rateScope = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rateName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryDelay = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotaErrorDetails {
    return {
      rateScope: isSet(object.rateScope) ? quotaErrorDetails_QuotaRateScopeFromJSON(object.rateScope) : 0,
      rateName: isSet(object.rateName) ? globalThis.String(object.rateName) : "",
      retryDelay: isSet(object.retryDelay) ? Duration.fromJSON(object.retryDelay) : undefined,
    };
  },

  toJSON(message: QuotaErrorDetails): unknown {
    const obj: any = {};
    if (message.rateScope !== 0) {
      obj.rateScope = quotaErrorDetails_QuotaRateScopeToJSON(message.rateScope);
    }
    if (message.rateName !== "") {
      obj.rateName = message.rateName;
    }
    if (message.retryDelay !== undefined) {
      obj.retryDelay = Duration.toJSON(message.retryDelay);
    }
    return obj;
  },

  create(base?: DeepPartial<QuotaErrorDetails>): QuotaErrorDetails {
    return QuotaErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotaErrorDetails>): QuotaErrorDetails {
    const message = createBaseQuotaErrorDetails();
    message.rateScope = object.rateScope ?? 0;
    message.rateName = object.rateName ?? "";
    message.retryDelay = (object.retryDelay !== undefined && object.retryDelay !== null)
      ? Duration.fromPartial(object.retryDelay)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
