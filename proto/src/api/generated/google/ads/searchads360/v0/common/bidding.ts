// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/searchads360/v0/common/bidding.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Int64Value } from "../../../../protobuf/wrappers.js";
import {
  TargetImpressionShareLocationEnum_TargetImpressionShareLocation,
  targetImpressionShareLocationEnum_TargetImpressionShareLocationFromJSON,
  targetImpressionShareLocationEnum_TargetImpressionShareLocationToJSON,
} from "../enums/target_impression_share_location.js";

export const protobufPackage = "google.ads.searchads360.v0.common";

/**
 * An automated bidding strategy that raises bids for clicks
 * that seem more likely to lead to a conversion and lowers
 * them for clicks where they seem less likely.
 *
 * This bidding strategy is deprecated and cannot be created anymore. Use
 * ManualCpc with enhanced_cpc_enabled set to true for equivalent functionality.
 */
export interface EnhancedCpc {
}

/**
 * Manual bidding strategy that allows advertiser to set the bid per
 * advertiser-specified action.
 */
export interface ManualCpa {
}

/** Manual click-based bidding where user pays per click. */
export interface ManualCpc {
  /** Whether bids are to be enhanced based on conversion optimizer data. */
  enhancedCpcEnabled?: boolean | undefined;
}

/** Manual impression-based bidding where user pays per thousand impressions. */
export interface ManualCpm {
}

/**
 * An automated bidding strategy to help get the most conversions for your
 * campaigns while spending your budget.
 */
export interface MaximizeConversions {
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidCeilingMicros: Long;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidFloorMicros: Long;
  /**
   * The target cost-per-action (CPA) option. This is the average amount that
   * you would like to spend per conversion action specified in micro units of
   * the bidding strategy's currency. If set, the bid strategy will get as many
   * conversions as possible at or below the target cost-per-action. If the
   * target CPA is not set, the bid strategy will aim to achieve the lowest
   * possible CPA given the budget.
   */
  targetCpaMicros: Long;
}

/**
 * An automated bidding strategy to help get the most conversion value for your
 * campaigns while spending your budget.
 */
export interface MaximizeConversionValue {
  /**
   * The target return on ad spend (ROAS) option. If set, the bid strategy will
   * maximize revenue while averaging the target return on ad spend. If the
   * target ROAS is high, the bid strategy may not be able to spend the full
   * budget. If the target ROAS is not set, the bid strategy will aim to
   * achieve the highest possible ROAS for the budget.
   */
  targetRoas?:
    | number
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidCeilingMicros: Long;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidFloorMicros: Long;
}

/**
 * An automated bid strategy that sets bids to help get as many conversions as
 * possible at the target cost-per-acquisition (CPA) you set.
 */
export interface TargetCpa {
  /**
   * Average CPA target.
   * This target should be greater than or equal to minimum billable unit based
   * on the currency for the account.
   */
  targetCpaMicros?:
    | Long
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidFloorMicros?: Long | undefined;
}

/**
 * Target CPM (cost per thousand impressions) is an automated bidding strategy
 * that sets bids to optimize performance given the target CPM you set.
 */
export interface TargetCpm {
}

/**
 * An automated bidding strategy that sets bids so that a certain percentage of
 * search ads are shown at the top of the first page (or other targeted
 * location).
 */
export interface TargetImpressionShare {
  /** The targeted location on the search results page. */
  location: TargetImpressionShareLocationEnum_TargetImpressionShareLocation;
  /**
   * The chosen fraction of ads to be shown in the targeted location in micros.
   * For example, 1% equals 10,000.
   */
  locationFractionMicros?:
    | Long
    | undefined;
  /**
   * The highest CPC bid the automated bidding system is permitted to specify.
   * This is a required field entered by the advertiser that sets the ceiling
   * and specified in local micros.
   */
  cpcBidCeilingMicros?: Long | undefined;
}

/**
 * An automated bidding strategy that sets bids based on the target fraction of
 * auctions where the advertiser should outrank a specific competitor.
 * This strategy is deprecated.
 */
export interface TargetOutrankShare {
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   */
  cpcBidCeilingMicros: Long | undefined;
}

/**
 * An automated bidding strategy that helps you maximize revenue while
 * averaging a specific target return on ad spend (ROAS).
 */
export interface TargetRoas {
  /**
   * Required. The chosen revenue (based on conversion data) per unit of spend.
   * Value must be between 0.01 and 1000.0, inclusive.
   */
  targetRoas?:
    | number
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidFloorMicros?: Long | undefined;
}

/**
 * An automated bid strategy that sets your bids to help get as many clicks
 * as possible within your budget.
 */
export interface TargetSpend {
  /**
   * Deprecated: The spend target under which to maximize clicks.
   * A TargetSpend bidder will attempt to spend the smaller of this value
   * or the natural throttling spend amount.
   * If not specified, the budget is used as the spend target.
   * This field is deprecated and should no longer be used. See
   * https://ads-developers.googleblog.com/2020/05/reminder-about-sunset-creation-of.html
   * for details.
   *
   * @deprecated
   */
  targetSpendMicros?:
    | Long
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   */
  cpcBidCeilingMicros?: Long | undefined;
}

/**
 * A bidding strategy where bids are a fraction of the advertised price for
 * some good or service.
 */
export interface PercentCpc {
  /**
   * Maximum bid limit that can be set by the bid strategy. This is
   * an optional field entered by the advertiser and specified in local micros.
   * Note: A zero value is interpreted in the same way as having bid_ceiling
   * undefined.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Adjusts the bid for each auction upward or downward, depending on the
   * likelihood of a conversion. Individual bids may exceed
   * cpc_bid_ceiling_micros, but the average bid amount for a campaign should
   * not.
   */
  enhancedCpcEnabled?: boolean | undefined;
}

function createBaseEnhancedCpc(): EnhancedCpc {
  return {};
}

export const EnhancedCpc: MessageFns<EnhancedCpc> = {
  encode(_: EnhancedCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnhancedCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnhancedCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnhancedCpc {
    return {};
  },

  toJSON(_: EnhancedCpc): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EnhancedCpc>): EnhancedCpc {
    return EnhancedCpc.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EnhancedCpc>): EnhancedCpc {
    const message = createBaseEnhancedCpc();
    return message;
  },
};

function createBaseManualCpa(): ManualCpa {
  return {};
}

export const ManualCpa: MessageFns<ManualCpa> = {
  encode(_: ManualCpa, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpa {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpa();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ManualCpa {
    return {};
  },

  toJSON(_: ManualCpa): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ManualCpa>): ManualCpa {
    return ManualCpa.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ManualCpa>): ManualCpa {
    const message = createBaseManualCpa();
    return message;
  },
};

function createBaseManualCpc(): ManualCpc {
  return { enhancedCpcEnabled: undefined };
}

export const ManualCpc: MessageFns<ManualCpc> = {
  encode(message: ManualCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enhancedCpcEnabled !== undefined) {
      writer.uint32(16).bool(message.enhancedCpcEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enhancedCpcEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualCpc {
    return {
      enhancedCpcEnabled: isSet(object.enhancedCpcEnabled) ? globalThis.Boolean(object.enhancedCpcEnabled) : undefined,
    };
  },

  toJSON(message: ManualCpc): unknown {
    const obj: any = {};
    if (message.enhancedCpcEnabled !== undefined) {
      obj.enhancedCpcEnabled = message.enhancedCpcEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ManualCpc>): ManualCpc {
    return ManualCpc.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualCpc>): ManualCpc {
    const message = createBaseManualCpc();
    message.enhancedCpcEnabled = object.enhancedCpcEnabled ?? undefined;
    return message;
  },
};

function createBaseManualCpm(): ManualCpm {
  return {};
}

export const ManualCpm: MessageFns<ManualCpm> = {
  encode(_: ManualCpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ManualCpm {
    return {};
  },

  toJSON(_: ManualCpm): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ManualCpm>): ManualCpm {
    return ManualCpm.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ManualCpm>): ManualCpm {
    const message = createBaseManualCpm();
    return message;
  },
};

function createBaseMaximizeConversions(): MaximizeConversions {
  return { cpcBidCeilingMicros: Long.ZERO, cpcBidFloorMicros: Long.ZERO, targetCpaMicros: Long.ZERO };
}

export const MaximizeConversions: MessageFns<MaximizeConversions> = {
  encode(message: MaximizeConversions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.cpcBidCeilingMicros.toString());
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.cpcBidFloorMicros.toString());
    }
    if (!message.targetCpaMicros.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.targetCpaMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeConversions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeConversions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetCpaMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeConversions {
    return {
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : Long.ZERO,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : Long.ZERO,
      targetCpaMicros: isSet(object.targetCpaMicros) ? Long.fromValue(object.targetCpaMicros) : Long.ZERO,
    };
  },

  toJSON(message: MaximizeConversions): unknown {
    const obj: any = {};
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    if (!message.targetCpaMicros.equals(Long.ZERO)) {
      obj.targetCpaMicros = (message.targetCpaMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeConversions>): MaximizeConversions {
    return MaximizeConversions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeConversions>): MaximizeConversions {
    const message = createBaseMaximizeConversions();
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : Long.ZERO;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : Long.ZERO;
    message.targetCpaMicros = (object.targetCpaMicros !== undefined && object.targetCpaMicros !== null)
      ? Long.fromValue(object.targetCpaMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseMaximizeConversionValue(): MaximizeConversionValue {
  return { targetRoas: undefined, cpcBidCeilingMicros: Long.ZERO, cpcBidFloorMicros: Long.ZERO };
}

export const MaximizeConversionValue: MessageFns<MaximizeConversionValue> = {
  encode(message: MaximizeConversionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRoas !== undefined) {
      writer.uint32(17).double(message.targetRoas);
    }
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.cpcBidCeilingMicros.toString());
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeConversionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeConversionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 17) {
            break;
          }

          message.targetRoas = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeConversionValue {
    return {
      targetRoas: isSet(object.targetRoas) ? globalThis.Number(object.targetRoas) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : Long.ZERO,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : Long.ZERO,
    };
  },

  toJSON(message: MaximizeConversionValue): unknown {
    const obj: any = {};
    if (message.targetRoas !== undefined) {
      obj.targetRoas = message.targetRoas;
    }
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeConversionValue>): MaximizeConversionValue {
    return MaximizeConversionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeConversionValue>): MaximizeConversionValue {
    const message = createBaseMaximizeConversionValue();
    message.targetRoas = object.targetRoas ?? undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : Long.ZERO;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseTargetCpa(): TargetCpa {
  return { targetCpaMicros: undefined, cpcBidCeilingMicros: undefined, cpcBidFloorMicros: undefined };
}

export const TargetCpa: MessageFns<TargetCpa> = {
  encode(message: TargetCpa, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetCpaMicros !== undefined) {
      writer.uint32(32).int64(message.targetCpaMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.cpcBidFloorMicros !== undefined) {
      writer.uint32(48).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpa {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpa();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetCpaMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetCpa {
    return {
      targetCpaMicros: isSet(object.targetCpaMicros) ? Long.fromValue(object.targetCpaMicros) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : undefined,
    };
  },

  toJSON(message: TargetCpa): unknown {
    const obj: any = {};
    if (message.targetCpaMicros !== undefined) {
      obj.targetCpaMicros = (message.targetCpaMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.cpcBidFloorMicros !== undefined) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetCpa>): TargetCpa {
    return TargetCpa.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetCpa>): TargetCpa {
    const message = createBaseTargetCpa();
    message.targetCpaMicros = (object.targetCpaMicros !== undefined && object.targetCpaMicros !== null)
      ? Long.fromValue(object.targetCpaMicros)
      : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetCpm(): TargetCpm {
  return {};
}

export const TargetCpm: MessageFns<TargetCpm> = {
  encode(_: TargetCpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TargetCpm {
    return {};
  },

  toJSON(_: TargetCpm): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TargetCpm>): TargetCpm {
    return TargetCpm.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TargetCpm>): TargetCpm {
    const message = createBaseTargetCpm();
    return message;
  },
};

function createBaseTargetImpressionShare(): TargetImpressionShare {
  return { location: 0, locationFractionMicros: undefined, cpcBidCeilingMicros: undefined };
}

export const TargetImpressionShare: MessageFns<TargetImpressionShare> = {
  encode(message: TargetImpressionShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== 0) {
      writer.uint32(8).int32(message.location);
    }
    if (message.locationFractionMicros !== undefined) {
      writer.uint32(32).int64(message.locationFractionMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetImpressionShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetImpressionShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.location = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.locationFractionMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetImpressionShare {
    return {
      location: isSet(object.location)
        ? targetImpressionShareLocationEnum_TargetImpressionShareLocationFromJSON(object.location)
        : 0,
      locationFractionMicros: isSet(object.locationFractionMicros)
        ? Long.fromValue(object.locationFractionMicros)
        : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
    };
  },

  toJSON(message: TargetImpressionShare): unknown {
    const obj: any = {};
    if (message.location !== 0) {
      obj.location = targetImpressionShareLocationEnum_TargetImpressionShareLocationToJSON(message.location);
    }
    if (message.locationFractionMicros !== undefined) {
      obj.locationFractionMicros = (message.locationFractionMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetImpressionShare>): TargetImpressionShare {
    return TargetImpressionShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetImpressionShare>): TargetImpressionShare {
    const message = createBaseTargetImpressionShare();
    message.location = object.location ?? 0;
    message.locationFractionMicros =
      (object.locationFractionMicros !== undefined && object.locationFractionMicros !== null)
        ? Long.fromValue(object.locationFractionMicros)
        : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetOutrankShare(): TargetOutrankShare {
  return { cpcBidCeilingMicros: undefined };
}

export const TargetOutrankShare: MessageFns<TargetOutrankShare> = {
  encode(message: TargetOutrankShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpcBidCeilingMicros !== undefined) {
      Int64Value.encode({ value: message.cpcBidCeilingMicros! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetOutrankShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetOutrankShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cpcBidCeilingMicros = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetOutrankShare {
    return {
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
    };
  },

  toJSON(message: TargetOutrankShare): unknown {
    const obj: any = {};
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = message.cpcBidCeilingMicros;
    }
    return obj;
  },

  create(base?: DeepPartial<TargetOutrankShare>): TargetOutrankShare {
    return TargetOutrankShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetOutrankShare>): TargetOutrankShare {
    const message = createBaseTargetOutrankShare();
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetRoas(): TargetRoas {
  return { targetRoas: undefined, cpcBidCeilingMicros: undefined, cpcBidFloorMicros: undefined };
}

export const TargetRoas: MessageFns<TargetRoas> = {
  encode(message: TargetRoas, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRoas !== undefined) {
      writer.uint32(33).double(message.targetRoas);
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.cpcBidFloorMicros !== undefined) {
      writer.uint32(48).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetRoas {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetRoas();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 33) {
            break;
          }

          message.targetRoas = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetRoas {
    return {
      targetRoas: isSet(object.targetRoas) ? globalThis.Number(object.targetRoas) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : undefined,
    };
  },

  toJSON(message: TargetRoas): unknown {
    const obj: any = {};
    if (message.targetRoas !== undefined) {
      obj.targetRoas = message.targetRoas;
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.cpcBidFloorMicros !== undefined) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetRoas>): TargetRoas {
    return TargetRoas.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetRoas>): TargetRoas {
    const message = createBaseTargetRoas();
    message.targetRoas = object.targetRoas ?? undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetSpend(): TargetSpend {
  return { targetSpendMicros: undefined, cpcBidCeilingMicros: undefined };
}

export const TargetSpend: MessageFns<TargetSpend> = {
  encode(message: TargetSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetSpendMicros !== undefined) {
      writer.uint32(24).int64(message.targetSpendMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(32).int64(message.cpcBidCeilingMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetSpendMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetSpend {
    return {
      targetSpendMicros: isSet(object.targetSpendMicros) ? Long.fromValue(object.targetSpendMicros) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
    };
  },

  toJSON(message: TargetSpend): unknown {
    const obj: any = {};
    if (message.targetSpendMicros !== undefined) {
      obj.targetSpendMicros = (message.targetSpendMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetSpend>): TargetSpend {
    return TargetSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetSpend>): TargetSpend {
    const message = createBaseTargetSpend();
    message.targetSpendMicros = (object.targetSpendMicros !== undefined && object.targetSpendMicros !== null)
      ? Long.fromValue(object.targetSpendMicros)
      : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    return message;
  },
};

function createBasePercentCpc(): PercentCpc {
  return { cpcBidCeilingMicros: undefined, enhancedCpcEnabled: undefined };
}

export const PercentCpc: MessageFns<PercentCpc> = {
  encode(message: PercentCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(24).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.enhancedCpcEnabled !== undefined) {
      writer.uint32(32).bool(message.enhancedCpcEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PercentCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePercentCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enhancedCpcEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PercentCpc {
    return {
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      enhancedCpcEnabled: isSet(object.enhancedCpcEnabled) ? globalThis.Boolean(object.enhancedCpcEnabled) : undefined,
    };
  },

  toJSON(message: PercentCpc): unknown {
    const obj: any = {};
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.enhancedCpcEnabled !== undefined) {
      obj.enhancedCpcEnabled = message.enhancedCpcEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PercentCpc>): PercentCpc {
    return PercentCpc.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PercentCpc>): PercentCpc {
    const message = createBasePercentCpc();
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.enhancedCpcEnabled = object.enhancedCpcEnabled ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
