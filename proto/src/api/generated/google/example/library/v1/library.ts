// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/example/library/v1/library.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";

export const protobufPackage = "google.example.library.v1";

/** A single book in the library. */
export interface Book {
  /**
   * The resource name of the book.
   * Book names have the form `shelves/{shelf_id}/books/{book_id}`.
   * The name is ignored when creating a book.
   */
  name: string;
  /** The name of the book author. */
  author: string;
  /** The title of the book. */
  title: string;
  /** Value indicating whether the book has been read. */
  read: boolean;
}

/** A Shelf contains a collection of books with a theme. */
export interface Shelf {
  /**
   * The resource name of the shelf.
   * Shelf names have the form `shelves/{shelf_id}`.
   * The name is ignored when creating a shelf.
   */
  name: string;
  /** The theme of the shelf */
  theme: string;
}

/** Request message for LibraryService.CreateShelf. */
export interface CreateShelfRequest {
  /** The shelf to create. */
  shelf: Shelf | undefined;
}

/** Request message for LibraryService.GetShelf. */
export interface GetShelfRequest {
  /** The name of the shelf to retrieve. */
  name: string;
}

/** Request message for LibraryService.ListShelves. */
export interface ListShelvesRequest {
  /**
   * Requested page size. Server may return fewer shelves than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /**
   * A token identifying a page of results the server should return.
   * Typically, this is the value of
   * [ListShelvesResponse.next_page_token][google.example.library.v1.ListShelvesResponse.next_page_token]
   * returned from the previous call to `ListShelves` method.
   */
  pageToken: string;
}

/** Response message for LibraryService.ListShelves. */
export interface ListShelvesResponse {
  /** The list of shelves. */
  shelves: Shelf[];
  /**
   * A token to retrieve next page of results.
   * Pass this value in the
   * [ListShelvesRequest.page_token][google.example.library.v1.ListShelvesRequest.page_token]
   * field in the subsequent call to `ListShelves` method to retrieve the next
   * page of results.
   */
  nextPageToken: string;
}

/** Request message for LibraryService.DeleteShelf. */
export interface DeleteShelfRequest {
  /** The name of the shelf to delete. */
  name: string;
}

/**
 * Describes the shelf being removed (other_shelf_name) and updated
 * (name) in this merge.
 */
export interface MergeShelvesRequest {
  /** The name of the shelf we're adding books to. */
  name: string;
  /** The name of the shelf we're removing books from and deleting. */
  otherShelf: string;
}

/** Request message for LibraryService.CreateBook. */
export interface CreateBookRequest {
  /** The name of the shelf in which the book is created. */
  parent: string;
  /** The book to create. */
  book: Book | undefined;
}

/** Request message for LibraryService.GetBook. */
export interface GetBookRequest {
  /** The name of the book to retrieve. */
  name: string;
}

/** Request message for LibraryService.ListBooks. */
export interface ListBooksRequest {
  /** The name of the shelf whose books we'd like to list. */
  parent: string;
  /**
   * Requested page size. Server may return fewer books than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /**
   * A token identifying a page of results the server should return.
   * Typically, this is the value of
   * [ListBooksResponse.next_page_token][google.example.library.v1.ListBooksResponse.next_page_token].
   * returned from the previous call to `ListBooks` method.
   */
  pageToken: string;
}

/** Response message for LibraryService.ListBooks. */
export interface ListBooksResponse {
  /** The list of books. */
  books: Book[];
  /**
   * A token to retrieve next page of results.
   * Pass this value in the
   * [ListBooksRequest.page_token][google.example.library.v1.ListBooksRequest.page_token]
   * field in the subsequent call to `ListBooks` method to retrieve the next
   * page of results.
   */
  nextPageToken: string;
}

/** Request message for LibraryService.UpdateBook. */
export interface UpdateBookRequest {
  /** The name of the book to update. */
  book:
    | Book
    | undefined;
  /** Required. Mask of fields to update. */
  updateMask: string[] | undefined;
}

/** Request message for LibraryService.DeleteBook. */
export interface DeleteBookRequest {
  /** The name of the book to delete. */
  name: string;
}

/**
 * Describes what book to move (name) and what shelf we're moving it
 * to (other_shelf_name).
 */
export interface MoveBookRequest {
  /** The name of the book to move. */
  name: string;
  /** The name of the destination shelf. */
  otherShelfName: string;
}

function createBaseBook(): Book {
  return { name: "", author: "", title: "", read: false };
}

export const Book: MessageFns<Book> = {
  encode(message: Book, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.author !== "") {
      writer.uint32(18).string(message.author);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.read !== false) {
      writer.uint32(32).bool(message.read);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Book {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.author = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.read = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Book {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      read: isSet(object.read) ? globalThis.Boolean(object.read) : false,
    };
  },

  toJSON(message: Book): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.read !== false) {
      obj.read = message.read;
    }
    return obj;
  },

  create(base?: DeepPartial<Book>): Book {
    return Book.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Book>): Book {
    const message = createBaseBook();
    message.name = object.name ?? "";
    message.author = object.author ?? "";
    message.title = object.title ?? "";
    message.read = object.read ?? false;
    return message;
  },
};

function createBaseShelf(): Shelf {
  return { name: "", theme: "" };
}

export const Shelf: MessageFns<Shelf> = {
  encode(message: Shelf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.theme !== "") {
      writer.uint32(18).string(message.theme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shelf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShelf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.theme = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shelf {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      theme: isSet(object.theme) ? globalThis.String(object.theme) : "",
    };
  },

  toJSON(message: Shelf): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.theme !== "") {
      obj.theme = message.theme;
    }
    return obj;
  },

  create(base?: DeepPartial<Shelf>): Shelf {
    return Shelf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shelf>): Shelf {
    const message = createBaseShelf();
    message.name = object.name ?? "";
    message.theme = object.theme ?? "";
    return message;
  },
};

function createBaseCreateShelfRequest(): CreateShelfRequest {
  return { shelf: undefined };
}

export const CreateShelfRequest: MessageFns<CreateShelfRequest> = {
  encode(message: CreateShelfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shelf !== undefined) {
      Shelf.encode(message.shelf, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateShelfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateShelfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shelf = Shelf.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateShelfRequest {
    return { shelf: isSet(object.shelf) ? Shelf.fromJSON(object.shelf) : undefined };
  },

  toJSON(message: CreateShelfRequest): unknown {
    const obj: any = {};
    if (message.shelf !== undefined) {
      obj.shelf = Shelf.toJSON(message.shelf);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateShelfRequest>): CreateShelfRequest {
    return CreateShelfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateShelfRequest>): CreateShelfRequest {
    const message = createBaseCreateShelfRequest();
    message.shelf = (object.shelf !== undefined && object.shelf !== null) ? Shelf.fromPartial(object.shelf) : undefined;
    return message;
  },
};

function createBaseGetShelfRequest(): GetShelfRequest {
  return { name: "" };
}

export const GetShelfRequest: MessageFns<GetShelfRequest> = {
  encode(message: GetShelfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShelfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShelfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetShelfRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetShelfRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetShelfRequest>): GetShelfRequest {
    return GetShelfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetShelfRequest>): GetShelfRequest {
    const message = createBaseGetShelfRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListShelvesRequest(): ListShelvesRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListShelvesRequest: MessageFns<ListShelvesRequest> = {
  encode(message: ListShelvesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShelvesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShelvesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShelvesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListShelvesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListShelvesRequest>): ListShelvesRequest {
    return ListShelvesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListShelvesRequest>): ListShelvesRequest {
    const message = createBaseListShelvesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListShelvesResponse(): ListShelvesResponse {
  return { shelves: [], nextPageToken: "" };
}

export const ListShelvesResponse: MessageFns<ListShelvesResponse> = {
  encode(message: ListShelvesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.shelves) {
      Shelf.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShelvesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShelvesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shelves.push(Shelf.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShelvesResponse {
    return {
      shelves: globalThis.Array.isArray(object?.shelves) ? object.shelves.map((e: any) => Shelf.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListShelvesResponse): unknown {
    const obj: any = {};
    if (message.shelves?.length) {
      obj.shelves = message.shelves.map((e) => Shelf.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListShelvesResponse>): ListShelvesResponse {
    return ListShelvesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListShelvesResponse>): ListShelvesResponse {
    const message = createBaseListShelvesResponse();
    message.shelves = object.shelves?.map((e) => Shelf.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteShelfRequest(): DeleteShelfRequest {
  return { name: "" };
}

export const DeleteShelfRequest: MessageFns<DeleteShelfRequest> = {
  encode(message: DeleteShelfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteShelfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteShelfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteShelfRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteShelfRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteShelfRequest>): DeleteShelfRequest {
    return DeleteShelfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteShelfRequest>): DeleteShelfRequest {
    const message = createBaseDeleteShelfRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMergeShelvesRequest(): MergeShelvesRequest {
  return { name: "", otherShelf: "" };
}

export const MergeShelvesRequest: MessageFns<MergeShelvesRequest> = {
  encode(message: MergeShelvesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.otherShelf !== "") {
      writer.uint32(18).string(message.otherShelf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeShelvesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeShelvesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.otherShelf = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeShelvesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      otherShelf: isSet(object.otherShelf) ? globalThis.String(object.otherShelf) : "",
    };
  },

  toJSON(message: MergeShelvesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.otherShelf !== "") {
      obj.otherShelf = message.otherShelf;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeShelvesRequest>): MergeShelvesRequest {
    return MergeShelvesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeShelvesRequest>): MergeShelvesRequest {
    const message = createBaseMergeShelvesRequest();
    message.name = object.name ?? "";
    message.otherShelf = object.otherShelf ?? "";
    return message;
  },
};

function createBaseCreateBookRequest(): CreateBookRequest {
  return { parent: "", book: undefined };
}

export const CreateBookRequest: MessageFns<CreateBookRequest> = {
  encode(message: CreateBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.book !== undefined) {
      Book.encode(message.book, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.book = Book.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBookRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      book: isSet(object.book) ? Book.fromJSON(object.book) : undefined,
    };
  },

  toJSON(message: CreateBookRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.book !== undefined) {
      obj.book = Book.toJSON(message.book);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBookRequest>): CreateBookRequest {
    return CreateBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBookRequest>): CreateBookRequest {
    const message = createBaseCreateBookRequest();
    message.parent = object.parent ?? "";
    message.book = (object.book !== undefined && object.book !== null) ? Book.fromPartial(object.book) : undefined;
    return message;
  },
};

function createBaseGetBookRequest(): GetBookRequest {
  return { name: "" };
}

export const GetBookRequest: MessageFns<GetBookRequest> = {
  encode(message: GetBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBookRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBookRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBookRequest>): GetBookRequest {
    return GetBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBookRequest>): GetBookRequest {
    const message = createBaseGetBookRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListBooksRequest(): ListBooksRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListBooksRequest: MessageFns<ListBooksRequest> = {
  encode(message: ListBooksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBooksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBooksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListBooksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBooksRequest>): ListBooksRequest {
    return ListBooksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBooksRequest>): ListBooksRequest {
    const message = createBaseListBooksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListBooksResponse(): ListBooksResponse {
  return { books: [], nextPageToken: "" };
}

export const ListBooksResponse: MessageFns<ListBooksResponse> = {
  encode(message: ListBooksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.books) {
      Book.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBooksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.books.push(Book.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBooksResponse {
    return {
      books: globalThis.Array.isArray(object?.books) ? object.books.map((e: any) => Book.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBooksResponse): unknown {
    const obj: any = {};
    if (message.books?.length) {
      obj.books = message.books.map((e) => Book.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBooksResponse>): ListBooksResponse {
    return ListBooksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBooksResponse>): ListBooksResponse {
    const message = createBaseListBooksResponse();
    message.books = object.books?.map((e) => Book.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateBookRequest(): UpdateBookRequest {
  return { book: undefined, updateMask: undefined };
}

export const UpdateBookRequest: MessageFns<UpdateBookRequest> = {
  encode(message: UpdateBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.book !== undefined) {
      Book.encode(message.book, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.book = Book.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBookRequest {
    return {
      book: isSet(object.book) ? Book.fromJSON(object.book) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateBookRequest): unknown {
    const obj: any = {};
    if (message.book !== undefined) {
      obj.book = Book.toJSON(message.book);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBookRequest>): UpdateBookRequest {
    return UpdateBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBookRequest>): UpdateBookRequest {
    const message = createBaseUpdateBookRequest();
    message.book = (object.book !== undefined && object.book !== null) ? Book.fromPartial(object.book) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteBookRequest(): DeleteBookRequest {
  return { name: "" };
}

export const DeleteBookRequest: MessageFns<DeleteBookRequest> = {
  encode(message: DeleteBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBookRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteBookRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBookRequest>): DeleteBookRequest {
    return DeleteBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBookRequest>): DeleteBookRequest {
    const message = createBaseDeleteBookRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMoveBookRequest(): MoveBookRequest {
  return { name: "", otherShelfName: "" };
}

export const MoveBookRequest: MessageFns<MoveBookRequest> = {
  encode(message: MoveBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.otherShelfName !== "") {
      writer.uint32(18).string(message.otherShelfName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.otherShelfName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveBookRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      otherShelfName: isSet(object.otherShelfName) ? globalThis.String(object.otherShelfName) : "",
    };
  },

  toJSON(message: MoveBookRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.otherShelfName !== "") {
      obj.otherShelfName = message.otherShelfName;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveBookRequest>): MoveBookRequest {
    return MoveBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveBookRequest>): MoveBookRequest {
    const message = createBaseMoveBookRequest();
    message.name = object.name ?? "";
    message.otherShelfName = object.otherShelfName ?? "";
    return message;
  },
};

/**
 * This API represents a simple digital library. It lets you manage Shelf
 * resources and Book resources in the library. It defines the following
 * resource model:
 *
 * - The API has a collection of [Shelf][google.example.library.v1.Shelf]
 *   resources, named `shelves/*`
 *
 * - Each Shelf has a collection of [Book][google.example.library.v1.Book]
 *   resources, named `shelves/* /books/*`
 */
export type LibraryServiceDefinition = typeof LibraryServiceDefinition;
export const LibraryServiceDefinition = {
  name: "LibraryService",
  fullName: "google.example.library.v1.LibraryService",
  methods: {
    /** Creates a shelf, and returns the new Shelf. */
    createShelf: {
      name: "CreateShelf",
      requestType: CreateShelfRequest,
      requestStream: false,
      responseType: Shelf,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 115, 104, 101, 108, 102])],
          578365826: [
            Buffer.from([
              20,
              58,
              5,
              115,
              104,
              101,
              108,
              102,
              34,
              11,
              47,
              118,
              49,
              47,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a shelf. Returns NOT_FOUND if the shelf does not exist. */
    getShelf: {
      name: "GetShelf",
      requestType: GetShelfRequest,
      requestStream: false,
      responseType: Shelf,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              22,
              18,
              20,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists shelves. The order is unspecified but deterministic. Newly created
     * shelves will not necessarily be added to the end of this list.
     */
    listShelves: {
      name: "ListShelves",
      requestType: ListShelvesRequest,
      requestStream: false,
      responseType: ListShelvesResponse,
      responseStream: false,
      options: {
        _unknownFields: { 578365826: [Buffer.from([13, 18, 11, 47, 118, 49, 47, 115, 104, 101, 108, 118, 101, 115])] },
      },
    },
    /** Deletes a shelf. Returns NOT_FOUND if the shelf does not exist. */
    deleteShelf: {
      name: "DeleteShelf",
      requestType: DeleteShelfRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              22,
              42,
              20,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Merges two shelves by adding all books from the shelf named
     * `other_shelf_name` to shelf `name`, and deletes
     * `other_shelf_name`. Returns the updated shelf.
     * The book ids of the moved books may not be the same as the original books.
     *
     * Returns NOT_FOUND if either shelf does not exist.
     * This call is a no-op if the specified shelves are the same.
     */
    mergeShelves: {
      name: "MergeShelves",
      requestType: MergeShelvesRequest,
      requestStream: false,
      responseType: Shelf,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 111, 116, 104, 101, 114, 95, 115, 104, 101, 108, 102])],
          578365826: [
            Buffer.from([
              31,
              58,
              1,
              42,
              34,
              26,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              125,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a book, and returns the new Book. */
    createBook: {
      name: "CreateBook",
      requestType: CreateBookRequest,
      requestStream: false,
      responseType: Book,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 98, 111, 111, 107])],
          578365826: [
            Buffer.from([
              36,
              58,
              4,
              98,
              111,
              111,
              107,
              34,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              125,
              47,
              98,
              111,
              111,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a book. Returns NOT_FOUND if the book does not exist. */
    getBook: {
      name: "GetBook",
      requestType: GetBookRequest,
      requestStream: false,
      responseType: Book,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              47,
              98,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists books in a shelf. The order is unspecified but deterministic. Newly
     * created books will not necessarily be added to the end of this list.
     * Returns NOT_FOUND if the shelf does not exist.
     */
    listBooks: {
      name: "ListBooks",
      requestType: ListBooksRequest,
      requestStream: false,
      responseType: ListBooksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              125,
              47,
              98,
              111,
              111,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a book. Returns NOT_FOUND if the book does not exist. */
    deleteBook: {
      name: "DeleteBook",
      requestType: DeleteBookRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              30,
              42,
              28,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              47,
              98,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a book. Returns INVALID_ARGUMENT if the name of the book
     * is non-empty and does not equal the existing name.
     */
    updateBook: {
      name: "UpdateBook",
      requestType: UpdateBookRequest,
      requestStream: false,
      responseType: Book,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 98, 111, 111, 107, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              41,
              58,
              4,
              98,
              111,
              111,
              107,
              50,
              33,
              47,
              118,
              49,
              47,
              123,
              98,
              111,
              111,
              107,
              46,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              47,
              98,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Moves a book to another shelf, and returns the new book. The book
     * id of the new book may not be the same as the original book.
     */
    moveBook: {
      name: "MoveBook",
      requestType: MoveBookRequest,
      requestStream: false,
      responseType: Book,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              110,
              97,
              109,
              101,
              44,
              111,
              116,
              104,
              101,
              114,
              95,
              115,
              104,
              101,
              108,
              102,
              95,
              110,
              97,
              109,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              38,
              58,
              1,
              42,
              34,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              115,
              104,
              101,
              108,
              118,
              101,
              115,
              47,
              42,
              47,
              98,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
              58,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface LibraryServiceImplementation<CallContextExt = {}> {
  /** Creates a shelf, and returns the new Shelf. */
  createShelf(request: CreateShelfRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Shelf>>;
  /** Gets a shelf. Returns NOT_FOUND if the shelf does not exist. */
  getShelf(request: GetShelfRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Shelf>>;
  /**
   * Lists shelves. The order is unspecified but deterministic. Newly created
   * shelves will not necessarily be added to the end of this list.
   */
  listShelves(
    request: ListShelvesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListShelvesResponse>>;
  /** Deletes a shelf. Returns NOT_FOUND if the shelf does not exist. */
  deleteShelf(request: DeleteShelfRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Merges two shelves by adding all books from the shelf named
   * `other_shelf_name` to shelf `name`, and deletes
   * `other_shelf_name`. Returns the updated shelf.
   * The book ids of the moved books may not be the same as the original books.
   *
   * Returns NOT_FOUND if either shelf does not exist.
   * This call is a no-op if the specified shelves are the same.
   */
  mergeShelves(request: MergeShelvesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Shelf>>;
  /** Creates a book, and returns the new Book. */
  createBook(request: CreateBookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Book>>;
  /** Gets a book. Returns NOT_FOUND if the book does not exist. */
  getBook(request: GetBookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Book>>;
  /**
   * Lists books in a shelf. The order is unspecified but deterministic. Newly
   * created books will not necessarily be added to the end of this list.
   * Returns NOT_FOUND if the shelf does not exist.
   */
  listBooks(request: ListBooksRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListBooksResponse>>;
  /** Deletes a book. Returns NOT_FOUND if the book does not exist. */
  deleteBook(request: DeleteBookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Updates a book. Returns INVALID_ARGUMENT if the name of the book
   * is non-empty and does not equal the existing name.
   */
  updateBook(request: UpdateBookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Book>>;
  /**
   * Moves a book to another shelf, and returns the new book. The book
   * id of the new book may not be the same as the original book.
   */
  moveBook(request: MoveBookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Book>>;
}

export interface LibraryServiceClient<CallOptionsExt = {}> {
  /** Creates a shelf, and returns the new Shelf. */
  createShelf(request: DeepPartial<CreateShelfRequest>, options?: CallOptions & CallOptionsExt): Promise<Shelf>;
  /** Gets a shelf. Returns NOT_FOUND if the shelf does not exist. */
  getShelf(request: DeepPartial<GetShelfRequest>, options?: CallOptions & CallOptionsExt): Promise<Shelf>;
  /**
   * Lists shelves. The order is unspecified but deterministic. Newly created
   * shelves will not necessarily be added to the end of this list.
   */
  listShelves(
    request: DeepPartial<ListShelvesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListShelvesResponse>;
  /** Deletes a shelf. Returns NOT_FOUND if the shelf does not exist. */
  deleteShelf(request: DeepPartial<DeleteShelfRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Merges two shelves by adding all books from the shelf named
   * `other_shelf_name` to shelf `name`, and deletes
   * `other_shelf_name`. Returns the updated shelf.
   * The book ids of the moved books may not be the same as the original books.
   *
   * Returns NOT_FOUND if either shelf does not exist.
   * This call is a no-op if the specified shelves are the same.
   */
  mergeShelves(request: DeepPartial<MergeShelvesRequest>, options?: CallOptions & CallOptionsExt): Promise<Shelf>;
  /** Creates a book, and returns the new Book. */
  createBook(request: DeepPartial<CreateBookRequest>, options?: CallOptions & CallOptionsExt): Promise<Book>;
  /** Gets a book. Returns NOT_FOUND if the book does not exist. */
  getBook(request: DeepPartial<GetBookRequest>, options?: CallOptions & CallOptionsExt): Promise<Book>;
  /**
   * Lists books in a shelf. The order is unspecified but deterministic. Newly
   * created books will not necessarily be added to the end of this list.
   * Returns NOT_FOUND if the shelf does not exist.
   */
  listBooks(request: DeepPartial<ListBooksRequest>, options?: CallOptions & CallOptionsExt): Promise<ListBooksResponse>;
  /** Deletes a book. Returns NOT_FOUND if the book does not exist. */
  deleteBook(request: DeepPartial<DeleteBookRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Updates a book. Returns INVALID_ARGUMENT if the name of the book
   * is non-empty and does not equal the existing name.
   */
  updateBook(request: DeepPartial<UpdateBookRequest>, options?: CallOptions & CallOptionsExt): Promise<Book>;
  /**
   * Moves a book to another shelf, and returns the new book. The book
   * id of the new book may not be the same as the original book.
   */
  moveBook(request: DeepPartial<MoveBookRequest>, options?: CallOptions & CallOptionsExt): Promise<Book>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
