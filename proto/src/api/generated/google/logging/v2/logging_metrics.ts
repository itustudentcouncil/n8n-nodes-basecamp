// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/logging/v2/logging_metrics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Distribution_BucketOptions } from "../../api/distribution.js";
import { MetricDescriptor } from "../../api/metric.js";
import { Empty } from "../../protobuf/empty.js";
import { Timestamp } from "../../protobuf/timestamp.js";

export const protobufPackage = "google.logging.v2";

/**
 * Describes a logs-based metric. The value of the metric is the number of log
 * entries that match a logs filter in a given time interval.
 *
 * Logs-based metrics can also be used to extract values from logs and create a
 * distribution of the values. The distribution records the statistics of the
 * extracted values along with an optional histogram of the values as specified
 * by the bucket options.
 */
export interface LogMetric {
  /**
   * Required. The client-assigned metric identifier.
   * Examples: `"error_count"`, `"nginx/requests"`.
   *
   * Metric identifiers are limited to 100 characters and can include only the
   * following characters: `A-Z`, `a-z`, `0-9`, and the special characters
   * `_-.,+!*',()%/`. The forward-slash character (`/`) denotes a hierarchy of
   * name pieces, and it cannot be the first character of the name.
   *
   * This field is the `[METRIC_ID]` part of a metric resource name in the
   * format "projects/[PROJECT_ID]/metrics/[METRIC_ID]". Example: If the
   * resource name of a metric is
   * `"projects/my-project/metrics/nginx%2Frequests"`, this field's value is
   * `"nginx/requests"`.
   */
  name: string;
  /**
   * Optional. A description of this metric, which is used in documentation.
   * The maximum length of the description is 8000 characters.
   */
  description: string;
  /**
   * Required. An [advanced logs
   * filter](https://cloud.google.com/logging/docs/view/advanced_filters) which
   * is used to match log entries. Example:
   *
   *     "resource.type=gae_app AND severity>=ERROR"
   *
   * The maximum length of the filter is 20000 characters.
   */
  filter: string;
  /**
   * Optional. The resource name of the Log Bucket that owns the Log Metric.
   * Only Log Buckets in projects are supported. The bucket has to be in the
   * same project as the metric.
   *
   * For example:
   *
   *   `projects/my-project/locations/global/buckets/my-bucket`
   *
   * If empty, then the Log Metric is considered a non-Bucket Log Metric.
   */
  bucketName: string;
  /**
   * Optional. If set to True, then this metric is disabled and it does not
   * generate any points.
   */
  disabled: boolean;
  /**
   * Optional. The metric descriptor associated with the logs-based metric.
   * If unspecified, it uses a default metric descriptor with a DELTA metric
   * kind, INT64 value type, with no labels and a unit of "1". Such a metric
   * counts the number of log entries matching the `filter` expression.
   *
   * The `name`, `type`, and `description` fields in the `metric_descriptor`
   * are output only, and is constructed using the `name` and `description`
   * field in the LogMetric.
   *
   * To create a logs-based metric that records a distribution of log values, a
   * DELTA metric kind with a DISTRIBUTION value type must be used along with
   * a `value_extractor` expression in the LogMetric.
   *
   * Each label in the metric descriptor must have a matching label
   * name as the key and an extractor expression as the value in the
   * `label_extractors` map.
   *
   * The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
   * be updated once initially configured. New labels can be added in the
   * `metric_descriptor`, but existing labels cannot be modified except for
   * their description.
   */
  metricDescriptor:
    | MetricDescriptor
    | undefined;
  /**
   * Optional. A `value_extractor` is required when using a distribution
   * logs-based metric to extract the values to record from a log entry.
   * Two functions are supported for value extraction: `EXTRACT(field)` or
   * `REGEXP_EXTRACT(field, regex)`. The arguments are:
   *
   *   1. field: The name of the log entry field from which the value is to be
   *      extracted.
   *   2. regex: A regular expression using the Google RE2 syntax
   *      (https://github.com/google/re2/wiki/Syntax) with a single capture
   *      group to extract data from the specified log entry field. The value
   *      of the field is converted to a string before applying the regex.
   *      It is an error to specify a regex that does not include exactly one
   *      capture group.
   *
   * The result of the extraction must be convertible to a double type, as the
   * distribution always records double values. If either the extraction or
   * the conversion to double fails, then those values are not recorded in the
   * distribution.
   *
   * Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\d+).*")`
   */
  valueExtractor: string;
  /**
   * Optional. A map from a label key string to an extractor expression which is
   * used to extract data from a log entry field and assign as the label value.
   * Each label key specified in the LabelDescriptor must have an associated
   * extractor expression in this map. The syntax of the extractor expression
   * is the same as for the `value_extractor` field.
   *
   * The extracted value is converted to the type defined in the label
   * descriptor. If either the extraction or the type conversion fails,
   * the label will have a default value. The default value for a string
   * label is an empty string, for an integer label its 0, and for a boolean
   * label its `false`.
   *
   * Note that there are upper bounds on the maximum number of labels and the
   * number of active time series that are allowed in a project.
   */
  labelExtractors: { [key: string]: string };
  /**
   * Optional. The `bucket_options` are required when the logs-based metric is
   * using a DISTRIBUTION value type and it describes the bucket boundaries
   * used to create a histogram of the extracted values.
   */
  bucketOptions:
    | Distribution_BucketOptions
    | undefined;
  /**
   * Output only. The creation timestamp of the metric.
   *
   * This field may not be present for older metrics.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The last update timestamp of the metric.
   *
   * This field may not be present for older metrics.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Deprecated. The API version that created or updated this metric.
   * The v2 format is used by default and cannot be changed.
   *
   * @deprecated
   */
  version: LogMetric_ApiVersion;
}

/** Logging API version. */
export enum LogMetric_ApiVersion {
  /** V2 - Logging API v2. */
  V2 = 0,
  /** V1 - Logging API v1. */
  V1 = 1,
  UNRECOGNIZED = -1,
}

export function logMetric_ApiVersionFromJSON(object: any): LogMetric_ApiVersion {
  switch (object) {
    case 0:
    case "V2":
      return LogMetric_ApiVersion.V2;
    case 1:
    case "V1":
      return LogMetric_ApiVersion.V1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogMetric_ApiVersion.UNRECOGNIZED;
  }
}

export function logMetric_ApiVersionToJSON(object: LogMetric_ApiVersion): string {
  switch (object) {
    case LogMetric_ApiVersion.V2:
      return "V2";
    case LogMetric_ApiVersion.V1:
      return "V1";
    case LogMetric_ApiVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LogMetric_LabelExtractorsEntry {
  key: string;
  value: string;
}

/** The parameters to ListLogMetrics. */
export interface ListLogMetricsRequest {
  /**
   * Required. The name of the project containing the metrics:
   *
   *     "projects/[PROJECT_ID]"
   */
  parent: string;
  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method. `pageToken` must be the value of
   * `nextPageToken` from the previous response. The values of other method
   * parameters should be identical to those in the previous call.
   */
  pageToken: string;
  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored. The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   */
  pageSize: number;
}

/** Result returned from ListLogMetrics. */
export interface ListLogMetricsResponse {
  /** A list of logs-based metrics. */
  metrics: LogMetric[];
  /**
   * If there might be more results than appear in this response, then
   * `nextPageToken` is included. To get the next set of results, call this
   * method again using the value of `nextPageToken` as `pageToken`.
   */
  nextPageToken: string;
}

/** The parameters to GetLogMetric. */
export interface GetLogMetricRequest {
  /**
   * Required. The resource name of the desired metric:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   */
  metricName: string;
}

/** The parameters to CreateLogMetric. */
export interface CreateLogMetricRequest {
  /**
   * Required. The resource name of the project in which to create the metric:
   *
   *     "projects/[PROJECT_ID]"
   *
   * The new metric must be provided in the request.
   */
  parent: string;
  /**
   * Required. The new logs-based metric, which must not have an identifier that
   * already exists.
   */
  metric: LogMetric | undefined;
}

/** The parameters to UpdateLogMetric. */
export interface UpdateLogMetricRequest {
  /**
   * Required. The resource name of the metric to update:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   *
   * The updated metric must be provided in the request and it's
   * `name` field must be the same as `[METRIC_ID]` If the metric
   * does not exist in `[PROJECT_ID]`, then a new metric is created.
   */
  metricName: string;
  /** Required. The updated metric. */
  metric: LogMetric | undefined;
}

/** The parameters to DeleteLogMetric. */
export interface DeleteLogMetricRequest {
  /**
   * Required. The resource name of the metric to delete:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   */
  metricName: string;
}

function createBaseLogMetric(): LogMetric {
  return {
    name: "",
    description: "",
    filter: "",
    bucketName: "",
    disabled: false,
    metricDescriptor: undefined,
    valueExtractor: "",
    labelExtractors: {},
    bucketOptions: undefined,
    createTime: undefined,
    updateTime: undefined,
    version: 0,
  };
}

export const LogMetric: MessageFns<LogMetric> = {
  encode(message: LogMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.bucketName !== "") {
      writer.uint32(106).string(message.bucketName);
    }
    if (message.disabled !== false) {
      writer.uint32(96).bool(message.disabled);
    }
    if (message.metricDescriptor !== undefined) {
      MetricDescriptor.encode(message.metricDescriptor, writer.uint32(42).fork()).join();
    }
    if (message.valueExtractor !== "") {
      writer.uint32(50).string(message.valueExtractor);
    }
    Object.entries(message.labelExtractors).forEach(([key, value]) => {
      LogMetric_LabelExtractorsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.bucketOptions !== undefined) {
      Distribution_BucketOptions.encode(message.bucketOptions, writer.uint32(66).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.version !== 0) {
      writer.uint32(32).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metricDescriptor = MetricDescriptor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.valueExtractor = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = LogMetric_LabelExtractorsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labelExtractors[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bucketOptions = Distribution_BucketOptions.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMetric {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      metricDescriptor: isSet(object.metricDescriptor) ? MetricDescriptor.fromJSON(object.metricDescriptor) : undefined,
      valueExtractor: isSet(object.valueExtractor) ? globalThis.String(object.valueExtractor) : "",
      labelExtractors: isObject(object.labelExtractors)
        ? Object.entries(object.labelExtractors).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      bucketOptions: isSet(object.bucketOptions)
        ? Distribution_BucketOptions.fromJSON(object.bucketOptions)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      version: isSet(object.version) ? logMetric_ApiVersionFromJSON(object.version) : 0,
    };
  },

  toJSON(message: LogMetric): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.metricDescriptor !== undefined) {
      obj.metricDescriptor = MetricDescriptor.toJSON(message.metricDescriptor);
    }
    if (message.valueExtractor !== "") {
      obj.valueExtractor = message.valueExtractor;
    }
    if (message.labelExtractors) {
      const entries = Object.entries(message.labelExtractors);
      if (entries.length > 0) {
        obj.labelExtractors = {};
        entries.forEach(([k, v]) => {
          obj.labelExtractors[k] = v;
        });
      }
    }
    if (message.bucketOptions !== undefined) {
      obj.bucketOptions = Distribution_BucketOptions.toJSON(message.bucketOptions);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.version !== 0) {
      obj.version = logMetric_ApiVersionToJSON(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<LogMetric>): LogMetric {
    return LogMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogMetric>): LogMetric {
    const message = createBaseLogMetric();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.filter = object.filter ?? "";
    message.bucketName = object.bucketName ?? "";
    message.disabled = object.disabled ?? false;
    message.metricDescriptor = (object.metricDescriptor !== undefined && object.metricDescriptor !== null)
      ? MetricDescriptor.fromPartial(object.metricDescriptor)
      : undefined;
    message.valueExtractor = object.valueExtractor ?? "";
    message.labelExtractors = Object.entries(object.labelExtractors ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.bucketOptions = (object.bucketOptions !== undefined && object.bucketOptions !== null)
      ? Distribution_BucketOptions.fromPartial(object.bucketOptions)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseLogMetric_LabelExtractorsEntry(): LogMetric_LabelExtractorsEntry {
  return { key: "", value: "" };
}

export const LogMetric_LabelExtractorsEntry: MessageFns<LogMetric_LabelExtractorsEntry> = {
  encode(message: LogMetric_LabelExtractorsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMetric_LabelExtractorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMetric_LabelExtractorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMetric_LabelExtractorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LogMetric_LabelExtractorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LogMetric_LabelExtractorsEntry>): LogMetric_LabelExtractorsEntry {
    return LogMetric_LabelExtractorsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogMetric_LabelExtractorsEntry>): LogMetric_LabelExtractorsEntry {
    const message = createBaseLogMetric_LabelExtractorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListLogMetricsRequest(): ListLogMetricsRequest {
  return { parent: "", pageToken: "", pageSize: 0 };
}

export const ListLogMetricsRequest: MessageFns<ListLogMetricsRequest> = {
  encode(message: ListLogMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLogMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLogMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLogMetricsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListLogMetricsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListLogMetricsRequest>): ListLogMetricsRequest {
    return ListLogMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLogMetricsRequest>): ListLogMetricsRequest {
    const message = createBaseListLogMetricsRequest();
    message.parent = object.parent ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListLogMetricsResponse(): ListLogMetricsResponse {
  return { metrics: [], nextPageToken: "" };
}

export const ListLogMetricsResponse: MessageFns<ListLogMetricsResponse> = {
  encode(message: ListLogMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metrics) {
      LogMetric.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLogMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLogMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metrics.push(LogMetric.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLogMetricsResponse {
    return {
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => LogMetric.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListLogMetricsResponse): unknown {
    const obj: any = {};
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => LogMetric.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLogMetricsResponse>): ListLogMetricsResponse {
    return ListLogMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLogMetricsResponse>): ListLogMetricsResponse {
    const message = createBaseListLogMetricsResponse();
    message.metrics = object.metrics?.map((e) => LogMetric.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetLogMetricRequest(): GetLogMetricRequest {
  return { metricName: "" };
}

export const GetLogMetricRequest: MessageFns<GetLogMetricRequest> = {
  encode(message: GetLogMetricRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogMetricRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogMetricRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogMetricRequest {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: GetLogMetricRequest): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLogMetricRequest>): GetLogMetricRequest {
    return GetLogMetricRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLogMetricRequest>): GetLogMetricRequest {
    const message = createBaseGetLogMetricRequest();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

function createBaseCreateLogMetricRequest(): CreateLogMetricRequest {
  return { parent: "", metric: undefined };
}

export const CreateLogMetricRequest: MessageFns<CreateLogMetricRequest> = {
  encode(message: CreateLogMetricRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.metric !== undefined) {
      LogMetric.encode(message.metric, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLogMetricRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLogMetricRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metric = LogMetric.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLogMetricRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      metric: isSet(object.metric) ? LogMetric.fromJSON(object.metric) : undefined,
    };
  },

  toJSON(message: CreateLogMetricRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.metric !== undefined) {
      obj.metric = LogMetric.toJSON(message.metric);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateLogMetricRequest>): CreateLogMetricRequest {
    return CreateLogMetricRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateLogMetricRequest>): CreateLogMetricRequest {
    const message = createBaseCreateLogMetricRequest();
    message.parent = object.parent ?? "";
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? LogMetric.fromPartial(object.metric)
      : undefined;
    return message;
  },
};

function createBaseUpdateLogMetricRequest(): UpdateLogMetricRequest {
  return { metricName: "", metric: undefined };
}

export const UpdateLogMetricRequest: MessageFns<UpdateLogMetricRequest> = {
  encode(message: UpdateLogMetricRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.metric !== undefined) {
      LogMetric.encode(message.metric, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLogMetricRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLogMetricRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metric = LogMetric.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLogMetricRequest {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      metric: isSet(object.metric) ? LogMetric.fromJSON(object.metric) : undefined,
    };
  },

  toJSON(message: UpdateLogMetricRequest): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.metric !== undefined) {
      obj.metric = LogMetric.toJSON(message.metric);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateLogMetricRequest>): UpdateLogMetricRequest {
    return UpdateLogMetricRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateLogMetricRequest>): UpdateLogMetricRequest {
    const message = createBaseUpdateLogMetricRequest();
    message.metricName = object.metricName ?? "";
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? LogMetric.fromPartial(object.metric)
      : undefined;
    return message;
  },
};

function createBaseDeleteLogMetricRequest(): DeleteLogMetricRequest {
  return { metricName: "" };
}

export const DeleteLogMetricRequest: MessageFns<DeleteLogMetricRequest> = {
  encode(message: DeleteLogMetricRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLogMetricRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLogMetricRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteLogMetricRequest {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: DeleteLogMetricRequest): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteLogMetricRequest>): DeleteLogMetricRequest {
    return DeleteLogMetricRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteLogMetricRequest>): DeleteLogMetricRequest {
    const message = createBaseDeleteLogMetricRequest();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

/** Service for configuring logs-based metrics. */
export type MetricsServiceV2Definition = typeof MetricsServiceV2Definition;
export const MetricsServiceV2Definition = {
  name: "MetricsServiceV2",
  fullName: "google.logging.v2.MetricsServiceV2",
  methods: {
    /** Lists logs-based metrics. */
    listLogMetrics: {
      name: "ListLogMetrics",
      requestType: ListLogMetricsRequest,
      requestStream: false,
      responseType: ListLogMetricsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a logs-based metric. */
    getLogMetric: {
      name: "GetLogMetric",
      requestType: GetLogMetricRequest,
      requestStream: false,
      responseType: LogMetric,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 109, 101, 116, 114, 105, 99, 95, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              50,
              47,
              123,
              109,
              101,
              116,
              114,
              105,
              99,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a logs-based metric. */
    createLogMetric: {
      name: "CreateLogMetric",
      requestType: CreateLogMetricRequest,
      requestStream: false,
      responseType: LogMetric,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 109, 101, 116, 114, 105, 99])],
          578365826: [
            Buffer.from([
              41,
              58,
              6,
              109,
              101,
              116,
              114,
              105,
              99,
              34,
              31,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates or updates a logs-based metric. */
    updateLogMetric: {
      name: "UpdateLogMetric",
      requestType: UpdateLogMetricRequest,
      requestStream: false,
      responseType: LogMetric,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 109, 101, 116, 114, 105, 99, 95, 110, 97, 109, 101, 44, 109, 101, 116, 114, 105, 99]),
          ],
          578365826: [
            Buffer.from([
              48,
              58,
              6,
              109,
              101,
              116,
              114,
              105,
              99,
              26,
              38,
              47,
              118,
              50,
              47,
              123,
              109,
              101,
              116,
              114,
              105,
              99,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a logs-based metric. */
    deleteLogMetric: {
      name: "DeleteLogMetric",
      requestType: DeleteLogMetricRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 109, 101, 116, 114, 105, 99, 95, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              42,
              38,
              47,
              118,
              50,
              47,
              123,
              109,
              101,
              116,
              114,
              105,
              99,
              95,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface MetricsServiceV2ServiceImplementation<CallContextExt = {}> {
  /** Lists logs-based metrics. */
  listLogMetrics(
    request: ListLogMetricsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListLogMetricsResponse>>;
  /** Gets a logs-based metric. */
  getLogMetric(request: GetLogMetricRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LogMetric>>;
  /** Creates a logs-based metric. */
  createLogMetric(
    request: CreateLogMetricRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LogMetric>>;
  /** Creates or updates a logs-based metric. */
  updateLogMetric(
    request: UpdateLogMetricRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LogMetric>>;
  /** Deletes a logs-based metric. */
  deleteLogMetric(request: DeleteLogMetricRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface MetricsServiceV2Client<CallOptionsExt = {}> {
  /** Lists logs-based metrics. */
  listLogMetrics(
    request: DeepPartial<ListLogMetricsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListLogMetricsResponse>;
  /** Gets a logs-based metric. */
  getLogMetric(request: DeepPartial<GetLogMetricRequest>, options?: CallOptions & CallOptionsExt): Promise<LogMetric>;
  /** Creates a logs-based metric. */
  createLogMetric(
    request: DeepPartial<CreateLogMetricRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LogMetric>;
  /** Creates or updates a logs-based metric. */
  updateLogMetric(
    request: DeepPartial<UpdateLogMetricRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LogMetric>;
  /** Deletes a logs-based metric. */
  deleteLogMetric(request: DeepPartial<DeleteLogMetricRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
