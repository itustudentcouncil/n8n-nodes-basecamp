// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/logging/v2/log_entry.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { MonitoredResource } from "../../api/monitored_resource.js";
import { Any } from "../../protobuf/any.js";
import { Struct } from "../../protobuf/struct.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { HttpRequest } from "../type/http_request.js";
import { LogSeverity, logSeverityFromJSON, logSeverityToJSON } from "../type/log_severity.js";

export const protobufPackage = "google.logging.v2";

/** An individual entry in a log. */
export interface LogEntry {
  /**
   * Required. The resource name of the log to which this log entry belongs:
   *
   *     "projects/[PROJECT_ID]/logs/[LOG_ID]"
   *     "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
   *     "folders/[FOLDER_ID]/logs/[LOG_ID]"
   *
   * A project number may be used in place of PROJECT_ID. The project number is
   * translated to its corresponding PROJECT_ID internally and the `log_name`
   * field will contain PROJECT_ID in queries and exports.
   *
   * `[LOG_ID]` must be URL-encoded within `log_name`. Example:
   * `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
   *
   * `[LOG_ID]` must be less than 512 characters long and can only include the
   * following characters: upper and lower case alphanumeric characters,
   * forward-slash, underscore, hyphen, and period.
   *
   * For backward compatibility, if `log_name` begins with a forward-slash, such
   * as `/projects/...`, then the log entry is ingested as usual, but the
   * forward-slash is removed. Listing the log entry will not show the leading
   * slash and filtering for a log name with a leading slash will never return
   * any results.
   */
  logName: string;
  /**
   * Required. The monitored resource that produced this log entry.
   *
   * Example: a log entry that reports a database error would be associated with
   * the monitored resource designating the particular database that reported
   * the error.
   */
  resource:
    | MonitoredResource
    | undefined;
  /**
   * The log entry payload, represented as a protocol buffer. Some Google
   * Cloud Platform services use this field for their log entry payloads.
   *
   * The following protocol buffer types are supported; user-defined types
   * are not supported:
   *
   *   "type.googleapis.com/google.cloud.audit.AuditLog"
   *   "type.googleapis.com/google.appengine.logging.v1.RequestLog"
   */
  protoPayload?:
    | Any
    | undefined;
  /** The log entry payload, represented as a Unicode string (UTF-8). */
  textPayload?:
    | string
    | undefined;
  /**
   * The log entry payload, represented as a structure that is
   * expressed as a JSON object.
   */
  jsonPayload?:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional. The time the event described by the log entry occurred. This time
   * is used to compute the log entry's age and to enforce the logs retention
   * period. If this field is omitted in a new log entry, then Logging assigns
   * it the current time. Timestamps have nanosecond accuracy, but trailing
   * zeros in the fractional seconds might be omitted when the timestamp is
   * displayed.
   *
   * Incoming log entries must have timestamps that don't exceed the
   * [logs retention
   * period](https://cloud.google.com/logging/quotas#logs_retention_periods) in
   * the past, and that don't exceed 24 hours in the future. Log entries outside
   * those time boundaries aren't ingested by Logging.
   */
  timestamp:
    | Date
    | undefined;
  /** Output only. The time the log entry was received by Logging. */
  receiveTimestamp:
    | Date
    | undefined;
  /**
   * Optional. The severity of the log entry. The default value is
   * `LogSeverity.DEFAULT`.
   */
  severity: LogSeverity;
  /**
   * Optional. A unique identifier for the log entry. If you provide a value,
   * then Logging considers other log entries in the same project, with the same
   * `timestamp`, and with the same `insert_id` to be duplicates which are
   * removed in a single query result. However, there are no guarantees of
   * de-duplication in the export of logs.
   *
   * If the `insert_id` is omitted when writing a log entry, the Logging API
   * assigns its own unique identifier in this field.
   *
   * In queries, the `insert_id` is also used to order log entries that have
   * the same `log_name` and `timestamp` values.
   */
  insertId: string;
  /**
   * Optional. Information about the HTTP request associated with this log
   * entry, if applicable.
   */
  httpRequest:
    | HttpRequest
    | undefined;
  /**
   * Optional. A map of key, value pairs that provides additional information
   * about the log entry. The labels can be user-defined or system-defined.
   *
   * User-defined labels are arbitrary key, value pairs that you can use to
   * classify logs.
   *
   * System-defined labels are defined by GCP services for platform logs.
   * They have two components - a service namespace component and the
   * attribute name. For example: `compute.googleapis.com/resource_name`.
   *
   * Cloud Logging truncates label keys that exceed 512 B and label
   * values that exceed 64 KB upon their associated log entry being
   * written. The truncation is indicated by an ellipsis at the
   * end of the character string.
   */
  labels: { [key: string]: string };
  /**
   * Optional. Information about an operation associated with the log entry, if
   * applicable.
   */
  operation:
    | LogEntryOperation
    | undefined;
  /**
   * Optional. The REST resource name of the trace being written to
   * [Cloud Trace](https://cloud.google.com/trace) in
   * association with this log entry. For example, if your trace data is stored
   * in the Cloud project "my-trace-project" and if the service that is creating
   * the log entry receives a trace header that includes the trace ID "12345",
   * then the service should use "projects/my-tracing-project/traces/12345".
   *
   * The `trace` field provides the link between logs and traces. By using
   * this field, you can navigate from a log entry to a trace.
   */
  trace: string;
  /**
   * Optional. The ID of the [Cloud Trace](https://cloud.google.com/trace) span
   * associated with the current operation in which the log is being written.
   * For example, if a span has the REST resource name of
   * "projects/some-project/traces/some-trace/spans/some-span-id", then the
   * `span_id` field is "some-span-id".
   *
   * A
   * [Span](https://cloud.google.com/trace/docs/reference/v2/rest/v2/projects.traces/batchWrite#Span)
   * represents a single operation within a trace. Whereas a trace may involve
   * multiple different microservices running on multiple different machines,
   * a span generally corresponds to a single logical operation being performed
   * in a single instance of a microservice on one specific machine. Spans
   * are the nodes within the tree that is a trace.
   *
   * Applications that are [instrumented for
   * tracing](https://cloud.google.com/trace/docs/setup) will generally assign a
   * new, unique span ID on each incoming request. It is also common to create
   * and record additional spans corresponding to internal processing elements
   * as well as issuing requests to dependencies.
   *
   * The span ID is expected to be a 16-character, hexadecimal encoding of an
   * 8-byte array and should not be zero. It should be unique within the trace
   * and should, ideally, be generated in a manner that is uniformly random.
   *
   * Example values:
   *
   *   - `000000000000004a`
   *   - `7a2190356c3fc94b`
   *   - `0000f00300090021`
   *   - `d39223e101960076`
   */
  spanId: string;
  /**
   * Optional. The sampling decision of the trace associated with the log entry.
   *
   * True means that the trace resource name in the `trace` field was sampled
   * for storage in a trace backend. False means that the trace was not sampled
   * for storage when this log entry was written, or the sampling decision was
   * unknown at the time. A non-sampled `trace` value is still useful as a
   * request correlation identifier. The default is False.
   */
  traceSampled: boolean;
  /**
   * Optional. Source code location information associated with the log entry,
   * if any.
   */
  sourceLocation:
    | LogEntrySourceLocation
    | undefined;
  /**
   * Optional. Information indicating this LogEntry is part of a sequence of
   * multiple log entries split from a single LogEntry.
   */
  split: LogSplit | undefined;
}

export interface LogEntry_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Additional information about a potentially long-running operation with which
 * a log entry is associated.
 */
export interface LogEntryOperation {
  /**
   * Optional. An arbitrary operation identifier. Log entries with the same
   * identifier are assumed to be part of the same operation.
   */
  id: string;
  /**
   * Optional. An arbitrary producer identifier. The combination of `id` and
   * `producer` must be globally unique. Examples for `producer`:
   * `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
   */
  producer: string;
  /** Optional. Set this to True if this is the first log entry in the operation. */
  first: boolean;
  /** Optional. Set this to True if this is the last log entry in the operation. */
  last: boolean;
}

/**
 * Additional information about the source code location that produced the log
 * entry.
 */
export interface LogEntrySourceLocation {
  /**
   * Optional. Source file name. Depending on the runtime environment, this
   * might be a simple name or a fully-qualified name.
   */
  file: string;
  /**
   * Optional. Line within the source file. 1-based; 0 indicates no line number
   * available.
   */
  line: Long;
  /**
   * Optional. Human-readable name of the function or method being invoked, with
   * optional context such as the class or package name. This information may be
   * used in contexts such as the logs viewer, where a file and line number are
   * less meaningful. The format can vary by language. For example:
   * `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
   * (Python).
   */
  function: string;
}

/**
 * Additional information used to correlate multiple log entries. Used when a
 * single LogEntry would exceed the Google Cloud Logging size limit and is
 * split across multiple log entries.
 */
export interface LogSplit {
  /**
   * A globally unique identifier for all log entries in a sequence of split log
   * entries. All log entries with the same |LogSplit.uid| are assumed to be
   * part of the same sequence of split log entries.
   */
  uid: string;
  /**
   * The index of this LogEntry in the sequence of split log entries. Log
   * entries are given |index| values 0, 1, ..., n-1 for a sequence of n log
   * entries.
   */
  index: number;
  /** The total number of log entries that the original LogEntry was split into. */
  totalSplits: number;
}

function createBaseLogEntry(): LogEntry {
  return {
    logName: "",
    resource: undefined,
    protoPayload: undefined,
    textPayload: undefined,
    jsonPayload: undefined,
    timestamp: undefined,
    receiveTimestamp: undefined,
    severity: 0,
    insertId: "",
    httpRequest: undefined,
    labels: {},
    operation: undefined,
    trace: "",
    spanId: "",
    traceSampled: false,
    sourceLocation: undefined,
    split: undefined,
  };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logName !== "") {
      writer.uint32(98).string(message.logName);
    }
    if (message.resource !== undefined) {
      MonitoredResource.encode(message.resource, writer.uint32(66).fork()).join();
    }
    if (message.protoPayload !== undefined) {
      Any.encode(message.protoPayload, writer.uint32(18).fork()).join();
    }
    if (message.textPayload !== undefined) {
      writer.uint32(26).string(message.textPayload);
    }
    if (message.jsonPayload !== undefined) {
      Struct.encode(Struct.wrap(message.jsonPayload), writer.uint32(50).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(74).fork()).join();
    }
    if (message.receiveTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.receiveTimestamp), writer.uint32(194).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(80).int32(message.severity);
    }
    if (message.insertId !== "") {
      writer.uint32(34).string(message.insertId);
    }
    if (message.httpRequest !== undefined) {
      HttpRequest.encode(message.httpRequest, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LogEntry_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.operation !== undefined) {
      LogEntryOperation.encode(message.operation, writer.uint32(122).fork()).join();
    }
    if (message.trace !== "") {
      writer.uint32(178).string(message.trace);
    }
    if (message.spanId !== "") {
      writer.uint32(218).string(message.spanId);
    }
    if (message.traceSampled !== false) {
      writer.uint32(240).bool(message.traceSampled);
    }
    if (message.sourceLocation !== undefined) {
      LogEntrySourceLocation.encode(message.sourceLocation, writer.uint32(186).fork()).join();
    }
    if (message.split !== undefined) {
      LogSplit.encode(message.split, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.logName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.resource = MonitoredResource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.protoPayload = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textPayload = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.jsonPayload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.receiveTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.insertId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.httpRequest = HttpRequest.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = LogEntry_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.operation = LogEntryOperation.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.trace = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.traceSampled = reader.bool();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.sourceLocation = LogEntrySourceLocation.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.split = LogSplit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      logName: isSet(object.logName) ? globalThis.String(object.logName) : "",
      resource: isSet(object.resource) ? MonitoredResource.fromJSON(object.resource) : undefined,
      protoPayload: isSet(object.protoPayload) ? Any.fromJSON(object.protoPayload) : undefined,
      textPayload: isSet(object.textPayload) ? globalThis.String(object.textPayload) : undefined,
      jsonPayload: isObject(object.jsonPayload) ? object.jsonPayload : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      receiveTimestamp: isSet(object.receiveTimestamp) ? fromJsonTimestamp(object.receiveTimestamp) : undefined,
      severity: isSet(object.severity) ? logSeverityFromJSON(object.severity) : 0,
      insertId: isSet(object.insertId) ? globalThis.String(object.insertId) : "",
      httpRequest: isSet(object.httpRequest) ? HttpRequest.fromJSON(object.httpRequest) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      operation: isSet(object.operation) ? LogEntryOperation.fromJSON(object.operation) : undefined,
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      traceSampled: isSet(object.traceSampled) ? globalThis.Boolean(object.traceSampled) : false,
      sourceLocation: isSet(object.sourceLocation) ? LogEntrySourceLocation.fromJSON(object.sourceLocation) : undefined,
      split: isSet(object.split) ? LogSplit.fromJSON(object.split) : undefined,
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    if (message.logName !== "") {
      obj.logName = message.logName;
    }
    if (message.resource !== undefined) {
      obj.resource = MonitoredResource.toJSON(message.resource);
    }
    if (message.protoPayload !== undefined) {
      obj.protoPayload = Any.toJSON(message.protoPayload);
    }
    if (message.textPayload !== undefined) {
      obj.textPayload = message.textPayload;
    }
    if (message.jsonPayload !== undefined) {
      obj.jsonPayload = message.jsonPayload;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.receiveTimestamp !== undefined) {
      obj.receiveTimestamp = message.receiveTimestamp.toISOString();
    }
    if (message.severity !== 0) {
      obj.severity = logSeverityToJSON(message.severity);
    }
    if (message.insertId !== "") {
      obj.insertId = message.insertId;
    }
    if (message.httpRequest !== undefined) {
      obj.httpRequest = HttpRequest.toJSON(message.httpRequest);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.operation !== undefined) {
      obj.operation = LogEntryOperation.toJSON(message.operation);
    }
    if (message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.traceSampled !== false) {
      obj.traceSampled = message.traceSampled;
    }
    if (message.sourceLocation !== undefined) {
      obj.sourceLocation = LogEntrySourceLocation.toJSON(message.sourceLocation);
    }
    if (message.split !== undefined) {
      obj.split = LogSplit.toJSON(message.split);
    }
    return obj;
  },

  create(base?: DeepPartial<LogEntry>): LogEntry {
    return LogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntry>): LogEntry {
    const message = createBaseLogEntry();
    message.logName = object.logName ?? "";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? MonitoredResource.fromPartial(object.resource)
      : undefined;
    message.protoPayload = (object.protoPayload !== undefined && object.protoPayload !== null)
      ? Any.fromPartial(object.protoPayload)
      : undefined;
    message.textPayload = object.textPayload ?? undefined;
    message.jsonPayload = object.jsonPayload ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.receiveTimestamp = object.receiveTimestamp ?? undefined;
    message.severity = object.severity ?? 0;
    message.insertId = object.insertId ?? "";
    message.httpRequest = (object.httpRequest !== undefined && object.httpRequest !== null)
      ? HttpRequest.fromPartial(object.httpRequest)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? LogEntryOperation.fromPartial(object.operation)
      : undefined;
    message.trace = object.trace ?? "";
    message.spanId = object.spanId ?? "";
    message.traceSampled = object.traceSampled ?? false;
    message.sourceLocation = (object.sourceLocation !== undefined && object.sourceLocation !== null)
      ? LogEntrySourceLocation.fromPartial(object.sourceLocation)
      : undefined;
    message.split = (object.split !== undefined && object.split !== null)
      ? LogSplit.fromPartial(object.split)
      : undefined;
    return message;
  },
};

function createBaseLogEntry_LabelsEntry(): LogEntry_LabelsEntry {
  return { key: "", value: "" };
}

export const LogEntry_LabelsEntry: MessageFns<LogEntry_LabelsEntry> = {
  encode(message: LogEntry_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LogEntry_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LogEntry_LabelsEntry>): LogEntry_LabelsEntry {
    return LogEntry_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntry_LabelsEntry>): LogEntry_LabelsEntry {
    const message = createBaseLogEntry_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLogEntryOperation(): LogEntryOperation {
  return { id: "", producer: "", first: false, last: false };
}

export const LogEntryOperation: MessageFns<LogEntryOperation> = {
  encode(message: LogEntryOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.producer !== "") {
      writer.uint32(18).string(message.producer);
    }
    if (message.first !== false) {
      writer.uint32(24).bool(message.first);
    }
    if (message.last !== false) {
      writer.uint32(32).bool(message.last);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntryOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntryOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producer = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.first = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.last = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntryOperation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      producer: isSet(object.producer) ? globalThis.String(object.producer) : "",
      first: isSet(object.first) ? globalThis.Boolean(object.first) : false,
      last: isSet(object.last) ? globalThis.Boolean(object.last) : false,
    };
  },

  toJSON(message: LogEntryOperation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.producer !== "") {
      obj.producer = message.producer;
    }
    if (message.first !== false) {
      obj.first = message.first;
    }
    if (message.last !== false) {
      obj.last = message.last;
    }
    return obj;
  },

  create(base?: DeepPartial<LogEntryOperation>): LogEntryOperation {
    return LogEntryOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntryOperation>): LogEntryOperation {
    const message = createBaseLogEntryOperation();
    message.id = object.id ?? "";
    message.producer = object.producer ?? "";
    message.first = object.first ?? false;
    message.last = object.last ?? false;
    return message;
  },
};

function createBaseLogEntrySourceLocation(): LogEntrySourceLocation {
  return { file: "", line: Long.ZERO, function: "" };
}

export const LogEntrySourceLocation: MessageFns<LogEntrySourceLocation> = {
  encode(message: LogEntrySourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== "") {
      writer.uint32(10).string(message.file);
    }
    if (!message.line.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.line.toString());
    }
    if (message.function !== "") {
      writer.uint32(26).string(message.function);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntrySourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntrySourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.file = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.line = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.function = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntrySourceLocation {
    return {
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      line: isSet(object.line) ? Long.fromValue(object.line) : Long.ZERO,
      function: isSet(object.function) ? globalThis.String(object.function) : "",
    };
  },

  toJSON(message: LogEntrySourceLocation): unknown {
    const obj: any = {};
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (!message.line.equals(Long.ZERO)) {
      obj.line = (message.line || Long.ZERO).toString();
    }
    if (message.function !== "") {
      obj.function = message.function;
    }
    return obj;
  },

  create(base?: DeepPartial<LogEntrySourceLocation>): LogEntrySourceLocation {
    return LogEntrySourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntrySourceLocation>): LogEntrySourceLocation {
    const message = createBaseLogEntrySourceLocation();
    message.file = object.file ?? "";
    message.line = (object.line !== undefined && object.line !== null) ? Long.fromValue(object.line) : Long.ZERO;
    message.function = object.function ?? "";
    return message;
  },
};

function createBaseLogSplit(): LogSplit {
  return { uid: "", index: 0, totalSplits: 0 };
}

export const LogSplit: MessageFns<LogSplit> = {
  encode(message: LogSplit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    if (message.totalSplits !== 0) {
      writer.uint32(24).int32(message.totalSplits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogSplit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogSplit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSplits = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogSplit {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      totalSplits: isSet(object.totalSplits) ? globalThis.Number(object.totalSplits) : 0,
    };
  },

  toJSON(message: LogSplit): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.totalSplits !== 0) {
      obj.totalSplits = Math.round(message.totalSplits);
    }
    return obj;
  },

  create(base?: DeepPartial<LogSplit>): LogSplit {
    return LogSplit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogSplit>): LogSplit {
    const message = createBaseLogSplit();
    message.uid = object.uid ?? "";
    message.index = object.index ?? 0;
    message.totalSplits = object.totalSplits ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
