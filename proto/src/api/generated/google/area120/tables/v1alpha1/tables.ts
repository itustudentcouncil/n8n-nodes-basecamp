// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/area120/tables/v1alpha1/tables.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Value } from "../../../protobuf/struct.js";

export const protobufPackage = "google.area120.tables.v1alpha1";

/** Column identifier used for the values in the row. */
export enum View {
  /** VIEW_UNSPECIFIED - Defaults to user entered text. */
  VIEW_UNSPECIFIED = 0,
  /** COLUMN_ID_VIEW - Uses internally generated column id to identify values. */
  COLUMN_ID_VIEW = 1,
  UNRECOGNIZED = -1,
}

export function viewFromJSON(object: any): View {
  switch (object) {
    case 0:
    case "VIEW_UNSPECIFIED":
      return View.VIEW_UNSPECIFIED;
    case 1:
    case "COLUMN_ID_VIEW":
      return View.COLUMN_ID_VIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return View.UNRECOGNIZED;
  }
}

export function viewToJSON(object: View): string {
  switch (object) {
    case View.VIEW_UNSPECIFIED:
      return "VIEW_UNSPECIFIED";
    case View.COLUMN_ID_VIEW:
      return "COLUMN_ID_VIEW";
    case View.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for TablesService.GetTable. */
export interface GetTableRequest {
  /**
   * Required. The name of the table to retrieve.
   * Format: tables/{table}
   */
  name: string;
}

/** Request message for TablesService.ListTables. */
export interface ListTablesRequest {
  /**
   * The maximum number of tables to return. The service may return fewer than
   * this value.
   *
   * If unspecified, at most 20 tables are returned. The maximum value is 100;
   * values above 100 are coerced to 100.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListTables` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTables` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for TablesService.ListTables. */
export interface ListTablesResponse {
  /** The list of tables. */
  tables: Table[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for TablesService.GetWorkspace. */
export interface GetWorkspaceRequest {
  /**
   * Required. The name of the workspace to retrieve.
   * Format: workspaces/{workspace}
   */
  name: string;
}

/** Request message for TablesService.ListWorkspaces. */
export interface ListWorkspacesRequest {
  /**
   * The maximum number of workspaces to return. The service may return fewer
   * than this value.
   *
   * If unspecified, at most 10 workspaces are returned. The maximum value is
   * 25; values above 25 are coerced to 25.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListWorkspaces` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListWorkspaces` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for TablesService.ListWorkspaces. */
export interface ListWorkspacesResponse {
  /** The list of workspaces. */
  workspaces: Workspace[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for TablesService.GetRow. */
export interface GetRowRequest {
  /**
   * Required. The name of the row to retrieve.
   * Format: tables/{table}/rows/{row}
   */
  name: string;
  /**
   * Optional. Column key to use for values in the row.
   * Defaults to user entered name.
   */
  view: View;
}

/** Request message for TablesService.ListRows. */
export interface ListRowsRequest {
  /**
   * Required. The parent table.
   * Format: tables/{table}
   */
  parent: string;
  /**
   * The maximum number of rows to return. The service may return fewer than
   * this value.
   *
   * If unspecified, at most 50 rows are returned. The maximum value is 1,000;
   * values above 1,000 are coerced to 1,000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListRows` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListRows` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Column key to use for values in the row.
   * Defaults to user entered name.
   */
  view: View;
  /**
   * Optional. Raw text query to search for in rows of the table.
   * Special characters must be escaped. Logical operators and field specific
   * filtering not supported.
   */
  filter: string;
}

/** Response message for TablesService.ListRows. */
export interface ListRowsResponse {
  /** The rows from the specified table. */
  rows: Row[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for TablesService.CreateRow. */
export interface CreateRowRequest {
  /**
   * Required. The parent table where this row will be created.
   * Format: tables/{table}
   */
  parent: string;
  /** Required. The row to create. */
  row:
    | Row
    | undefined;
  /**
   * Optional. Column key to use for values in the row.
   * Defaults to user entered name.
   */
  view: View;
}

/** Request message for TablesService.BatchCreateRows. */
export interface BatchCreateRowsRequest {
  /**
   * Required. The parent table where the rows will be created.
   * Format: tables/{table}
   */
  parent: string;
  /**
   * Required. The request message specifying the rows to create.
   *
   * A maximum of 500 rows can be created in a single batch.
   */
  requests: CreateRowRequest[];
}

/** Response message for TablesService.BatchCreateRows. */
export interface BatchCreateRowsResponse {
  /** The created rows. */
  rows: Row[];
}

/** Request message for TablesService.UpdateRow. */
export interface UpdateRowRequest {
  /** Required. The row to update. */
  row:
    | Row
    | undefined;
  /** The list of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. Column key to use for values in the row.
   * Defaults to user entered name.
   */
  view: View;
}

/** Request message for TablesService.BatchUpdateRows. */
export interface BatchUpdateRowsRequest {
  /**
   * Required. The parent table shared by all rows being updated.
   * Format: tables/{table}
   */
  parent: string;
  /**
   * Required. The request messages specifying the rows to update.
   *
   * A maximum of 500 rows can be modified in a single batch.
   */
  requests: UpdateRowRequest[];
}

/** Response message for TablesService.BatchUpdateRows. */
export interface BatchUpdateRowsResponse {
  /** The updated rows. */
  rows: Row[];
}

/** Request message for TablesService.DeleteRow */
export interface DeleteRowRequest {
  /**
   * Required. The name of the row to delete.
   * Format: tables/{table}/rows/{row}
   */
  name: string;
}

/** Request message for TablesService.BatchDeleteRows */
export interface BatchDeleteRowsRequest {
  /**
   * Required. The parent table shared by all rows being deleted.
   * Format: tables/{table}
   */
  parent: string;
  /**
   * Required. The names of the rows to delete. All rows must belong to the parent table
   * or else the entire batch will fail. A maximum of 500 rows can be deleted
   * in a batch.
   * Format: tables/{table}/rows/{row}
   */
  names: string[];
}

/** A single table. */
export interface Table {
  /**
   * The resource name of the table.
   * Table names have the form `tables/{table}`.
   */
  name: string;
  /** The human readable title of the table. */
  displayName: string;
  /**
   * List of columns in this table.
   * Order of columns matches the display order.
   */
  columns: ColumnDescription[];
}

/** Details on a column in the table. */
export interface ColumnDescription {
  /** column name */
  name: string;
  /**
   * Data type of the column
   * Supported types are auto_id, boolean, boolean_list, creator,
   * create_timestamp, date, dropdown, location, integer,
   * integer_list, number, number_list, person, person_list, tags, check_list,
   * text, text_list, update_timestamp, updater, relationship,
   * file_attachment_list.
   * These types directly map to the column types supported on Tables website.
   */
  dataType: string;
  /** Internal id for a column. */
  id: string;
  /**
   * Optional. Range of labeled values for the column.
   * Some columns like tags and drop-downs limit the values to a set of
   * possible values. We return the range of values in such cases to help
   * clients implement better user data validation.
   */
  labels: LabeledItem[];
  /**
   * Optional. Additional details about a relationship column. Specified when data_type
   * is relationship.
   */
  relationshipDetails:
    | RelationshipDetails
    | undefined;
  /**
   * Optional. Indicates that this is a lookup column whose value is derived from the
   * relationship column specified in the details. Lookup columns can not be
   * updated directly. To change the value you must update the associated
   * relationship column.
   */
  lookupDetails: LookupDetails | undefined;
}

/** A single item in a labeled column. */
export interface LabeledItem {
  /** Display string as entered by user. */
  name: string;
  /** Internal id associated with the item. */
  id: string;
}

/** Details about a relationship column. */
export interface RelationshipDetails {
  /** The name of the table this relationship is linked to. */
  linkedTable: string;
}

/**
 * Details about a lookup column whose value comes from the associated
 * relationship.
 */
export interface LookupDetails {
  /** The name of the relationship column associated with the lookup. */
  relationshipColumn: string;
  /** The id of the relationship column. */
  relationshipColumnId: string;
}

/** A single row in a table. */
export interface Row {
  /**
   * The resource name of the row.
   * Row names have the form `tables/{table}/rows/{row}`.
   * The name is ignored when creating a row.
   */
  name: string;
  /**
   * The values of the row. This is a map of column key to value.
   * Key is user entered name(default) or the internal column id based on
   * the view in the request.
   */
  values: { [key: string]: any | undefined };
}

export interface Row_ValuesEntry {
  key: string;
  value: any | undefined;
}

/** A single workspace. */
export interface Workspace {
  /**
   * The resource name of the workspace.
   * Workspace names have the form `workspaces/{workspace}`.
   */
  name: string;
  /** The human readable title of the workspace. */
  displayName: string;
  /** The list of tables in the workspace. */
  tables: Table[];
}

function createBaseGetTableRequest(): GetTableRequest {
  return { name: "" };
}

export const GetTableRequest: MessageFns<GetTableRequest> = {
  encode(message: GetTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTableRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableRequest>): GetTableRequest {
    return GetTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableRequest>): GetTableRequest {
    const message = createBaseGetTableRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTablesRequest(): ListTablesRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListTablesRequest: MessageFns<ListTablesRequest> = {
  encode(message: ListTablesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTablesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTablesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTablesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTablesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTablesRequest>): ListTablesRequest {
    return ListTablesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTablesRequest>): ListTablesRequest {
    const message = createBaseListTablesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTablesResponse(): ListTablesResponse {
  return { tables: [], nextPageToken: "" };
}

export const ListTablesResponse: MessageFns<ListTablesResponse> = {
  encode(message: ListTablesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tables) {
      Table.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTablesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTablesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tables.push(Table.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTablesResponse {
    return {
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => Table.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTablesResponse): unknown {
    const obj: any = {};
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Table.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTablesResponse>): ListTablesResponse {
    return ListTablesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTablesResponse>): ListTablesResponse {
    const message = createBaseListTablesResponse();
    message.tables = object.tables?.map((e) => Table.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetWorkspaceRequest(): GetWorkspaceRequest {
  return { name: "" };
}

export const GetWorkspaceRequest: MessageFns<GetWorkspaceRequest> = {
  encode(message: GetWorkspaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkspaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkspaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkspaceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWorkspaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkspaceRequest>): GetWorkspaceRequest {
    return GetWorkspaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkspaceRequest>): GetWorkspaceRequest {
    const message = createBaseGetWorkspaceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListWorkspacesRequest(): ListWorkspacesRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListWorkspacesRequest: MessageFns<ListWorkspacesRequest> = {
  encode(message: ListWorkspacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkspacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkspacesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkspacesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListWorkspacesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkspacesRequest>): ListWorkspacesRequest {
    return ListWorkspacesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkspacesRequest>): ListWorkspacesRequest {
    const message = createBaseListWorkspacesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListWorkspacesResponse(): ListWorkspacesResponse {
  return { workspaces: [], nextPageToken: "" };
}

export const ListWorkspacesResponse: MessageFns<ListWorkspacesResponse> = {
  encode(message: ListWorkspacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workspaces) {
      Workspace.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkspacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkspacesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workspaces.push(Workspace.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkspacesResponse {
    return {
      workspaces: globalThis.Array.isArray(object?.workspaces)
        ? object.workspaces.map((e: any) => Workspace.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListWorkspacesResponse): unknown {
    const obj: any = {};
    if (message.workspaces?.length) {
      obj.workspaces = message.workspaces.map((e) => Workspace.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkspacesResponse>): ListWorkspacesResponse {
    return ListWorkspacesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkspacesResponse>): ListWorkspacesResponse {
    const message = createBaseListWorkspacesResponse();
    message.workspaces = object.workspaces?.map((e) => Workspace.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetRowRequest(): GetRowRequest {
  return { name: "", view: 0 };
}

export const GetRowRequest: MessageFns<GetRowRequest> = {
  encode(message: GetRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRowRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? viewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetRowRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = viewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRowRequest>): GetRowRequest {
    return GetRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRowRequest>): GetRowRequest {
    const message = createBaseGetRowRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListRowsRequest(): ListRowsRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0, filter: "" };
}

export const ListRowsRequest: MessageFns<ListRowsRequest> = {
  encode(message: ListRowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRowsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? viewFromJSON(object.view) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRowsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = viewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRowsRequest>): ListRowsRequest {
    return ListRowsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRowsRequest>): ListRowsRequest {
    const message = createBaseListRowsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRowsResponse(): ListRowsResponse {
  return { rows: [], nextPageToken: "" };
}

export const ListRowsResponse: MessageFns<ListRowsResponse> = {
  encode(message: ListRowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRowsResponse {
    return {
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRowsResponse): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRowsResponse>): ListRowsResponse {
    return ListRowsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRowsResponse>): ListRowsResponse {
    const message = createBaseListRowsResponse();
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateRowRequest(): CreateRowRequest {
  return { parent: "", row: undefined, view: 0 };
}

export const CreateRowRequest: MessageFns<CreateRowRequest> = {
  encode(message: CreateRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.row !== undefined) {
      Row.encode(message.row, writer.uint32(18).fork()).join();
    }
    if (message.view !== 0) {
      writer.uint32(24).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.row = Row.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRowRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      row: isSet(object.row) ? Row.fromJSON(object.row) : undefined,
      view: isSet(object.view) ? viewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: CreateRowRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.row !== undefined) {
      obj.row = Row.toJSON(message.row);
    }
    if (message.view !== 0) {
      obj.view = viewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRowRequest>): CreateRowRequest {
    return CreateRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRowRequest>): CreateRowRequest {
    const message = createBaseCreateRowRequest();
    message.parent = object.parent ?? "";
    message.row = (object.row !== undefined && object.row !== null) ? Row.fromPartial(object.row) : undefined;
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseBatchCreateRowsRequest(): BatchCreateRowsRequest {
  return { parent: "", requests: [] };
}

export const BatchCreateRowsRequest: MessageFns<BatchCreateRowsRequest> = {
  encode(message: BatchCreateRowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      CreateRowRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(CreateRowRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRowsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateRowRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateRowsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateRowRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRowsRequest>): BatchCreateRowsRequest {
    return BatchCreateRowsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRowsRequest>): BatchCreateRowsRequest {
    const message = createBaseBatchCreateRowsRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => CreateRowRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateRowsResponse(): BatchCreateRowsResponse {
  return { rows: [] };
}

export const BatchCreateRowsResponse: MessageFns<BatchCreateRowsResponse> = {
  encode(message: BatchCreateRowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRowsResponse {
    return { rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [] };
  },

  toJSON(message: BatchCreateRowsResponse): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRowsResponse>): BatchCreateRowsResponse {
    return BatchCreateRowsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRowsResponse>): BatchCreateRowsResponse {
    const message = createBaseBatchCreateRowsResponse();
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateRowRequest(): UpdateRowRequest {
  return { row: undefined, updateMask: undefined, view: 0 };
}

export const UpdateRowRequest: MessageFns<UpdateRowRequest> = {
  encode(message: UpdateRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== undefined) {
      Row.encode(message.row, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.view !== 0) {
      writer.uint32(24).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.row = Row.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRowRequest {
    return {
      row: isSet(object.row) ? Row.fromJSON(object.row) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      view: isSet(object.view) ? viewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: UpdateRowRequest): unknown {
    const obj: any = {};
    if (message.row !== undefined) {
      obj.row = Row.toJSON(message.row);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.view !== 0) {
      obj.view = viewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRowRequest>): UpdateRowRequest {
    return UpdateRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRowRequest>): UpdateRowRequest {
    const message = createBaseUpdateRowRequest();
    message.row = (object.row !== undefined && object.row !== null) ? Row.fromPartial(object.row) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseBatchUpdateRowsRequest(): BatchUpdateRowsRequest {
  return { parent: "", requests: [] };
}

export const BatchUpdateRowsRequest: MessageFns<BatchUpdateRowsRequest> = {
  encode(message: BatchUpdateRowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      UpdateRowRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateRowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateRowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(UpdateRowRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateRowsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateRowRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateRowsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateRowRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateRowsRequest>): BatchUpdateRowsRequest {
    return BatchUpdateRowsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateRowsRequest>): BatchUpdateRowsRequest {
    const message = createBaseBatchUpdateRowsRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => UpdateRowRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateRowsResponse(): BatchUpdateRowsResponse {
  return { rows: [] };
}

export const BatchUpdateRowsResponse: MessageFns<BatchUpdateRowsResponse> = {
  encode(message: BatchUpdateRowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateRowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateRowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateRowsResponse {
    return { rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [] };
  },

  toJSON(message: BatchUpdateRowsResponse): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateRowsResponse>): BatchUpdateRowsResponse {
    return BatchUpdateRowsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateRowsResponse>): BatchUpdateRowsResponse {
    const message = createBaseBatchUpdateRowsResponse();
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteRowRequest(): DeleteRowRequest {
  return { name: "" };
}

export const DeleteRowRequest: MessageFns<DeleteRowRequest> = {
  encode(message: DeleteRowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRowRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteRowRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRowRequest>): DeleteRowRequest {
    return DeleteRowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRowRequest>): DeleteRowRequest {
    const message = createBaseDeleteRowRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBatchDeleteRowsRequest(): BatchDeleteRowsRequest {
  return { parent: "", names: [] };
}

export const BatchDeleteRowsRequest: MessageFns<BatchDeleteRowsRequest> = {
  encode(message: BatchDeleteRowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteRowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteRowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteRowsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeleteRowsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteRowsRequest>): BatchDeleteRowsRequest {
    return BatchDeleteRowsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteRowsRequest>): BatchDeleteRowsRequest {
    const message = createBaseBatchDeleteRowsRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseTable(): Table {
  return { name: "", displayName: "", columns: [] };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.columns) {
      ColumnDescription.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.columns.push(ColumnDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnDescription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Table): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnDescription.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Table>): Table {
    return Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table>): Table {
    const message = createBaseTable();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.columns = object.columns?.map((e) => ColumnDescription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnDescription(): ColumnDescription {
  return { name: "", dataType: "", id: "", labels: [], relationshipDetails: undefined, lookupDetails: undefined };
}

export const ColumnDescription: MessageFns<ColumnDescription> = {
  encode(message: ColumnDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    for (const v of message.labels) {
      LabeledItem.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.relationshipDetails !== undefined) {
      RelationshipDetails.encode(message.relationshipDetails, writer.uint32(42).fork()).join();
    }
    if (message.lookupDetails !== undefined) {
      LookupDetails.encode(message.lookupDetails, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.labels.push(LabeledItem.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.relationshipDetails = RelationshipDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lookupDetails = LookupDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnDescription {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => LabeledItem.fromJSON(e)) : [],
      relationshipDetails: isSet(object.relationshipDetails)
        ? RelationshipDetails.fromJSON(object.relationshipDetails)
        : undefined,
      lookupDetails: isSet(object.lookupDetails) ? LookupDetails.fromJSON(object.lookupDetails) : undefined,
    };
  },

  toJSON(message: ColumnDescription): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => LabeledItem.toJSON(e));
    }
    if (message.relationshipDetails !== undefined) {
      obj.relationshipDetails = RelationshipDetails.toJSON(message.relationshipDetails);
    }
    if (message.lookupDetails !== undefined) {
      obj.lookupDetails = LookupDetails.toJSON(message.lookupDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnDescription>): ColumnDescription {
    return ColumnDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnDescription>): ColumnDescription {
    const message = createBaseColumnDescription();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.id = object.id ?? "";
    message.labels = object.labels?.map((e) => LabeledItem.fromPartial(e)) || [];
    message.relationshipDetails = (object.relationshipDetails !== undefined && object.relationshipDetails !== null)
      ? RelationshipDetails.fromPartial(object.relationshipDetails)
      : undefined;
    message.lookupDetails = (object.lookupDetails !== undefined && object.lookupDetails !== null)
      ? LookupDetails.fromPartial(object.lookupDetails)
      : undefined;
    return message;
  },
};

function createBaseLabeledItem(): LabeledItem {
  return { name: "", id: "" };
}

export const LabeledItem: MessageFns<LabeledItem> = {
  encode(message: LabeledItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabeledItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabeledItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabeledItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: LabeledItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<LabeledItem>): LabeledItem {
    return LabeledItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabeledItem>): LabeledItem {
    const message = createBaseLabeledItem();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRelationshipDetails(): RelationshipDetails {
  return { linkedTable: "" };
}

export const RelationshipDetails: MessageFns<RelationshipDetails> = {
  encode(message: RelationshipDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkedTable !== "") {
      writer.uint32(10).string(message.linkedTable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelationshipDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelationshipDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.linkedTable = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelationshipDetails {
    return { linkedTable: isSet(object.linkedTable) ? globalThis.String(object.linkedTable) : "" };
  },

  toJSON(message: RelationshipDetails): unknown {
    const obj: any = {};
    if (message.linkedTable !== "") {
      obj.linkedTable = message.linkedTable;
    }
    return obj;
  },

  create(base?: DeepPartial<RelationshipDetails>): RelationshipDetails {
    return RelationshipDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelationshipDetails>): RelationshipDetails {
    const message = createBaseRelationshipDetails();
    message.linkedTable = object.linkedTable ?? "";
    return message;
  },
};

function createBaseLookupDetails(): LookupDetails {
  return { relationshipColumn: "", relationshipColumnId: "" };
}

export const LookupDetails: MessageFns<LookupDetails> = {
  encode(message: LookupDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relationshipColumn !== "") {
      writer.uint32(10).string(message.relationshipColumn);
    }
    if (message.relationshipColumnId !== "") {
      writer.uint32(18).string(message.relationshipColumnId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relationshipColumn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationshipColumnId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupDetails {
    return {
      relationshipColumn: isSet(object.relationshipColumn) ? globalThis.String(object.relationshipColumn) : "",
      relationshipColumnId: isSet(object.relationshipColumnId) ? globalThis.String(object.relationshipColumnId) : "",
    };
  },

  toJSON(message: LookupDetails): unknown {
    const obj: any = {};
    if (message.relationshipColumn !== "") {
      obj.relationshipColumn = message.relationshipColumn;
    }
    if (message.relationshipColumnId !== "") {
      obj.relationshipColumnId = message.relationshipColumnId;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupDetails>): LookupDetails {
    return LookupDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupDetails>): LookupDetails {
    const message = createBaseLookupDetails();
    message.relationshipColumn = object.relationshipColumn ?? "";
    message.relationshipColumnId = object.relationshipColumnId ?? "";
    return message;
  },
};

function createBaseRow(): Row {
  return { name: "", values: {} };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.values).forEach(([key, value]) => {
      if (value !== undefined) {
        Row_ValuesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Row_ValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.values[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Row>): Row {
    return Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row>): Row {
    const message = createBaseRow();
    message.name = object.name ?? "";
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRow_ValuesEntry(): Row_ValuesEntry {
  return { key: "", value: undefined };
}

export const Row_ValuesEntry: MessageFns<Row_ValuesEntry> = {
  encode(message: Row_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Row_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Row_ValuesEntry>): Row_ValuesEntry {
    return Row_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row_ValuesEntry>): Row_ValuesEntry {
    const message = createBaseRow_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseWorkspace(): Workspace {
  return { name: "", displayName: "", tables: [] };
}

export const Workspace: MessageFns<Workspace> = {
  encode(message: Workspace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.tables) {
      Table.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workspace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tables.push(Table.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workspace {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => Table.fromJSON(e)) : [],
    };
  },

  toJSON(message: Workspace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Table.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Workspace>): Workspace {
    return Workspace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workspace>): Workspace {
    const message = createBaseWorkspace();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.tables = object.tables?.map((e) => Table.fromPartial(e)) || [];
    return message;
  },
};

/**
 * The Tables Service provides an API for reading and updating tables.
 * It defines the following resource model:
 *
 * - The API has a collection of [Table][google.area120.tables.v1alpha1.Table]
 *   resources, named `tables/*`
 *
 * - Each Table has a collection of [Row][google.area120.tables.v1alpha1.Row]
 *   resources, named `tables/* /rows/*`
 *
 * - The API has a collection of
 *   [Workspace][google.area120.tables.v1alpha1.Workspace]
 *   resources, named `workspaces/*`.
 */
export type TablesServiceDefinition = typeof TablesServiceDefinition;
export const TablesServiceDefinition = {
  name: "TablesService",
  fullName: "google.area120.tables.v1alpha1.TablesService",
  methods: {
    /** Gets a table. Returns NOT_FOUND if the table does not exist. */
    getTable: {
      name: "GetTable",
      requestType: GetTableRequest,
      requestStream: false,
      responseType: Table,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              27,
              18,
              25,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists tables for the user. */
    listTables: {
      name: "ListTables",
      requestType: ListTablesRequest,
      requestStream: false,
      responseType: ListTablesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([18, 18, 16, 47, 118, 49, 97, 108, 112, 104, 97, 49, 47, 116, 97, 98, 108, 101, 115]),
          ],
        },
      },
    },
    /** Gets a workspace. Returns NOT_FOUND if the workspace does not exist. */
    getWorkspace: {
      name: "GetWorkspace",
      requestType: GetWorkspaceRequest,
      requestStream: false,
      responseType: Workspace,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              31,
              18,
              29,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              119,
              111,
              114,
              107,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists workspaces for the user. */
    listWorkspaces: {
      name: "ListWorkspaces",
      requestType: ListWorkspacesRequest,
      requestStream: false,
      responseType: ListWorkspacesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              22,
              18,
              20,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              119,
              111,
              114,
              107,
              115,
              112,
              97,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a row. Returns NOT_FOUND if the row does not exist in the table. */
    getRow: {
      name: "GetRow",
      requestType: GetRowRequest,
      requestStream: false,
      responseType: Row,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              119,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists rows in a table. Returns NOT_FOUND if the table does not exist. */
    listRows: {
      name: "ListRows",
      requestType: ListRowsRequest,
      requestStream: false,
      responseType: ListRowsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              34,
              18,
              32,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              119,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a row. */
    createRow: {
      name: "CreateRow",
      requestType: CreateRowRequest,
      requestStream: false,
      responseType: Row,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 112, 97, 114, 101, 110, 116, 44, 114, 111, 119])],
          578365826: [
            Buffer.from([
              39,
              58,
              3,
              114,
              111,
              119,
              34,
              32,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              119,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates multiple rows. */
    batchCreateRows: {
      name: "BatchCreateRows",
      requestType: BatchCreateRowsRequest,
      requestStream: false,
      responseType: BatchCreateRowsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              119,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Updates a row. */
    updateRow: {
      name: "UpdateRow",
      requestType: UpdateRowRequest,
      requestStream: false,
      responseType: Row,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 111, 119, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              43,
              58,
              3,
              114,
              111,
              119,
              50,
              36,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              114,
              111,
              119,
              46,
              110,
              97,
              109,
              101,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              119,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates multiple rows. */
    batchUpdateRows: {
      name: "BatchUpdateRows",
      requestType: BatchUpdateRowsRequest,
      requestStream: false,
      responseType: BatchUpdateRowsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              119,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Deletes a row. */
    deleteRow: {
      name: "DeleteRow",
      requestType: DeleteRowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              34,
              42,
              32,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              119,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes multiple rows. */
    batchDeleteRows: {
      name: "BatchDeleteRows",
      requestType: BatchDeleteRowsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              119,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TablesServiceImplementation<CallContextExt = {}> {
  /** Gets a table. Returns NOT_FOUND if the table does not exist. */
  getTable(request: GetTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Table>>;
  /** Lists tables for the user. */
  listTables(
    request: ListTablesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTablesResponse>>;
  /** Gets a workspace. Returns NOT_FOUND if the workspace does not exist. */
  getWorkspace(request: GetWorkspaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Workspace>>;
  /** Lists workspaces for the user. */
  listWorkspaces(
    request: ListWorkspacesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkspacesResponse>>;
  /** Gets a row. Returns NOT_FOUND if the row does not exist in the table. */
  getRow(request: GetRowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Row>>;
  /** Lists rows in a table. Returns NOT_FOUND if the table does not exist. */
  listRows(request: ListRowsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListRowsResponse>>;
  /** Creates a row. */
  createRow(request: CreateRowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Row>>;
  /** Creates multiple rows. */
  batchCreateRows(
    request: BatchCreateRowsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateRowsResponse>>;
  /** Updates a row. */
  updateRow(request: UpdateRowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Row>>;
  /** Updates multiple rows. */
  batchUpdateRows(
    request: BatchUpdateRowsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchUpdateRowsResponse>>;
  /** Deletes a row. */
  deleteRow(request: DeleteRowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes multiple rows. */
  batchDeleteRows(request: BatchDeleteRowsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface TablesServiceClient<CallOptionsExt = {}> {
  /** Gets a table. Returns NOT_FOUND if the table does not exist. */
  getTable(request: DeepPartial<GetTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Table>;
  /** Lists tables for the user. */
  listTables(
    request: DeepPartial<ListTablesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTablesResponse>;
  /** Gets a workspace. Returns NOT_FOUND if the workspace does not exist. */
  getWorkspace(request: DeepPartial<GetWorkspaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Workspace>;
  /** Lists workspaces for the user. */
  listWorkspaces(
    request: DeepPartial<ListWorkspacesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkspacesResponse>;
  /** Gets a row. Returns NOT_FOUND if the row does not exist in the table. */
  getRow(request: DeepPartial<GetRowRequest>, options?: CallOptions & CallOptionsExt): Promise<Row>;
  /** Lists rows in a table. Returns NOT_FOUND if the table does not exist. */
  listRows(request: DeepPartial<ListRowsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListRowsResponse>;
  /** Creates a row. */
  createRow(request: DeepPartial<CreateRowRequest>, options?: CallOptions & CallOptionsExt): Promise<Row>;
  /** Creates multiple rows. */
  batchCreateRows(
    request: DeepPartial<BatchCreateRowsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateRowsResponse>;
  /** Updates a row. */
  updateRow(request: DeepPartial<UpdateRowRequest>, options?: CallOptions & CallOptionsExt): Promise<Row>;
  /** Updates multiple rows. */
  batchUpdateRows(
    request: DeepPartial<BatchUpdateRowsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchUpdateRowsResponse>;
  /** Deletes a row. */
  deleteRow(request: DeepPartial<DeleteRowRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes multiple rows. */
  batchDeleteRows(request: DeepPartial<BatchDeleteRowsRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
