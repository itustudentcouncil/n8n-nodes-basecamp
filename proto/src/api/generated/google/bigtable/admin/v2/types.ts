// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/bigtable/admin/v2/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.bigtable.admin.v2";

/**
 * `Type` represents the type of data that is written to, read from, or stored
 * in Bigtable. It is heavily based on the GoogleSQL standard to help maintain
 * familiarity and consistency across products and features.
 *
 * For compatibility with Bigtable's existing untyped APIs, each `Type` includes
 * an `Encoding` which describes how to convert to/from the underlying data.
 *
 * Each encoding also defines the following properties:
 *
 *  * Order-preserving: Does the encoded value sort consistently with the
 *    original typed value? Note that Bigtable will always sort data based on
 *    the raw encoded value, *not* the decoded type.
 *     - Example: BYTES values sort in the same order as their raw encodings.
 *     - Counterexample: Encoding INT64 as a fixed-width decimal string does
 *       *not* preserve sort order when dealing with negative numbers.
 *       `INT64(1) > INT64(-1)`, but `STRING("-00001") > STRING("00001)`.
 *  * Self-delimiting: If we concatenate two encoded values, can we always tell
 *    where the first one ends and the second one begins?
 *     - Example: If we encode INT64s to fixed-width STRINGs, the first value
 *       will always contain exactly N digits, possibly preceded by a sign.
 *     - Counterexample: If we concatenate two UTF-8 encoded STRINGs, we have
 *       no way to tell where the first one ends.
 *  * Compatibility: Which other systems have matching encoding schemes? For
 *    example, does this encoding have a GoogleSQL equivalent? HBase? Java?
 */
export interface Type {
  /** Bytes */
  bytesType?:
    | Type_Bytes
    | undefined;
  /** String */
  stringType?:
    | Type_String
    | undefined;
  /** Int64 */
  int64Type?:
    | Type_Int64
    | undefined;
  /** Float32 */
  float32Type?:
    | Type_Float32
    | undefined;
  /** Float64 */
  float64Type?:
    | Type_Float64
    | undefined;
  /** Bool */
  boolType?:
    | Type_Bool
    | undefined;
  /** Timestamp */
  timestampType?:
    | Type_Timestamp
    | undefined;
  /** Date */
  dateType?:
    | Type_DateMessage
    | undefined;
  /** Aggregate */
  aggregateType?:
    | Type_Aggregate
    | undefined;
  /** Struct */
  structType?:
    | Type_Struct
    | undefined;
  /** Array */
  arrayType?:
    | Type_Array
    | undefined;
  /** Map */
  mapType?: Type_Map | undefined;
}

/**
 * Bytes
 * Values of type `Bytes` are stored in `Value.bytes_value`.
 */
export interface Type_Bytes {
  /** The encoding to use when converting to/from lower level types. */
  encoding: Type_Bytes_Encoding | undefined;
}

/** Rules used to convert to/from lower level types. */
export interface Type_Bytes_Encoding {
  /** Use `Raw` encoding. */
  raw?: Type_Bytes_Encoding_Raw | undefined;
}

/**
 * Leaves the value "as-is"
 * * Order-preserving? Yes
 * * Self-delimiting? No
 * * Compatibility? N/A
 */
export interface Type_Bytes_Encoding_Raw {
}

/**
 * String
 * Values of type `String` are stored in `Value.string_value`.
 */
export interface Type_String {
  /** The encoding to use when converting to/from lower level types. */
  encoding: Type_String_Encoding | undefined;
}

/** Rules used to convert to/from lower level types. */
export interface Type_String_Encoding {
  /**
   * Deprecated: if set, converts to an empty `utf8_bytes`.
   *
   * @deprecated
   */
  utf8Raw?:
    | Type_String_Encoding_Utf8Raw
    | undefined;
  /** Use `Utf8Bytes` encoding. */
  utf8Bytes?: Type_String_Encoding_Utf8Bytes | undefined;
}

/**
 * Deprecated: prefer the equivalent `Utf8Bytes`.
 *
 * @deprecated
 */
export interface Type_String_Encoding_Utf8Raw {
}

/**
 * UTF-8 encoding
 * * Order-preserving? Yes (code point order)
 * * Self-delimiting? No
 * * Compatibility?
 *    - BigQuery Federation `TEXT` encoding
 *    - HBase `Bytes.toBytes`
 *    - Java `String#getBytes(StandardCharsets.UTF_8)`
 */
export interface Type_String_Encoding_Utf8Bytes {
}

/**
 * Int64
 * Values of type `Int64` are stored in `Value.int_value`.
 */
export interface Type_Int64 {
  /** The encoding to use when converting to/from lower level types. */
  encoding: Type_Int64_Encoding | undefined;
}

/** Rules used to convert to/from lower level types. */
export interface Type_Int64_Encoding {
  /** Use `BigEndianBytes` encoding. */
  bigEndianBytes?: Type_Int64_Encoding_BigEndianBytes | undefined;
}

/**
 * Encodes the value as an 8-byte big endian twos complement `Bytes`
 * value.
 * * Order-preserving? No (positive values only)
 * * Self-delimiting? Yes
 * * Compatibility?
 *    - BigQuery Federation `BINARY` encoding
 *    - HBase `Bytes.toBytes`
 *    - Java `ByteBuffer.putLong()` with `ByteOrder.BIG_ENDIAN`
 */
export interface Type_Int64_Encoding_BigEndianBytes {
  /** Deprecated: ignored if set. */
  bytesType: Type_Bytes | undefined;
}

/**
 * bool
 * Values of type `Bool` are stored in `Value.bool_value`.
 */
export interface Type_Bool {
}

/**
 * Float32
 * Values of type `Float32` are stored in `Value.float_value`.
 */
export interface Type_Float32 {
}

/**
 * Float64
 * Values of type `Float64` are stored in `Value.float_value`.
 */
export interface Type_Float64 {
}

/**
 * Timestamp
 * Values of type `Timestamp` are stored in `Value.timestamp_value`.
 */
export interface Type_Timestamp {
}

/**
 * Date
 * Values of type `Date` are stored in `Value.date_value`.
 */
export interface Type_DateMessage {
}

/**
 * A structured data value, consisting of fields which map to dynamically
 * typed values.
 * Values of type `Struct` are stored in `Value.array_value` where entries are
 * in the same order and number as `field_types`.
 */
export interface Type_Struct {
  /** The names and types of the fields in this struct. */
  fields: Type_Struct_Field[];
}

/** A struct field and its type. */
export interface Type_Struct_Field {
  /**
   * The field name (optional). Fields without a `field_name` are considered
   * anonymous and cannot be referenced by name.
   */
  fieldName: string;
  /** The type of values in this field. */
  type: Type | undefined;
}

/**
 * An ordered list of elements of a given type.
 * Values of type `Array` are stored in `Value.array_value`.
 */
export interface Type_Array {
  /** The type of the elements in the array. This must not be `Array`. */
  elementType: Type | undefined;
}

/**
 * A mapping of keys to values of a given type.
 * Values of type `Map` are stored in a `Value.array_value` where each entry
 * is another `Value.array_value` with two elements (the key and the value,
 * in that order).
 * Normally encoded Map values won't have repeated keys, however, clients are
 * expected to handle the case in which they do. If the same key appears
 * multiple times, the _last_ value takes precedence.
 */
export interface Type_Map {
  /**
   * The type of a map key.
   * Only `Bytes`, `String`, and `Int64` are allowed as key types.
   */
  keyType:
    | Type
    | undefined;
  /** The type of the values in a map. */
  valueType: Type | undefined;
}

/**
 * A value that combines incremental updates into a summarized value.
 *
 * Data is never directly written or read using type `Aggregate`. Writes will
 * provide either the `input_type` or `state_type`, and reads will always
 * return the `state_type` .
 */
export interface Type_Aggregate {
  /**
   * Type of the inputs that are accumulated by this `Aggregate`, which must
   * specify a full encoding.
   * Use `AddInput` mutations to accumulate new inputs.
   */
  inputType:
    | Type
    | undefined;
  /**
   * Output only. Type that holds the internal accumulator state for the
   * `Aggregate`. This is a function of the `input_type` and `aggregator`
   * chosen, and will always specify a full encoding.
   */
  stateType:
    | Type
    | undefined;
  /** Sum aggregator. */
  sum?:
    | Type_Aggregate_Sum
    | undefined;
  /** HyperLogLogPlusPlusUniqueCount aggregator. */
  hllppUniqueCount?:
    | Type_Aggregate_HyperLogLogPlusPlusUniqueCount
    | undefined;
  /** Max aggregator. */
  max?:
    | Type_Aggregate_Max
    | undefined;
  /** Min aggregator. */
  min?: Type_Aggregate_Min | undefined;
}

/**
 * Computes the sum of the input values.
 * Allowed input: `Int64`
 * State: same as input
 */
export interface Type_Aggregate_Sum {
}

/**
 * Computes the max of the input values.
 * Allowed input: `Int64`
 * State: same as input
 */
export interface Type_Aggregate_Max {
}

/**
 * Computes the min of the input values.
 * Allowed input: `Int64`
 * State: same as input
 */
export interface Type_Aggregate_Min {
}

/**
 * Computes an approximate unique count over the input values. When using
 * raw data as input, be careful to use a consistent encoding. Otherwise
 * the same value encoded differently could count more than once, or two
 * distinct values could count as identical.
 * Input: Any, or omit for Raw
 * State: TBD
 * Special state conversions: `Int64` (the unique count estimate)
 */
export interface Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
}

function createBaseType(): Type {
  return {
    bytesType: undefined,
    stringType: undefined,
    int64Type: undefined,
    float32Type: undefined,
    float64Type: undefined,
    boolType: undefined,
    timestampType: undefined,
    dateType: undefined,
    aggregateType: undefined,
    structType: undefined,
    arrayType: undefined,
    mapType: undefined,
  };
}

export const Type: MessageFns<Type> = {
  encode(message: Type, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesType !== undefined) {
      Type_Bytes.encode(message.bytesType, writer.uint32(10).fork()).join();
    }
    if (message.stringType !== undefined) {
      Type_String.encode(message.stringType, writer.uint32(18).fork()).join();
    }
    if (message.int64Type !== undefined) {
      Type_Int64.encode(message.int64Type, writer.uint32(42).fork()).join();
    }
    if (message.float32Type !== undefined) {
      Type_Float32.encode(message.float32Type, writer.uint32(98).fork()).join();
    }
    if (message.float64Type !== undefined) {
      Type_Float64.encode(message.float64Type, writer.uint32(74).fork()).join();
    }
    if (message.boolType !== undefined) {
      Type_Bool.encode(message.boolType, writer.uint32(66).fork()).join();
    }
    if (message.timestampType !== undefined) {
      Type_Timestamp.encode(message.timestampType, writer.uint32(82).fork()).join();
    }
    if (message.dateType !== undefined) {
      Type_DateMessage.encode(message.dateType, writer.uint32(90).fork()).join();
    }
    if (message.aggregateType !== undefined) {
      Type_Aggregate.encode(message.aggregateType, writer.uint32(50).fork()).join();
    }
    if (message.structType !== undefined) {
      Type_Struct.encode(message.structType, writer.uint32(58).fork()).join();
    }
    if (message.arrayType !== undefined) {
      Type_Array.encode(message.arrayType, writer.uint32(26).fork()).join();
    }
    if (message.mapType !== undefined) {
      Type_Map.encode(message.mapType, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bytesType = Type_Bytes.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringType = Type_String.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.int64Type = Type_Int64.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.float32Type = Type_Float32.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.float64Type = Type_Float64.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.boolType = Type_Bool.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.timestampType = Type_Timestamp.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dateType = Type_DateMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.aggregateType = Type_Aggregate.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.structType = Type_Struct.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arrayType = Type_Array.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mapType = Type_Map.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type {
    return {
      bytesType: isSet(object.bytesType) ? Type_Bytes.fromJSON(object.bytesType) : undefined,
      stringType: isSet(object.stringType) ? Type_String.fromJSON(object.stringType) : undefined,
      int64Type: isSet(object.int64Type) ? Type_Int64.fromJSON(object.int64Type) : undefined,
      float32Type: isSet(object.float32Type) ? Type_Float32.fromJSON(object.float32Type) : undefined,
      float64Type: isSet(object.float64Type) ? Type_Float64.fromJSON(object.float64Type) : undefined,
      boolType: isSet(object.boolType) ? Type_Bool.fromJSON(object.boolType) : undefined,
      timestampType: isSet(object.timestampType) ? Type_Timestamp.fromJSON(object.timestampType) : undefined,
      dateType: isSet(object.dateType) ? Type_DateMessage.fromJSON(object.dateType) : undefined,
      aggregateType: isSet(object.aggregateType) ? Type_Aggregate.fromJSON(object.aggregateType) : undefined,
      structType: isSet(object.structType) ? Type_Struct.fromJSON(object.structType) : undefined,
      arrayType: isSet(object.arrayType) ? Type_Array.fromJSON(object.arrayType) : undefined,
      mapType: isSet(object.mapType) ? Type_Map.fromJSON(object.mapType) : undefined,
    };
  },

  toJSON(message: Type): unknown {
    const obj: any = {};
    if (message.bytesType !== undefined) {
      obj.bytesType = Type_Bytes.toJSON(message.bytesType);
    }
    if (message.stringType !== undefined) {
      obj.stringType = Type_String.toJSON(message.stringType);
    }
    if (message.int64Type !== undefined) {
      obj.int64Type = Type_Int64.toJSON(message.int64Type);
    }
    if (message.float32Type !== undefined) {
      obj.float32Type = Type_Float32.toJSON(message.float32Type);
    }
    if (message.float64Type !== undefined) {
      obj.float64Type = Type_Float64.toJSON(message.float64Type);
    }
    if (message.boolType !== undefined) {
      obj.boolType = Type_Bool.toJSON(message.boolType);
    }
    if (message.timestampType !== undefined) {
      obj.timestampType = Type_Timestamp.toJSON(message.timestampType);
    }
    if (message.dateType !== undefined) {
      obj.dateType = Type_DateMessage.toJSON(message.dateType);
    }
    if (message.aggregateType !== undefined) {
      obj.aggregateType = Type_Aggregate.toJSON(message.aggregateType);
    }
    if (message.structType !== undefined) {
      obj.structType = Type_Struct.toJSON(message.structType);
    }
    if (message.arrayType !== undefined) {
      obj.arrayType = Type_Array.toJSON(message.arrayType);
    }
    if (message.mapType !== undefined) {
      obj.mapType = Type_Map.toJSON(message.mapType);
    }
    return obj;
  },

  create(base?: DeepPartial<Type>): Type {
    return Type.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type>): Type {
    const message = createBaseType();
    message.bytesType = (object.bytesType !== undefined && object.bytesType !== null)
      ? Type_Bytes.fromPartial(object.bytesType)
      : undefined;
    message.stringType = (object.stringType !== undefined && object.stringType !== null)
      ? Type_String.fromPartial(object.stringType)
      : undefined;
    message.int64Type = (object.int64Type !== undefined && object.int64Type !== null)
      ? Type_Int64.fromPartial(object.int64Type)
      : undefined;
    message.float32Type = (object.float32Type !== undefined && object.float32Type !== null)
      ? Type_Float32.fromPartial(object.float32Type)
      : undefined;
    message.float64Type = (object.float64Type !== undefined && object.float64Type !== null)
      ? Type_Float64.fromPartial(object.float64Type)
      : undefined;
    message.boolType = (object.boolType !== undefined && object.boolType !== null)
      ? Type_Bool.fromPartial(object.boolType)
      : undefined;
    message.timestampType = (object.timestampType !== undefined && object.timestampType !== null)
      ? Type_Timestamp.fromPartial(object.timestampType)
      : undefined;
    message.dateType = (object.dateType !== undefined && object.dateType !== null)
      ? Type_DateMessage.fromPartial(object.dateType)
      : undefined;
    message.aggregateType = (object.aggregateType !== undefined && object.aggregateType !== null)
      ? Type_Aggregate.fromPartial(object.aggregateType)
      : undefined;
    message.structType = (object.structType !== undefined && object.structType !== null)
      ? Type_Struct.fromPartial(object.structType)
      : undefined;
    message.arrayType = (object.arrayType !== undefined && object.arrayType !== null)
      ? Type_Array.fromPartial(object.arrayType)
      : undefined;
    message.mapType = (object.mapType !== undefined && object.mapType !== null)
      ? Type_Map.fromPartial(object.mapType)
      : undefined;
    return message;
  },
};

function createBaseType_Bytes(): Type_Bytes {
  return { encoding: undefined };
}

export const Type_Bytes: MessageFns<Type_Bytes> = {
  encode(message: Type_Bytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encoding !== undefined) {
      Type_Bytes_Encoding.encode(message.encoding, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Bytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Bytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encoding = Type_Bytes_Encoding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Bytes {
    return { encoding: isSet(object.encoding) ? Type_Bytes_Encoding.fromJSON(object.encoding) : undefined };
  },

  toJSON(message: Type_Bytes): unknown {
    const obj: any = {};
    if (message.encoding !== undefined) {
      obj.encoding = Type_Bytes_Encoding.toJSON(message.encoding);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Bytes>): Type_Bytes {
    return Type_Bytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Bytes>): Type_Bytes {
    const message = createBaseType_Bytes();
    message.encoding = (object.encoding !== undefined && object.encoding !== null)
      ? Type_Bytes_Encoding.fromPartial(object.encoding)
      : undefined;
    return message;
  },
};

function createBaseType_Bytes_Encoding(): Type_Bytes_Encoding {
  return { raw: undefined };
}

export const Type_Bytes_Encoding: MessageFns<Type_Bytes_Encoding> = {
  encode(message: Type_Bytes_Encoding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.raw !== undefined) {
      Type_Bytes_Encoding_Raw.encode(message.raw, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Bytes_Encoding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Bytes_Encoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.raw = Type_Bytes_Encoding_Raw.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Bytes_Encoding {
    return { raw: isSet(object.raw) ? Type_Bytes_Encoding_Raw.fromJSON(object.raw) : undefined };
  },

  toJSON(message: Type_Bytes_Encoding): unknown {
    const obj: any = {};
    if (message.raw !== undefined) {
      obj.raw = Type_Bytes_Encoding_Raw.toJSON(message.raw);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Bytes_Encoding>): Type_Bytes_Encoding {
    return Type_Bytes_Encoding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Bytes_Encoding>): Type_Bytes_Encoding {
    const message = createBaseType_Bytes_Encoding();
    message.raw = (object.raw !== undefined && object.raw !== null)
      ? Type_Bytes_Encoding_Raw.fromPartial(object.raw)
      : undefined;
    return message;
  },
};

function createBaseType_Bytes_Encoding_Raw(): Type_Bytes_Encoding_Raw {
  return {};
}

export const Type_Bytes_Encoding_Raw: MessageFns<Type_Bytes_Encoding_Raw> = {
  encode(_: Type_Bytes_Encoding_Raw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Bytes_Encoding_Raw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Bytes_Encoding_Raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Bytes_Encoding_Raw {
    return {};
  },

  toJSON(_: Type_Bytes_Encoding_Raw): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Bytes_Encoding_Raw>): Type_Bytes_Encoding_Raw {
    return Type_Bytes_Encoding_Raw.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Bytes_Encoding_Raw>): Type_Bytes_Encoding_Raw {
    const message = createBaseType_Bytes_Encoding_Raw();
    return message;
  },
};

function createBaseType_String(): Type_String {
  return { encoding: undefined };
}

export const Type_String: MessageFns<Type_String> = {
  encode(message: Type_String, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encoding !== undefined) {
      Type_String_Encoding.encode(message.encoding, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_String {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_String();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encoding = Type_String_Encoding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_String {
    return { encoding: isSet(object.encoding) ? Type_String_Encoding.fromJSON(object.encoding) : undefined };
  },

  toJSON(message: Type_String): unknown {
    const obj: any = {};
    if (message.encoding !== undefined) {
      obj.encoding = Type_String_Encoding.toJSON(message.encoding);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_String>): Type_String {
    return Type_String.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_String>): Type_String {
    const message = createBaseType_String();
    message.encoding = (object.encoding !== undefined && object.encoding !== null)
      ? Type_String_Encoding.fromPartial(object.encoding)
      : undefined;
    return message;
  },
};

function createBaseType_String_Encoding(): Type_String_Encoding {
  return { utf8Raw: undefined, utf8Bytes: undefined };
}

export const Type_String_Encoding: MessageFns<Type_String_Encoding> = {
  encode(message: Type_String_Encoding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utf8Raw !== undefined) {
      Type_String_Encoding_Utf8Raw.encode(message.utf8Raw, writer.uint32(10).fork()).join();
    }
    if (message.utf8Bytes !== undefined) {
      Type_String_Encoding_Utf8Bytes.encode(message.utf8Bytes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_String_Encoding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_String_Encoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.utf8Raw = Type_String_Encoding_Utf8Raw.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utf8Bytes = Type_String_Encoding_Utf8Bytes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_String_Encoding {
    return {
      utf8Raw: isSet(object.utf8Raw) ? Type_String_Encoding_Utf8Raw.fromJSON(object.utf8Raw) : undefined,
      utf8Bytes: isSet(object.utf8Bytes) ? Type_String_Encoding_Utf8Bytes.fromJSON(object.utf8Bytes) : undefined,
    };
  },

  toJSON(message: Type_String_Encoding): unknown {
    const obj: any = {};
    if (message.utf8Raw !== undefined) {
      obj.utf8Raw = Type_String_Encoding_Utf8Raw.toJSON(message.utf8Raw);
    }
    if (message.utf8Bytes !== undefined) {
      obj.utf8Bytes = Type_String_Encoding_Utf8Bytes.toJSON(message.utf8Bytes);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_String_Encoding>): Type_String_Encoding {
    return Type_String_Encoding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_String_Encoding>): Type_String_Encoding {
    const message = createBaseType_String_Encoding();
    message.utf8Raw = (object.utf8Raw !== undefined && object.utf8Raw !== null)
      ? Type_String_Encoding_Utf8Raw.fromPartial(object.utf8Raw)
      : undefined;
    message.utf8Bytes = (object.utf8Bytes !== undefined && object.utf8Bytes !== null)
      ? Type_String_Encoding_Utf8Bytes.fromPartial(object.utf8Bytes)
      : undefined;
    return message;
  },
};

function createBaseType_String_Encoding_Utf8Raw(): Type_String_Encoding_Utf8Raw {
  return {};
}

export const Type_String_Encoding_Utf8Raw: MessageFns<Type_String_Encoding_Utf8Raw> = {
  encode(_: Type_String_Encoding_Utf8Raw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_String_Encoding_Utf8Raw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_String_Encoding_Utf8Raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_String_Encoding_Utf8Raw {
    return {};
  },

  toJSON(_: Type_String_Encoding_Utf8Raw): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_String_Encoding_Utf8Raw>): Type_String_Encoding_Utf8Raw {
    return Type_String_Encoding_Utf8Raw.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_String_Encoding_Utf8Raw>): Type_String_Encoding_Utf8Raw {
    const message = createBaseType_String_Encoding_Utf8Raw();
    return message;
  },
};

function createBaseType_String_Encoding_Utf8Bytes(): Type_String_Encoding_Utf8Bytes {
  return {};
}

export const Type_String_Encoding_Utf8Bytes: MessageFns<Type_String_Encoding_Utf8Bytes> = {
  encode(_: Type_String_Encoding_Utf8Bytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_String_Encoding_Utf8Bytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_String_Encoding_Utf8Bytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_String_Encoding_Utf8Bytes {
    return {};
  },

  toJSON(_: Type_String_Encoding_Utf8Bytes): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_String_Encoding_Utf8Bytes>): Type_String_Encoding_Utf8Bytes {
    return Type_String_Encoding_Utf8Bytes.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_String_Encoding_Utf8Bytes>): Type_String_Encoding_Utf8Bytes {
    const message = createBaseType_String_Encoding_Utf8Bytes();
    return message;
  },
};

function createBaseType_Int64(): Type_Int64 {
  return { encoding: undefined };
}

export const Type_Int64: MessageFns<Type_Int64> = {
  encode(message: Type_Int64, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encoding !== undefined) {
      Type_Int64_Encoding.encode(message.encoding, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Int64 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Int64();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encoding = Type_Int64_Encoding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Int64 {
    return { encoding: isSet(object.encoding) ? Type_Int64_Encoding.fromJSON(object.encoding) : undefined };
  },

  toJSON(message: Type_Int64): unknown {
    const obj: any = {};
    if (message.encoding !== undefined) {
      obj.encoding = Type_Int64_Encoding.toJSON(message.encoding);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Int64>): Type_Int64 {
    return Type_Int64.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Int64>): Type_Int64 {
    const message = createBaseType_Int64();
    message.encoding = (object.encoding !== undefined && object.encoding !== null)
      ? Type_Int64_Encoding.fromPartial(object.encoding)
      : undefined;
    return message;
  },
};

function createBaseType_Int64_Encoding(): Type_Int64_Encoding {
  return { bigEndianBytes: undefined };
}

export const Type_Int64_Encoding: MessageFns<Type_Int64_Encoding> = {
  encode(message: Type_Int64_Encoding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bigEndianBytes !== undefined) {
      Type_Int64_Encoding_BigEndianBytes.encode(message.bigEndianBytes, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Int64_Encoding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Int64_Encoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bigEndianBytes = Type_Int64_Encoding_BigEndianBytes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Int64_Encoding {
    return {
      bigEndianBytes: isSet(object.bigEndianBytes)
        ? Type_Int64_Encoding_BigEndianBytes.fromJSON(object.bigEndianBytes)
        : undefined,
    };
  },

  toJSON(message: Type_Int64_Encoding): unknown {
    const obj: any = {};
    if (message.bigEndianBytes !== undefined) {
      obj.bigEndianBytes = Type_Int64_Encoding_BigEndianBytes.toJSON(message.bigEndianBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Int64_Encoding>): Type_Int64_Encoding {
    return Type_Int64_Encoding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Int64_Encoding>): Type_Int64_Encoding {
    const message = createBaseType_Int64_Encoding();
    message.bigEndianBytes = (object.bigEndianBytes !== undefined && object.bigEndianBytes !== null)
      ? Type_Int64_Encoding_BigEndianBytes.fromPartial(object.bigEndianBytes)
      : undefined;
    return message;
  },
};

function createBaseType_Int64_Encoding_BigEndianBytes(): Type_Int64_Encoding_BigEndianBytes {
  return { bytesType: undefined };
}

export const Type_Int64_Encoding_BigEndianBytes: MessageFns<Type_Int64_Encoding_BigEndianBytes> = {
  encode(message: Type_Int64_Encoding_BigEndianBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesType !== undefined) {
      Type_Bytes.encode(message.bytesType, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Int64_Encoding_BigEndianBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Int64_Encoding_BigEndianBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bytesType = Type_Bytes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Int64_Encoding_BigEndianBytes {
    return { bytesType: isSet(object.bytesType) ? Type_Bytes.fromJSON(object.bytesType) : undefined };
  },

  toJSON(message: Type_Int64_Encoding_BigEndianBytes): unknown {
    const obj: any = {};
    if (message.bytesType !== undefined) {
      obj.bytesType = Type_Bytes.toJSON(message.bytesType);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Int64_Encoding_BigEndianBytes>): Type_Int64_Encoding_BigEndianBytes {
    return Type_Int64_Encoding_BigEndianBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Int64_Encoding_BigEndianBytes>): Type_Int64_Encoding_BigEndianBytes {
    const message = createBaseType_Int64_Encoding_BigEndianBytes();
    message.bytesType = (object.bytesType !== undefined && object.bytesType !== null)
      ? Type_Bytes.fromPartial(object.bytesType)
      : undefined;
    return message;
  },
};

function createBaseType_Bool(): Type_Bool {
  return {};
}

export const Type_Bool: MessageFns<Type_Bool> = {
  encode(_: Type_Bool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Bool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Bool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Bool {
    return {};
  },

  toJSON(_: Type_Bool): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Bool>): Type_Bool {
    return Type_Bool.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Bool>): Type_Bool {
    const message = createBaseType_Bool();
    return message;
  },
};

function createBaseType_Float32(): Type_Float32 {
  return {};
}

export const Type_Float32: MessageFns<Type_Float32> = {
  encode(_: Type_Float32, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Float32 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Float32();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Float32 {
    return {};
  },

  toJSON(_: Type_Float32): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Float32>): Type_Float32 {
    return Type_Float32.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Float32>): Type_Float32 {
    const message = createBaseType_Float32();
    return message;
  },
};

function createBaseType_Float64(): Type_Float64 {
  return {};
}

export const Type_Float64: MessageFns<Type_Float64> = {
  encode(_: Type_Float64, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Float64 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Float64();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Float64 {
    return {};
  },

  toJSON(_: Type_Float64): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Float64>): Type_Float64 {
    return Type_Float64.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Float64>): Type_Float64 {
    const message = createBaseType_Float64();
    return message;
  },
};

function createBaseType_Timestamp(): Type_Timestamp {
  return {};
}

export const Type_Timestamp: MessageFns<Type_Timestamp> = {
  encode(_: Type_Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Timestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Timestamp {
    return {};
  },

  toJSON(_: Type_Timestamp): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Timestamp>): Type_Timestamp {
    return Type_Timestamp.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Timestamp>): Type_Timestamp {
    const message = createBaseType_Timestamp();
    return message;
  },
};

function createBaseType_DateMessage(): Type_DateMessage {
  return {};
}

export const Type_DateMessage: MessageFns<Type_DateMessage> = {
  encode(_: Type_DateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_DateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_DateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_DateMessage {
    return {};
  },

  toJSON(_: Type_DateMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_DateMessage>): Type_DateMessage {
    return Type_DateMessage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_DateMessage>): Type_DateMessage {
    const message = createBaseType_DateMessage();
    return message;
  },
};

function createBaseType_Struct(): Type_Struct {
  return { fields: [] };
}

export const Type_Struct: MessageFns<Type_Struct> = {
  encode(message: Type_Struct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Type_Struct_Field.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Struct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Struct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(Type_Struct_Field.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Struct {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => Type_Struct_Field.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Type_Struct): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Type_Struct_Field.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Struct>): Type_Struct {
    return Type_Struct.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Struct>): Type_Struct {
    const message = createBaseType_Struct();
    message.fields = object.fields?.map((e) => Type_Struct_Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseType_Struct_Field(): Type_Struct_Field {
  return { fieldName: "", type: undefined };
}

export const Type_Struct_Field: MessageFns<Type_Struct_Field> = {
  encode(message: Type_Struct_Field, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.type !== undefined) {
      Type.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Struct_Field {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Struct_Field();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = Type.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Struct_Field {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      type: isSet(object.type) ? Type.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: Type_Struct_Field): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.type !== undefined) {
      obj.type = Type.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Struct_Field>): Type_Struct_Field {
    return Type_Struct_Field.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Struct_Field>): Type_Struct_Field {
    const message = createBaseType_Struct_Field();
    message.fieldName = object.fieldName ?? "";
    message.type = (object.type !== undefined && object.type !== null) ? Type.fromPartial(object.type) : undefined;
    return message;
  },
};

function createBaseType_Array(): Type_Array {
  return { elementType: undefined };
}

export const Type_Array: MessageFns<Type_Array> = {
  encode(message: Type_Array, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.elementType !== undefined) {
      Type.encode(message.elementType, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Array {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Array();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementType = Type.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Array {
    return { elementType: isSet(object.elementType) ? Type.fromJSON(object.elementType) : undefined };
  },

  toJSON(message: Type_Array): unknown {
    const obj: any = {};
    if (message.elementType !== undefined) {
      obj.elementType = Type.toJSON(message.elementType);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Array>): Type_Array {
    return Type_Array.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Array>): Type_Array {
    const message = createBaseType_Array();
    message.elementType = (object.elementType !== undefined && object.elementType !== null)
      ? Type.fromPartial(object.elementType)
      : undefined;
    return message;
  },
};

function createBaseType_Map(): Type_Map {
  return { keyType: undefined, valueType: undefined };
}

export const Type_Map: MessageFns<Type_Map> = {
  encode(message: Type_Map, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyType !== undefined) {
      Type.encode(message.keyType, writer.uint32(10).fork()).join();
    }
    if (message.valueType !== undefined) {
      Type.encode(message.valueType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Map {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Map();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyType = Type.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.valueType = Type.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Map {
    return {
      keyType: isSet(object.keyType) ? Type.fromJSON(object.keyType) : undefined,
      valueType: isSet(object.valueType) ? Type.fromJSON(object.valueType) : undefined,
    };
  },

  toJSON(message: Type_Map): unknown {
    const obj: any = {};
    if (message.keyType !== undefined) {
      obj.keyType = Type.toJSON(message.keyType);
    }
    if (message.valueType !== undefined) {
      obj.valueType = Type.toJSON(message.valueType);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Map>): Type_Map {
    return Type_Map.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Map>): Type_Map {
    const message = createBaseType_Map();
    message.keyType = (object.keyType !== undefined && object.keyType !== null)
      ? Type.fromPartial(object.keyType)
      : undefined;
    message.valueType = (object.valueType !== undefined && object.valueType !== null)
      ? Type.fromPartial(object.valueType)
      : undefined;
    return message;
  },
};

function createBaseType_Aggregate(): Type_Aggregate {
  return {
    inputType: undefined,
    stateType: undefined,
    sum: undefined,
    hllppUniqueCount: undefined,
    max: undefined,
    min: undefined,
  };
}

export const Type_Aggregate: MessageFns<Type_Aggregate> = {
  encode(message: Type_Aggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputType !== undefined) {
      Type.encode(message.inputType, writer.uint32(10).fork()).join();
    }
    if (message.stateType !== undefined) {
      Type.encode(message.stateType, writer.uint32(18).fork()).join();
    }
    if (message.sum !== undefined) {
      Type_Aggregate_Sum.encode(message.sum, writer.uint32(34).fork()).join();
    }
    if (message.hllppUniqueCount !== undefined) {
      Type_Aggregate_HyperLogLogPlusPlusUniqueCount.encode(message.hllppUniqueCount, writer.uint32(42).fork()).join();
    }
    if (message.max !== undefined) {
      Type_Aggregate_Max.encode(message.max, writer.uint32(50).fork()).join();
    }
    if (message.min !== undefined) {
      Type_Aggregate_Min.encode(message.min, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Aggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Aggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputType = Type.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateType = Type.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sum = Type_Aggregate_Sum.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hllppUniqueCount = Type_Aggregate_HyperLogLogPlusPlusUniqueCount.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.max = Type_Aggregate_Max.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.min = Type_Aggregate_Min.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Type_Aggregate {
    return {
      inputType: isSet(object.inputType) ? Type.fromJSON(object.inputType) : undefined,
      stateType: isSet(object.stateType) ? Type.fromJSON(object.stateType) : undefined,
      sum: isSet(object.sum) ? Type_Aggregate_Sum.fromJSON(object.sum) : undefined,
      hllppUniqueCount: isSet(object.hllppUniqueCount)
        ? Type_Aggregate_HyperLogLogPlusPlusUniqueCount.fromJSON(object.hllppUniqueCount)
        : undefined,
      max: isSet(object.max) ? Type_Aggregate_Max.fromJSON(object.max) : undefined,
      min: isSet(object.min) ? Type_Aggregate_Min.fromJSON(object.min) : undefined,
    };
  },

  toJSON(message: Type_Aggregate): unknown {
    const obj: any = {};
    if (message.inputType !== undefined) {
      obj.inputType = Type.toJSON(message.inputType);
    }
    if (message.stateType !== undefined) {
      obj.stateType = Type.toJSON(message.stateType);
    }
    if (message.sum !== undefined) {
      obj.sum = Type_Aggregate_Sum.toJSON(message.sum);
    }
    if (message.hllppUniqueCount !== undefined) {
      obj.hllppUniqueCount = Type_Aggregate_HyperLogLogPlusPlusUniqueCount.toJSON(message.hllppUniqueCount);
    }
    if (message.max !== undefined) {
      obj.max = Type_Aggregate_Max.toJSON(message.max);
    }
    if (message.min !== undefined) {
      obj.min = Type_Aggregate_Min.toJSON(message.min);
    }
    return obj;
  },

  create(base?: DeepPartial<Type_Aggregate>): Type_Aggregate {
    return Type_Aggregate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Type_Aggregate>): Type_Aggregate {
    const message = createBaseType_Aggregate();
    message.inputType = (object.inputType !== undefined && object.inputType !== null)
      ? Type.fromPartial(object.inputType)
      : undefined;
    message.stateType = (object.stateType !== undefined && object.stateType !== null)
      ? Type.fromPartial(object.stateType)
      : undefined;
    message.sum = (object.sum !== undefined && object.sum !== null)
      ? Type_Aggregate_Sum.fromPartial(object.sum)
      : undefined;
    message.hllppUniqueCount = (object.hllppUniqueCount !== undefined && object.hllppUniqueCount !== null)
      ? Type_Aggregate_HyperLogLogPlusPlusUniqueCount.fromPartial(object.hllppUniqueCount)
      : undefined;
    message.max = (object.max !== undefined && object.max !== null)
      ? Type_Aggregate_Max.fromPartial(object.max)
      : undefined;
    message.min = (object.min !== undefined && object.min !== null)
      ? Type_Aggregate_Min.fromPartial(object.min)
      : undefined;
    return message;
  },
};

function createBaseType_Aggregate_Sum(): Type_Aggregate_Sum {
  return {};
}

export const Type_Aggregate_Sum: MessageFns<Type_Aggregate_Sum> = {
  encode(_: Type_Aggregate_Sum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Aggregate_Sum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Aggregate_Sum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Aggregate_Sum {
    return {};
  },

  toJSON(_: Type_Aggregate_Sum): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Aggregate_Sum>): Type_Aggregate_Sum {
    return Type_Aggregate_Sum.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Aggregate_Sum>): Type_Aggregate_Sum {
    const message = createBaseType_Aggregate_Sum();
    return message;
  },
};

function createBaseType_Aggregate_Max(): Type_Aggregate_Max {
  return {};
}

export const Type_Aggregate_Max: MessageFns<Type_Aggregate_Max> = {
  encode(_: Type_Aggregate_Max, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Aggregate_Max {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Aggregate_Max();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Aggregate_Max {
    return {};
  },

  toJSON(_: Type_Aggregate_Max): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Aggregate_Max>): Type_Aggregate_Max {
    return Type_Aggregate_Max.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Aggregate_Max>): Type_Aggregate_Max {
    const message = createBaseType_Aggregate_Max();
    return message;
  },
};

function createBaseType_Aggregate_Min(): Type_Aggregate_Min {
  return {};
}

export const Type_Aggregate_Min: MessageFns<Type_Aggregate_Min> = {
  encode(_: Type_Aggregate_Min, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Type_Aggregate_Min {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_Aggregate_Min();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Type_Aggregate_Min {
    return {};
  },

  toJSON(_: Type_Aggregate_Min): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Type_Aggregate_Min>): Type_Aggregate_Min {
    return Type_Aggregate_Min.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Type_Aggregate_Min>): Type_Aggregate_Min {
    const message = createBaseType_Aggregate_Min();
    return message;
  },
};

function createBaseType_Aggregate_HyperLogLogPlusPlusUniqueCount(): Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
  return {};
}

export const Type_Aggregate_HyperLogLogPlusPlusUniqueCount: MessageFns<Type_Aggregate_HyperLogLogPlusPlusUniqueCount> =
  {
    encode(_: Type_Aggregate_HyperLogLogPlusPlusUniqueCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseType_Aggregate_HyperLogLogPlusPlusUniqueCount();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
      return {};
    },

    toJSON(_: Type_Aggregate_HyperLogLogPlusPlusUniqueCount): unknown {
      const obj: any = {};
      return obj;
    },

    create(
      base?: DeepPartial<Type_Aggregate_HyperLogLogPlusPlusUniqueCount>,
    ): Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
      return Type_Aggregate_HyperLogLogPlusPlusUniqueCount.fromPartial(base ?? {});
    },
    fromPartial(
      _: DeepPartial<Type_Aggregate_HyperLogLogPlusPlusUniqueCount>,
    ): Type_Aggregate_HyperLogLogPlusPlusUniqueCount {
      const message = createBaseType_Aggregate_HyperLogLogPlusPlusUniqueCount();
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
