// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/clouddms/logging/v1/clouddms_platform_logs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";

export const protobufPackage = "google.cloud.clouddms.logging.v1";

/** The database engines. */
export enum DatabaseEngine {
  /** DATABASE_ENGINE_UNSPECIFIED - The source database engine of the migration job is unknown. */
  DATABASE_ENGINE_UNSPECIFIED = 0,
  /** MYSQL - The source engine is MySQL. */
  MYSQL = 1,
  /** POSTGRESQL - The source engine is PostgreSQL. */
  POSTGRESQL = 2,
  /** SQLSERVER - The source engine is SQL Server. */
  SQLSERVER = 3,
  /** ORACLE - The source engine is Oracle (for heterogeneous migrations). */
  ORACLE = 4,
  /** SPANNER - The engine is Spanner (for heterogeneous migrations). */
  SPANNER = 5,
  UNRECOGNIZED = -1,
}

export function databaseEngineFromJSON(object: any): DatabaseEngine {
  switch (object) {
    case 0:
    case "DATABASE_ENGINE_UNSPECIFIED":
      return DatabaseEngine.DATABASE_ENGINE_UNSPECIFIED;
    case 1:
    case "MYSQL":
      return DatabaseEngine.MYSQL;
    case 2:
    case "POSTGRESQL":
      return DatabaseEngine.POSTGRESQL;
    case 3:
    case "SQLSERVER":
      return DatabaseEngine.SQLSERVER;
    case 4:
    case "ORACLE":
      return DatabaseEngine.ORACLE;
    case 5:
    case "SPANNER":
      return DatabaseEngine.SPANNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEngine.UNRECOGNIZED;
  }
}

export function databaseEngineToJSON(object: DatabaseEngine): string {
  switch (object) {
    case DatabaseEngine.DATABASE_ENGINE_UNSPECIFIED:
      return "DATABASE_ENGINE_UNSPECIFIED";
    case DatabaseEngine.MYSQL:
      return "MYSQL";
    case DatabaseEngine.POSTGRESQL:
      return "POSTGRESQL";
    case DatabaseEngine.SQLSERVER:
      return "SQLSERVER";
    case DatabaseEngine.ORACLE:
      return "ORACLE";
    case DatabaseEngine.SPANNER:
      return "SPANNER";
    case DatabaseEngine.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The database providers. */
export enum DatabaseProvider {
  /** DATABASE_PROVIDER_UNSPECIFIED - The database provider is unknown. */
  DATABASE_PROVIDER_UNSPECIFIED = 0,
  /** CLOUDSQL - CloudSQL runs the database. */
  CLOUDSQL = 1,
  /** RDS - RDS runs the database. */
  RDS = 2,
  /** AURORA - Amazon Aurora. */
  AURORA = 3,
  /** ALLOYDB - AlloyDB. */
  ALLOYDB = 4,
  UNRECOGNIZED = -1,
}

export function databaseProviderFromJSON(object: any): DatabaseProvider {
  switch (object) {
    case 0:
    case "DATABASE_PROVIDER_UNSPECIFIED":
      return DatabaseProvider.DATABASE_PROVIDER_UNSPECIFIED;
    case 1:
    case "CLOUDSQL":
      return DatabaseProvider.CLOUDSQL;
    case 2:
    case "RDS":
      return DatabaseProvider.RDS;
    case 3:
    case "AURORA":
      return DatabaseProvider.AURORA;
    case 4:
    case "ALLOYDB":
      return DatabaseProvider.ALLOYDB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseProvider.UNRECOGNIZED;
  }
}

export function databaseProviderToJSON(object: DatabaseProvider): string {
  switch (object) {
    case DatabaseProvider.DATABASE_PROVIDER_UNSPECIFIED:
      return "DATABASE_PROVIDER_UNSPECIFIED";
    case DatabaseProvider.CLOUDSQL:
      return "CLOUDSQL";
    case DatabaseProvider.RDS:
      return "RDS";
    case DatabaseProvider.AURORA:
      return "AURORA";
    case DatabaseProvider.ALLOYDB:
      return "ALLOYDB";
    case DatabaseProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A message defining the database engine and provider. */
export interface DatabaseType {
  /** The database provider. */
  provider: DatabaseProvider;
  /** The database engine. */
  engine: DatabaseEngine;
}

/**
 * Migration job as stored in Cloud Logging logs.
 * NEXT_TAG = 36.
 */
export interface LoggedMigrationJob {
  /** Required. The unique identifier for a migration job. */
  name: string;
  /** Required. Labels. */
  labels: { [key: string]: string };
  /** Required. The display name. */
  displayName: string;
  /** Required. The current migration job state. */
  state: LoggedMigrationJob_State;
  /** Required. The current migration job phase. */
  phase: LoggedMigrationJob_Phase;
  /** Required. The migration job type. */
  type: LoggedMigrationJob_Type;
  /** Optional. An optional dump path (gs://[BUCKET_NAME]/[OBJECT_NAME]). */
  dumpPath: string;
  /** Required. The migration job source connection profile name. */
  source: string;
  /** Required. The migration job destination connection profile name. */
  destination: string;
  /** Required. the migration job duration in seconds. */
  duration:
    | Duration
    | undefined;
  /** Required. Type of connectivity to source database. */
  connectivityType: LoggedMigrationJob_ConnectivityType;
  /** Required. The error details in case of state FAILED. */
  error:
    | Status
    | undefined;
  /**
   * Required. The time when this migration job was completed. Should only be set when the
   * phase of the migration job is COMPLETED.
   */
  endTime:
    | Date
    | undefined;
  /** Required. The indicative source database. */
  sourceDatabase:
    | DatabaseType
    | undefined;
  /** Required. The indicative destination database. */
  destinationDatabase: DatabaseType | undefined;
}

/** The migration job states enum. */
export enum LoggedMigrationJob_State {
  /** STATE_UNSPECIFIED - The state of the migration job is unknown. */
  STATE_UNSPECIFIED = 0,
  /** MAINTENANCE - The migration job is down for maintenance. */
  MAINTENANCE = 1,
  /** DRAFT - The migration job is in draft mode and fully editable. */
  DRAFT = 2,
  /** CREATING - The migration job is being created. */
  CREATING = 3,
  /** NOT_STARTED - The migration job is created and not started. */
  NOT_STARTED = 4,
  /** RUNNING - The migration job is running */
  RUNNING = 5,
  /** FAILED - The migration job failed. */
  FAILED = 6,
  /** COMPLETED - The migration job has been completed. */
  COMPLETED = 7,
  /** DELETING - The migration job is being deleted. */
  DELETING = 8,
  /** STOPPING - The migration job is being stopped. */
  STOPPING = 9,
  /** STOPPED - The migration job is currently stopped. */
  STOPPED = 10,
  /** DELETED - The migration job has been deleted. */
  DELETED = 11,
  /** UPDATING - The migration job is being updated. */
  UPDATING = 12,
  /** STARTING - The migration job is starting. */
  STARTING = 13,
  /** RESTARTING - The migration job is restarting. */
  RESTARTING = 14,
  /** RESUMING - The migration job is resuming. */
  RESUMING = 15,
  UNRECOGNIZED = -1,
}

export function loggedMigrationJob_StateFromJSON(object: any): LoggedMigrationJob_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return LoggedMigrationJob_State.STATE_UNSPECIFIED;
    case 1:
    case "MAINTENANCE":
      return LoggedMigrationJob_State.MAINTENANCE;
    case 2:
    case "DRAFT":
      return LoggedMigrationJob_State.DRAFT;
    case 3:
    case "CREATING":
      return LoggedMigrationJob_State.CREATING;
    case 4:
    case "NOT_STARTED":
      return LoggedMigrationJob_State.NOT_STARTED;
    case 5:
    case "RUNNING":
      return LoggedMigrationJob_State.RUNNING;
    case 6:
    case "FAILED":
      return LoggedMigrationJob_State.FAILED;
    case 7:
    case "COMPLETED":
      return LoggedMigrationJob_State.COMPLETED;
    case 8:
    case "DELETING":
      return LoggedMigrationJob_State.DELETING;
    case 9:
    case "STOPPING":
      return LoggedMigrationJob_State.STOPPING;
    case 10:
    case "STOPPED":
      return LoggedMigrationJob_State.STOPPED;
    case 11:
    case "DELETED":
      return LoggedMigrationJob_State.DELETED;
    case 12:
    case "UPDATING":
      return LoggedMigrationJob_State.UPDATING;
    case 13:
    case "STARTING":
      return LoggedMigrationJob_State.STARTING;
    case 14:
    case "RESTARTING":
      return LoggedMigrationJob_State.RESTARTING;
    case 15:
    case "RESUMING":
      return LoggedMigrationJob_State.RESUMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedMigrationJob_State.UNRECOGNIZED;
  }
}

export function loggedMigrationJob_StateToJSON(object: LoggedMigrationJob_State): string {
  switch (object) {
    case LoggedMigrationJob_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case LoggedMigrationJob_State.MAINTENANCE:
      return "MAINTENANCE";
    case LoggedMigrationJob_State.DRAFT:
      return "DRAFT";
    case LoggedMigrationJob_State.CREATING:
      return "CREATING";
    case LoggedMigrationJob_State.NOT_STARTED:
      return "NOT_STARTED";
    case LoggedMigrationJob_State.RUNNING:
      return "RUNNING";
    case LoggedMigrationJob_State.FAILED:
      return "FAILED";
    case LoggedMigrationJob_State.COMPLETED:
      return "COMPLETED";
    case LoggedMigrationJob_State.DELETING:
      return "DELETING";
    case LoggedMigrationJob_State.STOPPING:
      return "STOPPING";
    case LoggedMigrationJob_State.STOPPED:
      return "STOPPED";
    case LoggedMigrationJob_State.DELETED:
      return "DELETED";
    case LoggedMigrationJob_State.UPDATING:
      return "UPDATING";
    case LoggedMigrationJob_State.STARTING:
      return "STARTING";
    case LoggedMigrationJob_State.RESTARTING:
      return "RESTARTING";
    case LoggedMigrationJob_State.RESUMING:
      return "RESUMING";
    case LoggedMigrationJob_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The migration job phases enum. */
export enum LoggedMigrationJob_Phase {
  /** PHASE_UNSPECIFIED - The phase of the migration job is unknown. */
  PHASE_UNSPECIFIED = 0,
  /** FULL_DUMP - The migration job is in the full dump phase. */
  FULL_DUMP = 1,
  /** CDC - The migration job is CDC phase. */
  CDC = 2,
  /** PROMOTE_IN_PROGRESS - The migration job is running the promote phase. */
  PROMOTE_IN_PROGRESS = 3,
  /** WAITING_FOR_SOURCE_WRITES_TO_STOP - Only RDS flow - waiting for source writes to stop */
  WAITING_FOR_SOURCE_WRITES_TO_STOP = 4,
  /** PREPARING_THE_DUMP - Only RDS flow - the sources writes stopped, waiting for dump to begin */
  PREPARING_THE_DUMP = 5,
  UNRECOGNIZED = -1,
}

export function loggedMigrationJob_PhaseFromJSON(object: any): LoggedMigrationJob_Phase {
  switch (object) {
    case 0:
    case "PHASE_UNSPECIFIED":
      return LoggedMigrationJob_Phase.PHASE_UNSPECIFIED;
    case 1:
    case "FULL_DUMP":
      return LoggedMigrationJob_Phase.FULL_DUMP;
    case 2:
    case "CDC":
      return LoggedMigrationJob_Phase.CDC;
    case 3:
    case "PROMOTE_IN_PROGRESS":
      return LoggedMigrationJob_Phase.PROMOTE_IN_PROGRESS;
    case 4:
    case "WAITING_FOR_SOURCE_WRITES_TO_STOP":
      return LoggedMigrationJob_Phase.WAITING_FOR_SOURCE_WRITES_TO_STOP;
    case 5:
    case "PREPARING_THE_DUMP":
      return LoggedMigrationJob_Phase.PREPARING_THE_DUMP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedMigrationJob_Phase.UNRECOGNIZED;
  }
}

export function loggedMigrationJob_PhaseToJSON(object: LoggedMigrationJob_Phase): string {
  switch (object) {
    case LoggedMigrationJob_Phase.PHASE_UNSPECIFIED:
      return "PHASE_UNSPECIFIED";
    case LoggedMigrationJob_Phase.FULL_DUMP:
      return "FULL_DUMP";
    case LoggedMigrationJob_Phase.CDC:
      return "CDC";
    case LoggedMigrationJob_Phase.PROMOTE_IN_PROGRESS:
      return "PROMOTE_IN_PROGRESS";
    case LoggedMigrationJob_Phase.WAITING_FOR_SOURCE_WRITES_TO_STOP:
      return "WAITING_FOR_SOURCE_WRITES_TO_STOP";
    case LoggedMigrationJob_Phase.PREPARING_THE_DUMP:
      return "PREPARING_THE_DUMP";
    case LoggedMigrationJob_Phase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The migration job types. */
export enum LoggedMigrationJob_Type {
  /** TYPE_UNSPECIFIED - The type of the migration job is unknown. */
  TYPE_UNSPECIFIED = 0,
  /** ONE_TIME - The migration job is a one time migration. */
  ONE_TIME = 1,
  /** CONTINUOUS - The migration job is a continuous migration. */
  CONTINUOUS = 2,
  UNRECOGNIZED = -1,
}

export function loggedMigrationJob_TypeFromJSON(object: any): LoggedMigrationJob_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return LoggedMigrationJob_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ONE_TIME":
      return LoggedMigrationJob_Type.ONE_TIME;
    case 2:
    case "CONTINUOUS":
      return LoggedMigrationJob_Type.CONTINUOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedMigrationJob_Type.UNRECOGNIZED;
  }
}

export function loggedMigrationJob_TypeToJSON(object: LoggedMigrationJob_Type): string {
  switch (object) {
    case LoggedMigrationJob_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case LoggedMigrationJob_Type.ONE_TIME:
      return "ONE_TIME";
    case LoggedMigrationJob_Type.CONTINUOUS:
      return "CONTINUOUS";
    case LoggedMigrationJob_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of connectivity to source database. */
export enum LoggedMigrationJob_ConnectivityType {
  /** CONNECTIVITY_TYPE_UNSPECIFIED - No data defined. */
  CONNECTIVITY_TYPE_UNSPECIFIED = 0,
  /** STATIC_IP - Connect using static IO */
  STATIC_IP = 1,
  /** REVERSE_SSH - Use reverse SSH connectivity. */
  REVERSE_SSH = 2,
  /** VPC_PEERING - Use VPC Peering connectivity. */
  VPC_PEERING = 3,
  UNRECOGNIZED = -1,
}

export function loggedMigrationJob_ConnectivityTypeFromJSON(object: any): LoggedMigrationJob_ConnectivityType {
  switch (object) {
    case 0:
    case "CONNECTIVITY_TYPE_UNSPECIFIED":
      return LoggedMigrationJob_ConnectivityType.CONNECTIVITY_TYPE_UNSPECIFIED;
    case 1:
    case "STATIC_IP":
      return LoggedMigrationJob_ConnectivityType.STATIC_IP;
    case 2:
    case "REVERSE_SSH":
      return LoggedMigrationJob_ConnectivityType.REVERSE_SSH;
    case 3:
    case "VPC_PEERING":
      return LoggedMigrationJob_ConnectivityType.VPC_PEERING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedMigrationJob_ConnectivityType.UNRECOGNIZED;
  }
}

export function loggedMigrationJob_ConnectivityTypeToJSON(object: LoggedMigrationJob_ConnectivityType): string {
  switch (object) {
    case LoggedMigrationJob_ConnectivityType.CONNECTIVITY_TYPE_UNSPECIFIED:
      return "CONNECTIVITY_TYPE_UNSPECIFIED";
    case LoggedMigrationJob_ConnectivityType.STATIC_IP:
      return "STATIC_IP";
    case LoggedMigrationJob_ConnectivityType.REVERSE_SSH:
      return "REVERSE_SSH";
    case LoggedMigrationJob_ConnectivityType.VPC_PEERING:
      return "VPC_PEERING";
    case LoggedMigrationJob_ConnectivityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LoggedMigrationJob_LabelsEntry {
  key: string;
  value: string;
}

/** An MySQL database connection profile. */
export interface MySqlConnectionProfile {
  /** The database version. */
  version: MySqlConnectionProfile_Version;
  /** The Cloud SQL id for a Cloud SQL instance. */
  cloudSqlId: string;
}

/** The MySQL database version. */
export enum MySqlConnectionProfile_Version {
  /** VERSION_UNSPECIFIED - Unspecified version. */
  VERSION_UNSPECIFIED = 0,
  /** V5_5 - MySQL 5.5. */
  V5_5 = 1,
  /** V5_6 - MySQL 5.6. */
  V5_6 = 2,
  /** V5_7 - MySQL 5.7. */
  V5_7 = 3,
  /** V8_0 - MySQL 8.0. */
  V8_0 = 4,
  UNRECOGNIZED = -1,
}

export function mySqlConnectionProfile_VersionFromJSON(object: any): MySqlConnectionProfile_Version {
  switch (object) {
    case 0:
    case "VERSION_UNSPECIFIED":
      return MySqlConnectionProfile_Version.VERSION_UNSPECIFIED;
    case 1:
    case "V5_5":
      return MySqlConnectionProfile_Version.V5_5;
    case 2:
    case "V5_6":
      return MySqlConnectionProfile_Version.V5_6;
    case 3:
    case "V5_7":
      return MySqlConnectionProfile_Version.V5_7;
    case 4:
    case "V8_0":
      return MySqlConnectionProfile_Version.V8_0;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MySqlConnectionProfile_Version.UNRECOGNIZED;
  }
}

export function mySqlConnectionProfile_VersionToJSON(object: MySqlConnectionProfile_Version): string {
  switch (object) {
    case MySqlConnectionProfile_Version.VERSION_UNSPECIFIED:
      return "VERSION_UNSPECIFIED";
    case MySqlConnectionProfile_Version.V5_5:
      return "V5_5";
    case MySqlConnectionProfile_Version.V5_6:
      return "V5_6";
    case MySqlConnectionProfile_Version.V5_7:
      return "V5_7";
    case MySqlConnectionProfile_Version.V8_0:
      return "V8_0";
    case MySqlConnectionProfile_Version.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An PostgreSQL connection profile. */
export interface PostgreSqlConnectionProfile {
  /** The database version. */
  version: PostgreSqlConnectionProfile_Version;
  /** The Cloud SQL id for a Cloud SQL instance. */
  cloudSqlId: string;
}

/** The PostgreSQL database version. */
export enum PostgreSqlConnectionProfile_Version {
  /** VERSION_UNSPECIFIED - Unspecified version. */
  VERSION_UNSPECIFIED = 0,
  /** V9_6 - PostgreSQL 9.6. */
  V9_6 = 1,
  /** V11 - PostgreSQL 11. */
  V11 = 2,
  /** V10 - PostgreSQL 10. */
  V10 = 3,
  /** V12 - PostgreSQL 12. */
  V12 = 4,
  /** V13 - PostgreSQL 13. */
  V13 = 5,
  UNRECOGNIZED = -1,
}

export function postgreSqlConnectionProfile_VersionFromJSON(object: any): PostgreSqlConnectionProfile_Version {
  switch (object) {
    case 0:
    case "VERSION_UNSPECIFIED":
      return PostgreSqlConnectionProfile_Version.VERSION_UNSPECIFIED;
    case 1:
    case "V9_6":
      return PostgreSqlConnectionProfile_Version.V9_6;
    case 2:
    case "V11":
      return PostgreSqlConnectionProfile_Version.V11;
    case 3:
    case "V10":
      return PostgreSqlConnectionProfile_Version.V10;
    case 4:
    case "V12":
      return PostgreSqlConnectionProfile_Version.V12;
    case 5:
    case "V13":
      return PostgreSqlConnectionProfile_Version.V13;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostgreSqlConnectionProfile_Version.UNRECOGNIZED;
  }
}

export function postgreSqlConnectionProfile_VersionToJSON(object: PostgreSqlConnectionProfile_Version): string {
  switch (object) {
    case PostgreSqlConnectionProfile_Version.VERSION_UNSPECIFIED:
      return "VERSION_UNSPECIFIED";
    case PostgreSqlConnectionProfile_Version.V9_6:
      return "V9_6";
    case PostgreSqlConnectionProfile_Version.V11:
      return "V11";
    case PostgreSqlConnectionProfile_Version.V10:
      return "V10";
    case PostgreSqlConnectionProfile_Version.V12:
      return "V12";
    case PostgreSqlConnectionProfile_Version.V13:
      return "V13";
    case PostgreSqlConnectionProfile_Version.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A CloudSQL connection profile. */
export interface CloudSqlConnectionProfile {
  /** The Cloud SQL id. */
  cloudSqlId: string;
}

/** An Oracle connection profile. */
export interface OracleConnectionProfile {
  /** Required. Type of connectivity to source database. */
  connectivityType: OracleConnectionProfile_ConnectivityType;
}

/** Connectivity options used to establish a connection to the profile. */
export enum OracleConnectionProfile_ConnectivityType {
  /** CONNECTIVITY_TYPE_UNSPECIFIED - No data defined. */
  CONNECTIVITY_TYPE_UNSPECIFIED = 0,
  /** STATIC_SERVICE_IP - Static Service IP connectivity. */
  STATIC_SERVICE_IP = 1,
  /** FORWARD_SSH_TUNNEL - Forward SSH tunnel connectivity. */
  FORWARD_SSH_TUNNEL = 2,
  /** PRIVATE_CONNECTIVITY - Private connectivity. */
  PRIVATE_CONNECTIVITY = 3,
  UNRECOGNIZED = -1,
}

export function oracleConnectionProfile_ConnectivityTypeFromJSON(
  object: any,
): OracleConnectionProfile_ConnectivityType {
  switch (object) {
    case 0:
    case "CONNECTIVITY_TYPE_UNSPECIFIED":
      return OracleConnectionProfile_ConnectivityType.CONNECTIVITY_TYPE_UNSPECIFIED;
    case 1:
    case "STATIC_SERVICE_IP":
      return OracleConnectionProfile_ConnectivityType.STATIC_SERVICE_IP;
    case 2:
    case "FORWARD_SSH_TUNNEL":
      return OracleConnectionProfile_ConnectivityType.FORWARD_SSH_TUNNEL;
    case 3:
    case "PRIVATE_CONNECTIVITY":
      return OracleConnectionProfile_ConnectivityType.PRIVATE_CONNECTIVITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OracleConnectionProfile_ConnectivityType.UNRECOGNIZED;
  }
}

export function oracleConnectionProfile_ConnectivityTypeToJSON(
  object: OracleConnectionProfile_ConnectivityType,
): string {
  switch (object) {
    case OracleConnectionProfile_ConnectivityType.CONNECTIVITY_TYPE_UNSPECIFIED:
      return "CONNECTIVITY_TYPE_UNSPECIFIED";
    case OracleConnectionProfile_ConnectivityType.STATIC_SERVICE_IP:
      return "STATIC_SERVICE_IP";
    case OracleConnectionProfile_ConnectivityType.FORWARD_SSH_TUNNEL:
      return "FORWARD_SSH_TUNNEL";
    case OracleConnectionProfile_ConnectivityType.PRIVATE_CONNECTIVITY:
      return "PRIVATE_CONNECTIVITY";
    case OracleConnectionProfile_ConnectivityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An producer connection profile definition.
 * NEXT_TAG = 8.
 */
export interface LoggedConnectionProfile {
  /** The unique identifier for a connection profile. */
  name: string;
  /** Labels. */
  labels: { [key: string]: string };
  /** The current connection profile state. */
  state: LoggedConnectionProfile_State;
  /** The display name. */
  displayName: string;
  /** A MySQL database connection profile. */
  mysql?:
    | MySqlConnectionProfile
    | undefined;
  /** A PostgreSQL database connection profile. */
  postgresql?:
    | PostgreSqlConnectionProfile
    | undefined;
  /** A CloudSQL database connection profile. */
  cloudsql?:
    | CloudSqlConnectionProfile
    | undefined;
  /** An Oracle database connection profile. */
  oracle?:
    | OracleConnectionProfile
    | undefined;
  /** The error details in case of state FAILED. */
  error:
    | Status
    | undefined;
  /** The database provider. */
  provider: DatabaseProvider;
}

/** The connection profile states enum. */
export enum LoggedConnectionProfile_State {
  /** STATE_UNSPECIFIED - The state of the connection profile is unknown. */
  STATE_UNSPECIFIED = 0,
  /** DRAFT - The connection profile is in draft mode and fully editable. */
  DRAFT = 1,
  /** CREATING - The connection profile is being created. */
  CREATING = 2,
  /** READY - The connection profile is ready. */
  READY = 3,
  /** UPDATING - The connection profile is being updated. */
  UPDATING = 4,
  /** DELETING - The connection profile is being deleted. */
  DELETING = 5,
  /** DELETED - The connection profile has been deleted. */
  DELETED = 6,
  /** FAILED - The last action on the connection profile failed. */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function loggedConnectionProfile_StateFromJSON(object: any): LoggedConnectionProfile_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return LoggedConnectionProfile_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return LoggedConnectionProfile_State.DRAFT;
    case 2:
    case "CREATING":
      return LoggedConnectionProfile_State.CREATING;
    case 3:
    case "READY":
      return LoggedConnectionProfile_State.READY;
    case 4:
    case "UPDATING":
      return LoggedConnectionProfile_State.UPDATING;
    case 5:
    case "DELETING":
      return LoggedConnectionProfile_State.DELETING;
    case 6:
    case "DELETED":
      return LoggedConnectionProfile_State.DELETED;
    case 7:
    case "FAILED":
      return LoggedConnectionProfile_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedConnectionProfile_State.UNRECOGNIZED;
  }
}

export function loggedConnectionProfile_StateToJSON(object: LoggedConnectionProfile_State): string {
  switch (object) {
    case LoggedConnectionProfile_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case LoggedConnectionProfile_State.DRAFT:
      return "DRAFT";
    case LoggedConnectionProfile_State.CREATING:
      return "CREATING";
    case LoggedConnectionProfile_State.READY:
      return "READY";
    case LoggedConnectionProfile_State.UPDATING:
      return "UPDATING";
    case LoggedConnectionProfile_State.DELETING:
      return "DELETING";
    case LoggedConnectionProfile_State.DELETED:
      return "DELETED";
    case LoggedConnectionProfile_State.FAILED:
      return "FAILED";
    case LoggedConnectionProfile_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LoggedConnectionProfile_LabelsEntry {
  key: string;
  value: string;
}

/** Log definition for Migration Job event */
export interface MigrationJobEventLog {
  /** The migration job resource */
  migrationJob:
    | LoggedMigrationJob
    | undefined;
  /** Timestamp of the event */
  occurrenceTimestamp:
    | Date
    | undefined;
  /** Event code */
  code: number;
  /** Event message */
  textMessage: string;
  /** Original event code */
  originalCode?:
    | number
    | undefined;
  /** Original event message */
  originalMessage?: string | undefined;
}

/** Log definition for Connection Profile event */
export interface ConnectionProfileEventLog {
  /** The connection profilr resource */
  connectionProfile:
    | LoggedConnectionProfile
    | undefined;
  /** Timestamp of the event */
  occurrenceTimestamp:
    | Date
    | undefined;
  /** Event code */
  code: number;
  /** Event message */
  textMessage: string;
  /** Original event code */
  originalCode?:
    | number
    | undefined;
  /** Original event message */
  originalMessage?: string | undefined;
}

/**
 * The PrivateConnection resource is used to establish private connectivity
 * with the customer's network.
 */
export interface LoggedPrivateConnection {
  /** The resource's name. */
  name: string;
  /** Labels. */
  labels: { [key: string]: string };
  /** Display name. */
  displayName: string;
  /** The state of the Private Connection. */
  state: LoggedPrivateConnection_State;
  /** The error details in case of state FAILED. */
  error:
    | Status
    | undefined;
  /** VPC Peering Config. */
  vpcPeeringConfig: VpcPeeringConfig | undefined;
}

/** Private Connection state. */
export enum LoggedPrivateConnection_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The private connection is in creation state - creating resources. */
  CREATING = 1,
  /** CREATED - The private connection has been created with all of its resources. */
  CREATED = 2,
  /** FAILED - The private connection creation has failed. */
  FAILED = 3,
  /** DELETING - The private connection is being deleted. */
  DELETING = 4,
  /** FAILED_TO_DELETE - Delete request has failed, resource is in invalid state. */
  FAILED_TO_DELETE = 5,
  /** DELETED - The private connection has been deleted. */
  DELETED = 6,
  UNRECOGNIZED = -1,
}

export function loggedPrivateConnection_StateFromJSON(object: any): LoggedPrivateConnection_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return LoggedPrivateConnection_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return LoggedPrivateConnection_State.CREATING;
    case 2:
    case "CREATED":
      return LoggedPrivateConnection_State.CREATED;
    case 3:
    case "FAILED":
      return LoggedPrivateConnection_State.FAILED;
    case 4:
    case "DELETING":
      return LoggedPrivateConnection_State.DELETING;
    case 5:
    case "FAILED_TO_DELETE":
      return LoggedPrivateConnection_State.FAILED_TO_DELETE;
    case 6:
    case "DELETED":
      return LoggedPrivateConnection_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggedPrivateConnection_State.UNRECOGNIZED;
  }
}

export function loggedPrivateConnection_StateToJSON(object: LoggedPrivateConnection_State): string {
  switch (object) {
    case LoggedPrivateConnection_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case LoggedPrivateConnection_State.CREATING:
      return "CREATING";
    case LoggedPrivateConnection_State.CREATED:
      return "CREATED";
    case LoggedPrivateConnection_State.FAILED:
      return "FAILED";
    case LoggedPrivateConnection_State.DELETING:
      return "DELETING";
    case LoggedPrivateConnection_State.FAILED_TO_DELETE:
      return "FAILED_TO_DELETE";
    case LoggedPrivateConnection_State.DELETED:
      return "DELETED";
    case LoggedPrivateConnection_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LoggedPrivateConnection_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The VPC Peering configuration is used to create VPC peering between
 * the data plane and the consumer's VPC.
 */
export interface VpcPeeringConfig {
  /** Fully qualified name of the VPC DMS will peer to. */
  vpcName: string;
  /** The subnet that will be peered to. (CIDR of /29). */
  subnet: string;
}

/** Log definition for a Private Connection event. */
export interface PrivateConnectionEventLog {
  /** The private connection resource. */
  privateConnection:
    | LoggedPrivateConnection
    | undefined;
  /** Timestamp of the event. */
  occurrenceTimestamp:
    | Date
    | undefined;
  /** Event code. */
  code: number;
  /** Event message. */
  textMessage: string;
  /** Original event code. */
  originalCode?:
    | number
    | undefined;
  /** Original event message. */
  originalMessage?: string | undefined;
}

function createBaseDatabaseType(): DatabaseType {
  return { provider: 0, engine: 0 };
}

export const DatabaseType: MessageFns<DatabaseType> = {
  encode(message: DatabaseType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.engine !== 0) {
      writer.uint32(16).int32(message.engine);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseType {
    return {
      provider: isSet(object.provider) ? databaseProviderFromJSON(object.provider) : 0,
      engine: isSet(object.engine) ? databaseEngineFromJSON(object.engine) : 0,
    };
  },

  toJSON(message: DatabaseType): unknown {
    const obj: any = {};
    if (message.provider !== 0) {
      obj.provider = databaseProviderToJSON(message.provider);
    }
    if (message.engine !== 0) {
      obj.engine = databaseEngineToJSON(message.engine);
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseType>): DatabaseType {
    return DatabaseType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseType>): DatabaseType {
    const message = createBaseDatabaseType();
    message.provider = object.provider ?? 0;
    message.engine = object.engine ?? 0;
    return message;
  },
};

function createBaseLoggedMigrationJob(): LoggedMigrationJob {
  return {
    name: "",
    labels: {},
    displayName: "",
    state: 0,
    phase: 0,
    type: 0,
    dumpPath: "",
    source: "",
    destination: "",
    duration: undefined,
    connectivityType: 0,
    error: undefined,
    endTime: undefined,
    sourceDatabase: undefined,
    destinationDatabase: undefined,
  };
}

export const LoggedMigrationJob: MessageFns<LoggedMigrationJob> = {
  encode(message: LoggedMigrationJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LoggedMigrationJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.phase !== 0) {
      writer.uint32(40).int32(message.phase);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.dumpPath !== "") {
      writer.uint32(58).string(message.dumpPath);
    }
    if (message.source !== "") {
      writer.uint32(66).string(message.source);
    }
    if (message.destination !== "") {
      writer.uint32(74).string(message.destination);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(82).fork()).join();
    }
    if (message.connectivityType !== 0) {
      writer.uint32(88).int32(message.connectivityType);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(98).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(106).fork()).join();
    }
    if (message.sourceDatabase !== undefined) {
      DatabaseType.encode(message.sourceDatabase, writer.uint32(114).fork()).join();
    }
    if (message.destinationDatabase !== undefined) {
      DatabaseType.encode(message.destinationDatabase, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedMigrationJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedMigrationJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = LoggedMigrationJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dumpPath = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.source = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.connectivityType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.sourceDatabase = DatabaseType.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.destinationDatabase = DatabaseType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedMigrationJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? loggedMigrationJob_StateFromJSON(object.state) : 0,
      phase: isSet(object.phase) ? loggedMigrationJob_PhaseFromJSON(object.phase) : 0,
      type: isSet(object.type) ? loggedMigrationJob_TypeFromJSON(object.type) : 0,
      dumpPath: isSet(object.dumpPath) ? globalThis.String(object.dumpPath) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      connectivityType: isSet(object.connectivityType)
        ? loggedMigrationJob_ConnectivityTypeFromJSON(object.connectivityType)
        : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      sourceDatabase: isSet(object.sourceDatabase) ? DatabaseType.fromJSON(object.sourceDatabase) : undefined,
      destinationDatabase: isSet(object.destinationDatabase)
        ? DatabaseType.fromJSON(object.destinationDatabase)
        : undefined,
    };
  },

  toJSON(message: LoggedMigrationJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = loggedMigrationJob_StateToJSON(message.state);
    }
    if (message.phase !== 0) {
      obj.phase = loggedMigrationJob_PhaseToJSON(message.phase);
    }
    if (message.type !== 0) {
      obj.type = loggedMigrationJob_TypeToJSON(message.type);
    }
    if (message.dumpPath !== "") {
      obj.dumpPath = message.dumpPath;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.connectivityType !== 0) {
      obj.connectivityType = loggedMigrationJob_ConnectivityTypeToJSON(message.connectivityType);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.sourceDatabase !== undefined) {
      obj.sourceDatabase = DatabaseType.toJSON(message.sourceDatabase);
    }
    if (message.destinationDatabase !== undefined) {
      obj.destinationDatabase = DatabaseType.toJSON(message.destinationDatabase);
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedMigrationJob>): LoggedMigrationJob {
    return LoggedMigrationJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedMigrationJob>): LoggedMigrationJob {
    const message = createBaseLoggedMigrationJob();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.phase = object.phase ?? 0;
    message.type = object.type ?? 0;
    message.dumpPath = object.dumpPath ?? "";
    message.source = object.source ?? "";
    message.destination = object.destination ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.connectivityType = object.connectivityType ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.endTime = object.endTime ?? undefined;
    message.sourceDatabase = (object.sourceDatabase !== undefined && object.sourceDatabase !== null)
      ? DatabaseType.fromPartial(object.sourceDatabase)
      : undefined;
    message.destinationDatabase = (object.destinationDatabase !== undefined && object.destinationDatabase !== null)
      ? DatabaseType.fromPartial(object.destinationDatabase)
      : undefined;
    return message;
  },
};

function createBaseLoggedMigrationJob_LabelsEntry(): LoggedMigrationJob_LabelsEntry {
  return { key: "", value: "" };
}

export const LoggedMigrationJob_LabelsEntry: MessageFns<LoggedMigrationJob_LabelsEntry> = {
  encode(message: LoggedMigrationJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedMigrationJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedMigrationJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedMigrationJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LoggedMigrationJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedMigrationJob_LabelsEntry>): LoggedMigrationJob_LabelsEntry {
    return LoggedMigrationJob_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedMigrationJob_LabelsEntry>): LoggedMigrationJob_LabelsEntry {
    const message = createBaseLoggedMigrationJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMySqlConnectionProfile(): MySqlConnectionProfile {
  return { version: 0, cloudSqlId: "" };
}

export const MySqlConnectionProfile: MessageFns<MySqlConnectionProfile> = {
  encode(message: MySqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.cloudSqlId !== "") {
      writer.uint32(18).string(message.cloudSqlId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySqlConnectionProfile {
    return {
      version: isSet(object.version) ? mySqlConnectionProfile_VersionFromJSON(object.version) : 0,
      cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "",
    };
  },

  toJSON(message: MySqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = mySqlConnectionProfile_VersionToJSON(message.version);
    }
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    return obj;
  },

  create(base?: DeepPartial<MySqlConnectionProfile>): MySqlConnectionProfile {
    return MySqlConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MySqlConnectionProfile>): MySqlConnectionProfile {
    const message = createBaseMySqlConnectionProfile();
    message.version = object.version ?? 0;
    message.cloudSqlId = object.cloudSqlId ?? "";
    return message;
  },
};

function createBasePostgreSqlConnectionProfile(): PostgreSqlConnectionProfile {
  return { version: 0, cloudSqlId: "" };
}

export const PostgreSqlConnectionProfile: MessageFns<PostgreSqlConnectionProfile> = {
  encode(message: PostgreSqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.cloudSqlId !== "") {
      writer.uint32(18).string(message.cloudSqlId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgreSqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgreSqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostgreSqlConnectionProfile {
    return {
      version: isSet(object.version) ? postgreSqlConnectionProfile_VersionFromJSON(object.version) : 0,
      cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "",
    };
  },

  toJSON(message: PostgreSqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = postgreSqlConnectionProfile_VersionToJSON(message.version);
    }
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    return obj;
  },

  create(base?: DeepPartial<PostgreSqlConnectionProfile>): PostgreSqlConnectionProfile {
    return PostgreSqlConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostgreSqlConnectionProfile>): PostgreSqlConnectionProfile {
    const message = createBasePostgreSqlConnectionProfile();
    message.version = object.version ?? 0;
    message.cloudSqlId = object.cloudSqlId ?? "";
    return message;
  },
};

function createBaseCloudSqlConnectionProfile(): CloudSqlConnectionProfile {
  return { cloudSqlId: "" };
}

export const CloudSqlConnectionProfile: MessageFns<CloudSqlConnectionProfile> = {
  encode(message: CloudSqlConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudSqlId !== "") {
      writer.uint32(10).string(message.cloudSqlId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudSqlId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlConnectionProfile {
    return { cloudSqlId: isSet(object.cloudSqlId) ? globalThis.String(object.cloudSqlId) : "" };
  },

  toJSON(message: CloudSqlConnectionProfile): unknown {
    const obj: any = {};
    if (message.cloudSqlId !== "") {
      obj.cloudSqlId = message.cloudSqlId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlConnectionProfile>): CloudSqlConnectionProfile {
    return CloudSqlConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlConnectionProfile>): CloudSqlConnectionProfile {
    const message = createBaseCloudSqlConnectionProfile();
    message.cloudSqlId = object.cloudSqlId ?? "";
    return message;
  },
};

function createBaseOracleConnectionProfile(): OracleConnectionProfile {
  return { connectivityType: 0 };
}

export const OracleConnectionProfile: MessageFns<OracleConnectionProfile> = {
  encode(message: OracleConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectivityType !== 0) {
      writer.uint32(8).int32(message.connectivityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.connectivityType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleConnectionProfile {
    return {
      connectivityType: isSet(object.connectivityType)
        ? oracleConnectionProfile_ConnectivityTypeFromJSON(object.connectivityType)
        : 0,
    };
  },

  toJSON(message: OracleConnectionProfile): unknown {
    const obj: any = {};
    if (message.connectivityType !== 0) {
      obj.connectivityType = oracleConnectionProfile_ConnectivityTypeToJSON(message.connectivityType);
    }
    return obj;
  },

  create(base?: DeepPartial<OracleConnectionProfile>): OracleConnectionProfile {
    return OracleConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleConnectionProfile>): OracleConnectionProfile {
    const message = createBaseOracleConnectionProfile();
    message.connectivityType = object.connectivityType ?? 0;
    return message;
  },
};

function createBaseLoggedConnectionProfile(): LoggedConnectionProfile {
  return {
    name: "",
    labels: {},
    state: 0,
    displayName: "",
    mysql: undefined,
    postgresql: undefined,
    cloudsql: undefined,
    oracle: undefined,
    error: undefined,
    provider: 0,
  };
}

export const LoggedConnectionProfile: MessageFns<LoggedConnectionProfile> = {
  encode(message: LoggedConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LoggedConnectionProfile_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.mysql !== undefined) {
      MySqlConnectionProfile.encode(message.mysql, writer.uint32(802).fork()).join();
    }
    if (message.postgresql !== undefined) {
      PostgreSqlConnectionProfile.encode(message.postgresql, writer.uint32(810).fork()).join();
    }
    if (message.cloudsql !== undefined) {
      CloudSqlConnectionProfile.encode(message.cloudsql, writer.uint32(818).fork()).join();
    }
    if (message.oracle !== undefined) {
      OracleConnectionProfile.encode(message.oracle, writer.uint32(826).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.provider !== 0) {
      writer.uint32(48).int32(message.provider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = LoggedConnectionProfile_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.mysql = MySqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.postgresql = PostgreSqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.cloudsql = CloudSqlConnectionProfile.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.oracle = OracleConnectionProfile.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedConnectionProfile {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? loggedConnectionProfile_StateFromJSON(object.state) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      mysql: isSet(object.mysql) ? MySqlConnectionProfile.fromJSON(object.mysql) : undefined,
      postgresql: isSet(object.postgresql) ? PostgreSqlConnectionProfile.fromJSON(object.postgresql) : undefined,
      cloudsql: isSet(object.cloudsql) ? CloudSqlConnectionProfile.fromJSON(object.cloudsql) : undefined,
      oracle: isSet(object.oracle) ? OracleConnectionProfile.fromJSON(object.oracle) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      provider: isSet(object.provider) ? databaseProviderFromJSON(object.provider) : 0,
    };
  },

  toJSON(message: LoggedConnectionProfile): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.state !== 0) {
      obj.state = loggedConnectionProfile_StateToJSON(message.state);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.mysql !== undefined) {
      obj.mysql = MySqlConnectionProfile.toJSON(message.mysql);
    }
    if (message.postgresql !== undefined) {
      obj.postgresql = PostgreSqlConnectionProfile.toJSON(message.postgresql);
    }
    if (message.cloudsql !== undefined) {
      obj.cloudsql = CloudSqlConnectionProfile.toJSON(message.cloudsql);
    }
    if (message.oracle !== undefined) {
      obj.oracle = OracleConnectionProfile.toJSON(message.oracle);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.provider !== 0) {
      obj.provider = databaseProviderToJSON(message.provider);
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedConnectionProfile>): LoggedConnectionProfile {
    return LoggedConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedConnectionProfile>): LoggedConnectionProfile {
    const message = createBaseLoggedConnectionProfile();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.displayName = object.displayName ?? "";
    message.mysql = (object.mysql !== undefined && object.mysql !== null)
      ? MySqlConnectionProfile.fromPartial(object.mysql)
      : undefined;
    message.postgresql = (object.postgresql !== undefined && object.postgresql !== null)
      ? PostgreSqlConnectionProfile.fromPartial(object.postgresql)
      : undefined;
    message.cloudsql = (object.cloudsql !== undefined && object.cloudsql !== null)
      ? CloudSqlConnectionProfile.fromPartial(object.cloudsql)
      : undefined;
    message.oracle = (object.oracle !== undefined && object.oracle !== null)
      ? OracleConnectionProfile.fromPartial(object.oracle)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.provider = object.provider ?? 0;
    return message;
  },
};

function createBaseLoggedConnectionProfile_LabelsEntry(): LoggedConnectionProfile_LabelsEntry {
  return { key: "", value: "" };
}

export const LoggedConnectionProfile_LabelsEntry: MessageFns<LoggedConnectionProfile_LabelsEntry> = {
  encode(message: LoggedConnectionProfile_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedConnectionProfile_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedConnectionProfile_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedConnectionProfile_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LoggedConnectionProfile_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedConnectionProfile_LabelsEntry>): LoggedConnectionProfile_LabelsEntry {
    return LoggedConnectionProfile_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedConnectionProfile_LabelsEntry>): LoggedConnectionProfile_LabelsEntry {
    const message = createBaseLoggedConnectionProfile_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMigrationJobEventLog(): MigrationJobEventLog {
  return {
    migrationJob: undefined,
    occurrenceTimestamp: undefined,
    code: 0,
    textMessage: "",
    originalCode: undefined,
    originalMessage: undefined,
  };
}

export const MigrationJobEventLog: MessageFns<MigrationJobEventLog> = {
  encode(message: MigrationJobEventLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migrationJob !== undefined) {
      LoggedMigrationJob.encode(message.migrationJob, writer.uint32(10).fork()).join();
    }
    if (message.occurrenceTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.occurrenceTimestamp), writer.uint32(18).fork()).join();
    }
    if (message.code !== 0) {
      writer.uint32(24).int32(message.code);
    }
    if (message.textMessage !== "") {
      writer.uint32(34).string(message.textMessage);
    }
    if (message.originalCode !== undefined) {
      writer.uint32(1600).int32(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      writer.uint32(1610).string(message.originalMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationJobEventLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationJobEventLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migrationJob = LoggedMigrationJob.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrenceTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textMessage = reader.string();
          continue;
        case 200:
          if (tag !== 1600) {
            break;
          }

          message.originalCode = reader.int32();
          continue;
        case 201:
          if (tag !== 1610) {
            break;
          }

          message.originalMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationJobEventLog {
    return {
      migrationJob: isSet(object.migrationJob) ? LoggedMigrationJob.fromJSON(object.migrationJob) : undefined,
      occurrenceTimestamp: isSet(object.occurrenceTimestamp)
        ? fromJsonTimestamp(object.occurrenceTimestamp)
        : undefined,
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      textMessage: isSet(object.textMessage) ? globalThis.String(object.textMessage) : "",
      originalCode: isSet(object.originalCode) ? globalThis.Number(object.originalCode) : undefined,
      originalMessage: isSet(object.originalMessage) ? globalThis.String(object.originalMessage) : undefined,
    };
  },

  toJSON(message: MigrationJobEventLog): unknown {
    const obj: any = {};
    if (message.migrationJob !== undefined) {
      obj.migrationJob = LoggedMigrationJob.toJSON(message.migrationJob);
    }
    if (message.occurrenceTimestamp !== undefined) {
      obj.occurrenceTimestamp = message.occurrenceTimestamp.toISOString();
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.textMessage !== "") {
      obj.textMessage = message.textMessage;
    }
    if (message.originalCode !== undefined) {
      obj.originalCode = Math.round(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      obj.originalMessage = message.originalMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationJobEventLog>): MigrationJobEventLog {
    return MigrationJobEventLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationJobEventLog>): MigrationJobEventLog {
    const message = createBaseMigrationJobEventLog();
    message.migrationJob = (object.migrationJob !== undefined && object.migrationJob !== null)
      ? LoggedMigrationJob.fromPartial(object.migrationJob)
      : undefined;
    message.occurrenceTimestamp = object.occurrenceTimestamp ?? undefined;
    message.code = object.code ?? 0;
    message.textMessage = object.textMessage ?? "";
    message.originalCode = object.originalCode ?? undefined;
    message.originalMessage = object.originalMessage ?? undefined;
    return message;
  },
};

function createBaseConnectionProfileEventLog(): ConnectionProfileEventLog {
  return {
    connectionProfile: undefined,
    occurrenceTimestamp: undefined,
    code: 0,
    textMessage: "",
    originalCode: undefined,
    originalMessage: undefined,
  };
}

export const ConnectionProfileEventLog: MessageFns<ConnectionProfileEventLog> = {
  encode(message: ConnectionProfileEventLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionProfile !== undefined) {
      LoggedConnectionProfile.encode(message.connectionProfile, writer.uint32(10).fork()).join();
    }
    if (message.occurrenceTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.occurrenceTimestamp), writer.uint32(18).fork()).join();
    }
    if (message.code !== 0) {
      writer.uint32(24).int32(message.code);
    }
    if (message.textMessage !== "") {
      writer.uint32(34).string(message.textMessage);
    }
    if (message.originalCode !== undefined) {
      writer.uint32(1600).int32(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      writer.uint32(1610).string(message.originalMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfileEventLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfileEventLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectionProfile = LoggedConnectionProfile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrenceTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textMessage = reader.string();
          continue;
        case 200:
          if (tag !== 1600) {
            break;
          }

          message.originalCode = reader.int32();
          continue;
        case 201:
          if (tag !== 1610) {
            break;
          }

          message.originalMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfileEventLog {
    return {
      connectionProfile: isSet(object.connectionProfile)
        ? LoggedConnectionProfile.fromJSON(object.connectionProfile)
        : undefined,
      occurrenceTimestamp: isSet(object.occurrenceTimestamp)
        ? fromJsonTimestamp(object.occurrenceTimestamp)
        : undefined,
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      textMessage: isSet(object.textMessage) ? globalThis.String(object.textMessage) : "",
      originalCode: isSet(object.originalCode) ? globalThis.Number(object.originalCode) : undefined,
      originalMessage: isSet(object.originalMessage) ? globalThis.String(object.originalMessage) : undefined,
    };
  },

  toJSON(message: ConnectionProfileEventLog): unknown {
    const obj: any = {};
    if (message.connectionProfile !== undefined) {
      obj.connectionProfile = LoggedConnectionProfile.toJSON(message.connectionProfile);
    }
    if (message.occurrenceTimestamp !== undefined) {
      obj.occurrenceTimestamp = message.occurrenceTimestamp.toISOString();
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.textMessage !== "") {
      obj.textMessage = message.textMessage;
    }
    if (message.originalCode !== undefined) {
      obj.originalCode = Math.round(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      obj.originalMessage = message.originalMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionProfileEventLog>): ConnectionProfileEventLog {
    return ConnectionProfileEventLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionProfileEventLog>): ConnectionProfileEventLog {
    const message = createBaseConnectionProfileEventLog();
    message.connectionProfile = (object.connectionProfile !== undefined && object.connectionProfile !== null)
      ? LoggedConnectionProfile.fromPartial(object.connectionProfile)
      : undefined;
    message.occurrenceTimestamp = object.occurrenceTimestamp ?? undefined;
    message.code = object.code ?? 0;
    message.textMessage = object.textMessage ?? "";
    message.originalCode = object.originalCode ?? undefined;
    message.originalMessage = object.originalMessage ?? undefined;
    return message;
  },
};

function createBaseLoggedPrivateConnection(): LoggedPrivateConnection {
  return { name: "", labels: {}, displayName: "", state: 0, error: undefined, vpcPeeringConfig: undefined };
}

export const LoggedPrivateConnection: MessageFns<LoggedPrivateConnection> = {
  encode(message: LoggedPrivateConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      LoggedPrivateConnection_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.vpcPeeringConfig !== undefined) {
      VpcPeeringConfig.encode(message.vpcPeeringConfig, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedPrivateConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedPrivateConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = LoggedPrivateConnection_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.vpcPeeringConfig = VpcPeeringConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedPrivateConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? loggedPrivateConnection_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      vpcPeeringConfig: isSet(object.vpcPeeringConfig) ? VpcPeeringConfig.fromJSON(object.vpcPeeringConfig) : undefined,
    };
  },

  toJSON(message: LoggedPrivateConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = loggedPrivateConnection_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.vpcPeeringConfig !== undefined) {
      obj.vpcPeeringConfig = VpcPeeringConfig.toJSON(message.vpcPeeringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedPrivateConnection>): LoggedPrivateConnection {
    return LoggedPrivateConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedPrivateConnection>): LoggedPrivateConnection {
    const message = createBaseLoggedPrivateConnection();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.vpcPeeringConfig = (object.vpcPeeringConfig !== undefined && object.vpcPeeringConfig !== null)
      ? VpcPeeringConfig.fromPartial(object.vpcPeeringConfig)
      : undefined;
    return message;
  },
};

function createBaseLoggedPrivateConnection_LabelsEntry(): LoggedPrivateConnection_LabelsEntry {
  return { key: "", value: "" };
}

export const LoggedPrivateConnection_LabelsEntry: MessageFns<LoggedPrivateConnection_LabelsEntry> = {
  encode(message: LoggedPrivateConnection_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggedPrivateConnection_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggedPrivateConnection_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggedPrivateConnection_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LoggedPrivateConnection_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LoggedPrivateConnection_LabelsEntry>): LoggedPrivateConnection_LabelsEntry {
    return LoggedPrivateConnection_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggedPrivateConnection_LabelsEntry>): LoggedPrivateConnection_LabelsEntry {
    const message = createBaseLoggedPrivateConnection_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVpcPeeringConfig(): VpcPeeringConfig {
  return { vpcName: "", subnet: "" };
}

export const VpcPeeringConfig: MessageFns<VpcPeeringConfig> = {
  encode(message: VpcPeeringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vpcName !== "") {
      writer.uint32(10).string(message.vpcName);
    }
    if (message.subnet !== "") {
      writer.uint32(18).string(message.subnet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcPeeringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcPeeringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vpcName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcPeeringConfig {
    return {
      vpcName: isSet(object.vpcName) ? globalThis.String(object.vpcName) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
    };
  },

  toJSON(message: VpcPeeringConfig): unknown {
    const obj: any = {};
    if (message.vpcName !== "") {
      obj.vpcName = message.vpcName;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    return obj;
  },

  create(base?: DeepPartial<VpcPeeringConfig>): VpcPeeringConfig {
    return VpcPeeringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcPeeringConfig>): VpcPeeringConfig {
    const message = createBaseVpcPeeringConfig();
    message.vpcName = object.vpcName ?? "";
    message.subnet = object.subnet ?? "";
    return message;
  },
};

function createBasePrivateConnectionEventLog(): PrivateConnectionEventLog {
  return {
    privateConnection: undefined,
    occurrenceTimestamp: undefined,
    code: 0,
    textMessage: "",
    originalCode: undefined,
    originalMessage: undefined,
  };
}

export const PrivateConnectionEventLog: MessageFns<PrivateConnectionEventLog> = {
  encode(message: PrivateConnectionEventLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateConnection !== undefined) {
      LoggedPrivateConnection.encode(message.privateConnection, writer.uint32(10).fork()).join();
    }
    if (message.occurrenceTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.occurrenceTimestamp), writer.uint32(18).fork()).join();
    }
    if (message.code !== 0) {
      writer.uint32(24).int32(message.code);
    }
    if (message.textMessage !== "") {
      writer.uint32(34).string(message.textMessage);
    }
    if (message.originalCode !== undefined) {
      writer.uint32(1600).int32(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      writer.uint32(1610).string(message.originalMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateConnectionEventLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateConnectionEventLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateConnection = LoggedPrivateConnection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurrenceTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textMessage = reader.string();
          continue;
        case 200:
          if (tag !== 1600) {
            break;
          }

          message.originalCode = reader.int32();
          continue;
        case 201:
          if (tag !== 1610) {
            break;
          }

          message.originalMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateConnectionEventLog {
    return {
      privateConnection: isSet(object.privateConnection)
        ? LoggedPrivateConnection.fromJSON(object.privateConnection)
        : undefined,
      occurrenceTimestamp: isSet(object.occurrenceTimestamp)
        ? fromJsonTimestamp(object.occurrenceTimestamp)
        : undefined,
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      textMessage: isSet(object.textMessage) ? globalThis.String(object.textMessage) : "",
      originalCode: isSet(object.originalCode) ? globalThis.Number(object.originalCode) : undefined,
      originalMessage: isSet(object.originalMessage) ? globalThis.String(object.originalMessage) : undefined,
    };
  },

  toJSON(message: PrivateConnectionEventLog): unknown {
    const obj: any = {};
    if (message.privateConnection !== undefined) {
      obj.privateConnection = LoggedPrivateConnection.toJSON(message.privateConnection);
    }
    if (message.occurrenceTimestamp !== undefined) {
      obj.occurrenceTimestamp = message.occurrenceTimestamp.toISOString();
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.textMessage !== "") {
      obj.textMessage = message.textMessage;
    }
    if (message.originalCode !== undefined) {
      obj.originalCode = Math.round(message.originalCode);
    }
    if (message.originalMessage !== undefined) {
      obj.originalMessage = message.originalMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateConnectionEventLog>): PrivateConnectionEventLog {
    return PrivateConnectionEventLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateConnectionEventLog>): PrivateConnectionEventLog {
    const message = createBasePrivateConnectionEventLog();
    message.privateConnection = (object.privateConnection !== undefined && object.privateConnection !== null)
      ? LoggedPrivateConnection.fromPartial(object.privateConnection)
      : undefined;
    message.occurrenceTimestamp = object.occurrenceTimestamp ?? undefined;
    message.code = object.code ?? 0;
    message.textMessage = object.textMessage ?? "";
    message.originalCode = object.originalCode ?? undefined;
    message.originalMessage = object.originalMessage ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
