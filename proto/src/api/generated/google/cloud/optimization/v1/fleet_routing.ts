// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/optimization/v1/fleet_routing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { LatLng } from "../../../type/latlng.js";
import { InputConfig, OutputConfig } from "./async_model.js";

export const protobufPackage = "google.cloud.optimization.v1";

/**
 * Request to be given to a tour optimization solver which defines the
 * shipment model to solve as well as optimization parameters.
 */
export interface OptimizeToursRequest {
  /**
   * Required. Target project and location to make a call.
   *
   * Format: `projects/{project-id}/locations/{location-id}`.
   *
   * If no location is specified, a region will be chosen automatically.
   */
  parent: string;
  /**
   * If this timeout is set, the server returns a response before the timeout
   * period has elapsed or the server deadline for synchronous requests is
   * reached, whichever is sooner.
   *
   * For asynchronous requests, the server will generate a solution (if
   * possible) before the timeout has elapsed.
   */
  timeout:
    | Duration
    | undefined;
  /** Shipment model to solve. */
  model:
    | ShipmentModel
    | undefined;
  /** By default, the solving mode is `DEFAULT_SOLVE` (0). */
  solvingMode: OptimizeToursRequest_SolvingMode;
  /** Search mode used to solve the request. */
  searchMode: OptimizeToursRequest_SearchMode;
  /**
   * Guide the optimization algorithm in finding a first solution that is
   * similar to a previous solution.
   *
   * The model is constrained when the first solution is built.
   * Any shipments not performed on a route are implicitly skipped in the first
   * solution, but they may be performed in successive solutions.
   *
   * The solution must satisfy some basic validity assumptions:
   *
   *   * for all routes, `vehicle_index` must be in range and not be duplicated.
   *   * for all visits, `shipment_index` and `visit_request_index` must be
   *     in range.
   *   * a shipment may only be referenced on one route.
   *   * the pickup of a pickup-delivery shipment must be performed before
   *     the delivery.
   *   * no more than one pickup alternative or delivery alternative of
   *     a shipment may be performed.
   *   * for all routes, times are increasing (i.e., `vehicle_start_time
   *     <= visits[0].start_time <= visits[1].start_time ...
   *     <= vehicle_end_time`).
   *   * a shipment may only be performed on a vehicle that is allowed. A
   *     vehicle is allowed if
   *     [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices]
   *     is empty or its `vehicle_index` is included in
   *     [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices].
   *
   * If the injected solution is not feasible, a validation error is not
   * necessarily returned and an error indicating infeasibility may be returned
   * instead.
   */
  injectedFirstSolutionRoutes: ShipmentRoute[];
  /**
   * Constrain the optimization algorithm to find a final solution that is
   * similar to a previous solution. For example, this may be used to freeze
   * portions of routes which have already been completed or which are to be
   * completed but must not be modified.
   *
   * If the injected solution is not feasible, a validation error is not
   * necessarily returned and an error indicating infeasibility may be returned
   * instead.
   */
  injectedSolutionConstraint:
    | InjectedSolutionConstraint
    | undefined;
  /**
   * If non-empty, the given routes will be refreshed, without modifying their
   * underlying sequence of visits or travel times: only other details will be
   * updated. This does not solve the model.
   *
   * As of 2020/11, this only populates the polylines of non-empty routes and
   * requires that `populate_polylines` is true.
   *
   * The `route_polyline` fields of the passed-in routes may be inconsistent
   * with route `transitions`.
   *
   * This field must not be used together with `injected_first_solution_routes`
   * or `injected_solution_constraint`.
   *
   * `Shipment.ignore` and `Vehicle.ignore` have no effect on the behavior.
   * Polylines are still populated between all visits in all non-empty routes
   * regardless of whether the related shipments or vehicles are ignored.
   */
  refreshDetailsRoutes: ShipmentRoute[];
  /**
   * If true:
   *
   *   * uses
   *   [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label]
   *   instead of `vehicle_index` to
   *     match routes in an injected solution with vehicles in the request;
   *     reuses the mapping of original
   *     [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index]
   *     to new
   *     [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index]
   *     to update
   *     [ConstraintRelaxation.vehicle_indices][google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.vehicle_indices]
   *     if non-empty, but the mapping must be unambiguous (i.e., multiple
   *     `ShipmentRoute`s must not share the same original `vehicle_index`).
   *   * uses
   *   [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label]
   *   instead of `shipment_index`
   *     to match visits in an injected solution with shipments in the request;
   *   * uses
   *   [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label]
   *   instead of
   *   [SkippedShipment.index][google.cloud.optimization.v1.SkippedShipment.index]
   *   to
   *     match skipped shipments in the injected solution with request
   *     shipments.
   *
   * This interpretation applies to the `injected_first_solution_routes`,
   * `injected_solution_constraint`, and `refresh_details_routes` fields.
   * It can be used when shipment or vehicle indices in the request have
   * changed since the solution was created, perhaps because shipments or
   * vehicles have been removed from or added to the request.
   *
   * If true, labels in the following categories must appear at most once in
   * their category:
   *
   *   * [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] in the
   *   request;
   *   * [Shipment.label][google.cloud.optimization.v1.Shipment.label] in the
   *   request;
   *   * [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label] in the injected solution;
   *   * [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label] and [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label] in
   *     the injected solution (except pickup/delivery visit pairs, whose
   *     `shipment_label` must appear twice).
   *
   * If a `vehicle_label` in the injected solution does not correspond to a
   * request vehicle, the corresponding route is removed from the solution
   * along with its visits. If a `shipment_label` in the injected solution does
   * not correspond to a request shipment, the corresponding visit is removed
   * from the solution. If a
   * [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label]
   * in the injected solution does not correspond to a request shipment, the
   * `SkippedShipment` is removed from the solution.
   *
   * Removing route visits or entire routes from an injected solution may
   * have an effect on the implied constraints, which may lead to change in
   * solution, validation errors, or infeasibility.
   *
   * NOTE: The caller must ensure that each
   * [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] (resp.
   * [Shipment.label][google.cloud.optimization.v1.Shipment.label]) uniquely
   * identifies a vehicle (resp. shipment) entity used across the two relevant
   * requests: the past request that produced the `OptimizeToursResponse` used
   * in the injected solution and the current request that includes the injected
   * solution. The uniqueness checks described above are not enough to guarantee
   * this requirement.
   */
  interpretInjectedSolutionsUsingLabels: boolean;
  /**
   * Consider traffic estimation in calculating `ShipmentRoute` fields
   * [Transition.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration],
   * [Visit.start_time][google.cloud.optimization.v1.ShipmentRoute.Visit.start_time],
   * and `vehicle_end_time`; in setting the
   * [ShipmentRoute.has_traffic_infeasibilities][google.cloud.optimization.v1.ShipmentRoute.has_traffic_infeasibilities]
   * field, and in calculating the
   * [OptimizeToursResponse.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.total_cost]
   * field.
   */
  considerRoadTraffic: boolean;
  /** If true, polylines will be populated in response `ShipmentRoute`s. */
  populatePolylines: boolean;
  /**
   * If true, polylines will be populated in response
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions].
   * Note that in this case, the polylines will also be populated in the
   * deprecated `travel_steps`.
   */
  populateTransitionPolylines: boolean;
  /**
   * If this is set, then the request can have a deadline
   * (see https://grpc.io/blog/deadlines) of up to 60 minutes.
   * Otherwise, the maximum deadline is only 30 minutes.
   * Note that long-lived requests have a significantly larger (but still small)
   * risk of interruption.
   */
  allowLargeDeadlineDespiteInterruptionRisk: boolean;
  /**
   * If true, travel distances will be computed using geodesic distances instead
   * of Google Maps distances, and travel times will be computed using geodesic
   * distances with a speed defined by `geodesic_meters_per_second`.
   */
  useGeodesicDistances: boolean;
  /**
   * When `use_geodesic_distances` is true, this field must be set and defines
   * the speed applied to compute travel times. Its value must be at least 1.0
   * meters/seconds.
   */
  geodesicMetersPerSecond?:
    | number
    | undefined;
  /**
   * Truncates the number of validation errors returned. These errors are
   * typically attached to an INVALID_ARGUMENT error payload as a BadRequest
   * error detail (https://cloud.google.com/apis/design/errors#error_details),
   * unless solving_mode=VALIDATE_ONLY: see the
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * field.
   * This defaults to 100 and is capped at 10,000.
   */
  maxValidationErrors?:
    | number
    | undefined;
  /**
   * Label that may be used to identify this request, reported back in the
   * [OptimizeToursResponse.request_label][google.cloud.optimization.v1.OptimizeToursResponse.request_label].
   */
  label: string;
  /**
   * Deprecated: Use
   * [OptimizeToursRequest.populate_transition_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines]
   * instead. If true, polylines will be populated in response
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions].
   * Note that in this case, the polylines will also be populated in the
   * deprecated `travel_steps`.
   *
   * @deprecated
   */
  populateTravelStepPolylines: boolean;
}

/**
 * Defines how the solver should handle the request. In all modes but
 * `VALIDATE_ONLY`, if the request is invalid, you will receive an
 * `INVALID_REQUEST` error. See
 * [max_validation_errors][google.cloud.optimization.v1.OptimizeToursRequest.max_validation_errors]
 * to cap the number of errors returned.
 */
export enum OptimizeToursRequest_SolvingMode {
  /** DEFAULT_SOLVE - Solve the model. */
  DEFAULT_SOLVE = 0,
  /**
   * VALIDATE_ONLY - Only validates the model without solving it: populates as many
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * as possible.
   */
  VALIDATE_ONLY = 1,
  /**
   * DETECT_SOME_INFEASIBLE_SHIPMENTS - Only populates
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * or
   * [OptimizeToursResponse.skipped_shipments][google.cloud.optimization.v1.OptimizeToursResponse.skipped_shipments],
   * and doesn't actually solve the rest of the request (`status` and `routes`
   * are unset in the response).
   * If infeasibilities in `injected_solution_constraint` routes are detected
   * they are populated in the
   * [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors]
   * field and
   * [OptimizeToursResponse.skipped_shipments][google.cloud.optimization.v1.OptimizeToursResponse.skipped_shipments]
   * is left empty.
   *
   * *IMPORTANT*: not all infeasible shipments are returned here, but only the
   * ones that are detected as infeasible during preprocessing.
   */
  DETECT_SOME_INFEASIBLE_SHIPMENTS = 2,
  UNRECOGNIZED = -1,
}

export function optimizeToursRequest_SolvingModeFromJSON(object: any): OptimizeToursRequest_SolvingMode {
  switch (object) {
    case 0:
    case "DEFAULT_SOLVE":
      return OptimizeToursRequest_SolvingMode.DEFAULT_SOLVE;
    case 1:
    case "VALIDATE_ONLY":
      return OptimizeToursRequest_SolvingMode.VALIDATE_ONLY;
    case 2:
    case "DETECT_SOME_INFEASIBLE_SHIPMENTS":
      return OptimizeToursRequest_SolvingMode.DETECT_SOME_INFEASIBLE_SHIPMENTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OptimizeToursRequest_SolvingMode.UNRECOGNIZED;
  }
}

export function optimizeToursRequest_SolvingModeToJSON(object: OptimizeToursRequest_SolvingMode): string {
  switch (object) {
    case OptimizeToursRequest_SolvingMode.DEFAULT_SOLVE:
      return "DEFAULT_SOLVE";
    case OptimizeToursRequest_SolvingMode.VALIDATE_ONLY:
      return "VALIDATE_ONLY";
    case OptimizeToursRequest_SolvingMode.DETECT_SOME_INFEASIBLE_SHIPMENTS:
      return "DETECT_SOME_INFEASIBLE_SHIPMENTS";
    case OptimizeToursRequest_SolvingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Mode defining the behavior of the search, trading off latency versus
 * solution quality. In all modes, the global request deadline is enforced.
 */
export enum OptimizeToursRequest_SearchMode {
  /** SEARCH_MODE_UNSPECIFIED - Unspecified search mode, equivalent to `RETURN_FAST`. */
  SEARCH_MODE_UNSPECIFIED = 0,
  /** RETURN_FAST - Stop the search after finding the first good solution. */
  RETURN_FAST = 1,
  /** CONSUME_ALL_AVAILABLE_TIME - Spend all the available time to search for better solutions. */
  CONSUME_ALL_AVAILABLE_TIME = 2,
  UNRECOGNIZED = -1,
}

export function optimizeToursRequest_SearchModeFromJSON(object: any): OptimizeToursRequest_SearchMode {
  switch (object) {
    case 0:
    case "SEARCH_MODE_UNSPECIFIED":
      return OptimizeToursRequest_SearchMode.SEARCH_MODE_UNSPECIFIED;
    case 1:
    case "RETURN_FAST":
      return OptimizeToursRequest_SearchMode.RETURN_FAST;
    case 2:
    case "CONSUME_ALL_AVAILABLE_TIME":
      return OptimizeToursRequest_SearchMode.CONSUME_ALL_AVAILABLE_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OptimizeToursRequest_SearchMode.UNRECOGNIZED;
  }
}

export function optimizeToursRequest_SearchModeToJSON(object: OptimizeToursRequest_SearchMode): string {
  switch (object) {
    case OptimizeToursRequest_SearchMode.SEARCH_MODE_UNSPECIFIED:
      return "SEARCH_MODE_UNSPECIFIED";
    case OptimizeToursRequest_SearchMode.RETURN_FAST:
      return "RETURN_FAST";
    case OptimizeToursRequest_SearchMode.CONSUME_ALL_AVAILABLE_TIME:
      return "CONSUME_ALL_AVAILABLE_TIME";
    case OptimizeToursRequest_SearchMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Response after solving a tour optimization problem containing the routes
 * followed by each vehicle, the shipments which have been skipped and the
 * overall cost of the solution.
 */
export interface OptimizeToursResponse {
  /**
   * Routes computed for each vehicle; the i-th route corresponds to the i-th
   * vehicle in the model.
   */
  routes: ShipmentRoute[];
  /**
   * Copy of the
   * [OptimizeToursRequest.label][google.cloud.optimization.v1.OptimizeToursRequest.label],
   * if a label was specified in the request.
   */
  requestLabel: string;
  /** The list of all shipments skipped. */
  skippedShipments: SkippedShipment[];
  /**
   * List of all the validation errors that we were able to detect
   * independently. See the "MULTIPLE ERRORS" explanation for the
   * [OptimizeToursValidationError][google.cloud.optimization.v1.OptimizeToursValidationError]
   * message.
   */
  validationErrors: OptimizeToursValidationError[];
  /** Duration, distance and usage metrics for this solution. */
  metrics:
    | OptimizeToursResponse_Metrics
    | undefined;
  /**
   * Deprecated: Use
   * [Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost]
   * instead. Total cost of the solution. This takes into account all costs:
   * costs per per hour and travel hour, fixed vehicle costs, unperformed
   * shipment penalty costs, global duration cost, etc.
   *
   * @deprecated
   */
  totalCost: number;
}

/** Overall metrics, aggregated over all routes. */
export interface OptimizeToursResponse_Metrics {
  /**
   * Aggregated over the routes. Each metric is the sum (or max, for loads)
   * over all
   * [ShipmentRoute.metrics][google.cloud.optimization.v1.ShipmentRoute.metrics]
   * fields of the same name.
   */
  aggregatedRouteMetrics:
    | AggregatedMetrics
    | undefined;
  /** Number of mandatory shipments skipped. */
  skippedMandatoryShipmentCount: number;
  /**
   * Number of vehicles used. Note: if a vehicle route is empty and
   * [Vehicle.used_if_route_is_empty][google.cloud.optimization.v1.Vehicle.used_if_route_is_empty]
   * is true, the vehicle is considered used.
   */
  usedVehicleCount: number;
  /**
   * The earliest start time for a used vehicle, computed as the minimum over
   * all used vehicles of
   * [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time].
   */
  earliestVehicleStartTime:
    | Date
    | undefined;
  /**
   * The latest end time for a used vehicle, computed as the maximum over all
   * used vehicles of
   * [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time].
   */
  latestVehicleEndTime:
    | Date
    | undefined;
  /**
   * Cost of the solution, broken down by cost-related request fields.
   * The keys are proto paths, relative to the input OptimizeToursRequest,
   * e.g. "model.shipments.pickups.cost", and the values are the total cost
   * generated by the corresponding cost field, aggregated over the whole
   * solution. In other words, costs["model.shipments.pickups.cost"] is the
   * sum of all pickup costs over the solution. All costs defined in the model
   * are reported in detail here with the exception of costs related to
   * TransitionAttributes that are only reported in an aggregated way as of
   * 2022/01.
   */
  costs: { [key: string]: number };
  /** Total cost of the solution. The sum of all values in the costs map. */
  totalCost: number;
}

export interface OptimizeToursResponse_Metrics_CostsEntry {
  key: string;
  value: number;
}

/**
 * Request to batch optimize tours as an asynchronous operation.
 * Each input file should contain one `OptimizeToursRequest`, and each output
 * file will contain one `OptimizeToursResponse`. The request contains
 * information to read/write and parse the files. All the input and output files
 * should be under the same project.
 */
export interface BatchOptimizeToursRequest {
  /**
   * Required. Target project and location to make a call.
   *
   * Format: `projects/{project-id}/locations/{location-id}`.
   *
   * If no location is specified, a region will be chosen automatically.
   */
  parent: string;
  /**
   * Required. Input/Output information each purchase model, such as file paths
   * and data formats.
   */
  modelConfigs: BatchOptimizeToursRequest_AsyncModelConfig[];
}

/** Information for solving one optimization model asynchronously. */
export interface BatchOptimizeToursRequest_AsyncModelConfig {
  /**
   * User defined model name, can be used as alias by users to keep track of
   * models.
   */
  displayName: string;
  /** Required. Information about the input model. */
  inputConfig:
    | InputConfig
    | undefined;
  /** Required. The desired output location information. */
  outputConfig:
    | OutputConfig
    | undefined;
  /**
   * If this is set, the model will be solved in the checkpoint mode. In this
   * mode, the input model can have a deadline longer than 30 mins without the
   * risk of interruption. The model will be solved in multiple short-running
   * stages. Each stage generates an intermediate checkpoint
   * and stores it in the user's Cloud Storage buckets. The checkpoint
   * mode should be preferred over
   * allow_large_deadline_despite_interruption_risk since it prevents the risk
   * of interruption.
   */
  enableCheckpoints: boolean;
}

/**
 * Response to a `BatchOptimizeToursRequest`. This is returned in
 * the LRO Operation after the operation is complete.
 */
export interface BatchOptimizeToursResponse {
}

/**
 * A shipment model contains a set of shipments which must be performed by a
 * set of vehicles, while minimizing the overall cost, which is the sum of:
 *
 * * the cost of routing the vehicles (sum of cost per total time, cost per
 *   travel time, and fixed cost over all vehicles).
 * * the unperformed shipment penalties.
 * * the cost of the global duration of the shipments
 */
export interface ShipmentModel {
  /** Set of shipments which must be performed in the model. */
  shipments: Shipment[];
  /** Set of vehicles which can be used to perform visits. */
  vehicles: Vehicle[];
  /**
   * Constrains the maximum number of active vehicles. A vehicle is active if
   * its route performs at least one shipment. This can be used to limit the
   * number of routes in the case where there are fewer drivers than
   * vehicles and that the fleet of vehicles is heterogeneous. The optimization
   * will then select the best subset of vehicles to use.
   * Must be strictly positive.
   */
  maxActiveVehicles?:
    | number
    | undefined;
  /**
   * Global start and end time of the model: no times outside of this range
   * can be considered valid.
   *
   * The model's time span must be less than a year, i.e. the `global_end_time`
   * and the `global_start_time` must be within 31536000 seconds of each other.
   *
   * When using `cost_per_*hour` fields, you might want to set this window to a
   * smaller interval to increase performance (eg. if you model a single day,
   * you should set the global time limits to that day).
   * If unset, 00:00:00 UTC, January 1, 1970 (i.e. seconds: 0, nanos: 0) is used
   * as default.
   */
  globalStartTime:
    | Date
    | undefined;
  /**
   * If unset, 00:00:00 UTC, January 1, 1971 (i.e. seconds: 31536000, nanos: 0)
   * is used as default.
   */
  globalEndTime:
    | Date
    | undefined;
  /**
   * The "global duration" of the overall plan is the difference between the
   * earliest effective start time and the latest effective end time of
   * all vehicles. Users can assign a cost per hour to that quantity to try
   * and optimize for earliest job completion, for example. This cost must be in
   * the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   */
  globalDurationCostPerHour: number;
  /**
   * Specifies duration and distance matrices used in the model. If this field
   * is empty, Google Maps or geodesic distances will be used instead, depending
   * on the value of the `use_geodesic_distances` field. If it is not empty,
   * `use_geodesic_distances` cannot be true and neither
   * `duration_distance_matrix_src_tags` nor `duration_distance_matrix_dst_tags`
   * can be empty.
   *
   * Usage examples:
   *
   * * There are two locations: locA and locB.
   * * 1 vehicle starting its route at locA and ending it at locA.
   * * 1 pickup visit request at locB.
   *
   * ```
   * model {
   *   vehicles { start_tags: "locA"  end_tags: "locA" }
   *   shipments { pickups { tags: "locB" } }
   *   duration_distance_matrix_src_tags: "locA"
   *   duration_distance_matrix_src_tags: "locB"
   *   duration_distance_matrix_dst_tags: "locA"
   *   duration_distance_matrix_dst_tags: "locB"
   *   duration_distance_matrices {
   *     rows {  # from: locA
   *       durations { seconds: 0 }   meters: 0    # to: locA
   *       durations { seconds: 100 } meters: 1000 # to: locB
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 102 } meters: 990 # to: locA
   *       durations { seconds: 0 }   meters: 0   # to: locB
   *     }
   *   }
   * }
   * ```
   *
   * * There are three locations: locA, locB and locC.
   * * 1 vehicle starting its route at locA and ending it at locB, using
   *   matrix "fast".
   * * 1 vehicle starting its route at locB and ending it at locB, using
   *   matrix "slow".
   * * 1 vehicle starting its route at locB and ending it at locB, using
   *   matrix "fast".
   * * 1 pickup visit request at locC.
   *
   * ```
   * model {
   *   vehicles { start_tags: "locA" end_tags: "locB" start_tags: "fast" }
   *   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "slow" }
   *   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "fast" }
   *   shipments { pickups { tags: "locC" } }
   *   duration_distance_matrix_src_tags: "locA"
   *   duration_distance_matrix_src_tags: "locB"
   *   duration_distance_matrix_src_tags: "locC"
   *   duration_distance_matrix_dst_tags: "locB"
   *   duration_distance_matrix_dst_tags: "locC"
   *   duration_distance_matrices {
   *     vehicle_start_tag: "fast"
   *     rows {  # from: locA
   *       durations { seconds: 1000 } meters: 2000 # to: locB
   *       durations { seconds: 600 }  meters: 1000 # to: locC
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 0 }   meters: 0    # to: locB
   *       durations { seconds: 700 } meters: 1200 # to: locC
   *     }
   *     rows {  # from: locC
   *       durations { seconds: 702 } meters: 1190 # to: locB
   *       durations { seconds: 0 }   meters: 0    # to: locC
   *     }
   *   }
   *   duration_distance_matrices {
   *     vehicle_start_tag: "slow"
   *     rows {  # from: locA
   *       durations { seconds: 1800 } meters: 2001 # to: locB
   *       durations { seconds: 900 }  meters: 1002 # to: locC
   *     }
   *     rows {  # from: locB
   *       durations { seconds: 0 }    meters: 0    # to: locB
   *       durations { seconds: 1000 } meters: 1202 # to: locC
   *     }
   *     rows {  # from: locC
   *       durations { seconds: 1001 } meters: 1195 # to: locB
   *       durations { seconds: 0 }    meters: 0    # to: locC
   *     }
   *   }
   * }
   * ```
   */
  durationDistanceMatrices: ShipmentModel_DurationDistanceMatrix[];
  /**
   * Tags defining the sources of the duration and distance matrices;
   * `duration_distance_matrices(i).rows(j)` defines durations and distances
   * from visits with tag `duration_distance_matrix_src_tags(j)` to other visits
   * in matrix i.
   *
   * Tags correspond to
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags].
   * A given `VisitRequest` or `Vehicle` must match exactly one tag in this
   * field. Note that a `Vehicle`'s source, destination and matrix tags may be
   * the same; similarly a `VisitRequest`'s source and destination tags may be
   * the same. All tags must be different and cannot be empty strings. If this
   * field is not empty, then `duration_distance_matrices` must not be empty.
   */
  durationDistanceMatrixSrcTags: string[];
  /**
   * Tags defining the destinations of the duration and distance matrices;
   * `duration_distance_matrices(i).rows(j).durations(k)` (resp.
   * `duration_distance_matrices(i).rows(j).meters(k))` defines the duration
   * (resp. the distance) of the travel from visits with tag
   * `duration_distance_matrix_src_tags(j)` to visits with tag
   * `duration_distance_matrix_dst_tags(k)` in matrix i.
   *
   * Tags correspond to
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags].
   * A given `VisitRequest` or `Vehicle` must match exactly one tag in this
   * field. Note that a `Vehicle`'s source, destination and matrix tags may be
   * the same; similarly a `VisitRequest`'s source and destination tags may be
   * the same. All tags must be different and cannot be empty strings. If this
   * field is not empty, then `duration_distance_matrices` must not be empty.
   */
  durationDistanceMatrixDstTags: string[];
  /** Transition attributes added to the model. */
  transitionAttributes: TransitionAttributes[];
  /** Sets of incompatible shipment_types (see `ShipmentTypeIncompatibility`). */
  shipmentTypeIncompatibilities: ShipmentTypeIncompatibility[];
  /** Sets of `shipment_type` requirements (see `ShipmentTypeRequirement`). */
  shipmentTypeRequirements: ShipmentTypeRequirement[];
  /** Set of precedence rules which must be enforced in the model. */
  precedenceRules: ShipmentModel_PrecedenceRule[];
  /**
   * Deprecated: No longer used.
   * Set of break rules used in the model.
   * Each vehicle specifies the `BreakRule` that applies to it via the
   * [Vehicle.break_rule_indices][google.cloud.optimization.v1.Vehicle.break_rule_indices]
   * field (which must be a singleton).
   *
   * @deprecated
   */
  breakRules: ShipmentModel_BreakRule[];
}

/**
 * Specifies a duration and distance matrix from visit and vehicle start
 * locations to visit and vehicle end locations.
 */
export interface ShipmentModel_DurationDistanceMatrix {
  /**
   * Specifies the rows of the duration and distance matrix. It must have as
   * many elements as
   * [ShipmentModel.duration_distance_matrix_src_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_src_tags].
   */
  rows: ShipmentModel_DurationDistanceMatrix_Row[];
  /**
   * Tag defining to which vehicles this duration and distance matrix applies.
   * If empty, this applies to all vehicles, and there can only be a single
   * matrix.
   *
   * Each vehicle start must match exactly one matrix, i.e. exactly one of
   * their `start_tags` field must match the `vehicle_start_tag` of a matrix
   * (and of that matrix only).
   *
   * All matrices must have a different `vehicle_start_tag`.
   */
  vehicleStartTag: string;
}

/** Specifies a row of the duration and distance matrix. */
export interface ShipmentModel_DurationDistanceMatrix_Row {
  /**
   * Duration values for a given row. It must have as many elements as
   * [ShipmentModel.duration_distance_matrix_dst_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_dst_tags].
   */
  durations: Duration[];
  /**
   * Distance values for a given row. If no costs or constraints refer to
   * distances in the model, this can be left empty; otherwise it must have
   * as many elements as `durations`.
   */
  meters: number[];
}

/**
 * A precedence rule between two events (each event is the pickup or the
 * delivery of a shipment): the "second" event has to start at least
 * `offset_duration` after "first" has started.
 *
 * Several precedences can refer to the same (or related) events, e.g.,
 * "pickup of B happens after delivery of A" and "pickup of C happens after
 * pickup of B".
 *
 * Furthermore, precedences only apply when both shipments are performed and
 * are otherwise ignored.
 */
export interface ShipmentModel_PrecedenceRule {
  /** Shipment index of the "first" event. This field must be specified. */
  firstIndex?:
    | number
    | undefined;
  /** Indicates if the "first" event is a delivery. */
  firstIsDelivery: boolean;
  /** Shipment index of the "second" event. This field must be specified. */
  secondIndex?:
    | number
    | undefined;
  /** Indicates if the "second" event is a delivery. */
  secondIsDelivery: boolean;
  /** The offset between the "first" and "second" event. It can be negative. */
  offsetDuration: Duration | undefined;
}

/**
 * Deprecated: Use top level
 * [BreakRule][google.cloud.optimization.v1.ShipmentModel.BreakRule] instead.
 * Rules to generate time breaks for a vehicle (e.g. lunch
 * breaks). A break is a contiguous period of time during which the vehicle
 * remains idle at its current position and cannot perform any visit. A break
 * may occur:
 *
 * * during the travel between two visits (which includes the time right
 *   before or right after a visit, but not in the middle of a visit), in
 *   which case it extends the corresponding transit time between the visits
 * * before the vehicle start (the vehicle may not start in the middle of
 *   a break), in which case it does not affect the vehicle start time.
 * * after the vehicle end (ditto, with the vehicle end time).
 *
 * @deprecated
 */
export interface ShipmentModel_BreakRule {
  /** Sequence of breaks. See the `BreakRequest` message. */
  breakRequests: ShipmentModel_BreakRule_BreakRequest[];
  /**
   * Several `FrequencyConstraint` may apply. They must all be satisfied by
   * the `BreakRequest`s of this `BreakRule`. See `FrequencyConstraint`.
   */
  frequencyConstraints: ShipmentModel_BreakRule_FrequencyConstraint[];
}

/**
 * The sequence of breaks (i.e. their number and order) that apply to each
 * vehicle must be known beforehand. The repeated `BreakRequest`s define
 * that sequence, in the order in which they must occur. Their time windows
 * (`earliest_start_time` / `latest_start_time`) may overlap, but they must
 * be compatible with the order (this is checked).
 */
export interface ShipmentModel_BreakRule_BreakRequest {
  /** Required. Lower bound (inclusive) on the start of the break. */
  earliestStartTime:
    | Date
    | undefined;
  /** Required. Upper bound (inclusive) on the start of the break. */
  latestStartTime:
    | Date
    | undefined;
  /** Required. Minimum duration of the break. Must be positive. */
  minDuration: Duration | undefined;
}

/**
 * One may further constrain the frequency and duration of the breaks
 * specified above, by enforcing a minimum break frequency, such as
 * "There must be a break of at least 1 hour every 12 hours". Assuming that
 * this can be interpreted as "Within any sliding time window of 12h, there
 * must be at least one break of at least one hour", that example would
 * translate to the following `FrequencyConstraint`:
 * ```
 * {
 *    min_break_duration { seconds: 3600 }         # 1 hour.
 *    max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).
 * }
 * ```
 *
 * The timing and duration of the breaks in the solution will respect all
 * such constraints, in addition to the time windows and minimum durations
 * already specified in the `BreakRequest`.
 *
 * A `FrequencyConstraint` may in practice apply to non-consecutive breaks.
 * For example, the following schedule honors the "1h every 12h" example:
 * ```
 *   04:00 vehicle start
 *    .. performing travel and visits ..
 *   09:00 1 hour break
 *   10:00 end of the break
 *    .. performing travel and visits ..
 *   12:00 20-min lunch break
 *   12:20 end of the break
 *    .. performing travel and visits ..
 *   21:00 1 hour break
 *   22:00 end of the break
 *    .. performing travel and visits ..
 *   23:59 vehicle end
 * ```
 */
export interface ShipmentModel_BreakRule_FrequencyConstraint {
  /**
   * Required. Minimum break duration for this constraint. Nonnegative.
   * See description of `FrequencyConstraint`.
   */
  minBreakDuration:
    | Duration
    | undefined;
  /**
   * Required. Maximum allowed span of any interval of time in the route
   * that does not include at least partially a break of `duration >=
   * min_break_duration`. Must be positive.
   */
  maxInterBreakDuration: Duration | undefined;
}

/**
 * The shipment of a single item, from one of its pickups to one of its
 * deliveries. For the shipment to be considered as performed, a unique vehicle
 * must visit one of its pickup locations (and decrease its spare capacities
 * accordingly), then visit one of its delivery locations later on (and
 * therefore re-increase its spare capacities accordingly).
 */
export interface Shipment {
  /**
   * Set of pickup alternatives associated to the shipment. If not specified,
   * the vehicle only needs to visit a location corresponding to the deliveries.
   */
  pickups: Shipment_VisitRequest[];
  /**
   * Set of delivery alternatives associated to the shipment. If not specified,
   * the vehicle only needs to visit a location corresponding to the pickups.
   */
  deliveries: Shipment_VisitRequest[];
  /**
   * Load demands of the shipment (for example weight, volume, number of
   * pallets etc). The keys in the map should be identifiers describing the type
   * of the corresponding load, ideally also including the units.
   * For example: "weight_kg", "volume_gallons", "pallet_count", etc.
   * If a given key does not appear in the map, the corresponding load is
   * considered as null.
   */
  loadDemands: { [key: string]: Shipment_Load };
  /**
   * If the shipment is not completed, this penalty is added to the overall
   * cost of the routes. A shipment is considered completed if one of its pickup
   * and delivery alternatives is visited. The cost may be expressed in the
   * same unit used for all other cost-related fields in the model and must be
   * positive.
   *
   * *IMPORTANT*: If this penalty is not specified, it is considered infinite,
   * i.e. the shipment must be completed.
   */
  penaltyCost?:
    | number
    | undefined;
  /**
   * The set of vehicles that may perform this shipment. If empty, all vehicles
   * may perform it. Vehicles are given by their index in the `ShipmentModel`'s
   * `vehicles` list.
   */
  allowedVehicleIndices: number[];
  /**
   * Specifies the cost that is incurred when this shipment is delivered by each
   * vehicle. If specified, it must have EITHER:
   *
   *   * the same number of elements as `costs_per_vehicle_indices`.
   *     `costs_per_vehicle[i]` corresponds to vehicle
   *     `costs_per_vehicle_indices[i]` of the model.
   *   * the same number of elements as there are vehicles in the model. The
   *     i-th element corresponds to vehicle #i of the model.
   *
   * These costs must be in the same unit as `penalty_cost` and must not be
   * negative. Leave this field empty, if there are no such costs.
   */
  costsPerVehicle: number[];
  /**
   * Indices of the vehicles to which `costs_per_vehicle` applies. If non-empty,
   * it must have the same number of elements as `costs_per_vehicle`. A vehicle
   * index may not be specified more than once. If a vehicle is excluded from
   * `costs_per_vehicle_indices`, its cost is zero.
   */
  costsPerVehicleIndices: number[];
  /**
   * Specifies the maximum relative detour time compared to the shortest path
   * from pickup to delivery. If specified, it must be nonnegative, and the
   * shipment must contain at least a pickup and a delivery.
   *
   * For example, let t be the shortest time taken to go from the selected
   * pickup alternative directly to the selected delivery alternative. Then
   * setting `pickup_to_delivery_relative_detour_limit` enforces:
   *
   * ```
   * start_time(delivery) - start_time(pickup) <=
   * std::ceil(t * (1.0 + pickup_to_delivery_relative_detour_limit))
   * ```
   *
   * If both relative and absolute limits are specified on the same shipment,
   * the more constraining limit is used for each possible pickup/delivery pair.
   * As of 2017/10, detours are only supported when travel durations do not
   * depend on vehicles.
   */
  pickupToDeliveryRelativeDetourLimit?:
    | number
    | undefined;
  /**
   * Specifies the maximum absolute detour time compared to the shortest path
   * from pickup to delivery. If specified, it must be nonnegative, and the
   * shipment must contain at least a pickup and a delivery.
   *
   * For example, let t be the shortest time taken to go from the selected
   * pickup alternative directly to the selected delivery alternative. Then
   * setting `pickup_to_delivery_absolute_detour_limit` enforces:
   *
   * ```
   * start_time(delivery) - start_time(pickup) <=
   * t + pickup_to_delivery_absolute_detour_limit
   * ```
   *
   * If both relative and absolute limits are specified on the same shipment,
   * the more constraining limit is used for each possible pickup/delivery pair.
   * As of 2017/10, detours are only supported when travel durations do not
   * depend on vehicles.
   */
  pickupToDeliveryAbsoluteDetourLimit:
    | Duration
    | undefined;
  /**
   * Specifies the maximum duration from start of pickup to start of delivery of
   * a shipment. If specified, it must be nonnegative, and the shipment must
   * contain at least a pickup and a delivery. This does not depend on which
   * alternatives are selected for pickup and delivery, nor on vehicle speed.
   * This can be specified alongside maximum detour constraints: the solution
   * will respect both specifications.
   */
  pickupToDeliveryTimeLimit:
    | Duration
    | undefined;
  /**
   * Non-empty string specifying a "type" for this shipment.
   * This feature can be used to define incompatibilities or requirements
   * between `shipment_types` (see `shipment_type_incompatibilities` and
   * `shipment_type_requirements` in `ShipmentModel`).
   *
   * Differs from `visit_types` which is specified for a single visit: All
   * pickup/deliveries belonging to the same shipment share the same
   * `shipment_type`.
   */
  shipmentType: string;
  /**
   * Specifies a label for this shipment. This label is reported in the response
   * in the `shipment_label` of the corresponding
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit].
   */
  label: string;
  /**
   * If true, skip this shipment, but don't apply a `penalty_cost`.
   *
   * Ignoring a shipment results in a validation error when there are any
   * `shipment_type_requirements` in the model.
   *
   * Ignoring a shipment that is performed in `injected_first_solution_routes`
   * or `injected_solution_constraint` is permitted; the solver removes the
   * related pickup/delivery visits from the performing route.
   * `precedence_rules` that reference ignored shipments will also be ignored.
   */
  ignore: boolean;
  /**
   * Deprecated: Use
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * instead.
   *
   * @deprecated
   */
  demands: CapacityQuantity[];
}

/**
 * Request for a visit which can be done by a vehicle: it has a geo-location
 * (or two, see below), opening and closing times represented by time windows,
 * and a service duration time (time spent by the vehicle once it has arrived
 * to pickup or drop off goods).
 */
export interface Shipment_VisitRequest {
  /**
   * The geo-location where the vehicle arrives when performing this
   * `VisitRequest`. If the shipment model has duration distance matrices,
   * `arrival_location` must not be specified.
   */
  arrivalLocation:
    | LatLng
    | undefined;
  /**
   * The waypoint where the vehicle arrives when performing this
   * `VisitRequest`. If the shipment model has duration distance matrices,
   * `arrival_waypoint` must not be specified.
   */
  arrivalWaypoint:
    | Waypoint
    | undefined;
  /**
   * The geo-location where the vehicle departs after completing this
   * `VisitRequest`. Can be omitted if it is the same as `arrival_location`.
   * If the shipment model has duration distance matrices,
   * `departure_location` must not be specified.
   */
  departureLocation:
    | LatLng
    | undefined;
  /**
   * The waypoint where the vehicle departs after completing this
   * `VisitRequest`. Can be omitted if it is the same as `arrival_waypoint`.
   * If the shipment model has duration distance matrices,
   * `departure_waypoint` must not be specified.
   */
  departureWaypoint:
    | Waypoint
    | undefined;
  /**
   * Specifies tags attached to the visit request.
   * Empty or duplicate strings are not allowed.
   */
  tags: string[];
  /**
   * Time windows which constrain the arrival time at a visit.
   * Note that a vehicle may depart outside of the arrival time window, i.e.
   * arrival time + duration do not need to be inside a time window. This can
   * result in waiting time if the vehicle arrives before
   * [TimeWindow.start_time][google.cloud.optimization.v1.TimeWindow.start_time].
   *
   * The absence of `TimeWindow` means that the vehicle can perform this visit
   * at any time.
   *
   * Time windows must be disjoint, i.e. no time window must overlap with or
   * be adjacent to another, and they must be in increasing order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only
   * be set if there is a single time window.
   */
  timeWindows: TimeWindow[];
  /**
   * Duration of the visit, i.e. time spent by the vehicle between arrival
   * and departure (to be added to the possible waiting time; see
   * `time_windows`).
   */
  duration:
    | Duration
    | undefined;
  /**
   * Cost to service this visit request on a vehicle route. This can be used
   * to pay different costs for each alternative pickup or delivery of a
   * shipment. This cost must be in the same unit as `Shipment.penalty_cost`
   * and must not be negative.
   */
  cost: number;
  /**
   * Load demands of this visit request. This is just like
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * field, except that it only applies to this
   * [VisitRequest][google.cloud.optimization.v1.Shipment.VisitRequest]
   * instead of the whole [Shipment][google.cloud.optimization.v1.Shipment].
   * The demands listed here are added to the demands listed in
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands].
   */
  loadDemands: { [key: string]: Shipment_Load };
  /**
   * Specifies the types of the visit. This may be used to allocate additional
   * time required for a vehicle to complete this visit (see
   * [Vehicle.extra_visit_duration_for_visit_type][google.cloud.optimization.v1.Vehicle.extra_visit_duration_for_visit_type]).
   *
   * A type can only appear once.
   */
  visitTypes: string[];
  /**
   * Specifies a label for this `VisitRequest`. This label is reported in the
   * response as `visit_label` in the corresponding
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit].
   */
  label: string;
  /**
   * Deprecated: Use
   * [VisitRequest.load_demands][google.cloud.optimization.v1.Shipment.VisitRequest.load_demands]
   * instead.
   *
   * @deprecated
   */
  demands: CapacityQuantity[];
}

export interface Shipment_VisitRequest_LoadDemandsEntry {
  key: string;
  value: Shipment_Load | undefined;
}

/**
 * When performing a visit, a predefined amount may be added to the vehicle
 * load if it's a pickup, or subtracted if it's a delivery. This message
 * defines such amount. See
 * [load_demands][google.cloud.optimization.v1.Shipment.load_demands].
 */
export interface Shipment_Load {
  /**
   * The amount by which the load of the vehicle performing the corresponding
   * visit will vary. Since it is an integer, users are advised to choose an
   * appropriate unit to avoid loss of precision. Must be â‰¥ 0.
   */
  amount: Long;
}

export interface Shipment_LoadDemandsEntry {
  key: string;
  value: Shipment_Load | undefined;
}

/**
 * Specifies incompatibilties between shipments depending on their
 * shipment_type. The appearance of incompatible shipments on the same route is
 * restricted based on the incompatibility mode.
 */
export interface ShipmentTypeIncompatibility {
  /**
   * List of incompatible types. Two shipments having different `shipment_types`
   * among those listed are "incompatible".
   */
  types: string[];
  /** Mode applied to the incompatibility. */
  incompatibilityMode: ShipmentTypeIncompatibility_IncompatibilityMode;
}

/**
 * Modes defining how the appearance of incompatible shipments are restricted
 * on the same route.
 */
export enum ShipmentTypeIncompatibility_IncompatibilityMode {
  /** INCOMPATIBILITY_MODE_UNSPECIFIED - Unspecified incompatibility mode. This value should never be used. */
  INCOMPATIBILITY_MODE_UNSPECIFIED = 0,
  /**
   * NOT_PERFORMED_BY_SAME_VEHICLE - In this mode, two shipments with incompatible types can never share the
   * same vehicle.
   */
  NOT_PERFORMED_BY_SAME_VEHICLE = 1,
  /**
   * NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY - For two shipments with incompatible types with the
   * `NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY` incompatibility mode:
   *
   * * If both are pickups only (no deliveries) or deliveries only (no
   *   pickups), they cannot share the same vehicle at all.
   * * If one of the shipments has a delivery and the other a pickup, the two
   *   shipments can share the same vehicle iff the former shipment is
   *   delivered before the latter is picked up.
   */
  NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY = 2,
  UNRECOGNIZED = -1,
}

export function shipmentTypeIncompatibility_IncompatibilityModeFromJSON(
  object: any,
): ShipmentTypeIncompatibility_IncompatibilityMode {
  switch (object) {
    case 0:
    case "INCOMPATIBILITY_MODE_UNSPECIFIED":
      return ShipmentTypeIncompatibility_IncompatibilityMode.INCOMPATIBILITY_MODE_UNSPECIFIED;
    case 1:
    case "NOT_PERFORMED_BY_SAME_VEHICLE":
      return ShipmentTypeIncompatibility_IncompatibilityMode.NOT_PERFORMED_BY_SAME_VEHICLE;
    case 2:
    case "NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY":
      return ShipmentTypeIncompatibility_IncompatibilityMode.NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShipmentTypeIncompatibility_IncompatibilityMode.UNRECOGNIZED;
  }
}

export function shipmentTypeIncompatibility_IncompatibilityModeToJSON(
  object: ShipmentTypeIncompatibility_IncompatibilityMode,
): string {
  switch (object) {
    case ShipmentTypeIncompatibility_IncompatibilityMode.INCOMPATIBILITY_MODE_UNSPECIFIED:
      return "INCOMPATIBILITY_MODE_UNSPECIFIED";
    case ShipmentTypeIncompatibility_IncompatibilityMode.NOT_PERFORMED_BY_SAME_VEHICLE:
      return "NOT_PERFORMED_BY_SAME_VEHICLE";
    case ShipmentTypeIncompatibility_IncompatibilityMode.NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY:
      return "NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY";
    case ShipmentTypeIncompatibility_IncompatibilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies requirements between shipments based on their shipment_type.
 * The specifics of the requirement are defined by the requirement mode.
 */
export interface ShipmentTypeRequirement {
  /**
   * List of alternative shipment types required by the
   * `dependent_shipment_types`.
   */
  requiredShipmentTypeAlternatives: string[];
  /**
   * All shipments with a type in the `dependent_shipment_types` field require
   * at least one shipment of type `required_shipment_type_alternatives` to be
   * visited on the same route.
   *
   * NOTE: Chains of requirements such that a `shipment_type` depends on itself
   * are not allowed.
   */
  dependentShipmentTypes: string[];
  /** Mode applied to the requirement. */
  requirementMode: ShipmentTypeRequirement_RequirementMode;
}

/** Modes defining the appearance of dependent shipments on a route. */
export enum ShipmentTypeRequirement_RequirementMode {
  /** REQUIREMENT_MODE_UNSPECIFIED - Unspecified requirement mode. This value should never be used. */
  REQUIREMENT_MODE_UNSPECIFIED = 0,
  /**
   * PERFORMED_BY_SAME_VEHICLE - In this mode, all "dependent" shipments must share the same vehicle as at
   * least one of their "required" shipments.
   */
  PERFORMED_BY_SAME_VEHICLE = 1,
  /**
   * IN_SAME_VEHICLE_AT_PICKUP_TIME - With the `IN_SAME_VEHICLE_AT_PICKUP_TIME` mode, all "dependent"
   * shipments need to have at least one "required" shipment on their vehicle
   * at the time of their pickup.
   *
   * A "dependent" shipment pickup must therefore have either:
   *
   * * A delivery-only "required" shipment delivered on the route after, or
   * * A "required" shipment picked up on the route before it, and if the
   *   "required" shipment has a delivery, this delivery must be performed
   *   after the "dependent" shipment's pickup.
   */
  IN_SAME_VEHICLE_AT_PICKUP_TIME = 2,
  /**
   * IN_SAME_VEHICLE_AT_DELIVERY_TIME - Same as before, except the "dependent" shipments need to have a
   * "required" shipment on their vehicle at the time of their *delivery*.
   */
  IN_SAME_VEHICLE_AT_DELIVERY_TIME = 3,
  UNRECOGNIZED = -1,
}

export function shipmentTypeRequirement_RequirementModeFromJSON(object: any): ShipmentTypeRequirement_RequirementMode {
  switch (object) {
    case 0:
    case "REQUIREMENT_MODE_UNSPECIFIED":
      return ShipmentTypeRequirement_RequirementMode.REQUIREMENT_MODE_UNSPECIFIED;
    case 1:
    case "PERFORMED_BY_SAME_VEHICLE":
      return ShipmentTypeRequirement_RequirementMode.PERFORMED_BY_SAME_VEHICLE;
    case 2:
    case "IN_SAME_VEHICLE_AT_PICKUP_TIME":
      return ShipmentTypeRequirement_RequirementMode.IN_SAME_VEHICLE_AT_PICKUP_TIME;
    case 3:
    case "IN_SAME_VEHICLE_AT_DELIVERY_TIME":
      return ShipmentTypeRequirement_RequirementMode.IN_SAME_VEHICLE_AT_DELIVERY_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShipmentTypeRequirement_RequirementMode.UNRECOGNIZED;
  }
}

export function shipmentTypeRequirement_RequirementModeToJSON(object: ShipmentTypeRequirement_RequirementMode): string {
  switch (object) {
    case ShipmentTypeRequirement_RequirementMode.REQUIREMENT_MODE_UNSPECIFIED:
      return "REQUIREMENT_MODE_UNSPECIFIED";
    case ShipmentTypeRequirement_RequirementMode.PERFORMED_BY_SAME_VEHICLE:
      return "PERFORMED_BY_SAME_VEHICLE";
    case ShipmentTypeRequirement_RequirementMode.IN_SAME_VEHICLE_AT_PICKUP_TIME:
      return "IN_SAME_VEHICLE_AT_PICKUP_TIME";
    case ShipmentTypeRequirement_RequirementMode.IN_SAME_VEHICLE_AT_DELIVERY_TIME:
      return "IN_SAME_VEHICLE_AT_DELIVERY_TIME";
    case ShipmentTypeRequirement_RequirementMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Encapsulates a set of optional conditions to satisfy when calculating
 * vehicle routes. This is similar to `RouteModifiers` in the Google Maps
 * Platform API; see:
 * https://developers.google.com/maps/documentation/routes/reference/rest/v2/RouteModifiers.
 */
export interface RouteModifiers {
  /**
   * Specifies whether to avoid toll roads where reasonable. Preference will be
   * given to routes not containing toll roads. Applies only to motorized travel
   * modes.
   */
  avoidTolls: boolean;
  /**
   * Specifies whether to avoid highways where reasonable. Preference will be
   * given to routes not containing highways. Applies only to motorized travel
   * modes.
   */
  avoidHighways: boolean;
  /**
   * Specifies whether to avoid ferries where reasonable. Preference will be
   * given to routes not containing travel by ferries. Applies only to motorized
   * travel modes.
   */
  avoidFerries: boolean;
  /**
   * Optional. Specifies whether to avoid navigating indoors where reasonable.
   * Preference will be given to routes not containing indoor navigation.
   * Applies only to the `WALKING` travel mode.
   */
  avoidIndoor: boolean;
}

/**
 * Models a vehicle in a shipment problem. Solving a shipment problem will
 * build a route starting from `start_location` and ending at `end_location`
 * for this vehicle. A route is a sequence of visits (see `ShipmentRoute`).
 */
export interface Vehicle {
  /**
   * The travel mode which affects the roads usable by the vehicle and its
   * speed. See also `travel_duration_multiple`.
   */
  travelMode: Vehicle_TravelMode;
  /**
   * Optional. A set of conditions to satisfy that affect the way routes are
   * calculated for the given vehicle.
   */
  routeModifiers:
    | RouteModifiers
    | undefined;
  /**
   * Geographic location where the vehicle starts before picking up any
   * shipments. If not specified, the vehicle starts at its first pickup.
   * If the shipment model has duration and distance matrices, `start_location`
   * must not be specified.
   */
  startLocation:
    | LatLng
    | undefined;
  /**
   * Waypoint representing a geographic location where the vehicle starts before
   * picking up any shipments. If neither `start_waypoint` nor `start_location`
   * is specified, the vehicle starts at its first pickup.
   * If the shipment model has duration and distance matrices, `start_waypoint`
   * must not be specified.
   */
  startWaypoint:
    | Waypoint
    | undefined;
  /**
   * Geographic location where the vehicle ends after it has completed its last
   * `VisitRequest`. If not specified the vehicle's `ShipmentRoute` ends
   * immediately when it completes its last `VisitRequest`.
   * If the shipment model has duration and distance matrices, `end_location`
   * must not be specified.
   */
  endLocation:
    | LatLng
    | undefined;
  /**
   * Waypoint representing a geographic location where the vehicle ends after
   * it has completed its last `VisitRequest`. If neither `end_waypoint` nor
   * `end_location` is specified, the vehicle's `ShipmentRoute` ends immediately
   * when it completes its last `VisitRequest`.
   * If the shipment model has duration and distance matrices, `end_waypoint`
   * must not be specified.
   */
  endWaypoint:
    | Waypoint
    | undefined;
  /**
   * Specifies tags attached to the start of the vehicle's route.
   *
   * Empty or duplicate strings are not allowed.
   */
  startTags: string[];
  /**
   * Specifies tags attached to the end of the vehicle's route.
   *
   * Empty or duplicate strings are not allowed.
   */
  endTags: string[];
  /**
   * Time windows during which the vehicle may depart its start location.
   * They must be within the global time limits (see
   * [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time]
   * fields). If unspecified, there is no limitation besides those global time
   * limits.
   *
   * Time windows belonging to the same repeated field must be disjoint, i.e. no
   * time window can overlap with or be adjacent to another, and they must be in
   * chronological order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
   * there is a single time window.
   */
  startTimeWindows: TimeWindow[];
  /**
   * Time windows during which the vehicle may arrive at its end location.
   * They must be within the global time limits (see
   * [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time]
   * fields). If unspecified, there is no limitation besides those global time
   * limits.
   *
   * Time windows belonging to the same repeated field must be disjoint, i.e. no
   * time window can overlap with or be adjacent to another, and they must be in
   * chronological order.
   *
   * `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
   * there is a single time window.
   */
  endTimeWindows: TimeWindow[];
  /**
   * Specifies a multiplicative factor that can be used to increase or decrease
   * travel times of this vehicle. For example, setting this to 2.0 means
   * that this vehicle is slower and has travel times that are twice what they
   * are for standard vehicles. This multiple does not affect visit durations.
   * It does affect cost if `cost_per_hour` or `cost_per_traveled_hour` are
   * specified. This must be in the range [0.001, 1000.0]. If unset, the vehicle
   * is standard, and this multiple is considered 1.0.
   *
   * WARNING: Travel times will be rounded to the nearest second after this
   * multiple is applied but before performing any numerical operations, thus,
   * a small multiple may result in a loss of precision.
   *
   * See also `extra_visit_duration_for_visit_type` below.
   */
  travelDurationMultiple?:
    | number
    | undefined;
  /** Unloading policy enforced on the vehicle. */
  unloadingPolicy: Vehicle_UnloadingPolicy;
  /**
   * Capacities of the vehicle (weight, volume, # of pallets for example).
   * The keys in the map are the identifiers of the type of load, consistent
   * with the keys of the
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * field. If a given key is absent from this map, the corresponding capacity
   * is considered to be limitless.
   */
  loadLimits: { [key: string]: Vehicle_LoadLimit };
  /**
   * Vehicle costs: all costs add up and must be in the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   *
   * Cost per hour of the vehicle route. This cost is applied to the total time
   * taken by the route, and includes travel time, waiting time, and visit time.
   * Using `cost_per_hour` instead of just `cost_per_traveled_hour` may result
   * in additional latency.
   */
  costPerHour: number;
  /**
   * Cost per traveled hour of the vehicle route. This cost is applied only to
   * travel time taken by the route (i.e., that reported in
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]),
   * and excludes waiting time and visit time.
   */
  costPerTraveledHour: number;
  /**
   * Cost per kilometer of the vehicle route. This cost is applied to the
   * distance reported in the
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * and does not apply to any distance implicitly traveled from the
   * `arrival_location` to the `departure_location` of a single `VisitRequest`.
   */
  costPerKilometer: number;
  /** Fixed cost applied if this vehicle is used to handle a shipment. */
  fixedCost: number;
  /**
   * This field only applies to vehicles when their route does not serve any
   * shipments. It indicates if the vehicle should be considered as used or not
   * in this case.
   *
   * If true, the vehicle goes from its start to its end location even if it
   * doesn't serve any shipments, and time and distance costs resulting from its
   * start --> end travel are taken into account.
   *
   * Otherwise, it doesn't travel from its start to its end location, and no
   * `break_rule` or delay (from `TransitionAttributes`) are scheduled for this
   * vehicle. In this case, the vehicle's `ShipmentRoute` doesn't contain any
   * information except for the vehicle index and label.
   */
  usedIfRouteIsEmpty: boolean;
  /**
   * Limit applied to the total duration of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route duration of a vehicle is the
   * difference between its `vehicle_end_time` and `vehicle_start_time`.
   */
  routeDurationLimit:
    | Vehicle_DurationLimit
    | undefined;
  /**
   * Limit applied to the travel duration of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route travel duration is the sum of all its
   * [transitions.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration].
   */
  travelDurationLimit:
    | Vehicle_DurationLimit
    | undefined;
  /**
   * Limit applied to the total distance of the vehicle's route. In a given
   * `OptimizeToursResponse`, the route distance is the sum of all its
   * [transitions.travel_distance_meters][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_distance_meters].
   */
  routeDistanceLimit:
    | DistanceLimit
    | undefined;
  /**
   * Specifies a map from visit_types strings to durations. The duration is time
   * in addition to
   * [VisitRequest.duration][google.cloud.optimization.v1.Shipment.VisitRequest.duration]
   * to be taken at visits with the specified `visit_types`. This extra visit
   * duration adds cost if `cost_per_hour` is specified. Keys (i.e.
   * `visit_types`) cannot be empty strings.
   *
   * If a visit request has multiple types, a duration will be added for each
   * type in the map.
   */
  extraVisitDurationForVisitType: { [key: string]: Duration };
  /**
   * Describes the break schedule to be enforced on this vehicle.
   * If empty, no breaks will be scheduled for this vehicle.
   */
  breakRule:
    | BreakRule
    | undefined;
  /**
   * Specifies a label for this vehicle. This label is reported in the response
   * as the `vehicle_label` of the corresponding
   * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute].
   */
  label: string;
  /**
   * If true, `used_if_route_is_empty` must be false, and this vehicle will
   * remain unused.
   *
   * If a shipment is performed by an ignored vehicle in
   * `injected_first_solution_routes`, it is skipped in the first solution but
   * is free to be performed in the response.
   *
   * If a shipment is performed by an ignored vehicle in
   * `injected_solution_constraint` and any related pickup/delivery is
   * constrained to remain on the vehicle (i.e., not relaxed to level
   * `RELAX_ALL_AFTER_THRESHOLD`), it is skipped in the response.
   * If a shipment has a non-empty `allowed_vehicle_indices` field and all of
   * the allowed vehicles are ignored, it is skipped in the response.
   */
  ignore: boolean;
  /**
   * Deprecated: No longer used.
   * Indices in the `break_rule` field in the source
   * [ShipmentModel][google.cloud.optimization.v1.ShipmentModel]. They
   * correspond to break rules enforced on the vehicle.
   *
   * As of 2018/03, at most one rule index per vehicle can be specified.
   *
   * @deprecated
   */
  breakRuleIndices: number[];
  /**
   * Deprecated: Use
   * [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits]
   * instead.
   *
   * @deprecated
   */
  capacities: CapacityQuantity[];
  /**
   * Deprecated: Use
   * [Vehicle.LoadLimit.start_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.start_load_interval]
   * instead.
   *
   * @deprecated
   */
  startLoadIntervals: CapacityQuantityInterval[];
  /**
   * Deprecated: Use
   * [Vehicle.LoadLimit.end_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.end_load_interval]
   * instead.
   *
   * @deprecated
   */
  endLoadIntervals: CapacityQuantityInterval[];
}

/**
 * Travel modes which can be used by vehicles.
 *
 * These should be a subset of the Google Maps Platform Routes Preferred API
 * travel modes, see:
 * https://developers.google.com/maps/documentation/routes_preferred/reference/rest/Shared.Types/RouteTravelMode.
 */
export enum Vehicle_TravelMode {
  /** TRAVEL_MODE_UNSPECIFIED - Unspecified travel mode, equivalent to `DRIVING`. */
  TRAVEL_MODE_UNSPECIFIED = 0,
  /** DRIVING - Travel mode corresponding to driving directions (car, ...). */
  DRIVING = 1,
  /** WALKING - Travel mode corresponding to walking directions. */
  WALKING = 2,
  UNRECOGNIZED = -1,
}

export function vehicle_TravelModeFromJSON(object: any): Vehicle_TravelMode {
  switch (object) {
    case 0:
    case "TRAVEL_MODE_UNSPECIFIED":
      return Vehicle_TravelMode.TRAVEL_MODE_UNSPECIFIED;
    case 1:
    case "DRIVING":
      return Vehicle_TravelMode.DRIVING;
    case 2:
    case "WALKING":
      return Vehicle_TravelMode.WALKING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Vehicle_TravelMode.UNRECOGNIZED;
  }
}

export function vehicle_TravelModeToJSON(object: Vehicle_TravelMode): string {
  switch (object) {
    case Vehicle_TravelMode.TRAVEL_MODE_UNSPECIFIED:
      return "TRAVEL_MODE_UNSPECIFIED";
    case Vehicle_TravelMode.DRIVING:
      return "DRIVING";
    case Vehicle_TravelMode.WALKING:
      return "WALKING";
    case Vehicle_TravelMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Policy on how a vehicle can be unloaded. Applies only to shipments having
 * both a pickup and a delivery.
 *
 * Other shipments are free to occur anywhere on the route independent of
 * `unloading_policy`.
 */
export enum Vehicle_UnloadingPolicy {
  /**
   * UNLOADING_POLICY_UNSPECIFIED - Unspecified unloading policy; deliveries must just occur after their
   * corresponding pickups.
   */
  UNLOADING_POLICY_UNSPECIFIED = 0,
  /** LAST_IN_FIRST_OUT - Deliveries must occur in reverse order of pickups */
  LAST_IN_FIRST_OUT = 1,
  /** FIRST_IN_FIRST_OUT - Deliveries must occur in the same order as pickups */
  FIRST_IN_FIRST_OUT = 2,
  UNRECOGNIZED = -1,
}

export function vehicle_UnloadingPolicyFromJSON(object: any): Vehicle_UnloadingPolicy {
  switch (object) {
    case 0:
    case "UNLOADING_POLICY_UNSPECIFIED":
      return Vehicle_UnloadingPolicy.UNLOADING_POLICY_UNSPECIFIED;
    case 1:
    case "LAST_IN_FIRST_OUT":
      return Vehicle_UnloadingPolicy.LAST_IN_FIRST_OUT;
    case 2:
    case "FIRST_IN_FIRST_OUT":
      return Vehicle_UnloadingPolicy.FIRST_IN_FIRST_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Vehicle_UnloadingPolicy.UNRECOGNIZED;
  }
}

export function vehicle_UnloadingPolicyToJSON(object: Vehicle_UnloadingPolicy): string {
  switch (object) {
    case Vehicle_UnloadingPolicy.UNLOADING_POLICY_UNSPECIFIED:
      return "UNLOADING_POLICY_UNSPECIFIED";
    case Vehicle_UnloadingPolicy.LAST_IN_FIRST_OUT:
      return "LAST_IN_FIRST_OUT";
    case Vehicle_UnloadingPolicy.FIRST_IN_FIRST_OUT:
      return "FIRST_IN_FIRST_OUT";
    case Vehicle_UnloadingPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines a load limit applying to a vehicle, e.g. "this truck may only
 * carry up to 3500 kg". See
 * [load_limits][google.cloud.optimization.v1.Vehicle.load_limits].
 */
export interface Vehicle_LoadLimit {
  /** The maximum acceptable amount of load. */
  maxLoad?:
    | Long
    | undefined;
  /**
   * A soft limit of the load. See
   * [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max].
   */
  softMaxLoad: Long;
  /**
   * If the load ever exceeds
   * [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load]
   * along this vehicle's route, the following cost penalty applies (only once
   * per vehicle): (load -
   * [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load])
   * * [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max]. All costs
   * add up and must be in the same unit as
   * [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].
   */
  costPerUnitAboveSoftMax: number;
  /** The acceptable load interval of the vehicle at the start of the route. */
  startLoadInterval:
    | Vehicle_LoadLimit_Interval
    | undefined;
  /** The acceptable load interval of the vehicle at the end of the route. */
  endLoadInterval: Vehicle_LoadLimit_Interval | undefined;
}

/** Interval of acceptable load amounts. */
export interface Vehicle_LoadLimit_Interval {
  /**
   * A minimum acceptable load. Must be â‰¥ 0.
   * If they're both specified,
   * [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must
   * be â‰¤
   * [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].
   */
  min: Long;
  /**
   * A maximum acceptable load. Must be â‰¥ 0. If unspecified, the maximum
   * load is unrestricted by this message.
   * If they're both specified,
   * [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must
   * be â‰¤
   * [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].
   */
  max?: Long | undefined;
}

/**
 * A limit defining a maximum duration of the route of a vehicle. It can be
 * either hard or soft.
 *
 * When a soft limit field is defined, both the soft max threshold and its
 * associated cost must be defined together.
 */
export interface Vehicle_DurationLimit {
  /** A hard limit constraining the duration to be at most max_duration. */
  maxDuration:
    | Duration
    | undefined;
  /**
   * A soft limit not enforcing a maximum duration limit, but when violated
   * makes the route incur a cost. This cost adds up to other costs defined in
   * the model, with the same unit.
   *
   * If defined, `soft_max_duration` must be nonnegative. If max_duration is
   * also defined, `soft_max_duration` must be less than max_duration.
   */
  softMaxDuration:
    | Duration
    | undefined;
  /**
   * Cost per hour incurred if the `soft_max_duration` threshold is violated.
   * The additional cost is 0 if the duration is under the threshold,
   * otherwise the cost depends on the duration as follows:
   * ```
   *   cost_per_hour_after_soft_max * (duration - soft_max_duration)
   * ```
   * The cost must be nonnegative.
   */
  costPerHourAfterSoftMax?:
    | number
    | undefined;
  /**
   * A soft limit not enforcing a maximum duration limit, but when violated
   * makes the route incur a cost, quadratic in the duration. This cost adds
   * up to other costs defined in the model, with the same unit.
   *
   * If defined, `quadratic_soft_max_duration` must be nonnegative. If
   * `max_duration` is also defined, `quadratic_soft_max_duration` must be
   * less than `max_duration`, and the difference must be no larger than one
   * day:
   *
   *    `max_duration - quadratic_soft_max_duration <= 86400 seconds`
   */
  quadraticSoftMaxDuration:
    | Duration
    | undefined;
  /**
   * Cost per square hour incurred if the
   * `quadratic_soft_max_duration` threshold is violated.
   *
   * The additional cost is 0 if the duration is under the threshold,
   * otherwise the cost depends on the duration as follows:
   *
   * ```
   *   cost_per_square_hour_after_quadratic_soft_max *
   *   (duration - quadratic_soft_max_duration)^2
   * ```
   *
   * The cost must be nonnegative.
   */
  costPerSquareHourAfterQuadraticSoftMax?: number | undefined;
}

export interface Vehicle_LoadLimitsEntry {
  key: string;
  value: Vehicle_LoadLimit | undefined;
}

export interface Vehicle_ExtraVisitDurationForVisitTypeEntry {
  key: string;
  value: Duration | undefined;
}

/**
 * Time windows constrain the time of an event, such as the arrival time at a
 * visit, or the start and end time of a vehicle.
 *
 * Hard time window bounds, `start_time` and `end_time`, enforce the earliest
 * and latest time of the event, such that `start_time <= event_time <=
 * end_time`. The soft time window lower bound, `soft_start_time`, expresses a
 * preference for the event to happen at or after `soft_start_time` by incurring
 * a cost proportional to how long before soft_start_time the event occurs. The
 * soft time window upper bound, `soft_end_time`, expresses a preference for the
 * event to happen at or before `soft_end_time` by incurring a cost proportional
 * to how long after `soft_end_time` the event occurs. `start_time`, `end_time`,
 * `soft_start_time` and `soft_end_time` should be within the global time limits
 * (see
 * [ShipmentModel.global_start_time][google.cloud.optimization.v1.ShipmentModel.global_start_time]
 * and
 * [ShipmentModel.global_end_time][google.cloud.optimization.v1.ShipmentModel.global_end_time])
 * and should respect:
 * ```
 *   0 <= `start_time` <= `soft_start_time` <= `end_time` and
 *   0 <= `start_time` <= `soft_end_time` <= `end_time`.
 * ```
 */
export interface TimeWindow {
  /**
   * The hard time window start time. If unspecified it will be set to
   * `ShipmentModel.global_start_time`.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The hard time window end time. If unspecified it will be set to
   * `ShipmentModel.global_end_time`.
   */
  endTime:
    | Date
    | undefined;
  /** The soft start time of the time window. */
  softStartTime:
    | Date
    | undefined;
  /** The soft end time of the time window. */
  softEndTime:
    | Date
    | undefined;
  /**
   * A cost per hour added to other costs in the model if the event occurs
   * before soft_start_time, computed as:
   *
   * ```
   *    max(0, soft_start_time - t.seconds)
   *                           * cost_per_hour_before_soft_start_time / 3600,
   * t being the time of the event.
   * ```
   *
   * This cost must be positive, and the field can only be set if
   * soft_start_time has been set.
   */
  costPerHourBeforeSoftStartTime?:
    | number
    | undefined;
  /**
   * A cost per hour added to other costs in the model if the event occurs after
   * `soft_end_time`, computed as:
   *
   * ```
   *    max(0, t.seconds - soft_end_time.seconds)
   *                     * cost_per_hour_after_soft_end_time / 3600,
   * t being the time of the event.
   * ```
   *
   * This cost must be positive, and the field can only be set if
   * `soft_end_time` has been set.
   */
  costPerHourAfterSoftEndTime?: number | undefined;
}

/**
 * Deprecated: Use
 * [Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]
 * instead.
 *
 * @deprecated
 */
export interface CapacityQuantity {
  type: string;
  value: Long;
}

/**
 * Deprecated: Use
 * [Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]
 * instead.
 *
 * @deprecated
 */
export interface CapacityQuantityInterval {
  type: string;
  minValue?: Long | undefined;
  maxValue?: Long | undefined;
}

/**
 * A limit defining a maximum distance which can be traveled. It can be either
 * hard or soft.
 *
 * If a soft limit is defined, both `soft_max_meters` and
 * `cost_per_kilometer_above_soft_max` must be defined and be nonnegative.
 */
export interface DistanceLimit {
  /**
   * A hard limit constraining the distance to be at most max_meters. The limit
   * must be nonnegative.
   */
  maxMeters?:
    | Long
    | undefined;
  /**
   * A soft limit not enforcing a maximum distance limit, but when violated
   * results in a cost which adds up to other costs defined in the model,
   * with the same unit.
   *
   * If defined soft_max_meters must be less than max_meters and must be
   * nonnegative.
   */
  softMaxMeters?:
    | Long
    | undefined;
  /**
   * Cost per kilometer incurred, increasing up to `soft_max_meters`, with
   * formula:
   * ```
   *   min(distance_meters, soft_max_meters) / 1000.0 *
   *   cost_per_kilometer_below_soft_max.
   * ```
   * This cost is not supported in `route_distance_limit`.
   */
  costPerKilometerBelowSoftMax?:
    | number
    | undefined;
  /**
   * Cost per kilometer incurred if distance is above `soft_max_meters` limit.
   * The additional cost is 0 if the distance is under the limit, otherwise the
   * formula used to compute the cost is the following:
   * ```
   *   (distance_meters - soft_max_meters) / 1000.0 *
   *   cost_per_kilometer_above_soft_max.
   * ```
   * The cost must be nonnegative.
   */
  costPerKilometerAboveSoftMax?: number | undefined;
}

/**
 * Specifies attributes of transitions between two consecutive visits on a
 * route. Several `TransitionAttributes` may apply to the same transition: in
 * that case, all extra costs add up and the strictest constraint or limit
 * applies (following natural "AND" semantics).
 */
export interface TransitionAttributes {
  /**
   * Tags defining the set of (src->dst) transitions these attributes apply to.
   *
   * A source visit or vehicle start matches iff its
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags]
   * either contains `src_tag` or does not contain `excluded_src_tag` (depending
   * on which of these two fields is non-empty).
   */
  srcTag: string;
  /**
   * See `src_tag`. Exactly one of `src_tag` and `excluded_src_tag` must be
   * non-empty.
   */
  excludedSrcTag: string;
  /**
   * A destination visit or vehicle end matches iff its
   * [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]
   * or [Vehicle.end_tags][google.cloud.optimization.v1.Vehicle.end_tags] either
   * contains `dst_tag` or does not contain `excluded_dst_tag` (depending on
   * which of these two fields is non-empty).
   */
  dstTag: string;
  /**
   * See `dst_tag`. Exactly one of `dst_tag` and `excluded_dst_tag` must be
   * non-empty.
   */
  excludedDstTag: string;
  /**
   * Specifies a cost for performing this transition. This is in the same unit
   * as all other costs in the model and must not be negative. It is applied on
   * top of all other existing costs.
   */
  cost: number;
  /**
   * Specifies a cost per kilometer applied to the distance traveled while
   * performing this transition. It adds up to any
   * [Vehicle.cost_per_kilometer][google.cloud.optimization.v1.Vehicle.cost_per_kilometer]
   * specified on vehicles.
   */
  costPerKilometer: number;
  /**
   * Specifies a limit on the distance traveled while performing this
   * transition.
   *
   * As of 2021/06, only soft limits are supported.
   */
  distanceLimit:
    | DistanceLimit
    | undefined;
  /**
   * Specifies a delay incurred when performing this transition.
   *
   * This delay always occurs *after* finishing the source visit and *before*
   * starting the destination visit.
   */
  delay: Duration | undefined;
}

/**
 * Encapsulates a waypoint. Waypoints mark arrival and departure locations of
 * VisitRequests, and start and end locations of Vehicles.
 */
export interface Waypoint {
  /**
   * A point specified using geographic coordinates, including an optional
   * heading.
   */
  location?:
    | Location
    | undefined;
  /** The POI Place ID associated with the waypoint. */
  placeId?:
    | string
    | undefined;
  /**
   * Indicates that the location of this waypoint is meant to have a preference
   * for the vehicle to stop at a particular side of road. When you set this
   * value, the route will pass through the location so that the vehicle can
   * stop at the side of road that the location is biased towards from the
   * center of the road. This option works only for the 'DRIVING' travel mode,
   * and when the 'location_type' is set to 'location'.
   */
  sideOfRoad: boolean;
}

/** Encapsulates a location (a geographic point, and an optional heading). */
export interface Location {
  /** The waypoint's geographic coordinates. */
  latLng:
    | LatLng
    | undefined;
  /**
   * The compass heading associated with the direction of the flow of traffic.
   * This value is used to specify the side of the road to use for pickup and
   * drop-off. Heading values can be from 0 to 360, where 0 specifies a heading
   * of due North, 90 specifies a heading of due East, etc.
   */
  heading?: number | undefined;
}

/**
 * Rules to generate time breaks for a vehicle (e.g. lunch breaks). A break
 * is a contiguous period of time during which the vehicle remains idle at its
 * current position and cannot perform any visit. A break may occur:
 *
 * * during the travel between two visits (which includes the time right
 *   before or right after a visit, but not in the middle of a visit), in
 *   which case it extends the corresponding transit time between the visits,
 * * or before the vehicle start (the vehicle may not start in the middle of
 *   a break), in which case it does not affect the vehicle start time.
 * * or after the vehicle end (ditto, with the vehicle end time).
 */
export interface BreakRule {
  /** Sequence of breaks. See the `BreakRequest` message. */
  breakRequests: BreakRule_BreakRequest[];
  /**
   * Several `FrequencyConstraint` may apply. They must all be satisfied by
   * the `BreakRequest`s of this `BreakRule`. See `FrequencyConstraint`.
   */
  frequencyConstraints: BreakRule_FrequencyConstraint[];
}

/**
 * The sequence of breaks (i.e. their number and order) that apply to each
 * vehicle must be known beforehand. The repeated `BreakRequest`s define
 * that sequence, in the order in which they must occur. Their time windows
 * (`earliest_start_time` / `latest_start_time`) may overlap, but they must
 * be compatible with the order (this is checked).
 */
export interface BreakRule_BreakRequest {
  /** Required. Lower bound (inclusive) on the start of the break. */
  earliestStartTime:
    | Date
    | undefined;
  /** Required. Upper bound (inclusive) on the start of the break. */
  latestStartTime:
    | Date
    | undefined;
  /** Required. Minimum duration of the break. Must be positive. */
  minDuration: Duration | undefined;
}

/**
 * One may further constrain the frequency and duration of the breaks
 * specified above, by enforcing a minimum break frequency, such as
 * "There must be a break of at least 1 hour every 12 hours". Assuming that
 * this can be interpreted as "Within any sliding time window of 12h, there
 * must be at least one break of at least one hour", that example would
 * translate to the following `FrequencyConstraint`:
 * ```
 * {
 *    min_break_duration { seconds: 3600 }         # 1 hour.
 *    max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).
 * }
 * ```
 *
 * The timing and duration of the breaks in the solution will respect all
 * such constraints, in addition to the time windows and minimum durations
 * already specified in the `BreakRequest`.
 *
 * A `FrequencyConstraint` may in practice apply to non-consecutive breaks.
 * For example, the following schedule honors the "1h every 12h" example:
 * ```
 *   04:00 vehicle start
 *    .. performing travel and visits ..
 *   09:00 1 hour break
 *   10:00 end of the break
 *    .. performing travel and visits ..
 *   12:00 20-min lunch break
 *   12:20 end of the break
 *    .. performing travel and visits ..
 *   21:00 1 hour break
 *   22:00 end of the break
 *    .. performing travel and visits ..
 *   23:59 vehicle end
 * ```
 */
export interface BreakRule_FrequencyConstraint {
  /**
   * Required. Minimum break duration for this constraint. Nonnegative.
   * See description of `FrequencyConstraint`.
   */
  minBreakDuration:
    | Duration
    | undefined;
  /**
   * Required. Maximum allowed span of any interval of time in the route that
   * does not include at least partially a break of `duration >=
   * min_break_duration`. Must be positive.
   */
  maxInterBreakDuration: Duration | undefined;
}

/**
 * A vehicle's route can be decomposed, along the time axis, like this (we
 * assume there are n visits):
 * ```
 *   |            |            |          |       |  T[2], |        |      |
 *   | Transition |  Visit #0  |          |       |  V[2], |        |      |
 *   |     #0     |    aka     |   T[1]   |  V[1] |  ...   | V[n-1] | T[n] |
 *   |  aka T[0]  |    V[0]    |          |       | V[n-2],|        |      |
 *   |            |            |          |       | T[n-1] |        |      |
 *   ^            ^            ^          ^       ^        ^        ^      ^
 * vehicle    V[0].start   V[0].end     V[1].   V[1].    V[n].    V[n]. vehicle
 *  start     (arrival)   (departure)   start   end      start    end     end
 * ```
 * Note that we make a difference between:
 *
 * * "punctual events", such as the vehicle start and end and each visit's start
 *   and end (aka arrival and departure). They happen at a given second.
 * * "time intervals", such as the visits themselves, and the transition between
 *   visits. Though time intervals can sometimes have zero duration, i.e. start
 *   and end at the same second, they often have a positive duration.
 *
 * Invariants:
 *
 * * If there are n visits, there are n+1 transitions.
 * * A visit is always surrounded by a transition before it (same index) and a
 *   transition after it (index + 1).
 * * The vehicle start is always followed by transition #0.
 * * The vehicle end is always preceded by transition #n.
 *
 * Zooming in, here is what happens during a `Transition` and a `Visit`:
 * ```
 * ---+-------------------------------------+-----------------------------+-->
 *    |           TRANSITION[i]             |           VISIT[i]          |
 *    |                                     |                             |
 *    |  * TRAVEL: the vehicle moves from   |      PERFORM the visit:     |
 *    |    VISIT[i-1].departure_location to |                             |
 *    |    VISIT[i].arrival_location, which |  * Spend some time:         |
 *    |    takes a given travel duration    |    the "visit duration".    |
 *    |    and distance                     |                             |
 *    |                                     |  * Load or unload           |
 *    |  * BREAKS: the driver may have      |    some quantities from the |
 *    |    breaks (e.g. lunch break).       |    vehicle: the "demand".   |
 *    |                                     |                             |
 *    |  * WAIT: the driver/vehicle does    |                             |
 *    |    nothing. This can happen for     |                             |
 *    |    many reasons, for example when   |                             |
 *    |    the vehicle reaches the next     |                             |
 *    |    event's destination before the   |                             |
 *    |    start of its time window         |                             |
 *    |                                     |                             |
 *    |  * DELAY: *right before* the next   |                             |
 *    |    arrival. E.g. the vehicle and/or |                             |
 *    |    driver spends time unloading.    |                             |
 *    |                                     |                             |
 * ---+-------------------------------------+-----------------------------+-->
 *    ^                                     ^                             ^
 * V[i-1].end                           V[i].start                    V[i].end
 * ```
 * Lastly, here is how the TRAVEL, BREAKS, DELAY and WAIT can be arranged
 * during a transition.
 *
 * * They don't overlap.
 * * The DELAY is unique and *must* be a contiguous period of time right
 *   before the next visit (or vehicle end). Thus, it suffice to know the
 *   delay duration to know its start and end time.
 * * The BREAKS are contiguous, non-overlapping periods of time. The
 *   response specifies the start time and duration of each break.
 * * TRAVEL and WAIT are "preemptable": they can be interrupted several times
 *   during this transition. Clients can assume that travel happens "as soon as
 *   possible" and that "wait" fills the remaining time.
 *
 * A (complex) example:
 * ```
 *                                TRANSITION[i]
 * --++-----+-----------------------------------------------------------++-->
 *   ||     |       |           |       |           |         |         ||
 *   ||  T  |   B   |     T     |       |     B     |         |    D    ||
 *   ||  r  |   r   |     r     |   W   |     r     |    W    |    e    ||
 *   ||  a  |   e   |     a     |   a   |     e     |    a    |    l    ||
 *   ||  v  |   a   |     v     |   i   |     a     |    i    |    a    ||
 *   ||  e  |   k   |     e     |   t   |     k     |    t    |    y    ||
 *   ||  l  |       |     l     |       |           |         |         ||
 *   ||     |       |           |       |           |         |         ||
 * --++-----------------------------------------------------------------++-->
 * ```
 */
export interface ShipmentRoute {
  /**
   * Vehicle performing the route, identified by its index in the source
   * `ShipmentModel`.
   */
  vehicleIndex: number;
  /**
   * Label of the vehicle performing this route, equal to
   * `ShipmentModel.vehicles(vehicle_index).label`, if specified.
   */
  vehicleLabel: string;
  /** Time at which the vehicle starts its route. */
  vehicleStartTime:
    | Date
    | undefined;
  /** Time at which the vehicle finishes its route. */
  vehicleEndTime:
    | Date
    | undefined;
  /**
   * Ordered sequence of visits representing a route.
   * visits[i] is the i-th visit in the route.
   * If this field is empty, the vehicle is considered as unused.
   */
  visits: ShipmentRoute_Visit[];
  /** Ordered list of transitions for the route. */
  transitions: ShipmentRoute_Transition[];
  /**
   * When
   * [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * is set to true, this field indicates that inconsistencies in route timings
   * are predicted using traffic-based travel duration estimates. There may be
   * insufficient time to complete traffic-adjusted travel, delays, and breaks
   * between visits, before the first visit, or after the last visit, while
   * still satisfying the visit and vehicle time windows. For example,
   *
   * ```
   *   start_time(previous_visit) + duration(previous_visit) +
   *   travel_duration(previous_visit, next_visit) > start_time(next_visit)
   * ```
   *
   * Arrival at next_visit will likely happen later than its current
   * time window due the increased estimate of travel time
   * `travel_duration(previous_visit, next_visit)` due to traffic. Also, a break
   * may be forced to overlap with a visit due to an increase in travel time
   * estimates and visit or break time window restrictions.
   */
  hasTrafficInfeasibilities: boolean;
  /**
   * The encoded polyline representation of the route.
   * This field is only populated if
   * [OptimizeToursRequest.populate_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_polylines]
   * is set to true.
   */
  routePolyline:
    | ShipmentRoute_EncodedPolyline
    | undefined;
  /**
   * Breaks scheduled for the vehicle performing this route.
   * The `breaks` sequence represents time intervals, each starting at the
   * corresponding `start_time` and lasting `duration` seconds.
   */
  breaks: ShipmentRoute_Break[];
  /**
   * Duration, distance and load metrics for this route. The fields of
   * [AggregatedMetrics][google.cloud.optimization.v1.AggregatedMetrics] are
   * summed over all
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * or
   * [ShipmentRoute.visits][google.cloud.optimization.v1.ShipmentRoute.visits],
   * depending on the context.
   */
  metrics:
    | AggregatedMetrics
    | undefined;
  /**
   * Cost of the route, broken down by cost-related request fields.
   * The keys are proto paths, relative to the input OptimizeToursRequest, e.g.
   * "model.shipments.pickups.cost", and the values are the total cost
   * generated by the corresponding cost field, aggregated over the whole route.
   * In other words, costs["model.shipments.pickups.cost"] is the sum of all
   * pickup costs over the route. All costs defined in the model are reported in
   * detail here with the exception of costs related to TransitionAttributes
   * that are only reported in an aggregated way as of 2022/01.
   */
  routeCosts: { [key: string]: number };
  /** Total cost of the route. The sum of all costs in the cost map. */
  routeTotalCost: number;
  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead. Vehicle loads upon arrival at its end location, for each type
   * specified in
   * [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities],
   * `start_load_intervals`, `end_load_intervals` or demands. Exception: we omit
   * loads for quantity types unconstrained by intervals and that don't have any
   * non-zero demand on the route.
   *
   * @deprecated
   */
  endLoads: CapacityQuantity[];
  /**
   * Deprecated: Use
   * [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]
   * instead. Ordered list of travel steps for the route.
   *
   * @deprecated
   */
  travelSteps: ShipmentRoute_TravelStep[];
  /**
   * Deprecated: No longer used.
   * This field will only be populated at the
   * [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit]
   * level.
   *
   * This field is the extra detour time due to the shipments visited on the
   * route.
   *
   * It is equal to `vehicle_end_time` - `vehicle_start_time` - travel duration
   * from the vehicle's start_location to its `end_location`.
   *
   * @deprecated
   */
  vehicleDetour:
    | Duration
    | undefined;
  /**
   * Deprecated: Delay occurring before the vehicle end. See
   * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
   *
   * @deprecated
   */
  delayBeforeVehicleEnd: ShipmentRoute_Delay | undefined;
}

/**
 * Deprecated: Use
 * [ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration]
 * instead. Time interval spent on the route resulting from a
 * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
 *
 * @deprecated
 */
export interface ShipmentRoute_Delay {
  /** Start of the delay. */
  startTime:
    | Date
    | undefined;
  /** Duration of the delay. */
  duration: Duration | undefined;
}

/**
 * A visit performed during a route. This visit corresponds to a pickup or a
 * delivery of a `Shipment`.
 */
export interface ShipmentRoute_Visit {
  /**
   * Index of the `shipments` field in the source
   * [ShipmentModel][google.cloud.optimization.v1.ShipmentModel].
   */
  shipmentIndex: number;
  /**
   * If true the visit corresponds to a pickup of a `Shipment`. Otherwise, it
   * corresponds to a delivery.
   */
  isPickup: boolean;
  /**
   * Index of `VisitRequest` in either the pickup or delivery field of the
   * `Shipment` (see `is_pickup`).
   */
  visitRequestIndex: number;
  /**
   * Time at which the visit starts. Note that the vehicle may arrive earlier
   * than this at the visit location. Times are consistent with the
   * `ShipmentModel`.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Total visit load demand as the sum of the shipment and the visit request
   * `load_demands`. The values are negative if the visit is a delivery.
   * Demands are reported for the same types as the
   * [Transition.loads][google.cloud.optimization.v1.ShipmentRoute.Transition]
   * (see this field).
   */
  loadDemands: { [key: string]: Shipment_Load };
  /**
   * Extra detour time due to the shipments visited on the route before the
   * visit and to the potential waiting time induced by time windows.
   * If the visit is a delivery, the detour is computed from the corresponding
   * pickup visit and is equal to:
   * ```
   * start_time(delivery) - start_time(pickup)
   * - (duration(pickup) + travel duration from the pickup location
   * to the delivery location).
   * ```
   * Otherwise, it is computed from the vehicle `start_location` and is equal
   * to:
   * ```
   * start_time - vehicle_start_time - travel duration from
   * the vehicle's `start_location` to the visit.
   * ```
   */
  detour:
    | Duration
    | undefined;
  /**
   * Copy of the corresponding `Shipment.label`, if specified in the
   * `Shipment`.
   */
  shipmentLabel: string;
  /**
   * Copy of the corresponding
   * [VisitRequest.label][google.cloud.optimization.v1.Shipment.VisitRequest.label],
   * if specified in the `VisitRequest`.
   */
  visitLabel: string;
  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead. Vehicle loads upon arrival at the visit location, for each type
   * specified in
   * [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities],
   * `start_load_intervals`, `end_load_intervals` or `demands`.
   *
   * Exception: we omit loads for quantity types unconstrained by intervals
   * and that don't have any non-zero demand on the route.
   *
   * @deprecated
   */
  arrivalLoads: CapacityQuantity[];
  /**
   * Deprecated: Use
   * [ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration]
   * instead. Delay occurring before the visit starts.
   *
   * @deprecated
   */
  delayBeforeStart:
    | ShipmentRoute_Delay
    | undefined;
  /**
   * Deprecated: Use
   * [Visit.load_demands][google.cloud.optimization.v1.ShipmentRoute.Visit.load_demands]
   * instead.
   *
   * @deprecated
   */
  demands: CapacityQuantity[];
}

export interface ShipmentRoute_Visit_LoadDemandsEntry {
  key: string;
  value: Shipment_Load | undefined;
}

/**
 * Transition between two events on the route. See the description of
 * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute].
 *
 * If the vehicle does not have a `start_location` and/or `end_location`, the
 * corresponding travel metrics are 0.
 */
export interface ShipmentRoute_Transition {
  /** Travel duration during this transition. */
  travelDuration:
    | Duration
    | undefined;
  /** Distance traveled during the transition. */
  travelDistanceMeters: number;
  /**
   * When traffic is requested via
   * [OptimizeToursRequest.consider_road_traffic]
   * [google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * and the traffic info couldn't be retrieved for a `Transition`, this
   * boolean is set to true. This may be temporary (rare hiccup in the
   * realtime traffic servers) or permanent (no data for this location).
   */
  trafficInfoUnavailable: boolean;
  /**
   * Sum of the delay durations applied to this transition. If any, the delay
   * starts exactly `delay_duration` seconds before the next event (visit or
   * vehicle end). See
   * [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].
   */
  delayDuration:
    | Duration
    | undefined;
  /**
   * Sum of the duration of the breaks occurring during this transition, if
   * any. Details about each break's start time and duration are stored in
   * [ShipmentRoute.breaks][google.cloud.optimization.v1.ShipmentRoute.breaks].
   */
  breakDuration:
    | Duration
    | undefined;
  /**
   * Time spent waiting during this transition. Wait duration corresponds to
   * idle time and does not include break time. Also note that this wait time
   * may be split into several non-contiguous intervals.
   */
  waitDuration:
    | Duration
    | undefined;
  /**
   * Total duration of the transition, provided for convenience. It is equal
   * to:
   *
   * * next visit `start_time` (or `vehicle_end_time` if this is the last
   * transition) - this transition's `start_time`;
   * * if `ShipmentRoute.has_traffic_infeasibilities` is false, the following
   * additionally holds: `total_duration = travel_duration + delay_duration
   * + break_duration + wait_duration`.
   */
  totalDuration:
    | Duration
    | undefined;
  /** Start time of this transition. */
  startTime:
    | Date
    | undefined;
  /**
   * The encoded polyline representation of the route followed during the
   * transition.
   * This field is only populated if [populate_transition_polylines]
   * [google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines]
   * is set to true.
   */
  routePolyline:
    | ShipmentRoute_EncodedPolyline
    | undefined;
  /**
   * Vehicle loads during this transition, for each type that either appears
   * in this vehicle's
   * [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits],
   * or that have non-zero
   * [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]
   * on some shipment performed on this route.
   *
   * The loads during the first transition are the starting loads of the
   * vehicle route. Then, after each visit, the visit's `load_demands` are
   * either added or subtracted to get the next transition's loads, depending
   * on whether the visit was a pickup or a delivery.
   */
  vehicleLoads: { [key: string]: ShipmentRoute_VehicleLoad };
  /**
   * Deprecated: Use
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * instead.
   *
   * @deprecated
   */
  loads: CapacityQuantity[];
}

export interface ShipmentRoute_Transition_VehicleLoadsEntry {
  key: string;
  value: ShipmentRoute_VehicleLoad | undefined;
}

/**
 * Reports the actual load of the vehicle at some point along the route,
 * for a given type (see
 * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]).
 */
export interface ShipmentRoute_VehicleLoad {
  /**
   * The amount of load on the vehicle, for the given type. The unit of load
   * is usually indicated by the type. See
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads].
   */
  amount: Long;
}

/**
 * The encoded representation of a polyline. More information on polyline
 * encoding can be found here:
 * https://developers.google.com/maps/documentation/utilities/polylinealgorithm
 * https://developers.google.com/maps/documentation/javascript/reference/geometry#encoding.
 */
export interface ShipmentRoute_EncodedPolyline {
  /** String representing encoded points of the polyline. */
  points: string;
}

/** Data representing the execution of a break. */
export interface ShipmentRoute_Break {
  /** Start time of a break. */
  startTime:
    | Date
    | undefined;
  /** Duration of a break. */
  duration: Duration | undefined;
}

/**
 * Deprecated: Use
 * [ShipmentRoute.Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]
 * instead. Travel between each visit along the route: from the vehicle's
 * `start_location` to the first visit's `arrival_location`, then from the
 * first visit's `departure_location` to the second visit's
 * `arrival_location`, and so on until the vehicle's `end_location`. This
 * accounts only for the actual travel between visits, not counting the
 * waiting time, the time spent performing a visit, nor the distance covered
 * during a visit.
 *
 * Invariant: `travel_steps_size() == visits_size() + 1`.
 *
 * If the vehicle does not have a start_ and/or end_location, the
 * corresponding travel metrics are 0 and/or empty.
 *
 * @deprecated
 */
export interface ShipmentRoute_TravelStep {
  /** Duration of the travel step. */
  duration:
    | Duration
    | undefined;
  /** Distance traveled during the step. */
  distanceMeters: number;
  /**
   * When traffic is requested via
   * [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],
   * and the traffic info couldn't be retrieved for a TravelStep, this boolean
   * is set to true. This may be temporary (rare hiccup in the realtime
   * traffic servers) or permanent (no data for this location).
   */
  trafficInfoUnavailable: boolean;
  /**
   * The encoded polyline representation of the route followed during the
   * step.
   *
   * This field is only populated if
   * [OptimizeToursRequest.populate_travel_step_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_travel_step_polylines]
   * is set to true.
   */
  routePolyline: ShipmentRoute_EncodedPolyline | undefined;
}

export interface ShipmentRoute_RouteCostsEntry {
  key: string;
  value: number;
}

/**
 * Specifies details of unperformed shipments in a solution. For trivial cases
 * and/or if we are able to identify the cause for skipping, we report the
 * reason here.
 */
export interface SkippedShipment {
  /**
   * The index corresponds to the index of the shipment in the source
   * `ShipmentModel`.
   */
  index: number;
  /**
   * Copy of the corresponding
   * [Shipment.label][google.cloud.optimization.v1.Shipment.label], if specified
   * in the `Shipment`.
   */
  label: string;
  /**
   * A list of reasons that explain why the shipment was skipped. See comment
   * above `Reason`.
   */
  reasons: SkippedShipment_Reason[];
}

/**
 * If we can explain why the shipment was skipped, reasons will be listed
 * here. If the reason is not the same for all vehicles, `reason` will have
 * more than 1 element. A skipped shipment cannot have duplicate reasons,
 * i.e. where all fields are the same except for `example_vehicle_index`.
 * Example:
 * ```
 * reasons {
 *   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
 *   example_vehicle_index: 1
 *   example_exceeded_capacity_type: "Apples"
 * }
 * reasons {
 *   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
 *   example_vehicle_index: 3
 *   example_exceeded_capacity_type: "Pears"
 * }
 * reasons {
 *   code: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT
 *   example_vehicle_index: 1
 * }
 * ```
 * The skipped shipment is incompatible with all vehicles. The reasons may
 * be different for all vehicles but at least one vehicle's "Apples"
 * capacity would be exceeded (including vehicle 1), at least one vehicle's
 * "Pears" capacity would be exceeded (including vehicle 3) and at least one
 * vehicle's distance limit would be exceeded (including vehicle 1).
 */
export interface SkippedShipment_Reason {
  /** Refer to the comments of Code. */
  code: SkippedShipment_Reason_Code;
  /**
   * If the reason is related to a shipment-vehicle incompatibility, this
   * field provides the index of one relevant vehicle.
   */
  exampleVehicleIndex?:
    | number
    | undefined;
  /**
   * If the reason code is `DEMAND_EXCEEDS_VEHICLE_CAPACITY`, documents one
   * capacity type that is exceeded.
   */
  exampleExceededCapacityType: string;
}

/**
 * Code identifying the reason type. The order here is meaningless. In
 * particular, it gives no indication of whether a given reason will
 * appear before another in the solution, if both apply.
 */
export enum SkippedShipment_Reason_Code {
  /**
   * CODE_UNSPECIFIED - This should never be used. If we are unable to understand why a
   * shipment was skipped, we simply return an empty set of reasons.
   */
  CODE_UNSPECIFIED = 0,
  /** NO_VEHICLE - There is no vehicle in the model making all shipments infeasible. */
  NO_VEHICLE = 1,
  /**
   * DEMAND_EXCEEDS_VEHICLE_CAPACITY - The demand of the shipment exceeds a vehicle's capacity for some
   * capacity types, one of which is `example_exceeded_capacity_type`.
   */
  DEMAND_EXCEEDS_VEHICLE_CAPACITY = 2,
  /**
   * CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT - The minimum distance necessary to perform this shipment, i.e. from
   * the vehicle's `start_location` to the shipment's pickup and/or delivery
   * locations and to the vehicle's end location exceeds the vehicle's
   * `route_distance_limit`.
   *
   * Note that for this computation we use the geodesic distances.
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT = 3,
  /**
   * CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT - The minimum time necessary to perform this shipment, including travel
   * time, wait time and service time exceeds the vehicle's
   * `route_duration_limit`.
   *
   * Note: travel time is computed in the best-case scenario, namely as
   * geodesic distance x 36 m/s (roughly 130 km/hour).
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT = 4,
  /**
   * CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT - Same as above but we only compare minimum travel time and the
   * vehicle's `travel_duration_limit`.
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT = 5,
  /**
   * CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS - The vehicle cannot perform this shipment in the best-case scenario
   * (see `CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT` for time
   * computation) if it starts at its earliest start time: the total time
   * would make the vehicle end after its latest end time.
   */
  CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS = 6,
  /**
   * VEHICLE_NOT_ALLOWED - The `allowed_vehicle_indices` field of the shipment is not empty and
   * this vehicle does not belong to it.
   */
  VEHICLE_NOT_ALLOWED = 7,
  UNRECOGNIZED = -1,
}

export function skippedShipment_Reason_CodeFromJSON(object: any): SkippedShipment_Reason_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return SkippedShipment_Reason_Code.CODE_UNSPECIFIED;
    case 1:
    case "NO_VEHICLE":
      return SkippedShipment_Reason_Code.NO_VEHICLE;
    case 2:
    case "DEMAND_EXCEEDS_VEHICLE_CAPACITY":
      return SkippedShipment_Reason_Code.DEMAND_EXCEEDS_VEHICLE_CAPACITY;
    case 3:
    case "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT":
      return SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT;
    case 4:
    case "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT":
      return SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT;
    case 5:
    case "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT":
      return SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT;
    case 6:
    case "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS":
      return SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS;
    case 7:
    case "VEHICLE_NOT_ALLOWED":
      return SkippedShipment_Reason_Code.VEHICLE_NOT_ALLOWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SkippedShipment_Reason_Code.UNRECOGNIZED;
  }
}

export function skippedShipment_Reason_CodeToJSON(object: SkippedShipment_Reason_Code): string {
  switch (object) {
    case SkippedShipment_Reason_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case SkippedShipment_Reason_Code.NO_VEHICLE:
      return "NO_VEHICLE";
    case SkippedShipment_Reason_Code.DEMAND_EXCEEDS_VEHICLE_CAPACITY:
      return "DEMAND_EXCEEDS_VEHICLE_CAPACITY";
    case SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT:
      return "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT";
    case SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT:
      return "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT";
    case SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT:
      return "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT";
    case SkippedShipment_Reason_Code.CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS:
      return "CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS";
    case SkippedShipment_Reason_Code.VEHICLE_NOT_ALLOWED:
      return "VEHICLE_NOT_ALLOWED";
    case SkippedShipment_Reason_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Aggregated metrics for
 * [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute] (resp. for
 * [OptimizeToursResponse][google.cloud.optimization.v1.OptimizeToursResponse]
 * over all [Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]
 * and/or [Visit][google.cloud.optimization.v1.ShipmentRoute.Visit] (resp. over
 * all [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute]) elements.
 */
export interface AggregatedMetrics {
  /**
   * Number of shipments performed. Note that a pickup and delivery pair only
   * counts once.
   */
  performedShipmentCount: number;
  /** Total travel duration for a route or a solution. */
  travelDuration:
    | Duration
    | undefined;
  /** Total wait duration for a route or a solution. */
  waitDuration:
    | Duration
    | undefined;
  /** Total delay duration for a route or a solution. */
  delayDuration:
    | Duration
    | undefined;
  /** Total break duration for a route or a solution. */
  breakDuration:
    | Duration
    | undefined;
  /** Total visit duration for a route or a solution. */
  visitDuration:
    | Duration
    | undefined;
  /**
   * The total duration should be equal to the sum of all durations above.
   * For routes, it also corresponds to:
   * [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time]
   * `-`
   * [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time]
   */
  totalDuration:
    | Duration
    | undefined;
  /** Total travel distance for a route or a solution. */
  travelDistanceMeters: number;
  /**
   * Maximum load achieved over the entire route (resp. solution), for each of
   * the quantities on this route (resp. solution), computed as the maximum over
   * all
   * [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]
   * (resp.
   * [ShipmentRoute.metrics.max_loads][google.cloud.optimization.v1.AggregatedMetrics.max_loads].
   */
  maxLoads: { [key: string]: ShipmentRoute_VehicleLoad };
  /**
   * Deprecated: Use
   * [ShipmentRoute.route_costs][google.cloud.optimization.v1.ShipmentRoute.route_costs]
   * and
   * [OptimizeToursResponse.Metrics.costs][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.costs]
   * instead.
   *
   * @deprecated
   */
  costs: { [key: string]: number };
  /**
   * Deprecated: Use
   * [ShipmentRoute.route_total_cost][google.cloud.optimization.v1.ShipmentRoute.route_total_cost]
   * and
   * [OptimizeToursResponse.Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost]
   * instead.
   *
   * @deprecated
   */
  totalCost: number;
}

export interface AggregatedMetrics_MaxLoadsEntry {
  key: string;
  value: ShipmentRoute_VehicleLoad | undefined;
}

export interface AggregatedMetrics_CostsEntry {
  key: string;
  value: number;
}

/**
 * Solution injected in the request including information about which visits
 * must be constrained and how they must be constrained.
 */
export interface InjectedSolutionConstraint {
  /**
   * Routes of the solution to inject. Some routes may be omitted from the
   * original solution. The routes and skipped shipments must satisfy the basic
   * validity assumptions listed for `injected_first_solution_routes`.
   */
  routes: ShipmentRoute[];
  /**
   * Skipped shipments of the solution to inject. Some may be omitted from the
   * original solution. See the `routes` field.
   */
  skippedShipments: SkippedShipment[];
  /**
   * For zero or more groups of vehicles, specifies when and how much to relax
   * constraints. If this field is empty, all non-empty vehicle routes are
   * fully constrained.
   */
  constraintRelaxations: InjectedSolutionConstraint_ConstraintRelaxation[];
}

/**
 * For a group of vehicles, specifies at what threshold(s) constraints on
 * visits will be relaxed and to which level. Shipments listed in
 * the `skipped_shipment` field are constrained to be skipped; i.e., they
 * cannot be performed.
 */
export interface InjectedSolutionConstraint_ConstraintRelaxation {
  /**
   * All the visit constraint relaxations that will apply to visits on
   * routes with vehicles in `vehicle_indices`.
   */
  relaxations: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation[];
  /**
   * Specifies the vehicle indices to which the visit constraint
   * `relaxations` apply. If empty, this is considered the default and the
   * `relaxations` apply to all vehicles that are not specified in other
   * `constraint_relaxations`. There can be at most one default, i.e., at
   * most one constraint relaxation field is allowed empty
   * `vehicle_indices`. A vehicle index can only be listed once, even within
   * several `constraint_relaxations`.
   *
   * A vehicle index is mapped the same as
   * [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index],
   * if `interpret_injected_solutions_using_labels` is true (see `fields`
   * comment).
   */
  vehicleIndices: number[];
}

/**
 * If `relaxations` is empty, the start time and sequence of all visits
 * on `routes` are fully constrained and no new visits may be inserted or
 * added to those routes. Also, a vehicle's start and end time in
 * `routes` is fully constrained, unless the vehicle is empty (i.e., has no
 * visits and has `used_if_route_is_empty` set to false in the model).
 *
 * `relaxations(i).level` specifies the constraint relaxation level applied
 * to a visit #j that satisfies:
 *
 *   * `route.visits(j).start_time >= relaxations(i).threshold_time` AND
 *   * `j + 1 >= relaxations(i).threshold_visit_count`
 *
 * Similarly, the vehicle start is relaxed to `relaxations(i).level` if it
 * satisfies:
 *
 *   * `vehicle_start_time >= relaxations(i).threshold_time` AND
 *   * `relaxations(i).threshold_visit_count == 0`
 * and the vehicle end is relaxed to `relaxations(i).level` if it satisfies:
 *   * `vehicle_end_time >= relaxations(i).threshold_time` AND
 *   * `route.visits_size() + 1 >= relaxations(i).threshold_visit_count`
 *
 * To apply a relaxation level if a visit meets the `threshold_visit_count`
 * OR the `threshold_time` add two `relaxations` with the same `level`:
 * one with only `threshold_visit_count` set and the other with only
 * `threshold_time` set. If a visit satisfies the conditions of multiple
 * `relaxations`, the most relaxed level applies. As a result, from the
 * vehicle start through the route visits in order to the vehicle end, the
 * relaxation level becomes more relaxed: i.e., the relaxation level is
 * non-decreasing as the route progresses.
 *
 * The timing and sequence of route visits that do not satisfy the
 * threshold conditions of any `relaxations` are fully constrained
 * and no visits may be inserted into these sequences. Also, if a
 * vehicle start or end does not satisfy the conditions of any
 * relaxation the time is fixed, unless the vehicle is empty.
 */
export interface InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
  /**
   * The constraint relaxation level that applies when the conditions
   * at or after `threshold_time` AND at least `threshold_visit_count` are
   * satisfied.
   */
  level: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level;
  /** The time at or after which the relaxation `level` may be applied. */
  thresholdTime:
    | Date
    | undefined;
  /**
   * The number of visits at or after which the relaxation `level` may be
   * applied. If `threshold_visit_count` is 0 (or unset), the `level` may be
   * applied directly at the vehicle start.
   *
   * If it is `route.visits_size() + 1`, the `level` may only be applied to
   * the vehicle end. If it is more than `route.visits_size() + 1`,
   * `level` is not applied at all for that route.
   */
  thresholdVisitCount: number;
}

/**
 * Expresses the different constraint relaxation levels, which are
 * applied for a visit and those that follow when it satisfies the
 * threshold conditions.
 *
 * The enumeration below is in order of increasing relaxation.
 */
export enum InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level {
  /**
   * LEVEL_UNSPECIFIED - Implicit default relaxation level: no constraints are relaxed,
   * i.e., all visits are fully constrained.
   *
   * This value must not be explicitly used in `level`.
   */
  LEVEL_UNSPECIFIED = 0,
  /**
   * RELAX_VISIT_TIMES_AFTER_THRESHOLD - Visit start times and vehicle start/end times will be relaxed, but
   * each visit remains bound to the same vehicle and the visit sequence
   * must be observed: no visit can be inserted between them or before
   * them.
   */
  RELAX_VISIT_TIMES_AFTER_THRESHOLD = 1,
  /**
   * RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD - Same as `RELAX_VISIT_TIMES_AFTER_THRESHOLD`, but the visit sequence
   * is also relaxed: visits can only be performed by this vehicle, but
   * can potentially become unperformed.
   */
  RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD = 2,
  /**
   * RELAX_ALL_AFTER_THRESHOLD - Same as `RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD`, but the
   * vehicle is also relaxed: visits are completely free at or after the
   * threshold time and can potentially become unperformed.
   */
  RELAX_ALL_AFTER_THRESHOLD = 3,
  UNRECOGNIZED = -1,
}

export function injectedSolutionConstraint_ConstraintRelaxation_Relaxation_LevelFromJSON(
  object: any,
): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level {
  switch (object) {
    case 0:
    case "LEVEL_UNSPECIFIED":
      return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.LEVEL_UNSPECIFIED;
    case 1:
    case "RELAX_VISIT_TIMES_AFTER_THRESHOLD":
      return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.RELAX_VISIT_TIMES_AFTER_THRESHOLD;
    case 2:
    case "RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD":
      return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level
        .RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD;
    case 3:
    case "RELAX_ALL_AFTER_THRESHOLD":
      return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.RELAX_ALL_AFTER_THRESHOLD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.UNRECOGNIZED;
  }
}

export function injectedSolutionConstraint_ConstraintRelaxation_Relaxation_LevelToJSON(
  object: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level,
): string {
  switch (object) {
    case InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.LEVEL_UNSPECIFIED:
      return "LEVEL_UNSPECIFIED";
    case InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.RELAX_VISIT_TIMES_AFTER_THRESHOLD:
      return "RELAX_VISIT_TIMES_AFTER_THRESHOLD";
    case InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level
      .RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD:
      return "RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD";
    case InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.RELAX_ALL_AFTER_THRESHOLD:
      return "RELAX_ALL_AFTER_THRESHOLD";
    case InjectedSolutionConstraint_ConstraintRelaxation_Relaxation_Level.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes an error encountered when validating an `OptimizeToursRequest`. */
export interface OptimizeToursValidationError {
  /**
   * A validation error is defined by the pair (`code`, `display_name`) which
   * are always present.
   *
   * Other fields (below) provide more context about the error.
   *
   * *MULTIPLE ERRORS*:
   * When there are multiple errors, the validation process tries to output
   * several of them. Much like a compiler, this is an imperfect process. Some
   * validation errors will be "fatal", meaning that they stop the entire
   * validation process. This is the case for `display_name="UNSPECIFIED"`
   * errors, among others. Some may cause the validation process to skip other
   * errors.
   *
   * *STABILITY*:
   * `code` and `display_name` should be very stable. But new codes and
   * display names may appear over time, which may cause a given (invalid)
   * request to yield a different (`code`, `display_name`) pair because the new
   * error hid the old one (see "MULTIPLE ERRORS").
   *
   * *REFERENCE*: A list of all (code, name) pairs:
   *
   * * UNSPECIFIED = 0;
   * * VALIDATION_TIMEOUT_ERROR = 10; Validation couldn't be completed within
   * the deadline.
   *
   * * REQUEST_OPTIONS_ERROR = 12;
   *     * REQUEST_OPTIONS_INVALID_SOLVING_MODE = 1201;
   *     * REQUEST_OPTIONS_INVALID_MAX_VALIDATION_ERRORS = 1203;
   *     * REQUEST_OPTIONS_INVALID_GEODESIC_METERS_PER_SECOND = 1204;
   *     * REQUEST_OPTIONS_GEODESIC_METERS_PER_SECOND_TOO_SMALL = 1205;
   *     * REQUEST_OPTIONS_MISSING_GEODESIC_METERS_PER_SECOND = 1206;
   *     * REQUEST_OPTIONS_POPULATE_PATHFINDER_TRIPS_AND_GEODESIC_DISTANCE
   *       = 1207;
   *     * REQUEST_OPTIONS_COST_MODEL_OPTIONS_AND_GEODESIC_DISTANCE = 1208;
   *     * REQUEST_OPTIONS_TRAVEL_MODE_INCOMPATIBLE_WITH_TRAFFIC = 1211;
   *     * REQUEST_OPTIONS_MULTIPLE_TRAFFIC_FLAVORS = 1212;
   *     * REQUEST_OPTIONS_INVALID_TRAFFIC_FLAVOR = 1213;
   *     * REQUEST_OPTIONS_TRAFFIC_ENABLED_WITHOUT_GLOBAL_START_TIME = 1214;
   *     * REQUEST_OPTIONS_TRAFFIC_ENABLED_WITH_PRECEDENCES = 1215;
   *     * REQUEST_OPTIONS_TRAFFIC_PREFILL_MODE_INVALID = 1216;
   *     * REQUEST_OPTIONS_TRAFFIC_PREFILL_ENABLED_WITHOUT_TRAFFIC = 1217;
   * * INJECTED_SOLUTION_ERROR = 20;
   *     * INJECTED_SOLUTION_MISSING_LABEL = 2000;
   *     * INJECTED_SOLUTION_DUPLICATE_LABEL = 2001;
   *     * INJECTED_SOLUTION_AMBIGUOUS_INDEX = 2002;
   *     * INJECTED_SOLUTION_INFEASIBLE_AFTER_GETTING_TRAVEL_TIMES = 2003;
   *     * INJECTED_SOLUTION_TRANSITION_INCONSISTENT_WITH_ACTUAL_TRAVEL = 2004;
   *     * INJECTED_SOLUTION_CONCURRENT_SOLUTION_TYPES = 2005;
   *     * INJECTED_SOLUTION_MORE_THAN_ONE_PER_TYPE = 2006;
   *     * INJECTED_SOLUTION_REFRESH_WITHOUT_POPULATE = 2008;
   *     * INJECTED_SOLUTION_CONSTRAINED_ROUTE_PORTION_INFEASIBLE = 2010;
   * * SHIPMENT_MODEL_ERROR = 22;
   *     * SHIPMENT_MODEL_TOO_LARGE = 2200;
   *     * SHIPMENT_MODEL_TOO_MANY_CAPACITY_TYPES = 2201;
   *     * SHIPMENT_MODEL_GLOBAL_START_TIME_NEGATIVE_OR_NAN = 2202;
   *     * SHIPMENT_MODEL_GLOBAL_END_TIME_TOO_LARGE_OR_NAN = 2203;
   *     * SHIPMENT_MODEL_GLOBAL_START_TIME_AFTER_GLOBAL_END_TIME = 2204;
   *     * SHIPMENT_MODEL_GLOBAL_DURATION_TOO_LONG = 2205;
   *     * SHIPMENT_MODEL_MAX_ACTIVE_VEHICLES_NOT_POSITIVE = 2206;
   *     * SHIPMENT_MODEL_DURATION_MATRIX_TOO_LARGE = 2207;
   * * INDEX_ERROR = 24;
   * * TAG_ERROR = 26;
   * * TIME_WINDOW_ERROR = 28;
   *     * TIME_WINDOW_INVALID_START_TIME = 2800;
   *     * TIME_WINDOW_INVALID_END_TIME = 2801;
   *     * TIME_WINDOW_INVALID_SOFT_START_TIME = 2802;
   *     * TIME_WINDOW_INVALID_SOFT_END_TIME = 2803;
   *     * TIME_WINDOW_OUTSIDE_GLOBAL_TIME_WINDOW = 2804;
   *     * TIME_WINDOW_START_TIME_AFTER_END_TIME = 2805;
   *     * TIME_WINDOW_INVALID_COST_PER_HOUR_BEFORE_SOFT_START_TIME = 2806;
   *     * TIME_WINDOW_INVALID_COST_PER_HOUR_AFTER_SOFT_END_TIME = 2807;
   *     * TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_WITHOUT_SOFT_START_TIME
   *       = 2808;
   *     * TIME_WINDOW_COST_AFTER_SOFT_END_TIME_WITHOUT_SOFT_END_TIME = 2809;
   *     * TIME_WINDOW_SOFT_START_TIME_WITHOUT_COST_BEFORE_SOFT_START_TIME
   *       = 2810;
   *     * TIME_WINDOW_SOFT_END_TIME_WITHOUT_COST_AFTER_SOFT_END_TIME = 2811;
   *     * TIME_WINDOW_OVERLAPPING_ADJACENT_OR_EARLIER_THAN_PREVIOUS = 2812;
   *     * TIME_WINDOW_START_TIME_AFTER_SOFT_START_TIME = 2813;
   *     * TIME_WINDOW_SOFT_START_TIME_AFTER_END_TIME = 2814;
   *     * TIME_WINDOW_START_TIME_AFTER_SOFT_END_TIME = 2815;
   *     * TIME_WINDOW_SOFT_END_TIME_AFTER_END_TIME = 2816;
   *     * TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_SET_AND_MULTIPLE_WINDOWS
   *       = 2817;
   *     * TIME_WINDOW_COST_AFTER_SOFT_END_TIME_SET_AND_MULTIPLE_WINDOWS = 2818;
   *     * TRANSITION_ATTRIBUTES_ERROR = 30;
   *     * TRANSITION_ATTRIBUTES_INVALID_COST = 3000;
   *     * TRANSITION_ATTRIBUTES_INVALID_COST_PER_KILOMETER = 3001;
   *     * TRANSITION_ATTRIBUTES_DUPLICATE_TAG_PAIR = 3002;
   *     * TRANSITION_ATTRIBUTES_DISTANCE_LIMIT_MAX_METERS_UNSUPPORTED = 3003;
   *     * TRANSITION_ATTRIBUTES_UNSPECIFIED_SOURCE_TAGS = 3004;
   *     * TRANSITION_ATTRIBUTES_CONFLICTING_SOURCE_TAGS_FIELDS = 3005;
   *     * TRANSITION_ATTRIBUTES_UNSPECIFIED_DESTINATION_TAGS = 3006;
   *     * TRANSITION_ATTRIBUTES_CONFLICTING_DESTINATION_TAGS_FIELDS = 3007;
   *     * TRANSITION_ATTRIBUTES_DELAY_DURATION_NEGATIVE_OR_NAN = 3008;
   *     * TRANSITION_ATTRIBUTES_DELAY_DURATION_EXCEEDS_GLOBAL_DURATION = 3009;
   * * AMOUNT_ERROR = 31;
   *     * AMOUNT_NEGATIVE_VALUE = 3100;
   * * LOAD_LIMIT_ERROR = 33;
   *     * LOAD_LIMIT_INVALID_COST_ABOVE_SOFT_MAX = 3303;
   *     * LOAD_LIMIT_SOFT_MAX_WITHOUT_COST_ABOVE_SOFT_MAX = 3304;
   *     * LOAD_LIMIT_COST_ABOVE_SOFT_MAX_WITHOUT_SOFT_MAX = 3305;
   *     * LOAD_LIMIT_NEGATIVE_SOFT_MAX = 3306;
   *     * LOAD_LIMIT_MIXED_DEMAND_TYPE = 3307;
   *     * LOAD_LIMIT_MAX_LOAD_NEGATIVE_VALUE = 3308;
   *     * LOAD_LIMIT_SOFT_MAX_ABOVE_MAX = 3309;
   * * INTERVAL_ERROR = 34;
   *     * INTERVAL_MIN_EXCEEDS_MAX = 3401;
   *     * INTERVAL_NEGATIVE_MIN = 3402;
   *     * INTERVAL_NEGATIVE_MAX = 3403;
   *     * INTERVAL_MIN_EXCEEDS_CAPACITY = 3404;
   *     * INTERVAL_MAX_EXCEEDS_CAPACITY = 3405;
   * * DISTANCE_LIMIT_ERROR = 36;
   *     * DISTANCE_LIMIT_INVALID_COST_AFTER_SOFT_MAX = 3601;
   *     * DISTANCE_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3602;
   *     * DISTANCE_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3603;
   *     * DISTANCE_LIMIT_NEGATIVE_MAX = 3604;
   *     * DISTANCE_LIMIT_NEGATIVE_SOFT_MAX = 3605;
   *     * DISTANCE_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3606;
   * * DURATION_LIMIT_ERROR = 38;
   *     * DURATION_LIMIT_MAX_DURATION_NEGATIVE_OR_NAN = 3800;
   *     * DURATION_LIMIT_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3801;
   *     * DURATION_LIMIT_INVALID_COST_PER_HOUR_AFTER_SOFT_MAX = 3802;
   *     * DURATION_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3803;
   *     * DURATION_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3804;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3805;
   *     * DURATION_LIMIT_INVALID_COST_AFTER_QUADRATIC_SOFT_MAX = 3806;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_COST_PER_SQUARE_HOUR
   *       = 3807;
   *     * DURATION_LIMIT_COST_PER_SQUARE_HOUR_WITHOUT_QUADRATIC_SOFT_MAX
   *       = 3808;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_MAX = 3809;
   *     * DURATION_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3810;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_LARGER_THAN_MAX = 3811;
   *     * DURATION_LIMIT_DIFF_BETWEEN_MAX_AND_QUADRATIC_SOFT_MAX_TOO_LARGE
   *       = 3812;
   *     * DURATION_LIMIT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3813;
   *     * DURATION_LIMIT_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3814;
   *     * DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 3815;
   * * SHIPMENT_ERROR = 40;
   *     * SHIPMENT_PD_LIMIT_WITHOUT_PICKUP_AND_DELIVERY = 4014;
   *     * SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_NEGATIVE_OR_NAN = 4000;
   *     * SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 4001;
   *     * SHIPMENT_PD_RELATIVE_DETOUR_LIMIT_INVALID = 4015;
   *     * SHIPMENT_PD_DETOUR_LIMIT_AND_EXTRA_VISIT_DURATION = 4016;
   *     * SHIPMENT_PD_TIME_LIMIT_DURATION_NEGATIVE_OR_NAN = 4002;
   *     * SHIPMENT_PD_TIME_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4003;
   *     * SHIPMENT_EMPTY_SHIPMENT_TYPE = 4004;
   *     * SHIPMENT_NO_PICKUP_NO_DELIVERY = 4005;
   *     * SHIPMENT_INVALID_PENALTY_COST = 4006;
   *     * SHIPMENT_ALLOWED_VEHICLE_INDEX_OUT_OF_BOUNDS = 4007;
   *     * SHIPMENT_DUPLICATE_ALLOWED_VEHICLE_INDEX = 4008;
   *     * SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITHOUT_INDEX = 4009;
   *     * SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITH_INDEX = 4010;
   *     * SHIPMENT_INVALID_COST_FOR_VEHICLE = 4011;
   *     * SHIPMENT_COST_FOR_VEHICLE_INDEX_OUT_OF_BOUNDS = 4012;
   *     * SHIPMENT_DUPLICATE_COST_FOR_VEHICLE_INDEX = 4013;
   * * VEHICLE_ERROR = 42;
   *     * VEHICLE_EMPTY_REQUIRED_OPERATOR_TYPE = 4200;
   *     * VEHICLE_DUPLICATE_REQUIRED_OPERATOR_TYPE = 4201;
   *     * VEHICLE_NO_OPERATOR_WITH_REQUIRED_OPERATOR_TYPE = 4202;
   *     * VEHICLE_EMPTY_START_TAG = 4203;
   *     * VEHICLE_DUPLICATE_START_TAG = 4204;
   *     * VEHICLE_EMPTY_END_TAG = 4205;
   *     * VEHICLE_DUPLICATE_END_TAG = 4206;
   *     * VEHICLE_EXTRA_VISIT_DURATION_NEGATIVE_OR_NAN = 4207;
   *     * VEHICLE_EXTRA_VISIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4208;
   *     * VEHICLE_EXTRA_VISIT_DURATION_EMPTY_KEY = 4209;
   *     * VEHICLE_FIRST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4210;
   *     * VEHICLE_FIRST_SHIPMENT_IGNORED = 4211;
   *     * VEHICLE_FIRST_SHIPMENT_NOT_BOUND = 4212;
   *     * VEHICLE_LAST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4213;
   *     * VEHICLE_LAST_SHIPMENT_IGNORED = 4214;
   *     * VEHICLE_LAST_SHIPMENT_NOT_BOUND = 4215;
   *     * VEHICLE_IGNORED_WITH_USED_IF_ROUTE_IS_EMPTY = 4216;
   *     * VEHICLE_INVALID_COST_PER_KILOMETER = 4217;
   *     * VEHICLE_INVALID_COST_PER_HOUR = 4218;
   *     * VEHICLE_INVALID_COST_PER_TRAVELED_HOUR = 4219;
   *     * VEHICLE_INVALID_FIXED_COST = 4220;
   *     * VEHICLE_INVALID_TRAVEL_DURATION_MULTIPLE = 4221;
   *     * VEHICLE_TRAVEL_DURATION_MULTIPLE_WITH_SHIPMENT_PD_DETOUR_LIMITS
   *       = 4223;
   *     * VEHICLE_MATRIX_INDEX_WITH_SHIPMENT_PD_DETOUR_LIMITS = 4224;
   *     * VEHICLE_MINIMUM_DURATION_LONGER_THAN_DURATION_LIMIT = 4222;
   * * VISIT_REQUEST_ERROR = 44;
   *     * VISIT_REQUEST_EMPTY_TAG = 4400;
   *     * VISIT_REQUEST_DUPLICATE_TAG = 4401;
   *     * VISIT_REQUEST_DURATION_NEGATIVE_OR_NAN = 4404;
   *     * VISIT_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4405;
   * * PRECEDENCE_ERROR = 46;
   *     * PRECEDENCE_RULE_MISSING_FIRST_INDEX = 4600;
   *     * PRECEDENCE_RULE_MISSING_SECOND_INDEX = 4601;
   *     * PRECEDENCE_RULE_FIRST_INDEX_OUT_OF_BOUNDS = 4602;
   *     * PRECEDENCE_RULE_SECOND_INDEX_OUT_OF_BOUNDS = 4603;
   *     * PRECEDENCE_RULE_DUPLICATE_INDEX = 4604;
   *     * PRECEDENCE_RULE_INEXISTENT_FIRST_VISIT_REQUEST = 4605;
   *     * PRECEDENCE_RULE_INEXISTENT_SECOND_VISIT_REQUEST = 4606;
   * * BREAK_ERROR = 48;
   *     * BREAK_RULE_EMPTY = 4800;
   *     * BREAK_REQUEST_UNSPECIFIED_DURATION = 4801;
   *     * BREAK_REQUEST_UNSPECIFIED_EARLIEST_START_TIME = 4802;
   *     * BREAK_REQUEST_UNSPECIFIED_LATEST_START_TIME = 4803;
   *     * BREAK_REQUEST_DURATION_NEGATIVE_OR_NAN = 4804; = 4804;
   *     * BREAK_REQUEST_LATEST_START_TIME_BEFORE_EARLIEST_START_TIME = 4805;
   *     * BREAK_REQUEST_EARLIEST_START_TIME_BEFORE_GLOBAL_START_TIME = 4806;
   *     * BREAK_REQUEST_LATEST_END_TIME_AFTER_GLOBAL_END_TIME = 4807;
   *     * BREAK_REQUEST_NON_SCHEDULABLE = 4808;
   *     * BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_NEGATIVE_OR_NAN = 4809;
   *     * BREAK_FREQUENCY_MIN_BREAK_DURATION_NEGATIVE_OR_NAN = 4810;
   *     * BREAK_FREQUENCY_MIN_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION = 4811;
   *     * BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION
   *       = 4812;
   *     * BREAK_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4813;
   *     * BREAK_FREQUENCY_MISSING_MAX_INTER_BREAK_DURATION = 4814;
   *     * BREAK_FREQUENCY_MISSING_MIN_BREAK_DURATION = 4815;
   * * SHIPMENT_TYPE_INCOMPATIBILITY_ERROR = 50;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_EMPTY_TYPE = 5001;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_LESS_THAN_TWO_TYPES = 5002;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_DUPLICATE_TYPE = 5003;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_INVALID_INCOMPATIBILITY_MODE = 5004;
   *     * SHIPMENT_TYPE_INCOMPATIBILITY_TOO_MANY_INCOMPATIBILITIES = 5005;
   * * SHIPMENT_TYPE_REQUIREMENT_ERROR = 52;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE = 52001;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_DEPENDENT_TYPE = 52002;
   *     * SHIPMENT_TYPE_REQUIREMENT_INVALID_REQUIREMENT_MODE = 52003;
   *     * SHIPMENT_TYPE_REQUIREMENT_TOO_MANY_REQUIREMENTS = 52004;
   *     * SHIPMENT_TYPE_REQUIREMENT_EMPTY_REQUIRED_TYPE = 52005;
   *     * SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_REQUIRED_TYPE = 52006;
   *     * SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE_FOUND = 52007;
   *     * SHIPMENT_TYPE_REQUIREMENT_EMPTY_DEPENDENT_TYPE = 52008;
   *     * SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_DEPENDENT_TYPE = 52009;
   *     * SHIPMENT_TYPE_REQUIREMENT_SELF_DEPENDENT_TYPE = 52010;
   *     * SHIPMENT_TYPE_REQUIREMENT_GRAPH_HAS_CYCLES = 52011;
   * * VEHICLE_OPERATOR_ERROR = 54;
   *     * VEHICLE_OPERATOR_EMPTY_TYPE = 5400;
   *     * VEHICLE_OPERATOR_MULTIPLE_START_TIME_WINDOWS = 5401;
   *     * VEHICLE_OPERATOR_SOFT_START_TIME_WINDOW = 5402;
   *     * VEHICLE_OPERATOR_MULTIPLE_END_TIME_WINDOWS = 5403;
   *     * VEHICLE_OPERATOR_SOFT_END_TIME_WINDOW = 5404;
   * * DURATION_SECONDS_MATRIX_ERROR = 56;
   *     * DURATION_SECONDS_MATRIX_DURATION_NEGATIVE_OR_NAN = 5600;
   *     * DURATION_SECONDS_MATRIX_DURATION_EXCEEDS_GLOBAL_DURATION = 5601;
   */
  code: number;
  /** The error display name. */
  displayName: string;
  /**
   * An error context may involve 0, 1 (most of the time) or more fields. For
   * example, referring to vehicle #4 and shipment #2's first pickup can be
   * done as follows:
   * ```
   * fields { name: "vehicles" index: 4}
   * fields { name: "shipments" index: 2 sub_field {name: "pickups" index: 0} }
   * ```
   * Note, however, that the cardinality of `fields` should not change for a
   * given error code.
   */
  fields: OptimizeToursValidationError_FieldReference[];
  /**
   * Human-readable string describing the error. There is a 1:1 mapping
   * between `code` and `error_message` (when code != "UNSPECIFIED").
   *
   * *STABILITY*: Not stable: the error message associated to a given `code` may
   * change (hopefully to clarify it) over time. Please rely on the
   * `display_name` and `code` instead.
   */
  errorMessage: string;
  /**
   * May contain the value(s) of the field(s). This is not always available. You
   * should absolutely not rely on it and use it only for manual model
   * debugging.
   */
  offendingValues: string;
}

/**
 * Specifies a context for the validation error. A `FieldReference` always
 * refers to a given field in this file and follows the same hierarchical
 * structure. For example, we may specify element #2 of `start_time_windows`
 * of vehicle #5 using:
 * ```
 * name: "vehicles" index: 5 sub_field { name: "end_time_windows" index: 2 }
 * ```
 * We however omit top-level entities such as `OptimizeToursRequest` or
 * `ShipmentModel` to avoid crowding the message.
 */
export interface OptimizeToursValidationError_FieldReference {
  /** Name of the field, e.g., "vehicles". */
  name: string;
  /** Index of the field if repeated. */
  index?:
    | number
    | undefined;
  /** Key if the field is a map. */
  key?:
    | string
    | undefined;
  /** Recursively nested sub-field, if needed. */
  subField: OptimizeToursValidationError_FieldReference | undefined;
}

function createBaseOptimizeToursRequest(): OptimizeToursRequest {
  return {
    parent: "",
    timeout: undefined,
    model: undefined,
    solvingMode: 0,
    searchMode: 0,
    injectedFirstSolutionRoutes: [],
    injectedSolutionConstraint: undefined,
    refreshDetailsRoutes: [],
    interpretInjectedSolutionsUsingLabels: false,
    considerRoadTraffic: false,
    populatePolylines: false,
    populateTransitionPolylines: false,
    allowLargeDeadlineDespiteInterruptionRisk: false,
    useGeodesicDistances: false,
    geodesicMetersPerSecond: undefined,
    maxValidationErrors: undefined,
    label: "",
    populateTravelStepPolylines: false,
  };
}

export const OptimizeToursRequest: MessageFns<OptimizeToursRequest> = {
  encode(message: OptimizeToursRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(18).fork()).join();
    }
    if (message.model !== undefined) {
      ShipmentModel.encode(message.model, writer.uint32(26).fork()).join();
    }
    if (message.solvingMode !== 0) {
      writer.uint32(32).int32(message.solvingMode);
    }
    if (message.searchMode !== 0) {
      writer.uint32(48).int32(message.searchMode);
    }
    for (const v of message.injectedFirstSolutionRoutes) {
      ShipmentRoute.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.injectedSolutionConstraint !== undefined) {
      InjectedSolutionConstraint.encode(message.injectedSolutionConstraint, writer.uint32(66).fork()).join();
    }
    for (const v of message.refreshDetailsRoutes) {
      ShipmentRoute.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.interpretInjectedSolutionsUsingLabels !== false) {
      writer.uint32(80).bool(message.interpretInjectedSolutionsUsingLabels);
    }
    if (message.considerRoadTraffic !== false) {
      writer.uint32(88).bool(message.considerRoadTraffic);
    }
    if (message.populatePolylines !== false) {
      writer.uint32(96).bool(message.populatePolylines);
    }
    if (message.populateTransitionPolylines !== false) {
      writer.uint32(104).bool(message.populateTransitionPolylines);
    }
    if (message.allowLargeDeadlineDespiteInterruptionRisk !== false) {
      writer.uint32(112).bool(message.allowLargeDeadlineDespiteInterruptionRisk);
    }
    if (message.useGeodesicDistances !== false) {
      writer.uint32(120).bool(message.useGeodesicDistances);
    }
    if (message.geodesicMetersPerSecond !== undefined) {
      writer.uint32(129).double(message.geodesicMetersPerSecond);
    }
    if (message.maxValidationErrors !== undefined) {
      writer.uint32(40).int32(message.maxValidationErrors);
    }
    if (message.label !== "") {
      writer.uint32(138).string(message.label);
    }
    if (message.populateTravelStepPolylines !== false) {
      writer.uint32(160).bool(message.populateTravelStepPolylines);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = ShipmentModel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.solvingMode = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.searchMode = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.injectedFirstSolutionRoutes.push(ShipmentRoute.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.injectedSolutionConstraint = InjectedSolutionConstraint.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.refreshDetailsRoutes.push(ShipmentRoute.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.interpretInjectedSolutionsUsingLabels = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.considerRoadTraffic = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.populatePolylines = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.populateTransitionPolylines = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.allowLargeDeadlineDespiteInterruptionRisk = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.useGeodesicDistances = reader.bool();
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.geodesicMetersPerSecond = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxValidationErrors = reader.int32();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.label = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.populateTravelStepPolylines = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      model: isSet(object.model) ? ShipmentModel.fromJSON(object.model) : undefined,
      solvingMode: isSet(object.solvingMode) ? optimizeToursRequest_SolvingModeFromJSON(object.solvingMode) : 0,
      searchMode: isSet(object.searchMode) ? optimizeToursRequest_SearchModeFromJSON(object.searchMode) : 0,
      injectedFirstSolutionRoutes: globalThis.Array.isArray(object?.injectedFirstSolutionRoutes)
        ? object.injectedFirstSolutionRoutes.map((e: any) => ShipmentRoute.fromJSON(e))
        : [],
      injectedSolutionConstraint: isSet(object.injectedSolutionConstraint)
        ? InjectedSolutionConstraint.fromJSON(object.injectedSolutionConstraint)
        : undefined,
      refreshDetailsRoutes: globalThis.Array.isArray(object?.refreshDetailsRoutes)
        ? object.refreshDetailsRoutes.map((e: any) => ShipmentRoute.fromJSON(e))
        : [],
      interpretInjectedSolutionsUsingLabels: isSet(object.interpretInjectedSolutionsUsingLabels)
        ? globalThis.Boolean(object.interpretInjectedSolutionsUsingLabels)
        : false,
      considerRoadTraffic: isSet(object.considerRoadTraffic) ? globalThis.Boolean(object.considerRoadTraffic) : false,
      populatePolylines: isSet(object.populatePolylines) ? globalThis.Boolean(object.populatePolylines) : false,
      populateTransitionPolylines: isSet(object.populateTransitionPolylines)
        ? globalThis.Boolean(object.populateTransitionPolylines)
        : false,
      allowLargeDeadlineDespiteInterruptionRisk: isSet(object.allowLargeDeadlineDespiteInterruptionRisk)
        ? globalThis.Boolean(object.allowLargeDeadlineDespiteInterruptionRisk)
        : false,
      useGeodesicDistances: isSet(object.useGeodesicDistances)
        ? globalThis.Boolean(object.useGeodesicDistances)
        : false,
      geodesicMetersPerSecond: isSet(object.geodesicMetersPerSecond)
        ? globalThis.Number(object.geodesicMetersPerSecond)
        : undefined,
      maxValidationErrors: isSet(object.maxValidationErrors)
        ? globalThis.Number(object.maxValidationErrors)
        : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      populateTravelStepPolylines: isSet(object.populateTravelStepPolylines)
        ? globalThis.Boolean(object.populateTravelStepPolylines)
        : false,
    };
  },

  toJSON(message: OptimizeToursRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.model !== undefined) {
      obj.model = ShipmentModel.toJSON(message.model);
    }
    if (message.solvingMode !== 0) {
      obj.solvingMode = optimizeToursRequest_SolvingModeToJSON(message.solvingMode);
    }
    if (message.searchMode !== 0) {
      obj.searchMode = optimizeToursRequest_SearchModeToJSON(message.searchMode);
    }
    if (message.injectedFirstSolutionRoutes?.length) {
      obj.injectedFirstSolutionRoutes = message.injectedFirstSolutionRoutes.map((e) => ShipmentRoute.toJSON(e));
    }
    if (message.injectedSolutionConstraint !== undefined) {
      obj.injectedSolutionConstraint = InjectedSolutionConstraint.toJSON(message.injectedSolutionConstraint);
    }
    if (message.refreshDetailsRoutes?.length) {
      obj.refreshDetailsRoutes = message.refreshDetailsRoutes.map((e) => ShipmentRoute.toJSON(e));
    }
    if (message.interpretInjectedSolutionsUsingLabels !== false) {
      obj.interpretInjectedSolutionsUsingLabels = message.interpretInjectedSolutionsUsingLabels;
    }
    if (message.considerRoadTraffic !== false) {
      obj.considerRoadTraffic = message.considerRoadTraffic;
    }
    if (message.populatePolylines !== false) {
      obj.populatePolylines = message.populatePolylines;
    }
    if (message.populateTransitionPolylines !== false) {
      obj.populateTransitionPolylines = message.populateTransitionPolylines;
    }
    if (message.allowLargeDeadlineDespiteInterruptionRisk !== false) {
      obj.allowLargeDeadlineDespiteInterruptionRisk = message.allowLargeDeadlineDespiteInterruptionRisk;
    }
    if (message.useGeodesicDistances !== false) {
      obj.useGeodesicDistances = message.useGeodesicDistances;
    }
    if (message.geodesicMetersPerSecond !== undefined) {
      obj.geodesicMetersPerSecond = message.geodesicMetersPerSecond;
    }
    if (message.maxValidationErrors !== undefined) {
      obj.maxValidationErrors = Math.round(message.maxValidationErrors);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.populateTravelStepPolylines !== false) {
      obj.populateTravelStepPolylines = message.populateTravelStepPolylines;
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursRequest>): OptimizeToursRequest {
    return OptimizeToursRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptimizeToursRequest>): OptimizeToursRequest {
    const message = createBaseOptimizeToursRequest();
    message.parent = object.parent ?? "";
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? ShipmentModel.fromPartial(object.model)
      : undefined;
    message.solvingMode = object.solvingMode ?? 0;
    message.searchMode = object.searchMode ?? 0;
    message.injectedFirstSolutionRoutes =
      object.injectedFirstSolutionRoutes?.map((e) => ShipmentRoute.fromPartial(e)) || [];
    message.injectedSolutionConstraint =
      (object.injectedSolutionConstraint !== undefined && object.injectedSolutionConstraint !== null)
        ? InjectedSolutionConstraint.fromPartial(object.injectedSolutionConstraint)
        : undefined;
    message.refreshDetailsRoutes = object.refreshDetailsRoutes?.map((e) => ShipmentRoute.fromPartial(e)) || [];
    message.interpretInjectedSolutionsUsingLabels = object.interpretInjectedSolutionsUsingLabels ?? false;
    message.considerRoadTraffic = object.considerRoadTraffic ?? false;
    message.populatePolylines = object.populatePolylines ?? false;
    message.populateTransitionPolylines = object.populateTransitionPolylines ?? false;
    message.allowLargeDeadlineDespiteInterruptionRisk = object.allowLargeDeadlineDespiteInterruptionRisk ?? false;
    message.useGeodesicDistances = object.useGeodesicDistances ?? false;
    message.geodesicMetersPerSecond = object.geodesicMetersPerSecond ?? undefined;
    message.maxValidationErrors = object.maxValidationErrors ?? undefined;
    message.label = object.label ?? "";
    message.populateTravelStepPolylines = object.populateTravelStepPolylines ?? false;
    return message;
  },
};

function createBaseOptimizeToursResponse(): OptimizeToursResponse {
  return { routes: [], requestLabel: "", skippedShipments: [], validationErrors: [], metrics: undefined, totalCost: 0 };
}

export const OptimizeToursResponse: MessageFns<OptimizeToursResponse> = {
  encode(message: OptimizeToursResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      ShipmentRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.requestLabel !== "") {
      writer.uint32(26).string(message.requestLabel);
    }
    for (const v of message.skippedShipments) {
      SkippedShipment.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.validationErrors) {
      OptimizeToursValidationError.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.metrics !== undefined) {
      OptimizeToursResponse_Metrics.encode(message.metrics, writer.uint32(50).fork()).join();
    }
    if (message.totalCost !== 0) {
      writer.uint32(17).double(message.totalCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routes.push(ShipmentRoute.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestLabel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.skippedShipments.push(SkippedShipment.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validationErrors.push(OptimizeToursValidationError.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metrics = OptimizeToursResponse_Metrics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.totalCost = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursResponse {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => ShipmentRoute.fromJSON(e)) : [],
      requestLabel: isSet(object.requestLabel) ? globalThis.String(object.requestLabel) : "",
      skippedShipments: globalThis.Array.isArray(object?.skippedShipments)
        ? object.skippedShipments.map((e: any) => SkippedShipment.fromJSON(e))
        : [],
      validationErrors: globalThis.Array.isArray(object?.validationErrors)
        ? object.validationErrors.map((e: any) => OptimizeToursValidationError.fromJSON(e))
        : [],
      metrics: isSet(object.metrics) ? OptimizeToursResponse_Metrics.fromJSON(object.metrics) : undefined,
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
    };
  },

  toJSON(message: OptimizeToursResponse): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => ShipmentRoute.toJSON(e));
    }
    if (message.requestLabel !== "") {
      obj.requestLabel = message.requestLabel;
    }
    if (message.skippedShipments?.length) {
      obj.skippedShipments = message.skippedShipments.map((e) => SkippedShipment.toJSON(e));
    }
    if (message.validationErrors?.length) {
      obj.validationErrors = message.validationErrors.map((e) => OptimizeToursValidationError.toJSON(e));
    }
    if (message.metrics !== undefined) {
      obj.metrics = OptimizeToursResponse_Metrics.toJSON(message.metrics);
    }
    if (message.totalCost !== 0) {
      obj.totalCost = message.totalCost;
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursResponse>): OptimizeToursResponse {
    return OptimizeToursResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptimizeToursResponse>): OptimizeToursResponse {
    const message = createBaseOptimizeToursResponse();
    message.routes = object.routes?.map((e) => ShipmentRoute.fromPartial(e)) || [];
    message.requestLabel = object.requestLabel ?? "";
    message.skippedShipments = object.skippedShipments?.map((e) => SkippedShipment.fromPartial(e)) || [];
    message.validationErrors = object.validationErrors?.map((e) => OptimizeToursValidationError.fromPartial(e)) || [];
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? OptimizeToursResponse_Metrics.fromPartial(object.metrics)
      : undefined;
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

function createBaseOptimizeToursResponse_Metrics(): OptimizeToursResponse_Metrics {
  return {
    aggregatedRouteMetrics: undefined,
    skippedMandatoryShipmentCount: 0,
    usedVehicleCount: 0,
    earliestVehicleStartTime: undefined,
    latestVehicleEndTime: undefined,
    costs: {},
    totalCost: 0,
  };
}

export const OptimizeToursResponse_Metrics: MessageFns<OptimizeToursResponse_Metrics> = {
  encode(message: OptimizeToursResponse_Metrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregatedRouteMetrics !== undefined) {
      AggregatedMetrics.encode(message.aggregatedRouteMetrics, writer.uint32(10).fork()).join();
    }
    if (message.skippedMandatoryShipmentCount !== 0) {
      writer.uint32(16).int32(message.skippedMandatoryShipmentCount);
    }
    if (message.usedVehicleCount !== 0) {
      writer.uint32(24).int32(message.usedVehicleCount);
    }
    if (message.earliestVehicleStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestVehicleStartTime), writer.uint32(34).fork()).join();
    }
    if (message.latestVehicleEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.latestVehicleEndTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.costs).forEach(([key, value]) => {
      OptimizeToursResponse_Metrics_CostsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.totalCost !== 0) {
      writer.uint32(49).double(message.totalCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursResponse_Metrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursResponse_Metrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aggregatedRouteMetrics = AggregatedMetrics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skippedMandatoryShipmentCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.usedVehicleCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.earliestVehicleStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.latestVehicleEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = OptimizeToursResponse_Metrics_CostsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.costs[entry10.key] = entry10.value;
          }
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.totalCost = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursResponse_Metrics {
    return {
      aggregatedRouteMetrics: isSet(object.aggregatedRouteMetrics)
        ? AggregatedMetrics.fromJSON(object.aggregatedRouteMetrics)
        : undefined,
      skippedMandatoryShipmentCount: isSet(object.skippedMandatoryShipmentCount)
        ? globalThis.Number(object.skippedMandatoryShipmentCount)
        : 0,
      usedVehicleCount: isSet(object.usedVehicleCount) ? globalThis.Number(object.usedVehicleCount) : 0,
      earliestVehicleStartTime: isSet(object.earliestVehicleStartTime)
        ? fromJsonTimestamp(object.earliestVehicleStartTime)
        : undefined,
      latestVehicleEndTime: isSet(object.latestVehicleEndTime)
        ? fromJsonTimestamp(object.latestVehicleEndTime)
        : undefined,
      costs: isObject(object.costs)
        ? Object.entries(object.costs).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
    };
  },

  toJSON(message: OptimizeToursResponse_Metrics): unknown {
    const obj: any = {};
    if (message.aggregatedRouteMetrics !== undefined) {
      obj.aggregatedRouteMetrics = AggregatedMetrics.toJSON(message.aggregatedRouteMetrics);
    }
    if (message.skippedMandatoryShipmentCount !== 0) {
      obj.skippedMandatoryShipmentCount = Math.round(message.skippedMandatoryShipmentCount);
    }
    if (message.usedVehicleCount !== 0) {
      obj.usedVehicleCount = Math.round(message.usedVehicleCount);
    }
    if (message.earliestVehicleStartTime !== undefined) {
      obj.earliestVehicleStartTime = message.earliestVehicleStartTime.toISOString();
    }
    if (message.latestVehicleEndTime !== undefined) {
      obj.latestVehicleEndTime = message.latestVehicleEndTime.toISOString();
    }
    if (message.costs) {
      const entries = Object.entries(message.costs);
      if (entries.length > 0) {
        obj.costs = {};
        entries.forEach(([k, v]) => {
          obj.costs[k] = v;
        });
      }
    }
    if (message.totalCost !== 0) {
      obj.totalCost = message.totalCost;
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursResponse_Metrics>): OptimizeToursResponse_Metrics {
    return OptimizeToursResponse_Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptimizeToursResponse_Metrics>): OptimizeToursResponse_Metrics {
    const message = createBaseOptimizeToursResponse_Metrics();
    message.aggregatedRouteMetrics =
      (object.aggregatedRouteMetrics !== undefined && object.aggregatedRouteMetrics !== null)
        ? AggregatedMetrics.fromPartial(object.aggregatedRouteMetrics)
        : undefined;
    message.skippedMandatoryShipmentCount = object.skippedMandatoryShipmentCount ?? 0;
    message.usedVehicleCount = object.usedVehicleCount ?? 0;
    message.earliestVehicleStartTime = object.earliestVehicleStartTime ?? undefined;
    message.latestVehicleEndTime = object.latestVehicleEndTime ?? undefined;
    message.costs = Object.entries(object.costs ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

function createBaseOptimizeToursResponse_Metrics_CostsEntry(): OptimizeToursResponse_Metrics_CostsEntry {
  return { key: "", value: 0 };
}

export const OptimizeToursResponse_Metrics_CostsEntry: MessageFns<OptimizeToursResponse_Metrics_CostsEntry> = {
  encode(message: OptimizeToursResponse_Metrics_CostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursResponse_Metrics_CostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursResponse_Metrics_CostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursResponse_Metrics_CostsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: OptimizeToursResponse_Metrics_CostsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursResponse_Metrics_CostsEntry>): OptimizeToursResponse_Metrics_CostsEntry {
    return OptimizeToursResponse_Metrics_CostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptimizeToursResponse_Metrics_CostsEntry>): OptimizeToursResponse_Metrics_CostsEntry {
    const message = createBaseOptimizeToursResponse_Metrics_CostsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBatchOptimizeToursRequest(): BatchOptimizeToursRequest {
  return { parent: "", modelConfigs: [] };
}

export const BatchOptimizeToursRequest: MessageFns<BatchOptimizeToursRequest> = {
  encode(message: BatchOptimizeToursRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.modelConfigs) {
      BatchOptimizeToursRequest_AsyncModelConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOptimizeToursRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOptimizeToursRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelConfigs.push(BatchOptimizeToursRequest_AsyncModelConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchOptimizeToursRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      modelConfigs: globalThis.Array.isArray(object?.modelConfigs)
        ? object.modelConfigs.map((e: any) => BatchOptimizeToursRequest_AsyncModelConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchOptimizeToursRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.modelConfigs?.length) {
      obj.modelConfigs = message.modelConfigs.map((e) => BatchOptimizeToursRequest_AsyncModelConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchOptimizeToursRequest>): BatchOptimizeToursRequest {
    return BatchOptimizeToursRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchOptimizeToursRequest>): BatchOptimizeToursRequest {
    const message = createBaseBatchOptimizeToursRequest();
    message.parent = object.parent ?? "";
    message.modelConfigs = object.modelConfigs?.map((e) => BatchOptimizeToursRequest_AsyncModelConfig.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseBatchOptimizeToursRequest_AsyncModelConfig(): BatchOptimizeToursRequest_AsyncModelConfig {
  return { displayName: "", inputConfig: undefined, outputConfig: undefined, enableCheckpoints: false };
}

export const BatchOptimizeToursRequest_AsyncModelConfig: MessageFns<BatchOptimizeToursRequest_AsyncModelConfig> = {
  encode(message: BatchOptimizeToursRequest_AsyncModelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.inputConfig !== undefined) {
      InputConfig.encode(message.inputConfig, writer.uint32(18).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(26).fork()).join();
    }
    if (message.enableCheckpoints !== false) {
      writer.uint32(32).bool(message.enableCheckpoints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOptimizeToursRequest_AsyncModelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOptimizeToursRequest_AsyncModelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputConfig = InputConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableCheckpoints = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchOptimizeToursRequest_AsyncModelConfig {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      inputConfig: isSet(object.inputConfig) ? InputConfig.fromJSON(object.inputConfig) : undefined,
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
      enableCheckpoints: isSet(object.enableCheckpoints) ? globalThis.Boolean(object.enableCheckpoints) : false,
    };
  },

  toJSON(message: BatchOptimizeToursRequest_AsyncModelConfig): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = InputConfig.toJSON(message.inputConfig);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    if (message.enableCheckpoints !== false) {
      obj.enableCheckpoints = message.enableCheckpoints;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchOptimizeToursRequest_AsyncModelConfig>): BatchOptimizeToursRequest_AsyncModelConfig {
    return BatchOptimizeToursRequest_AsyncModelConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchOptimizeToursRequest_AsyncModelConfig>,
  ): BatchOptimizeToursRequest_AsyncModelConfig {
    const message = createBaseBatchOptimizeToursRequest_AsyncModelConfig();
    message.displayName = object.displayName ?? "";
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? InputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.enableCheckpoints = object.enableCheckpoints ?? false;
    return message;
  },
};

function createBaseBatchOptimizeToursResponse(): BatchOptimizeToursResponse {
  return {};
}

export const BatchOptimizeToursResponse: MessageFns<BatchOptimizeToursResponse> = {
  encode(_: BatchOptimizeToursResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOptimizeToursResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOptimizeToursResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchOptimizeToursResponse {
    return {};
  },

  toJSON(_: BatchOptimizeToursResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchOptimizeToursResponse>): BatchOptimizeToursResponse {
    return BatchOptimizeToursResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchOptimizeToursResponse>): BatchOptimizeToursResponse {
    const message = createBaseBatchOptimizeToursResponse();
    return message;
  },
};

function createBaseShipmentModel(): ShipmentModel {
  return {
    shipments: [],
    vehicles: [],
    maxActiveVehicles: undefined,
    globalStartTime: undefined,
    globalEndTime: undefined,
    globalDurationCostPerHour: 0,
    durationDistanceMatrices: [],
    durationDistanceMatrixSrcTags: [],
    durationDistanceMatrixDstTags: [],
    transitionAttributes: [],
    shipmentTypeIncompatibilities: [],
    shipmentTypeRequirements: [],
    precedenceRules: [],
    breakRules: [],
  };
}

export const ShipmentModel: MessageFns<ShipmentModel> = {
  encode(message: ShipmentModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.shipments) {
      Shipment.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.vehicles) {
      Vehicle.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.maxActiveVehicles !== undefined) {
      writer.uint32(32).int32(message.maxActiveVehicles);
    }
    if (message.globalStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.globalStartTime), writer.uint32(42).fork()).join();
    }
    if (message.globalEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.globalEndTime), writer.uint32(50).fork()).join();
    }
    if (message.globalDurationCostPerHour !== 0) {
      writer.uint32(57).double(message.globalDurationCostPerHour);
    }
    for (const v of message.durationDistanceMatrices) {
      ShipmentModel_DurationDistanceMatrix.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.durationDistanceMatrixSrcTags) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.durationDistanceMatrixDstTags) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.transitionAttributes) {
      TransitionAttributes.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.shipmentTypeIncompatibilities) {
      ShipmentTypeIncompatibility.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.shipmentTypeRequirements) {
      ShipmentTypeRequirement.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.precedenceRules) {
      ShipmentModel_PrecedenceRule.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.breakRules) {
      ShipmentModel_BreakRule.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shipments.push(Shipment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vehicles.push(Vehicle.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxActiveVehicles = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.globalStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.globalEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.globalDurationCostPerHour = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.durationDistanceMatrices.push(ShipmentModel_DurationDistanceMatrix.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.durationDistanceMatrixSrcTags.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.durationDistanceMatrixDstTags.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transitionAttributes.push(TransitionAttributes.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.shipmentTypeIncompatibilities.push(ShipmentTypeIncompatibility.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.shipmentTypeRequirements.push(ShipmentTypeRequirement.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.precedenceRules.push(ShipmentModel_PrecedenceRule.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.breakRules.push(ShipmentModel_BreakRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel {
    return {
      shipments: globalThis.Array.isArray(object?.shipments)
        ? object.shipments.map((e: any) => Shipment.fromJSON(e))
        : [],
      vehicles: globalThis.Array.isArray(object?.vehicles) ? object.vehicles.map((e: any) => Vehicle.fromJSON(e)) : [],
      maxActiveVehicles: isSet(object.maxActiveVehicles) ? globalThis.Number(object.maxActiveVehicles) : undefined,
      globalStartTime: isSet(object.globalStartTime) ? fromJsonTimestamp(object.globalStartTime) : undefined,
      globalEndTime: isSet(object.globalEndTime) ? fromJsonTimestamp(object.globalEndTime) : undefined,
      globalDurationCostPerHour: isSet(object.globalDurationCostPerHour)
        ? globalThis.Number(object.globalDurationCostPerHour)
        : 0,
      durationDistanceMatrices: globalThis.Array.isArray(object?.durationDistanceMatrices)
        ? object.durationDistanceMatrices.map((e: any) => ShipmentModel_DurationDistanceMatrix.fromJSON(e))
        : [],
      durationDistanceMatrixSrcTags: globalThis.Array.isArray(object?.durationDistanceMatrixSrcTags)
        ? object.durationDistanceMatrixSrcTags.map((e: any) => globalThis.String(e))
        : [],
      durationDistanceMatrixDstTags: globalThis.Array.isArray(object?.durationDistanceMatrixDstTags)
        ? object.durationDistanceMatrixDstTags.map((e: any) => globalThis.String(e))
        : [],
      transitionAttributes: globalThis.Array.isArray(object?.transitionAttributes)
        ? object.transitionAttributes.map((e: any) => TransitionAttributes.fromJSON(e))
        : [],
      shipmentTypeIncompatibilities: globalThis.Array.isArray(object?.shipmentTypeIncompatibilities)
        ? object.shipmentTypeIncompatibilities.map((e: any) => ShipmentTypeIncompatibility.fromJSON(e))
        : [],
      shipmentTypeRequirements: globalThis.Array.isArray(object?.shipmentTypeRequirements)
        ? object.shipmentTypeRequirements.map((e: any) => ShipmentTypeRequirement.fromJSON(e))
        : [],
      precedenceRules: globalThis.Array.isArray(object?.precedenceRules)
        ? object.precedenceRules.map((e: any) => ShipmentModel_PrecedenceRule.fromJSON(e))
        : [],
      breakRules: globalThis.Array.isArray(object?.breakRules)
        ? object.breakRules.map((e: any) => ShipmentModel_BreakRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ShipmentModel): unknown {
    const obj: any = {};
    if (message.shipments?.length) {
      obj.shipments = message.shipments.map((e) => Shipment.toJSON(e));
    }
    if (message.vehicles?.length) {
      obj.vehicles = message.vehicles.map((e) => Vehicle.toJSON(e));
    }
    if (message.maxActiveVehicles !== undefined) {
      obj.maxActiveVehicles = Math.round(message.maxActiveVehicles);
    }
    if (message.globalStartTime !== undefined) {
      obj.globalStartTime = message.globalStartTime.toISOString();
    }
    if (message.globalEndTime !== undefined) {
      obj.globalEndTime = message.globalEndTime.toISOString();
    }
    if (message.globalDurationCostPerHour !== 0) {
      obj.globalDurationCostPerHour = message.globalDurationCostPerHour;
    }
    if (message.durationDistanceMatrices?.length) {
      obj.durationDistanceMatrices = message.durationDistanceMatrices.map((e) =>
        ShipmentModel_DurationDistanceMatrix.toJSON(e)
      );
    }
    if (message.durationDistanceMatrixSrcTags?.length) {
      obj.durationDistanceMatrixSrcTags = message.durationDistanceMatrixSrcTags;
    }
    if (message.durationDistanceMatrixDstTags?.length) {
      obj.durationDistanceMatrixDstTags = message.durationDistanceMatrixDstTags;
    }
    if (message.transitionAttributes?.length) {
      obj.transitionAttributes = message.transitionAttributes.map((e) => TransitionAttributes.toJSON(e));
    }
    if (message.shipmentTypeIncompatibilities?.length) {
      obj.shipmentTypeIncompatibilities = message.shipmentTypeIncompatibilities.map((e) =>
        ShipmentTypeIncompatibility.toJSON(e)
      );
    }
    if (message.shipmentTypeRequirements?.length) {
      obj.shipmentTypeRequirements = message.shipmentTypeRequirements.map((e) => ShipmentTypeRequirement.toJSON(e));
    }
    if (message.precedenceRules?.length) {
      obj.precedenceRules = message.precedenceRules.map((e) => ShipmentModel_PrecedenceRule.toJSON(e));
    }
    if (message.breakRules?.length) {
      obj.breakRules = message.breakRules.map((e) => ShipmentModel_BreakRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel>): ShipmentModel {
    return ShipmentModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel>): ShipmentModel {
    const message = createBaseShipmentModel();
    message.shipments = object.shipments?.map((e) => Shipment.fromPartial(e)) || [];
    message.vehicles = object.vehicles?.map((e) => Vehicle.fromPartial(e)) || [];
    message.maxActiveVehicles = object.maxActiveVehicles ?? undefined;
    message.globalStartTime = object.globalStartTime ?? undefined;
    message.globalEndTime = object.globalEndTime ?? undefined;
    message.globalDurationCostPerHour = object.globalDurationCostPerHour ?? 0;
    message.durationDistanceMatrices =
      object.durationDistanceMatrices?.map((e) => ShipmentModel_DurationDistanceMatrix.fromPartial(e)) || [];
    message.durationDistanceMatrixSrcTags = object.durationDistanceMatrixSrcTags?.map((e) => e) || [];
    message.durationDistanceMatrixDstTags = object.durationDistanceMatrixDstTags?.map((e) => e) || [];
    message.transitionAttributes = object.transitionAttributes?.map((e) => TransitionAttributes.fromPartial(e)) || [];
    message.shipmentTypeIncompatibilities =
      object.shipmentTypeIncompatibilities?.map((e) => ShipmentTypeIncompatibility.fromPartial(e)) || [];
    message.shipmentTypeRequirements =
      object.shipmentTypeRequirements?.map((e) => ShipmentTypeRequirement.fromPartial(e)) || [];
    message.precedenceRules = object.precedenceRules?.map((e) => ShipmentModel_PrecedenceRule.fromPartial(e)) || [];
    message.breakRules = object.breakRules?.map((e) => ShipmentModel_BreakRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipmentModel_DurationDistanceMatrix(): ShipmentModel_DurationDistanceMatrix {
  return { rows: [], vehicleStartTag: "" };
}

export const ShipmentModel_DurationDistanceMatrix: MessageFns<ShipmentModel_DurationDistanceMatrix> = {
  encode(message: ShipmentModel_DurationDistanceMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      ShipmentModel_DurationDistanceMatrix_Row.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.vehicleStartTag !== "") {
      writer.uint32(18).string(message.vehicleStartTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_DurationDistanceMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_DurationDistanceMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rows.push(ShipmentModel_DurationDistanceMatrix_Row.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vehicleStartTag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_DurationDistanceMatrix {
    return {
      rows: globalThis.Array.isArray(object?.rows)
        ? object.rows.map((e: any) => ShipmentModel_DurationDistanceMatrix_Row.fromJSON(e))
        : [],
      vehicleStartTag: isSet(object.vehicleStartTag) ? globalThis.String(object.vehicleStartTag) : "",
    };
  },

  toJSON(message: ShipmentModel_DurationDistanceMatrix): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => ShipmentModel_DurationDistanceMatrix_Row.toJSON(e));
    }
    if (message.vehicleStartTag !== "") {
      obj.vehicleStartTag = message.vehicleStartTag;
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_DurationDistanceMatrix>): ShipmentModel_DurationDistanceMatrix {
    return ShipmentModel_DurationDistanceMatrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel_DurationDistanceMatrix>): ShipmentModel_DurationDistanceMatrix {
    const message = createBaseShipmentModel_DurationDistanceMatrix();
    message.rows = object.rows?.map((e) => ShipmentModel_DurationDistanceMatrix_Row.fromPartial(e)) || [];
    message.vehicleStartTag = object.vehicleStartTag ?? "";
    return message;
  },
};

function createBaseShipmentModel_DurationDistanceMatrix_Row(): ShipmentModel_DurationDistanceMatrix_Row {
  return { durations: [], meters: [] };
}

export const ShipmentModel_DurationDistanceMatrix_Row: MessageFns<ShipmentModel_DurationDistanceMatrix_Row> = {
  encode(message: ShipmentModel_DurationDistanceMatrix_Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.durations) {
      Duration.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.meters) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_DurationDistanceMatrix_Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_DurationDistanceMatrix_Row();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.durations.push(Duration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag === 17) {
            message.meters.push(reader.double());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.meters.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_DurationDistanceMatrix_Row {
    return {
      durations: globalThis.Array.isArray(object?.durations)
        ? object.durations.map((e: any) => Duration.fromJSON(e))
        : [],
      meters: globalThis.Array.isArray(object?.meters) ? object.meters.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: ShipmentModel_DurationDistanceMatrix_Row): unknown {
    const obj: any = {};
    if (message.durations?.length) {
      obj.durations = message.durations.map((e) => Duration.toJSON(e));
    }
    if (message.meters?.length) {
      obj.meters = message.meters;
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_DurationDistanceMatrix_Row>): ShipmentModel_DurationDistanceMatrix_Row {
    return ShipmentModel_DurationDistanceMatrix_Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel_DurationDistanceMatrix_Row>): ShipmentModel_DurationDistanceMatrix_Row {
    const message = createBaseShipmentModel_DurationDistanceMatrix_Row();
    message.durations = object.durations?.map((e) => Duration.fromPartial(e)) || [];
    message.meters = object.meters?.map((e) => e) || [];
    return message;
  },
};

function createBaseShipmentModel_PrecedenceRule(): ShipmentModel_PrecedenceRule {
  return {
    firstIndex: undefined,
    firstIsDelivery: false,
    secondIndex: undefined,
    secondIsDelivery: false,
    offsetDuration: undefined,
  };
}

export const ShipmentModel_PrecedenceRule: MessageFns<ShipmentModel_PrecedenceRule> = {
  encode(message: ShipmentModel_PrecedenceRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstIndex !== undefined) {
      writer.uint32(8).int32(message.firstIndex);
    }
    if (message.firstIsDelivery !== false) {
      writer.uint32(24).bool(message.firstIsDelivery);
    }
    if (message.secondIndex !== undefined) {
      writer.uint32(16).int32(message.secondIndex);
    }
    if (message.secondIsDelivery !== false) {
      writer.uint32(32).bool(message.secondIsDelivery);
    }
    if (message.offsetDuration !== undefined) {
      Duration.encode(message.offsetDuration, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_PrecedenceRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_PrecedenceRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.firstIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.firstIsDelivery = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.secondIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.secondIsDelivery = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.offsetDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_PrecedenceRule {
    return {
      firstIndex: isSet(object.firstIndex) ? globalThis.Number(object.firstIndex) : undefined,
      firstIsDelivery: isSet(object.firstIsDelivery) ? globalThis.Boolean(object.firstIsDelivery) : false,
      secondIndex: isSet(object.secondIndex) ? globalThis.Number(object.secondIndex) : undefined,
      secondIsDelivery: isSet(object.secondIsDelivery) ? globalThis.Boolean(object.secondIsDelivery) : false,
      offsetDuration: isSet(object.offsetDuration) ? Duration.fromJSON(object.offsetDuration) : undefined,
    };
  },

  toJSON(message: ShipmentModel_PrecedenceRule): unknown {
    const obj: any = {};
    if (message.firstIndex !== undefined) {
      obj.firstIndex = Math.round(message.firstIndex);
    }
    if (message.firstIsDelivery !== false) {
      obj.firstIsDelivery = message.firstIsDelivery;
    }
    if (message.secondIndex !== undefined) {
      obj.secondIndex = Math.round(message.secondIndex);
    }
    if (message.secondIsDelivery !== false) {
      obj.secondIsDelivery = message.secondIsDelivery;
    }
    if (message.offsetDuration !== undefined) {
      obj.offsetDuration = Duration.toJSON(message.offsetDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_PrecedenceRule>): ShipmentModel_PrecedenceRule {
    return ShipmentModel_PrecedenceRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel_PrecedenceRule>): ShipmentModel_PrecedenceRule {
    const message = createBaseShipmentModel_PrecedenceRule();
    message.firstIndex = object.firstIndex ?? undefined;
    message.firstIsDelivery = object.firstIsDelivery ?? false;
    message.secondIndex = object.secondIndex ?? undefined;
    message.secondIsDelivery = object.secondIsDelivery ?? false;
    message.offsetDuration = (object.offsetDuration !== undefined && object.offsetDuration !== null)
      ? Duration.fromPartial(object.offsetDuration)
      : undefined;
    return message;
  },
};

function createBaseShipmentModel_BreakRule(): ShipmentModel_BreakRule {
  return { breakRequests: [], frequencyConstraints: [] };
}

export const ShipmentModel_BreakRule: MessageFns<ShipmentModel_BreakRule> = {
  encode(message: ShipmentModel_BreakRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.breakRequests) {
      ShipmentModel_BreakRule_BreakRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.frequencyConstraints) {
      ShipmentModel_BreakRule_FrequencyConstraint.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_BreakRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_BreakRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakRequests.push(ShipmentModel_BreakRule_BreakRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.frequencyConstraints.push(
            ShipmentModel_BreakRule_FrequencyConstraint.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_BreakRule {
    return {
      breakRequests: globalThis.Array.isArray(object?.breakRequests)
        ? object.breakRequests.map((e: any) => ShipmentModel_BreakRule_BreakRequest.fromJSON(e))
        : [],
      frequencyConstraints: globalThis.Array.isArray(object?.frequencyConstraints)
        ? object.frequencyConstraints.map((e: any) => ShipmentModel_BreakRule_FrequencyConstraint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ShipmentModel_BreakRule): unknown {
    const obj: any = {};
    if (message.breakRequests?.length) {
      obj.breakRequests = message.breakRequests.map((e) => ShipmentModel_BreakRule_BreakRequest.toJSON(e));
    }
    if (message.frequencyConstraints?.length) {
      obj.frequencyConstraints = message.frequencyConstraints.map((e) =>
        ShipmentModel_BreakRule_FrequencyConstraint.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_BreakRule>): ShipmentModel_BreakRule {
    return ShipmentModel_BreakRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel_BreakRule>): ShipmentModel_BreakRule {
    const message = createBaseShipmentModel_BreakRule();
    message.breakRequests = object.breakRequests?.map((e) => ShipmentModel_BreakRule_BreakRequest.fromPartial(e)) || [];
    message.frequencyConstraints =
      object.frequencyConstraints?.map((e) => ShipmentModel_BreakRule_FrequencyConstraint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipmentModel_BreakRule_BreakRequest(): ShipmentModel_BreakRule_BreakRequest {
  return { earliestStartTime: undefined, latestStartTime: undefined, minDuration: undefined };
}

export const ShipmentModel_BreakRule_BreakRequest: MessageFns<ShipmentModel_BreakRule_BreakRequest> = {
  encode(message: ShipmentModel_BreakRule_BreakRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.earliestStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStartTime), writer.uint32(10).fork()).join();
    }
    if (message.latestStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStartTime), writer.uint32(18).fork()).join();
    }
    if (message.minDuration !== undefined) {
      Duration.encode(message.minDuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_BreakRule_BreakRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_BreakRule_BreakRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.earliestStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_BreakRule_BreakRequest {
    return {
      earliestStartTime: isSet(object.earliestStartTime) ? fromJsonTimestamp(object.earliestStartTime) : undefined,
      latestStartTime: isSet(object.latestStartTime) ? fromJsonTimestamp(object.latestStartTime) : undefined,
      minDuration: isSet(object.minDuration) ? Duration.fromJSON(object.minDuration) : undefined,
    };
  },

  toJSON(message: ShipmentModel_BreakRule_BreakRequest): unknown {
    const obj: any = {};
    if (message.earliestStartTime !== undefined) {
      obj.earliestStartTime = message.earliestStartTime.toISOString();
    }
    if (message.latestStartTime !== undefined) {
      obj.latestStartTime = message.latestStartTime.toISOString();
    }
    if (message.minDuration !== undefined) {
      obj.minDuration = Duration.toJSON(message.minDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_BreakRule_BreakRequest>): ShipmentModel_BreakRule_BreakRequest {
    return ShipmentModel_BreakRule_BreakRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentModel_BreakRule_BreakRequest>): ShipmentModel_BreakRule_BreakRequest {
    const message = createBaseShipmentModel_BreakRule_BreakRequest();
    message.earliestStartTime = object.earliestStartTime ?? undefined;
    message.latestStartTime = object.latestStartTime ?? undefined;
    message.minDuration = (object.minDuration !== undefined && object.minDuration !== null)
      ? Duration.fromPartial(object.minDuration)
      : undefined;
    return message;
  },
};

function createBaseShipmentModel_BreakRule_FrequencyConstraint(): ShipmentModel_BreakRule_FrequencyConstraint {
  return { minBreakDuration: undefined, maxInterBreakDuration: undefined };
}

export const ShipmentModel_BreakRule_FrequencyConstraint: MessageFns<ShipmentModel_BreakRule_FrequencyConstraint> = {
  encode(
    message: ShipmentModel_BreakRule_FrequencyConstraint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.minBreakDuration !== undefined) {
      Duration.encode(message.minBreakDuration, writer.uint32(10).fork()).join();
    }
    if (message.maxInterBreakDuration !== undefined) {
      Duration.encode(message.maxInterBreakDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentModel_BreakRule_FrequencyConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentModel_BreakRule_FrequencyConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minBreakDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxInterBreakDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentModel_BreakRule_FrequencyConstraint {
    return {
      minBreakDuration: isSet(object.minBreakDuration) ? Duration.fromJSON(object.minBreakDuration) : undefined,
      maxInterBreakDuration: isSet(object.maxInterBreakDuration)
        ? Duration.fromJSON(object.maxInterBreakDuration)
        : undefined,
    };
  },

  toJSON(message: ShipmentModel_BreakRule_FrequencyConstraint): unknown {
    const obj: any = {};
    if (message.minBreakDuration !== undefined) {
      obj.minBreakDuration = Duration.toJSON(message.minBreakDuration);
    }
    if (message.maxInterBreakDuration !== undefined) {
      obj.maxInterBreakDuration = Duration.toJSON(message.maxInterBreakDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentModel_BreakRule_FrequencyConstraint>): ShipmentModel_BreakRule_FrequencyConstraint {
    return ShipmentModel_BreakRule_FrequencyConstraint.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ShipmentModel_BreakRule_FrequencyConstraint>,
  ): ShipmentModel_BreakRule_FrequencyConstraint {
    const message = createBaseShipmentModel_BreakRule_FrequencyConstraint();
    message.minBreakDuration = (object.minBreakDuration !== undefined && object.minBreakDuration !== null)
      ? Duration.fromPartial(object.minBreakDuration)
      : undefined;
    message.maxInterBreakDuration =
      (object.maxInterBreakDuration !== undefined && object.maxInterBreakDuration !== null)
        ? Duration.fromPartial(object.maxInterBreakDuration)
        : undefined;
    return message;
  },
};

function createBaseShipment(): Shipment {
  return {
    pickups: [],
    deliveries: [],
    loadDemands: {},
    penaltyCost: undefined,
    allowedVehicleIndices: [],
    costsPerVehicle: [],
    costsPerVehicleIndices: [],
    pickupToDeliveryRelativeDetourLimit: undefined,
    pickupToDeliveryAbsoluteDetourLimit: undefined,
    pickupToDeliveryTimeLimit: undefined,
    shipmentType: "",
    label: "",
    ignore: false,
    demands: [],
  };
}

export const Shipment: MessageFns<Shipment> = {
  encode(message: Shipment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pickups) {
      Shipment_VisitRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.deliveries) {
      Shipment_VisitRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.loadDemands).forEach(([key, value]) => {
      Shipment_LoadDemandsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.penaltyCost !== undefined) {
      writer.uint32(33).double(message.penaltyCost);
    }
    writer.uint32(42).fork();
    for (const v of message.allowedVehicleIndices) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.costsPerVehicle) {
      writer.double(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.costsPerVehicleIndices) {
      writer.int32(v);
    }
    writer.join();
    if (message.pickupToDeliveryRelativeDetourLimit !== undefined) {
      writer.uint32(65).double(message.pickupToDeliveryRelativeDetourLimit);
    }
    if (message.pickupToDeliveryAbsoluteDetourLimit !== undefined) {
      Duration.encode(message.pickupToDeliveryAbsoluteDetourLimit, writer.uint32(74).fork()).join();
    }
    if (message.pickupToDeliveryTimeLimit !== undefined) {
      Duration.encode(message.pickupToDeliveryTimeLimit, writer.uint32(82).fork()).join();
    }
    if (message.shipmentType !== "") {
      writer.uint32(90).string(message.shipmentType);
    }
    if (message.label !== "") {
      writer.uint32(98).string(message.label);
    }
    if (message.ignore !== false) {
      writer.uint32(104).bool(message.ignore);
    }
    for (const v of message.demands) {
      CapacityQuantity.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pickups.push(Shipment_VisitRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deliveries.push(Shipment_VisitRequest.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = Shipment_LoadDemandsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.loadDemands[entry14.key] = entry14.value;
          }
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.penaltyCost = reader.double();
          continue;
        case 5:
          if (tag === 40) {
            message.allowedVehicleIndices.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedVehicleIndices.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 49) {
            message.costsPerVehicle.push(reader.double());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.costsPerVehicle.push(reader.double());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.costsPerVehicleIndices.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.costsPerVehicleIndices.push(reader.int32());
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.pickupToDeliveryRelativeDetourLimit = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pickupToDeliveryAbsoluteDetourLimit = Duration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pickupToDeliveryTimeLimit = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.shipmentType = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.label = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.ignore = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.demands.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment {
    return {
      pickups: globalThis.Array.isArray(object?.pickups)
        ? object.pickups.map((e: any) => Shipment_VisitRequest.fromJSON(e))
        : [],
      deliveries: globalThis.Array.isArray(object?.deliveries)
        ? object.deliveries.map((e: any) => Shipment_VisitRequest.fromJSON(e))
        : [],
      loadDemands: isObject(object.loadDemands)
        ? Object.entries(object.loadDemands).reduce<{ [key: string]: Shipment_Load }>((acc, [key, value]) => {
          acc[key] = Shipment_Load.fromJSON(value);
          return acc;
        }, {})
        : {},
      penaltyCost: isSet(object.penaltyCost) ? globalThis.Number(object.penaltyCost) : undefined,
      allowedVehicleIndices: globalThis.Array.isArray(object?.allowedVehicleIndices)
        ? object.allowedVehicleIndices.map((e: any) => globalThis.Number(e))
        : [],
      costsPerVehicle: globalThis.Array.isArray(object?.costsPerVehicle)
        ? object.costsPerVehicle.map((e: any) => globalThis.Number(e))
        : [],
      costsPerVehicleIndices: globalThis.Array.isArray(object?.costsPerVehicleIndices)
        ? object.costsPerVehicleIndices.map((e: any) => globalThis.Number(e))
        : [],
      pickupToDeliveryRelativeDetourLimit: isSet(object.pickupToDeliveryRelativeDetourLimit)
        ? globalThis.Number(object.pickupToDeliveryRelativeDetourLimit)
        : undefined,
      pickupToDeliveryAbsoluteDetourLimit: isSet(object.pickupToDeliveryAbsoluteDetourLimit)
        ? Duration.fromJSON(object.pickupToDeliveryAbsoluteDetourLimit)
        : undefined,
      pickupToDeliveryTimeLimit: isSet(object.pickupToDeliveryTimeLimit)
        ? Duration.fromJSON(object.pickupToDeliveryTimeLimit)
        : undefined,
      shipmentType: isSet(object.shipmentType) ? globalThis.String(object.shipmentType) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      ignore: isSet(object.ignore) ? globalThis.Boolean(object.ignore) : false,
      demands: globalThis.Array.isArray(object?.demands)
        ? object.demands.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Shipment): unknown {
    const obj: any = {};
    if (message.pickups?.length) {
      obj.pickups = message.pickups.map((e) => Shipment_VisitRequest.toJSON(e));
    }
    if (message.deliveries?.length) {
      obj.deliveries = message.deliveries.map((e) => Shipment_VisitRequest.toJSON(e));
    }
    if (message.loadDemands) {
      const entries = Object.entries(message.loadDemands);
      if (entries.length > 0) {
        obj.loadDemands = {};
        entries.forEach(([k, v]) => {
          obj.loadDemands[k] = Shipment_Load.toJSON(v);
        });
      }
    }
    if (message.penaltyCost !== undefined) {
      obj.penaltyCost = message.penaltyCost;
    }
    if (message.allowedVehicleIndices?.length) {
      obj.allowedVehicleIndices = message.allowedVehicleIndices.map((e) => Math.round(e));
    }
    if (message.costsPerVehicle?.length) {
      obj.costsPerVehicle = message.costsPerVehicle;
    }
    if (message.costsPerVehicleIndices?.length) {
      obj.costsPerVehicleIndices = message.costsPerVehicleIndices.map((e) => Math.round(e));
    }
    if (message.pickupToDeliveryRelativeDetourLimit !== undefined) {
      obj.pickupToDeliveryRelativeDetourLimit = message.pickupToDeliveryRelativeDetourLimit;
    }
    if (message.pickupToDeliveryAbsoluteDetourLimit !== undefined) {
      obj.pickupToDeliveryAbsoluteDetourLimit = Duration.toJSON(message.pickupToDeliveryAbsoluteDetourLimit);
    }
    if (message.pickupToDeliveryTimeLimit !== undefined) {
      obj.pickupToDeliveryTimeLimit = Duration.toJSON(message.pickupToDeliveryTimeLimit);
    }
    if (message.shipmentType !== "") {
      obj.shipmentType = message.shipmentType;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.ignore !== false) {
      obj.ignore = message.ignore;
    }
    if (message.demands?.length) {
      obj.demands = message.demands.map((e) => CapacityQuantity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Shipment>): Shipment {
    return Shipment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipment>): Shipment {
    const message = createBaseShipment();
    message.pickups = object.pickups?.map((e) => Shipment_VisitRequest.fromPartial(e)) || [];
    message.deliveries = object.deliveries?.map((e) => Shipment_VisitRequest.fromPartial(e)) || [];
    message.loadDemands = Object.entries(object.loadDemands ?? {}).reduce<{ [key: string]: Shipment_Load }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Shipment_Load.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.penaltyCost = object.penaltyCost ?? undefined;
    message.allowedVehicleIndices = object.allowedVehicleIndices?.map((e) => e) || [];
    message.costsPerVehicle = object.costsPerVehicle?.map((e) => e) || [];
    message.costsPerVehicleIndices = object.costsPerVehicleIndices?.map((e) => e) || [];
    message.pickupToDeliveryRelativeDetourLimit = object.pickupToDeliveryRelativeDetourLimit ?? undefined;
    message.pickupToDeliveryAbsoluteDetourLimit =
      (object.pickupToDeliveryAbsoluteDetourLimit !== undefined && object.pickupToDeliveryAbsoluteDetourLimit !== null)
        ? Duration.fromPartial(object.pickupToDeliveryAbsoluteDetourLimit)
        : undefined;
    message.pickupToDeliveryTimeLimit =
      (object.pickupToDeliveryTimeLimit !== undefined && object.pickupToDeliveryTimeLimit !== null)
        ? Duration.fromPartial(object.pickupToDeliveryTimeLimit)
        : undefined;
    message.shipmentType = object.shipmentType ?? "";
    message.label = object.label ?? "";
    message.ignore = object.ignore ?? false;
    message.demands = object.demands?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipment_VisitRequest(): Shipment_VisitRequest {
  return {
    arrivalLocation: undefined,
    arrivalWaypoint: undefined,
    departureLocation: undefined,
    departureWaypoint: undefined,
    tags: [],
    timeWindows: [],
    duration: undefined,
    cost: 0,
    loadDemands: {},
    visitTypes: [],
    label: "",
    demands: [],
  };
}

export const Shipment_VisitRequest: MessageFns<Shipment_VisitRequest> = {
  encode(message: Shipment_VisitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.arrivalLocation !== undefined) {
      LatLng.encode(message.arrivalLocation, writer.uint32(10).fork()).join();
    }
    if (message.arrivalWaypoint !== undefined) {
      Waypoint.encode(message.arrivalWaypoint, writer.uint32(18).fork()).join();
    }
    if (message.departureLocation !== undefined) {
      LatLng.encode(message.departureLocation, writer.uint32(26).fork()).join();
    }
    if (message.departureWaypoint !== undefined) {
      Waypoint.encode(message.departureWaypoint, writer.uint32(34).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.timeWindows) {
      TimeWindow.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(58).fork()).join();
    }
    if (message.cost !== 0) {
      writer.uint32(65).double(message.cost);
    }
    Object.entries(message.loadDemands).forEach(([key, value]) => {
      Shipment_VisitRequest_LoadDemandsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    for (const v of message.visitTypes) {
      writer.uint32(82).string(v!);
    }
    if (message.label !== "") {
      writer.uint32(90).string(message.label);
    }
    for (const v of message.demands) {
      CapacityQuantity.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment_VisitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment_VisitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.arrivalLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arrivalWaypoint = Waypoint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.departureLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.departureWaypoint = Waypoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeWindows.push(TimeWindow.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.cost = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Shipment_VisitRequest_LoadDemandsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.loadDemands[entry12.key] = entry12.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.visitTypes.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.label = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.demands.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment_VisitRequest {
    return {
      arrivalLocation: isSet(object.arrivalLocation) ? LatLng.fromJSON(object.arrivalLocation) : undefined,
      arrivalWaypoint: isSet(object.arrivalWaypoint) ? Waypoint.fromJSON(object.arrivalWaypoint) : undefined,
      departureLocation: isSet(object.departureLocation) ? LatLng.fromJSON(object.departureLocation) : undefined,
      departureWaypoint: isSet(object.departureWaypoint) ? Waypoint.fromJSON(object.departureWaypoint) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      timeWindows: globalThis.Array.isArray(object?.timeWindows)
        ? object.timeWindows.map((e: any) => TimeWindow.fromJSON(e))
        : [],
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      loadDemands: isObject(object.loadDemands)
        ? Object.entries(object.loadDemands).reduce<{ [key: string]: Shipment_Load }>((acc, [key, value]) => {
          acc[key] = Shipment_Load.fromJSON(value);
          return acc;
        }, {})
        : {},
      visitTypes: globalThis.Array.isArray(object?.visitTypes)
        ? object.visitTypes.map((e: any) => globalThis.String(e))
        : [],
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      demands: globalThis.Array.isArray(object?.demands)
        ? object.demands.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Shipment_VisitRequest): unknown {
    const obj: any = {};
    if (message.arrivalLocation !== undefined) {
      obj.arrivalLocation = LatLng.toJSON(message.arrivalLocation);
    }
    if (message.arrivalWaypoint !== undefined) {
      obj.arrivalWaypoint = Waypoint.toJSON(message.arrivalWaypoint);
    }
    if (message.departureLocation !== undefined) {
      obj.departureLocation = LatLng.toJSON(message.departureLocation);
    }
    if (message.departureWaypoint !== undefined) {
      obj.departureWaypoint = Waypoint.toJSON(message.departureWaypoint);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.timeWindows?.length) {
      obj.timeWindows = message.timeWindows.map((e) => TimeWindow.toJSON(e));
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.loadDemands) {
      const entries = Object.entries(message.loadDemands);
      if (entries.length > 0) {
        obj.loadDemands = {};
        entries.forEach(([k, v]) => {
          obj.loadDemands[k] = Shipment_Load.toJSON(v);
        });
      }
    }
    if (message.visitTypes?.length) {
      obj.visitTypes = message.visitTypes;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.demands?.length) {
      obj.demands = message.demands.map((e) => CapacityQuantity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Shipment_VisitRequest>): Shipment_VisitRequest {
    return Shipment_VisitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipment_VisitRequest>): Shipment_VisitRequest {
    const message = createBaseShipment_VisitRequest();
    message.arrivalLocation = (object.arrivalLocation !== undefined && object.arrivalLocation !== null)
      ? LatLng.fromPartial(object.arrivalLocation)
      : undefined;
    message.arrivalWaypoint = (object.arrivalWaypoint !== undefined && object.arrivalWaypoint !== null)
      ? Waypoint.fromPartial(object.arrivalWaypoint)
      : undefined;
    message.departureLocation = (object.departureLocation !== undefined && object.departureLocation !== null)
      ? LatLng.fromPartial(object.departureLocation)
      : undefined;
    message.departureWaypoint = (object.departureWaypoint !== undefined && object.departureWaypoint !== null)
      ? Waypoint.fromPartial(object.departureWaypoint)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.timeWindows = object.timeWindows?.map((e) => TimeWindow.fromPartial(e)) || [];
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.cost = object.cost ?? 0;
    message.loadDemands = Object.entries(object.loadDemands ?? {}).reduce<{ [key: string]: Shipment_Load }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Shipment_Load.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.visitTypes = object.visitTypes?.map((e) => e) || [];
    message.label = object.label ?? "";
    message.demands = object.demands?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipment_VisitRequest_LoadDemandsEntry(): Shipment_VisitRequest_LoadDemandsEntry {
  return { key: "", value: undefined };
}

export const Shipment_VisitRequest_LoadDemandsEntry: MessageFns<Shipment_VisitRequest_LoadDemandsEntry> = {
  encode(message: Shipment_VisitRequest_LoadDemandsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Shipment_Load.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment_VisitRequest_LoadDemandsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment_VisitRequest_LoadDemandsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Shipment_Load.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment_VisitRequest_LoadDemandsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Shipment_Load.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Shipment_VisitRequest_LoadDemandsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Shipment_Load.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Shipment_VisitRequest_LoadDemandsEntry>): Shipment_VisitRequest_LoadDemandsEntry {
    return Shipment_VisitRequest_LoadDemandsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipment_VisitRequest_LoadDemandsEntry>): Shipment_VisitRequest_LoadDemandsEntry {
    const message = createBaseShipment_VisitRequest_LoadDemandsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Shipment_Load.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseShipment_Load(): Shipment_Load {
  return { amount: Long.ZERO };
}

export const Shipment_Load: MessageFns<Shipment_Load> = {
  encode(message: Shipment_Load, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.amount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment_Load {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment_Load();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment_Load {
    return { amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO };
  },

  toJSON(message: Shipment_Load): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Shipment_Load>): Shipment_Load {
    return Shipment_Load.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipment_Load>): Shipment_Load {
    const message = createBaseShipment_Load();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function createBaseShipment_LoadDemandsEntry(): Shipment_LoadDemandsEntry {
  return { key: "", value: undefined };
}

export const Shipment_LoadDemandsEntry: MessageFns<Shipment_LoadDemandsEntry> = {
  encode(message: Shipment_LoadDemandsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Shipment_Load.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipment_LoadDemandsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipment_LoadDemandsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Shipment_Load.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipment_LoadDemandsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Shipment_Load.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Shipment_LoadDemandsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Shipment_Load.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Shipment_LoadDemandsEntry>): Shipment_LoadDemandsEntry {
    return Shipment_LoadDemandsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipment_LoadDemandsEntry>): Shipment_LoadDemandsEntry {
    const message = createBaseShipment_LoadDemandsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Shipment_Load.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseShipmentTypeIncompatibility(): ShipmentTypeIncompatibility {
  return { types: [], incompatibilityMode: 0 };
}

export const ShipmentTypeIncompatibility: MessageFns<ShipmentTypeIncompatibility> = {
  encode(message: ShipmentTypeIncompatibility, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.types) {
      writer.uint32(10).string(v!);
    }
    if (message.incompatibilityMode !== 0) {
      writer.uint32(16).int32(message.incompatibilityMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentTypeIncompatibility {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentTypeIncompatibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.incompatibilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentTypeIncompatibility {
    return {
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      incompatibilityMode: isSet(object.incompatibilityMode)
        ? shipmentTypeIncompatibility_IncompatibilityModeFromJSON(object.incompatibilityMode)
        : 0,
    };
  },

  toJSON(message: ShipmentTypeIncompatibility): unknown {
    const obj: any = {};
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.incompatibilityMode !== 0) {
      obj.incompatibilityMode = shipmentTypeIncompatibility_IncompatibilityModeToJSON(message.incompatibilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentTypeIncompatibility>): ShipmentTypeIncompatibility {
    return ShipmentTypeIncompatibility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentTypeIncompatibility>): ShipmentTypeIncompatibility {
    const message = createBaseShipmentTypeIncompatibility();
    message.types = object.types?.map((e) => e) || [];
    message.incompatibilityMode = object.incompatibilityMode ?? 0;
    return message;
  },
};

function createBaseShipmentTypeRequirement(): ShipmentTypeRequirement {
  return { requiredShipmentTypeAlternatives: [], dependentShipmentTypes: [], requirementMode: 0 };
}

export const ShipmentTypeRequirement: MessageFns<ShipmentTypeRequirement> = {
  encode(message: ShipmentTypeRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requiredShipmentTypeAlternatives) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.dependentShipmentTypes) {
      writer.uint32(18).string(v!);
    }
    if (message.requirementMode !== 0) {
      writer.uint32(24).int32(message.requirementMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentTypeRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentTypeRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requiredShipmentTypeAlternatives.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dependentShipmentTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requirementMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentTypeRequirement {
    return {
      requiredShipmentTypeAlternatives: globalThis.Array.isArray(object?.requiredShipmentTypeAlternatives)
        ? object.requiredShipmentTypeAlternatives.map((e: any) => globalThis.String(e))
        : [],
      dependentShipmentTypes: globalThis.Array.isArray(object?.dependentShipmentTypes)
        ? object.dependentShipmentTypes.map((e: any) => globalThis.String(e))
        : [],
      requirementMode: isSet(object.requirementMode)
        ? shipmentTypeRequirement_RequirementModeFromJSON(object.requirementMode)
        : 0,
    };
  },

  toJSON(message: ShipmentTypeRequirement): unknown {
    const obj: any = {};
    if (message.requiredShipmentTypeAlternatives?.length) {
      obj.requiredShipmentTypeAlternatives = message.requiredShipmentTypeAlternatives;
    }
    if (message.dependentShipmentTypes?.length) {
      obj.dependentShipmentTypes = message.dependentShipmentTypes;
    }
    if (message.requirementMode !== 0) {
      obj.requirementMode = shipmentTypeRequirement_RequirementModeToJSON(message.requirementMode);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentTypeRequirement>): ShipmentTypeRequirement {
    return ShipmentTypeRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentTypeRequirement>): ShipmentTypeRequirement {
    const message = createBaseShipmentTypeRequirement();
    message.requiredShipmentTypeAlternatives = object.requiredShipmentTypeAlternatives?.map((e) => e) || [];
    message.dependentShipmentTypes = object.dependentShipmentTypes?.map((e) => e) || [];
    message.requirementMode = object.requirementMode ?? 0;
    return message;
  },
};

function createBaseRouteModifiers(): RouteModifiers {
  return { avoidTolls: false, avoidHighways: false, avoidFerries: false, avoidIndoor: false };
}

export const RouteModifiers: MessageFns<RouteModifiers> = {
  encode(message: RouteModifiers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avoidTolls !== false) {
      writer.uint32(16).bool(message.avoidTolls);
    }
    if (message.avoidHighways !== false) {
      writer.uint32(24).bool(message.avoidHighways);
    }
    if (message.avoidFerries !== false) {
      writer.uint32(32).bool(message.avoidFerries);
    }
    if (message.avoidIndoor !== false) {
      writer.uint32(40).bool(message.avoidIndoor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteModifiers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteModifiers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.avoidTolls = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.avoidHighways = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.avoidFerries = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.avoidIndoor = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteModifiers {
    return {
      avoidTolls: isSet(object.avoidTolls) ? globalThis.Boolean(object.avoidTolls) : false,
      avoidHighways: isSet(object.avoidHighways) ? globalThis.Boolean(object.avoidHighways) : false,
      avoidFerries: isSet(object.avoidFerries) ? globalThis.Boolean(object.avoidFerries) : false,
      avoidIndoor: isSet(object.avoidIndoor) ? globalThis.Boolean(object.avoidIndoor) : false,
    };
  },

  toJSON(message: RouteModifiers): unknown {
    const obj: any = {};
    if (message.avoidTolls !== false) {
      obj.avoidTolls = message.avoidTolls;
    }
    if (message.avoidHighways !== false) {
      obj.avoidHighways = message.avoidHighways;
    }
    if (message.avoidFerries !== false) {
      obj.avoidFerries = message.avoidFerries;
    }
    if (message.avoidIndoor !== false) {
      obj.avoidIndoor = message.avoidIndoor;
    }
    return obj;
  },

  create(base?: DeepPartial<RouteModifiers>): RouteModifiers {
    return RouteModifiers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteModifiers>): RouteModifiers {
    const message = createBaseRouteModifiers();
    message.avoidTolls = object.avoidTolls ?? false;
    message.avoidHighways = object.avoidHighways ?? false;
    message.avoidFerries = object.avoidFerries ?? false;
    message.avoidIndoor = object.avoidIndoor ?? false;
    return message;
  },
};

function createBaseVehicle(): Vehicle {
  return {
    travelMode: 0,
    routeModifiers: undefined,
    startLocation: undefined,
    startWaypoint: undefined,
    endLocation: undefined,
    endWaypoint: undefined,
    startTags: [],
    endTags: [],
    startTimeWindows: [],
    endTimeWindows: [],
    travelDurationMultiple: undefined,
    unloadingPolicy: 0,
    loadLimits: {},
    costPerHour: 0,
    costPerTraveledHour: 0,
    costPerKilometer: 0,
    fixedCost: 0,
    usedIfRouteIsEmpty: false,
    routeDurationLimit: undefined,
    travelDurationLimit: undefined,
    routeDistanceLimit: undefined,
    extraVisitDurationForVisitType: {},
    breakRule: undefined,
    label: "",
    ignore: false,
    breakRuleIndices: [],
    capacities: [],
    startLoadIntervals: [],
    endLoadIntervals: [],
  };
}

export const Vehicle: MessageFns<Vehicle> = {
  encode(message: Vehicle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.travelMode !== 0) {
      writer.uint32(8).int32(message.travelMode);
    }
    if (message.routeModifiers !== undefined) {
      RouteModifiers.encode(message.routeModifiers, writer.uint32(18).fork()).join();
    }
    if (message.startLocation !== undefined) {
      LatLng.encode(message.startLocation, writer.uint32(26).fork()).join();
    }
    if (message.startWaypoint !== undefined) {
      Waypoint.encode(message.startWaypoint, writer.uint32(34).fork()).join();
    }
    if (message.endLocation !== undefined) {
      LatLng.encode(message.endLocation, writer.uint32(42).fork()).join();
    }
    if (message.endWaypoint !== undefined) {
      Waypoint.encode(message.endWaypoint, writer.uint32(50).fork()).join();
    }
    for (const v of message.startTags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.endTags) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.startTimeWindows) {
      TimeWindow.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.endTimeWindows) {
      TimeWindow.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.travelDurationMultiple !== undefined) {
      writer.uint32(89).double(message.travelDurationMultiple);
    }
    if (message.unloadingPolicy !== 0) {
      writer.uint32(96).int32(message.unloadingPolicy);
    }
    Object.entries(message.loadLimits).forEach(([key, value]) => {
      Vehicle_LoadLimitsEntry.encode({ key: key as any, value }, writer.uint32(242).fork()).join();
    });
    if (message.costPerHour !== 0) {
      writer.uint32(129).double(message.costPerHour);
    }
    if (message.costPerTraveledHour !== 0) {
      writer.uint32(137).double(message.costPerTraveledHour);
    }
    if (message.costPerKilometer !== 0) {
      writer.uint32(145).double(message.costPerKilometer);
    }
    if (message.fixedCost !== 0) {
      writer.uint32(153).double(message.fixedCost);
    }
    if (message.usedIfRouteIsEmpty !== false) {
      writer.uint32(160).bool(message.usedIfRouteIsEmpty);
    }
    if (message.routeDurationLimit !== undefined) {
      Vehicle_DurationLimit.encode(message.routeDurationLimit, writer.uint32(170).fork()).join();
    }
    if (message.travelDurationLimit !== undefined) {
      Vehicle_DurationLimit.encode(message.travelDurationLimit, writer.uint32(178).fork()).join();
    }
    if (message.routeDistanceLimit !== undefined) {
      DistanceLimit.encode(message.routeDistanceLimit, writer.uint32(186).fork()).join();
    }
    Object.entries(message.extraVisitDurationForVisitType).forEach(([key, value]) => {
      Vehicle_ExtraVisitDurationForVisitTypeEntry.encode({ key: key as any, value }, writer.uint32(194).fork()).join();
    });
    if (message.breakRule !== undefined) {
      BreakRule.encode(message.breakRule, writer.uint32(202).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(218).string(message.label);
    }
    if (message.ignore !== false) {
      writer.uint32(224).bool(message.ignore);
    }
    writer.uint32(234).fork();
    for (const v of message.breakRuleIndices) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.capacities) {
      CapacityQuantity.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.startLoadIntervals) {
      CapacityQuantityInterval.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.endLoadIntervals) {
      CapacityQuantityInterval.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routeModifiers = RouteModifiers.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startWaypoint = Waypoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endLocation = LatLng.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endWaypoint = Waypoint.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startTags.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTags.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.startTimeWindows.push(TimeWindow.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.endTimeWindows.push(TimeWindow.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.travelDurationMultiple = reader.double();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.unloadingPolicy = reader.int32() as any;
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          const entry30 = Vehicle_LoadLimitsEntry.decode(reader, reader.uint32());
          if (entry30.value !== undefined) {
            message.loadLimits[entry30.key] = entry30.value;
          }
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.costPerHour = reader.double();
          continue;
        case 17:
          if (tag !== 137) {
            break;
          }

          message.costPerTraveledHour = reader.double();
          continue;
        case 18:
          if (tag !== 145) {
            break;
          }

          message.costPerKilometer = reader.double();
          continue;
        case 19:
          if (tag !== 153) {
            break;
          }

          message.fixedCost = reader.double();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.usedIfRouteIsEmpty = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.routeDurationLimit = Vehicle_DurationLimit.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.travelDurationLimit = Vehicle_DurationLimit.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.routeDistanceLimit = DistanceLimit.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          const entry24 = Vehicle_ExtraVisitDurationForVisitTypeEntry.decode(reader, reader.uint32());
          if (entry24.value !== undefined) {
            message.extraVisitDurationForVisitType[entry24.key] = entry24.value;
          }
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.breakRule = BreakRule.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.label = reader.string();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.ignore = reader.bool();
          continue;
        case 29:
          if (tag === 232) {
            message.breakRuleIndices.push(reader.int32());

            continue;
          }

          if (tag === 234) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.breakRuleIndices.push(reader.int32());
            }

            continue;
          }

          break;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.capacities.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.startLoadIntervals.push(CapacityQuantityInterval.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.endLoadIntervals.push(CapacityQuantityInterval.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle {
    return {
      travelMode: isSet(object.travelMode) ? vehicle_TravelModeFromJSON(object.travelMode) : 0,
      routeModifiers: isSet(object.routeModifiers) ? RouteModifiers.fromJSON(object.routeModifiers) : undefined,
      startLocation: isSet(object.startLocation) ? LatLng.fromJSON(object.startLocation) : undefined,
      startWaypoint: isSet(object.startWaypoint) ? Waypoint.fromJSON(object.startWaypoint) : undefined,
      endLocation: isSet(object.endLocation) ? LatLng.fromJSON(object.endLocation) : undefined,
      endWaypoint: isSet(object.endWaypoint) ? Waypoint.fromJSON(object.endWaypoint) : undefined,
      startTags: globalThis.Array.isArray(object?.startTags)
        ? object.startTags.map((e: any) => globalThis.String(e))
        : [],
      endTags: globalThis.Array.isArray(object?.endTags) ? object.endTags.map((e: any) => globalThis.String(e)) : [],
      startTimeWindows: globalThis.Array.isArray(object?.startTimeWindows)
        ? object.startTimeWindows.map((e: any) => TimeWindow.fromJSON(e))
        : [],
      endTimeWindows: globalThis.Array.isArray(object?.endTimeWindows)
        ? object.endTimeWindows.map((e: any) => TimeWindow.fromJSON(e))
        : [],
      travelDurationMultiple: isSet(object.travelDurationMultiple)
        ? globalThis.Number(object.travelDurationMultiple)
        : undefined,
      unloadingPolicy: isSet(object.unloadingPolicy) ? vehicle_UnloadingPolicyFromJSON(object.unloadingPolicy) : 0,
      loadLimits: isObject(object.loadLimits)
        ? Object.entries(object.loadLimits).reduce<{ [key: string]: Vehicle_LoadLimit }>((acc, [key, value]) => {
          acc[key] = Vehicle_LoadLimit.fromJSON(value);
          return acc;
        }, {})
        : {},
      costPerHour: isSet(object.costPerHour) ? globalThis.Number(object.costPerHour) : 0,
      costPerTraveledHour: isSet(object.costPerTraveledHour) ? globalThis.Number(object.costPerTraveledHour) : 0,
      costPerKilometer: isSet(object.costPerKilometer) ? globalThis.Number(object.costPerKilometer) : 0,
      fixedCost: isSet(object.fixedCost) ? globalThis.Number(object.fixedCost) : 0,
      usedIfRouteIsEmpty: isSet(object.usedIfRouteIsEmpty) ? globalThis.Boolean(object.usedIfRouteIsEmpty) : false,
      routeDurationLimit: isSet(object.routeDurationLimit)
        ? Vehicle_DurationLimit.fromJSON(object.routeDurationLimit)
        : undefined,
      travelDurationLimit: isSet(object.travelDurationLimit)
        ? Vehicle_DurationLimit.fromJSON(object.travelDurationLimit)
        : undefined,
      routeDistanceLimit: isSet(object.routeDistanceLimit)
        ? DistanceLimit.fromJSON(object.routeDistanceLimit)
        : undefined,
      extraVisitDurationForVisitType: isObject(object.extraVisitDurationForVisitType)
        ? Object.entries(object.extraVisitDurationForVisitType).reduce<{ [key: string]: Duration }>(
          (acc, [key, value]) => {
            acc[key] = Duration.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      breakRule: isSet(object.breakRule) ? BreakRule.fromJSON(object.breakRule) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      ignore: isSet(object.ignore) ? globalThis.Boolean(object.ignore) : false,
      breakRuleIndices: globalThis.Array.isArray(object?.breakRuleIndices)
        ? object.breakRuleIndices.map((e: any) => globalThis.Number(e))
        : [],
      capacities: globalThis.Array.isArray(object?.capacities)
        ? object.capacities.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
      startLoadIntervals: globalThis.Array.isArray(object?.startLoadIntervals)
        ? object.startLoadIntervals.map((e: any) => CapacityQuantityInterval.fromJSON(e))
        : [],
      endLoadIntervals: globalThis.Array.isArray(object?.endLoadIntervals)
        ? object.endLoadIntervals.map((e: any) => CapacityQuantityInterval.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Vehicle): unknown {
    const obj: any = {};
    if (message.travelMode !== 0) {
      obj.travelMode = vehicle_TravelModeToJSON(message.travelMode);
    }
    if (message.routeModifiers !== undefined) {
      obj.routeModifiers = RouteModifiers.toJSON(message.routeModifiers);
    }
    if (message.startLocation !== undefined) {
      obj.startLocation = LatLng.toJSON(message.startLocation);
    }
    if (message.startWaypoint !== undefined) {
      obj.startWaypoint = Waypoint.toJSON(message.startWaypoint);
    }
    if (message.endLocation !== undefined) {
      obj.endLocation = LatLng.toJSON(message.endLocation);
    }
    if (message.endWaypoint !== undefined) {
      obj.endWaypoint = Waypoint.toJSON(message.endWaypoint);
    }
    if (message.startTags?.length) {
      obj.startTags = message.startTags;
    }
    if (message.endTags?.length) {
      obj.endTags = message.endTags;
    }
    if (message.startTimeWindows?.length) {
      obj.startTimeWindows = message.startTimeWindows.map((e) => TimeWindow.toJSON(e));
    }
    if (message.endTimeWindows?.length) {
      obj.endTimeWindows = message.endTimeWindows.map((e) => TimeWindow.toJSON(e));
    }
    if (message.travelDurationMultiple !== undefined) {
      obj.travelDurationMultiple = message.travelDurationMultiple;
    }
    if (message.unloadingPolicy !== 0) {
      obj.unloadingPolicy = vehicle_UnloadingPolicyToJSON(message.unloadingPolicy);
    }
    if (message.loadLimits) {
      const entries = Object.entries(message.loadLimits);
      if (entries.length > 0) {
        obj.loadLimits = {};
        entries.forEach(([k, v]) => {
          obj.loadLimits[k] = Vehicle_LoadLimit.toJSON(v);
        });
      }
    }
    if (message.costPerHour !== 0) {
      obj.costPerHour = message.costPerHour;
    }
    if (message.costPerTraveledHour !== 0) {
      obj.costPerTraveledHour = message.costPerTraveledHour;
    }
    if (message.costPerKilometer !== 0) {
      obj.costPerKilometer = message.costPerKilometer;
    }
    if (message.fixedCost !== 0) {
      obj.fixedCost = message.fixedCost;
    }
    if (message.usedIfRouteIsEmpty !== false) {
      obj.usedIfRouteIsEmpty = message.usedIfRouteIsEmpty;
    }
    if (message.routeDurationLimit !== undefined) {
      obj.routeDurationLimit = Vehicle_DurationLimit.toJSON(message.routeDurationLimit);
    }
    if (message.travelDurationLimit !== undefined) {
      obj.travelDurationLimit = Vehicle_DurationLimit.toJSON(message.travelDurationLimit);
    }
    if (message.routeDistanceLimit !== undefined) {
      obj.routeDistanceLimit = DistanceLimit.toJSON(message.routeDistanceLimit);
    }
    if (message.extraVisitDurationForVisitType) {
      const entries = Object.entries(message.extraVisitDurationForVisitType);
      if (entries.length > 0) {
        obj.extraVisitDurationForVisitType = {};
        entries.forEach(([k, v]) => {
          obj.extraVisitDurationForVisitType[k] = Duration.toJSON(v);
        });
      }
    }
    if (message.breakRule !== undefined) {
      obj.breakRule = BreakRule.toJSON(message.breakRule);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.ignore !== false) {
      obj.ignore = message.ignore;
    }
    if (message.breakRuleIndices?.length) {
      obj.breakRuleIndices = message.breakRuleIndices.map((e) => Math.round(e));
    }
    if (message.capacities?.length) {
      obj.capacities = message.capacities.map((e) => CapacityQuantity.toJSON(e));
    }
    if (message.startLoadIntervals?.length) {
      obj.startLoadIntervals = message.startLoadIntervals.map((e) => CapacityQuantityInterval.toJSON(e));
    }
    if (message.endLoadIntervals?.length) {
      obj.endLoadIntervals = message.endLoadIntervals.map((e) => CapacityQuantityInterval.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle>): Vehicle {
    return Vehicle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle>): Vehicle {
    const message = createBaseVehicle();
    message.travelMode = object.travelMode ?? 0;
    message.routeModifiers = (object.routeModifiers !== undefined && object.routeModifiers !== null)
      ? RouteModifiers.fromPartial(object.routeModifiers)
      : undefined;
    message.startLocation = (object.startLocation !== undefined && object.startLocation !== null)
      ? LatLng.fromPartial(object.startLocation)
      : undefined;
    message.startWaypoint = (object.startWaypoint !== undefined && object.startWaypoint !== null)
      ? Waypoint.fromPartial(object.startWaypoint)
      : undefined;
    message.endLocation = (object.endLocation !== undefined && object.endLocation !== null)
      ? LatLng.fromPartial(object.endLocation)
      : undefined;
    message.endWaypoint = (object.endWaypoint !== undefined && object.endWaypoint !== null)
      ? Waypoint.fromPartial(object.endWaypoint)
      : undefined;
    message.startTags = object.startTags?.map((e) => e) || [];
    message.endTags = object.endTags?.map((e) => e) || [];
    message.startTimeWindows = object.startTimeWindows?.map((e) => TimeWindow.fromPartial(e)) || [];
    message.endTimeWindows = object.endTimeWindows?.map((e) => TimeWindow.fromPartial(e)) || [];
    message.travelDurationMultiple = object.travelDurationMultiple ?? undefined;
    message.unloadingPolicy = object.unloadingPolicy ?? 0;
    message.loadLimits = Object.entries(object.loadLimits ?? {}).reduce<{ [key: string]: Vehicle_LoadLimit }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Vehicle_LoadLimit.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.costPerHour = object.costPerHour ?? 0;
    message.costPerTraveledHour = object.costPerTraveledHour ?? 0;
    message.costPerKilometer = object.costPerKilometer ?? 0;
    message.fixedCost = object.fixedCost ?? 0;
    message.usedIfRouteIsEmpty = object.usedIfRouteIsEmpty ?? false;
    message.routeDurationLimit = (object.routeDurationLimit !== undefined && object.routeDurationLimit !== null)
      ? Vehicle_DurationLimit.fromPartial(object.routeDurationLimit)
      : undefined;
    message.travelDurationLimit = (object.travelDurationLimit !== undefined && object.travelDurationLimit !== null)
      ? Vehicle_DurationLimit.fromPartial(object.travelDurationLimit)
      : undefined;
    message.routeDistanceLimit = (object.routeDistanceLimit !== undefined && object.routeDistanceLimit !== null)
      ? DistanceLimit.fromPartial(object.routeDistanceLimit)
      : undefined;
    message.extraVisitDurationForVisitType = Object.entries(object.extraVisitDurationForVisitType ?? {}).reduce<
      { [key: string]: Duration }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Duration.fromPartial(value);
      }
      return acc;
    }, {});
    message.breakRule = (object.breakRule !== undefined && object.breakRule !== null)
      ? BreakRule.fromPartial(object.breakRule)
      : undefined;
    message.label = object.label ?? "";
    message.ignore = object.ignore ?? false;
    message.breakRuleIndices = object.breakRuleIndices?.map((e) => e) || [];
    message.capacities = object.capacities?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    message.startLoadIntervals = object.startLoadIntervals?.map((e) => CapacityQuantityInterval.fromPartial(e)) || [];
    message.endLoadIntervals = object.endLoadIntervals?.map((e) => CapacityQuantityInterval.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVehicle_LoadLimit(): Vehicle_LoadLimit {
  return {
    maxLoad: undefined,
    softMaxLoad: Long.ZERO,
    costPerUnitAboveSoftMax: 0,
    startLoadInterval: undefined,
    endLoadInterval: undefined,
  };
}

export const Vehicle_LoadLimit: MessageFns<Vehicle_LoadLimit> = {
  encode(message: Vehicle_LoadLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxLoad !== undefined) {
      writer.uint32(8).int64(message.maxLoad.toString());
    }
    if (!message.softMaxLoad.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.softMaxLoad.toString());
    }
    if (message.costPerUnitAboveSoftMax !== 0) {
      writer.uint32(25).double(message.costPerUnitAboveSoftMax);
    }
    if (message.startLoadInterval !== undefined) {
      Vehicle_LoadLimit_Interval.encode(message.startLoadInterval, writer.uint32(34).fork()).join();
    }
    if (message.endLoadInterval !== undefined) {
      Vehicle_LoadLimit_Interval.encode(message.endLoadInterval, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_LoadLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_LoadLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxLoad = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.softMaxLoad = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.costPerUnitAboveSoftMax = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startLoadInterval = Vehicle_LoadLimit_Interval.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endLoadInterval = Vehicle_LoadLimit_Interval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_LoadLimit {
    return {
      maxLoad: isSet(object.maxLoad) ? Long.fromValue(object.maxLoad) : undefined,
      softMaxLoad: isSet(object.softMaxLoad) ? Long.fromValue(object.softMaxLoad) : Long.ZERO,
      costPerUnitAboveSoftMax: isSet(object.costPerUnitAboveSoftMax)
        ? globalThis.Number(object.costPerUnitAboveSoftMax)
        : 0,
      startLoadInterval: isSet(object.startLoadInterval)
        ? Vehicle_LoadLimit_Interval.fromJSON(object.startLoadInterval)
        : undefined,
      endLoadInterval: isSet(object.endLoadInterval)
        ? Vehicle_LoadLimit_Interval.fromJSON(object.endLoadInterval)
        : undefined,
    };
  },

  toJSON(message: Vehicle_LoadLimit): unknown {
    const obj: any = {};
    if (message.maxLoad !== undefined) {
      obj.maxLoad = (message.maxLoad || Long.ZERO).toString();
    }
    if (!message.softMaxLoad.equals(Long.ZERO)) {
      obj.softMaxLoad = (message.softMaxLoad || Long.ZERO).toString();
    }
    if (message.costPerUnitAboveSoftMax !== 0) {
      obj.costPerUnitAboveSoftMax = message.costPerUnitAboveSoftMax;
    }
    if (message.startLoadInterval !== undefined) {
      obj.startLoadInterval = Vehicle_LoadLimit_Interval.toJSON(message.startLoadInterval);
    }
    if (message.endLoadInterval !== undefined) {
      obj.endLoadInterval = Vehicle_LoadLimit_Interval.toJSON(message.endLoadInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_LoadLimit>): Vehicle_LoadLimit {
    return Vehicle_LoadLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle_LoadLimit>): Vehicle_LoadLimit {
    const message = createBaseVehicle_LoadLimit();
    message.maxLoad = (object.maxLoad !== undefined && object.maxLoad !== null)
      ? Long.fromValue(object.maxLoad)
      : undefined;
    message.softMaxLoad = (object.softMaxLoad !== undefined && object.softMaxLoad !== null)
      ? Long.fromValue(object.softMaxLoad)
      : Long.ZERO;
    message.costPerUnitAboveSoftMax = object.costPerUnitAboveSoftMax ?? 0;
    message.startLoadInterval = (object.startLoadInterval !== undefined && object.startLoadInterval !== null)
      ? Vehicle_LoadLimit_Interval.fromPartial(object.startLoadInterval)
      : undefined;
    message.endLoadInterval = (object.endLoadInterval !== undefined && object.endLoadInterval !== null)
      ? Vehicle_LoadLimit_Interval.fromPartial(object.endLoadInterval)
      : undefined;
    return message;
  },
};

function createBaseVehicle_LoadLimit_Interval(): Vehicle_LoadLimit_Interval {
  return { min: Long.ZERO, max: undefined };
}

export const Vehicle_LoadLimit_Interval: MessageFns<Vehicle_LoadLimit_Interval> = {
  encode(message: Vehicle_LoadLimit_Interval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.min.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.min.toString());
    }
    if (message.max !== undefined) {
      writer.uint32(16).int64(message.max.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_LoadLimit_Interval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_LoadLimit_Interval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.min = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.max = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_LoadLimit_Interval {
    return {
      min: isSet(object.min) ? Long.fromValue(object.min) : Long.ZERO,
      max: isSet(object.max) ? Long.fromValue(object.max) : undefined,
    };
  },

  toJSON(message: Vehicle_LoadLimit_Interval): unknown {
    const obj: any = {};
    if (!message.min.equals(Long.ZERO)) {
      obj.min = (message.min || Long.ZERO).toString();
    }
    if (message.max !== undefined) {
      obj.max = (message.max || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_LoadLimit_Interval>): Vehicle_LoadLimit_Interval {
    return Vehicle_LoadLimit_Interval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle_LoadLimit_Interval>): Vehicle_LoadLimit_Interval {
    const message = createBaseVehicle_LoadLimit_Interval();
    message.min = (object.min !== undefined && object.min !== null) ? Long.fromValue(object.min) : Long.ZERO;
    message.max = (object.max !== undefined && object.max !== null) ? Long.fromValue(object.max) : undefined;
    return message;
  },
};

function createBaseVehicle_DurationLimit(): Vehicle_DurationLimit {
  return {
    maxDuration: undefined,
    softMaxDuration: undefined,
    costPerHourAfterSoftMax: undefined,
    quadraticSoftMaxDuration: undefined,
    costPerSquareHourAfterQuadraticSoftMax: undefined,
  };
}

export const Vehicle_DurationLimit: MessageFns<Vehicle_DurationLimit> = {
  encode(message: Vehicle_DurationLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxDuration !== undefined) {
      Duration.encode(message.maxDuration, writer.uint32(10).fork()).join();
    }
    if (message.softMaxDuration !== undefined) {
      Duration.encode(message.softMaxDuration, writer.uint32(18).fork()).join();
    }
    if (message.costPerHourAfterSoftMax !== undefined) {
      writer.uint32(25).double(message.costPerHourAfterSoftMax);
    }
    if (message.quadraticSoftMaxDuration !== undefined) {
      Duration.encode(message.quadraticSoftMaxDuration, writer.uint32(34).fork()).join();
    }
    if (message.costPerSquareHourAfterQuadraticSoftMax !== undefined) {
      writer.uint32(41).double(message.costPerSquareHourAfterQuadraticSoftMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_DurationLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_DurationLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.maxDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.softMaxDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.costPerHourAfterSoftMax = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quadraticSoftMaxDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.costPerSquareHourAfterQuadraticSoftMax = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_DurationLimit {
    return {
      maxDuration: isSet(object.maxDuration) ? Duration.fromJSON(object.maxDuration) : undefined,
      softMaxDuration: isSet(object.softMaxDuration) ? Duration.fromJSON(object.softMaxDuration) : undefined,
      costPerHourAfterSoftMax: isSet(object.costPerHourAfterSoftMax)
        ? globalThis.Number(object.costPerHourAfterSoftMax)
        : undefined,
      quadraticSoftMaxDuration: isSet(object.quadraticSoftMaxDuration)
        ? Duration.fromJSON(object.quadraticSoftMaxDuration)
        : undefined,
      costPerSquareHourAfterQuadraticSoftMax: isSet(object.costPerSquareHourAfterQuadraticSoftMax)
        ? globalThis.Number(object.costPerSquareHourAfterQuadraticSoftMax)
        : undefined,
    };
  },

  toJSON(message: Vehicle_DurationLimit): unknown {
    const obj: any = {};
    if (message.maxDuration !== undefined) {
      obj.maxDuration = Duration.toJSON(message.maxDuration);
    }
    if (message.softMaxDuration !== undefined) {
      obj.softMaxDuration = Duration.toJSON(message.softMaxDuration);
    }
    if (message.costPerHourAfterSoftMax !== undefined) {
      obj.costPerHourAfterSoftMax = message.costPerHourAfterSoftMax;
    }
    if (message.quadraticSoftMaxDuration !== undefined) {
      obj.quadraticSoftMaxDuration = Duration.toJSON(message.quadraticSoftMaxDuration);
    }
    if (message.costPerSquareHourAfterQuadraticSoftMax !== undefined) {
      obj.costPerSquareHourAfterQuadraticSoftMax = message.costPerSquareHourAfterQuadraticSoftMax;
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_DurationLimit>): Vehicle_DurationLimit {
    return Vehicle_DurationLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle_DurationLimit>): Vehicle_DurationLimit {
    const message = createBaseVehicle_DurationLimit();
    message.maxDuration = (object.maxDuration !== undefined && object.maxDuration !== null)
      ? Duration.fromPartial(object.maxDuration)
      : undefined;
    message.softMaxDuration = (object.softMaxDuration !== undefined && object.softMaxDuration !== null)
      ? Duration.fromPartial(object.softMaxDuration)
      : undefined;
    message.costPerHourAfterSoftMax = object.costPerHourAfterSoftMax ?? undefined;
    message.quadraticSoftMaxDuration =
      (object.quadraticSoftMaxDuration !== undefined && object.quadraticSoftMaxDuration !== null)
        ? Duration.fromPartial(object.quadraticSoftMaxDuration)
        : undefined;
    message.costPerSquareHourAfterQuadraticSoftMax = object.costPerSquareHourAfterQuadraticSoftMax ?? undefined;
    return message;
  },
};

function createBaseVehicle_LoadLimitsEntry(): Vehicle_LoadLimitsEntry {
  return { key: "", value: undefined };
}

export const Vehicle_LoadLimitsEntry: MessageFns<Vehicle_LoadLimitsEntry> = {
  encode(message: Vehicle_LoadLimitsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Vehicle_LoadLimit.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_LoadLimitsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_LoadLimitsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Vehicle_LoadLimit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_LoadLimitsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Vehicle_LoadLimit.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Vehicle_LoadLimitsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Vehicle_LoadLimit.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_LoadLimitsEntry>): Vehicle_LoadLimitsEntry {
    return Vehicle_LoadLimitsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vehicle_LoadLimitsEntry>): Vehicle_LoadLimitsEntry {
    const message = createBaseVehicle_LoadLimitsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Vehicle_LoadLimit.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseVehicle_ExtraVisitDurationForVisitTypeEntry(): Vehicle_ExtraVisitDurationForVisitTypeEntry {
  return { key: "", value: undefined };
}

export const Vehicle_ExtraVisitDurationForVisitTypeEntry: MessageFns<Vehicle_ExtraVisitDurationForVisitTypeEntry> = {
  encode(
    message: Vehicle_ExtraVisitDurationForVisitTypeEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Duration.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle_ExtraVisitDurationForVisitTypeEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle_ExtraVisitDurationForVisitTypeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle_ExtraVisitDurationForVisitTypeEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Duration.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Vehicle_ExtraVisitDurationForVisitTypeEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Duration.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Vehicle_ExtraVisitDurationForVisitTypeEntry>): Vehicle_ExtraVisitDurationForVisitTypeEntry {
    return Vehicle_ExtraVisitDurationForVisitTypeEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Vehicle_ExtraVisitDurationForVisitTypeEntry>,
  ): Vehicle_ExtraVisitDurationForVisitTypeEntry {
    const message = createBaseVehicle_ExtraVisitDurationForVisitTypeEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Duration.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return {
    startTime: undefined,
    endTime: undefined,
    softStartTime: undefined,
    softEndTime: undefined,
    costPerHourBeforeSoftStartTime: undefined,
    costPerHourAfterSoftEndTime: undefined,
  };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.softStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.softStartTime), writer.uint32(26).fork()).join();
    }
    if (message.softEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.softEndTime), writer.uint32(34).fork()).join();
    }
    if (message.costPerHourBeforeSoftStartTime !== undefined) {
      writer.uint32(41).double(message.costPerHourBeforeSoftStartTime);
    }
    if (message.costPerHourAfterSoftEndTime !== undefined) {
      writer.uint32(49).double(message.costPerHourAfterSoftEndTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.softStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.softEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.costPerHourBeforeSoftStartTime = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.costPerHourAfterSoftEndTime = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      softStartTime: isSet(object.softStartTime) ? fromJsonTimestamp(object.softStartTime) : undefined,
      softEndTime: isSet(object.softEndTime) ? fromJsonTimestamp(object.softEndTime) : undefined,
      costPerHourBeforeSoftStartTime: isSet(object.costPerHourBeforeSoftStartTime)
        ? globalThis.Number(object.costPerHourBeforeSoftStartTime)
        : undefined,
      costPerHourAfterSoftEndTime: isSet(object.costPerHourAfterSoftEndTime)
        ? globalThis.Number(object.costPerHourAfterSoftEndTime)
        : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.softStartTime !== undefined) {
      obj.softStartTime = message.softStartTime.toISOString();
    }
    if (message.softEndTime !== undefined) {
      obj.softEndTime = message.softEndTime.toISOString();
    }
    if (message.costPerHourBeforeSoftStartTime !== undefined) {
      obj.costPerHourBeforeSoftStartTime = message.costPerHourBeforeSoftStartTime;
    }
    if (message.costPerHourAfterSoftEndTime !== undefined) {
      obj.costPerHourAfterSoftEndTime = message.costPerHourAfterSoftEndTime;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.softStartTime = object.softStartTime ?? undefined;
    message.softEndTime = object.softEndTime ?? undefined;
    message.costPerHourBeforeSoftStartTime = object.costPerHourBeforeSoftStartTime ?? undefined;
    message.costPerHourAfterSoftEndTime = object.costPerHourAfterSoftEndTime ?? undefined;
    return message;
  },
};

function createBaseCapacityQuantity(): CapacityQuantity {
  return { type: "", value: Long.ZERO };
}

export const CapacityQuantity: MessageFns<CapacityQuantity> = {
  encode(message: CapacityQuantity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapacityQuantity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapacityQuantity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapacityQuantity {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: CapacityQuantity): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<CapacityQuantity>): CapacityQuantity {
    return CapacityQuantity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CapacityQuantity>): CapacityQuantity {
    const message = createBaseCapacityQuantity();
    message.type = object.type ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseCapacityQuantityInterval(): CapacityQuantityInterval {
  return { type: "", minValue: undefined, maxValue: undefined };
}

export const CapacityQuantityInterval: MessageFns<CapacityQuantityInterval> = {
  encode(message: CapacityQuantityInterval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.minValue !== undefined) {
      writer.uint32(16).int64(message.minValue.toString());
    }
    if (message.maxValue !== undefined) {
      writer.uint32(24).int64(message.maxValue.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapacityQuantityInterval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapacityQuantityInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxValue = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapacityQuantityInterval {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      minValue: isSet(object.minValue) ? Long.fromValue(object.minValue) : undefined,
      maxValue: isSet(object.maxValue) ? Long.fromValue(object.maxValue) : undefined,
    };
  },

  toJSON(message: CapacityQuantityInterval): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.minValue !== undefined) {
      obj.minValue = (message.minValue || Long.ZERO).toString();
    }
    if (message.maxValue !== undefined) {
      obj.maxValue = (message.maxValue || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<CapacityQuantityInterval>): CapacityQuantityInterval {
    return CapacityQuantityInterval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CapacityQuantityInterval>): CapacityQuantityInterval {
    const message = createBaseCapacityQuantityInterval();
    message.type = object.type ?? "";
    message.minValue = (object.minValue !== undefined && object.minValue !== null)
      ? Long.fromValue(object.minValue)
      : undefined;
    message.maxValue = (object.maxValue !== undefined && object.maxValue !== null)
      ? Long.fromValue(object.maxValue)
      : undefined;
    return message;
  },
};

function createBaseDistanceLimit(): DistanceLimit {
  return {
    maxMeters: undefined,
    softMaxMeters: undefined,
    costPerKilometerBelowSoftMax: undefined,
    costPerKilometerAboveSoftMax: undefined,
  };
}

export const DistanceLimit: MessageFns<DistanceLimit> = {
  encode(message: DistanceLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxMeters !== undefined) {
      writer.uint32(8).int64(message.maxMeters.toString());
    }
    if (message.softMaxMeters !== undefined) {
      writer.uint32(16).int64(message.softMaxMeters.toString());
    }
    if (message.costPerKilometerBelowSoftMax !== undefined) {
      writer.uint32(33).double(message.costPerKilometerBelowSoftMax);
    }
    if (message.costPerKilometerAboveSoftMax !== undefined) {
      writer.uint32(25).double(message.costPerKilometerAboveSoftMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistanceLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistanceLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxMeters = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.softMaxMeters = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.costPerKilometerBelowSoftMax = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.costPerKilometerAboveSoftMax = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistanceLimit {
    return {
      maxMeters: isSet(object.maxMeters) ? Long.fromValue(object.maxMeters) : undefined,
      softMaxMeters: isSet(object.softMaxMeters) ? Long.fromValue(object.softMaxMeters) : undefined,
      costPerKilometerBelowSoftMax: isSet(object.costPerKilometerBelowSoftMax)
        ? globalThis.Number(object.costPerKilometerBelowSoftMax)
        : undefined,
      costPerKilometerAboveSoftMax: isSet(object.costPerKilometerAboveSoftMax)
        ? globalThis.Number(object.costPerKilometerAboveSoftMax)
        : undefined,
    };
  },

  toJSON(message: DistanceLimit): unknown {
    const obj: any = {};
    if (message.maxMeters !== undefined) {
      obj.maxMeters = (message.maxMeters || Long.ZERO).toString();
    }
    if (message.softMaxMeters !== undefined) {
      obj.softMaxMeters = (message.softMaxMeters || Long.ZERO).toString();
    }
    if (message.costPerKilometerBelowSoftMax !== undefined) {
      obj.costPerKilometerBelowSoftMax = message.costPerKilometerBelowSoftMax;
    }
    if (message.costPerKilometerAboveSoftMax !== undefined) {
      obj.costPerKilometerAboveSoftMax = message.costPerKilometerAboveSoftMax;
    }
    return obj;
  },

  create(base?: DeepPartial<DistanceLimit>): DistanceLimit {
    return DistanceLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DistanceLimit>): DistanceLimit {
    const message = createBaseDistanceLimit();
    message.maxMeters = (object.maxMeters !== undefined && object.maxMeters !== null)
      ? Long.fromValue(object.maxMeters)
      : undefined;
    message.softMaxMeters = (object.softMaxMeters !== undefined && object.softMaxMeters !== null)
      ? Long.fromValue(object.softMaxMeters)
      : undefined;
    message.costPerKilometerBelowSoftMax = object.costPerKilometerBelowSoftMax ?? undefined;
    message.costPerKilometerAboveSoftMax = object.costPerKilometerAboveSoftMax ?? undefined;
    return message;
  },
};

function createBaseTransitionAttributes(): TransitionAttributes {
  return {
    srcTag: "",
    excludedSrcTag: "",
    dstTag: "",
    excludedDstTag: "",
    cost: 0,
    costPerKilometer: 0,
    distanceLimit: undefined,
    delay: undefined,
  };
}

export const TransitionAttributes: MessageFns<TransitionAttributes> = {
  encode(message: TransitionAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcTag !== "") {
      writer.uint32(10).string(message.srcTag);
    }
    if (message.excludedSrcTag !== "") {
      writer.uint32(18).string(message.excludedSrcTag);
    }
    if (message.dstTag !== "") {
      writer.uint32(26).string(message.dstTag);
    }
    if (message.excludedDstTag !== "") {
      writer.uint32(34).string(message.excludedDstTag);
    }
    if (message.cost !== 0) {
      writer.uint32(41).double(message.cost);
    }
    if (message.costPerKilometer !== 0) {
      writer.uint32(49).double(message.costPerKilometer);
    }
    if (message.distanceLimit !== undefined) {
      DistanceLimit.encode(message.distanceLimit, writer.uint32(58).fork()).join();
    }
    if (message.delay !== undefined) {
      Duration.encode(message.delay, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.srcTag = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludedSrcTag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dstTag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.excludedDstTag = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.cost = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.costPerKilometer = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.distanceLimit = DistanceLimit.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.delay = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionAttributes {
    return {
      srcTag: isSet(object.srcTag) ? globalThis.String(object.srcTag) : "",
      excludedSrcTag: isSet(object.excludedSrcTag) ? globalThis.String(object.excludedSrcTag) : "",
      dstTag: isSet(object.dstTag) ? globalThis.String(object.dstTag) : "",
      excludedDstTag: isSet(object.excludedDstTag) ? globalThis.String(object.excludedDstTag) : "",
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      costPerKilometer: isSet(object.costPerKilometer) ? globalThis.Number(object.costPerKilometer) : 0,
      distanceLimit: isSet(object.distanceLimit) ? DistanceLimit.fromJSON(object.distanceLimit) : undefined,
      delay: isSet(object.delay) ? Duration.fromJSON(object.delay) : undefined,
    };
  },

  toJSON(message: TransitionAttributes): unknown {
    const obj: any = {};
    if (message.srcTag !== "") {
      obj.srcTag = message.srcTag;
    }
    if (message.excludedSrcTag !== "") {
      obj.excludedSrcTag = message.excludedSrcTag;
    }
    if (message.dstTag !== "") {
      obj.dstTag = message.dstTag;
    }
    if (message.excludedDstTag !== "") {
      obj.excludedDstTag = message.excludedDstTag;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.costPerKilometer !== 0) {
      obj.costPerKilometer = message.costPerKilometer;
    }
    if (message.distanceLimit !== undefined) {
      obj.distanceLimit = DistanceLimit.toJSON(message.distanceLimit);
    }
    if (message.delay !== undefined) {
      obj.delay = Duration.toJSON(message.delay);
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionAttributes>): TransitionAttributes {
    return TransitionAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionAttributes>): TransitionAttributes {
    const message = createBaseTransitionAttributes();
    message.srcTag = object.srcTag ?? "";
    message.excludedSrcTag = object.excludedSrcTag ?? "";
    message.dstTag = object.dstTag ?? "";
    message.excludedDstTag = object.excludedDstTag ?? "";
    message.cost = object.cost ?? 0;
    message.costPerKilometer = object.costPerKilometer ?? 0;
    message.distanceLimit = (object.distanceLimit !== undefined && object.distanceLimit !== null)
      ? DistanceLimit.fromPartial(object.distanceLimit)
      : undefined;
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? Duration.fromPartial(object.delay)
      : undefined;
    return message;
  },
};

function createBaseWaypoint(): Waypoint {
  return { location: undefined, placeId: undefined, sideOfRoad: false };
}

export const Waypoint: MessageFns<Waypoint> = {
  encode(message: Waypoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.placeId !== undefined) {
      writer.uint32(18).string(message.placeId);
    }
    if (message.sideOfRoad !== false) {
      writer.uint32(24).bool(message.sideOfRoad);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Waypoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sideOfRoad = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Waypoint {
    return {
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : undefined,
      sideOfRoad: isSet(object.sideOfRoad) ? globalThis.Boolean(object.sideOfRoad) : false,
    };
  },

  toJSON(message: Waypoint): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    if (message.placeId !== undefined) {
      obj.placeId = message.placeId;
    }
    if (message.sideOfRoad !== false) {
      obj.sideOfRoad = message.sideOfRoad;
    }
    return obj;
  },

  create(base?: DeepPartial<Waypoint>): Waypoint {
    return Waypoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Waypoint>): Waypoint {
    const message = createBaseWaypoint();
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    message.placeId = object.placeId ?? undefined;
    message.sideOfRoad = object.sideOfRoad ?? false;
    return message;
  },
};

function createBaseLocation(): Location {
  return { latLng: undefined, heading: undefined };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latLng !== undefined) {
      LatLng.encode(message.latLng, writer.uint32(10).fork()).join();
    }
    if (message.heading !== undefined) {
      writer.uint32(16).int32(message.heading);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.latLng = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heading = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      latLng: isSet(object.latLng) ? LatLng.fromJSON(object.latLng) : undefined,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : undefined,
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.latLng !== undefined) {
      obj.latLng = LatLng.toJSON(message.latLng);
    }
    if (message.heading !== undefined) {
      obj.heading = Math.round(message.heading);
    }
    return obj;
  },

  create(base?: DeepPartial<Location>): Location {
    return Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Location>): Location {
    const message = createBaseLocation();
    message.latLng = (object.latLng !== undefined && object.latLng !== null)
      ? LatLng.fromPartial(object.latLng)
      : undefined;
    message.heading = object.heading ?? undefined;
    return message;
  },
};

function createBaseBreakRule(): BreakRule {
  return { breakRequests: [], frequencyConstraints: [] };
}

export const BreakRule: MessageFns<BreakRule> = {
  encode(message: BreakRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.breakRequests) {
      BreakRule_BreakRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.frequencyConstraints) {
      BreakRule_FrequencyConstraint.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BreakRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.breakRequests.push(BreakRule_BreakRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.frequencyConstraints.push(BreakRule_FrequencyConstraint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BreakRule {
    return {
      breakRequests: globalThis.Array.isArray(object?.breakRequests)
        ? object.breakRequests.map((e: any) => BreakRule_BreakRequest.fromJSON(e))
        : [],
      frequencyConstraints: globalThis.Array.isArray(object?.frequencyConstraints)
        ? object.frequencyConstraints.map((e: any) => BreakRule_FrequencyConstraint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BreakRule): unknown {
    const obj: any = {};
    if (message.breakRequests?.length) {
      obj.breakRequests = message.breakRequests.map((e) => BreakRule_BreakRequest.toJSON(e));
    }
    if (message.frequencyConstraints?.length) {
      obj.frequencyConstraints = message.frequencyConstraints.map((e) => BreakRule_FrequencyConstraint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BreakRule>): BreakRule {
    return BreakRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BreakRule>): BreakRule {
    const message = createBaseBreakRule();
    message.breakRequests = object.breakRequests?.map((e) => BreakRule_BreakRequest.fromPartial(e)) || [];
    message.frequencyConstraints =
      object.frequencyConstraints?.map((e) => BreakRule_FrequencyConstraint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBreakRule_BreakRequest(): BreakRule_BreakRequest {
  return { earliestStartTime: undefined, latestStartTime: undefined, minDuration: undefined };
}

export const BreakRule_BreakRequest: MessageFns<BreakRule_BreakRequest> = {
  encode(message: BreakRule_BreakRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.earliestStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestStartTime), writer.uint32(10).fork()).join();
    }
    if (message.latestStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.latestStartTime), writer.uint32(18).fork()).join();
    }
    if (message.minDuration !== undefined) {
      Duration.encode(message.minDuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BreakRule_BreakRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakRule_BreakRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.earliestStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BreakRule_BreakRequest {
    return {
      earliestStartTime: isSet(object.earliestStartTime) ? fromJsonTimestamp(object.earliestStartTime) : undefined,
      latestStartTime: isSet(object.latestStartTime) ? fromJsonTimestamp(object.latestStartTime) : undefined,
      minDuration: isSet(object.minDuration) ? Duration.fromJSON(object.minDuration) : undefined,
    };
  },

  toJSON(message: BreakRule_BreakRequest): unknown {
    const obj: any = {};
    if (message.earliestStartTime !== undefined) {
      obj.earliestStartTime = message.earliestStartTime.toISOString();
    }
    if (message.latestStartTime !== undefined) {
      obj.latestStartTime = message.latestStartTime.toISOString();
    }
    if (message.minDuration !== undefined) {
      obj.minDuration = Duration.toJSON(message.minDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<BreakRule_BreakRequest>): BreakRule_BreakRequest {
    return BreakRule_BreakRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BreakRule_BreakRequest>): BreakRule_BreakRequest {
    const message = createBaseBreakRule_BreakRequest();
    message.earliestStartTime = object.earliestStartTime ?? undefined;
    message.latestStartTime = object.latestStartTime ?? undefined;
    message.minDuration = (object.minDuration !== undefined && object.minDuration !== null)
      ? Duration.fromPartial(object.minDuration)
      : undefined;
    return message;
  },
};

function createBaseBreakRule_FrequencyConstraint(): BreakRule_FrequencyConstraint {
  return { minBreakDuration: undefined, maxInterBreakDuration: undefined };
}

export const BreakRule_FrequencyConstraint: MessageFns<BreakRule_FrequencyConstraint> = {
  encode(message: BreakRule_FrequencyConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minBreakDuration !== undefined) {
      Duration.encode(message.minBreakDuration, writer.uint32(10).fork()).join();
    }
    if (message.maxInterBreakDuration !== undefined) {
      Duration.encode(message.maxInterBreakDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BreakRule_FrequencyConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakRule_FrequencyConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minBreakDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxInterBreakDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BreakRule_FrequencyConstraint {
    return {
      minBreakDuration: isSet(object.minBreakDuration) ? Duration.fromJSON(object.minBreakDuration) : undefined,
      maxInterBreakDuration: isSet(object.maxInterBreakDuration)
        ? Duration.fromJSON(object.maxInterBreakDuration)
        : undefined,
    };
  },

  toJSON(message: BreakRule_FrequencyConstraint): unknown {
    const obj: any = {};
    if (message.minBreakDuration !== undefined) {
      obj.minBreakDuration = Duration.toJSON(message.minBreakDuration);
    }
    if (message.maxInterBreakDuration !== undefined) {
      obj.maxInterBreakDuration = Duration.toJSON(message.maxInterBreakDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<BreakRule_FrequencyConstraint>): BreakRule_FrequencyConstraint {
    return BreakRule_FrequencyConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BreakRule_FrequencyConstraint>): BreakRule_FrequencyConstraint {
    const message = createBaseBreakRule_FrequencyConstraint();
    message.minBreakDuration = (object.minBreakDuration !== undefined && object.minBreakDuration !== null)
      ? Duration.fromPartial(object.minBreakDuration)
      : undefined;
    message.maxInterBreakDuration =
      (object.maxInterBreakDuration !== undefined && object.maxInterBreakDuration !== null)
        ? Duration.fromPartial(object.maxInterBreakDuration)
        : undefined;
    return message;
  },
};

function createBaseShipmentRoute(): ShipmentRoute {
  return {
    vehicleIndex: 0,
    vehicleLabel: "",
    vehicleStartTime: undefined,
    vehicleEndTime: undefined,
    visits: [],
    transitions: [],
    hasTrafficInfeasibilities: false,
    routePolyline: undefined,
    breaks: [],
    metrics: undefined,
    routeCosts: {},
    routeTotalCost: 0,
    endLoads: [],
    travelSteps: [],
    vehicleDetour: undefined,
    delayBeforeVehicleEnd: undefined,
  };
}

export const ShipmentRoute: MessageFns<ShipmentRoute> = {
  encode(message: ShipmentRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehicleIndex !== 0) {
      writer.uint32(8).int32(message.vehicleIndex);
    }
    if (message.vehicleLabel !== "") {
      writer.uint32(18).string(message.vehicleLabel);
    }
    if (message.vehicleStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.vehicleStartTime), writer.uint32(42).fork()).join();
    }
    if (message.vehicleEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.vehicleEndTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.visits) {
      ShipmentRoute_Visit.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.transitions) {
      ShipmentRoute_Transition.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.hasTrafficInfeasibilities !== false) {
      writer.uint32(72).bool(message.hasTrafficInfeasibilities);
    }
    if (message.routePolyline !== undefined) {
      ShipmentRoute_EncodedPolyline.encode(message.routePolyline, writer.uint32(82).fork()).join();
    }
    for (const v of message.breaks) {
      ShipmentRoute_Break.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.metrics !== undefined) {
      AggregatedMetrics.encode(message.metrics, writer.uint32(98).fork()).join();
    }
    Object.entries(message.routeCosts).forEach(([key, value]) => {
      ShipmentRoute_RouteCostsEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    if (message.routeTotalCost !== 0) {
      writer.uint32(145).double(message.routeTotalCost);
    }
    for (const v of message.endLoads) {
      CapacityQuantity.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.travelSteps) {
      ShipmentRoute_TravelStep.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.vehicleDetour !== undefined) {
      Duration.encode(message.vehicleDetour, writer.uint32(122).fork()).join();
    }
    if (message.delayBeforeVehicleEnd !== undefined) {
      ShipmentRoute_Delay.encode(message.delayBeforeVehicleEnd, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.vehicleIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vehicleLabel = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vehicleStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vehicleEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.visits.push(ShipmentRoute_Visit.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transitions.push(ShipmentRoute_Transition.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.hasTrafficInfeasibilities = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.routePolyline = ShipmentRoute_EncodedPolyline.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.breaks.push(ShipmentRoute_Break.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.metrics = AggregatedMetrics.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = ShipmentRoute_RouteCostsEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.routeCosts[entry17.key] = entry17.value;
          }
          continue;
        case 18:
          if (tag !== 145) {
            break;
          }

          message.routeTotalCost = reader.double();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.endLoads.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.travelSteps.push(ShipmentRoute_TravelStep.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.vehicleDetour = Duration.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.delayBeforeVehicleEnd = ShipmentRoute_Delay.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute {
    return {
      vehicleIndex: isSet(object.vehicleIndex) ? globalThis.Number(object.vehicleIndex) : 0,
      vehicleLabel: isSet(object.vehicleLabel) ? globalThis.String(object.vehicleLabel) : "",
      vehicleStartTime: isSet(object.vehicleStartTime) ? fromJsonTimestamp(object.vehicleStartTime) : undefined,
      vehicleEndTime: isSet(object.vehicleEndTime) ? fromJsonTimestamp(object.vehicleEndTime) : undefined,
      visits: globalThis.Array.isArray(object?.visits)
        ? object.visits.map((e: any) => ShipmentRoute_Visit.fromJSON(e))
        : [],
      transitions: globalThis.Array.isArray(object?.transitions)
        ? object.transitions.map((e: any) => ShipmentRoute_Transition.fromJSON(e))
        : [],
      hasTrafficInfeasibilities: isSet(object.hasTrafficInfeasibilities)
        ? globalThis.Boolean(object.hasTrafficInfeasibilities)
        : false,
      routePolyline: isSet(object.routePolyline)
        ? ShipmentRoute_EncodedPolyline.fromJSON(object.routePolyline)
        : undefined,
      breaks: globalThis.Array.isArray(object?.breaks)
        ? object.breaks.map((e: any) => ShipmentRoute_Break.fromJSON(e))
        : [],
      metrics: isSet(object.metrics) ? AggregatedMetrics.fromJSON(object.metrics) : undefined,
      routeCosts: isObject(object.routeCosts)
        ? Object.entries(object.routeCosts).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      routeTotalCost: isSet(object.routeTotalCost) ? globalThis.Number(object.routeTotalCost) : 0,
      endLoads: globalThis.Array.isArray(object?.endLoads)
        ? object.endLoads.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
      travelSteps: globalThis.Array.isArray(object?.travelSteps)
        ? object.travelSteps.map((e: any) => ShipmentRoute_TravelStep.fromJSON(e))
        : [],
      vehicleDetour: isSet(object.vehicleDetour) ? Duration.fromJSON(object.vehicleDetour) : undefined,
      delayBeforeVehicleEnd: isSet(object.delayBeforeVehicleEnd)
        ? ShipmentRoute_Delay.fromJSON(object.delayBeforeVehicleEnd)
        : undefined,
    };
  },

  toJSON(message: ShipmentRoute): unknown {
    const obj: any = {};
    if (message.vehicleIndex !== 0) {
      obj.vehicleIndex = Math.round(message.vehicleIndex);
    }
    if (message.vehicleLabel !== "") {
      obj.vehicleLabel = message.vehicleLabel;
    }
    if (message.vehicleStartTime !== undefined) {
      obj.vehicleStartTime = message.vehicleStartTime.toISOString();
    }
    if (message.vehicleEndTime !== undefined) {
      obj.vehicleEndTime = message.vehicleEndTime.toISOString();
    }
    if (message.visits?.length) {
      obj.visits = message.visits.map((e) => ShipmentRoute_Visit.toJSON(e));
    }
    if (message.transitions?.length) {
      obj.transitions = message.transitions.map((e) => ShipmentRoute_Transition.toJSON(e));
    }
    if (message.hasTrafficInfeasibilities !== false) {
      obj.hasTrafficInfeasibilities = message.hasTrafficInfeasibilities;
    }
    if (message.routePolyline !== undefined) {
      obj.routePolyline = ShipmentRoute_EncodedPolyline.toJSON(message.routePolyline);
    }
    if (message.breaks?.length) {
      obj.breaks = message.breaks.map((e) => ShipmentRoute_Break.toJSON(e));
    }
    if (message.metrics !== undefined) {
      obj.metrics = AggregatedMetrics.toJSON(message.metrics);
    }
    if (message.routeCosts) {
      const entries = Object.entries(message.routeCosts);
      if (entries.length > 0) {
        obj.routeCosts = {};
        entries.forEach(([k, v]) => {
          obj.routeCosts[k] = v;
        });
      }
    }
    if (message.routeTotalCost !== 0) {
      obj.routeTotalCost = message.routeTotalCost;
    }
    if (message.endLoads?.length) {
      obj.endLoads = message.endLoads.map((e) => CapacityQuantity.toJSON(e));
    }
    if (message.travelSteps?.length) {
      obj.travelSteps = message.travelSteps.map((e) => ShipmentRoute_TravelStep.toJSON(e));
    }
    if (message.vehicleDetour !== undefined) {
      obj.vehicleDetour = Duration.toJSON(message.vehicleDetour);
    }
    if (message.delayBeforeVehicleEnd !== undefined) {
      obj.delayBeforeVehicleEnd = ShipmentRoute_Delay.toJSON(message.delayBeforeVehicleEnd);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute>): ShipmentRoute {
    return ShipmentRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute>): ShipmentRoute {
    const message = createBaseShipmentRoute();
    message.vehicleIndex = object.vehicleIndex ?? 0;
    message.vehicleLabel = object.vehicleLabel ?? "";
    message.vehicleStartTime = object.vehicleStartTime ?? undefined;
    message.vehicleEndTime = object.vehicleEndTime ?? undefined;
    message.visits = object.visits?.map((e) => ShipmentRoute_Visit.fromPartial(e)) || [];
    message.transitions = object.transitions?.map((e) => ShipmentRoute_Transition.fromPartial(e)) || [];
    message.hasTrafficInfeasibilities = object.hasTrafficInfeasibilities ?? false;
    message.routePolyline = (object.routePolyline !== undefined && object.routePolyline !== null)
      ? ShipmentRoute_EncodedPolyline.fromPartial(object.routePolyline)
      : undefined;
    message.breaks = object.breaks?.map((e) => ShipmentRoute_Break.fromPartial(e)) || [];
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? AggregatedMetrics.fromPartial(object.metrics)
      : undefined;
    message.routeCosts = Object.entries(object.routeCosts ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.routeTotalCost = object.routeTotalCost ?? 0;
    message.endLoads = object.endLoads?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    message.travelSteps = object.travelSteps?.map((e) => ShipmentRoute_TravelStep.fromPartial(e)) || [];
    message.vehicleDetour = (object.vehicleDetour !== undefined && object.vehicleDetour !== null)
      ? Duration.fromPartial(object.vehicleDetour)
      : undefined;
    message.delayBeforeVehicleEnd =
      (object.delayBeforeVehicleEnd !== undefined && object.delayBeforeVehicleEnd !== null)
        ? ShipmentRoute_Delay.fromPartial(object.delayBeforeVehicleEnd)
        : undefined;
    return message;
  },
};

function createBaseShipmentRoute_Delay(): ShipmentRoute_Delay {
  return { startTime: undefined, duration: undefined };
}

export const ShipmentRoute_Delay: MessageFns<ShipmentRoute_Delay> = {
  encode(message: ShipmentRoute_Delay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Delay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Delay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Delay {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: ShipmentRoute_Delay): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Delay>): ShipmentRoute_Delay {
    return ShipmentRoute_Delay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_Delay>): ShipmentRoute_Delay {
    const message = createBaseShipmentRoute_Delay();
    message.startTime = object.startTime ?? undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseShipmentRoute_Visit(): ShipmentRoute_Visit {
  return {
    shipmentIndex: 0,
    isPickup: false,
    visitRequestIndex: 0,
    startTime: undefined,
    loadDemands: {},
    detour: undefined,
    shipmentLabel: "",
    visitLabel: "",
    arrivalLoads: [],
    delayBeforeStart: undefined,
    demands: [],
  };
}

export const ShipmentRoute_Visit: MessageFns<ShipmentRoute_Visit> = {
  encode(message: ShipmentRoute_Visit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shipmentIndex !== 0) {
      writer.uint32(8).int32(message.shipmentIndex);
    }
    if (message.isPickup !== false) {
      writer.uint32(16).bool(message.isPickup);
    }
    if (message.visitRequestIndex !== 0) {
      writer.uint32(24).int32(message.visitRequestIndex);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.loadDemands).forEach(([key, value]) => {
      ShipmentRoute_Visit_LoadDemandsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.detour !== undefined) {
      Duration.encode(message.detour, writer.uint32(50).fork()).join();
    }
    if (message.shipmentLabel !== "") {
      writer.uint32(58).string(message.shipmentLabel);
    }
    if (message.visitLabel !== "") {
      writer.uint32(66).string(message.visitLabel);
    }
    for (const v of message.arrivalLoads) {
      CapacityQuantity.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.delayBeforeStart !== undefined) {
      ShipmentRoute_Delay.encode(message.delayBeforeStart, writer.uint32(82).fork()).join();
    }
    for (const v of message.demands) {
      CapacityQuantity.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Visit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Visit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shipmentIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPickup = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.visitRequestIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = ShipmentRoute_Visit_LoadDemandsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.loadDemands[entry11.key] = entry11.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.detour = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shipmentLabel = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.visitLabel = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.arrivalLoads.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.delayBeforeStart = ShipmentRoute_Delay.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.demands.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Visit {
    return {
      shipmentIndex: isSet(object.shipmentIndex) ? globalThis.Number(object.shipmentIndex) : 0,
      isPickup: isSet(object.isPickup) ? globalThis.Boolean(object.isPickup) : false,
      visitRequestIndex: isSet(object.visitRequestIndex) ? globalThis.Number(object.visitRequestIndex) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      loadDemands: isObject(object.loadDemands)
        ? Object.entries(object.loadDemands).reduce<{ [key: string]: Shipment_Load }>((acc, [key, value]) => {
          acc[key] = Shipment_Load.fromJSON(value);
          return acc;
        }, {})
        : {},
      detour: isSet(object.detour) ? Duration.fromJSON(object.detour) : undefined,
      shipmentLabel: isSet(object.shipmentLabel) ? globalThis.String(object.shipmentLabel) : "",
      visitLabel: isSet(object.visitLabel) ? globalThis.String(object.visitLabel) : "",
      arrivalLoads: globalThis.Array.isArray(object?.arrivalLoads)
        ? object.arrivalLoads.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
      delayBeforeStart: isSet(object.delayBeforeStart)
        ? ShipmentRoute_Delay.fromJSON(object.delayBeforeStart)
        : undefined,
      demands: globalThis.Array.isArray(object?.demands)
        ? object.demands.map((e: any) => CapacityQuantity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ShipmentRoute_Visit): unknown {
    const obj: any = {};
    if (message.shipmentIndex !== 0) {
      obj.shipmentIndex = Math.round(message.shipmentIndex);
    }
    if (message.isPickup !== false) {
      obj.isPickup = message.isPickup;
    }
    if (message.visitRequestIndex !== 0) {
      obj.visitRequestIndex = Math.round(message.visitRequestIndex);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.loadDemands) {
      const entries = Object.entries(message.loadDemands);
      if (entries.length > 0) {
        obj.loadDemands = {};
        entries.forEach(([k, v]) => {
          obj.loadDemands[k] = Shipment_Load.toJSON(v);
        });
      }
    }
    if (message.detour !== undefined) {
      obj.detour = Duration.toJSON(message.detour);
    }
    if (message.shipmentLabel !== "") {
      obj.shipmentLabel = message.shipmentLabel;
    }
    if (message.visitLabel !== "") {
      obj.visitLabel = message.visitLabel;
    }
    if (message.arrivalLoads?.length) {
      obj.arrivalLoads = message.arrivalLoads.map((e) => CapacityQuantity.toJSON(e));
    }
    if (message.delayBeforeStart !== undefined) {
      obj.delayBeforeStart = ShipmentRoute_Delay.toJSON(message.delayBeforeStart);
    }
    if (message.demands?.length) {
      obj.demands = message.demands.map((e) => CapacityQuantity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Visit>): ShipmentRoute_Visit {
    return ShipmentRoute_Visit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_Visit>): ShipmentRoute_Visit {
    const message = createBaseShipmentRoute_Visit();
    message.shipmentIndex = object.shipmentIndex ?? 0;
    message.isPickup = object.isPickup ?? false;
    message.visitRequestIndex = object.visitRequestIndex ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.loadDemands = Object.entries(object.loadDemands ?? {}).reduce<{ [key: string]: Shipment_Load }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Shipment_Load.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.detour = (object.detour !== undefined && object.detour !== null)
      ? Duration.fromPartial(object.detour)
      : undefined;
    message.shipmentLabel = object.shipmentLabel ?? "";
    message.visitLabel = object.visitLabel ?? "";
    message.arrivalLoads = object.arrivalLoads?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    message.delayBeforeStart = (object.delayBeforeStart !== undefined && object.delayBeforeStart !== null)
      ? ShipmentRoute_Delay.fromPartial(object.delayBeforeStart)
      : undefined;
    message.demands = object.demands?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipmentRoute_Visit_LoadDemandsEntry(): ShipmentRoute_Visit_LoadDemandsEntry {
  return { key: "", value: undefined };
}

export const ShipmentRoute_Visit_LoadDemandsEntry: MessageFns<ShipmentRoute_Visit_LoadDemandsEntry> = {
  encode(message: ShipmentRoute_Visit_LoadDemandsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Shipment_Load.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Visit_LoadDemandsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Visit_LoadDemandsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Shipment_Load.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Visit_LoadDemandsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Shipment_Load.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ShipmentRoute_Visit_LoadDemandsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Shipment_Load.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Visit_LoadDemandsEntry>): ShipmentRoute_Visit_LoadDemandsEntry {
    return ShipmentRoute_Visit_LoadDemandsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_Visit_LoadDemandsEntry>): ShipmentRoute_Visit_LoadDemandsEntry {
    const message = createBaseShipmentRoute_Visit_LoadDemandsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Shipment_Load.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseShipmentRoute_Transition(): ShipmentRoute_Transition {
  return {
    travelDuration: undefined,
    travelDistanceMeters: 0,
    trafficInfoUnavailable: false,
    delayDuration: undefined,
    breakDuration: undefined,
    waitDuration: undefined,
    totalDuration: undefined,
    startTime: undefined,
    routePolyline: undefined,
    vehicleLoads: {},
    loads: [],
  };
}

export const ShipmentRoute_Transition: MessageFns<ShipmentRoute_Transition> = {
  encode(message: ShipmentRoute_Transition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.travelDuration !== undefined) {
      Duration.encode(message.travelDuration, writer.uint32(10).fork()).join();
    }
    if (message.travelDistanceMeters !== 0) {
      writer.uint32(17).double(message.travelDistanceMeters);
    }
    if (message.trafficInfoUnavailable !== false) {
      writer.uint32(24).bool(message.trafficInfoUnavailable);
    }
    if (message.delayDuration !== undefined) {
      Duration.encode(message.delayDuration, writer.uint32(34).fork()).join();
    }
    if (message.breakDuration !== undefined) {
      Duration.encode(message.breakDuration, writer.uint32(42).fork()).join();
    }
    if (message.waitDuration !== undefined) {
      Duration.encode(message.waitDuration, writer.uint32(50).fork()).join();
    }
    if (message.totalDuration !== undefined) {
      Duration.encode(message.totalDuration, writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(66).fork()).join();
    }
    if (message.routePolyline !== undefined) {
      ShipmentRoute_EncodedPolyline.encode(message.routePolyline, writer.uint32(74).fork()).join();
    }
    Object.entries(message.vehicleLoads).forEach(([key, value]) => {
      ShipmentRoute_Transition_VehicleLoadsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    for (const v of message.loads) {
      CapacityQuantity.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Transition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Transition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.travelDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.travelDistanceMeters = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.trafficInfoUnavailable = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.delayDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.breakDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.waitDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.totalDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.routePolyline = ShipmentRoute_EncodedPolyline.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = ShipmentRoute_Transition_VehicleLoadsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.vehicleLoads[entry11.key] = entry11.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.loads.push(CapacityQuantity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Transition {
    return {
      travelDuration: isSet(object.travelDuration) ? Duration.fromJSON(object.travelDuration) : undefined,
      travelDistanceMeters: isSet(object.travelDistanceMeters) ? globalThis.Number(object.travelDistanceMeters) : 0,
      trafficInfoUnavailable: isSet(object.trafficInfoUnavailable)
        ? globalThis.Boolean(object.trafficInfoUnavailable)
        : false,
      delayDuration: isSet(object.delayDuration) ? Duration.fromJSON(object.delayDuration) : undefined,
      breakDuration: isSet(object.breakDuration) ? Duration.fromJSON(object.breakDuration) : undefined,
      waitDuration: isSet(object.waitDuration) ? Duration.fromJSON(object.waitDuration) : undefined,
      totalDuration: isSet(object.totalDuration) ? Duration.fromJSON(object.totalDuration) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      routePolyline: isSet(object.routePolyline)
        ? ShipmentRoute_EncodedPolyline.fromJSON(object.routePolyline)
        : undefined,
      vehicleLoads: isObject(object.vehicleLoads)
        ? Object.entries(object.vehicleLoads).reduce<{ [key: string]: ShipmentRoute_VehicleLoad }>(
          (acc, [key, value]) => {
            acc[key] = ShipmentRoute_VehicleLoad.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      loads: globalThis.Array.isArray(object?.loads) ? object.loads.map((e: any) => CapacityQuantity.fromJSON(e)) : [],
    };
  },

  toJSON(message: ShipmentRoute_Transition): unknown {
    const obj: any = {};
    if (message.travelDuration !== undefined) {
      obj.travelDuration = Duration.toJSON(message.travelDuration);
    }
    if (message.travelDistanceMeters !== 0) {
      obj.travelDistanceMeters = message.travelDistanceMeters;
    }
    if (message.trafficInfoUnavailable !== false) {
      obj.trafficInfoUnavailable = message.trafficInfoUnavailable;
    }
    if (message.delayDuration !== undefined) {
      obj.delayDuration = Duration.toJSON(message.delayDuration);
    }
    if (message.breakDuration !== undefined) {
      obj.breakDuration = Duration.toJSON(message.breakDuration);
    }
    if (message.waitDuration !== undefined) {
      obj.waitDuration = Duration.toJSON(message.waitDuration);
    }
    if (message.totalDuration !== undefined) {
      obj.totalDuration = Duration.toJSON(message.totalDuration);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.routePolyline !== undefined) {
      obj.routePolyline = ShipmentRoute_EncodedPolyline.toJSON(message.routePolyline);
    }
    if (message.vehicleLoads) {
      const entries = Object.entries(message.vehicleLoads);
      if (entries.length > 0) {
        obj.vehicleLoads = {};
        entries.forEach(([k, v]) => {
          obj.vehicleLoads[k] = ShipmentRoute_VehicleLoad.toJSON(v);
        });
      }
    }
    if (message.loads?.length) {
      obj.loads = message.loads.map((e) => CapacityQuantity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Transition>): ShipmentRoute_Transition {
    return ShipmentRoute_Transition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_Transition>): ShipmentRoute_Transition {
    const message = createBaseShipmentRoute_Transition();
    message.travelDuration = (object.travelDuration !== undefined && object.travelDuration !== null)
      ? Duration.fromPartial(object.travelDuration)
      : undefined;
    message.travelDistanceMeters = object.travelDistanceMeters ?? 0;
    message.trafficInfoUnavailable = object.trafficInfoUnavailable ?? false;
    message.delayDuration = (object.delayDuration !== undefined && object.delayDuration !== null)
      ? Duration.fromPartial(object.delayDuration)
      : undefined;
    message.breakDuration = (object.breakDuration !== undefined && object.breakDuration !== null)
      ? Duration.fromPartial(object.breakDuration)
      : undefined;
    message.waitDuration = (object.waitDuration !== undefined && object.waitDuration !== null)
      ? Duration.fromPartial(object.waitDuration)
      : undefined;
    message.totalDuration = (object.totalDuration !== undefined && object.totalDuration !== null)
      ? Duration.fromPartial(object.totalDuration)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.routePolyline = (object.routePolyline !== undefined && object.routePolyline !== null)
      ? ShipmentRoute_EncodedPolyline.fromPartial(object.routePolyline)
      : undefined;
    message.vehicleLoads = Object.entries(object.vehicleLoads ?? {}).reduce<
      { [key: string]: ShipmentRoute_VehicleLoad }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ShipmentRoute_VehicleLoad.fromPartial(value);
      }
      return acc;
    }, {});
    message.loads = object.loads?.map((e) => CapacityQuantity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipmentRoute_Transition_VehicleLoadsEntry(): ShipmentRoute_Transition_VehicleLoadsEntry {
  return { key: "", value: undefined };
}

export const ShipmentRoute_Transition_VehicleLoadsEntry: MessageFns<ShipmentRoute_Transition_VehicleLoadsEntry> = {
  encode(message: ShipmentRoute_Transition_VehicleLoadsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ShipmentRoute_VehicleLoad.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Transition_VehicleLoadsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Transition_VehicleLoadsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ShipmentRoute_VehicleLoad.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Transition_VehicleLoadsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ShipmentRoute_VehicleLoad.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ShipmentRoute_Transition_VehicleLoadsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ShipmentRoute_VehicleLoad.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Transition_VehicleLoadsEntry>): ShipmentRoute_Transition_VehicleLoadsEntry {
    return ShipmentRoute_Transition_VehicleLoadsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ShipmentRoute_Transition_VehicleLoadsEntry>,
  ): ShipmentRoute_Transition_VehicleLoadsEntry {
    const message = createBaseShipmentRoute_Transition_VehicleLoadsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ShipmentRoute_VehicleLoad.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseShipmentRoute_VehicleLoad(): ShipmentRoute_VehicleLoad {
  return { amount: Long.ZERO };
}

export const ShipmentRoute_VehicleLoad: MessageFns<ShipmentRoute_VehicleLoad> = {
  encode(message: ShipmentRoute_VehicleLoad, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.amount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_VehicleLoad {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_VehicleLoad();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.amount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_VehicleLoad {
    return { amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO };
  },

  toJSON(message: ShipmentRoute_VehicleLoad): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_VehicleLoad>): ShipmentRoute_VehicleLoad {
    return ShipmentRoute_VehicleLoad.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_VehicleLoad>): ShipmentRoute_VehicleLoad {
    const message = createBaseShipmentRoute_VehicleLoad();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function createBaseShipmentRoute_EncodedPolyline(): ShipmentRoute_EncodedPolyline {
  return { points: "" };
}

export const ShipmentRoute_EncodedPolyline: MessageFns<ShipmentRoute_EncodedPolyline> = {
  encode(message: ShipmentRoute_EncodedPolyline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== "") {
      writer.uint32(10).string(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_EncodedPolyline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_EncodedPolyline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.points = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_EncodedPolyline {
    return { points: isSet(object.points) ? globalThis.String(object.points) : "" };
  },

  toJSON(message: ShipmentRoute_EncodedPolyline): unknown {
    const obj: any = {};
    if (message.points !== "") {
      obj.points = message.points;
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_EncodedPolyline>): ShipmentRoute_EncodedPolyline {
    return ShipmentRoute_EncodedPolyline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_EncodedPolyline>): ShipmentRoute_EncodedPolyline {
    const message = createBaseShipmentRoute_EncodedPolyline();
    message.points = object.points ?? "";
    return message;
  },
};

function createBaseShipmentRoute_Break(): ShipmentRoute_Break {
  return { startTime: undefined, duration: undefined };
}

export const ShipmentRoute_Break: MessageFns<ShipmentRoute_Break> = {
  encode(message: ShipmentRoute_Break, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_Break {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_Break();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_Break {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: ShipmentRoute_Break): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_Break>): ShipmentRoute_Break {
    return ShipmentRoute_Break.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_Break>): ShipmentRoute_Break {
    const message = createBaseShipmentRoute_Break();
    message.startTime = object.startTime ?? undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseShipmentRoute_TravelStep(): ShipmentRoute_TravelStep {
  return { duration: undefined, distanceMeters: 0, trafficInfoUnavailable: false, routePolyline: undefined };
}

export const ShipmentRoute_TravelStep: MessageFns<ShipmentRoute_TravelStep> = {
  encode(message: ShipmentRoute_TravelStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(17).double(message.distanceMeters);
    }
    if (message.trafficInfoUnavailable !== false) {
      writer.uint32(24).bool(message.trafficInfoUnavailable);
    }
    if (message.routePolyline !== undefined) {
      ShipmentRoute_EncodedPolyline.encode(message.routePolyline, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_TravelStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_TravelStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.distanceMeters = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.trafficInfoUnavailable = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.routePolyline = ShipmentRoute_EncodedPolyline.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_TravelStep {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      trafficInfoUnavailable: isSet(object.trafficInfoUnavailable)
        ? globalThis.Boolean(object.trafficInfoUnavailable)
        : false,
      routePolyline: isSet(object.routePolyline)
        ? ShipmentRoute_EncodedPolyline.fromJSON(object.routePolyline)
        : undefined,
    };
  },

  toJSON(message: ShipmentRoute_TravelStep): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = message.distanceMeters;
    }
    if (message.trafficInfoUnavailable !== false) {
      obj.trafficInfoUnavailable = message.trafficInfoUnavailable;
    }
    if (message.routePolyline !== undefined) {
      obj.routePolyline = ShipmentRoute_EncodedPolyline.toJSON(message.routePolyline);
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_TravelStep>): ShipmentRoute_TravelStep {
    return ShipmentRoute_TravelStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_TravelStep>): ShipmentRoute_TravelStep {
    const message = createBaseShipmentRoute_TravelStep();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.distanceMeters = object.distanceMeters ?? 0;
    message.trafficInfoUnavailable = object.trafficInfoUnavailable ?? false;
    message.routePolyline = (object.routePolyline !== undefined && object.routePolyline !== null)
      ? ShipmentRoute_EncodedPolyline.fromPartial(object.routePolyline)
      : undefined;
    return message;
  },
};

function createBaseShipmentRoute_RouteCostsEntry(): ShipmentRoute_RouteCostsEntry {
  return { key: "", value: 0 };
}

export const ShipmentRoute_RouteCostsEntry: MessageFns<ShipmentRoute_RouteCostsEntry> = {
  encode(message: ShipmentRoute_RouteCostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipmentRoute_RouteCostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipmentRoute_RouteCostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipmentRoute_RouteCostsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ShipmentRoute_RouteCostsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ShipmentRoute_RouteCostsEntry>): ShipmentRoute_RouteCostsEntry {
    return ShipmentRoute_RouteCostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShipmentRoute_RouteCostsEntry>): ShipmentRoute_RouteCostsEntry {
    const message = createBaseShipmentRoute_RouteCostsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSkippedShipment(): SkippedShipment {
  return { index: 0, label: "", reasons: [] };
}

export const SkippedShipment: MessageFns<SkippedShipment> = {
  encode(message: SkippedShipment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    for (const v of message.reasons) {
      SkippedShipment_Reason.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkippedShipment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkippedShipment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reasons.push(SkippedShipment_Reason.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkippedShipment {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => SkippedShipment_Reason.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SkippedShipment): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => SkippedShipment_Reason.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SkippedShipment>): SkippedShipment {
    return SkippedShipment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkippedShipment>): SkippedShipment {
    const message = createBaseSkippedShipment();
    message.index = object.index ?? 0;
    message.label = object.label ?? "";
    message.reasons = object.reasons?.map((e) => SkippedShipment_Reason.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkippedShipment_Reason(): SkippedShipment_Reason {
  return { code: 0, exampleVehicleIndex: undefined, exampleExceededCapacityType: "" };
}

export const SkippedShipment_Reason: MessageFns<SkippedShipment_Reason> = {
  encode(message: SkippedShipment_Reason, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.exampleVehicleIndex !== undefined) {
      writer.uint32(16).int32(message.exampleVehicleIndex);
    }
    if (message.exampleExceededCapacityType !== "") {
      writer.uint32(26).string(message.exampleExceededCapacityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkippedShipment_Reason {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkippedShipment_Reason();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.exampleVehicleIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exampleExceededCapacityType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkippedShipment_Reason {
    return {
      code: isSet(object.code) ? skippedShipment_Reason_CodeFromJSON(object.code) : 0,
      exampleVehicleIndex: isSet(object.exampleVehicleIndex)
        ? globalThis.Number(object.exampleVehicleIndex)
        : undefined,
      exampleExceededCapacityType: isSet(object.exampleExceededCapacityType)
        ? globalThis.String(object.exampleExceededCapacityType)
        : "",
    };
  },

  toJSON(message: SkippedShipment_Reason): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = skippedShipment_Reason_CodeToJSON(message.code);
    }
    if (message.exampleVehicleIndex !== undefined) {
      obj.exampleVehicleIndex = Math.round(message.exampleVehicleIndex);
    }
    if (message.exampleExceededCapacityType !== "") {
      obj.exampleExceededCapacityType = message.exampleExceededCapacityType;
    }
    return obj;
  },

  create(base?: DeepPartial<SkippedShipment_Reason>): SkippedShipment_Reason {
    return SkippedShipment_Reason.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkippedShipment_Reason>): SkippedShipment_Reason {
    const message = createBaseSkippedShipment_Reason();
    message.code = object.code ?? 0;
    message.exampleVehicleIndex = object.exampleVehicleIndex ?? undefined;
    message.exampleExceededCapacityType = object.exampleExceededCapacityType ?? "";
    return message;
  },
};

function createBaseAggregatedMetrics(): AggregatedMetrics {
  return {
    performedShipmentCount: 0,
    travelDuration: undefined,
    waitDuration: undefined,
    delayDuration: undefined,
    breakDuration: undefined,
    visitDuration: undefined,
    totalDuration: undefined,
    travelDistanceMeters: 0,
    maxLoads: {},
    costs: {},
    totalCost: 0,
  };
}

export const AggregatedMetrics: MessageFns<AggregatedMetrics> = {
  encode(message: AggregatedMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.performedShipmentCount !== 0) {
      writer.uint32(8).int32(message.performedShipmentCount);
    }
    if (message.travelDuration !== undefined) {
      Duration.encode(message.travelDuration, writer.uint32(18).fork()).join();
    }
    if (message.waitDuration !== undefined) {
      Duration.encode(message.waitDuration, writer.uint32(26).fork()).join();
    }
    if (message.delayDuration !== undefined) {
      Duration.encode(message.delayDuration, writer.uint32(34).fork()).join();
    }
    if (message.breakDuration !== undefined) {
      Duration.encode(message.breakDuration, writer.uint32(42).fork()).join();
    }
    if (message.visitDuration !== undefined) {
      Duration.encode(message.visitDuration, writer.uint32(50).fork()).join();
    }
    if (message.totalDuration !== undefined) {
      Duration.encode(message.totalDuration, writer.uint32(58).fork()).join();
    }
    if (message.travelDistanceMeters !== 0) {
      writer.uint32(65).double(message.travelDistanceMeters);
    }
    Object.entries(message.maxLoads).forEach(([key, value]) => {
      AggregatedMetrics_MaxLoadsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.costs).forEach(([key, value]) => {
      AggregatedMetrics_CostsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.totalCost !== 0) {
      writer.uint32(89).double(message.totalCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.performedShipmentCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.travelDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.waitDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.delayDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.breakDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.visitDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.totalDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.travelDistanceMeters = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = AggregatedMetrics_MaxLoadsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.maxLoads[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = AggregatedMetrics_CostsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.costs[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.totalCost = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedMetrics {
    return {
      performedShipmentCount: isSet(object.performedShipmentCount)
        ? globalThis.Number(object.performedShipmentCount)
        : 0,
      travelDuration: isSet(object.travelDuration) ? Duration.fromJSON(object.travelDuration) : undefined,
      waitDuration: isSet(object.waitDuration) ? Duration.fromJSON(object.waitDuration) : undefined,
      delayDuration: isSet(object.delayDuration) ? Duration.fromJSON(object.delayDuration) : undefined,
      breakDuration: isSet(object.breakDuration) ? Duration.fromJSON(object.breakDuration) : undefined,
      visitDuration: isSet(object.visitDuration) ? Duration.fromJSON(object.visitDuration) : undefined,
      totalDuration: isSet(object.totalDuration) ? Duration.fromJSON(object.totalDuration) : undefined,
      travelDistanceMeters: isSet(object.travelDistanceMeters) ? globalThis.Number(object.travelDistanceMeters) : 0,
      maxLoads: isObject(object.maxLoads)
        ? Object.entries(object.maxLoads).reduce<{ [key: string]: ShipmentRoute_VehicleLoad }>((acc, [key, value]) => {
          acc[key] = ShipmentRoute_VehicleLoad.fromJSON(value);
          return acc;
        }, {})
        : {},
      costs: isObject(object.costs)
        ? Object.entries(object.costs).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
    };
  },

  toJSON(message: AggregatedMetrics): unknown {
    const obj: any = {};
    if (message.performedShipmentCount !== 0) {
      obj.performedShipmentCount = Math.round(message.performedShipmentCount);
    }
    if (message.travelDuration !== undefined) {
      obj.travelDuration = Duration.toJSON(message.travelDuration);
    }
    if (message.waitDuration !== undefined) {
      obj.waitDuration = Duration.toJSON(message.waitDuration);
    }
    if (message.delayDuration !== undefined) {
      obj.delayDuration = Duration.toJSON(message.delayDuration);
    }
    if (message.breakDuration !== undefined) {
      obj.breakDuration = Duration.toJSON(message.breakDuration);
    }
    if (message.visitDuration !== undefined) {
      obj.visitDuration = Duration.toJSON(message.visitDuration);
    }
    if (message.totalDuration !== undefined) {
      obj.totalDuration = Duration.toJSON(message.totalDuration);
    }
    if (message.travelDistanceMeters !== 0) {
      obj.travelDistanceMeters = message.travelDistanceMeters;
    }
    if (message.maxLoads) {
      const entries = Object.entries(message.maxLoads);
      if (entries.length > 0) {
        obj.maxLoads = {};
        entries.forEach(([k, v]) => {
          obj.maxLoads[k] = ShipmentRoute_VehicleLoad.toJSON(v);
        });
      }
    }
    if (message.costs) {
      const entries = Object.entries(message.costs);
      if (entries.length > 0) {
        obj.costs = {};
        entries.forEach(([k, v]) => {
          obj.costs[k] = v;
        });
      }
    }
    if (message.totalCost !== 0) {
      obj.totalCost = message.totalCost;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedMetrics>): AggregatedMetrics {
    return AggregatedMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedMetrics>): AggregatedMetrics {
    const message = createBaseAggregatedMetrics();
    message.performedShipmentCount = object.performedShipmentCount ?? 0;
    message.travelDuration = (object.travelDuration !== undefined && object.travelDuration !== null)
      ? Duration.fromPartial(object.travelDuration)
      : undefined;
    message.waitDuration = (object.waitDuration !== undefined && object.waitDuration !== null)
      ? Duration.fromPartial(object.waitDuration)
      : undefined;
    message.delayDuration = (object.delayDuration !== undefined && object.delayDuration !== null)
      ? Duration.fromPartial(object.delayDuration)
      : undefined;
    message.breakDuration = (object.breakDuration !== undefined && object.breakDuration !== null)
      ? Duration.fromPartial(object.breakDuration)
      : undefined;
    message.visitDuration = (object.visitDuration !== undefined && object.visitDuration !== null)
      ? Duration.fromPartial(object.visitDuration)
      : undefined;
    message.totalDuration = (object.totalDuration !== undefined && object.totalDuration !== null)
      ? Duration.fromPartial(object.totalDuration)
      : undefined;
    message.travelDistanceMeters = object.travelDistanceMeters ?? 0;
    message.maxLoads = Object.entries(object.maxLoads ?? {}).reduce<{ [key: string]: ShipmentRoute_VehicleLoad }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ShipmentRoute_VehicleLoad.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.costs = Object.entries(object.costs ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

function createBaseAggregatedMetrics_MaxLoadsEntry(): AggregatedMetrics_MaxLoadsEntry {
  return { key: "", value: undefined };
}

export const AggregatedMetrics_MaxLoadsEntry: MessageFns<AggregatedMetrics_MaxLoadsEntry> = {
  encode(message: AggregatedMetrics_MaxLoadsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ShipmentRoute_VehicleLoad.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedMetrics_MaxLoadsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedMetrics_MaxLoadsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ShipmentRoute_VehicleLoad.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedMetrics_MaxLoadsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ShipmentRoute_VehicleLoad.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AggregatedMetrics_MaxLoadsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ShipmentRoute_VehicleLoad.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedMetrics_MaxLoadsEntry>): AggregatedMetrics_MaxLoadsEntry {
    return AggregatedMetrics_MaxLoadsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedMetrics_MaxLoadsEntry>): AggregatedMetrics_MaxLoadsEntry {
    const message = createBaseAggregatedMetrics_MaxLoadsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ShipmentRoute_VehicleLoad.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAggregatedMetrics_CostsEntry(): AggregatedMetrics_CostsEntry {
  return { key: "", value: 0 };
}

export const AggregatedMetrics_CostsEntry: MessageFns<AggregatedMetrics_CostsEntry> = {
  encode(message: AggregatedMetrics_CostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedMetrics_CostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedMetrics_CostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedMetrics_CostsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: AggregatedMetrics_CostsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedMetrics_CostsEntry>): AggregatedMetrics_CostsEntry {
    return AggregatedMetrics_CostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedMetrics_CostsEntry>): AggregatedMetrics_CostsEntry {
    const message = createBaseAggregatedMetrics_CostsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseInjectedSolutionConstraint(): InjectedSolutionConstraint {
  return { routes: [], skippedShipments: [], constraintRelaxations: [] };
}

export const InjectedSolutionConstraint: MessageFns<InjectedSolutionConstraint> = {
  encode(message: InjectedSolutionConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      ShipmentRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.skippedShipments) {
      SkippedShipment.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.constraintRelaxations) {
      InjectedSolutionConstraint_ConstraintRelaxation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InjectedSolutionConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInjectedSolutionConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routes.push(ShipmentRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skippedShipments.push(SkippedShipment.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constraintRelaxations.push(
            InjectedSolutionConstraint_ConstraintRelaxation.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InjectedSolutionConstraint {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => ShipmentRoute.fromJSON(e)) : [],
      skippedShipments: globalThis.Array.isArray(object?.skippedShipments)
        ? object.skippedShipments.map((e: any) => SkippedShipment.fromJSON(e))
        : [],
      constraintRelaxations: globalThis.Array.isArray(object?.constraintRelaxations)
        ? object.constraintRelaxations.map((e: any) => InjectedSolutionConstraint_ConstraintRelaxation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InjectedSolutionConstraint): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => ShipmentRoute.toJSON(e));
    }
    if (message.skippedShipments?.length) {
      obj.skippedShipments = message.skippedShipments.map((e) => SkippedShipment.toJSON(e));
    }
    if (message.constraintRelaxations?.length) {
      obj.constraintRelaxations = message.constraintRelaxations.map((e) =>
        InjectedSolutionConstraint_ConstraintRelaxation.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<InjectedSolutionConstraint>): InjectedSolutionConstraint {
    return InjectedSolutionConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InjectedSolutionConstraint>): InjectedSolutionConstraint {
    const message = createBaseInjectedSolutionConstraint();
    message.routes = object.routes?.map((e) => ShipmentRoute.fromPartial(e)) || [];
    message.skippedShipments = object.skippedShipments?.map((e) => SkippedShipment.fromPartial(e)) || [];
    message.constraintRelaxations =
      object.constraintRelaxations?.map((e) => InjectedSolutionConstraint_ConstraintRelaxation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInjectedSolutionConstraint_ConstraintRelaxation(): InjectedSolutionConstraint_ConstraintRelaxation {
  return { relaxations: [], vehicleIndices: [] };
}

export const InjectedSolutionConstraint_ConstraintRelaxation: MessageFns<
  InjectedSolutionConstraint_ConstraintRelaxation
> = {
  encode(
    message: InjectedSolutionConstraint_ConstraintRelaxation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.relaxations) {
      InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.vehicleIndices) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InjectedSolutionConstraint_ConstraintRelaxation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInjectedSolutionConstraint_ConstraintRelaxation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relaxations.push(
            InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag === 16) {
            message.vehicleIndices.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vehicleIndices.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InjectedSolutionConstraint_ConstraintRelaxation {
    return {
      relaxations: globalThis.Array.isArray(object?.relaxations)
        ? object.relaxations.map((e: any) => InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.fromJSON(e))
        : [],
      vehicleIndices: globalThis.Array.isArray(object?.vehicleIndices)
        ? object.vehicleIndices.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: InjectedSolutionConstraint_ConstraintRelaxation): unknown {
    const obj: any = {};
    if (message.relaxations?.length) {
      obj.relaxations = message.relaxations.map((e) =>
        InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.toJSON(e)
      );
    }
    if (message.vehicleIndices?.length) {
      obj.vehicleIndices = message.vehicleIndices.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<InjectedSolutionConstraint_ConstraintRelaxation>,
  ): InjectedSolutionConstraint_ConstraintRelaxation {
    return InjectedSolutionConstraint_ConstraintRelaxation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InjectedSolutionConstraint_ConstraintRelaxation>,
  ): InjectedSolutionConstraint_ConstraintRelaxation {
    const message = createBaseInjectedSolutionConstraint_ConstraintRelaxation();
    message.relaxations =
      object.relaxations?.map((e) => InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.fromPartial(e)) || [];
    message.vehicleIndices = object.vehicleIndices?.map((e) => e) || [];
    return message;
  },
};

function createBaseInjectedSolutionConstraint_ConstraintRelaxation_Relaxation(): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
  return { level: 0, thresholdTime: undefined, thresholdVisitCount: 0 };
}

export const InjectedSolutionConstraint_ConstraintRelaxation_Relaxation: MessageFns<
  InjectedSolutionConstraint_ConstraintRelaxation_Relaxation
> = {
  encode(
    message: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    if (message.thresholdTime !== undefined) {
      Timestamp.encode(toTimestamp(message.thresholdTime), writer.uint32(18).fork()).join();
    }
    if (message.thresholdVisitCount !== 0) {
      writer.uint32(24).int32(message.thresholdVisitCount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInjectedSolutionConstraint_ConstraintRelaxation_Relaxation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.thresholdTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.thresholdVisitCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
    return {
      level: isSet(object.level)
        ? injectedSolutionConstraint_ConstraintRelaxation_Relaxation_LevelFromJSON(object.level)
        : 0,
      thresholdTime: isSet(object.thresholdTime) ? fromJsonTimestamp(object.thresholdTime) : undefined,
      thresholdVisitCount: isSet(object.thresholdVisitCount) ? globalThis.Number(object.thresholdVisitCount) : 0,
    };
  },

  toJSON(message: InjectedSolutionConstraint_ConstraintRelaxation_Relaxation): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = injectedSolutionConstraint_ConstraintRelaxation_Relaxation_LevelToJSON(message.level);
    }
    if (message.thresholdTime !== undefined) {
      obj.thresholdTime = message.thresholdTime.toISOString();
    }
    if (message.thresholdVisitCount !== 0) {
      obj.thresholdVisitCount = Math.round(message.thresholdVisitCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<InjectedSolutionConstraint_ConstraintRelaxation_Relaxation>,
  ): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
    return InjectedSolutionConstraint_ConstraintRelaxation_Relaxation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InjectedSolutionConstraint_ConstraintRelaxation_Relaxation>,
  ): InjectedSolutionConstraint_ConstraintRelaxation_Relaxation {
    const message = createBaseInjectedSolutionConstraint_ConstraintRelaxation_Relaxation();
    message.level = object.level ?? 0;
    message.thresholdTime = object.thresholdTime ?? undefined;
    message.thresholdVisitCount = object.thresholdVisitCount ?? 0;
    return message;
  },
};

function createBaseOptimizeToursValidationError(): OptimizeToursValidationError {
  return { code: 0, displayName: "", fields: [], errorMessage: "", offendingValues: "" };
}

export const OptimizeToursValidationError: MessageFns<OptimizeToursValidationError> = {
  encode(message: OptimizeToursValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.fields) {
      OptimizeToursValidationError_FieldReference.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.offendingValues !== "") {
      writer.uint32(42).string(message.offendingValues);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fields.push(OptimizeToursValidationError_FieldReference.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.offendingValues = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursValidationError {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => OptimizeToursValidationError_FieldReference.fromJSON(e))
        : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      offendingValues: isSet(object.offendingValues) ? globalThis.String(object.offendingValues) : "",
    };
  },

  toJSON(message: OptimizeToursValidationError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => OptimizeToursValidationError_FieldReference.toJSON(e));
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.offendingValues !== "") {
      obj.offendingValues = message.offendingValues;
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursValidationError>): OptimizeToursValidationError {
    return OptimizeToursValidationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptimizeToursValidationError>): OptimizeToursValidationError {
    const message = createBaseOptimizeToursValidationError();
    message.code = object.code ?? 0;
    message.displayName = object.displayName ?? "";
    message.fields = object.fields?.map((e) => OptimizeToursValidationError_FieldReference.fromPartial(e)) || [];
    message.errorMessage = object.errorMessage ?? "";
    message.offendingValues = object.offendingValues ?? "";
    return message;
  },
};

function createBaseOptimizeToursValidationError_FieldReference(): OptimizeToursValidationError_FieldReference {
  return { name: "", index: undefined, key: undefined, subField: undefined };
}

export const OptimizeToursValidationError_FieldReference: MessageFns<OptimizeToursValidationError_FieldReference> = {
  encode(
    message: OptimizeToursValidationError_FieldReference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.index !== undefined) {
      writer.uint32(16).int32(message.index);
    }
    if (message.key !== undefined) {
      writer.uint32(34).string(message.key);
    }
    if (message.subField !== undefined) {
      OptimizeToursValidationError_FieldReference.encode(message.subField, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptimizeToursValidationError_FieldReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptimizeToursValidationError_FieldReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subField = OptimizeToursValidationError_FieldReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptimizeToursValidationError_FieldReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      subField: isSet(object.subField)
        ? OptimizeToursValidationError_FieldReference.fromJSON(object.subField)
        : undefined,
    };
  },

  toJSON(message: OptimizeToursValidationError_FieldReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.subField !== undefined) {
      obj.subField = OptimizeToursValidationError_FieldReference.toJSON(message.subField);
    }
    return obj;
  },

  create(base?: DeepPartial<OptimizeToursValidationError_FieldReference>): OptimizeToursValidationError_FieldReference {
    return OptimizeToursValidationError_FieldReference.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OptimizeToursValidationError_FieldReference>,
  ): OptimizeToursValidationError_FieldReference {
    const message = createBaseOptimizeToursValidationError_FieldReference();
    message.name = object.name ?? "";
    message.index = object.index ?? undefined;
    message.key = object.key ?? undefined;
    message.subField = (object.subField !== undefined && object.subField !== null)
      ? OptimizeToursValidationError_FieldReference.fromPartial(object.subField)
      : undefined;
    return message;
  },
};

/**
 * A service for optimizing vehicle tours.
 *
 * Validity of certain types of fields:
 *
 *   * `google.protobuf.Timestamp`
 *     * Times are in Unix time: seconds since 1970-01-01T00:00:00+00:00.
 *     * seconds must be in [0, 253402300799],
 *       i.e. in [1970-01-01T00:00:00+00:00, 9999-12-31T23:59:59+00:00].
 *     * nanos must be unset or set to 0.
 *   * `google.protobuf.Duration`
 *     * seconds must be in [0, 253402300799],
 *       i.e. in [1970-01-01T00:00:00+00:00, 9999-12-31T23:59:59+00:00].
 *     * nanos must be unset or set to 0.
 *   * `google.type.LatLng`
 *     * latitude must be in [-90.0, 90.0].
 *     * longitude must be in [-180.0, 180.0].
 *     * at least one of latitude and longitude must be non-zero.
 */
export type FleetRoutingDefinition = typeof FleetRoutingDefinition;
export const FleetRoutingDefinition = {
  name: "FleetRouting",
  fullName: "google.cloud.optimization.v1.FleetRouting",
  methods: {
    /**
     * Sends an `OptimizeToursRequest` containing a `ShipmentModel` and returns an
     * `OptimizeToursResponse` containing `ShipmentRoute`s, which are a set of
     * routes to be performed by vehicles minimizing the overall cost.
     *
     * A `ShipmentModel` model consists mainly of `Shipment`s that need to be
     * carried out and `Vehicle`s that can be used to transport the `Shipment`s.
     * The `ShipmentRoute`s assign `Shipment`s to `Vehicle`s. More specifically,
     * they assign a series of `Visit`s to each vehicle, where a `Visit`
     * corresponds to a `VisitRequest`, which is a pickup or delivery for a
     * `Shipment`.
     *
     * The goal is to provide an assignment of `ShipmentRoute`s to `Vehicle`s that
     * minimizes the total cost where cost has many components defined in the
     * `ShipmentModel`.
     */
    optimizeTours: {
      name: "OptimizeTours",
      requestType: OptimizeToursRequest,
      requestStream: false,
      responseType: OptimizeToursResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              98,
              58,
              1,
              42,
              90,
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              111,
              112,
              116,
              105,
              109,
              105,
              122,
              101,
              84,
              111,
              117,
              114,
              115,
              34,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              111,
              112,
              116,
              105,
              109,
              105,
              122,
              101,
              84,
              111,
              117,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Optimizes vehicle tours for one or more `OptimizeToursRequest`
     * messages as a batch.
     *
     * This method is a Long Running Operation (LRO). The inputs for optimization
     * (`OptimizeToursRequest` messages) and outputs (`OptimizeToursResponse`
     * messages) are read/written from/to Cloud Storage in user-specified
     * format. Like the `OptimizeTours` method, each `OptimizeToursRequest`
     * contains a `ShipmentModel` and returns an `OptimizeToursResponse`
     * containing `ShipmentRoute`s, which are a set of routes to be performed by
     * vehicles minimizing the overall cost.
     */
    batchOptimizeTours: {
      name: "BatchOptimizeTours",
      requestType: BatchOptimizeToursRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              26,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              116,
              105,
              109,
              105,
              122,
              101,
              84,
              111,
              117,
              114,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              18,
              65,
              115,
              121,
              110,
              99,
              77,
              111,
              100,
              101,
              108,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              108,
              58,
              1,
              42,
              90,
              47,
              58,
              1,
              42,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              79,
              112,
              116,
              105,
              109,
              105,
              122,
              101,
              84,
              111,
              117,
              114,
              115,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              79,
              112,
              116,
              105,
              109,
              105,
              122,
              101,
              84,
              111,
              117,
              114,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FleetRoutingServiceImplementation<CallContextExt = {}> {
  /**
   * Sends an `OptimizeToursRequest` containing a `ShipmentModel` and returns an
   * `OptimizeToursResponse` containing `ShipmentRoute`s, which are a set of
   * routes to be performed by vehicles minimizing the overall cost.
   *
   * A `ShipmentModel` model consists mainly of `Shipment`s that need to be
   * carried out and `Vehicle`s that can be used to transport the `Shipment`s.
   * The `ShipmentRoute`s assign `Shipment`s to `Vehicle`s. More specifically,
   * they assign a series of `Visit`s to each vehicle, where a `Visit`
   * corresponds to a `VisitRequest`, which is a pickup or delivery for a
   * `Shipment`.
   *
   * The goal is to provide an assignment of `ShipmentRoute`s to `Vehicle`s that
   * minimizes the total cost where cost has many components defined in the
   * `ShipmentModel`.
   */
  optimizeTours(
    request: OptimizeToursRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<OptimizeToursResponse>>;
  /**
   * Optimizes vehicle tours for one or more `OptimizeToursRequest`
   * messages as a batch.
   *
   * This method is a Long Running Operation (LRO). The inputs for optimization
   * (`OptimizeToursRequest` messages) and outputs (`OptimizeToursResponse`
   * messages) are read/written from/to Cloud Storage in user-specified
   * format. Like the `OptimizeTours` method, each `OptimizeToursRequest`
   * contains a `ShipmentModel` and returns an `OptimizeToursResponse`
   * containing `ShipmentRoute`s, which are a set of routes to be performed by
   * vehicles minimizing the overall cost.
   */
  batchOptimizeTours(
    request: BatchOptimizeToursRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface FleetRoutingClient<CallOptionsExt = {}> {
  /**
   * Sends an `OptimizeToursRequest` containing a `ShipmentModel` and returns an
   * `OptimizeToursResponse` containing `ShipmentRoute`s, which are a set of
   * routes to be performed by vehicles minimizing the overall cost.
   *
   * A `ShipmentModel` model consists mainly of `Shipment`s that need to be
   * carried out and `Vehicle`s that can be used to transport the `Shipment`s.
   * The `ShipmentRoute`s assign `Shipment`s to `Vehicle`s. More specifically,
   * they assign a series of `Visit`s to each vehicle, where a `Visit`
   * corresponds to a `VisitRequest`, which is a pickup or delivery for a
   * `Shipment`.
   *
   * The goal is to provide an assignment of `ShipmentRoute`s to `Vehicle`s that
   * minimizes the total cost where cost has many components defined in the
   * `ShipmentModel`.
   */
  optimizeTours(
    request: DeepPartial<OptimizeToursRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OptimizeToursResponse>;
  /**
   * Optimizes vehicle tours for one or more `OptimizeToursRequest`
   * messages as a batch.
   *
   * This method is a Long Running Operation (LRO). The inputs for optimization
   * (`OptimizeToursRequest` messages) and outputs (`OptimizeToursResponse`
   * messages) are read/written from/to Cloud Storage in user-specified
   * format. Like the `OptimizeTours` method, each `OptimizeToursRequest`
   * contains a `ShipmentModel` and returns an `OptimizeToursResponse`
   * containing `ShipmentRoute`s, which are a set of routes to be performed by
   * vehicles minimizing the overall cost.
   */
  batchOptimizeTours(
    request: DeepPartial<BatchOptimizeToursRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
