// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recaptchaenterprise/v1/recaptchaenterprise.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.recaptchaenterprise.v1";

/** The create assessment request message. */
export interface CreateAssessmentRequest {
  /**
   * Required. The name of the project in which the assessment is created,
   * in the format `projects/{project}`.
   */
  parent: string;
  /** Required. The assessment details. */
  assessment: Assessment | undefined;
}

/** Describes an event in the lifecycle of a payment transaction. */
export interface TransactionEvent {
  /** Optional. The type of this transaction event. */
  eventType: TransactionEvent_TransactionEventType;
  /**
   * Optional. The reason or standardized code that corresponds with this
   * transaction event, if one exists. For example, a CHARGEBACK event with code
   * 6005.
   */
  reason: string;
  /**
   * Optional. The value that corresponds with this transaction event, if one
   * exists. For example, a refund event where $5.00 was refunded. Currency is
   * obtained from the original transaction data.
   */
  value: number;
  /**
   * Optional. Timestamp when this transaction event occurred; otherwise assumed
   * to be the time of the API call.
   */
  eventTime: Date | undefined;
}

/** Enum that represents an event in the payment transaction lifecycle. */
export enum TransactionEvent_TransactionEventType {
  /** TRANSACTION_EVENT_TYPE_UNSPECIFIED - Default, unspecified event type. */
  TRANSACTION_EVENT_TYPE_UNSPECIFIED = 0,
  /**
   * MERCHANT_APPROVE - Indicates that the transaction is approved by the merchant. The
   * accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
   * 'CYBERSOURCE', or 'MANUAL_REVIEW'.
   */
  MERCHANT_APPROVE = 1,
  /**
   * MERCHANT_DENY - Indicates that the transaction is denied and concluded due to risks
   * detected by the merchant. The accompanying reasons can include terms such
   * as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
   */
  MERCHANT_DENY = 2,
  /**
   * MANUAL_REVIEW - Indicates that the transaction is being evaluated by a human, due to
   * suspicion or risk.
   */
  MANUAL_REVIEW = 3,
  /** AUTHORIZATION - Indicates that the authorization attempt with the card issuer succeeded. */
  AUTHORIZATION = 4,
  /**
   * AUTHORIZATION_DECLINE - Indicates that the authorization attempt with the card issuer failed.
   * The accompanying reasons can include Visa's '54' indicating that the card
   * is expired, or '82' indicating that the CVV is incorrect.
   */
  AUTHORIZATION_DECLINE = 5,
  /**
   * PAYMENT_CAPTURE - Indicates that the transaction is completed because the funds were
   * settled.
   */
  PAYMENT_CAPTURE = 6,
  /**
   * PAYMENT_CAPTURE_DECLINE - Indicates that the transaction could not be completed because the funds
   * were not settled.
   */
  PAYMENT_CAPTURE_DECLINE = 7,
  /**
   * CANCEL - Indicates that the transaction has been canceled. Specify the reason
   * for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
   */
  CANCEL = 8,
  /**
   * CHARGEBACK_INQUIRY - Indicates that the merchant has received a chargeback inquiry due to
   * fraud for the transaction, requesting additional information before a
   * fraud chargeback is officially issued and a formal chargeback
   * notification is sent.
   */
  CHARGEBACK_INQUIRY = 9,
  /**
   * CHARGEBACK_ALERT - Indicates that the merchant has received a chargeback alert due to fraud
   * for the transaction. The process of resolving the dispute without
   * involving the payment network is started.
   */
  CHARGEBACK_ALERT = 10,
  /**
   * FRAUD_NOTIFICATION - Indicates that a fraud notification is issued for the transaction, sent
   * by the payment instrument's issuing bank because the transaction appears
   * to be fraudulent. We recommend including TC40 or SAFE data in the
   * `reason` field for this event type. For partial chargebacks, we recommend
   * that you include an amount in the `value` field.
   */
  FRAUD_NOTIFICATION = 11,
  /**
   * CHARGEBACK - Indicates that the merchant is informed by the payment network that the
   * transaction has entered the chargeback process due to fraud. Reason code
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   */
  CHARGEBACK = 12,
  /**
   * CHARGEBACK_REPRESENTMENT - Indicates that the transaction has entered the chargeback process due to
   * fraud, and that the merchant has chosen to enter representment. Reason
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   */
  CHARGEBACK_REPRESENTMENT = 13,
  /**
   * CHARGEBACK_REVERSE - Indicates that the transaction has had a fraud chargeback which was
   * illegitimate and was reversed as a result. For partial chargebacks, we
   * recommend that you include an amount in the `value` field.
   */
  CHARGEBACK_REVERSE = 14,
  /**
   * REFUND_REQUEST - Indicates that the merchant has received a refund for a completed
   * transaction. For partial refunds, we recommend that you include an amount
   * in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
   * exempt tax)
   */
  REFUND_REQUEST = 15,
  /**
   * REFUND_DECLINE - Indicates that the merchant has received a refund request for this
   * transaction, but that they have declined it. For partial refunds, we
   * recommend that you include an amount in the `value` field. Reason
   * example: 'TAX_EXEMPT' (partial refund of exempt tax)
   */
  REFUND_DECLINE = 16,
  /**
   * REFUND - Indicates that the completed transaction was refunded by the merchant.
   * For partial refunds, we recommend that you include an amount in the
   * `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
   * tax)
   */
  REFUND = 17,
  /**
   * REFUND_REVERSE - Indicates that the completed transaction was refunded by the merchant,
   * and that this refund was reversed. For partial refunds, we recommend that
   * you include an amount in the `value` field.
   */
  REFUND_REVERSE = 18,
  UNRECOGNIZED = -1,
}

export function transactionEvent_TransactionEventTypeFromJSON(object: any): TransactionEvent_TransactionEventType {
  switch (object) {
    case 0:
    case "TRANSACTION_EVENT_TYPE_UNSPECIFIED":
      return TransactionEvent_TransactionEventType.TRANSACTION_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "MERCHANT_APPROVE":
      return TransactionEvent_TransactionEventType.MERCHANT_APPROVE;
    case 2:
    case "MERCHANT_DENY":
      return TransactionEvent_TransactionEventType.MERCHANT_DENY;
    case 3:
    case "MANUAL_REVIEW":
      return TransactionEvent_TransactionEventType.MANUAL_REVIEW;
    case 4:
    case "AUTHORIZATION":
      return TransactionEvent_TransactionEventType.AUTHORIZATION;
    case 5:
    case "AUTHORIZATION_DECLINE":
      return TransactionEvent_TransactionEventType.AUTHORIZATION_DECLINE;
    case 6:
    case "PAYMENT_CAPTURE":
      return TransactionEvent_TransactionEventType.PAYMENT_CAPTURE;
    case 7:
    case "PAYMENT_CAPTURE_DECLINE":
      return TransactionEvent_TransactionEventType.PAYMENT_CAPTURE_DECLINE;
    case 8:
    case "CANCEL":
      return TransactionEvent_TransactionEventType.CANCEL;
    case 9:
    case "CHARGEBACK_INQUIRY":
      return TransactionEvent_TransactionEventType.CHARGEBACK_INQUIRY;
    case 10:
    case "CHARGEBACK_ALERT":
      return TransactionEvent_TransactionEventType.CHARGEBACK_ALERT;
    case 11:
    case "FRAUD_NOTIFICATION":
      return TransactionEvent_TransactionEventType.FRAUD_NOTIFICATION;
    case 12:
    case "CHARGEBACK":
      return TransactionEvent_TransactionEventType.CHARGEBACK;
    case 13:
    case "CHARGEBACK_REPRESENTMENT":
      return TransactionEvent_TransactionEventType.CHARGEBACK_REPRESENTMENT;
    case 14:
    case "CHARGEBACK_REVERSE":
      return TransactionEvent_TransactionEventType.CHARGEBACK_REVERSE;
    case 15:
    case "REFUND_REQUEST":
      return TransactionEvent_TransactionEventType.REFUND_REQUEST;
    case 16:
    case "REFUND_DECLINE":
      return TransactionEvent_TransactionEventType.REFUND_DECLINE;
    case 17:
    case "REFUND":
      return TransactionEvent_TransactionEventType.REFUND;
    case 18:
    case "REFUND_REVERSE":
      return TransactionEvent_TransactionEventType.REFUND_REVERSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionEvent_TransactionEventType.UNRECOGNIZED;
  }
}

export function transactionEvent_TransactionEventTypeToJSON(object: TransactionEvent_TransactionEventType): string {
  switch (object) {
    case TransactionEvent_TransactionEventType.TRANSACTION_EVENT_TYPE_UNSPECIFIED:
      return "TRANSACTION_EVENT_TYPE_UNSPECIFIED";
    case TransactionEvent_TransactionEventType.MERCHANT_APPROVE:
      return "MERCHANT_APPROVE";
    case TransactionEvent_TransactionEventType.MERCHANT_DENY:
      return "MERCHANT_DENY";
    case TransactionEvent_TransactionEventType.MANUAL_REVIEW:
      return "MANUAL_REVIEW";
    case TransactionEvent_TransactionEventType.AUTHORIZATION:
      return "AUTHORIZATION";
    case TransactionEvent_TransactionEventType.AUTHORIZATION_DECLINE:
      return "AUTHORIZATION_DECLINE";
    case TransactionEvent_TransactionEventType.PAYMENT_CAPTURE:
      return "PAYMENT_CAPTURE";
    case TransactionEvent_TransactionEventType.PAYMENT_CAPTURE_DECLINE:
      return "PAYMENT_CAPTURE_DECLINE";
    case TransactionEvent_TransactionEventType.CANCEL:
      return "CANCEL";
    case TransactionEvent_TransactionEventType.CHARGEBACK_INQUIRY:
      return "CHARGEBACK_INQUIRY";
    case TransactionEvent_TransactionEventType.CHARGEBACK_ALERT:
      return "CHARGEBACK_ALERT";
    case TransactionEvent_TransactionEventType.FRAUD_NOTIFICATION:
      return "FRAUD_NOTIFICATION";
    case TransactionEvent_TransactionEventType.CHARGEBACK:
      return "CHARGEBACK";
    case TransactionEvent_TransactionEventType.CHARGEBACK_REPRESENTMENT:
      return "CHARGEBACK_REPRESENTMENT";
    case TransactionEvent_TransactionEventType.CHARGEBACK_REVERSE:
      return "CHARGEBACK_REVERSE";
    case TransactionEvent_TransactionEventType.REFUND_REQUEST:
      return "REFUND_REQUEST";
    case TransactionEvent_TransactionEventType.REFUND_DECLINE:
      return "REFUND_DECLINE";
    case TransactionEvent_TransactionEventType.REFUND:
      return "REFUND";
    case TransactionEvent_TransactionEventType.REFUND_REVERSE:
      return "REFUND_REVERSE";
    case TransactionEvent_TransactionEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The request message to annotate an Assessment. */
export interface AnnotateAssessmentRequest {
  /**
   * Required. The resource name of the Assessment, in the format
   * `projects/{project}/assessments/{assessment}`.
   */
  name: string;
  /**
   * Optional. The annotation that is assigned to the Event. This field can
   * be left empty to provide reasons that apply to an event without concluding
   * whether the event is legitimate or fraudulent.
   */
  annotation: AnnotateAssessmentRequest_Annotation;
  /** Optional. Reasons for the annotation that are assigned to the event. */
  reasons: AnnotateAssessmentRequest_Reason[];
  /**
   * Optional. A stable account identifier to apply to the assessment. This is
   * an alternative to setting `account_id` in `CreateAssessment`, for example
   * when a stable account identifier is not yet known in the initial request.
   */
  accountId: string;
  /**
   * Optional. A stable hashed account identifier to apply to the assessment.
   * This is an alternative to setting `hashed_account_id` in
   * `CreateAssessment`, for example when a stable account identifier is not yet
   * known in the initial request.
   */
  hashedAccountId: Buffer;
  /**
   * Optional. If the assessment is part of a payment transaction, provide
   * details on payment lifecycle events that occur in the transaction.
   */
  transactionEvent: TransactionEvent | undefined;
}

/** Enum that represents the types of annotations. */
export enum AnnotateAssessmentRequest_Annotation {
  /** ANNOTATION_UNSPECIFIED - Default unspecified type. */
  ANNOTATION_UNSPECIFIED = 0,
  /** LEGITIMATE - Provides information that the event turned out to be legitimate. */
  LEGITIMATE = 1,
  /** FRAUDULENT - Provides information that the event turned out to be fraudulent. */
  FRAUDULENT = 2,
  /**
   * PASSWORD_CORRECT - Provides information that the event was related to a login event in which
   * the user typed the correct password. Deprecated, prefer indicating
   * CORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   */
  PASSWORD_CORRECT = 3,
  /**
   * PASSWORD_INCORRECT - Provides information that the event was related to a login event in which
   * the user typed the incorrect password. Deprecated, prefer indicating
   * INCORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   */
  PASSWORD_INCORRECT = 4,
  UNRECOGNIZED = -1,
}

export function annotateAssessmentRequest_AnnotationFromJSON(object: any): AnnotateAssessmentRequest_Annotation {
  switch (object) {
    case 0:
    case "ANNOTATION_UNSPECIFIED":
      return AnnotateAssessmentRequest_Annotation.ANNOTATION_UNSPECIFIED;
    case 1:
    case "LEGITIMATE":
      return AnnotateAssessmentRequest_Annotation.LEGITIMATE;
    case 2:
    case "FRAUDULENT":
      return AnnotateAssessmentRequest_Annotation.FRAUDULENT;
    case 3:
    case "PASSWORD_CORRECT":
      return AnnotateAssessmentRequest_Annotation.PASSWORD_CORRECT;
    case 4:
    case "PASSWORD_INCORRECT":
      return AnnotateAssessmentRequest_Annotation.PASSWORD_INCORRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotateAssessmentRequest_Annotation.UNRECOGNIZED;
  }
}

export function annotateAssessmentRequest_AnnotationToJSON(object: AnnotateAssessmentRequest_Annotation): string {
  switch (object) {
    case AnnotateAssessmentRequest_Annotation.ANNOTATION_UNSPECIFIED:
      return "ANNOTATION_UNSPECIFIED";
    case AnnotateAssessmentRequest_Annotation.LEGITIMATE:
      return "LEGITIMATE";
    case AnnotateAssessmentRequest_Annotation.FRAUDULENT:
      return "FRAUDULENT";
    case AnnotateAssessmentRequest_Annotation.PASSWORD_CORRECT:
      return "PASSWORD_CORRECT";
    case AnnotateAssessmentRequest_Annotation.PASSWORD_INCORRECT:
      return "PASSWORD_INCORRECT";
    case AnnotateAssessmentRequest_Annotation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum that represents potential reasons for annotating an assessment. */
export enum AnnotateAssessmentRequest_Reason {
  /** REASON_UNSPECIFIED - Default unspecified reason. */
  REASON_UNSPECIFIED = 0,
  /**
   * CHARGEBACK - Indicates that the transaction had a chargeback issued with no other
   * details. When possible, specify the type by using CHARGEBACK_FRAUD or
   * CHARGEBACK_DISPUTE instead.
   */
  CHARGEBACK = 1,
  /**
   * CHARGEBACK_FRAUD - Indicates that the transaction had a chargeback issued related to an
   * alleged unauthorized transaction from the cardholder's perspective (for
   * example, the card number was stolen).
   */
  CHARGEBACK_FRAUD = 8,
  /**
   * CHARGEBACK_DISPUTE - Indicates that the transaction had a chargeback issued related to the
   * cardholder having provided their card details but allegedly not being
   * satisfied with the purchase (for example, misrepresentation, attempted
   * cancellation).
   */
  CHARGEBACK_DISPUTE = 9,
  /**
   * REFUND - Indicates that the completed payment transaction was refunded by the
   * seller.
   */
  REFUND = 10,
  /**
   * REFUND_FRAUD - Indicates that the completed payment transaction was determined to be
   * fraudulent by the seller, and was cancelled and refunded as a result.
   */
  REFUND_FRAUD = 11,
  /**
   * TRANSACTION_ACCEPTED - Indicates that the payment transaction was accepted, and the user was
   * charged.
   */
  TRANSACTION_ACCEPTED = 12,
  /**
   * TRANSACTION_DECLINED - Indicates that the payment transaction was declined, for example due to
   * invalid card details.
   */
  TRANSACTION_DECLINED = 13,
  /**
   * PAYMENT_HEURISTICS - Indicates the transaction associated with the assessment is suspected of
   * being fraudulent based on the payment method, billing details, shipping
   * address or other transaction information.
   */
  PAYMENT_HEURISTICS = 2,
  /**
   * INITIATED_TWO_FACTOR - Indicates that the user was served a 2FA challenge. An old assessment
   * with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
   * overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
   * This is equivalent to `FAILED_TWO_FACTOR`.
   */
  INITIATED_TWO_FACTOR = 7,
  /** PASSED_TWO_FACTOR - Indicates that the user passed a 2FA challenge. */
  PASSED_TWO_FACTOR = 3,
  /** FAILED_TWO_FACTOR - Indicates that the user failed a 2FA challenge. */
  FAILED_TWO_FACTOR = 4,
  /** CORRECT_PASSWORD - Indicates the user provided the correct password. */
  CORRECT_PASSWORD = 5,
  /** INCORRECT_PASSWORD - Indicates the user provided an incorrect password. */
  INCORRECT_PASSWORD = 6,
  /**
   * SOCIAL_SPAM - Indicates that the user sent unwanted and abusive messages to other users
   * of the platform, such as spam, scams, phishing, or social engineering.
   */
  SOCIAL_SPAM = 14,
  UNRECOGNIZED = -1,
}

export function annotateAssessmentRequest_ReasonFromJSON(object: any): AnnotateAssessmentRequest_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return AnnotateAssessmentRequest_Reason.REASON_UNSPECIFIED;
    case 1:
    case "CHARGEBACK":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK;
    case 8:
    case "CHARGEBACK_FRAUD":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK_FRAUD;
    case 9:
    case "CHARGEBACK_DISPUTE":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK_DISPUTE;
    case 10:
    case "REFUND":
      return AnnotateAssessmentRequest_Reason.REFUND;
    case 11:
    case "REFUND_FRAUD":
      return AnnotateAssessmentRequest_Reason.REFUND_FRAUD;
    case 12:
    case "TRANSACTION_ACCEPTED":
      return AnnotateAssessmentRequest_Reason.TRANSACTION_ACCEPTED;
    case 13:
    case "TRANSACTION_DECLINED":
      return AnnotateAssessmentRequest_Reason.TRANSACTION_DECLINED;
    case 2:
    case "PAYMENT_HEURISTICS":
      return AnnotateAssessmentRequest_Reason.PAYMENT_HEURISTICS;
    case 7:
    case "INITIATED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.INITIATED_TWO_FACTOR;
    case 3:
    case "PASSED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.PASSED_TWO_FACTOR;
    case 4:
    case "FAILED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.FAILED_TWO_FACTOR;
    case 5:
    case "CORRECT_PASSWORD":
      return AnnotateAssessmentRequest_Reason.CORRECT_PASSWORD;
    case 6:
    case "INCORRECT_PASSWORD":
      return AnnotateAssessmentRequest_Reason.INCORRECT_PASSWORD;
    case 14:
    case "SOCIAL_SPAM":
      return AnnotateAssessmentRequest_Reason.SOCIAL_SPAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotateAssessmentRequest_Reason.UNRECOGNIZED;
  }
}

export function annotateAssessmentRequest_ReasonToJSON(object: AnnotateAssessmentRequest_Reason): string {
  switch (object) {
    case AnnotateAssessmentRequest_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK:
      return "CHARGEBACK";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK_FRAUD:
      return "CHARGEBACK_FRAUD";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK_DISPUTE:
      return "CHARGEBACK_DISPUTE";
    case AnnotateAssessmentRequest_Reason.REFUND:
      return "REFUND";
    case AnnotateAssessmentRequest_Reason.REFUND_FRAUD:
      return "REFUND_FRAUD";
    case AnnotateAssessmentRequest_Reason.TRANSACTION_ACCEPTED:
      return "TRANSACTION_ACCEPTED";
    case AnnotateAssessmentRequest_Reason.TRANSACTION_DECLINED:
      return "TRANSACTION_DECLINED";
    case AnnotateAssessmentRequest_Reason.PAYMENT_HEURISTICS:
      return "PAYMENT_HEURISTICS";
    case AnnotateAssessmentRequest_Reason.INITIATED_TWO_FACTOR:
      return "INITIATED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.PASSED_TWO_FACTOR:
      return "PASSED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.FAILED_TWO_FACTOR:
      return "FAILED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.CORRECT_PASSWORD:
      return "CORRECT_PASSWORD";
    case AnnotateAssessmentRequest_Reason.INCORRECT_PASSWORD:
      return "INCORRECT_PASSWORD";
    case AnnotateAssessmentRequest_Reason.SOCIAL_SPAM:
      return "SOCIAL_SPAM";
    case AnnotateAssessmentRequest_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Empty response for AnnotateAssessment. */
export interface AnnotateAssessmentResponse {
}

/** Information about a verification endpoint that can be used for 2FA. */
export interface EndpointVerificationInfo {
  /** Email address for which to trigger a verification request. */
  emailAddress?:
    | string
    | undefined;
  /**
   * Phone number for which to trigger a verification request. Should be given
   * in E.164 format.
   */
  phoneNumber?:
    | string
    | undefined;
  /**
   * Output only. Token to provide to the client to trigger endpoint
   * verification. It must be used within 15 minutes.
   */
  requestToken: string;
  /**
   * Output only. Timestamp of the last successful verification for the
   * endpoint, if any.
   */
  lastVerificationTime: Date | undefined;
}

/** Information about account verification, used for identity verification. */
export interface AccountVerificationInfo {
  /** Optional. Endpoints that can be used for identity verification. */
  endpoints: EndpointVerificationInfo[];
  /**
   * Optional. Language code preference for the verification message, set as a
   * IETF BCP 47 language code.
   */
  languageCode: string;
  /** Output only. Result of the latest account verification challenge. */
  latestVerificationResult: AccountVerificationInfo_Result;
  /**
   * Username of the account that is being verified. Deprecated. Customers
   * should now provide the `account_id` field in `event.user_info`.
   *
   * @deprecated
   */
  username: string;
}

/**
 * Result of the account verification as contained in the verdict token issued
 * at the end of the verification flow.
 */
export enum AccountVerificationInfo_Result {
  /** RESULT_UNSPECIFIED - No information about the latest account verification. */
  RESULT_UNSPECIFIED = 0,
  /**
   * SUCCESS_USER_VERIFIED - The user was successfully verified. This means the account verification
   * challenge was successfully completed.
   */
  SUCCESS_USER_VERIFIED = 1,
  /** ERROR_USER_NOT_VERIFIED - The user failed the verification challenge. */
  ERROR_USER_NOT_VERIFIED = 2,
  /**
   * ERROR_SITE_ONBOARDING_INCOMPLETE - The site is not properly onboarded to use the account verification
   * feature.
   */
  ERROR_SITE_ONBOARDING_INCOMPLETE = 3,
  /**
   * ERROR_RECIPIENT_NOT_ALLOWED - The recipient is not allowed for account verification. This can occur
   * during integration but should not occur in production.
   */
  ERROR_RECIPIENT_NOT_ALLOWED = 4,
  /**
   * ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED - The recipient has already been sent too many verification codes in a
   * short amount of time.
   */
  ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED = 5,
  /**
   * ERROR_CRITICAL_INTERNAL - The verification flow could not be completed due to a critical internal
   * error.
   */
  ERROR_CRITICAL_INTERNAL = 6,
  /**
   * ERROR_CUSTOMER_QUOTA_EXHAUSTED - The client has exceeded their two factor request quota for this period of
   * time.
   */
  ERROR_CUSTOMER_QUOTA_EXHAUSTED = 7,
  /**
   * ERROR_VERIFICATION_BYPASSED - The request cannot be processed at the time because of an incident. This
   * bypass can be restricted to a problematic destination email domain, a
   * customer, or could affect the entire service.
   */
  ERROR_VERIFICATION_BYPASSED = 8,
  /**
   * ERROR_VERDICT_MISMATCH - The request parameters do not match with the token provided and cannot be
   * processed.
   */
  ERROR_VERDICT_MISMATCH = 9,
  UNRECOGNIZED = -1,
}

export function accountVerificationInfo_ResultFromJSON(object: any): AccountVerificationInfo_Result {
  switch (object) {
    case 0:
    case "RESULT_UNSPECIFIED":
      return AccountVerificationInfo_Result.RESULT_UNSPECIFIED;
    case 1:
    case "SUCCESS_USER_VERIFIED":
      return AccountVerificationInfo_Result.SUCCESS_USER_VERIFIED;
    case 2:
    case "ERROR_USER_NOT_VERIFIED":
      return AccountVerificationInfo_Result.ERROR_USER_NOT_VERIFIED;
    case 3:
    case "ERROR_SITE_ONBOARDING_INCOMPLETE":
      return AccountVerificationInfo_Result.ERROR_SITE_ONBOARDING_INCOMPLETE;
    case 4:
    case "ERROR_RECIPIENT_NOT_ALLOWED":
      return AccountVerificationInfo_Result.ERROR_RECIPIENT_NOT_ALLOWED;
    case 5:
    case "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED":
      return AccountVerificationInfo_Result.ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED;
    case 6:
    case "ERROR_CRITICAL_INTERNAL":
      return AccountVerificationInfo_Result.ERROR_CRITICAL_INTERNAL;
    case 7:
    case "ERROR_CUSTOMER_QUOTA_EXHAUSTED":
      return AccountVerificationInfo_Result.ERROR_CUSTOMER_QUOTA_EXHAUSTED;
    case 8:
    case "ERROR_VERIFICATION_BYPASSED":
      return AccountVerificationInfo_Result.ERROR_VERIFICATION_BYPASSED;
    case 9:
    case "ERROR_VERDICT_MISMATCH":
      return AccountVerificationInfo_Result.ERROR_VERDICT_MISMATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountVerificationInfo_Result.UNRECOGNIZED;
  }
}

export function accountVerificationInfo_ResultToJSON(object: AccountVerificationInfo_Result): string {
  switch (object) {
    case AccountVerificationInfo_Result.RESULT_UNSPECIFIED:
      return "RESULT_UNSPECIFIED";
    case AccountVerificationInfo_Result.SUCCESS_USER_VERIFIED:
      return "SUCCESS_USER_VERIFIED";
    case AccountVerificationInfo_Result.ERROR_USER_NOT_VERIFIED:
      return "ERROR_USER_NOT_VERIFIED";
    case AccountVerificationInfo_Result.ERROR_SITE_ONBOARDING_INCOMPLETE:
      return "ERROR_SITE_ONBOARDING_INCOMPLETE";
    case AccountVerificationInfo_Result.ERROR_RECIPIENT_NOT_ALLOWED:
      return "ERROR_RECIPIENT_NOT_ALLOWED";
    case AccountVerificationInfo_Result.ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED:
      return "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED";
    case AccountVerificationInfo_Result.ERROR_CRITICAL_INTERNAL:
      return "ERROR_CRITICAL_INTERNAL";
    case AccountVerificationInfo_Result.ERROR_CUSTOMER_QUOTA_EXHAUSTED:
      return "ERROR_CUSTOMER_QUOTA_EXHAUSTED";
    case AccountVerificationInfo_Result.ERROR_VERIFICATION_BYPASSED:
      return "ERROR_VERIFICATION_BYPASSED";
    case AccountVerificationInfo_Result.ERROR_VERDICT_MISMATCH:
      return "ERROR_VERDICT_MISMATCH";
    case AccountVerificationInfo_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Private password leak verification info. */
export interface PrivatePasswordLeakVerification {
  /**
   * Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
   * username. It is used to look up password leaks associated with that hash
   * prefix.
   */
  lookupHashPrefix: Buffer;
  /**
   * Optional. Encrypted Scrypt hash of the canonicalized username+password. It
   * is re-encrypted by the server and returned through
   * `reencrypted_user_credentials_hash`.
   */
  encryptedUserCredentialsHash: Buffer;
  /**
   * Output only. List of prefixes of the encrypted potential password leaks
   * that matched the given parameters. They must be compared with the
   * client-side decryption prefix of `reencrypted_user_credentials_hash`
   */
  encryptedLeakMatchPrefixes: Buffer[];
  /**
   * Output only. Corresponds to the re-encryption of the
   * `encrypted_user_credentials_hash` field. It is used to match potential
   * password leaks within `encrypted_leak_match_prefixes`.
   */
  reencryptedUserCredentialsHash: Buffer;
}

/** A reCAPTCHA Enterprise assessment resource. */
export interface Assessment {
  /**
   * Output only. Identifier. The resource name for the Assessment in the format
   * `projects/{project}/assessments/{assessment}`.
   */
  name: string;
  /** Optional. The event being assessed. */
  event:
    | Event
    | undefined;
  /** Output only. The risk analysis result for the event being assessed. */
  riskAnalysis:
    | RiskAnalysis
    | undefined;
  /** Output only. Properties of the provided event token. */
  tokenProperties:
    | TokenProperties
    | undefined;
  /**
   * Optional. Account verification information for identity verification. The
   * assessment event must include a token and site key to use this feature.
   */
  accountVerification:
    | AccountVerificationInfo
    | undefined;
  /**
   * Output only. Assessment returned by account defender when an account
   * identifier is provided.
   */
  accountDefenderAssessment:
    | AccountDefenderAssessment
    | undefined;
  /**
   * Optional. The private password leak verification field contains the
   * parameters that are used to to check for leaks privately without sharing
   * user credentials.
   */
  privatePasswordLeakVerification:
    | PrivatePasswordLeakVerification
    | undefined;
  /**
   * Output only. Assessment returned when firewall policies belonging to the
   * project are evaluated using the field firewall_policy_evaluation.
   */
  firewallPolicyAssessment:
    | FirewallPolicyAssessment
    | undefined;
  /**
   * Output only. Assessment returned by Fraud Prevention when TransactionData
   * is provided.
   */
  fraudPreventionAssessment:
    | FraudPreventionAssessment
    | undefined;
  /**
   * Output only. Fraud Signals specific to the users involved in a payment
   * transaction.
   */
  fraudSignals:
    | FraudSignals
    | undefined;
  /**
   * Output only. Assessment returned when a site key, a token, and a phone
   * number as `user_id` are provided. Account defender and SMS toll fraud
   * protection need to be enabled.
   */
  phoneFraudAssessment:
    | PhoneFraudAssessment
    | undefined;
  /**
   * Optional. The environment creating the assessment. This describes your
   * environment (the system invoking CreateAssessment), NOT the environment of
   * your user.
   */
  assessmentEnvironment: AssessmentEnvironment | undefined;
}

/** The event being assessed. */
export interface Event {
  /**
   * Optional. The user response token provided by the reCAPTCHA Enterprise
   * client-side integration on your site.
   */
  token: string;
  /**
   * Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
   * site and generate the token.
   */
  siteKey: string;
  /**
   * Optional. The user agent present in the request from the user's device
   * related to this event.
   */
  userAgent: string;
  /**
   * Optional. The IP address in the request from the user's device related to
   * this event.
   */
  userIpAddress: string;
  /**
   * Optional. The expected action for this type of event. This should be the
   * same action provided at token generation time on client-side platforms
   * already integrated with recaptcha enterprise.
   */
  expectedAction: string;
  /**
   * Optional. Deprecated: use `user_info.account_id` instead.
   * Unique stable hashed user identifier for the request. The identifier must
   * be hashed using hmac-sha256 with stable secret.
   *
   * @deprecated
   */
  hashedAccountId: Buffer;
  /**
   * Optional. Flag for a reCAPTCHA express request for an assessment without a
   * token. If enabled, `site_key` must reference an express key.
   */
  express: boolean;
  /** Optional. The URI resource the user requested that triggered an assessment. */
  requestedUri: string;
  /**
   * Optional. Flag for running WAF token assessment.
   * If enabled, the token must be specified, and have been created by a
   * WAF-enabled key.
   */
  wafTokenAssessment: boolean;
  /** Optional. JA3 fingerprint for SSL clients. */
  ja3: string;
  /** Optional. HTTP header information about the request. */
  headers: string[];
  /**
   * Optional. Flag for enabling firewall policy config assessment.
   * If this flag is enabled, the firewall policy is evaluated and a
   * suggested firewall action is returned in the response.
   */
  firewallPolicyEvaluation: boolean;
  /**
   * Optional. Data describing a payment transaction to be assessed. Sending
   * this data enables reCAPTCHA Fraud Prevention and the
   * FraudPreventionAssessment component in the response.
   */
  transactionData:
    | TransactionData
    | undefined;
  /**
   * Optional. Information about the user that generates this event, when they
   * can be identified. They are often identified through the use of an account
   * for logged-in requests or login/registration requests, or by providing user
   * identifiers for guest actions like checkout.
   */
  userInfo:
    | UserInfo
    | undefined;
  /** Optional. The Fraud Prevention setting for this assessment. */
  fraudPrevention: Event_FraudPrevention;
}

/** Setting that controls Fraud Prevention assessments. */
export enum Event_FraudPrevention {
  /**
   * FRAUD_PREVENTION_UNSPECIFIED - Default, unspecified setting. If opted in for automatic detection,
   * `fraud_prevention_assessment` is returned based on the request.
   * Otherwise, `fraud_prevention_assessment` is returned if
   * `transaction_data` is present in the `Event` and Fraud Prevention is
   * enabled in the Google Cloud console.
   */
  FRAUD_PREVENTION_UNSPECIFIED = 0,
  /**
   * ENABLED - Enable Fraud Prevention for this assessment, if Fraud Prevention is
   * enabled in the Google Cloud console.
   */
  ENABLED = 1,
  /**
   * DISABLED - Disable Fraud Prevention for this assessment, regardless of opt-in
   * status or Google Cloud console settings.
   */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function event_FraudPreventionFromJSON(object: any): Event_FraudPrevention {
  switch (object) {
    case 0:
    case "FRAUD_PREVENTION_UNSPECIFIED":
      return Event_FraudPrevention.FRAUD_PREVENTION_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Event_FraudPrevention.ENABLED;
    case 2:
    case "DISABLED":
      return Event_FraudPrevention.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_FraudPrevention.UNRECOGNIZED;
  }
}

export function event_FraudPreventionToJSON(object: Event_FraudPrevention): string {
  switch (object) {
    case Event_FraudPrevention.FRAUD_PREVENTION_UNSPECIFIED:
      return "FRAUD_PREVENTION_UNSPECIFIED";
    case Event_FraudPrevention.ENABLED:
      return "ENABLED";
    case Event_FraudPrevention.DISABLED:
      return "DISABLED";
    case Event_FraudPrevention.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction data associated with a payment protected by reCAPTCHA Enterprise. */
export interface TransactionData {
  /**
   * Unique identifier for the transaction. This custom identifier can be used
   * to reference this transaction in the future, for example, labeling a refund
   * or chargeback event. Two attempts at the same transaction should use the
   * same transaction id.
   */
  transactionId?:
    | string
    | undefined;
  /**
   * Optional. The payment method for the transaction. The allowed values are:
   *
   * * credit-card
   * * debit-card
   * * gift-card
   * * processor-{name} (If a third-party is used, for example,
   * processor-paypal)
   * * custom-{name} (If an alternative method is used, for example,
   * custom-crypto)
   */
  paymentMethod: string;
  /**
   * Optional. The Bank Identification Number - generally the first 6 or 8
   * digits of the card.
   */
  cardBin: string;
  /** Optional. The last four digits of the card. */
  cardLastFour: string;
  /** Optional. The currency code in ISO-4217 format. */
  currencyCode: string;
  /** Optional. The decimal value of the transaction in the specified currency. */
  value: number;
  /**
   * Optional. The value of shipping in the specified currency. 0 for free or no
   * shipping.
   */
  shippingValue: number;
  /**
   * Optional. Destination address if this transaction involves shipping a
   * physical item.
   */
  shippingAddress:
    | TransactionData_Address
    | undefined;
  /** Optional. Address associated with the payment method when applicable. */
  billingAddress:
    | TransactionData_Address
    | undefined;
  /** Optional. Information about the user paying/initiating the transaction. */
  user:
    | TransactionData_User
    | undefined;
  /** Optional. Information about the user or users fulfilling the transaction. */
  merchants: TransactionData_User[];
  /** Optional. Items purchased in this transaction. */
  items: TransactionData_Item[];
  /**
   * Optional. Information about the payment gateway's response to the
   * transaction.
   */
  gatewayInfo: TransactionData_GatewayInfo | undefined;
}

/** Structured address format for billing and shipping addresses. */
export interface TransactionData_Address {
  /**
   * Optional. The recipient name, potentially including information such as
   * "care of".
   */
  recipient: string;
  /**
   * Optional. The first lines of the address. The first line generally
   * contains the street name and number, and further lines may include
   * information such as an apartment number.
   */
  address: string[];
  /** Optional. The town/city of the address. */
  locality: string;
  /**
   * Optional. The state, province, or otherwise administrative area of the
   * address.
   */
  administrativeArea: string;
  /** Optional. The CLDR country/region of the address. */
  regionCode: string;
  /** Optional. The postal or ZIP code of the address. */
  postalCode: string;
}

/** Details about a user's account involved in the transaction. */
export interface TransactionData_User {
  /**
   * Optional. Unique account identifier for this user. If using account
   * defender, this should match the hashed_account_id field. Otherwise, a
   * unique and persistent identifier for this account.
   */
  accountId: string;
  /** Optional. The epoch milliseconds of the user's account creation. */
  creationMs: Long;
  /** Optional. The email address of the user. */
  email: string;
  /**
   * Optional. Whether the email has been verified to be accessible by the
   * user (OTP or similar).
   */
  emailVerified: boolean;
  /** Optional. The phone number of the user, with country code. */
  phoneNumber: string;
  /**
   * Optional. Whether the phone number has been verified to be accessible by
   * the user (OTP or similar).
   */
  phoneVerified: boolean;
}

/** Line items being purchased in this transaction. */
export interface TransactionData_Item {
  /** Optional. The full name of the item. */
  name: string;
  /**
   * Optional. The value per item that the user is paying, in the transaction
   * currency, after discounts.
   */
  value: number;
  /** Optional. The quantity of this item that is being purchased. */
  quantity: Long;
  /**
   * Optional. When a merchant is specified, its corresponding account_id.
   * Necessary to populate marketplace-style transactions.
   */
  merchantAccountId: string;
}

/** Details about the transaction from the gateway. */
export interface TransactionData_GatewayInfo {
  /**
   * Optional. Name of the gateway service (for example, stripe, square,
   * paypal).
   */
  name: string;
  /** Optional. Gateway response code describing the state of the transaction. */
  gatewayResponseCode: string;
  /**
   * Optional. AVS response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   */
  avsResponseCode: string;
  /**
   * Optional. CVV response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   */
  cvvResponseCode: string;
}

/** User information associated with a request protected by reCAPTCHA Enterprise. */
export interface UserInfo {
  /**
   * Optional. Creation time for this account associated with this user. Leave
   * blank for non logged-in actions, guest checkout, or when there is no
   * account associated with the current user.
   */
  createAccountTime:
    | Date
    | undefined;
  /**
   * Optional. For logged-in requests or login/registration requests, the unique
   * account identifier associated with this user. You can use the username if
   * it is stable (meaning it is the same for every request associated with the
   * same user), or any stable user ID of your choice. Leave blank for non
   * logged-in actions or guest checkout.
   */
  accountId: string;
  /** Optional. Identifiers associated with this user or request. */
  userIds: UserId[];
}

/** An identifier associated with a user. */
export interface UserId {
  /** Optional. An email address. */
  email?:
    | string
    | undefined;
  /** Optional. A phone number. Should use the E.164 format. */
  phoneNumber?:
    | string
    | undefined;
  /**
   * Optional. A unique username, if different from all the other identifiers
   * and `account_id` that are provided. Can be a unique login handle or
   * display name for a user.
   */
  username?: string | undefined;
}

/** Risk analysis result for an event. */
export interface RiskAnalysis {
  /**
   * Output only. Legitimate event score from 0.0 to 1.0.
   * (1.0 means very likely legitimate traffic while 0.0 means very likely
   * non-legitimate traffic).
   */
  score: number;
  /** Output only. Reasons contributing to the risk analysis verdict. */
  reasons: RiskAnalysis_ClassificationReason[];
  /**
   * Output only. Extended verdict reasons to be used for experimentation only.
   * The set of possible reasons is subject to change.
   */
  extendedVerdictReasons: string[];
}

/** Reasons contributing to the risk analysis verdict. */
export enum RiskAnalysis_ClassificationReason {
  /** CLASSIFICATION_REASON_UNSPECIFIED - Default unspecified type. */
  CLASSIFICATION_REASON_UNSPECIFIED = 0,
  /** AUTOMATION - Interactions matched the behavior of an automated agent. */
  AUTOMATION = 1,
  /** UNEXPECTED_ENVIRONMENT - The event originated from an illegitimate environment. */
  UNEXPECTED_ENVIRONMENT = 2,
  /** TOO_MUCH_TRAFFIC - Traffic volume from the event source is higher than normal. */
  TOO_MUCH_TRAFFIC = 3,
  /**
   * UNEXPECTED_USAGE_PATTERNS - Interactions with the site were significantly different than expected
   * patterns.
   */
  UNEXPECTED_USAGE_PATTERNS = 4,
  /**
   * LOW_CONFIDENCE_SCORE - Too little traffic has been received from this site thus far to generate
   * quality risk analysis.
   */
  LOW_CONFIDENCE_SCORE = 5,
  /** SUSPECTED_CARDING - The request matches behavioral characteristics of a carding attack. */
  SUSPECTED_CARDING = 6,
  /** SUSPECTED_CHARGEBACK - The request matches behavioral characteristics of chargebacks for fraud. */
  SUSPECTED_CHARGEBACK = 7,
  UNRECOGNIZED = -1,
}

export function riskAnalysis_ClassificationReasonFromJSON(object: any): RiskAnalysis_ClassificationReason {
  switch (object) {
    case 0:
    case "CLASSIFICATION_REASON_UNSPECIFIED":
      return RiskAnalysis_ClassificationReason.CLASSIFICATION_REASON_UNSPECIFIED;
    case 1:
    case "AUTOMATION":
      return RiskAnalysis_ClassificationReason.AUTOMATION;
    case 2:
    case "UNEXPECTED_ENVIRONMENT":
      return RiskAnalysis_ClassificationReason.UNEXPECTED_ENVIRONMENT;
    case 3:
    case "TOO_MUCH_TRAFFIC":
      return RiskAnalysis_ClassificationReason.TOO_MUCH_TRAFFIC;
    case 4:
    case "UNEXPECTED_USAGE_PATTERNS":
      return RiskAnalysis_ClassificationReason.UNEXPECTED_USAGE_PATTERNS;
    case 5:
    case "LOW_CONFIDENCE_SCORE":
      return RiskAnalysis_ClassificationReason.LOW_CONFIDENCE_SCORE;
    case 6:
    case "SUSPECTED_CARDING":
      return RiskAnalysis_ClassificationReason.SUSPECTED_CARDING;
    case 7:
    case "SUSPECTED_CHARGEBACK":
      return RiskAnalysis_ClassificationReason.SUSPECTED_CHARGEBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RiskAnalysis_ClassificationReason.UNRECOGNIZED;
  }
}

export function riskAnalysis_ClassificationReasonToJSON(object: RiskAnalysis_ClassificationReason): string {
  switch (object) {
    case RiskAnalysis_ClassificationReason.CLASSIFICATION_REASON_UNSPECIFIED:
      return "CLASSIFICATION_REASON_UNSPECIFIED";
    case RiskAnalysis_ClassificationReason.AUTOMATION:
      return "AUTOMATION";
    case RiskAnalysis_ClassificationReason.UNEXPECTED_ENVIRONMENT:
      return "UNEXPECTED_ENVIRONMENT";
    case RiskAnalysis_ClassificationReason.TOO_MUCH_TRAFFIC:
      return "TOO_MUCH_TRAFFIC";
    case RiskAnalysis_ClassificationReason.UNEXPECTED_USAGE_PATTERNS:
      return "UNEXPECTED_USAGE_PATTERNS";
    case RiskAnalysis_ClassificationReason.LOW_CONFIDENCE_SCORE:
      return "LOW_CONFIDENCE_SCORE";
    case RiskAnalysis_ClassificationReason.SUSPECTED_CARDING:
      return "SUSPECTED_CARDING";
    case RiskAnalysis_ClassificationReason.SUSPECTED_CHARGEBACK:
      return "SUSPECTED_CHARGEBACK";
    case RiskAnalysis_ClassificationReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Properties of the provided event token. */
export interface TokenProperties {
  /**
   * Output only. Whether the provided user response token is valid. When valid
   * = false, the reason could be specified in invalid_reason or it could also
   * be due to a user failing to solve a challenge or a sitekey mismatch (i.e
   * the sitekey used to generate the token was different than the one specified
   * in the assessment).
   */
  valid: boolean;
  /** Output only. Reason associated with the response when valid = false. */
  invalidReason: TokenProperties_InvalidReason;
  /** Output only. The timestamp corresponding to the generation of the token. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The hostname of the page on which the token was generated (Web
   * keys only).
   */
  hostname: string;
  /**
   * Output only. The name of the Android package with which the token was
   * generated (Android keys only).
   */
  androidPackageName: string;
  /**
   * Output only. The ID of the iOS bundle with which the token was generated
   * (iOS keys only).
   */
  iosBundleId: string;
  /** Output only. Action name provided at token generation. */
  action: string;
}

/** Enum that represents the types of invalid token reasons. */
export enum TokenProperties_InvalidReason {
  /** INVALID_REASON_UNSPECIFIED - Default unspecified type. */
  INVALID_REASON_UNSPECIFIED = 0,
  /** UNKNOWN_INVALID_REASON - If the failure reason was not accounted for. */
  UNKNOWN_INVALID_REASON = 1,
  /** MALFORMED - The provided user verification token was malformed. */
  MALFORMED = 2,
  /** EXPIRED - The user verification token had expired. */
  EXPIRED = 3,
  /** DUPE - The user verification had already been seen. */
  DUPE = 4,
  /** MISSING - The user verification token was not present. */
  MISSING = 5,
  /**
   * BROWSER_ERROR - A retriable error (such as network failure) occurred on the browser.
   * Could easily be simulated by an attacker.
   */
  BROWSER_ERROR = 6,
  UNRECOGNIZED = -1,
}

export function tokenProperties_InvalidReasonFromJSON(object: any): TokenProperties_InvalidReason {
  switch (object) {
    case 0:
    case "INVALID_REASON_UNSPECIFIED":
      return TokenProperties_InvalidReason.INVALID_REASON_UNSPECIFIED;
    case 1:
    case "UNKNOWN_INVALID_REASON":
      return TokenProperties_InvalidReason.UNKNOWN_INVALID_REASON;
    case 2:
    case "MALFORMED":
      return TokenProperties_InvalidReason.MALFORMED;
    case 3:
    case "EXPIRED":
      return TokenProperties_InvalidReason.EXPIRED;
    case 4:
    case "DUPE":
      return TokenProperties_InvalidReason.DUPE;
    case 5:
    case "MISSING":
      return TokenProperties_InvalidReason.MISSING;
    case 6:
    case "BROWSER_ERROR":
      return TokenProperties_InvalidReason.BROWSER_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TokenProperties_InvalidReason.UNRECOGNIZED;
  }
}

export function tokenProperties_InvalidReasonToJSON(object: TokenProperties_InvalidReason): string {
  switch (object) {
    case TokenProperties_InvalidReason.INVALID_REASON_UNSPECIFIED:
      return "INVALID_REASON_UNSPECIFIED";
    case TokenProperties_InvalidReason.UNKNOWN_INVALID_REASON:
      return "UNKNOWN_INVALID_REASON";
    case TokenProperties_InvalidReason.MALFORMED:
      return "MALFORMED";
    case TokenProperties_InvalidReason.EXPIRED:
      return "EXPIRED";
    case TokenProperties_InvalidReason.DUPE:
      return "DUPE";
    case TokenProperties_InvalidReason.MISSING:
      return "MISSING";
    case TokenProperties_InvalidReason.BROWSER_ERROR:
      return "BROWSER_ERROR";
    case TokenProperties_InvalidReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Assessment for Fraud Prevention. */
export interface FraudPreventionAssessment {
  /**
   * Output only. Probability of this transaction being fraudulent. Summarizes
   * the combined risk of attack vectors below. Values are from 0.0 (lowest)
   * to 1.0 (highest).
   */
  transactionRisk: number;
  /**
   * Output only. Assessment of this transaction for risk of a stolen
   * instrument.
   */
  stolenInstrumentVerdict:
    | FraudPreventionAssessment_StolenInstrumentVerdict
    | undefined;
  /**
   * Output only. Assessment of this transaction for risk of being part of a
   * card testing attack.
   */
  cardTestingVerdict:
    | FraudPreventionAssessment_CardTestingVerdict
    | undefined;
  /** Output only. Assessment of this transaction for behavioral trust. */
  behavioralTrustVerdict: FraudPreventionAssessment_BehavioralTrustVerdict | undefined;
}

/**
 * Information about stolen instrument fraud, where the user is not the
 * legitimate owner of the instrument being used for the purchase.
 */
export interface FraudPreventionAssessment_StolenInstrumentVerdict {
  /**
   * Output only. Probability of this transaction being executed with a stolen
   * instrument. Values are from 0.0 (lowest) to 1.0 (highest).
   */
  risk: number;
}

/**
 * Information about card testing fraud, where an adversary is testing
 * fraudulently obtained cards or brute forcing their details.
 */
export interface FraudPreventionAssessment_CardTestingVerdict {
  /**
   * Output only. Probability of this transaction attempt being part of a card
   * testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
   */
  risk: number;
}

/** Information about behavioral trust of the transaction. */
export interface FraudPreventionAssessment_BehavioralTrustVerdict {
  /**
   * Output only. Probability of this transaction attempt being executed in a
   * behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
   * (highest).
   */
  trust: number;
}

/** Fraud signals describing users and cards involved in the transaction. */
export interface FraudSignals {
  /** Output only. Signals describing the end user in this transaction. */
  userSignals:
    | FraudSignals_UserSignals
    | undefined;
  /**
   * Output only. Signals describing the payment card or cards used in this
   * transaction.
   */
  cardSignals: FraudSignals_CardSignals | undefined;
}

/** Signals describing the user involved in this transaction. */
export interface FraudSignals_UserSignals {
  /**
   * Output only. This user (based on email, phone, and other identifiers) has
   * been seen on the internet for at least this number of days.
   */
  activeDaysLowerBound: number;
  /**
   * Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
   * components in their identity, such as a randomly generated email address,
   * temporary phone number, or fake shipping address.
   */
  syntheticRisk: number;
}

/** Signals describing the payment card used in this transaction. */
export interface FraudSignals_CardSignals {
  /** Output only. The labels for the payment card in this transaction. */
  cardLabels: FraudSignals_CardSignals_CardLabel[];
}

/**
 * Risk labels describing the card being assessed, such as its funding
 * mechanism.
 */
export enum FraudSignals_CardSignals_CardLabel {
  /** CARD_LABEL_UNSPECIFIED - No label specified. */
  CARD_LABEL_UNSPECIFIED = 0,
  /** PREPAID - This card has been detected as prepaid. */
  PREPAID = 1,
  /**
   * VIRTUAL - This card has been detected as virtual, such as a card number generated
   * for a single transaction or merchant.
   */
  VIRTUAL = 2,
  /**
   * UNEXPECTED_LOCATION - This card has been detected as being used in an unexpected geographic
   * location.
   */
  UNEXPECTED_LOCATION = 3,
  UNRECOGNIZED = -1,
}

export function fraudSignals_CardSignals_CardLabelFromJSON(object: any): FraudSignals_CardSignals_CardLabel {
  switch (object) {
    case 0:
    case "CARD_LABEL_UNSPECIFIED":
      return FraudSignals_CardSignals_CardLabel.CARD_LABEL_UNSPECIFIED;
    case 1:
    case "PREPAID":
      return FraudSignals_CardSignals_CardLabel.PREPAID;
    case 2:
    case "VIRTUAL":
      return FraudSignals_CardSignals_CardLabel.VIRTUAL;
    case 3:
    case "UNEXPECTED_LOCATION":
      return FraudSignals_CardSignals_CardLabel.UNEXPECTED_LOCATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FraudSignals_CardSignals_CardLabel.UNRECOGNIZED;
  }
}

export function fraudSignals_CardSignals_CardLabelToJSON(object: FraudSignals_CardSignals_CardLabel): string {
  switch (object) {
    case FraudSignals_CardSignals_CardLabel.CARD_LABEL_UNSPECIFIED:
      return "CARD_LABEL_UNSPECIFIED";
    case FraudSignals_CardSignals_CardLabel.PREPAID:
      return "PREPAID";
    case FraudSignals_CardSignals_CardLabel.VIRTUAL:
      return "VIRTUAL";
    case FraudSignals_CardSignals_CardLabel.UNEXPECTED_LOCATION:
      return "UNEXPECTED_LOCATION";
    case FraudSignals_CardSignals_CardLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about SMS toll fraud. */
export interface SmsTollFraudVerdict {
  /**
   * Output only. Probability of an SMS event being fraudulent.
   * Values are from 0.0 (lowest) to 1.0 (highest).
   */
  risk: number;
  /** Output only. Reasons contributing to the SMS toll fraud verdict. */
  reasons: SmsTollFraudVerdict_SmsTollFraudReason[];
}

/** Reasons contributing to the SMS toll fraud verdict. */
export enum SmsTollFraudVerdict_SmsTollFraudReason {
  /** SMS_TOLL_FRAUD_REASON_UNSPECIFIED - Default unspecified reason */
  SMS_TOLL_FRAUD_REASON_UNSPECIFIED = 0,
  /** INVALID_PHONE_NUMBER - The provided phone number was invalid */
  INVALID_PHONE_NUMBER = 1,
  UNRECOGNIZED = -1,
}

export function smsTollFraudVerdict_SmsTollFraudReasonFromJSON(object: any): SmsTollFraudVerdict_SmsTollFraudReason {
  switch (object) {
    case 0:
    case "SMS_TOLL_FRAUD_REASON_UNSPECIFIED":
      return SmsTollFraudVerdict_SmsTollFraudReason.SMS_TOLL_FRAUD_REASON_UNSPECIFIED;
    case 1:
    case "INVALID_PHONE_NUMBER":
      return SmsTollFraudVerdict_SmsTollFraudReason.INVALID_PHONE_NUMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SmsTollFraudVerdict_SmsTollFraudReason.UNRECOGNIZED;
  }
}

export function smsTollFraudVerdict_SmsTollFraudReasonToJSON(object: SmsTollFraudVerdict_SmsTollFraudReason): string {
  switch (object) {
    case SmsTollFraudVerdict_SmsTollFraudReason.SMS_TOLL_FRAUD_REASON_UNSPECIFIED:
      return "SMS_TOLL_FRAUD_REASON_UNSPECIFIED";
    case SmsTollFraudVerdict_SmsTollFraudReason.INVALID_PHONE_NUMBER:
      return "INVALID_PHONE_NUMBER";
    case SmsTollFraudVerdict_SmsTollFraudReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Assessment for Phone Fraud */
export interface PhoneFraudAssessment {
  /** Output only. Assessment of this phone event for risk of SMS toll fraud. */
  smsTollFraudVerdict: SmsTollFraudVerdict | undefined;
}

/** Account defender risk assessment. */
export interface AccountDefenderAssessment {
  /** Output only. Labels for this request. */
  labels: AccountDefenderAssessment_AccountDefenderLabel[];
}

/** Labels returned by account defender for this request. */
export enum AccountDefenderAssessment_AccountDefenderLabel {
  /** ACCOUNT_DEFENDER_LABEL_UNSPECIFIED - Default unspecified type. */
  ACCOUNT_DEFENDER_LABEL_UNSPECIFIED = 0,
  /** PROFILE_MATCH - The request matches a known good profile for the user. */
  PROFILE_MATCH = 1,
  /**
   * SUSPICIOUS_LOGIN_ACTIVITY - The request is potentially a suspicious login event and must be further
   * verified either through multi-factor authentication or another system.
   */
  SUSPICIOUS_LOGIN_ACTIVITY = 2,
  /**
   * SUSPICIOUS_ACCOUNT_CREATION - The request matched a profile that previously had suspicious account
   * creation behavior. This can mean that this is a fake account.
   */
  SUSPICIOUS_ACCOUNT_CREATION = 3,
  /**
   * RELATED_ACCOUNTS_NUMBER_HIGH - The account in the request has a high number of related accounts. It does
   * not necessarily imply that the account is bad but can require further
   * investigation.
   */
  RELATED_ACCOUNTS_NUMBER_HIGH = 4,
  UNRECOGNIZED = -1,
}

export function accountDefenderAssessment_AccountDefenderLabelFromJSON(
  object: any,
): AccountDefenderAssessment_AccountDefenderLabel {
  switch (object) {
    case 0:
    case "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED":
      return AccountDefenderAssessment_AccountDefenderLabel.ACCOUNT_DEFENDER_LABEL_UNSPECIFIED;
    case 1:
    case "PROFILE_MATCH":
      return AccountDefenderAssessment_AccountDefenderLabel.PROFILE_MATCH;
    case 2:
    case "SUSPICIOUS_LOGIN_ACTIVITY":
      return AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_LOGIN_ACTIVITY;
    case 3:
    case "SUSPICIOUS_ACCOUNT_CREATION":
      return AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_ACCOUNT_CREATION;
    case 4:
    case "RELATED_ACCOUNTS_NUMBER_HIGH":
      return AccountDefenderAssessment_AccountDefenderLabel.RELATED_ACCOUNTS_NUMBER_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountDefenderAssessment_AccountDefenderLabel.UNRECOGNIZED;
  }
}

export function accountDefenderAssessment_AccountDefenderLabelToJSON(
  object: AccountDefenderAssessment_AccountDefenderLabel,
): string {
  switch (object) {
    case AccountDefenderAssessment_AccountDefenderLabel.ACCOUNT_DEFENDER_LABEL_UNSPECIFIED:
      return "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED";
    case AccountDefenderAssessment_AccountDefenderLabel.PROFILE_MATCH:
      return "PROFILE_MATCH";
    case AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_LOGIN_ACTIVITY:
      return "SUSPICIOUS_LOGIN_ACTIVITY";
    case AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_ACCOUNT_CREATION:
      return "SUSPICIOUS_ACCOUNT_CREATION";
    case AccountDefenderAssessment_AccountDefenderLabel.RELATED_ACCOUNTS_NUMBER_HIGH:
      return "RELATED_ACCOUNTS_NUMBER_HIGH";
    case AccountDefenderAssessment_AccountDefenderLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The create key request message. */
export interface CreateKeyRequest {
  /**
   * Required. The name of the project in which the key is created, in the
   * format `projects/{project}`.
   */
  parent: string;
  /** Required. Information to create a reCAPTCHA Enterprise key. */
  key: Key | undefined;
}

/** The list keys request message. */
export interface ListKeysRequest {
  /**
   * Required. The name of the project that contains the keys that are
   * listed, in the format `projects/{project}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of keys to return. Default is 10. Max limit is
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous.
   * ListKeysRequest, if any.
   */
  pageToken: string;
}

/** Response to request to list keys in a project. */
export interface ListKeysResponse {
  /** Key details. */
  keys: Key[];
  /**
   * Token to retrieve the next page of results. It is set to empty if no keys
   * remain in results.
   */
  nextPageToken: string;
}

/** The retrieve legacy secret key request message. */
export interface RetrieveLegacySecretKeyRequest {
  /**
   * Required. The public key name linked to the requested secret key in the
   * format `projects/{project}/keys/{key}`.
   */
  key: string;
}

/** The get key request message. */
export interface GetKeyRequest {
  /**
   * Required. The name of the requested key, in the format
   * `projects/{project}/keys/{key}`.
   */
  name: string;
}

/** The update key request message. */
export interface UpdateKeyRequest {
  /** Required. The key to update. */
  key:
    | Key
    | undefined;
  /**
   * Optional. The mask to control which fields of the key get updated. If the
   * mask is not present, all fields are updated.
   */
  updateMask: string[] | undefined;
}

/** The delete key request message. */
export interface DeleteKeyRequest {
  /**
   * Required. The name of the key to be deleted, in the format
   * `projects/{project}/keys/{key}`.
   */
  name: string;
}

/** The create firewall policy request message. */
export interface CreateFirewallPolicyRequest {
  /**
   * Required. The name of the project this policy will apply to, in the format
   * `projects/{project}`.
   */
  parent: string;
  /** Required. Information to create the policy. */
  firewallPolicy: FirewallPolicy | undefined;
}

/** The list firewall policies request message. */
export interface ListFirewallPoliciesRequest {
  /**
   * Required. The name of the project to list the policies for, in the format
   * `projects/{project}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of policies to return. Default is 10. Max
   * limit is 1000.
   */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous.
   * ListFirewallPoliciesRequest, if any.
   */
  pageToken: string;
}

/** Response to request to list firewall policies belonging to a project. */
export interface ListFirewallPoliciesResponse {
  /** Policy details. */
  firewallPolicies: FirewallPolicy[];
  /**
   * Token to retrieve the next page of results. It is set to empty if no
   * policies remain in results.
   */
  nextPageToken: string;
}

/** The get firewall policy request message. */
export interface GetFirewallPolicyRequest {
  /**
   * Required. The name of the requested policy, in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   */
  name: string;
}

/** The update firewall policy request message. */
export interface UpdateFirewallPolicyRequest {
  /** Required. The policy to update. */
  firewallPolicy:
    | FirewallPolicy
    | undefined;
  /**
   * Optional. The mask to control which fields of the policy get updated. If
   * the mask is not present, all fields are updated.
   */
  updateMask: string[] | undefined;
}

/** The delete firewall policy request message. */
export interface DeleteFirewallPolicyRequest {
  /**
   * Required. The name of the policy to be deleted, in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   */
  name: string;
}

/** The reorder firewall policies request message. */
export interface ReorderFirewallPoliciesRequest {
  /**
   * Required. The name of the project to list the policies for, in the format
   * `projects/{project}`.
   */
  parent: string;
  /**
   * Required. A list containing all policy names, in the new order. Each name
   * is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
   */
  names: string[];
}

/** The reorder firewall policies response message. */
export interface ReorderFirewallPoliciesResponse {
}

/** The migrate key request message. */
export interface MigrateKeyRequest {
  /**
   * Required. The name of the key to be migrated, in the format
   * `projects/{project}/keys/{key}`.
   */
  name: string;
  /**
   * Optional. If true, skips the billing check.
   * A reCAPTCHA Enterprise key or migrated key behaves differently than a
   * reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
   * https://cloud.google.com/recaptcha/quotas#quota_limit). To avoid
   * any disruption of your usage, we check that a billing account is present.
   * If your usage of reCAPTCHA is under the free quota, you can safely skip the
   * billing check and proceed with the migration. See
   * https://cloud.google.com/recaptcha/docs/billing-information.
   */
  skipBillingCheck: boolean;
}

/** The get metrics request message. */
export interface GetMetricsRequest {
  /**
   * Required. The name of the requested metrics, in the format
   * `projects/{project}/keys/{key}/metrics`.
   */
  name: string;
}

/** Metrics for a single Key. */
export interface Metrics {
  /**
   * Output only. Identifier. The name of the metrics, in the format
   * `projects/{project}/keys/{key}/metrics`.
   */
  name: string;
  /** Inclusive start time aligned to a day (UTC). */
  startTime:
    | Date
    | undefined;
  /**
   * Metrics are continuous and in order by dates, and in the granularity
   * of day. All Key types should have score-based data.
   */
  scoreMetrics: ScoreMetrics[];
  /**
   * Metrics are continuous and in order by dates, and in the granularity
   * of day. Only challenge-based keys (CHECKBOX, INVISIBLE), will have
   * challenge-based data.
   */
  challengeMetrics: ChallengeMetrics[];
}

/**
 * Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
 * integration with legacy reCAPTCHA.
 */
export interface RetrieveLegacySecretKeyResponse {
  /**
   * The secret key (also known as shared secret) authorizes communication
   * between your application backend and the reCAPTCHA Enterprise server to
   * create an assessment.
   * The secret key needs to be kept safe for security purposes.
   */
  legacySecretKey: string;
}

/**
 * A key used to identify and configure applications (web and/or mobile) that
 * use reCAPTCHA Enterprise.
 */
export interface Key {
  /**
   * Identifier. The resource name for the Key in the format
   * `projects/{project}/keys/{key}`.
   */
  name: string;
  /** Required. Human-readable display name of this key. Modifiable by user. */
  displayName: string;
  /** Settings for keys that can be used by websites. */
  webSettings?:
    | WebKeySettings
    | undefined;
  /** Settings for keys that can be used by Android apps. */
  androidSettings?:
    | AndroidKeySettings
    | undefined;
  /** Settings for keys that can be used by iOS apps. */
  iosSettings?:
    | IOSKeySettings
    | undefined;
  /** Settings specific to keys that can be used for reCAPTCHA Express. */
  expressSettings?:
    | ExpressKeySettings
    | undefined;
  /**
   * Optional. See [Creating and managing labels]
   * (https://cloud.google.com/recaptcha/docs/labels).
   */
  labels: { [key: string]: string };
  /** Output only. The timestamp corresponding to the creation of this key. */
  createTime:
    | Date
    | undefined;
  /** Optional. Options for user acceptance testing. */
  testingOptions:
    | TestingOptions
    | undefined;
  /** Optional. Settings for WAF */
  wafSettings: WafSettings | undefined;
}

export interface Key_LabelsEntry {
  key: string;
  value: string;
}

/** Options for user acceptance testing. */
export interface TestingOptions {
  /**
   * Optional. All assessments for this Key will return this score. Must be
   * between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
   */
  testingScore: number;
  /**
   * Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
   * challenge requests for this site will return nocaptcha if NOCAPTCHA, or an
   * unsolvable challenge if CHALLENGE.
   */
  testingChallenge: TestingOptions_TestingChallenge;
}

/**
 * Enum that represents the challenge option for challenge-based (CHECKBOX,
 * INVISIBLE) testing keys.
 */
export enum TestingOptions_TestingChallenge {
  /**
   * TESTING_CHALLENGE_UNSPECIFIED - Perform the normal risk analysis and return either nocaptcha or a
   * challenge depending on risk and trust factors.
   */
  TESTING_CHALLENGE_UNSPECIFIED = 0,
  /**
   * NOCAPTCHA - Challenge requests for this key always return a nocaptcha, which
   * does not require a solution.
   */
  NOCAPTCHA = 1,
  /**
   * UNSOLVABLE_CHALLENGE - Challenge requests for this key always return an unsolvable
   * challenge.
   */
  UNSOLVABLE_CHALLENGE = 2,
  UNRECOGNIZED = -1,
}

export function testingOptions_TestingChallengeFromJSON(object: any): TestingOptions_TestingChallenge {
  switch (object) {
    case 0:
    case "TESTING_CHALLENGE_UNSPECIFIED":
      return TestingOptions_TestingChallenge.TESTING_CHALLENGE_UNSPECIFIED;
    case 1:
    case "NOCAPTCHA":
      return TestingOptions_TestingChallenge.NOCAPTCHA;
    case 2:
    case "UNSOLVABLE_CHALLENGE":
      return TestingOptions_TestingChallenge.UNSOLVABLE_CHALLENGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestingOptions_TestingChallenge.UNRECOGNIZED;
  }
}

export function testingOptions_TestingChallengeToJSON(object: TestingOptions_TestingChallenge): string {
  switch (object) {
    case TestingOptions_TestingChallenge.TESTING_CHALLENGE_UNSPECIFIED:
      return "TESTING_CHALLENGE_UNSPECIFIED";
    case TestingOptions_TestingChallenge.NOCAPTCHA:
      return "NOCAPTCHA";
    case TestingOptions_TestingChallenge.UNSOLVABLE_CHALLENGE:
      return "UNSOLVABLE_CHALLENGE";
    case TestingOptions_TestingChallenge.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Settings specific to keys that can be used by websites. */
export interface WebKeySettings {
  /** Optional. If set to true, it means allowed_domains will not be enforced. */
  allowAllDomains: boolean;
  /**
   * Optional. Domains or subdomains of websites allowed to use the key. All
   * subdomains of an allowed domain are automatically allowed. A valid domain
   * requires a host and must not include any path, port, query or fragment.
   * Examples: 'example.com' or 'subdomain.example.com'
   */
  allowedDomains: string[];
  /**
   * Optional. If set to true, the key can be used on AMP (Accelerated Mobile
   * Pages) websites. This is supported only for the SCORE integration type.
   */
  allowAmpTraffic: boolean;
  /** Required. Describes how this key is integrated with the website. */
  integrationType: WebKeySettings_IntegrationType;
  /**
   * Optional. Settings for the frequency and difficulty at which this key
   * triggers captcha challenges. This should only be specified for
   * IntegrationTypes CHECKBOX and INVISIBLE.
   */
  challengeSecurityPreference: WebKeySettings_ChallengeSecurityPreference;
}

/** Enum that represents the integration types for web keys. */
export enum WebKeySettings_IntegrationType {
  /**
   * INTEGRATION_TYPE_UNSPECIFIED - Default type that indicates this enum hasn't been specified. This is not
   * a valid IntegrationType, one of the other types must be specified
   * instead.
   */
  INTEGRATION_TYPE_UNSPECIFIED = 0,
  /**
   * SCORE - Only used to produce scores. It doesn't display the "I'm not a robot"
   * checkbox and never shows captcha challenges.
   */
  SCORE = 1,
  /**
   * CHECKBOX - Displays the "I'm not a robot" checkbox and may show captcha challenges
   * after it is checked.
   */
  CHECKBOX = 2,
  /**
   * INVISIBLE - Doesn't display the "I'm not a robot" checkbox, but may show captcha
   * challenges after risk analysis.
   */
  INVISIBLE = 3,
  UNRECOGNIZED = -1,
}

export function webKeySettings_IntegrationTypeFromJSON(object: any): WebKeySettings_IntegrationType {
  switch (object) {
    case 0:
    case "INTEGRATION_TYPE_UNSPECIFIED":
      return WebKeySettings_IntegrationType.INTEGRATION_TYPE_UNSPECIFIED;
    case 1:
    case "SCORE":
      return WebKeySettings_IntegrationType.SCORE;
    case 2:
    case "CHECKBOX":
      return WebKeySettings_IntegrationType.CHECKBOX;
    case 3:
    case "INVISIBLE":
      return WebKeySettings_IntegrationType.INVISIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebKeySettings_IntegrationType.UNRECOGNIZED;
  }
}

export function webKeySettings_IntegrationTypeToJSON(object: WebKeySettings_IntegrationType): string {
  switch (object) {
    case WebKeySettings_IntegrationType.INTEGRATION_TYPE_UNSPECIFIED:
      return "INTEGRATION_TYPE_UNSPECIFIED";
    case WebKeySettings_IntegrationType.SCORE:
      return "SCORE";
    case WebKeySettings_IntegrationType.CHECKBOX:
      return "CHECKBOX";
    case WebKeySettings_IntegrationType.INVISIBLE:
      return "INVISIBLE";
    case WebKeySettings_IntegrationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enum that represents the possible challenge frequency and difficulty
 * configurations for a web key.
 */
export enum WebKeySettings_ChallengeSecurityPreference {
  /** CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED - Default type that indicates this enum hasn't been specified. */
  CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED = 0,
  /** USABILITY - Key tends to show fewer and easier challenges. */
  USABILITY = 1,
  /** BALANCE - Key tends to show balanced (in amount and difficulty) challenges. */
  BALANCE = 2,
  /** SECURITY - Key tends to show more and harder challenges. */
  SECURITY = 3,
  UNRECOGNIZED = -1,
}

export function webKeySettings_ChallengeSecurityPreferenceFromJSON(
  object: any,
): WebKeySettings_ChallengeSecurityPreference {
  switch (object) {
    case 0:
    case "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED":
      return WebKeySettings_ChallengeSecurityPreference.CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED;
    case 1:
    case "USABILITY":
      return WebKeySettings_ChallengeSecurityPreference.USABILITY;
    case 2:
    case "BALANCE":
      return WebKeySettings_ChallengeSecurityPreference.BALANCE;
    case 3:
    case "SECURITY":
      return WebKeySettings_ChallengeSecurityPreference.SECURITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebKeySettings_ChallengeSecurityPreference.UNRECOGNIZED;
  }
}

export function webKeySettings_ChallengeSecurityPreferenceToJSON(
  object: WebKeySettings_ChallengeSecurityPreference,
): string {
  switch (object) {
    case WebKeySettings_ChallengeSecurityPreference.CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED:
      return "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED";
    case WebKeySettings_ChallengeSecurityPreference.USABILITY:
      return "USABILITY";
    case WebKeySettings_ChallengeSecurityPreference.BALANCE:
      return "BALANCE";
    case WebKeySettings_ChallengeSecurityPreference.SECURITY:
      return "SECURITY";
    case WebKeySettings_ChallengeSecurityPreference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Settings specific to keys that can be used by Android apps. */
export interface AndroidKeySettings {
  /** Optional. If set to true, allowed_package_names are not enforced. */
  allowAllPackageNames: boolean;
  /**
   * Optional. Android package names of apps allowed to use the key.
   * Example: 'com.companyname.appname'
   */
  allowedPackageNames: string[];
  /**
   * Optional. Set to true for keys that are used in an Android application that
   * is available for download in app stores in addition to the Google Play
   * Store.
   */
  supportNonGoogleAppStoreDistribution: boolean;
}

/** Settings specific to keys that can be used by iOS apps. */
export interface IOSKeySettings {
  /** Optional. If set to true, allowed_bundle_ids are not enforced. */
  allowAllBundleIds: boolean;
  /**
   * Optional. iOS bundle ids of apps allowed to use the key.
   * Example: 'com.companyname.productname.appname'
   */
  allowedBundleIds: string[];
  /**
   * Optional. Apple Developer account details for the app that is protected by
   * the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks
   * like Apple App Attest and Apple DeviceCheck to protect your app from abuse.
   * Providing these fields allows reCAPTCHA Enterprise to get a better
   * assessment of the integrity of your app.
   */
  appleDeveloperId: AppleDeveloperId | undefined;
}

/** Settings specific to keys that can be used for reCAPTCHA Express. */
export interface ExpressKeySettings {
}

/** Contains fields that are required to perform Apple-specific integrity checks. */
export interface AppleDeveloperId {
  /**
   * Required. Input only. A private key (downloaded as a text file with a .p8
   * file extension) generated for your Apple Developer account. Ensure that
   * Apple DeviceCheck is enabled for the private key.
   */
  privateKey: string;
  /** Required. The Apple developer key ID (10-character string). */
  keyId: string;
  /**
   * Required. The Apple team ID (10-character string) owning the provisioning
   * profile used to build your application.
   */
  teamId: string;
}

/** Score distribution. */
export interface ScoreDistribution {
  /**
   * Map key is score value multiplied by 100. The scores are discrete values
   * between [0, 1]. The maximum number of buckets is on order of a few dozen,
   * but typically much lower (ie. 10).
   */
  scoreBuckets: { [key: number]: Long };
}

export interface ScoreDistribution_ScoreBucketsEntry {
  key: number;
  value: Long;
}

/** Metrics related to scoring. */
export interface ScoreMetrics {
  /** Aggregated score metrics for all traffic. */
  overallMetrics:
    | ScoreDistribution
    | undefined;
  /**
   * Action-based metrics. The map key is the action name which specified by the
   * site owners at time of the "execute" client-side call.
   */
  actionMetrics: { [key: string]: ScoreDistribution };
}

export interface ScoreMetrics_ActionMetricsEntry {
  key: string;
  value: ScoreDistribution | undefined;
}

/** Metrics related to challenges. */
export interface ChallengeMetrics {
  /**
   * Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
   * to a count of pageloads for pages that include reCAPTCHA.
   */
  pageloadCount: Long;
  /** Count of nocaptchas (successful verification without a challenge) issued. */
  nocaptchaCount: Long;
  /**
   * Count of submitted challenge solutions that were incorrect or otherwise
   * deemed suspicious such that a subsequent challenge was triggered.
   */
  failedCount: Long;
  /**
   * Count of nocaptchas (successful verification without a challenge) plus
   * submitted challenge solutions that were correct and resulted in
   * verification.
   */
  passedCount: Long;
}

/** Policy config assessment. */
export interface FirewallPolicyAssessment {
  /**
   * Output only. If the processing of a policy config fails, an error is
   * populated and the firewall_policy is left empty.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. The policy that matched the request. If more than one policy
   * may match, this is the first match. If no policy matches the incoming
   * request, the policy field is left empty.
   */
  firewallPolicy: FirewallPolicy | undefined;
}

/**
 * An individual action. Each action represents what to do if a policy
 * matches.
 */
export interface FirewallAction {
  /**
   * The user request did not match any policy and should be allowed
   * access to the requested resource.
   */
  allow?:
    | FirewallAction_AllowAction
    | undefined;
  /**
   * This action will deny access to a given page. The user will get an HTTP
   * error code.
   */
  block?:
    | FirewallAction_BlockAction
    | undefined;
  /**
   * This action will inject reCAPTCHA JavaScript code into the HTML page
   * returned by the site backend.
   */
  includeRecaptchaScript?:
    | FirewallAction_IncludeRecaptchaScriptAction
    | undefined;
  /**
   * This action will redirect the request to a ReCaptcha interstitial to
   * attach a token.
   */
  redirect?:
    | FirewallAction_RedirectAction
    | undefined;
  /**
   * This action will transparently serve a different page to an offending
   * user.
   */
  substitute?:
    | FirewallAction_SubstituteAction
    | undefined;
  /**
   * This action will set a custom header but allow the request to continue
   * to the customer backend.
   */
  setHeader?: FirewallAction_SetHeaderAction | undefined;
}

/** An allow action continues processing a request unimpeded. */
export interface FirewallAction_AllowAction {
}

/**
 * A block action serves an HTTP error code a prevents the request from
 * hitting the backend.
 */
export interface FirewallAction_BlockAction {
}

/**
 * An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
 * code into the HTML returned by the site backend. This reCAPTCHA
 * script is tasked with collecting user signals on the requested web page,
 * issuing tokens as a cookie within the site domain, and enabling their
 * utilization in subsequent page requests.
 */
export interface FirewallAction_IncludeRecaptchaScriptAction {
}

/**
 * A redirect action returns a 307 (temporary redirect) response, pointing
 * the user to a ReCaptcha interstitial page to attach a token.
 */
export interface FirewallAction_RedirectAction {
}

/**
 * A substitute action transparently serves a different page than the one
 * requested.
 */
export interface FirewallAction_SubstituteAction {
  /**
   * Optional. The address to redirect to. The target is a relative path in
   * the current host. Example: "/blog/404.html".
   */
  path: string;
}

/**
 * A set header action sets a header and forwards the request to the
 * backend. This can be used to trigger custom protection implemented on the
 * backend.
 */
export interface FirewallAction_SetHeaderAction {
  /** Optional. The header key to set in the request to the backend server. */
  key: string;
  /** Optional. The header value to set in the request to the backend server. */
  value: string;
}

/**
 * A FirewallPolicy represents a single matching pattern and resulting actions
 * to take.
 */
export interface FirewallPolicy {
  /**
   * Identifier. The resource name for the FirewallPolicy in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   */
  name: string;
  /**
   * Optional. A description of what this policy aims to achieve, for
   * convenience purposes. The description can at most include 256 UTF-8
   * characters.
   */
  description: string;
  /**
   * Optional. The path for which this policy applies, specified as a glob
   * pattern. For more information on glob, see the [manual
   * page](https://man7.org/linux/man-pages/man7/glob.7.html).
   * A path has a max length of 200 characters.
   */
  path: string;
  /**
   * Optional. A CEL (Common Expression Language) conditional expression that
   * specifies if this policy applies to an incoming user request. If this
   * condition evaluates to true and the requested path matched the path
   * pattern, the associated actions should be executed by the caller. The
   * condition string is checked for CEL syntax correctness on creation. For
   * more information, see the [CEL spec](https://github.com/google/cel-spec)
   * and its [language
   * definition](https://github.com/google/cel-spec/blob/master/doc/langdef.md).
   * A condition has a max length of 500 characters.
   */
  condition: string;
  /**
   * Optional. The actions that the caller should take regarding user access.
   * There should be at most one terminal action. A terminal action is any
   * action that forces a response, such as `AllowAction`,
   * `BlockAction` or `SubstituteAction`.
   * Zero or more non-terminal actions such as `SetHeader` might be
   * specified. A single policy can contain up to 16 actions.
   */
  actions: FirewallAction[];
}

/** The request message to list memberships in a related account group. */
export interface ListRelatedAccountGroupMembershipsRequest {
  /**
   * Required. The resource name for the related account group in the format
   * `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of accounts to return. The service might
   * return fewer than this value. If unspecified, at most 50 accounts are
   * returned. The maximum value is 1000; values above 1000 are coerced to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `ListRelatedAccountGroupMemberships` call.
   *
   * When paginating, all other parameters provided to
   * `ListRelatedAccountGroupMemberships` must match the call that provided the
   * page token.
   */
  pageToken: string;
}

/** The response to a `ListRelatedAccountGroupMemberships` call. */
export interface ListRelatedAccountGroupMembershipsResponse {
  /** The memberships listed by the query. */
  relatedAccountGroupMemberships: RelatedAccountGroupMembership[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The request message to list related account groups. */
export interface ListRelatedAccountGroupsRequest {
  /**
   * Required. The name of the project to list related account groups from, in
   * the format `projects/{project}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of groups to return. The service might return
   * fewer than this value. If unspecified, at most 50 groups are returned. The
   * maximum value is 1000; values above 1000 are coerced to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListRelatedAccountGroups`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListRelatedAccountGroups` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** The response to a `ListRelatedAccountGroups` call. */
export interface ListRelatedAccountGroupsResponse {
  /** The groups of related accounts listed by the query. */
  relatedAccountGroups: RelatedAccountGroup[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The request message to search related account group memberships. */
export interface SearchRelatedAccountGroupMembershipsRequest {
  /**
   * Required. The name of the project to search related account group
   * memberships from. Specify the project name in the following format:
   * `projects/{project}`.
   */
  project: string;
  /**
   * Optional. The unique stable account identifier used to search connections.
   * The identifier should correspond to an `account_id` provided in a previous
   * `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
   * or account_id must be set, but not both.
   */
  accountId: string;
  /**
   * Optional. Deprecated: use `account_id` instead.
   * The unique stable hashed account identifier used to search connections. The
   * identifier should correspond to a `hashed_account_id` provided in a
   * previous `CreateAssessment` or `AnnotateAssessment` call. Either
   * hashed_account_id or account_id must be set, but not both.
   *
   * @deprecated
   */
  hashedAccountId: Buffer;
  /**
   * Optional. The maximum number of groups to return. The service might return
   * fewer than this value. If unspecified, at most 50 groups are returned. The
   * maximum value is 1000; values above 1000 are coerced to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
   * subsequent page.
   *
   * When paginating, all other parameters provided to
   * `SearchRelatedAccountGroupMemberships` must match the call that provided
   * the page token.
   */
  pageToken: string;
}

/** The response to a `SearchRelatedAccountGroupMemberships` call. */
export interface SearchRelatedAccountGroupMembershipsResponse {
  /** The queried memberships. */
  relatedAccountGroupMemberships: RelatedAccountGroupMembership[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The AddIpOverride request message. */
export interface AddIpOverrideRequest {
  /**
   * Required. The name of the key to which the IP override is added, in the
   * format `projects/{project}/keys/{key}`.
   */
  name: string;
  /** Required. IP override added to the key. */
  ipOverrideData: IpOverrideData | undefined;
}

/** Response for AddIpOverride. */
export interface AddIpOverrideResponse {
}

/** A membership in a group of related accounts. */
export interface RelatedAccountGroupMembership {
  /**
   * Required. Identifier. The resource name for this membership in the format
   * `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
   */
  name: string;
  /**
   * The unique stable account identifier of the member. The identifier
   * corresponds to an `account_id` provided in a previous `CreateAssessment` or
   * `AnnotateAssessment` call.
   */
  accountId: string;
  /**
   * Deprecated: use `account_id` instead.
   * The unique stable hashed account identifier of the member. The identifier
   * corresponds to a `hashed_account_id` provided in a previous
   * `CreateAssessment` or `AnnotateAssessment` call.
   *
   * @deprecated
   */
  hashedAccountId: Buffer;
}

/** A group of related accounts. */
export interface RelatedAccountGroup {
  /**
   * Required. Identifier. The resource name for the related account group in
   * the format
   * `projects/{project}/relatedaccountgroups/{related_account_group}`.
   */
  name: string;
}

/**
 * Settings specific to keys that can be used for WAF (Web Application
 * Firewall).
 */
export interface WafSettings {
  /** Required. The WAF service that uses this key. */
  wafService: WafSettings_WafService;
  /** Required. The WAF feature for which this key is enabled. */
  wafFeature: WafSettings_WafFeature;
}

/**
 * Supported WAF features. For more information, see
 * https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features.
 */
export enum WafSettings_WafFeature {
  /** WAF_FEATURE_UNSPECIFIED - Undefined feature. */
  WAF_FEATURE_UNSPECIFIED = 0,
  /** CHALLENGE_PAGE - Redirects suspicious traffic to reCAPTCHA. */
  CHALLENGE_PAGE = 1,
  /**
   * SESSION_TOKEN - Use reCAPTCHA session-tokens to protect the whole user session on the
   * site's domain.
   */
  SESSION_TOKEN = 2,
  /** ACTION_TOKEN - Use reCAPTCHA action-tokens to protect user actions. */
  ACTION_TOKEN = 3,
  /**
   * EXPRESS - Use reCAPTCHA WAF express protection to protect any content other than
   * web pages, like APIs and IoT devices.
   */
  EXPRESS = 5,
  UNRECOGNIZED = -1,
}

export function wafSettings_WafFeatureFromJSON(object: any): WafSettings_WafFeature {
  switch (object) {
    case 0:
    case "WAF_FEATURE_UNSPECIFIED":
      return WafSettings_WafFeature.WAF_FEATURE_UNSPECIFIED;
    case 1:
    case "CHALLENGE_PAGE":
      return WafSettings_WafFeature.CHALLENGE_PAGE;
    case 2:
    case "SESSION_TOKEN":
      return WafSettings_WafFeature.SESSION_TOKEN;
    case 3:
    case "ACTION_TOKEN":
      return WafSettings_WafFeature.ACTION_TOKEN;
    case 5:
    case "EXPRESS":
      return WafSettings_WafFeature.EXPRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WafSettings_WafFeature.UNRECOGNIZED;
  }
}

export function wafSettings_WafFeatureToJSON(object: WafSettings_WafFeature): string {
  switch (object) {
    case WafSettings_WafFeature.WAF_FEATURE_UNSPECIFIED:
      return "WAF_FEATURE_UNSPECIFIED";
    case WafSettings_WafFeature.CHALLENGE_PAGE:
      return "CHALLENGE_PAGE";
    case WafSettings_WafFeature.SESSION_TOKEN:
      return "SESSION_TOKEN";
    case WafSettings_WafFeature.ACTION_TOKEN:
      return "ACTION_TOKEN";
    case WafSettings_WafFeature.EXPRESS:
      return "EXPRESS";
    case WafSettings_WafFeature.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Web Application Firewalls supported by reCAPTCHA Enterprise. */
export enum WafSettings_WafService {
  /** WAF_SERVICE_UNSPECIFIED - Undefined WAF */
  WAF_SERVICE_UNSPECIFIED = 0,
  /** CA - Cloud Armor */
  CA = 1,
  /** FASTLY - Fastly */
  FASTLY = 3,
  /** CLOUDFLARE - Cloudflare */
  CLOUDFLARE = 4,
  UNRECOGNIZED = -1,
}

export function wafSettings_WafServiceFromJSON(object: any): WafSettings_WafService {
  switch (object) {
    case 0:
    case "WAF_SERVICE_UNSPECIFIED":
      return WafSettings_WafService.WAF_SERVICE_UNSPECIFIED;
    case 1:
    case "CA":
      return WafSettings_WafService.CA;
    case 3:
    case "FASTLY":
      return WafSettings_WafService.FASTLY;
    case 4:
    case "CLOUDFLARE":
      return WafSettings_WafService.CLOUDFLARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WafSettings_WafService.UNRECOGNIZED;
  }
}

export function wafSettings_WafServiceToJSON(object: WafSettings_WafService): string {
  switch (object) {
    case WafSettings_WafService.WAF_SERVICE_UNSPECIFIED:
      return "WAF_SERVICE_UNSPECIFIED";
    case WafSettings_WafService.CA:
      return "CA";
    case WafSettings_WafService.FASTLY:
      return "FASTLY";
    case WafSettings_WafService.CLOUDFLARE:
      return "CLOUDFLARE";
    case WafSettings_WafService.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The environment creating the assessment. This describes your environment
 * (the system invoking CreateAssessment), NOT the environment of your user.
 */
export interface AssessmentEnvironment {
  /**
   * Optional. Identifies the client module initiating the CreateAssessment
   * request. This can be the link to the client module's project. Examples
   * include:
   * - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
   * - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
   * - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
   * - "wordpress.org/plugins/recaptcha-something"
   */
  client: string;
  /** Optional. The version of the client module. For example, "1.0.0". */
  version: string;
}

/** Information about the IP or IP range override. */
export interface IpOverrideData {
  /**
   * Required. The IP address to override (can be IPv4, IPv6 or CIDR).
   * The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
   * The IP override must be a public IP address.
   * Example of IPv4: 168.192.5.6
   * Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
   * Example of IPv4 with CIDR: 168.192.5.0/24
   * Example of IPv6 with CIDR: 2001:0DB8:1234::/48
   */
  ip: string;
  /** Required. Describes the type of IP override. */
  overrideType: IpOverrideData_OverrideType;
}

/** Enum that represents the type of IP override. */
export enum IpOverrideData_OverrideType {
  /** OVERRIDE_TYPE_UNSPECIFIED - Default override type that indicates this enum hasn't been specified. */
  OVERRIDE_TYPE_UNSPECIFIED = 0,
  /**
   * ALLOW - Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
   * all valid assessments.
   */
  ALLOW = 1,
  UNRECOGNIZED = -1,
}

export function ipOverrideData_OverrideTypeFromJSON(object: any): IpOverrideData_OverrideType {
  switch (object) {
    case 0:
    case "OVERRIDE_TYPE_UNSPECIFIED":
      return IpOverrideData_OverrideType.OVERRIDE_TYPE_UNSPECIFIED;
    case 1:
    case "ALLOW":
      return IpOverrideData_OverrideType.ALLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IpOverrideData_OverrideType.UNRECOGNIZED;
  }
}

export function ipOverrideData_OverrideTypeToJSON(object: IpOverrideData_OverrideType): string {
  switch (object) {
    case IpOverrideData_OverrideType.OVERRIDE_TYPE_UNSPECIFIED:
      return "OVERRIDE_TYPE_UNSPECIFIED";
    case IpOverrideData_OverrideType.ALLOW:
      return "ALLOW";
    case IpOverrideData_OverrideType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseCreateAssessmentRequest(): CreateAssessmentRequest {
  return { parent: "", assessment: undefined };
}

export const CreateAssessmentRequest: MessageFns<CreateAssessmentRequest> = {
  encode(message: CreateAssessmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.assessment !== undefined) {
      Assessment.encode(message.assessment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssessmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssessmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assessment = Assessment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssessmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      assessment: isSet(object.assessment) ? Assessment.fromJSON(object.assessment) : undefined,
    };
  },

  toJSON(message: CreateAssessmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.assessment !== undefined) {
      obj.assessment = Assessment.toJSON(message.assessment);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssessmentRequest>): CreateAssessmentRequest {
    return CreateAssessmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssessmentRequest>): CreateAssessmentRequest {
    const message = createBaseCreateAssessmentRequest();
    message.parent = object.parent ?? "";
    message.assessment = (object.assessment !== undefined && object.assessment !== null)
      ? Assessment.fromPartial(object.assessment)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent(): TransactionEvent {
  return { eventType: 0, reason: "", value: 0, eventTime: undefined };
}

export const TransactionEvent: MessageFns<TransactionEvent> = {
  encode(message: TransactionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.value !== 0) {
      writer.uint32(25).double(message.value);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent {
    return {
      eventType: isSet(object.eventType) ? transactionEvent_TransactionEventTypeFromJSON(object.eventType) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
    };
  },

  toJSON(message: TransactionEvent): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = transactionEvent_TransactionEventTypeToJSON(message.eventType);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent>): TransactionEvent {
    return TransactionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent>): TransactionEvent {
    const message = createBaseTransactionEvent();
    message.eventType = object.eventType ?? 0;
    message.reason = object.reason ?? "";
    message.value = object.value ?? 0;
    message.eventTime = object.eventTime ?? undefined;
    return message;
  },
};

function createBaseAnnotateAssessmentRequest(): AnnotateAssessmentRequest {
  return {
    name: "",
    annotation: 0,
    reasons: [],
    accountId: "",
    hashedAccountId: Buffer.alloc(0),
    transactionEvent: undefined,
  };
}

export const AnnotateAssessmentRequest: MessageFns<AnnotateAssessmentRequest> = {
  encode(message: AnnotateAssessmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.annotation !== 0) {
      writer.uint32(16).int32(message.annotation);
    }
    writer.uint32(26).fork();
    for (const v of message.reasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.accountId !== "") {
      writer.uint32(58).string(message.accountId);
    }
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(34).bytes(message.hashedAccountId);
    }
    if (message.transactionEvent !== undefined) {
      TransactionEvent.encode(message.transactionEvent, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateAssessmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateAssessmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.annotation = reader.int32() as any;
          continue;
        case 3:
          if (tag === 24) {
            message.reasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionEvent = TransactionEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotateAssessmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      annotation: isSet(object.annotation) ? annotateAssessmentRequest_AnnotationFromJSON(object.annotation) : 0,
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => annotateAssessmentRequest_ReasonFromJSON(e))
        : [],
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
      transactionEvent: isSet(object.transactionEvent) ? TransactionEvent.fromJSON(object.transactionEvent) : undefined,
    };
  },

  toJSON(message: AnnotateAssessmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.annotation !== 0) {
      obj.annotation = annotateAssessmentRequest_AnnotationToJSON(message.annotation);
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => annotateAssessmentRequest_ReasonToJSON(e));
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    if (message.transactionEvent !== undefined) {
      obj.transactionEvent = TransactionEvent.toJSON(message.transactionEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotateAssessmentRequest>): AnnotateAssessmentRequest {
    return AnnotateAssessmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotateAssessmentRequest>): AnnotateAssessmentRequest {
    const message = createBaseAnnotateAssessmentRequest();
    message.name = object.name ?? "";
    message.annotation = object.annotation ?? 0;
    message.reasons = object.reasons?.map((e) => e) || [];
    message.accountId = object.accountId ?? "";
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    message.transactionEvent = (object.transactionEvent !== undefined && object.transactionEvent !== null)
      ? TransactionEvent.fromPartial(object.transactionEvent)
      : undefined;
    return message;
  },
};

function createBaseAnnotateAssessmentResponse(): AnnotateAssessmentResponse {
  return {};
}

export const AnnotateAssessmentResponse: MessageFns<AnnotateAssessmentResponse> = {
  encode(_: AnnotateAssessmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateAssessmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateAssessmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnnotateAssessmentResponse {
    return {};
  },

  toJSON(_: AnnotateAssessmentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AnnotateAssessmentResponse>): AnnotateAssessmentResponse {
    return AnnotateAssessmentResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AnnotateAssessmentResponse>): AnnotateAssessmentResponse {
    const message = createBaseAnnotateAssessmentResponse();
    return message;
  },
};

function createBaseEndpointVerificationInfo(): EndpointVerificationInfo {
  return { emailAddress: undefined, phoneNumber: undefined, requestToken: "", lastVerificationTime: undefined };
}

export const EndpointVerificationInfo: MessageFns<EndpointVerificationInfo> = {
  encode(message: EndpointVerificationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAddress !== undefined) {
      writer.uint32(10).string(message.emailAddress);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(18).string(message.phoneNumber);
    }
    if (message.requestToken !== "") {
      writer.uint32(26).string(message.requestToken);
    }
    if (message.lastVerificationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastVerificationTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointVerificationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointVerificationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastVerificationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointVerificationInfo {
    return {
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      requestToken: isSet(object.requestToken) ? globalThis.String(object.requestToken) : "",
      lastVerificationTime: isSet(object.lastVerificationTime)
        ? fromJsonTimestamp(object.lastVerificationTime)
        : undefined,
    };
  },

  toJSON(message: EndpointVerificationInfo): unknown {
    const obj: any = {};
    if (message.emailAddress !== undefined) {
      obj.emailAddress = message.emailAddress;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.requestToken !== "") {
      obj.requestToken = message.requestToken;
    }
    if (message.lastVerificationTime !== undefined) {
      obj.lastVerificationTime = message.lastVerificationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<EndpointVerificationInfo>): EndpointVerificationInfo {
    return EndpointVerificationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndpointVerificationInfo>): EndpointVerificationInfo {
    const message = createBaseEndpointVerificationInfo();
    message.emailAddress = object.emailAddress ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.requestToken = object.requestToken ?? "";
    message.lastVerificationTime = object.lastVerificationTime ?? undefined;
    return message;
  },
};

function createBaseAccountVerificationInfo(): AccountVerificationInfo {
  return { endpoints: [], languageCode: "", latestVerificationResult: 0, username: "" };
}

export const AccountVerificationInfo: MessageFns<AccountVerificationInfo> = {
  encode(message: AccountVerificationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.endpoints) {
      EndpointVerificationInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    if (message.latestVerificationResult !== 0) {
      writer.uint32(56).int32(message.latestVerificationResult);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountVerificationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountVerificationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpoints.push(EndpointVerificationInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.latestVerificationResult = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountVerificationInfo {
    return {
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => EndpointVerificationInfo.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      latestVerificationResult: isSet(object.latestVerificationResult)
        ? accountVerificationInfo_ResultFromJSON(object.latestVerificationResult)
        : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AccountVerificationInfo): unknown {
    const obj: any = {};
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => EndpointVerificationInfo.toJSON(e));
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.latestVerificationResult !== 0) {
      obj.latestVerificationResult = accountVerificationInfo_ResultToJSON(message.latestVerificationResult);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountVerificationInfo>): AccountVerificationInfo {
    return AccountVerificationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountVerificationInfo>): AccountVerificationInfo {
    const message = createBaseAccountVerificationInfo();
    message.endpoints = object.endpoints?.map((e) => EndpointVerificationInfo.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    message.latestVerificationResult = object.latestVerificationResult ?? 0;
    message.username = object.username ?? "";
    return message;
  },
};

function createBasePrivatePasswordLeakVerification(): PrivatePasswordLeakVerification {
  return {
    lookupHashPrefix: Buffer.alloc(0),
    encryptedUserCredentialsHash: Buffer.alloc(0),
    encryptedLeakMatchPrefixes: [],
    reencryptedUserCredentialsHash: Buffer.alloc(0),
  };
}

export const PrivatePasswordLeakVerification: MessageFns<PrivatePasswordLeakVerification> = {
  encode(message: PrivatePasswordLeakVerification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lookupHashPrefix.length !== 0) {
      writer.uint32(10).bytes(message.lookupHashPrefix);
    }
    if (message.encryptedUserCredentialsHash.length !== 0) {
      writer.uint32(18).bytes(message.encryptedUserCredentialsHash);
    }
    for (const v of message.encryptedLeakMatchPrefixes) {
      writer.uint32(26).bytes(v!);
    }
    if (message.reencryptedUserCredentialsHash.length !== 0) {
      writer.uint32(34).bytes(message.reencryptedUserCredentialsHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivatePasswordLeakVerification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivatePasswordLeakVerification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lookupHashPrefix = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.encryptedUserCredentialsHash = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.encryptedLeakMatchPrefixes.push(Buffer.from(reader.bytes()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reencryptedUserCredentialsHash = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivatePasswordLeakVerification {
    return {
      lookupHashPrefix: isSet(object.lookupHashPrefix)
        ? Buffer.from(bytesFromBase64(object.lookupHashPrefix))
        : Buffer.alloc(0),
      encryptedUserCredentialsHash: isSet(object.encryptedUserCredentialsHash)
        ? Buffer.from(bytesFromBase64(object.encryptedUserCredentialsHash))
        : Buffer.alloc(0),
      encryptedLeakMatchPrefixes: globalThis.Array.isArray(object?.encryptedLeakMatchPrefixes)
        ? object.encryptedLeakMatchPrefixes.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      reencryptedUserCredentialsHash: isSet(object.reencryptedUserCredentialsHash)
        ? Buffer.from(bytesFromBase64(object.reencryptedUserCredentialsHash))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: PrivatePasswordLeakVerification): unknown {
    const obj: any = {};
    if (message.lookupHashPrefix.length !== 0) {
      obj.lookupHashPrefix = base64FromBytes(message.lookupHashPrefix);
    }
    if (message.encryptedUserCredentialsHash.length !== 0) {
      obj.encryptedUserCredentialsHash = base64FromBytes(message.encryptedUserCredentialsHash);
    }
    if (message.encryptedLeakMatchPrefixes?.length) {
      obj.encryptedLeakMatchPrefixes = message.encryptedLeakMatchPrefixes.map((e) => base64FromBytes(e));
    }
    if (message.reencryptedUserCredentialsHash.length !== 0) {
      obj.reencryptedUserCredentialsHash = base64FromBytes(message.reencryptedUserCredentialsHash);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivatePasswordLeakVerification>): PrivatePasswordLeakVerification {
    return PrivatePasswordLeakVerification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivatePasswordLeakVerification>): PrivatePasswordLeakVerification {
    const message = createBasePrivatePasswordLeakVerification();
    message.lookupHashPrefix = object.lookupHashPrefix ?? Buffer.alloc(0);
    message.encryptedUserCredentialsHash = object.encryptedUserCredentialsHash ?? Buffer.alloc(0);
    message.encryptedLeakMatchPrefixes = object.encryptedLeakMatchPrefixes?.map((e) => e) || [];
    message.reencryptedUserCredentialsHash = object.reencryptedUserCredentialsHash ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAssessment(): Assessment {
  return {
    name: "",
    event: undefined,
    riskAnalysis: undefined,
    tokenProperties: undefined,
    accountVerification: undefined,
    accountDefenderAssessment: undefined,
    privatePasswordLeakVerification: undefined,
    firewallPolicyAssessment: undefined,
    fraudPreventionAssessment: undefined,
    fraudSignals: undefined,
    phoneFraudAssessment: undefined,
    assessmentEnvironment: undefined,
  };
}

export const Assessment: MessageFns<Assessment> = {
  encode(message: Assessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.riskAnalysis !== undefined) {
      RiskAnalysis.encode(message.riskAnalysis, writer.uint32(26).fork()).join();
    }
    if (message.tokenProperties !== undefined) {
      TokenProperties.encode(message.tokenProperties, writer.uint32(34).fork()).join();
    }
    if (message.accountVerification !== undefined) {
      AccountVerificationInfo.encode(message.accountVerification, writer.uint32(42).fork()).join();
    }
    if (message.accountDefenderAssessment !== undefined) {
      AccountDefenderAssessment.encode(message.accountDefenderAssessment, writer.uint32(50).fork()).join();
    }
    if (message.privatePasswordLeakVerification !== undefined) {
      PrivatePasswordLeakVerification.encode(message.privatePasswordLeakVerification, writer.uint32(66).fork()).join();
    }
    if (message.firewallPolicyAssessment !== undefined) {
      FirewallPolicyAssessment.encode(message.firewallPolicyAssessment, writer.uint32(82).fork()).join();
    }
    if (message.fraudPreventionAssessment !== undefined) {
      FraudPreventionAssessment.encode(message.fraudPreventionAssessment, writer.uint32(90).fork()).join();
    }
    if (message.fraudSignals !== undefined) {
      FraudSignals.encode(message.fraudSignals, writer.uint32(106).fork()).join();
    }
    if (message.phoneFraudAssessment !== undefined) {
      PhoneFraudAssessment.encode(message.phoneFraudAssessment, writer.uint32(98).fork()).join();
    }
    if (message.assessmentEnvironment !== undefined) {
      AssessmentEnvironment.encode(message.assessmentEnvironment, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.riskAnalysis = RiskAnalysis.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenProperties = TokenProperties.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accountVerification = AccountVerificationInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accountDefenderAssessment = AccountDefenderAssessment.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.privatePasswordLeakVerification = PrivatePasswordLeakVerification.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.firewallPolicyAssessment = FirewallPolicyAssessment.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fraudPreventionAssessment = FraudPreventionAssessment.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.fraudSignals = FraudSignals.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.phoneFraudAssessment = PhoneFraudAssessment.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assessmentEnvironment = AssessmentEnvironment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assessment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      riskAnalysis: isSet(object.riskAnalysis) ? RiskAnalysis.fromJSON(object.riskAnalysis) : undefined,
      tokenProperties: isSet(object.tokenProperties) ? TokenProperties.fromJSON(object.tokenProperties) : undefined,
      accountVerification: isSet(object.accountVerification)
        ? AccountVerificationInfo.fromJSON(object.accountVerification)
        : undefined,
      accountDefenderAssessment: isSet(object.accountDefenderAssessment)
        ? AccountDefenderAssessment.fromJSON(object.accountDefenderAssessment)
        : undefined,
      privatePasswordLeakVerification: isSet(object.privatePasswordLeakVerification)
        ? PrivatePasswordLeakVerification.fromJSON(object.privatePasswordLeakVerification)
        : undefined,
      firewallPolicyAssessment: isSet(object.firewallPolicyAssessment)
        ? FirewallPolicyAssessment.fromJSON(object.firewallPolicyAssessment)
        : undefined,
      fraudPreventionAssessment: isSet(object.fraudPreventionAssessment)
        ? FraudPreventionAssessment.fromJSON(object.fraudPreventionAssessment)
        : undefined,
      fraudSignals: isSet(object.fraudSignals) ? FraudSignals.fromJSON(object.fraudSignals) : undefined,
      phoneFraudAssessment: isSet(object.phoneFraudAssessment)
        ? PhoneFraudAssessment.fromJSON(object.phoneFraudAssessment)
        : undefined,
      assessmentEnvironment: isSet(object.assessmentEnvironment)
        ? AssessmentEnvironment.fromJSON(object.assessmentEnvironment)
        : undefined,
    };
  },

  toJSON(message: Assessment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.riskAnalysis !== undefined) {
      obj.riskAnalysis = RiskAnalysis.toJSON(message.riskAnalysis);
    }
    if (message.tokenProperties !== undefined) {
      obj.tokenProperties = TokenProperties.toJSON(message.tokenProperties);
    }
    if (message.accountVerification !== undefined) {
      obj.accountVerification = AccountVerificationInfo.toJSON(message.accountVerification);
    }
    if (message.accountDefenderAssessment !== undefined) {
      obj.accountDefenderAssessment = AccountDefenderAssessment.toJSON(message.accountDefenderAssessment);
    }
    if (message.privatePasswordLeakVerification !== undefined) {
      obj.privatePasswordLeakVerification = PrivatePasswordLeakVerification.toJSON(
        message.privatePasswordLeakVerification,
      );
    }
    if (message.firewallPolicyAssessment !== undefined) {
      obj.firewallPolicyAssessment = FirewallPolicyAssessment.toJSON(message.firewallPolicyAssessment);
    }
    if (message.fraudPreventionAssessment !== undefined) {
      obj.fraudPreventionAssessment = FraudPreventionAssessment.toJSON(message.fraudPreventionAssessment);
    }
    if (message.fraudSignals !== undefined) {
      obj.fraudSignals = FraudSignals.toJSON(message.fraudSignals);
    }
    if (message.phoneFraudAssessment !== undefined) {
      obj.phoneFraudAssessment = PhoneFraudAssessment.toJSON(message.phoneFraudAssessment);
    }
    if (message.assessmentEnvironment !== undefined) {
      obj.assessmentEnvironment = AssessmentEnvironment.toJSON(message.assessmentEnvironment);
    }
    return obj;
  },

  create(base?: DeepPartial<Assessment>): Assessment {
    return Assessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assessment>): Assessment {
    const message = createBaseAssessment();
    message.name = object.name ?? "";
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.riskAnalysis = (object.riskAnalysis !== undefined && object.riskAnalysis !== null)
      ? RiskAnalysis.fromPartial(object.riskAnalysis)
      : undefined;
    message.tokenProperties = (object.tokenProperties !== undefined && object.tokenProperties !== null)
      ? TokenProperties.fromPartial(object.tokenProperties)
      : undefined;
    message.accountVerification = (object.accountVerification !== undefined && object.accountVerification !== null)
      ? AccountVerificationInfo.fromPartial(object.accountVerification)
      : undefined;
    message.accountDefenderAssessment =
      (object.accountDefenderAssessment !== undefined && object.accountDefenderAssessment !== null)
        ? AccountDefenderAssessment.fromPartial(object.accountDefenderAssessment)
        : undefined;
    message.privatePasswordLeakVerification =
      (object.privatePasswordLeakVerification !== undefined && object.privatePasswordLeakVerification !== null)
        ? PrivatePasswordLeakVerification.fromPartial(object.privatePasswordLeakVerification)
        : undefined;
    message.firewallPolicyAssessment =
      (object.firewallPolicyAssessment !== undefined && object.firewallPolicyAssessment !== null)
        ? FirewallPolicyAssessment.fromPartial(object.firewallPolicyAssessment)
        : undefined;
    message.fraudPreventionAssessment =
      (object.fraudPreventionAssessment !== undefined && object.fraudPreventionAssessment !== null)
        ? FraudPreventionAssessment.fromPartial(object.fraudPreventionAssessment)
        : undefined;
    message.fraudSignals = (object.fraudSignals !== undefined && object.fraudSignals !== null)
      ? FraudSignals.fromPartial(object.fraudSignals)
      : undefined;
    message.phoneFraudAssessment = (object.phoneFraudAssessment !== undefined && object.phoneFraudAssessment !== null)
      ? PhoneFraudAssessment.fromPartial(object.phoneFraudAssessment)
      : undefined;
    message.assessmentEnvironment =
      (object.assessmentEnvironment !== undefined && object.assessmentEnvironment !== null)
        ? AssessmentEnvironment.fromPartial(object.assessmentEnvironment)
        : undefined;
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    token: "",
    siteKey: "",
    userAgent: "",
    userIpAddress: "",
    expectedAction: "",
    hashedAccountId: Buffer.alloc(0),
    express: false,
    requestedUri: "",
    wafTokenAssessment: false,
    ja3: "",
    headers: [],
    firewallPolicyEvaluation: false,
    transactionData: undefined,
    userInfo: undefined,
    fraudPrevention: 0,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.siteKey !== "") {
      writer.uint32(18).string(message.siteKey);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (message.userIpAddress !== "") {
      writer.uint32(34).string(message.userIpAddress);
    }
    if (message.expectedAction !== "") {
      writer.uint32(42).string(message.expectedAction);
    }
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(50).bytes(message.hashedAccountId);
    }
    if (message.express !== false) {
      writer.uint32(112).bool(message.express);
    }
    if (message.requestedUri !== "") {
      writer.uint32(66).string(message.requestedUri);
    }
    if (message.wafTokenAssessment !== false) {
      writer.uint32(72).bool(message.wafTokenAssessment);
    }
    if (message.ja3 !== "") {
      writer.uint32(82).string(message.ja3);
    }
    for (const v of message.headers) {
      writer.uint32(90).string(v!);
    }
    if (message.firewallPolicyEvaluation !== false) {
      writer.uint32(96).bool(message.firewallPolicyEvaluation);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(106).fork()).join();
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(122).fork()).join();
    }
    if (message.fraudPrevention !== 0) {
      writer.uint32(136).int32(message.fraudPrevention);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.siteKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userIpAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expectedAction = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.express = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.requestedUri = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.wafTokenAssessment = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.ja3 = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.headers.push(reader.string());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.firewallPolicyEvaluation = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.fraudPrevention = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      siteKey: isSet(object.siteKey) ? globalThis.String(object.siteKey) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      userIpAddress: isSet(object.userIpAddress) ? globalThis.String(object.userIpAddress) : "",
      expectedAction: isSet(object.expectedAction) ? globalThis.String(object.expectedAction) : "",
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
      express: isSet(object.express) ? globalThis.Boolean(object.express) : false,
      requestedUri: isSet(object.requestedUri) ? globalThis.String(object.requestedUri) : "",
      wafTokenAssessment: isSet(object.wafTokenAssessment) ? globalThis.Boolean(object.wafTokenAssessment) : false,
      ja3: isSet(object.ja3) ? globalThis.String(object.ja3) : "",
      headers: globalThis.Array.isArray(object?.headers) ? object.headers.map((e: any) => globalThis.String(e)) : [],
      firewallPolicyEvaluation: isSet(object.firewallPolicyEvaluation)
        ? globalThis.Boolean(object.firewallPolicyEvaluation)
        : false,
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      fraudPrevention: isSet(object.fraudPrevention) ? event_FraudPreventionFromJSON(object.fraudPrevention) : 0,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.siteKey !== "") {
      obj.siteKey = message.siteKey;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.userIpAddress !== "") {
      obj.userIpAddress = message.userIpAddress;
    }
    if (message.expectedAction !== "") {
      obj.expectedAction = message.expectedAction;
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    if (message.express !== false) {
      obj.express = message.express;
    }
    if (message.requestedUri !== "") {
      obj.requestedUri = message.requestedUri;
    }
    if (message.wafTokenAssessment !== false) {
      obj.wafTokenAssessment = message.wafTokenAssessment;
    }
    if (message.ja3 !== "") {
      obj.ja3 = message.ja3;
    }
    if (message.headers?.length) {
      obj.headers = message.headers;
    }
    if (message.firewallPolicyEvaluation !== false) {
      obj.firewallPolicyEvaluation = message.firewallPolicyEvaluation;
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.fraudPrevention !== 0) {
      obj.fraudPrevention = event_FraudPreventionToJSON(message.fraudPrevention);
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent();
    message.token = object.token ?? "";
    message.siteKey = object.siteKey ?? "";
    message.userAgent = object.userAgent ?? "";
    message.userIpAddress = object.userIpAddress ?? "";
    message.expectedAction = object.expectedAction ?? "";
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    message.express = object.express ?? false;
    message.requestedUri = object.requestedUri ?? "";
    message.wafTokenAssessment = object.wafTokenAssessment ?? false;
    message.ja3 = object.ja3 ?? "";
    message.headers = object.headers?.map((e) => e) || [];
    message.firewallPolicyEvaluation = object.firewallPolicyEvaluation ?? false;
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.fraudPrevention = object.fraudPrevention ?? 0;
    return message;
  },
};

function createBaseTransactionData(): TransactionData {
  return {
    transactionId: undefined,
    paymentMethod: "",
    cardBin: "",
    cardLastFour: "",
    currencyCode: "",
    value: 0,
    shippingValue: 0,
    shippingAddress: undefined,
    billingAddress: undefined,
    user: undefined,
    merchants: [],
    items: [],
    gatewayInfo: undefined,
  };
}

export const TransactionData: MessageFns<TransactionData> = {
  encode(message: TransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== undefined) {
      writer.uint32(90).string(message.transactionId);
    }
    if (message.paymentMethod !== "") {
      writer.uint32(10).string(message.paymentMethod);
    }
    if (message.cardBin !== "") {
      writer.uint32(18).string(message.cardBin);
    }
    if (message.cardLastFour !== "") {
      writer.uint32(26).string(message.cardLastFour);
    }
    if (message.currencyCode !== "") {
      writer.uint32(34).string(message.currencyCode);
    }
    if (message.value !== 0) {
      writer.uint32(41).double(message.value);
    }
    if (message.shippingValue !== 0) {
      writer.uint32(97).double(message.shippingValue);
    }
    if (message.shippingAddress !== undefined) {
      TransactionData_Address.encode(message.shippingAddress, writer.uint32(50).fork()).join();
    }
    if (message.billingAddress !== undefined) {
      TransactionData_Address.encode(message.billingAddress, writer.uint32(58).fork()).join();
    }
    if (message.user !== undefined) {
      TransactionData_User.encode(message.user, writer.uint32(66).fork()).join();
    }
    for (const v of message.merchants) {
      TransactionData_User.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.items) {
      TransactionData_Item.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.gatewayInfo !== undefined) {
      TransactionData_GatewayInfo.encode(message.gatewayInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cardBin = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cardLastFour = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.value = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.shippingValue = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shippingAddress = TransactionData_Address.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.billingAddress = TransactionData_Address.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.user = TransactionData_User.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.merchants.push(TransactionData_User.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.items.push(TransactionData_Item.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gatewayInfo = TransactionData_GatewayInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : "",
      cardBin: isSet(object.cardBin) ? globalThis.String(object.cardBin) : "",
      cardLastFour: isSet(object.cardLastFour) ? globalThis.String(object.cardLastFour) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      shippingValue: isSet(object.shippingValue) ? globalThis.Number(object.shippingValue) : 0,
      shippingAddress: isSet(object.shippingAddress)
        ? TransactionData_Address.fromJSON(object.shippingAddress)
        : undefined,
      billingAddress: isSet(object.billingAddress)
        ? TransactionData_Address.fromJSON(object.billingAddress)
        : undefined,
      user: isSet(object.user) ? TransactionData_User.fromJSON(object.user) : undefined,
      merchants: globalThis.Array.isArray(object?.merchants)
        ? object.merchants.map((e: any) => TransactionData_User.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TransactionData_Item.fromJSON(e))
        : [],
      gatewayInfo: isSet(object.gatewayInfo) ? TransactionData_GatewayInfo.fromJSON(object.gatewayInfo) : undefined,
    };
  },

  toJSON(message: TransactionData): unknown {
    const obj: any = {};
    if (message.transactionId !== undefined) {
      obj.transactionId = message.transactionId;
    }
    if (message.paymentMethod !== "") {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.cardBin !== "") {
      obj.cardBin = message.cardBin;
    }
    if (message.cardLastFour !== "") {
      obj.cardLastFour = message.cardLastFour;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.shippingValue !== 0) {
      obj.shippingValue = message.shippingValue;
    }
    if (message.shippingAddress !== undefined) {
      obj.shippingAddress = TransactionData_Address.toJSON(message.shippingAddress);
    }
    if (message.billingAddress !== undefined) {
      obj.billingAddress = TransactionData_Address.toJSON(message.billingAddress);
    }
    if (message.user !== undefined) {
      obj.user = TransactionData_User.toJSON(message.user);
    }
    if (message.merchants?.length) {
      obj.merchants = message.merchants.map((e) => TransactionData_User.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => TransactionData_Item.toJSON(e));
    }
    if (message.gatewayInfo !== undefined) {
      obj.gatewayInfo = TransactionData_GatewayInfo.toJSON(message.gatewayInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData>): TransactionData {
    return TransactionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData>): TransactionData {
    const message = createBaseTransactionData();
    message.transactionId = object.transactionId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? "";
    message.cardBin = object.cardBin ?? "";
    message.cardLastFour = object.cardLastFour ?? "";
    message.currencyCode = object.currencyCode ?? "";
    message.value = object.value ?? 0;
    message.shippingValue = object.shippingValue ?? 0;
    message.shippingAddress = (object.shippingAddress !== undefined && object.shippingAddress !== null)
      ? TransactionData_Address.fromPartial(object.shippingAddress)
      : undefined;
    message.billingAddress = (object.billingAddress !== undefined && object.billingAddress !== null)
      ? TransactionData_Address.fromPartial(object.billingAddress)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null)
      ? TransactionData_User.fromPartial(object.user)
      : undefined;
    message.merchants = object.merchants?.map((e) => TransactionData_User.fromPartial(e)) || [];
    message.items = object.items?.map((e) => TransactionData_Item.fromPartial(e)) || [];
    message.gatewayInfo = (object.gatewayInfo !== undefined && object.gatewayInfo !== null)
      ? TransactionData_GatewayInfo.fromPartial(object.gatewayInfo)
      : undefined;
    return message;
  },
};

function createBaseTransactionData_Address(): TransactionData_Address {
  return { recipient: "", address: [], locality: "", administrativeArea: "", regionCode: "", postalCode: "" };
}

export const TransactionData_Address: MessageFns<TransactionData_Address> = {
  encode(message: TransactionData_Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipient !== "") {
      writer.uint32(10).string(message.recipient);
    }
    for (const v of message.address) {
      writer.uint32(18).string(v!);
    }
    if (message.locality !== "") {
      writer.uint32(26).string(message.locality);
    }
    if (message.administrativeArea !== "") {
      writer.uint32(34).string(message.administrativeArea);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    if (message.postalCode !== "") {
      writer.uint32(50).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_Address();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recipient = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locality = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.administrativeArea = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_Address {
    return {
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
      address: globalThis.Array.isArray(object?.address) ? object.address.map((e: any) => globalThis.String(e)) : [],
      locality: isSet(object.locality) ? globalThis.String(object.locality) : "",
      administrativeArea: isSet(object.administrativeArea) ? globalThis.String(object.administrativeArea) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
    };
  },

  toJSON(message: TransactionData_Address): unknown {
    const obj: any = {};
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    if (message.address?.length) {
      obj.address = message.address;
    }
    if (message.locality !== "") {
      obj.locality = message.locality;
    }
    if (message.administrativeArea !== "") {
      obj.administrativeArea = message.administrativeArea;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_Address>): TransactionData_Address {
    return TransactionData_Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_Address>): TransactionData_Address {
    const message = createBaseTransactionData_Address();
    message.recipient = object.recipient ?? "";
    message.address = object.address?.map((e) => e) || [];
    message.locality = object.locality ?? "";
    message.administrativeArea = object.administrativeArea ?? "";
    message.regionCode = object.regionCode ?? "";
    message.postalCode = object.postalCode ?? "";
    return message;
  },
};

function createBaseTransactionData_User(): TransactionData_User {
  return {
    accountId: "",
    creationMs: Long.ZERO,
    email: "",
    emailVerified: false,
    phoneNumber: "",
    phoneVerified: false,
  };
}

export const TransactionData_User: MessageFns<TransactionData_User> = {
  encode(message: TransactionData_User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(50).string(message.accountId);
    }
    if (!message.creationMs.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.creationMs.toString());
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.emailVerified !== false) {
      writer.uint32(24).bool(message.emailVerified);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(34).string(message.phoneNumber);
    }
    if (message.phoneVerified !== false) {
      writer.uint32(40).bool(message.phoneVerified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_User();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.creationMs = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.emailVerified = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.phoneVerified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_User {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      creationMs: isSet(object.creationMs) ? Long.fromValue(object.creationMs) : Long.ZERO,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      emailVerified: isSet(object.emailVerified) ? globalThis.Boolean(object.emailVerified) : false,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      phoneVerified: isSet(object.phoneVerified) ? globalThis.Boolean(object.phoneVerified) : false,
    };
  },

  toJSON(message: TransactionData_User): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (!message.creationMs.equals(Long.ZERO)) {
      obj.creationMs = (message.creationMs || Long.ZERO).toString();
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.emailVerified !== false) {
      obj.emailVerified = message.emailVerified;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.phoneVerified !== false) {
      obj.phoneVerified = message.phoneVerified;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_User>): TransactionData_User {
    return TransactionData_User.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_User>): TransactionData_User {
    const message = createBaseTransactionData_User();
    message.accountId = object.accountId ?? "";
    message.creationMs = (object.creationMs !== undefined && object.creationMs !== null)
      ? Long.fromValue(object.creationMs)
      : Long.ZERO;
    message.email = object.email ?? "";
    message.emailVerified = object.emailVerified ?? false;
    message.phoneNumber = object.phoneNumber ?? "";
    message.phoneVerified = object.phoneVerified ?? false;
    return message;
  },
};

function createBaseTransactionData_Item(): TransactionData_Item {
  return { name: "", value: 0, quantity: Long.ZERO, merchantAccountId: "" };
}

export const TransactionData_Item: MessageFns<TransactionData_Item> = {
  encode(message: TransactionData_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    if (!message.quantity.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.quantity.toString());
    }
    if (message.merchantAccountId !== "") {
      writer.uint32(34).string(message.merchantAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quantity = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.merchantAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_Item {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      quantity: isSet(object.quantity) ? Long.fromValue(object.quantity) : Long.ZERO,
      merchantAccountId: isSet(object.merchantAccountId) ? globalThis.String(object.merchantAccountId) : "",
    };
  },

  toJSON(message: TransactionData_Item): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (!message.quantity.equals(Long.ZERO)) {
      obj.quantity = (message.quantity || Long.ZERO).toString();
    }
    if (message.merchantAccountId !== "") {
      obj.merchantAccountId = message.merchantAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_Item>): TransactionData_Item {
    return TransactionData_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_Item>): TransactionData_Item {
    const message = createBaseTransactionData_Item();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Long.fromValue(object.quantity)
      : Long.ZERO;
    message.merchantAccountId = object.merchantAccountId ?? "";
    return message;
  },
};

function createBaseTransactionData_GatewayInfo(): TransactionData_GatewayInfo {
  return { name: "", gatewayResponseCode: "", avsResponseCode: "", cvvResponseCode: "" };
}

export const TransactionData_GatewayInfo: MessageFns<TransactionData_GatewayInfo> = {
  encode(message: TransactionData_GatewayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.gatewayResponseCode !== "") {
      writer.uint32(18).string(message.gatewayResponseCode);
    }
    if (message.avsResponseCode !== "") {
      writer.uint32(26).string(message.avsResponseCode);
    }
    if (message.cvvResponseCode !== "") {
      writer.uint32(34).string(message.cvvResponseCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_GatewayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_GatewayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gatewayResponseCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avsResponseCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cvvResponseCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_GatewayInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      gatewayResponseCode: isSet(object.gatewayResponseCode) ? globalThis.String(object.gatewayResponseCode) : "",
      avsResponseCode: isSet(object.avsResponseCode) ? globalThis.String(object.avsResponseCode) : "",
      cvvResponseCode: isSet(object.cvvResponseCode) ? globalThis.String(object.cvvResponseCode) : "",
    };
  },

  toJSON(message: TransactionData_GatewayInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.gatewayResponseCode !== "") {
      obj.gatewayResponseCode = message.gatewayResponseCode;
    }
    if (message.avsResponseCode !== "") {
      obj.avsResponseCode = message.avsResponseCode;
    }
    if (message.cvvResponseCode !== "") {
      obj.cvvResponseCode = message.cvvResponseCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_GatewayInfo>): TransactionData_GatewayInfo {
    return TransactionData_GatewayInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_GatewayInfo>): TransactionData_GatewayInfo {
    const message = createBaseTransactionData_GatewayInfo();
    message.name = object.name ?? "";
    message.gatewayResponseCode = object.gatewayResponseCode ?? "";
    message.avsResponseCode = object.avsResponseCode ?? "";
    message.cvvResponseCode = object.cvvResponseCode ?? "";
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { createAccountTime: undefined, accountId: "", userIds: [] };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createAccountTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createAccountTime), writer.uint32(10).fork()).join();
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    for (const v of message.userIds) {
      UserId.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createAccountTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userIds.push(UserId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      createAccountTime: isSet(object.createAccountTime) ? fromJsonTimestamp(object.createAccountTime) : undefined,
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => UserId.fromJSON(e)) : [],
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.createAccountTime !== undefined) {
      obj.createAccountTime = message.createAccountTime.toISOString();
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => UserId.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.createAccountTime = object.createAccountTime ?? undefined;
    message.accountId = object.accountId ?? "";
    message.userIds = object.userIds?.map((e) => UserId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserId(): UserId {
  return { email: undefined, phoneNumber: undefined, username: undefined };
}

export const UserId: MessageFns<UserId> = {
  encode(message: UserId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      writer.uint32(10).string(message.email);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(18).string(message.phoneNumber);
    }
    if (message.username !== undefined) {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserId {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
    };
  },

  toJSON(message: UserId): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<UserId>): UserId {
    return UserId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserId>): UserId {
    const message = createBaseUserId();
    message.email = object.email ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.username = object.username ?? undefined;
    return message;
  },
};

function createBaseRiskAnalysis(): RiskAnalysis {
  return { score: 0, reasons: [], extendedVerdictReasons: [] };
}

export const RiskAnalysis: MessageFns<RiskAnalysis> = {
  encode(message: RiskAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(13).float(message.score);
    }
    writer.uint32(18).fork();
    for (const v of message.reasons) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.extendedVerdictReasons) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiskAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiskAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag === 16) {
            message.reasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extendedVerdictReasons.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiskAnalysis {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => riskAnalysis_ClassificationReasonFromJSON(e))
        : [],
      extendedVerdictReasons: globalThis.Array.isArray(object?.extendedVerdictReasons)
        ? object.extendedVerdictReasons.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RiskAnalysis): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => riskAnalysis_ClassificationReasonToJSON(e));
    }
    if (message.extendedVerdictReasons?.length) {
      obj.extendedVerdictReasons = message.extendedVerdictReasons;
    }
    return obj;
  },

  create(base?: DeepPartial<RiskAnalysis>): RiskAnalysis {
    return RiskAnalysis.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RiskAnalysis>): RiskAnalysis {
    const message = createBaseRiskAnalysis();
    message.score = object.score ?? 0;
    message.reasons = object.reasons?.map((e) => e) || [];
    message.extendedVerdictReasons = object.extendedVerdictReasons?.map((e) => e) || [];
    return message;
  },
};

function createBaseTokenProperties(): TokenProperties {
  return {
    valid: false,
    invalidReason: 0,
    createTime: undefined,
    hostname: "",
    androidPackageName: "",
    iosBundleId: "",
    action: "",
  };
}

export const TokenProperties: MessageFns<TokenProperties> = {
  encode(message: TokenProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.invalidReason !== 0) {
      writer.uint32(16).int32(message.invalidReason);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.hostname !== "") {
      writer.uint32(34).string(message.hostname);
    }
    if (message.androidPackageName !== "") {
      writer.uint32(66).string(message.androidPackageName);
    }
    if (message.iosBundleId !== "") {
      writer.uint32(74).string(message.iosBundleId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invalidReason = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.androidPackageName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.iosBundleId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenProperties {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      invalidReason: isSet(object.invalidReason) ? tokenProperties_InvalidReasonFromJSON(object.invalidReason) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      androidPackageName: isSet(object.androidPackageName) ? globalThis.String(object.androidPackageName) : "",
      iosBundleId: isSet(object.iosBundleId) ? globalThis.String(object.iosBundleId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: TokenProperties): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.invalidReason !== 0) {
      obj.invalidReason = tokenProperties_InvalidReasonToJSON(message.invalidReason);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.androidPackageName !== "") {
      obj.androidPackageName = message.androidPackageName;
    }
    if (message.iosBundleId !== "") {
      obj.iosBundleId = message.iosBundleId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create(base?: DeepPartial<TokenProperties>): TokenProperties {
    return TokenProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenProperties>): TokenProperties {
    const message = createBaseTokenProperties();
    message.valid = object.valid ?? false;
    message.invalidReason = object.invalidReason ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.hostname = object.hostname ?? "";
    message.androidPackageName = object.androidPackageName ?? "";
    message.iosBundleId = object.iosBundleId ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseFraudPreventionAssessment(): FraudPreventionAssessment {
  return {
    transactionRisk: 0,
    stolenInstrumentVerdict: undefined,
    cardTestingVerdict: undefined,
    behavioralTrustVerdict: undefined,
  };
}

export const FraudPreventionAssessment: MessageFns<FraudPreventionAssessment> = {
  encode(message: FraudPreventionAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionRisk !== 0) {
      writer.uint32(13).float(message.transactionRisk);
    }
    if (message.stolenInstrumentVerdict !== undefined) {
      FraudPreventionAssessment_StolenInstrumentVerdict.encode(
        message.stolenInstrumentVerdict,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.cardTestingVerdict !== undefined) {
      FraudPreventionAssessment_CardTestingVerdict.encode(message.cardTestingVerdict, writer.uint32(26).fork()).join();
    }
    if (message.behavioralTrustVerdict !== undefined) {
      FraudPreventionAssessment_BehavioralTrustVerdict.encode(message.behavioralTrustVerdict, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.transactionRisk = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stolenInstrumentVerdict = FraudPreventionAssessment_StolenInstrumentVerdict.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cardTestingVerdict = FraudPreventionAssessment_CardTestingVerdict.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.behavioralTrustVerdict = FraudPreventionAssessment_BehavioralTrustVerdict.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment {
    return {
      transactionRisk: isSet(object.transactionRisk) ? globalThis.Number(object.transactionRisk) : 0,
      stolenInstrumentVerdict: isSet(object.stolenInstrumentVerdict)
        ? FraudPreventionAssessment_StolenInstrumentVerdict.fromJSON(object.stolenInstrumentVerdict)
        : undefined,
      cardTestingVerdict: isSet(object.cardTestingVerdict)
        ? FraudPreventionAssessment_CardTestingVerdict.fromJSON(object.cardTestingVerdict)
        : undefined,
      behavioralTrustVerdict: isSet(object.behavioralTrustVerdict)
        ? FraudPreventionAssessment_BehavioralTrustVerdict.fromJSON(object.behavioralTrustVerdict)
        : undefined,
    };
  },

  toJSON(message: FraudPreventionAssessment): unknown {
    const obj: any = {};
    if (message.transactionRisk !== 0) {
      obj.transactionRisk = message.transactionRisk;
    }
    if (message.stolenInstrumentVerdict !== undefined) {
      obj.stolenInstrumentVerdict = FraudPreventionAssessment_StolenInstrumentVerdict.toJSON(
        message.stolenInstrumentVerdict,
      );
    }
    if (message.cardTestingVerdict !== undefined) {
      obj.cardTestingVerdict = FraudPreventionAssessment_CardTestingVerdict.toJSON(message.cardTestingVerdict);
    }
    if (message.behavioralTrustVerdict !== undefined) {
      obj.behavioralTrustVerdict = FraudPreventionAssessment_BehavioralTrustVerdict.toJSON(
        message.behavioralTrustVerdict,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FraudPreventionAssessment>): FraudPreventionAssessment {
    return FraudPreventionAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FraudPreventionAssessment>): FraudPreventionAssessment {
    const message = createBaseFraudPreventionAssessment();
    message.transactionRisk = object.transactionRisk ?? 0;
    message.stolenInstrumentVerdict =
      (object.stolenInstrumentVerdict !== undefined && object.stolenInstrumentVerdict !== null)
        ? FraudPreventionAssessment_StolenInstrumentVerdict.fromPartial(object.stolenInstrumentVerdict)
        : undefined;
    message.cardTestingVerdict = (object.cardTestingVerdict !== undefined && object.cardTestingVerdict !== null)
      ? FraudPreventionAssessment_CardTestingVerdict.fromPartial(object.cardTestingVerdict)
      : undefined;
    message.behavioralTrustVerdict =
      (object.behavioralTrustVerdict !== undefined && object.behavioralTrustVerdict !== null)
        ? FraudPreventionAssessment_BehavioralTrustVerdict.fromPartial(object.behavioralTrustVerdict)
        : undefined;
    return message;
  },
};

function createBaseFraudPreventionAssessment_StolenInstrumentVerdict(): FraudPreventionAssessment_StolenInstrumentVerdict {
  return { risk: 0 };
}

export const FraudPreventionAssessment_StolenInstrumentVerdict: MessageFns<
  FraudPreventionAssessment_StolenInstrumentVerdict
> = {
  encode(
    message: FraudPreventionAssessment_StolenInstrumentVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.risk !== 0) {
      writer.uint32(13).float(message.risk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_StolenInstrumentVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_StolenInstrumentVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.risk = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_StolenInstrumentVerdict {
    return { risk: isSet(object.risk) ? globalThis.Number(object.risk) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_StolenInstrumentVerdict): unknown {
    const obj: any = {};
    if (message.risk !== 0) {
      obj.risk = message.risk;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_StolenInstrumentVerdict>,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    return FraudPreventionAssessment_StolenInstrumentVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_StolenInstrumentVerdict>,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    const message = createBaseFraudPreventionAssessment_StolenInstrumentVerdict();
    message.risk = object.risk ?? 0;
    return message;
  },
};

function createBaseFraudPreventionAssessment_CardTestingVerdict(): FraudPreventionAssessment_CardTestingVerdict {
  return { risk: 0 };
}

export const FraudPreventionAssessment_CardTestingVerdict: MessageFns<FraudPreventionAssessment_CardTestingVerdict> = {
  encode(
    message: FraudPreventionAssessment_CardTestingVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.risk !== 0) {
      writer.uint32(13).float(message.risk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_CardTestingVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_CardTestingVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.risk = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_CardTestingVerdict {
    return { risk: isSet(object.risk) ? globalThis.Number(object.risk) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_CardTestingVerdict): unknown {
    const obj: any = {};
    if (message.risk !== 0) {
      obj.risk = message.risk;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_CardTestingVerdict>,
  ): FraudPreventionAssessment_CardTestingVerdict {
    return FraudPreventionAssessment_CardTestingVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_CardTestingVerdict>,
  ): FraudPreventionAssessment_CardTestingVerdict {
    const message = createBaseFraudPreventionAssessment_CardTestingVerdict();
    message.risk = object.risk ?? 0;
    return message;
  },
};

function createBaseFraudPreventionAssessment_BehavioralTrustVerdict(): FraudPreventionAssessment_BehavioralTrustVerdict {
  return { trust: 0 };
}

export const FraudPreventionAssessment_BehavioralTrustVerdict: MessageFns<
  FraudPreventionAssessment_BehavioralTrustVerdict
> = {
  encode(
    message: FraudPreventionAssessment_BehavioralTrustVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trust !== 0) {
      writer.uint32(13).float(message.trust);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_BehavioralTrustVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_BehavioralTrustVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.trust = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_BehavioralTrustVerdict {
    return { trust: isSet(object.trust) ? globalThis.Number(object.trust) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_BehavioralTrustVerdict): unknown {
    const obj: any = {};
    if (message.trust !== 0) {
      obj.trust = message.trust;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_BehavioralTrustVerdict>,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    return FraudPreventionAssessment_BehavioralTrustVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_BehavioralTrustVerdict>,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    const message = createBaseFraudPreventionAssessment_BehavioralTrustVerdict();
    message.trust = object.trust ?? 0;
    return message;
  },
};

function createBaseFraudSignals(): FraudSignals {
  return { userSignals: undefined, cardSignals: undefined };
}

export const FraudSignals: MessageFns<FraudSignals> = {
  encode(message: FraudSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userSignals !== undefined) {
      FraudSignals_UserSignals.encode(message.userSignals, writer.uint32(10).fork()).join();
    }
    if (message.cardSignals !== undefined) {
      FraudSignals_CardSignals.encode(message.cardSignals, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userSignals = FraudSignals_UserSignals.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cardSignals = FraudSignals_CardSignals.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudSignals {
    return {
      userSignals: isSet(object.userSignals) ? FraudSignals_UserSignals.fromJSON(object.userSignals) : undefined,
      cardSignals: isSet(object.cardSignals) ? FraudSignals_CardSignals.fromJSON(object.cardSignals) : undefined,
    };
  },

  toJSON(message: FraudSignals): unknown {
    const obj: any = {};
    if (message.userSignals !== undefined) {
      obj.userSignals = FraudSignals_UserSignals.toJSON(message.userSignals);
    }
    if (message.cardSignals !== undefined) {
      obj.cardSignals = FraudSignals_CardSignals.toJSON(message.cardSignals);
    }
    return obj;
  },

  create(base?: DeepPartial<FraudSignals>): FraudSignals {
    return FraudSignals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FraudSignals>): FraudSignals {
    const message = createBaseFraudSignals();
    message.userSignals = (object.userSignals !== undefined && object.userSignals !== null)
      ? FraudSignals_UserSignals.fromPartial(object.userSignals)
      : undefined;
    message.cardSignals = (object.cardSignals !== undefined && object.cardSignals !== null)
      ? FraudSignals_CardSignals.fromPartial(object.cardSignals)
      : undefined;
    return message;
  },
};

function createBaseFraudSignals_UserSignals(): FraudSignals_UserSignals {
  return { activeDaysLowerBound: 0, syntheticRisk: 0 };
}

export const FraudSignals_UserSignals: MessageFns<FraudSignals_UserSignals> = {
  encode(message: FraudSignals_UserSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeDaysLowerBound !== 0) {
      writer.uint32(8).int32(message.activeDaysLowerBound);
    }
    if (message.syntheticRisk !== 0) {
      writer.uint32(21).float(message.syntheticRisk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudSignals_UserSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudSignals_UserSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.activeDaysLowerBound = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.syntheticRisk = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudSignals_UserSignals {
    return {
      activeDaysLowerBound: isSet(object.activeDaysLowerBound) ? globalThis.Number(object.activeDaysLowerBound) : 0,
      syntheticRisk: isSet(object.syntheticRisk) ? globalThis.Number(object.syntheticRisk) : 0,
    };
  },

  toJSON(message: FraudSignals_UserSignals): unknown {
    const obj: any = {};
    if (message.activeDaysLowerBound !== 0) {
      obj.activeDaysLowerBound = Math.round(message.activeDaysLowerBound);
    }
    if (message.syntheticRisk !== 0) {
      obj.syntheticRisk = message.syntheticRisk;
    }
    return obj;
  },

  create(base?: DeepPartial<FraudSignals_UserSignals>): FraudSignals_UserSignals {
    return FraudSignals_UserSignals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FraudSignals_UserSignals>): FraudSignals_UserSignals {
    const message = createBaseFraudSignals_UserSignals();
    message.activeDaysLowerBound = object.activeDaysLowerBound ?? 0;
    message.syntheticRisk = object.syntheticRisk ?? 0;
    return message;
  },
};

function createBaseFraudSignals_CardSignals(): FraudSignals_CardSignals {
  return { cardLabels: [] };
}

export const FraudSignals_CardSignals: MessageFns<FraudSignals_CardSignals> = {
  encode(message: FraudSignals_CardSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.cardLabels) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudSignals_CardSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudSignals_CardSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.cardLabels.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cardLabels.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudSignals_CardSignals {
    return {
      cardLabels: globalThis.Array.isArray(object?.cardLabels)
        ? object.cardLabels.map((e: any) => fraudSignals_CardSignals_CardLabelFromJSON(e))
        : [],
    };
  },

  toJSON(message: FraudSignals_CardSignals): unknown {
    const obj: any = {};
    if (message.cardLabels?.length) {
      obj.cardLabels = message.cardLabels.map((e) => fraudSignals_CardSignals_CardLabelToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FraudSignals_CardSignals>): FraudSignals_CardSignals {
    return FraudSignals_CardSignals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FraudSignals_CardSignals>): FraudSignals_CardSignals {
    const message = createBaseFraudSignals_CardSignals();
    message.cardLabels = object.cardLabels?.map((e) => e) || [];
    return message;
  },
};

function createBaseSmsTollFraudVerdict(): SmsTollFraudVerdict {
  return { risk: 0, reasons: [] };
}

export const SmsTollFraudVerdict: MessageFns<SmsTollFraudVerdict> = {
  encode(message: SmsTollFraudVerdict, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.risk !== 0) {
      writer.uint32(13).float(message.risk);
    }
    writer.uint32(18).fork();
    for (const v of message.reasons) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmsTollFraudVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmsTollFraudVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.risk = reader.float();
          continue;
        case 2:
          if (tag === 16) {
            message.reasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmsTollFraudVerdict {
    return {
      risk: isSet(object.risk) ? globalThis.Number(object.risk) : 0,
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => smsTollFraudVerdict_SmsTollFraudReasonFromJSON(e))
        : [],
    };
  },

  toJSON(message: SmsTollFraudVerdict): unknown {
    const obj: any = {};
    if (message.risk !== 0) {
      obj.risk = message.risk;
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => smsTollFraudVerdict_SmsTollFraudReasonToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SmsTollFraudVerdict>): SmsTollFraudVerdict {
    return SmsTollFraudVerdict.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmsTollFraudVerdict>): SmsTollFraudVerdict {
    const message = createBaseSmsTollFraudVerdict();
    message.risk = object.risk ?? 0;
    message.reasons = object.reasons?.map((e) => e) || [];
    return message;
  },
};

function createBasePhoneFraudAssessment(): PhoneFraudAssessment {
  return { smsTollFraudVerdict: undefined };
}

export const PhoneFraudAssessment: MessageFns<PhoneFraudAssessment> = {
  encode(message: PhoneFraudAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.smsTollFraudVerdict !== undefined) {
      SmsTollFraudVerdict.encode(message.smsTollFraudVerdict, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneFraudAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneFraudAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.smsTollFraudVerdict = SmsTollFraudVerdict.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneFraudAssessment {
    return {
      smsTollFraudVerdict: isSet(object.smsTollFraudVerdict)
        ? SmsTollFraudVerdict.fromJSON(object.smsTollFraudVerdict)
        : undefined,
    };
  },

  toJSON(message: PhoneFraudAssessment): unknown {
    const obj: any = {};
    if (message.smsTollFraudVerdict !== undefined) {
      obj.smsTollFraudVerdict = SmsTollFraudVerdict.toJSON(message.smsTollFraudVerdict);
    }
    return obj;
  },

  create(base?: DeepPartial<PhoneFraudAssessment>): PhoneFraudAssessment {
    return PhoneFraudAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhoneFraudAssessment>): PhoneFraudAssessment {
    const message = createBasePhoneFraudAssessment();
    message.smsTollFraudVerdict = (object.smsTollFraudVerdict !== undefined && object.smsTollFraudVerdict !== null)
      ? SmsTollFraudVerdict.fromPartial(object.smsTollFraudVerdict)
      : undefined;
    return message;
  },
};

function createBaseAccountDefenderAssessment(): AccountDefenderAssessment {
  return { labels: [] };
}

export const AccountDefenderAssessment: MessageFns<AccountDefenderAssessment> = {
  encode(message: AccountDefenderAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.labels) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountDefenderAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDefenderAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.labels.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.labels.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDefenderAssessment {
    return {
      labels: globalThis.Array.isArray(object?.labels)
        ? object.labels.map((e: any) => accountDefenderAssessment_AccountDefenderLabelFromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountDefenderAssessment): unknown {
    const obj: any = {};
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => accountDefenderAssessment_AccountDefenderLabelToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccountDefenderAssessment>): AccountDefenderAssessment {
    return AccountDefenderAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountDefenderAssessment>): AccountDefenderAssessment {
    const message = createBaseAccountDefenderAssessment();
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateKeyRequest(): CreateKeyRequest {
  return { parent: "", key: undefined };
}

export const CreateKeyRequest: MessageFns<CreateKeyRequest> = {
  encode(message: CreateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateKeyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: CreateKeyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateKeyRequest>): CreateKeyRequest {
    return CreateKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateKeyRequest>): CreateKeyRequest {
    const message = createBaseCreateKeyRequest();
    message.parent = object.parent ?? "";
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeysRequest>): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeysRequest>): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListKeysResponse(): ListKeysResponse {
  return { keys: [], nextPageToken: "" };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysResponse {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeysResponse>): ListKeysResponse {
    return ListKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeysResponse>): ListKeysResponse {
    const message = createBaseListKeysResponse();
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseRetrieveLegacySecretKeyRequest(): RetrieveLegacySecretKeyRequest {
  return { key: "" };
}

export const RetrieveLegacySecretKeyRequest: MessageFns<RetrieveLegacySecretKeyRequest> = {
  encode(message: RetrieveLegacySecretKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveLegacySecretKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveLegacySecretKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveLegacySecretKeyRequest {
    return { key: isSet(object.key) ? globalThis.String(object.key) : "" };
  },

  toJSON(message: RetrieveLegacySecretKeyRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveLegacySecretKeyRequest>): RetrieveLegacySecretKeyRequest {
    return RetrieveLegacySecretKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveLegacySecretKeyRequest>): RetrieveLegacySecretKeyRequest {
    const message = createBaseRetrieveLegacySecretKeyRequest();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseGetKeyRequest(): GetKeyRequest {
  return { name: "" };
}

export const GetKeyRequest: MessageFns<GetKeyRequest> = {
  encode(message: GetKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKeyRequest>): GetKeyRequest {
    return GetKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKeyRequest>): GetKeyRequest {
    const message = createBaseGetKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateKeyRequest(): UpdateKeyRequest {
  return { key: undefined, updateMask: undefined };
}

export const UpdateKeyRequest: MessageFns<UpdateKeyRequest> = {
  encode(message: UpdateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateKeyRequest {
    return {
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateKeyRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateKeyRequest>): UpdateKeyRequest {
    return UpdateKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateKeyRequest>): UpdateKeyRequest {
    const message = createBaseUpdateKeyRequest();
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteKeyRequest(): DeleteKeyRequest {
  return { name: "" };
}

export const DeleteKeyRequest: MessageFns<DeleteKeyRequest> = {
  encode(message: DeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteKeyRequest>): DeleteKeyRequest {
    return DeleteKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteKeyRequest>): DeleteKeyRequest {
    const message = createBaseDeleteKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateFirewallPolicyRequest(): CreateFirewallPolicyRequest {
  return { parent: "", firewallPolicy: undefined };
}

export const CreateFirewallPolicyRequest: MessageFns<CreateFirewallPolicyRequest> = {
  encode(message: CreateFirewallPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.firewallPolicy !== undefined) {
      FirewallPolicy.encode(message.firewallPolicy, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFirewallPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFirewallPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.firewallPolicy = FirewallPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFirewallPolicyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      firewallPolicy: isSet(object.firewallPolicy) ? FirewallPolicy.fromJSON(object.firewallPolicy) : undefined,
    };
  },

  toJSON(message: CreateFirewallPolicyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.firewallPolicy !== undefined) {
      obj.firewallPolicy = FirewallPolicy.toJSON(message.firewallPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFirewallPolicyRequest>): CreateFirewallPolicyRequest {
    return CreateFirewallPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFirewallPolicyRequest>): CreateFirewallPolicyRequest {
    const message = createBaseCreateFirewallPolicyRequest();
    message.parent = object.parent ?? "";
    message.firewallPolicy = (object.firewallPolicy !== undefined && object.firewallPolicy !== null)
      ? FirewallPolicy.fromPartial(object.firewallPolicy)
      : undefined;
    return message;
  },
};

function createBaseListFirewallPoliciesRequest(): ListFirewallPoliciesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListFirewallPoliciesRequest: MessageFns<ListFirewallPoliciesRequest> = {
  encode(message: ListFirewallPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFirewallPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFirewallPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFirewallPoliciesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListFirewallPoliciesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFirewallPoliciesRequest>): ListFirewallPoliciesRequest {
    return ListFirewallPoliciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFirewallPoliciesRequest>): ListFirewallPoliciesRequest {
    const message = createBaseListFirewallPoliciesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListFirewallPoliciesResponse(): ListFirewallPoliciesResponse {
  return { firewallPolicies: [], nextPageToken: "" };
}

export const ListFirewallPoliciesResponse: MessageFns<ListFirewallPoliciesResponse> = {
  encode(message: ListFirewallPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.firewallPolicies) {
      FirewallPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFirewallPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFirewallPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firewallPolicies.push(FirewallPolicy.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFirewallPoliciesResponse {
    return {
      firewallPolicies: globalThis.Array.isArray(object?.firewallPolicies)
        ? object.firewallPolicies.map((e: any) => FirewallPolicy.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFirewallPoliciesResponse): unknown {
    const obj: any = {};
    if (message.firewallPolicies?.length) {
      obj.firewallPolicies = message.firewallPolicies.map((e) => FirewallPolicy.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFirewallPoliciesResponse>): ListFirewallPoliciesResponse {
    return ListFirewallPoliciesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFirewallPoliciesResponse>): ListFirewallPoliciesResponse {
    const message = createBaseListFirewallPoliciesResponse();
    message.firewallPolicies = object.firewallPolicies?.map((e) => FirewallPolicy.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetFirewallPolicyRequest(): GetFirewallPolicyRequest {
  return { name: "" };
}

export const GetFirewallPolicyRequest: MessageFns<GetFirewallPolicyRequest> = {
  encode(message: GetFirewallPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFirewallPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFirewallPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFirewallPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFirewallPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFirewallPolicyRequest>): GetFirewallPolicyRequest {
    return GetFirewallPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFirewallPolicyRequest>): GetFirewallPolicyRequest {
    const message = createBaseGetFirewallPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateFirewallPolicyRequest(): UpdateFirewallPolicyRequest {
  return { firewallPolicy: undefined, updateMask: undefined };
}

export const UpdateFirewallPolicyRequest: MessageFns<UpdateFirewallPolicyRequest> = {
  encode(message: UpdateFirewallPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firewallPolicy !== undefined) {
      FirewallPolicy.encode(message.firewallPolicy, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFirewallPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFirewallPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firewallPolicy = FirewallPolicy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFirewallPolicyRequest {
    return {
      firewallPolicy: isSet(object.firewallPolicy) ? FirewallPolicy.fromJSON(object.firewallPolicy) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateFirewallPolicyRequest): unknown {
    const obj: any = {};
    if (message.firewallPolicy !== undefined) {
      obj.firewallPolicy = FirewallPolicy.toJSON(message.firewallPolicy);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFirewallPolicyRequest>): UpdateFirewallPolicyRequest {
    return UpdateFirewallPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFirewallPolicyRequest>): UpdateFirewallPolicyRequest {
    const message = createBaseUpdateFirewallPolicyRequest();
    message.firewallPolicy = (object.firewallPolicy !== undefined && object.firewallPolicy !== null)
      ? FirewallPolicy.fromPartial(object.firewallPolicy)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteFirewallPolicyRequest(): DeleteFirewallPolicyRequest {
  return { name: "" };
}

export const DeleteFirewallPolicyRequest: MessageFns<DeleteFirewallPolicyRequest> = {
  encode(message: DeleteFirewallPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFirewallPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFirewallPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFirewallPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteFirewallPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteFirewallPolicyRequest>): DeleteFirewallPolicyRequest {
    return DeleteFirewallPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteFirewallPolicyRequest>): DeleteFirewallPolicyRequest {
    const message = createBaseDeleteFirewallPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseReorderFirewallPoliciesRequest(): ReorderFirewallPoliciesRequest {
  return { parent: "", names: [] };
}

export const ReorderFirewallPoliciesRequest: MessageFns<ReorderFirewallPoliciesRequest> = {
  encode(message: ReorderFirewallPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReorderFirewallPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReorderFirewallPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReorderFirewallPoliciesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ReorderFirewallPoliciesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<ReorderFirewallPoliciesRequest>): ReorderFirewallPoliciesRequest {
    return ReorderFirewallPoliciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReorderFirewallPoliciesRequest>): ReorderFirewallPoliciesRequest {
    const message = createBaseReorderFirewallPoliciesRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseReorderFirewallPoliciesResponse(): ReorderFirewallPoliciesResponse {
  return {};
}

export const ReorderFirewallPoliciesResponse: MessageFns<ReorderFirewallPoliciesResponse> = {
  encode(_: ReorderFirewallPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReorderFirewallPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReorderFirewallPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReorderFirewallPoliciesResponse {
    return {};
  },

  toJSON(_: ReorderFirewallPoliciesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReorderFirewallPoliciesResponse>): ReorderFirewallPoliciesResponse {
    return ReorderFirewallPoliciesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReorderFirewallPoliciesResponse>): ReorderFirewallPoliciesResponse {
    const message = createBaseReorderFirewallPoliciesResponse();
    return message;
  },
};

function createBaseMigrateKeyRequest(): MigrateKeyRequest {
  return { name: "", skipBillingCheck: false };
}

export const MigrateKeyRequest: MessageFns<MigrateKeyRequest> = {
  encode(message: MigrateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.skipBillingCheck !== false) {
      writer.uint32(16).bool(message.skipBillingCheck);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skipBillingCheck = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrateKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      skipBillingCheck: isSet(object.skipBillingCheck) ? globalThis.Boolean(object.skipBillingCheck) : false,
    };
  },

  toJSON(message: MigrateKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.skipBillingCheck !== false) {
      obj.skipBillingCheck = message.skipBillingCheck;
    }
    return obj;
  },

  create(base?: DeepPartial<MigrateKeyRequest>): MigrateKeyRequest {
    return MigrateKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrateKeyRequest>): MigrateKeyRequest {
    const message = createBaseMigrateKeyRequest();
    message.name = object.name ?? "";
    message.skipBillingCheck = object.skipBillingCheck ?? false;
    return message;
  },
};

function createBaseGetMetricsRequest(): GetMetricsRequest {
  return { name: "" };
}

export const GetMetricsRequest: MessageFns<GetMetricsRequest> = {
  encode(message: GetMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMetricsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    return GetMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricsRequest>): GetMetricsRequest {
    const message = createBaseGetMetricsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseMetrics(): Metrics {
  return { name: "", startTime: undefined, scoreMetrics: [], challengeMetrics: [] };
}

export const Metrics: MessageFns<Metrics> = {
  encode(message: Metrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.scoreMetrics) {
      ScoreMetrics.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.challengeMetrics) {
      ChallengeMetrics.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scoreMetrics.push(ScoreMetrics.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challengeMetrics.push(ChallengeMetrics.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metrics {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      scoreMetrics: globalThis.Array.isArray(object?.scoreMetrics)
        ? object.scoreMetrics.map((e: any) => ScoreMetrics.fromJSON(e))
        : [],
      challengeMetrics: globalThis.Array.isArray(object?.challengeMetrics)
        ? object.challengeMetrics.map((e: any) => ChallengeMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Metrics): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.scoreMetrics?.length) {
      obj.scoreMetrics = message.scoreMetrics.map((e) => ScoreMetrics.toJSON(e));
    }
    if (message.challengeMetrics?.length) {
      obj.challengeMetrics = message.challengeMetrics.map((e) => ChallengeMetrics.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Metrics>): Metrics {
    return Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metrics>): Metrics {
    const message = createBaseMetrics();
    message.name = object.name ?? "";
    message.startTime = object.startTime ?? undefined;
    message.scoreMetrics = object.scoreMetrics?.map((e) => ScoreMetrics.fromPartial(e)) || [];
    message.challengeMetrics = object.challengeMetrics?.map((e) => ChallengeMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRetrieveLegacySecretKeyResponse(): RetrieveLegacySecretKeyResponse {
  return { legacySecretKey: "" };
}

export const RetrieveLegacySecretKeyResponse: MessageFns<RetrieveLegacySecretKeyResponse> = {
  encode(message: RetrieveLegacySecretKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacySecretKey !== "") {
      writer.uint32(10).string(message.legacySecretKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveLegacySecretKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveLegacySecretKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.legacySecretKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveLegacySecretKeyResponse {
    return { legacySecretKey: isSet(object.legacySecretKey) ? globalThis.String(object.legacySecretKey) : "" };
  },

  toJSON(message: RetrieveLegacySecretKeyResponse): unknown {
    const obj: any = {};
    if (message.legacySecretKey !== "") {
      obj.legacySecretKey = message.legacySecretKey;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveLegacySecretKeyResponse>): RetrieveLegacySecretKeyResponse {
    return RetrieveLegacySecretKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveLegacySecretKeyResponse>): RetrieveLegacySecretKeyResponse {
    const message = createBaseRetrieveLegacySecretKeyResponse();
    message.legacySecretKey = object.legacySecretKey ?? "";
    return message;
  },
};

function createBaseKey(): Key {
  return {
    name: "",
    displayName: "",
    webSettings: undefined,
    androidSettings: undefined,
    iosSettings: undefined,
    expressSettings: undefined,
    labels: {},
    createTime: undefined,
    testingOptions: undefined,
    wafSettings: undefined,
  };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.webSettings !== undefined) {
      WebKeySettings.encode(message.webSettings, writer.uint32(26).fork()).join();
    }
    if (message.androidSettings !== undefined) {
      AndroidKeySettings.encode(message.androidSettings, writer.uint32(34).fork()).join();
    }
    if (message.iosSettings !== undefined) {
      IOSKeySettings.encode(message.iosSettings, writer.uint32(42).fork()).join();
    }
    if (message.expressSettings !== undefined) {
      ExpressKeySettings.encode(message.expressSettings, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Key_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.testingOptions !== undefined) {
      TestingOptions.encode(message.testingOptions, writer.uint32(74).fork()).join();
    }
    if (message.wafSettings !== undefined) {
      WafSettings.encode(message.wafSettings, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.webSettings = WebKeySettings.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.androidSettings = AndroidKeySettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.iosSettings = IOSKeySettings.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.expressSettings = ExpressKeySettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Key_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.testingOptions = TestingOptions.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.wafSettings = WafSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      webSettings: isSet(object.webSettings) ? WebKeySettings.fromJSON(object.webSettings) : undefined,
      androidSettings: isSet(object.androidSettings) ? AndroidKeySettings.fromJSON(object.androidSettings) : undefined,
      iosSettings: isSet(object.iosSettings) ? IOSKeySettings.fromJSON(object.iosSettings) : undefined,
      expressSettings: isSet(object.expressSettings) ? ExpressKeySettings.fromJSON(object.expressSettings) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      testingOptions: isSet(object.testingOptions) ? TestingOptions.fromJSON(object.testingOptions) : undefined,
      wafSettings: isSet(object.wafSettings) ? WafSettings.fromJSON(object.wafSettings) : undefined,
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.webSettings !== undefined) {
      obj.webSettings = WebKeySettings.toJSON(message.webSettings);
    }
    if (message.androidSettings !== undefined) {
      obj.androidSettings = AndroidKeySettings.toJSON(message.androidSettings);
    }
    if (message.iosSettings !== undefined) {
      obj.iosSettings = IOSKeySettings.toJSON(message.iosSettings);
    }
    if (message.expressSettings !== undefined) {
      obj.expressSettings = ExpressKeySettings.toJSON(message.expressSettings);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.testingOptions !== undefined) {
      obj.testingOptions = TestingOptions.toJSON(message.testingOptions);
    }
    if (message.wafSettings !== undefined) {
      obj.wafSettings = WafSettings.toJSON(message.wafSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<Key>): Key {
    return Key.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Key>): Key {
    const message = createBaseKey();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.webSettings = (object.webSettings !== undefined && object.webSettings !== null)
      ? WebKeySettings.fromPartial(object.webSettings)
      : undefined;
    message.androidSettings = (object.androidSettings !== undefined && object.androidSettings !== null)
      ? AndroidKeySettings.fromPartial(object.androidSettings)
      : undefined;
    message.iosSettings = (object.iosSettings !== undefined && object.iosSettings !== null)
      ? IOSKeySettings.fromPartial(object.iosSettings)
      : undefined;
    message.expressSettings = (object.expressSettings !== undefined && object.expressSettings !== null)
      ? ExpressKeySettings.fromPartial(object.expressSettings)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.testingOptions = (object.testingOptions !== undefined && object.testingOptions !== null)
      ? TestingOptions.fromPartial(object.testingOptions)
      : undefined;
    message.wafSettings = (object.wafSettings !== undefined && object.wafSettings !== null)
      ? WafSettings.fromPartial(object.wafSettings)
      : undefined;
    return message;
  },
};

function createBaseKey_LabelsEntry(): Key_LabelsEntry {
  return { key: "", value: "" };
}

export const Key_LabelsEntry: MessageFns<Key_LabelsEntry> = {
  encode(message: Key_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Key_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Key_LabelsEntry>): Key_LabelsEntry {
    return Key_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Key_LabelsEntry>): Key_LabelsEntry {
    const message = createBaseKey_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTestingOptions(): TestingOptions {
  return { testingScore: 0, testingChallenge: 0 };
}

export const TestingOptions: MessageFns<TestingOptions> = {
  encode(message: TestingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testingScore !== 0) {
      writer.uint32(13).float(message.testingScore);
    }
    if (message.testingChallenge !== 0) {
      writer.uint32(16).int32(message.testingChallenge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.testingScore = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.testingChallenge = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestingOptions {
    return {
      testingScore: isSet(object.testingScore) ? globalThis.Number(object.testingScore) : 0,
      testingChallenge: isSet(object.testingChallenge)
        ? testingOptions_TestingChallengeFromJSON(object.testingChallenge)
        : 0,
    };
  },

  toJSON(message: TestingOptions): unknown {
    const obj: any = {};
    if (message.testingScore !== 0) {
      obj.testingScore = message.testingScore;
    }
    if (message.testingChallenge !== 0) {
      obj.testingChallenge = testingOptions_TestingChallengeToJSON(message.testingChallenge);
    }
    return obj;
  },

  create(base?: DeepPartial<TestingOptions>): TestingOptions {
    return TestingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestingOptions>): TestingOptions {
    const message = createBaseTestingOptions();
    message.testingScore = object.testingScore ?? 0;
    message.testingChallenge = object.testingChallenge ?? 0;
    return message;
  },
};

function createBaseWebKeySettings(): WebKeySettings {
  return {
    allowAllDomains: false,
    allowedDomains: [],
    allowAmpTraffic: false,
    integrationType: 0,
    challengeSecurityPreference: 0,
  };
}

export const WebKeySettings: MessageFns<WebKeySettings> = {
  encode(message: WebKeySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAllDomains !== false) {
      writer.uint32(24).bool(message.allowAllDomains);
    }
    for (const v of message.allowedDomains) {
      writer.uint32(10).string(v!);
    }
    if (message.allowAmpTraffic !== false) {
      writer.uint32(16).bool(message.allowAmpTraffic);
    }
    if (message.integrationType !== 0) {
      writer.uint32(32).int32(message.integrationType);
    }
    if (message.challengeSecurityPreference !== 0) {
      writer.uint32(40).int32(message.challengeSecurityPreference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebKeySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebKeySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowAllDomains = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedDomains.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowAmpTraffic = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.integrationType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.challengeSecurityPreference = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebKeySettings {
    return {
      allowAllDomains: isSet(object.allowAllDomains) ? globalThis.Boolean(object.allowAllDomains) : false,
      allowedDomains: globalThis.Array.isArray(object?.allowedDomains)
        ? object.allowedDomains.map((e: any) => globalThis.String(e))
        : [],
      allowAmpTraffic: isSet(object.allowAmpTraffic) ? globalThis.Boolean(object.allowAmpTraffic) : false,
      integrationType: isSet(object.integrationType)
        ? webKeySettings_IntegrationTypeFromJSON(object.integrationType)
        : 0,
      challengeSecurityPreference: isSet(object.challengeSecurityPreference)
        ? webKeySettings_ChallengeSecurityPreferenceFromJSON(object.challengeSecurityPreference)
        : 0,
    };
  },

  toJSON(message: WebKeySettings): unknown {
    const obj: any = {};
    if (message.allowAllDomains !== false) {
      obj.allowAllDomains = message.allowAllDomains;
    }
    if (message.allowedDomains?.length) {
      obj.allowedDomains = message.allowedDomains;
    }
    if (message.allowAmpTraffic !== false) {
      obj.allowAmpTraffic = message.allowAmpTraffic;
    }
    if (message.integrationType !== 0) {
      obj.integrationType = webKeySettings_IntegrationTypeToJSON(message.integrationType);
    }
    if (message.challengeSecurityPreference !== 0) {
      obj.challengeSecurityPreference = webKeySettings_ChallengeSecurityPreferenceToJSON(
        message.challengeSecurityPreference,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<WebKeySettings>): WebKeySettings {
    return WebKeySettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebKeySettings>): WebKeySettings {
    const message = createBaseWebKeySettings();
    message.allowAllDomains = object.allowAllDomains ?? false;
    message.allowedDomains = object.allowedDomains?.map((e) => e) || [];
    message.allowAmpTraffic = object.allowAmpTraffic ?? false;
    message.integrationType = object.integrationType ?? 0;
    message.challengeSecurityPreference = object.challengeSecurityPreference ?? 0;
    return message;
  },
};

function createBaseAndroidKeySettings(): AndroidKeySettings {
  return { allowAllPackageNames: false, allowedPackageNames: [], supportNonGoogleAppStoreDistribution: false };
}

export const AndroidKeySettings: MessageFns<AndroidKeySettings> = {
  encode(message: AndroidKeySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAllPackageNames !== false) {
      writer.uint32(16).bool(message.allowAllPackageNames);
    }
    for (const v of message.allowedPackageNames) {
      writer.uint32(10).string(v!);
    }
    if (message.supportNonGoogleAppStoreDistribution !== false) {
      writer.uint32(24).bool(message.supportNonGoogleAppStoreDistribution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidKeySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidKeySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowAllPackageNames = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedPackageNames.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.supportNonGoogleAppStoreDistribution = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidKeySettings {
    return {
      allowAllPackageNames: isSet(object.allowAllPackageNames)
        ? globalThis.Boolean(object.allowAllPackageNames)
        : false,
      allowedPackageNames: globalThis.Array.isArray(object?.allowedPackageNames)
        ? object.allowedPackageNames.map((e: any) => globalThis.String(e))
        : [],
      supportNonGoogleAppStoreDistribution: isSet(object.supportNonGoogleAppStoreDistribution)
        ? globalThis.Boolean(object.supportNonGoogleAppStoreDistribution)
        : false,
    };
  },

  toJSON(message: AndroidKeySettings): unknown {
    const obj: any = {};
    if (message.allowAllPackageNames !== false) {
      obj.allowAllPackageNames = message.allowAllPackageNames;
    }
    if (message.allowedPackageNames?.length) {
      obj.allowedPackageNames = message.allowedPackageNames;
    }
    if (message.supportNonGoogleAppStoreDistribution !== false) {
      obj.supportNonGoogleAppStoreDistribution = message.supportNonGoogleAppStoreDistribution;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidKeySettings>): AndroidKeySettings {
    return AndroidKeySettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidKeySettings>): AndroidKeySettings {
    const message = createBaseAndroidKeySettings();
    message.allowAllPackageNames = object.allowAllPackageNames ?? false;
    message.allowedPackageNames = object.allowedPackageNames?.map((e) => e) || [];
    message.supportNonGoogleAppStoreDistribution = object.supportNonGoogleAppStoreDistribution ?? false;
    return message;
  },
};

function createBaseIOSKeySettings(): IOSKeySettings {
  return { allowAllBundleIds: false, allowedBundleIds: [], appleDeveloperId: undefined };
}

export const IOSKeySettings: MessageFns<IOSKeySettings> = {
  encode(message: IOSKeySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAllBundleIds !== false) {
      writer.uint32(16).bool(message.allowAllBundleIds);
    }
    for (const v of message.allowedBundleIds) {
      writer.uint32(10).string(v!);
    }
    if (message.appleDeveloperId !== undefined) {
      AppleDeveloperId.encode(message.appleDeveloperId, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IOSKeySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIOSKeySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowAllBundleIds = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedBundleIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.appleDeveloperId = AppleDeveloperId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IOSKeySettings {
    return {
      allowAllBundleIds: isSet(object.allowAllBundleIds) ? globalThis.Boolean(object.allowAllBundleIds) : false,
      allowedBundleIds: globalThis.Array.isArray(object?.allowedBundleIds)
        ? object.allowedBundleIds.map((e: any) => globalThis.String(e))
        : [],
      appleDeveloperId: isSet(object.appleDeveloperId) ? AppleDeveloperId.fromJSON(object.appleDeveloperId) : undefined,
    };
  },

  toJSON(message: IOSKeySettings): unknown {
    const obj: any = {};
    if (message.allowAllBundleIds !== false) {
      obj.allowAllBundleIds = message.allowAllBundleIds;
    }
    if (message.allowedBundleIds?.length) {
      obj.allowedBundleIds = message.allowedBundleIds;
    }
    if (message.appleDeveloperId !== undefined) {
      obj.appleDeveloperId = AppleDeveloperId.toJSON(message.appleDeveloperId);
    }
    return obj;
  },

  create(base?: DeepPartial<IOSKeySettings>): IOSKeySettings {
    return IOSKeySettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IOSKeySettings>): IOSKeySettings {
    const message = createBaseIOSKeySettings();
    message.allowAllBundleIds = object.allowAllBundleIds ?? false;
    message.allowedBundleIds = object.allowedBundleIds?.map((e) => e) || [];
    message.appleDeveloperId = (object.appleDeveloperId !== undefined && object.appleDeveloperId !== null)
      ? AppleDeveloperId.fromPartial(object.appleDeveloperId)
      : undefined;
    return message;
  },
};

function createBaseExpressKeySettings(): ExpressKeySettings {
  return {};
}

export const ExpressKeySettings: MessageFns<ExpressKeySettings> = {
  encode(_: ExpressKeySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpressKeySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpressKeySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExpressKeySettings {
    return {};
  },

  toJSON(_: ExpressKeySettings): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExpressKeySettings>): ExpressKeySettings {
    return ExpressKeySettings.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExpressKeySettings>): ExpressKeySettings {
    const message = createBaseExpressKeySettings();
    return message;
  },
};

function createBaseAppleDeveloperId(): AppleDeveloperId {
  return { privateKey: "", keyId: "", teamId: "" };
}

export const AppleDeveloperId: MessageFns<AppleDeveloperId> = {
  encode(message: AppleDeveloperId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateKey !== "") {
      writer.uint32(10).string(message.privateKey);
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    if (message.teamId !== "") {
      writer.uint32(26).string(message.teamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppleDeveloperId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppleDeveloperId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppleDeveloperId {
    return {
      privateKey: isSet(object.privateKey) ? globalThis.String(object.privateKey) : "",
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
    };
  },

  toJSON(message: AppleDeveloperId): unknown {
    const obj: any = {};
    if (message.privateKey !== "") {
      obj.privateKey = message.privateKey;
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    return obj;
  },

  create(base?: DeepPartial<AppleDeveloperId>): AppleDeveloperId {
    return AppleDeveloperId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppleDeveloperId>): AppleDeveloperId {
    const message = createBaseAppleDeveloperId();
    message.privateKey = object.privateKey ?? "";
    message.keyId = object.keyId ?? "";
    message.teamId = object.teamId ?? "";
    return message;
  },
};

function createBaseScoreDistribution(): ScoreDistribution {
  return { scoreBuckets: {} };
}

export const ScoreDistribution: MessageFns<ScoreDistribution> = {
  encode(message: ScoreDistribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.scoreBuckets).forEach(([key, value]) => {
      ScoreDistribution_ScoreBucketsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoreDistribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ScoreDistribution_ScoreBucketsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.scoreBuckets[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreDistribution {
    return {
      scoreBuckets: isObject(object.scoreBuckets)
        ? Object.entries(object.scoreBuckets).reduce<{ [key: number]: Long }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ScoreDistribution): unknown {
    const obj: any = {};
    if (message.scoreBuckets) {
      const entries = Object.entries(message.scoreBuckets);
      if (entries.length > 0) {
        obj.scoreBuckets = {};
        entries.forEach(([k, v]) => {
          obj.scoreBuckets[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ScoreDistribution>): ScoreDistribution {
    return ScoreDistribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScoreDistribution>): ScoreDistribution {
    const message = createBaseScoreDistribution();
    message.scoreBuckets = Object.entries(object.scoreBuckets ?? {}).reduce<{ [key: number]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseScoreDistribution_ScoreBucketsEntry(): ScoreDistribution_ScoreBucketsEntry {
  return { key: 0, value: Long.ZERO };
}

export const ScoreDistribution_ScoreBucketsEntry: MessageFns<ScoreDistribution_ScoreBucketsEntry> = {
  encode(message: ScoreDistribution_ScoreBucketsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoreDistribution_ScoreBucketsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreDistribution_ScoreBucketsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreDistribution_ScoreBucketsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: ScoreDistribution_ScoreBucketsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ScoreDistribution_ScoreBucketsEntry>): ScoreDistribution_ScoreBucketsEntry {
    return ScoreDistribution_ScoreBucketsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScoreDistribution_ScoreBucketsEntry>): ScoreDistribution_ScoreBucketsEntry {
    const message = createBaseScoreDistribution_ScoreBucketsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseScoreMetrics(): ScoreMetrics {
  return { overallMetrics: undefined, actionMetrics: {} };
}

export const ScoreMetrics: MessageFns<ScoreMetrics> = {
  encode(message: ScoreMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallMetrics !== undefined) {
      ScoreDistribution.encode(message.overallMetrics, writer.uint32(10).fork()).join();
    }
    Object.entries(message.actionMetrics).forEach(([key, value]) => {
      ScoreMetrics_ActionMetricsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoreMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.overallMetrics = ScoreDistribution.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ScoreMetrics_ActionMetricsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.actionMetrics[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreMetrics {
    return {
      overallMetrics: isSet(object.overallMetrics) ? ScoreDistribution.fromJSON(object.overallMetrics) : undefined,
      actionMetrics: isObject(object.actionMetrics)
        ? Object.entries(object.actionMetrics).reduce<{ [key: string]: ScoreDistribution }>((acc, [key, value]) => {
          acc[key] = ScoreDistribution.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ScoreMetrics): unknown {
    const obj: any = {};
    if (message.overallMetrics !== undefined) {
      obj.overallMetrics = ScoreDistribution.toJSON(message.overallMetrics);
    }
    if (message.actionMetrics) {
      const entries = Object.entries(message.actionMetrics);
      if (entries.length > 0) {
        obj.actionMetrics = {};
        entries.forEach(([k, v]) => {
          obj.actionMetrics[k] = ScoreDistribution.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ScoreMetrics>): ScoreMetrics {
    return ScoreMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScoreMetrics>): ScoreMetrics {
    const message = createBaseScoreMetrics();
    message.overallMetrics = (object.overallMetrics !== undefined && object.overallMetrics !== null)
      ? ScoreDistribution.fromPartial(object.overallMetrics)
      : undefined;
    message.actionMetrics = Object.entries(object.actionMetrics ?? {}).reduce<{ [key: string]: ScoreDistribution }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScoreDistribution.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseScoreMetrics_ActionMetricsEntry(): ScoreMetrics_ActionMetricsEntry {
  return { key: "", value: undefined };
}

export const ScoreMetrics_ActionMetricsEntry: MessageFns<ScoreMetrics_ActionMetricsEntry> = {
  encode(message: ScoreMetrics_ActionMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScoreDistribution.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoreMetrics_ActionMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreMetrics_ActionMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ScoreDistribution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreMetrics_ActionMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScoreDistribution.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ScoreMetrics_ActionMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScoreDistribution.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ScoreMetrics_ActionMetricsEntry>): ScoreMetrics_ActionMetricsEntry {
    return ScoreMetrics_ActionMetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScoreMetrics_ActionMetricsEntry>): ScoreMetrics_ActionMetricsEntry {
    const message = createBaseScoreMetrics_ActionMetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScoreDistribution.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseChallengeMetrics(): ChallengeMetrics {
  return { pageloadCount: Long.ZERO, nocaptchaCount: Long.ZERO, failedCount: Long.ZERO, passedCount: Long.ZERO };
}

export const ChallengeMetrics: MessageFns<ChallengeMetrics> = {
  encode(message: ChallengeMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.pageloadCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.pageloadCount.toString());
    }
    if (!message.nocaptchaCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.nocaptchaCount.toString());
    }
    if (!message.failedCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.failedCount.toString());
    }
    if (!message.passedCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.passedCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChallengeMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageloadCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nocaptchaCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.passedCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeMetrics {
    return {
      pageloadCount: isSet(object.pageloadCount) ? Long.fromValue(object.pageloadCount) : Long.ZERO,
      nocaptchaCount: isSet(object.nocaptchaCount) ? Long.fromValue(object.nocaptchaCount) : Long.ZERO,
      failedCount: isSet(object.failedCount) ? Long.fromValue(object.failedCount) : Long.ZERO,
      passedCount: isSet(object.passedCount) ? Long.fromValue(object.passedCount) : Long.ZERO,
    };
  },

  toJSON(message: ChallengeMetrics): unknown {
    const obj: any = {};
    if (!message.pageloadCount.equals(Long.ZERO)) {
      obj.pageloadCount = (message.pageloadCount || Long.ZERO).toString();
    }
    if (!message.nocaptchaCount.equals(Long.ZERO)) {
      obj.nocaptchaCount = (message.nocaptchaCount || Long.ZERO).toString();
    }
    if (!message.failedCount.equals(Long.ZERO)) {
      obj.failedCount = (message.failedCount || Long.ZERO).toString();
    }
    if (!message.passedCount.equals(Long.ZERO)) {
      obj.passedCount = (message.passedCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ChallengeMetrics>): ChallengeMetrics {
    return ChallengeMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChallengeMetrics>): ChallengeMetrics {
    const message = createBaseChallengeMetrics();
    message.pageloadCount = (object.pageloadCount !== undefined && object.pageloadCount !== null)
      ? Long.fromValue(object.pageloadCount)
      : Long.ZERO;
    message.nocaptchaCount = (object.nocaptchaCount !== undefined && object.nocaptchaCount !== null)
      ? Long.fromValue(object.nocaptchaCount)
      : Long.ZERO;
    message.failedCount = (object.failedCount !== undefined && object.failedCount !== null)
      ? Long.fromValue(object.failedCount)
      : Long.ZERO;
    message.passedCount = (object.passedCount !== undefined && object.passedCount !== null)
      ? Long.fromValue(object.passedCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseFirewallPolicyAssessment(): FirewallPolicyAssessment {
  return { error: undefined, firewallPolicy: undefined };
}

export const FirewallPolicyAssessment: MessageFns<FirewallPolicyAssessment> = {
  encode(message: FirewallPolicyAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.firewallPolicy !== undefined) {
      FirewallPolicy.encode(message.firewallPolicy, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallPolicyAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallPolicyAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.firewallPolicy = FirewallPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallPolicyAssessment {
    return {
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      firewallPolicy: isSet(object.firewallPolicy) ? FirewallPolicy.fromJSON(object.firewallPolicy) : undefined,
    };
  },

  toJSON(message: FirewallPolicyAssessment): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.firewallPolicy !== undefined) {
      obj.firewallPolicy = FirewallPolicy.toJSON(message.firewallPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallPolicyAssessment>): FirewallPolicyAssessment {
    return FirewallPolicyAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallPolicyAssessment>): FirewallPolicyAssessment {
    const message = createBaseFirewallPolicyAssessment();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.firewallPolicy = (object.firewallPolicy !== undefined && object.firewallPolicy !== null)
      ? FirewallPolicy.fromPartial(object.firewallPolicy)
      : undefined;
    return message;
  },
};

function createBaseFirewallAction(): FirewallAction {
  return {
    allow: undefined,
    block: undefined,
    includeRecaptchaScript: undefined,
    redirect: undefined,
    substitute: undefined,
    setHeader: undefined,
  };
}

export const FirewallAction: MessageFns<FirewallAction> = {
  encode(message: FirewallAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allow !== undefined) {
      FirewallAction_AllowAction.encode(message.allow, writer.uint32(10).fork()).join();
    }
    if (message.block !== undefined) {
      FirewallAction_BlockAction.encode(message.block, writer.uint32(18).fork()).join();
    }
    if (message.includeRecaptchaScript !== undefined) {
      FirewallAction_IncludeRecaptchaScriptAction.encode(message.includeRecaptchaScript, writer.uint32(50).fork())
        .join();
    }
    if (message.redirect !== undefined) {
      FirewallAction_RedirectAction.encode(message.redirect, writer.uint32(42).fork()).join();
    }
    if (message.substitute !== undefined) {
      FirewallAction_SubstituteAction.encode(message.substitute, writer.uint32(26).fork()).join();
    }
    if (message.setHeader !== undefined) {
      FirewallAction_SetHeaderAction.encode(message.setHeader, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allow = FirewallAction_AllowAction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.block = FirewallAction_BlockAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.includeRecaptchaScript = FirewallAction_IncludeRecaptchaScriptAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.redirect = FirewallAction_RedirectAction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.substitute = FirewallAction_SubstituteAction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.setHeader = FirewallAction_SetHeaderAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallAction {
    return {
      allow: isSet(object.allow) ? FirewallAction_AllowAction.fromJSON(object.allow) : undefined,
      block: isSet(object.block) ? FirewallAction_BlockAction.fromJSON(object.block) : undefined,
      includeRecaptchaScript: isSet(object.includeRecaptchaScript)
        ? FirewallAction_IncludeRecaptchaScriptAction.fromJSON(object.includeRecaptchaScript)
        : undefined,
      redirect: isSet(object.redirect) ? FirewallAction_RedirectAction.fromJSON(object.redirect) : undefined,
      substitute: isSet(object.substitute) ? FirewallAction_SubstituteAction.fromJSON(object.substitute) : undefined,
      setHeader: isSet(object.setHeader) ? FirewallAction_SetHeaderAction.fromJSON(object.setHeader) : undefined,
    };
  },

  toJSON(message: FirewallAction): unknown {
    const obj: any = {};
    if (message.allow !== undefined) {
      obj.allow = FirewallAction_AllowAction.toJSON(message.allow);
    }
    if (message.block !== undefined) {
      obj.block = FirewallAction_BlockAction.toJSON(message.block);
    }
    if (message.includeRecaptchaScript !== undefined) {
      obj.includeRecaptchaScript = FirewallAction_IncludeRecaptchaScriptAction.toJSON(message.includeRecaptchaScript);
    }
    if (message.redirect !== undefined) {
      obj.redirect = FirewallAction_RedirectAction.toJSON(message.redirect);
    }
    if (message.substitute !== undefined) {
      obj.substitute = FirewallAction_SubstituteAction.toJSON(message.substitute);
    }
    if (message.setHeader !== undefined) {
      obj.setHeader = FirewallAction_SetHeaderAction.toJSON(message.setHeader);
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallAction>): FirewallAction {
    return FirewallAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallAction>): FirewallAction {
    const message = createBaseFirewallAction();
    message.allow = (object.allow !== undefined && object.allow !== null)
      ? FirewallAction_AllowAction.fromPartial(object.allow)
      : undefined;
    message.block = (object.block !== undefined && object.block !== null)
      ? FirewallAction_BlockAction.fromPartial(object.block)
      : undefined;
    message.includeRecaptchaScript =
      (object.includeRecaptchaScript !== undefined && object.includeRecaptchaScript !== null)
        ? FirewallAction_IncludeRecaptchaScriptAction.fromPartial(object.includeRecaptchaScript)
        : undefined;
    message.redirect = (object.redirect !== undefined && object.redirect !== null)
      ? FirewallAction_RedirectAction.fromPartial(object.redirect)
      : undefined;
    message.substitute = (object.substitute !== undefined && object.substitute !== null)
      ? FirewallAction_SubstituteAction.fromPartial(object.substitute)
      : undefined;
    message.setHeader = (object.setHeader !== undefined && object.setHeader !== null)
      ? FirewallAction_SetHeaderAction.fromPartial(object.setHeader)
      : undefined;
    return message;
  },
};

function createBaseFirewallAction_AllowAction(): FirewallAction_AllowAction {
  return {};
}

export const FirewallAction_AllowAction: MessageFns<FirewallAction_AllowAction> = {
  encode(_: FirewallAction_AllowAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_AllowAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_AllowAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FirewallAction_AllowAction {
    return {};
  },

  toJSON(_: FirewallAction_AllowAction): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_AllowAction>): FirewallAction_AllowAction {
    return FirewallAction_AllowAction.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FirewallAction_AllowAction>): FirewallAction_AllowAction {
    const message = createBaseFirewallAction_AllowAction();
    return message;
  },
};

function createBaseFirewallAction_BlockAction(): FirewallAction_BlockAction {
  return {};
}

export const FirewallAction_BlockAction: MessageFns<FirewallAction_BlockAction> = {
  encode(_: FirewallAction_BlockAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_BlockAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_BlockAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FirewallAction_BlockAction {
    return {};
  },

  toJSON(_: FirewallAction_BlockAction): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_BlockAction>): FirewallAction_BlockAction {
    return FirewallAction_BlockAction.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FirewallAction_BlockAction>): FirewallAction_BlockAction {
    const message = createBaseFirewallAction_BlockAction();
    return message;
  },
};

function createBaseFirewallAction_IncludeRecaptchaScriptAction(): FirewallAction_IncludeRecaptchaScriptAction {
  return {};
}

export const FirewallAction_IncludeRecaptchaScriptAction: MessageFns<FirewallAction_IncludeRecaptchaScriptAction> = {
  encode(_: FirewallAction_IncludeRecaptchaScriptAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_IncludeRecaptchaScriptAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_IncludeRecaptchaScriptAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FirewallAction_IncludeRecaptchaScriptAction {
    return {};
  },

  toJSON(_: FirewallAction_IncludeRecaptchaScriptAction): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_IncludeRecaptchaScriptAction>): FirewallAction_IncludeRecaptchaScriptAction {
    return FirewallAction_IncludeRecaptchaScriptAction.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<FirewallAction_IncludeRecaptchaScriptAction>,
  ): FirewallAction_IncludeRecaptchaScriptAction {
    const message = createBaseFirewallAction_IncludeRecaptchaScriptAction();
    return message;
  },
};

function createBaseFirewallAction_RedirectAction(): FirewallAction_RedirectAction {
  return {};
}

export const FirewallAction_RedirectAction: MessageFns<FirewallAction_RedirectAction> = {
  encode(_: FirewallAction_RedirectAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_RedirectAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_RedirectAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FirewallAction_RedirectAction {
    return {};
  },

  toJSON(_: FirewallAction_RedirectAction): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_RedirectAction>): FirewallAction_RedirectAction {
    return FirewallAction_RedirectAction.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FirewallAction_RedirectAction>): FirewallAction_RedirectAction {
    const message = createBaseFirewallAction_RedirectAction();
    return message;
  },
};

function createBaseFirewallAction_SubstituteAction(): FirewallAction_SubstituteAction {
  return { path: "" };
}

export const FirewallAction_SubstituteAction: MessageFns<FirewallAction_SubstituteAction> = {
  encode(message: FirewallAction_SubstituteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_SubstituteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_SubstituteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallAction_SubstituteAction {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: FirewallAction_SubstituteAction): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_SubstituteAction>): FirewallAction_SubstituteAction {
    return FirewallAction_SubstituteAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallAction_SubstituteAction>): FirewallAction_SubstituteAction {
    const message = createBaseFirewallAction_SubstituteAction();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseFirewallAction_SetHeaderAction(): FirewallAction_SetHeaderAction {
  return { key: "", value: "" };
}

export const FirewallAction_SetHeaderAction: MessageFns<FirewallAction_SetHeaderAction> = {
  encode(message: FirewallAction_SetHeaderAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallAction_SetHeaderAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallAction_SetHeaderAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallAction_SetHeaderAction {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FirewallAction_SetHeaderAction): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallAction_SetHeaderAction>): FirewallAction_SetHeaderAction {
    return FirewallAction_SetHeaderAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallAction_SetHeaderAction>): FirewallAction_SetHeaderAction {
    const message = createBaseFirewallAction_SetHeaderAction();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFirewallPolicy(): FirewallPolicy {
  return { name: "", description: "", path: "", condition: "", actions: [] };
}

export const FirewallPolicy: MessageFns<FirewallPolicy> = {
  encode(message: FirewallPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.condition !== "") {
      writer.uint32(42).string(message.condition);
    }
    for (const v of message.actions) {
      FirewallAction.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.actions.push(FirewallAction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => FirewallAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FirewallPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => FirewallAction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallPolicy>): FirewallPolicy {
    return FirewallPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallPolicy>): FirewallPolicy {
    const message = createBaseFirewallPolicy();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.path = object.path ?? "";
    message.condition = object.condition ?? "";
    message.actions = object.actions?.map((e) => FirewallAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRelatedAccountGroupMembershipsRequest(): ListRelatedAccountGroupMembershipsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRelatedAccountGroupMembershipsRequest: MessageFns<ListRelatedAccountGroupMembershipsRequest> = {
  encode(message: ListRelatedAccountGroupMembershipsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRelatedAccountGroupMembershipsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedAccountGroupMembershipsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedAccountGroupMembershipsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRelatedAccountGroupMembershipsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRelatedAccountGroupMembershipsRequest>): ListRelatedAccountGroupMembershipsRequest {
    return ListRelatedAccountGroupMembershipsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListRelatedAccountGroupMembershipsRequest>,
  ): ListRelatedAccountGroupMembershipsRequest {
    const message = createBaseListRelatedAccountGroupMembershipsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRelatedAccountGroupMembershipsResponse(): ListRelatedAccountGroupMembershipsResponse {
  return { relatedAccountGroupMemberships: [], nextPageToken: "" };
}

export const ListRelatedAccountGroupMembershipsResponse: MessageFns<ListRelatedAccountGroupMembershipsResponse> = {
  encode(message: ListRelatedAccountGroupMembershipsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.relatedAccountGroupMemberships) {
      RelatedAccountGroupMembership.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRelatedAccountGroupMembershipsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedAccountGroupMembershipsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relatedAccountGroupMemberships.push(RelatedAccountGroupMembership.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedAccountGroupMembershipsResponse {
    return {
      relatedAccountGroupMemberships: globalThis.Array.isArray(object?.relatedAccountGroupMemberships)
        ? object.relatedAccountGroupMemberships.map((e: any) => RelatedAccountGroupMembership.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRelatedAccountGroupMembershipsResponse): unknown {
    const obj: any = {};
    if (message.relatedAccountGroupMemberships?.length) {
      obj.relatedAccountGroupMemberships = message.relatedAccountGroupMemberships.map((e) =>
        RelatedAccountGroupMembership.toJSON(e)
      );
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRelatedAccountGroupMembershipsResponse>): ListRelatedAccountGroupMembershipsResponse {
    return ListRelatedAccountGroupMembershipsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListRelatedAccountGroupMembershipsResponse>,
  ): ListRelatedAccountGroupMembershipsResponse {
    const message = createBaseListRelatedAccountGroupMembershipsResponse();
    message.relatedAccountGroupMemberships =
      object.relatedAccountGroupMemberships?.map((e) => RelatedAccountGroupMembership.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListRelatedAccountGroupsRequest(): ListRelatedAccountGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRelatedAccountGroupsRequest: MessageFns<ListRelatedAccountGroupsRequest> = {
  encode(message: ListRelatedAccountGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRelatedAccountGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedAccountGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedAccountGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRelatedAccountGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRelatedAccountGroupsRequest>): ListRelatedAccountGroupsRequest {
    return ListRelatedAccountGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRelatedAccountGroupsRequest>): ListRelatedAccountGroupsRequest {
    const message = createBaseListRelatedAccountGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRelatedAccountGroupsResponse(): ListRelatedAccountGroupsResponse {
  return { relatedAccountGroups: [], nextPageToken: "" };
}

export const ListRelatedAccountGroupsResponse: MessageFns<ListRelatedAccountGroupsResponse> = {
  encode(message: ListRelatedAccountGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.relatedAccountGroups) {
      RelatedAccountGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRelatedAccountGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedAccountGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relatedAccountGroups.push(RelatedAccountGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedAccountGroupsResponse {
    return {
      relatedAccountGroups: globalThis.Array.isArray(object?.relatedAccountGroups)
        ? object.relatedAccountGroups.map((e: any) => RelatedAccountGroup.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRelatedAccountGroupsResponse): unknown {
    const obj: any = {};
    if (message.relatedAccountGroups?.length) {
      obj.relatedAccountGroups = message.relatedAccountGroups.map((e) => RelatedAccountGroup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRelatedAccountGroupsResponse>): ListRelatedAccountGroupsResponse {
    return ListRelatedAccountGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRelatedAccountGroupsResponse>): ListRelatedAccountGroupsResponse {
    const message = createBaseListRelatedAccountGroupsResponse();
    message.relatedAccountGroups = object.relatedAccountGroups?.map((e) => RelatedAccountGroup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchRelatedAccountGroupMembershipsRequest(): SearchRelatedAccountGroupMembershipsRequest {
  return { project: "", accountId: "", hashedAccountId: Buffer.alloc(0), pageSize: 0, pageToken: "" };
}

export const SearchRelatedAccountGroupMembershipsRequest: MessageFns<SearchRelatedAccountGroupMembershipsRequest> = {
  encode(
    message: SearchRelatedAccountGroupMembershipsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.accountId !== "") {
      writer.uint32(42).string(message.accountId);
    }
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(18).bytes(message.hashedAccountId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRelatedAccountGroupMembershipsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRelatedAccountGroupMembershipsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRelatedAccountGroupMembershipsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchRelatedAccountGroupMembershipsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRelatedAccountGroupMembershipsRequest>): SearchRelatedAccountGroupMembershipsRequest {
    return SearchRelatedAccountGroupMembershipsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRelatedAccountGroupMembershipsRequest>,
  ): SearchRelatedAccountGroupMembershipsRequest {
    const message = createBaseSearchRelatedAccountGroupMembershipsRequest();
    message.project = object.project ?? "";
    message.accountId = object.accountId ?? "";
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchRelatedAccountGroupMembershipsResponse(): SearchRelatedAccountGroupMembershipsResponse {
  return { relatedAccountGroupMemberships: [], nextPageToken: "" };
}

export const SearchRelatedAccountGroupMembershipsResponse: MessageFns<SearchRelatedAccountGroupMembershipsResponse> = {
  encode(
    message: SearchRelatedAccountGroupMembershipsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.relatedAccountGroupMemberships) {
      RelatedAccountGroupMembership.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRelatedAccountGroupMembershipsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRelatedAccountGroupMembershipsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relatedAccountGroupMemberships.push(RelatedAccountGroupMembership.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRelatedAccountGroupMembershipsResponse {
    return {
      relatedAccountGroupMemberships: globalThis.Array.isArray(object?.relatedAccountGroupMemberships)
        ? object.relatedAccountGroupMemberships.map((e: any) => RelatedAccountGroupMembership.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchRelatedAccountGroupMembershipsResponse): unknown {
    const obj: any = {};
    if (message.relatedAccountGroupMemberships?.length) {
      obj.relatedAccountGroupMemberships = message.relatedAccountGroupMemberships.map((e) =>
        RelatedAccountGroupMembership.toJSON(e)
      );
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRelatedAccountGroupMembershipsResponse>,
  ): SearchRelatedAccountGroupMembershipsResponse {
    return SearchRelatedAccountGroupMembershipsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRelatedAccountGroupMembershipsResponse>,
  ): SearchRelatedAccountGroupMembershipsResponse {
    const message = createBaseSearchRelatedAccountGroupMembershipsResponse();
    message.relatedAccountGroupMemberships =
      object.relatedAccountGroupMemberships?.map((e) => RelatedAccountGroupMembership.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAddIpOverrideRequest(): AddIpOverrideRequest {
  return { name: "", ipOverrideData: undefined };
}

export const AddIpOverrideRequest: MessageFns<AddIpOverrideRequest> = {
  encode(message: AddIpOverrideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ipOverrideData !== undefined) {
      IpOverrideData.encode(message.ipOverrideData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddIpOverrideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddIpOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipOverrideData = IpOverrideData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddIpOverrideRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ipOverrideData: isSet(object.ipOverrideData) ? IpOverrideData.fromJSON(object.ipOverrideData) : undefined,
    };
  },

  toJSON(message: AddIpOverrideRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ipOverrideData !== undefined) {
      obj.ipOverrideData = IpOverrideData.toJSON(message.ipOverrideData);
    }
    return obj;
  },

  create(base?: DeepPartial<AddIpOverrideRequest>): AddIpOverrideRequest {
    return AddIpOverrideRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddIpOverrideRequest>): AddIpOverrideRequest {
    const message = createBaseAddIpOverrideRequest();
    message.name = object.name ?? "";
    message.ipOverrideData = (object.ipOverrideData !== undefined && object.ipOverrideData !== null)
      ? IpOverrideData.fromPartial(object.ipOverrideData)
      : undefined;
    return message;
  },
};

function createBaseAddIpOverrideResponse(): AddIpOverrideResponse {
  return {};
}

export const AddIpOverrideResponse: MessageFns<AddIpOverrideResponse> = {
  encode(_: AddIpOverrideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddIpOverrideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddIpOverrideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddIpOverrideResponse {
    return {};
  },

  toJSON(_: AddIpOverrideResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddIpOverrideResponse>): AddIpOverrideResponse {
    return AddIpOverrideResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddIpOverrideResponse>): AddIpOverrideResponse {
    const message = createBaseAddIpOverrideResponse();
    return message;
  },
};

function createBaseRelatedAccountGroupMembership(): RelatedAccountGroupMembership {
  return { name: "", accountId: "", hashedAccountId: Buffer.alloc(0) };
}

export const RelatedAccountGroupMembership: MessageFns<RelatedAccountGroupMembership> = {
  encode(message: RelatedAccountGroupMembership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accountId !== "") {
      writer.uint32(34).string(message.accountId);
    }
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(18).bytes(message.hashedAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedAccountGroupMembership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedAccountGroupMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedAccountGroupMembership {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: RelatedAccountGroupMembership): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedAccountGroupMembership>): RelatedAccountGroupMembership {
    return RelatedAccountGroupMembership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedAccountGroupMembership>): RelatedAccountGroupMembership {
    const message = createBaseRelatedAccountGroupMembership();
    message.name = object.name ?? "";
    message.accountId = object.accountId ?? "";
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRelatedAccountGroup(): RelatedAccountGroup {
  return { name: "" };
}

export const RelatedAccountGroup: MessageFns<RelatedAccountGroup> = {
  encode(message: RelatedAccountGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedAccountGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedAccountGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedAccountGroup {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RelatedAccountGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedAccountGroup>): RelatedAccountGroup {
    return RelatedAccountGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedAccountGroup>): RelatedAccountGroup {
    const message = createBaseRelatedAccountGroup();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseWafSettings(): WafSettings {
  return { wafService: 0, wafFeature: 0 };
}

export const WafSettings: MessageFns<WafSettings> = {
  encode(message: WafSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wafService !== 0) {
      writer.uint32(8).int32(message.wafService);
    }
    if (message.wafFeature !== 0) {
      writer.uint32(16).int32(message.wafFeature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WafSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWafSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wafService = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wafFeature = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WafSettings {
    return {
      wafService: isSet(object.wafService) ? wafSettings_WafServiceFromJSON(object.wafService) : 0,
      wafFeature: isSet(object.wafFeature) ? wafSettings_WafFeatureFromJSON(object.wafFeature) : 0,
    };
  },

  toJSON(message: WafSettings): unknown {
    const obj: any = {};
    if (message.wafService !== 0) {
      obj.wafService = wafSettings_WafServiceToJSON(message.wafService);
    }
    if (message.wafFeature !== 0) {
      obj.wafFeature = wafSettings_WafFeatureToJSON(message.wafFeature);
    }
    return obj;
  },

  create(base?: DeepPartial<WafSettings>): WafSettings {
    return WafSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WafSettings>): WafSettings {
    const message = createBaseWafSettings();
    message.wafService = object.wafService ?? 0;
    message.wafFeature = object.wafFeature ?? 0;
    return message;
  },
};

function createBaseAssessmentEnvironment(): AssessmentEnvironment {
  return { client: "", version: "" };
}

export const AssessmentEnvironment: MessageFns<AssessmentEnvironment> = {
  encode(message: AssessmentEnvironment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client !== "") {
      writer.uint32(10).string(message.client);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssessmentEnvironment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssessmentEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.client = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssessmentEnvironment {
    return {
      client: isSet(object.client) ? globalThis.String(object.client) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: AssessmentEnvironment): unknown {
    const obj: any = {};
    if (message.client !== "") {
      obj.client = message.client;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<AssessmentEnvironment>): AssessmentEnvironment {
    return AssessmentEnvironment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssessmentEnvironment>): AssessmentEnvironment {
    const message = createBaseAssessmentEnvironment();
    message.client = object.client ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseIpOverrideData(): IpOverrideData {
  return { ip: "", overrideType: 0 };
}

export const IpOverrideData: MessageFns<IpOverrideData> = {
  encode(message: IpOverrideData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    if (message.overrideType !== 0) {
      writer.uint32(24).int32(message.overrideType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpOverrideData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpOverrideData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.overrideType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpOverrideData {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      overrideType: isSet(object.overrideType) ? ipOverrideData_OverrideTypeFromJSON(object.overrideType) : 0,
    };
  },

  toJSON(message: IpOverrideData): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.overrideType !== 0) {
      obj.overrideType = ipOverrideData_OverrideTypeToJSON(message.overrideType);
    }
    return obj;
  },

  create(base?: DeepPartial<IpOverrideData>): IpOverrideData {
    return IpOverrideData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IpOverrideData>): IpOverrideData {
    const message = createBaseIpOverrideData();
    message.ip = object.ip ?? "";
    message.overrideType = object.overrideType ?? 0;
    return message;
  },
};

/** Service to determine the likelihood an event is legitimate. */
export type RecaptchaEnterpriseServiceDefinition = typeof RecaptchaEnterpriseServiceDefinition;
export const RecaptchaEnterpriseServiceDefinition = {
  name: "RecaptchaEnterpriseService",
  fullName: "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
  methods: {
    /** Creates an Assessment of the likelihood an event is legitimate. */
    createAssessment: {
      name: "CreateAssessment",
      requestType: CreateAssessmentRequest,
      requestStream: false,
      responseType: Assessment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 112, 97, 114, 101, 110, 116, 44, 97, 115, 115, 101, 115, 115, 109, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              58,
              10,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              34,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Annotates a previously created Assessment to provide additional information
     * on whether the event turned out to be authentic or fraudulent.
     */
    annotateAssessment: {
      name: "AnnotateAssessment",
      requestType: AnnotateAssessmentRequest,
      requestStream: false,
      responseType: AnnotateAssessmentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new reCAPTCHA Enterprise key. */
    createKey: {
      name: "CreateKey",
      requestType: CreateKeyRequest,
      requestStream: false,
      responseType: Key,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 112, 97, 114, 101, 110, 116, 44, 107, 101, 121])],
          578365826: [
            Buffer.from([
              35,
              58,
              3,
              107,
              101,
              121,
              34,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all keys that belong to a project. */
    listKeys: {
      name: "ListKeys",
      requestType: ListKeysRequest,
      requestStream: false,
      responseType: ListKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the secret key related to the specified public key.
     * You must use the legacy secret key only in a 3rd party integration with
     * legacy reCAPTCHA.
     */
    retrieveLegacySecretKey: {
      name: "RetrieveLegacySecretKey",
      requestType: RetrieveLegacySecretKeyRequest,
      requestStream: false,
      responseType: RetrieveLegacySecretKeyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([3, 107, 101, 121])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              107,
              101,
              121,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              116,
              114,
              105,
              101,
              118,
              101,
              76,
              101,
              103,
              97,
              99,
              121,
              83,
              101,
              99,
              114,
              101,
              116,
              75,
              101,
              121,
            ]),
          ],
        },
      },
    },
    /** Returns the specified key. */
    getKey: {
      name: "GetKey",
      requestType: GetKeyRequest,
      requestStream: false,
      responseType: Key,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified key. */
    updateKey: {
      name: "UpdateKey",
      requestType: UpdateKeyRequest,
      requestStream: false,
      responseType: Key,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 107, 101, 121, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              39,
              58,
              3,
              107,
              101,
              121,
              50,
              32,
              47,
              118,
              49,
              47,
              123,
              107,
              101,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified key. */
    deleteKey: {
      name: "DeleteKey",
      requestType: DeleteKeyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              30,
              42,
              28,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Migrates an existing key from reCAPTCHA to reCAPTCHA Enterprise.
     * Once a key is migrated, it can be used from either product. SiteVerify
     * requests are billed as CreateAssessment calls. You must be
     * authenticated as one of the current owners of the reCAPTCHA Key, and
     * your user must have the reCAPTCHA Enterprise Admin IAM role in the
     * destination project.
     */
    migrateKey: {
      name: "MigrateKey",
      requestType: MigrateKeyRequest,
      requestStream: false,
      responseType: Key,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              41,
              58,
              1,
              42,
              34,
              36,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              109,
              105,
              103,
              114,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Adds an IP override to a key. The following restrictions hold:
     * * The maximum number of IP overrides per key is 100.
     * * For any conflict (such as IP already exists or IP part of an existing
     *   IP range), an error is returned.
     */
    addIpOverride: {
      name: "AddIpOverride",
      requestType: AddIpOverrideRequest,
      requestStream: false,
      responseType: AddIpOverrideResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              110,
              97,
              109,
              101,
              44,
              105,
              112,
              95,
              111,
              118,
              101,
              114,
              114,
              105,
              100,
              101,
              95,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              47,
              58,
              1,
              42,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              73,
              112,
              79,
              118,
              101,
              114,
              114,
              105,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Get some aggregated metrics for a Key. This data can be used to build
     * dashboards.
     */
    getMetrics: {
      name: "GetMetrics",
      requestType: GetMetricsRequest,
      requestStream: false,
      responseType: Metrics,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              38,
              18,
              36,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new FirewallPolicy, specifying conditions at which reCAPTCHA
     * Enterprise actions can be executed.
     * A project may have a maximum of 1000 policies.
     */
    createFirewallPolicy: {
      name: "CreateFirewallPolicy",
      requestType: CreateFirewallPolicyRequest,
      requestStream: false,
      responseType: FirewallPolicy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              59,
              58,
              15,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all firewall policies that belong to a project. */
    listFirewallPolicies: {
      name: "ListFirewallPolicies",
      requestType: ListFirewallPoliciesRequest,
      requestStream: false,
      responseType: ListFirewallPoliciesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified firewall policy. */
    getFirewallPolicy: {
      name: "GetFirewallPolicy",
      requestType: GetFirewallPolicyRequest,
      requestStream: false,
      responseType: FirewallPolicy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified firewall policy. */
    updateFirewallPolicy: {
      name: "UpdateFirewallPolicy",
      requestType: UpdateFirewallPolicyRequest,
      requestStream: false,
      responseType: FirewallPolicy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              27,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              15,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              50,
              56,
              47,
              118,
              49,
              47,
              123,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified firewall policy. */
    deleteFirewallPolicy: {
      name: "DeleteFirewallPolicy",
      requestType: DeleteFirewallPolicyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              42,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Reorders all firewall policies. */
    reorderFirewallPolicies: {
      name: "ReorderFirewallPolicies",
      requestType: ReorderFirewallPoliciesRequest,
      requestStream: false,
      responseType: ReorderFirewallPoliciesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 110, 97, 109, 101, 115])],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              114,
              101,
              119,
              97,
              108,
              108,
              112,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              58,
              114,
              101,
              111,
              114,
              100,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /** List groups of related accounts. */
    listRelatedAccountGroups: {
      name: "ListRelatedAccountGroups",
      requestType: ListRelatedAccountGroupsRequest,
      requestStream: false,
      responseType: ListRelatedAccountGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              108,
              97,
              116,
              101,
              100,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Get memberships in a group of related accounts. */
    listRelatedAccountGroupMemberships: {
      name: "ListRelatedAccountGroupMemberships",
      requestType: ListRelatedAccountGroupMembershipsRequest,
      requestStream: false,
      responseType: ListRelatedAccountGroupMembershipsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              97,
              116,
              101,
              100,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Search group memberships related to a given account. */
    searchRelatedAccountGroupMemberships: {
      name: "SearchRelatedAccountGroupMemberships",
      requestType: SearchRelatedAccountGroupMembershipsRequest,
      requestStream: false,
      responseType: SearchRelatedAccountGroupMembershipsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              44,
              104,
              97,
              115,
              104,
              101,
              100,
              95,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              108,
              97,
              116,
              101,
              100,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              103,
              114,
              111,
              117,
              112,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface RecaptchaEnterpriseServiceImplementation<CallContextExt = {}> {
  /** Creates an Assessment of the likelihood an event is legitimate. */
  createAssessment(
    request: CreateAssessmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Assessment>>;
  /**
   * Annotates a previously created Assessment to provide additional information
   * on whether the event turned out to be authentic or fraudulent.
   */
  annotateAssessment(
    request: AnnotateAssessmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnnotateAssessmentResponse>>;
  /** Creates a new reCAPTCHA Enterprise key. */
  createKey(request: CreateKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Key>>;
  /** Returns the list of all keys that belong to a project. */
  listKeys(request: ListKeysRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListKeysResponse>>;
  /**
   * Returns the secret key related to the specified public key.
   * You must use the legacy secret key only in a 3rd party integration with
   * legacy reCAPTCHA.
   */
  retrieveLegacySecretKey(
    request: RetrieveLegacySecretKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RetrieveLegacySecretKeyResponse>>;
  /** Returns the specified key. */
  getKey(request: GetKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Key>>;
  /** Updates the specified key. */
  updateKey(request: UpdateKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Key>>;
  /** Deletes the specified key. */
  deleteKey(request: DeleteKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Migrates an existing key from reCAPTCHA to reCAPTCHA Enterprise.
   * Once a key is migrated, it can be used from either product. SiteVerify
   * requests are billed as CreateAssessment calls. You must be
   * authenticated as one of the current owners of the reCAPTCHA Key, and
   * your user must have the reCAPTCHA Enterprise Admin IAM role in the
   * destination project.
   */
  migrateKey(request: MigrateKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Key>>;
  /**
   * Adds an IP override to a key. The following restrictions hold:
   * * The maximum number of IP overrides per key is 100.
   * * For any conflict (such as IP already exists or IP part of an existing
   *   IP range), an error is returned.
   */
  addIpOverride(
    request: AddIpOverrideRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AddIpOverrideResponse>>;
  /**
   * Get some aggregated metrics for a Key. This data can be used to build
   * dashboards.
   */
  getMetrics(request: GetMetricsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Metrics>>;
  /**
   * Creates a new FirewallPolicy, specifying conditions at which reCAPTCHA
   * Enterprise actions can be executed.
   * A project may have a maximum of 1000 policies.
   */
  createFirewallPolicy(
    request: CreateFirewallPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallPolicy>>;
  /** Returns the list of all firewall policies that belong to a project. */
  listFirewallPolicies(
    request: ListFirewallPoliciesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFirewallPoliciesResponse>>;
  /** Returns the specified firewall policy. */
  getFirewallPolicy(
    request: GetFirewallPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallPolicy>>;
  /** Updates the specified firewall policy. */
  updateFirewallPolicy(
    request: UpdateFirewallPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FirewallPolicy>>;
  /** Deletes the specified firewall policy. */
  deleteFirewallPolicy(
    request: DeleteFirewallPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Reorders all firewall policies. */
  reorderFirewallPolicies(
    request: ReorderFirewallPoliciesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReorderFirewallPoliciesResponse>>;
  /** List groups of related accounts. */
  listRelatedAccountGroups(
    request: ListRelatedAccountGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRelatedAccountGroupsResponse>>;
  /** Get memberships in a group of related accounts. */
  listRelatedAccountGroupMemberships(
    request: ListRelatedAccountGroupMembershipsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRelatedAccountGroupMembershipsResponse>>;
  /** Search group memberships related to a given account. */
  searchRelatedAccountGroupMemberships(
    request: SearchRelatedAccountGroupMembershipsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchRelatedAccountGroupMembershipsResponse>>;
}

export interface RecaptchaEnterpriseServiceClient<CallOptionsExt = {}> {
  /** Creates an Assessment of the likelihood an event is legitimate. */
  createAssessment(
    request: DeepPartial<CreateAssessmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Assessment>;
  /**
   * Annotates a previously created Assessment to provide additional information
   * on whether the event turned out to be authentic or fraudulent.
   */
  annotateAssessment(
    request: DeepPartial<AnnotateAssessmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnnotateAssessmentResponse>;
  /** Creates a new reCAPTCHA Enterprise key. */
  createKey(request: DeepPartial<CreateKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Key>;
  /** Returns the list of all keys that belong to a project. */
  listKeys(request: DeepPartial<ListKeysRequest>, options?: CallOptions & CallOptionsExt): Promise<ListKeysResponse>;
  /**
   * Returns the secret key related to the specified public key.
   * You must use the legacy secret key only in a 3rd party integration with
   * legacy reCAPTCHA.
   */
  retrieveLegacySecretKey(
    request: DeepPartial<RetrieveLegacySecretKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RetrieveLegacySecretKeyResponse>;
  /** Returns the specified key. */
  getKey(request: DeepPartial<GetKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Key>;
  /** Updates the specified key. */
  updateKey(request: DeepPartial<UpdateKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Key>;
  /** Deletes the specified key. */
  deleteKey(request: DeepPartial<DeleteKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Migrates an existing key from reCAPTCHA to reCAPTCHA Enterprise.
   * Once a key is migrated, it can be used from either product. SiteVerify
   * requests are billed as CreateAssessment calls. You must be
   * authenticated as one of the current owners of the reCAPTCHA Key, and
   * your user must have the reCAPTCHA Enterprise Admin IAM role in the
   * destination project.
   */
  migrateKey(request: DeepPartial<MigrateKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Key>;
  /**
   * Adds an IP override to a key. The following restrictions hold:
   * * The maximum number of IP overrides per key is 100.
   * * For any conflict (such as IP already exists or IP part of an existing
   *   IP range), an error is returned.
   */
  addIpOverride(
    request: DeepPartial<AddIpOverrideRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AddIpOverrideResponse>;
  /**
   * Get some aggregated metrics for a Key. This data can be used to build
   * dashboards.
   */
  getMetrics(request: DeepPartial<GetMetricsRequest>, options?: CallOptions & CallOptionsExt): Promise<Metrics>;
  /**
   * Creates a new FirewallPolicy, specifying conditions at which reCAPTCHA
   * Enterprise actions can be executed.
   * A project may have a maximum of 1000 policies.
   */
  createFirewallPolicy(
    request: DeepPartial<CreateFirewallPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallPolicy>;
  /** Returns the list of all firewall policies that belong to a project. */
  listFirewallPolicies(
    request: DeepPartial<ListFirewallPoliciesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFirewallPoliciesResponse>;
  /** Returns the specified firewall policy. */
  getFirewallPolicy(
    request: DeepPartial<GetFirewallPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallPolicy>;
  /** Updates the specified firewall policy. */
  updateFirewallPolicy(
    request: DeepPartial<UpdateFirewallPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FirewallPolicy>;
  /** Deletes the specified firewall policy. */
  deleteFirewallPolicy(
    request: DeepPartial<DeleteFirewallPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Reorders all firewall policies. */
  reorderFirewallPolicies(
    request: DeepPartial<ReorderFirewallPoliciesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReorderFirewallPoliciesResponse>;
  /** List groups of related accounts. */
  listRelatedAccountGroups(
    request: DeepPartial<ListRelatedAccountGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRelatedAccountGroupsResponse>;
  /** Get memberships in a group of related accounts. */
  listRelatedAccountGroupMemberships(
    request: DeepPartial<ListRelatedAccountGroupMembershipsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRelatedAccountGroupMembershipsResponse>;
  /** Search group memberships related to a given account. */
  searchRelatedAccountGroupMemberships(
    request: DeepPartial<SearchRelatedAccountGroupMembershipsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchRelatedAccountGroupMembershipsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
