// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tasks/v2/cloudtasks.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Queue } from "./queue.js";
import { Task, Task_View, task_ViewFromJSON, task_ViewToJSON } from "./task.js";

export const protobufPackage = "google.cloud.tasks.v2";

/**
 * Request message for
 * [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
 */
export interface ListQueuesRequest {
  /**
   * Required. The location name.
   * For example: `projects/PROJECT_ID/locations/LOCATION_ID`
   */
  parent: string;
  /**
   * `filter` can be used to specify a subset of queues. Any
   * [Queue][google.cloud.tasks.v2.Queue] field can be used as a filter and
   * several operators as supported. For example: `<=, <, >=, >, !=, =, :`. The
   * filter syntax is the same as described in [Stackdriver's Advanced Logs
   * Filters](https://cloud.google.com/logging/docs/view/advanced_filters).
   *
   * Sample filter "state: PAUSED".
   *
   * Note that using filters might cause fewer queues than the
   * requested page_size to be returned.
   */
  filter: string;
  /**
   * Requested page size.
   *
   * The maximum page size is 9800. If unspecified, the page size will
   * be the maximum. Fewer queues than requested might be returned,
   * even if more queues exist; use the
   * [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
   * in the response to determine if more queues exist.
   */
  pageSize: number;
  /**
   * A token identifying the page of results to return.
   *
   * To request the first page results, page_token must be empty. To
   * request the next page of results, page_token must be the value of
   * [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
   * returned from the previous call to
   * [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] method. It is an
   * error to switch the value of the
   * [filter][google.cloud.tasks.v2.ListQueuesRequest.filter] while iterating
   * through pages.
   */
  pageToken: string;
}

/**
 * Response message for
 * [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
 */
export interface ListQueuesResponse {
  /** The list of queues. */
  queues: Queue[];
  /**
   * A token to retrieve next page of results.
   *
   * To return the next page of results, call
   * [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] with this value
   * as the [page_token][google.cloud.tasks.v2.ListQueuesRequest.page_token].
   *
   * If the next_page_token is empty, there are no more results.
   *
   * The page token is valid for only 2 hours.
   */
  nextPageToken: string;
}

/** Request message for [GetQueue][google.cloud.tasks.v2.CloudTasks.GetQueue]. */
export interface GetQueueRequest {
  /**
   * Required. The resource name of the queue. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [CreateQueue][google.cloud.tasks.v2.CloudTasks.CreateQueue].
 */
export interface CreateQueueRequest {
  /**
   * Required. The location name in which the queue will be created.
   * For example: `projects/PROJECT_ID/locations/LOCATION_ID`
   *
   * The list of allowed locations can be obtained by calling Cloud
   * Tasks' implementation of
   * [ListLocations][google.cloud.location.Locations.ListLocations].
   */
  parent: string;
  /**
   * Required. The queue to create.
   *
   * [Queue's name][google.cloud.tasks.v2.Queue.name] cannot be the same as an
   * existing queue.
   */
  queue: Queue | undefined;
}

/**
 * Request message for
 * [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue].
 */
export interface UpdateQueueRequest {
  /**
   * Required. The queue to create or update.
   *
   * The queue's [name][google.cloud.tasks.v2.Queue.name] must be specified.
   *
   * Output only fields cannot be modified using UpdateQueue.
   * Any value specified for an output only field will be ignored.
   * The queue's [name][google.cloud.tasks.v2.Queue.name] cannot be changed.
   */
  queue:
    | Queue
    | undefined;
  /**
   * A mask used to specify which fields of the queue are being updated.
   *
   * If empty, then all fields will be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [DeleteQueue][google.cloud.tasks.v2.CloudTasks.DeleteQueue].
 */
export interface DeleteQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [PurgeQueue][google.cloud.tasks.v2.CloudTasks.PurgeQueue].
 */
export interface PurgeQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [PauseQueue][google.cloud.tasks.v2.CloudTasks.PauseQueue].
 */
export interface PauseQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue].
 */
export interface ResumeQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for listing tasks using
 * [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
 */
export interface ListTasksRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  parent: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2.Task] will be returned.
   *
   * By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
   * not all information is retrieved by default because some data, such as
   * payloads, might be desirable to return only when needed because
   * of its large size or because of the sensitivity of data that it
   * contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
   * `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
   * permission on the [Task][google.cloud.tasks.v2.Task] resource.
   */
  responseView: Task_View;
  /**
   * Maximum page size.
   *
   * Fewer tasks than requested might be returned, even if more tasks exist; use
   * [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
   * in the response to determine if more tasks exist.
   *
   * The maximum page size is 1000. If unspecified, the page size will be the
   * maximum.
   */
  pageSize: number;
  /**
   * A token identifying the page of results to return.
   *
   * To request the first page results, page_token must be empty. To
   * request the next page of results, page_token must be the value of
   * [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
   * returned from the previous call to
   * [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] method.
   *
   * The page token is valid for only 2 hours.
   */
  pageToken: string;
}

/**
 * Response message for listing tasks using
 * [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
 */
export interface ListTasksResponse {
  /** The list of tasks. */
  tasks: Task[];
  /**
   * A token to retrieve next page of results.
   *
   * To return the next page of results, call
   * [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] with this value as
   * the [page_token][google.cloud.tasks.v2.ListTasksRequest.page_token].
   *
   * If the next_page_token is empty, there are no more results.
   */
  nextPageToken: string;
}

/**
 * Request message for getting a task using
 * [GetTask][google.cloud.tasks.v2.CloudTasks.GetTask].
 */
export interface GetTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2.Task] will be returned.
   *
   * By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
   * not all information is retrieved by default because some data, such as
   * payloads, might be desirable to return only when needed because
   * of its large size or because of the sensitivity of data that it
   * contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
   * `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
   * permission on the [Task][google.cloud.tasks.v2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for
 * [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask].
 */
export interface CreateTaskRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   *
   * The queue must already exist.
   */
  parent: string;
  /**
   * Required. The task to add.
   *
   * Task names have the following format:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`.
   * The user can optionally specify a task
   * [name][google.cloud.tasks.v2.Task.name]. If a name is not specified then
   * the system will generate a random unique task id, which will be set in the
   * task returned in the [response][google.cloud.tasks.v2.Task.name].
   *
   * If [schedule_time][google.cloud.tasks.v2.Task.schedule_time] is not set or
   * is in the past then Cloud Tasks will set it to the current time.
   *
   * Task De-duplication:
   *
   * Explicitly specifying a task ID enables task de-duplication.  If
   * a task's ID is identical to that of an existing task or a task
   * that was deleted or executed recently then the call will fail
   * with [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS].
   * If the task's queue was created using Cloud Tasks, then another task with
   * the same name can't be created for ~1hour after the original task was
   * deleted or executed. If the task's queue was created using queue.yaml or
   * queue.xml, then another task with the same name can't be created
   * for ~9days after the original task was deleted or executed.
   *
   * Because there is an extra lookup cost to identify duplicate task
   * names, these [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask]
   * calls have significantly increased latency. Using hashed strings for the
   * task id or for the prefix of the task id is recommended. Choosing task ids
   * that are sequential or have sequential prefixes, for example using a
   * timestamp, causes an increase in latency and error rates in all
   * task commands. The infrastructure relies on an approximately
   * uniform distribution of task ids to store and serve tasks
   * efficiently.
   */
  task:
    | Task
    | undefined;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2.Task] will be returned.
   *
   * By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
   * not all information is retrieved by default because some data, such as
   * payloads, might be desirable to return only when needed because
   * of its large size or because of the sensitivity of data that it
   * contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
   * `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
   * permission on the [Task][google.cloud.tasks.v2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for deleting a task using
 * [DeleteTask][google.cloud.tasks.v2.CloudTasks.DeleteTask].
 */
export interface DeleteTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
}

/**
 * Request message for forcing a task to run now using
 * [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask].
 */
export interface RunTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2.Task] will be returned.
   *
   * By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
   * not all information is retrieved by default because some data, such as
   * payloads, might be desirable to return only when needed because
   * of its large size or because of the sensitivity of data that it
   * contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
   * `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
   * permission on the [Task][google.cloud.tasks.v2.Task] resource.
   */
  responseView: Task_View;
}

function createBaseListQueuesRequest(): ListQueuesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListQueuesRequest: MessageFns<ListQueuesRequest> = {
  encode(message: ListQueuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListQueuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuesRequest>): ListQueuesRequest {
    return ListQueuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuesRequest>): ListQueuesRequest {
    const message = createBaseListQueuesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListQueuesResponse(): ListQueuesResponse {
  return { queues: [], nextPageToken: "" };
}

export const ListQueuesResponse: MessageFns<ListQueuesResponse> = {
  encode(message: ListQueuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queues) {
      Queue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queues.push(Queue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuesResponse {
    return {
      queues: globalThis.Array.isArray(object?.queues) ? object.queues.map((e: any) => Queue.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListQueuesResponse): unknown {
    const obj: any = {};
    if (message.queues?.length) {
      obj.queues = message.queues.map((e) => Queue.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuesResponse>): ListQueuesResponse {
    return ListQueuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuesResponse>): ListQueuesResponse {
    const message = createBaseListQueuesResponse();
    message.queues = object.queues?.map((e) => Queue.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetQueueRequest(): GetQueueRequest {
  return { name: "" };
}

export const GetQueueRequest: MessageFns<GetQueueRequest> = {
  encode(message: GetQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueueRequest>): GetQueueRequest {
    return GetQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueueRequest>): GetQueueRequest {
    const message = createBaseGetQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateQueueRequest(): CreateQueueRequest {
  return { parent: "", queue: undefined };
}

export const CreateQueueRequest: MessageFns<CreateQueueRequest> = {
  encode(message: CreateQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.queue !== undefined) {
      Queue.encode(message.queue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queue = Queue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQueueRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      queue: isSet(object.queue) ? Queue.fromJSON(object.queue) : undefined,
    };
  },

  toJSON(message: CreateQueueRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.queue !== undefined) {
      obj.queue = Queue.toJSON(message.queue);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateQueueRequest>): CreateQueueRequest {
    return CreateQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateQueueRequest>): CreateQueueRequest {
    const message = createBaseCreateQueueRequest();
    message.parent = object.parent ?? "";
    message.queue = (object.queue !== undefined && object.queue !== null) ? Queue.fromPartial(object.queue) : undefined;
    return message;
  },
};

function createBaseUpdateQueueRequest(): UpdateQueueRequest {
  return { queue: undefined, updateMask: undefined };
}

export const UpdateQueueRequest: MessageFns<UpdateQueueRequest> = {
  encode(message: UpdateQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queue !== undefined) {
      Queue.encode(message.queue, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queue = Queue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateQueueRequest {
    return {
      queue: isSet(object.queue) ? Queue.fromJSON(object.queue) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateQueueRequest): unknown {
    const obj: any = {};
    if (message.queue !== undefined) {
      obj.queue = Queue.toJSON(message.queue);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateQueueRequest>): UpdateQueueRequest {
    return UpdateQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateQueueRequest>): UpdateQueueRequest {
    const message = createBaseUpdateQueueRequest();
    message.queue = (object.queue !== undefined && object.queue !== null) ? Queue.fromPartial(object.queue) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteQueueRequest(): DeleteQueueRequest {
  return { name: "" };
}

export const DeleteQueueRequest: MessageFns<DeleteQueueRequest> = {
  encode(message: DeleteQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteQueueRequest>): DeleteQueueRequest {
    return DeleteQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteQueueRequest>): DeleteQueueRequest {
    const message = createBaseDeleteQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePurgeQueueRequest(): PurgeQueueRequest {
  return { name: "" };
}

export const PurgeQueueRequest: MessageFns<PurgeQueueRequest> = {
  encode(message: PurgeQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PurgeQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeQueueRequest>): PurgeQueueRequest {
    return PurgeQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeQueueRequest>): PurgeQueueRequest {
    const message = createBasePurgeQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePauseQueueRequest(): PauseQueueRequest {
  return { name: "" };
}

export const PauseQueueRequest: MessageFns<PauseQueueRequest> = {
  encode(message: PauseQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PauseQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PauseQueueRequest>): PauseQueueRequest {
    return PauseQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseQueueRequest>): PauseQueueRequest {
    const message = createBasePauseQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResumeQueueRequest(): ResumeQueueRequest {
  return { name: "" };
}

export const ResumeQueueRequest: MessageFns<ResumeQueueRequest> = {
  encode(message: ResumeQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResumeQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumeQueueRequest>): ResumeQueueRequest {
    return ResumeQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeQueueRequest>): ResumeQueueRequest {
    const message = createBaseResumeQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTasksRequest(): ListTasksRequest {
  return { parent: "", responseView: 0, pageSize: 0, pageToken: "" };
}

export const ListTasksRequest: MessageFns<ListTasksRequest> = {
  encode(message: ListTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTasksRequest>): ListTasksRequest {
    return ListTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTasksRequest>): ListTasksRequest {
    const message = createBaseListTasksRequest();
    message.parent = object.parent ?? "";
    message.responseView = object.responseView ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTasksResponse(): ListTasksResponse {
  return { tasks: [], nextPageToken: "" };
}

export const ListTasksResponse: MessageFns<ListTasksResponse> = {
  encode(message: ListTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksResponse {
    return {
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTasksResponse>): ListTasksResponse {
    return ListTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTasksResponse>): ListTasksResponse {
    const message = createBaseListTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { name: "", responseView: 0 };
}

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  encode(message: GetTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: GetTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTaskRequest>): GetTaskRequest {
    return GetTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTaskRequest>): GetTaskRequest {
    const message = createBaseGetTaskRequest();
    message.name = object.name ?? "";
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseCreateTaskRequest(): CreateTaskRequest {
  return { parent: "", task: undefined, responseView: 0 };
}

export const CreateTaskRequest: MessageFns<CreateTaskRequest> = {
  encode(message: CreateTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(18).fork()).join();
    }
    if (message.responseView !== 0) {
      writer.uint32(24).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: CreateTaskRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskRequest>): CreateTaskRequest {
    return CreateTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskRequest>): CreateTaskRequest {
    const message = createBaseCreateTaskRequest();
    message.parent = object.parent ?? "";
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseDeleteTaskRequest(): DeleteTaskRequest {
  return { name: "" };
}

export const DeleteTaskRequest: MessageFns<DeleteTaskRequest> = {
  encode(message: DeleteTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTaskRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTaskRequest>): DeleteTaskRequest {
    return DeleteTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTaskRequest>): DeleteTaskRequest {
    const message = createBaseDeleteTaskRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRunTaskRequest(): RunTaskRequest {
  return { name: "", responseView: 0 };
}

export const RunTaskRequest: MessageFns<RunTaskRequest> = {
  encode(message: RunTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: RunTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<RunTaskRequest>): RunTaskRequest {
    return RunTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunTaskRequest>): RunTaskRequest {
    const message = createBaseRunTaskRequest();
    message.name = object.name ?? "";
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

/**
 * Cloud Tasks allows developers to manage the execution of background
 * work in their applications.
 */
export type CloudTasksDefinition = typeof CloudTasksDefinition;
export const CloudTasksDefinition = {
  name: "CloudTasks",
  fullName: "google.cloud.tasks.v2.CloudTasks",
  methods: {
    /**
     * Lists queues.
     *
     * Queues are returned in lexicographical order.
     */
    listQueues: {
      name: "ListQueues",
      requestType: ListQueuesRequest,
      requestStream: false,
      responseType: ListQueuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a queue. */
    getQueue: {
      name: "GetQueue",
      requestType: GetQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a queue.
     *
     * Queues created with this method allow tasks to live for a maximum of 31
     * days. After a task is 31 days old, the task will be deleted regardless of
     * whether it was dispatched or not.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    createQueue: {
      name: "CreateQueue",
      requestType: CreateQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 117, 101])],
          578365826: [
            Buffer.from([
              51,
              58,
              5,
              113,
              117,
              101,
              117,
              101,
              34,
              42,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a queue.
     *
     * This method creates the queue if it does not exist and updates
     * the queue if it does exist.
     *
     * Queues created with this method allow tasks to live for a maximum of 31
     * days. After a task is 31 days old, the task will be deleted regardless of
     * whether it was dispatched or not.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    updateQueue: {
      name: "UpdateQueue",
      requestType: UpdateQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 113, 117, 101, 117, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              113,
              117,
              101,
              117,
              101,
              50,
              48,
              47,
              118,
              50,
              47,
              123,
              113,
              117,
              101,
              117,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a queue.
     *
     * This command will delete the queue even if it has tasks in it.
     *
     * Note: If you delete a queue, a queue with the same name can't be created
     * for 7 days.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    deleteQueue: {
      name: "DeleteQueue",
      requestType: DeleteQueueRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Purges a queue by deleting all of its tasks.
     *
     * All tasks created before this method is called are permanently deleted.
     *
     * Purge operations can take up to one minute to take effect. Tasks
     * might be dispatched before the purge takes effect. A purge is irreversible.
     */
    purgeQueue: {
      name: "PurgeQueue",
      requestType: PurgeQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              112,
              117,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Pauses the queue.
     *
     * If a queue is paused then the system will stop dispatching tasks
     * until the queue is resumed via
     * [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue]. Tasks can
     * still be added when the queue is paused. A queue is paused if its
     * [state][google.cloud.tasks.v2.Queue.state] is
     * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
     */
    pauseQueue: {
      name: "PauseQueue",
      requestType: PauseQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              112,
              97,
              117,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Resume a queue.
     *
     * This method resumes a queue after it has been
     * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED] or
     * [DISABLED][google.cloud.tasks.v2.Queue.State.DISABLED]. The state of a
     * queue is stored in the queue's [state][google.cloud.tasks.v2.Queue.state];
     * after calling this method it will be set to
     * [RUNNING][google.cloud.tasks.v2.Queue.State.RUNNING].
     *
     * WARNING: Resuming many high-QPS queues at the same time can
     * lead to target overloading. If you are resuming high-QPS
     * queues, follow the 500/50/5 pattern described in
     * [Managing Cloud Tasks Scaling
     * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
     */
    resumeQueue: {
      name: "ResumeQueue",
      requestType: ResumeQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              117,
              109,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
     * Returns an empty policy if the resource exists and does not have a policy
     * set.
     *
     * Authorization requires the following
     * [Google IAM](https://cloud.google.com/iam) permission on the specified
     * resource parent:
     *
     * * `cloudtasks.queues.getIamPolicy`
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
     * Replaces any existing policy.
     *
     * Note: The Cloud Console does not check queue-level IAM permissions yet.
     * Project-level permissions are required to use the Cloud Console.
     *
     * Authorization requires the following
     * [Google IAM](https://cloud.google.com/iam) permission on the specified
     * resource parent:
     *
     * * `cloudtasks.queues.setIamPolicy`
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on a
     * [Queue][google.cloud.tasks.v2.Queue]. If the resource does not exist, this
     * will return an empty set of permissions, not a
     * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
     *
     * Note: This operation is designed to be used for building permission-aware
     * UIs and command-line tools, not for authorization checking. This operation
     * may "fail open" without warning.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the tasks in a queue.
     *
     * By default, only the [BASIC][google.cloud.tasks.v2.Task.View.BASIC] view is
     * retrieved due to performance considerations;
     * [response_view][google.cloud.tasks.v2.ListTasksRequest.response_view]
     * controls the subset of information which is returned.
     *
     * The tasks may be returned in any order. The ordering may change at any
     * time.
     */
    listTasks: {
      name: "ListTasks",
      requestType: ListTasksRequest,
      requestStream: false,
      responseType: ListTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a task. */
    getTask: {
      name: "GetTask",
      requestType: GetTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a task and adds it to a queue.
     *
     * Tasks cannot be updated after creation; there is no UpdateTask command.
     *
     * * The maximum task size is 100KB.
     */
    createTask: {
      name: "CreateTask",
      requestType: CreateTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 116, 97, 115, 107])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a task.
     *
     * A task can be deleted if it is scheduled or dispatched. A task
     * cannot be deleted if it has executed successfully or permanently
     * failed.
     */
    deleteTask: {
      name: "DeleteTask",
      requestType: DeleteTaskRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Forces a task to run now.
     *
     * When this method is called, Cloud Tasks will dispatch the task, even if
     * the task is already running, the queue has reached its
     * [RateLimits][google.cloud.tasks.v2.RateLimits] or is
     * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
     *
     * This command is meant to be used for manual debugging. For
     * example, [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] can be used to
     * retry a failed task after a fix has been made or to manually force a task
     * to be dispatched now.
     *
     * The dispatched task is returned. That is, the task that is returned
     * contains the [status][Task.status] after the task is dispatched but
     * before the task is received by its target.
     *
     * If Cloud Tasks receives a successful response from the task's
     * target, then the task will be deleted; otherwise the task's
     * [schedule_time][google.cloud.tasks.v2.Task.schedule_time] will be reset to
     * the time that [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] was
     * called plus the retry delay specified in the queue's
     * [RetryConfig][google.cloud.tasks.v2.RetryConfig].
     *
     * [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] returns
     * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
     * task that has already succeeded or permanently failed.
     */
    runTask: {
      name: "RunTask",
      requestType: RunTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudTasksServiceImplementation<CallContextExt = {}> {
  /**
   * Lists queues.
   *
   * Queues are returned in lexicographical order.
   */
  listQueues(
    request: ListQueuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListQueuesResponse>>;
  /** Gets a queue. */
  getQueue(request: GetQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Creates a queue.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  createQueue(request: CreateQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Updates a queue.
   *
   * This method creates the queue if it does not exist and updates
   * the queue if it does exist.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  updateQueue(request: UpdateQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Deletes a queue.
   *
   * This command will delete the queue even if it has tasks in it.
   *
   * Note: If you delete a queue, a queue with the same name can't be created
   * for 7 days.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  deleteQueue(request: DeleteQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Purges a queue by deleting all of its tasks.
   *
   * All tasks created before this method is called are permanently deleted.
   *
   * Purge operations can take up to one minute to take effect. Tasks
   * might be dispatched before the purge takes effect. A purge is irreversible.
   */
  purgeQueue(request: PurgeQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Pauses the queue.
   *
   * If a queue is paused then the system will stop dispatching tasks
   * until the queue is resumed via
   * [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue]. Tasks can
   * still be added when the queue is paused. A queue is paused if its
   * [state][google.cloud.tasks.v2.Queue.state] is
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
   */
  pauseQueue(request: PauseQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Resume a queue.
   *
   * This method resumes a queue after it has been
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED] or
   * [DISABLED][google.cloud.tasks.v2.Queue.State.DISABLED]. The state of a
   * queue is stored in the queue's [state][google.cloud.tasks.v2.Queue.state];
   * after calling this method it will be set to
   * [RUNNING][google.cloud.tasks.v2.Queue.State.RUNNING].
   *
   * WARNING: Resuming many high-QPS queues at the same time can
   * lead to target overloading. If you are resuming high-QPS
   * queues, follow the 500/50/5 pattern described in
   * [Managing Cloud Tasks Scaling
   * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
   */
  resumeQueue(request: ResumeQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Gets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.getIamPolicy`
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
   * Replaces any existing policy.
   *
   * Note: The Cloud Console does not check queue-level IAM permissions yet.
   * Project-level permissions are required to use the Cloud Console.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.setIamPolicy`
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on a
   * [Queue][google.cloud.tasks.v2.Queue]. If the resource does not exist, this
   * will return an empty set of permissions, not a
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /**
   * Lists the tasks in a queue.
   *
   * By default, only the [BASIC][google.cloud.tasks.v2.Task.View.BASIC] view is
   * retrieved due to performance considerations;
   * [response_view][google.cloud.tasks.v2.ListTasksRequest.response_view]
   * controls the subset of information which is returned.
   *
   * The tasks may be returned in any order. The ordering may change at any
   * time.
   */
  listTasks(request: ListTasksRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListTasksResponse>>;
  /** Gets a task. */
  getTask(request: GetTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Creates a task and adds it to a queue.
   *
   * Tasks cannot be updated after creation; there is no UpdateTask command.
   *
   * * The maximum task size is 100KB.
   */
  createTask(request: CreateTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Deletes a task.
   *
   * A task can be deleted if it is scheduled or dispatched. A task
   * cannot be deleted if it has executed successfully or permanently
   * failed.
   */
  deleteTask(request: DeleteTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Forces a task to run now.
   *
   * When this method is called, Cloud Tasks will dispatch the task, even if
   * the task is already running, the queue has reached its
   * [RateLimits][google.cloud.tasks.v2.RateLimits] or is
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
   *
   * This command is meant to be used for manual debugging. For
   * example, [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] can be used to
   * retry a failed task after a fix has been made or to manually force a task
   * to be dispatched now.
   *
   * The dispatched task is returned. That is, the task that is returned
   * contains the [status][Task.status] after the task is dispatched but
   * before the task is received by its target.
   *
   * If Cloud Tasks receives a successful response from the task's
   * target, then the task will be deleted; otherwise the task's
   * [schedule_time][google.cloud.tasks.v2.Task.schedule_time] will be reset to
   * the time that [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] was
   * called plus the retry delay specified in the queue's
   * [RetryConfig][google.cloud.tasks.v2.RetryConfig].
   *
   * [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] returns
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
   * task that has already succeeded or permanently failed.
   */
  runTask(request: RunTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
}

export interface CloudTasksClient<CallOptionsExt = {}> {
  /**
   * Lists queues.
   *
   * Queues are returned in lexicographical order.
   */
  listQueues(
    request: DeepPartial<ListQueuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListQueuesResponse>;
  /** Gets a queue. */
  getQueue(request: DeepPartial<GetQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Creates a queue.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  createQueue(request: DeepPartial<CreateQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Updates a queue.
   *
   * This method creates the queue if it does not exist and updates
   * the queue if it does exist.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  updateQueue(request: DeepPartial<UpdateQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Deletes a queue.
   *
   * This command will delete the queue even if it has tasks in it.
   *
   * Note: If you delete a queue, a queue with the same name can't be created
   * for 7 days.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  deleteQueue(request: DeepPartial<DeleteQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Purges a queue by deleting all of its tasks.
   *
   * All tasks created before this method is called are permanently deleted.
   *
   * Purge operations can take up to one minute to take effect. Tasks
   * might be dispatched before the purge takes effect. A purge is irreversible.
   */
  purgeQueue(request: DeepPartial<PurgeQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Pauses the queue.
   *
   * If a queue is paused then the system will stop dispatching tasks
   * until the queue is resumed via
   * [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue]. Tasks can
   * still be added when the queue is paused. A queue is paused if its
   * [state][google.cloud.tasks.v2.Queue.state] is
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
   */
  pauseQueue(request: DeepPartial<PauseQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Resume a queue.
   *
   * This method resumes a queue after it has been
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED] or
   * [DISABLED][google.cloud.tasks.v2.Queue.State.DISABLED]. The state of a
   * queue is stored in the queue's [state][google.cloud.tasks.v2.Queue.state];
   * after calling this method it will be set to
   * [RUNNING][google.cloud.tasks.v2.Queue.State.RUNNING].
   *
   * WARNING: Resuming many high-QPS queues at the same time can
   * lead to target overloading. If you are resuming high-QPS
   * queues, follow the 500/50/5 pattern described in
   * [Managing Cloud Tasks Scaling
   * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
   */
  resumeQueue(request: DeepPartial<ResumeQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Gets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.getIamPolicy`
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy for a [Queue][google.cloud.tasks.v2.Queue].
   * Replaces any existing policy.
   *
   * Note: The Cloud Console does not check queue-level IAM permissions yet.
   * Project-level permissions are required to use the Cloud Console.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.setIamPolicy`
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on a
   * [Queue][google.cloud.tasks.v2.Queue]. If the resource does not exist, this
   * will return an empty set of permissions, not a
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /**
   * Lists the tasks in a queue.
   *
   * By default, only the [BASIC][google.cloud.tasks.v2.Task.View.BASIC] view is
   * retrieved due to performance considerations;
   * [response_view][google.cloud.tasks.v2.ListTasksRequest.response_view]
   * controls the subset of information which is returned.
   *
   * The tasks may be returned in any order. The ordering may change at any
   * time.
   */
  listTasks(request: DeepPartial<ListTasksRequest>, options?: CallOptions & CallOptionsExt): Promise<ListTasksResponse>;
  /** Gets a task. */
  getTask(request: DeepPartial<GetTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Creates a task and adds it to a queue.
   *
   * Tasks cannot be updated after creation; there is no UpdateTask command.
   *
   * * The maximum task size is 100KB.
   */
  createTask(request: DeepPartial<CreateTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Deletes a task.
   *
   * A task can be deleted if it is scheduled or dispatched. A task
   * cannot be deleted if it has executed successfully or permanently
   * failed.
   */
  deleteTask(request: DeepPartial<DeleteTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Forces a task to run now.
   *
   * When this method is called, Cloud Tasks will dispatch the task, even if
   * the task is already running, the queue has reached its
   * [RateLimits][google.cloud.tasks.v2.RateLimits] or is
   * [PAUSED][google.cloud.tasks.v2.Queue.State.PAUSED].
   *
   * This command is meant to be used for manual debugging. For
   * example, [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] can be used to
   * retry a failed task after a fix has been made or to manually force a task
   * to be dispatched now.
   *
   * The dispatched task is returned. That is, the task that is returned
   * contains the [status][Task.status] after the task is dispatched but
   * before the task is received by its target.
   *
   * If Cloud Tasks receives a successful response from the task's
   * target, then the task will be deleted; otherwise the task's
   * [schedule_time][google.cloud.tasks.v2.Task.schedule_time] will be reset to
   * the time that [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] was
   * called plus the retry delay specified in the queue's
   * [RetryConfig][google.cloud.tasks.v2.RetryConfig].
   *
   * [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask] returns
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
   * task that has already succeeded or permanently failed.
   */
  runTask(request: DeepPartial<RunTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
