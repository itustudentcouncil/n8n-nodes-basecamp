// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tasks/v2beta2/cloudtasks.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { HttpBody } from "../../../api/httpbody.js";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Queue } from "./queue.js";
import { Task, Task_View, task_ViewFromJSON, task_ViewToJSON } from "./task.js";

export const protobufPackage = "google.cloud.tasks.v2beta2";

/**
 * Request message for
 * [ListQueues][google.cloud.tasks.v2beta2.CloudTasks.ListQueues].
 */
export interface ListQueuesRequest {
  /**
   * Required. The location name.
   * For example: `projects/PROJECT_ID/locations/LOCATION_ID`
   */
  parent: string;
  /**
   * `filter` can be used to specify a subset of queues. Any
   * [Queue][google.cloud.tasks.v2beta2.Queue] field can be used as a filter and
   * several operators as supported. For example: `<=, <, >=, >, !=, =, :`. The
   * filter syntax is the same as described in [Stackdriver's Advanced Logs
   * Filters](https://cloud.google.com/logging/docs/view/advanced_filters).
   *
   * Sample filter "app_engine_http_target: *".
   *
   * Note that using filters might cause fewer queues than the
   * requested_page size to be returned.
   */
  filter: string;
  /**
   * Requested page size.
   *
   * The maximum page size is 9800. If unspecified, the page size will
   * be the maximum. Fewer queues than requested might be returned,
   * even if more queues exist; use the
   * [next_page_token][google.cloud.tasks.v2beta2.ListQueuesResponse.next_page_token]
   * in the response to determine if more queues exist.
   */
  pageSize: number;
  /**
   * A token identifying the page of results to return.
   *
   * To request the first page results, page_token must be empty. To
   * request the next page of results, page_token must be the value of
   * [next_page_token][google.cloud.tasks.v2beta2.ListQueuesResponse.next_page_token]
   * returned from the previous call to
   * [ListQueues][google.cloud.tasks.v2beta2.CloudTasks.ListQueues] method. It
   * is an error to switch the value of the
   * [filter][google.cloud.tasks.v2beta2.ListQueuesRequest.filter] while
   * iterating through pages.
   */
  pageToken: string;
  /**
   * Optional. Read mask is used for a more granular control over what the API
   * returns. If the mask is not present all fields will be returned except
   * [Queue.stats]. [Queue.stats] will be returned only if it was  explicitly
   * specified in the mask.
   */
  readMask: string[] | undefined;
}

/**
 * Response message for
 * [ListQueues][google.cloud.tasks.v2beta2.CloudTasks.ListQueues].
 */
export interface ListQueuesResponse {
  /** The list of queues. */
  queues: Queue[];
  /**
   * A token to retrieve next page of results.
   *
   * To return the next page of results, call
   * [ListQueues][google.cloud.tasks.v2beta2.CloudTasks.ListQueues] with this
   * value as the
   * [page_token][google.cloud.tasks.v2beta2.ListQueuesRequest.page_token].
   *
   * If the next_page_token is empty, there are no more results.
   *
   * The page token is valid for only 2 hours.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [GetQueue][google.cloud.tasks.v2beta2.CloudTasks.GetQueue].
 */
export interface GetQueueRequest {
  /**
   * Required. The resource name of the queue. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
  /**
   * Optional. Read mask is used for a more granular control over what the API
   * returns. If the mask is not present all fields will be returned except
   * [Queue.stats]. [Queue.stats] will be returned only if it was  explicitly
   * specified in the mask.
   */
  readMask: string[] | undefined;
}

/**
 * Request message for
 * [CreateQueue][google.cloud.tasks.v2beta2.CloudTasks.CreateQueue].
 */
export interface CreateQueueRequest {
  /**
   * Required. The location name in which the queue will be created.
   * For example: `projects/PROJECT_ID/locations/LOCATION_ID`
   *
   * The list of allowed locations can be obtained by calling Cloud
   * Tasks' implementation of
   * [ListLocations][google.cloud.location.Locations.ListLocations].
   */
  parent: string;
  /**
   * Required. The queue to create.
   *
   * [Queue's name][google.cloud.tasks.v2beta2.Queue.name] cannot be the same as
   * an existing queue.
   */
  queue: Queue | undefined;
}

/**
 * Request message for
 * [UpdateQueue][google.cloud.tasks.v2beta2.CloudTasks.UpdateQueue].
 */
export interface UpdateQueueRequest {
  /**
   * Required. The queue to create or update.
   *
   * The queue's [name][google.cloud.tasks.v2beta2.Queue.name] must be
   * specified.
   *
   * Output only fields cannot be modified using UpdateQueue.
   * Any value specified for an output only field will be ignored.
   * The queue's [name][google.cloud.tasks.v2beta2.Queue.name] cannot be
   * changed.
   */
  queue:
    | Queue
    | undefined;
  /**
   * A mask used to specify which fields of the queue are being updated.
   *
   * If empty, then all fields will be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [DeleteQueue][google.cloud.tasks.v2beta2.CloudTasks.DeleteQueue].
 */
export interface DeleteQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [PurgeQueue][google.cloud.tasks.v2beta2.CloudTasks.PurgeQueue].
 */
export interface PurgeQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [PauseQueue][google.cloud.tasks.v2beta2.CloudTasks.PauseQueue].
 */
export interface PauseQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [ResumeQueue][google.cloud.tasks.v2beta2.CloudTasks.ResumeQueue].
 */
export interface ResumeQueueRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
   */
  name: string;
}

/**
 * Request message for
 * [UploadQueueYaml][google.cloud.tasks.v2beta2.CloudTasks.UploadQueueYaml].
 */
export interface UploadQueueYamlRequest {
  /**
   * Required. The App ID is supplied as an HTTP parameter. Unlike internal
   * usage of App ID, it does not include a region prefix. Rather, the App ID
   * represents the Project ID against which to make the request.
   */
  appId: string;
  /** The http body contains the queue.yaml file which used to update queue lists */
  httpBody?: HttpBody | undefined;
}

/**
 * Request message for listing tasks using
 * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks].
 */
export interface ListTasksRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  parent: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
  /**
   * Maximum page size.
   *
   * Fewer tasks than requested might be returned, even if more tasks exist; use
   * [next_page_token][google.cloud.tasks.v2beta2.ListTasksResponse.next_page_token]
   * in the response to determine if more tasks exist.
   *
   * The maximum page size is 1000. If unspecified, the page size will be the
   * maximum.
   */
  pageSize: number;
  /**
   * A token identifying the page of results to return.
   *
   * To request the first page results, page_token must be empty. To
   * request the next page of results, page_token must be the value of
   * [next_page_token][google.cloud.tasks.v2beta2.ListTasksResponse.next_page_token]
   * returned from the previous call to
   * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks] method.
   *
   * The page token is valid for only 2 hours.
   */
  pageToken: string;
}

/**
 * Response message for listing tasks using
 * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks].
 */
export interface ListTasksResponse {
  /** The list of tasks. */
  tasks: Task[];
  /**
   * A token to retrieve next page of results.
   *
   * To return the next page of results, call
   * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks] with this
   * value as the
   * [page_token][google.cloud.tasks.v2beta2.ListTasksRequest.page_token].
   *
   * If the next_page_token is empty, there are no more results.
   */
  nextPageToken: string;
}

/**
 * Request message for getting a task using
 * [GetTask][google.cloud.tasks.v2beta2.CloudTasks.GetTask].
 */
export interface GetTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for
 * [CreateTask][google.cloud.tasks.v2beta2.CloudTasks.CreateTask].
 */
export interface CreateTaskRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   *
   * The queue must already exist.
   */
  parent: string;
  /**
   * Required. The task to add.
   *
   * Task names have the following format:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`.
   * The user can optionally specify a task
   * [name][google.cloud.tasks.v2beta2.Task.name]. If a name is not specified
   * then the system will generate a random unique task id, which will be set in
   * the task returned in the [response][google.cloud.tasks.v2beta2.Task.name].
   *
   * If [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] is not
   * set or is in the past then Cloud Tasks will set it to the current time.
   *
   * Task De-duplication:
   *
   * Explicitly specifying a task ID enables task de-duplication.  If
   * a task's ID is identical to that of an existing task or a task
   * that was deleted or completed recently then the call will fail
   * with [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS].
   * If the task's queue was created using Cloud Tasks, then another task with
   * the same name can't be created for ~1 hour after the original task was
   * deleted or completed. If the task's queue was created using queue.yaml or
   * queue.xml, then another task with the same name can't be created
   * for ~9 days after the original task was deleted or completed.
   *
   * Because there is an extra lookup cost to identify duplicate task
   * names, these [CreateTask][google.cloud.tasks.v2beta2.CloudTasks.CreateTask]
   * calls have significantly increased latency. Using hashed strings for the
   * task id or for the prefix of the task id is recommended. Choosing task ids
   * that are sequential or have sequential prefixes, for example using a
   * timestamp, causes an increase in latency and error rates in all
   * task commands. The infrastructure relies on an approximately
   * uniform distribution of task ids to store and serve tasks
   * efficiently.
   */
  task:
    | Task
    | undefined;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for deleting a task using
 * [DeleteTask][google.cloud.tasks.v2beta2.CloudTasks.DeleteTask].
 */
export interface DeleteTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
}

/**
 * Request message for leasing tasks using
 * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks].
 */
export interface LeaseTasksRequest {
  /**
   * Required. The queue name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
   */
  parent: string;
  /**
   * The maximum number of tasks to lease.
   *
   * The system will make a best effort to return as close to as
   * `max_tasks` as possible.
   *
   * The largest that `max_tasks` can be is 1000.
   *
   * The maximum total size of a [lease tasks
   * response][google.cloud.tasks.v2beta2.LeaseTasksResponse] is 32 MB. If the
   * sum of all task sizes requested reaches this limit, fewer tasks than
   * requested are returned.
   */
  maxTasks: number;
  /**
   * Required. The duration of the lease.
   *
   * Each task returned in the
   * [response][google.cloud.tasks.v2beta2.LeaseTasksResponse] will have its
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] set to the
   * current time plus the `lease_duration`. The task is leased until its
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time]; thus, the
   * task will not be returned to another
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] call before
   * its [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time].
   *
   * After the worker has successfully finished the work associated
   * with the task, the worker must call via
   * [AcknowledgeTask][google.cloud.tasks.v2beta2.CloudTasks.AcknowledgeTask]
   * before the [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time].
   * Otherwise the task will be returned to a later
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] call so that
   * another worker can retry it.
   *
   * The maximum lease duration is 1 week.
   * `lease_duration` will be truncated to the nearest second.
   */
  leaseDuration:
    | Duration
    | undefined;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
  /**
   * `filter` can be used to specify a subset of tasks to lease.
   *
   * When `filter` is set to `tag=<my-tag>` then the
   * [response][google.cloud.tasks.v2beta2.LeaseTasksResponse] will contain only
   * tasks whose [tag][google.cloud.tasks.v2beta2.PullMessage.tag] is equal to
   * `<my-tag>`. `<my-tag>` must be less than 500 characters.
   *
   * When `filter` is set to `tag_function=oldest_tag()`, only tasks which have
   * the same tag as the task with the oldest
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] will be
   * returned.
   *
   * Grammar Syntax:
   *
   * * `filter = "tag=" tag | "tag_function=" function`
   *
   * * `tag = string`
   *
   * * `function = "oldest_tag()"`
   *
   * The `oldest_tag()` function returns tasks which have the same tag as the
   * oldest task (ordered by schedule time).
   *
   * SDK compatibility: Although the SDK allows tags to be either
   * string or
   * [bytes](https://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/taskqueue/TaskOptions.html#tag-byte:A-),
   * only UTF-8 encoded tags can be used in Cloud Tasks. Tag which
   * aren't UTF-8 encoded can't be used in the
   * [filter][google.cloud.tasks.v2beta2.LeaseTasksRequest.filter] and the
   * task's [tag][google.cloud.tasks.v2beta2.PullMessage.tag] will be displayed
   * as empty in Cloud Tasks.
   */
  filter: string;
}

/**
 * Response message for leasing tasks using
 * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks].
 */
export interface LeaseTasksResponse {
  /** The leased tasks. */
  tasks: Task[];
}

/**
 * Request message for acknowledging a task using
 * [AcknowledgeTask][google.cloud.tasks.v2beta2.CloudTasks.AcknowledgeTask].
 */
export interface AcknowledgeTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * Required. The task's current schedule time, available in the
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] returned by
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] response or
   * [RenewLease][google.cloud.tasks.v2beta2.CloudTasks.RenewLease] response.
   * This restriction is to ensure that your worker currently holds the lease.
   */
  scheduleTime: Date | undefined;
}

/**
 * Request message for renewing a lease using
 * [RenewLease][google.cloud.tasks.v2beta2.CloudTasks.RenewLease].
 */
export interface RenewLeaseRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * Required. The task's current schedule time, available in the
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] returned by
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] response or
   * [RenewLease][google.cloud.tasks.v2beta2.CloudTasks.RenewLease] response.
   * This restriction is to ensure that your worker currently holds the lease.
   */
  scheduleTime:
    | Date
    | undefined;
  /**
   * Required. The desired new lease duration, starting from now.
   *
   * The maximum lease duration is 1 week.
   * `lease_duration` will be truncated to the nearest second.
   */
  leaseDuration:
    | Duration
    | undefined;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for canceling a lease using
 * [CancelLease][google.cloud.tasks.v2beta2.CloudTasks.CancelLease].
 */
export interface CancelLeaseRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * Required. The task's current schedule time, available in the
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] returned by
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] response or
   * [RenewLease][google.cloud.tasks.v2beta2.CloudTasks.RenewLease] response.
   * This restriction is to ensure that your worker currently holds the lease.
   */
  scheduleTime:
    | Date
    | undefined;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
}

/**
 * Request message for forcing a task to run now using
 * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask].
 */
export interface RunTaskRequest {
  /**
   * Required. The task name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
   */
  name: string;
  /**
   * The response_view specifies which subset of the
   * [Task][google.cloud.tasks.v2beta2.Task] will be returned.
   *
   * By default response_view is
   * [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]; not all information is
   * retrieved by default because some data, such as payloads, might be
   * desirable to return only when needed because of its large size or because
   * of the sensitivity of data that it contains.
   *
   * Authorization for [FULL][google.cloud.tasks.v2beta2.Task.View.FULL]
   * requires `cloudtasks.tasks.fullView` [Google
   * IAM](https://cloud.google.com/iam/) permission on the
   * [Task][google.cloud.tasks.v2beta2.Task] resource.
   */
  responseView: Task_View;
}

function createBaseListQueuesRequest(): ListQueuesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "", readMask: undefined };
}

export const ListQueuesRequest: MessageFns<ListQueuesRequest> = {
  encode(message: ListQueuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: ListQueuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuesRequest>): ListQueuesRequest {
    return ListQueuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuesRequest>): ListQueuesRequest {
    const message = createBaseListQueuesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseListQueuesResponse(): ListQueuesResponse {
  return { queues: [], nextPageToken: "" };
}

export const ListQueuesResponse: MessageFns<ListQueuesResponse> = {
  encode(message: ListQueuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queues) {
      Queue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queues.push(Queue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuesResponse {
    return {
      queues: globalThis.Array.isArray(object?.queues) ? object.queues.map((e: any) => Queue.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListQueuesResponse): unknown {
    const obj: any = {};
    if (message.queues?.length) {
      obj.queues = message.queues.map((e) => Queue.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuesResponse>): ListQueuesResponse {
    return ListQueuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuesResponse>): ListQueuesResponse {
    const message = createBaseListQueuesResponse();
    message.queues = object.queues?.map((e) => Queue.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetQueueRequest(): GetQueueRequest {
  return { name: "", readMask: undefined };
}

export const GetQueueRequest: MessageFns<GetQueueRequest> = {
  encode(message: GetQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueueRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: GetQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueueRequest>): GetQueueRequest {
    return GetQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueueRequest>): GetQueueRequest {
    const message = createBaseGetQueueRequest();
    message.name = object.name ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseCreateQueueRequest(): CreateQueueRequest {
  return { parent: "", queue: undefined };
}

export const CreateQueueRequest: MessageFns<CreateQueueRequest> = {
  encode(message: CreateQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.queue !== undefined) {
      Queue.encode(message.queue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queue = Queue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQueueRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      queue: isSet(object.queue) ? Queue.fromJSON(object.queue) : undefined,
    };
  },

  toJSON(message: CreateQueueRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.queue !== undefined) {
      obj.queue = Queue.toJSON(message.queue);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateQueueRequest>): CreateQueueRequest {
    return CreateQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateQueueRequest>): CreateQueueRequest {
    const message = createBaseCreateQueueRequest();
    message.parent = object.parent ?? "";
    message.queue = (object.queue !== undefined && object.queue !== null) ? Queue.fromPartial(object.queue) : undefined;
    return message;
  },
};

function createBaseUpdateQueueRequest(): UpdateQueueRequest {
  return { queue: undefined, updateMask: undefined };
}

export const UpdateQueueRequest: MessageFns<UpdateQueueRequest> = {
  encode(message: UpdateQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queue !== undefined) {
      Queue.encode(message.queue, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queue = Queue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateQueueRequest {
    return {
      queue: isSet(object.queue) ? Queue.fromJSON(object.queue) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateQueueRequest): unknown {
    const obj: any = {};
    if (message.queue !== undefined) {
      obj.queue = Queue.toJSON(message.queue);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateQueueRequest>): UpdateQueueRequest {
    return UpdateQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateQueueRequest>): UpdateQueueRequest {
    const message = createBaseUpdateQueueRequest();
    message.queue = (object.queue !== undefined && object.queue !== null) ? Queue.fromPartial(object.queue) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteQueueRequest(): DeleteQueueRequest {
  return { name: "" };
}

export const DeleteQueueRequest: MessageFns<DeleteQueueRequest> = {
  encode(message: DeleteQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteQueueRequest>): DeleteQueueRequest {
    return DeleteQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteQueueRequest>): DeleteQueueRequest {
    const message = createBaseDeleteQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePurgeQueueRequest(): PurgeQueueRequest {
  return { name: "" };
}

export const PurgeQueueRequest: MessageFns<PurgeQueueRequest> = {
  encode(message: PurgeQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PurgeQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeQueueRequest>): PurgeQueueRequest {
    return PurgeQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeQueueRequest>): PurgeQueueRequest {
    const message = createBasePurgeQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePauseQueueRequest(): PauseQueueRequest {
  return { name: "" };
}

export const PauseQueueRequest: MessageFns<PauseQueueRequest> = {
  encode(message: PauseQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PauseQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PauseQueueRequest>): PauseQueueRequest {
    return PauseQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseQueueRequest>): PauseQueueRequest {
    const message = createBasePauseQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResumeQueueRequest(): ResumeQueueRequest {
  return { name: "" };
}

export const ResumeQueueRequest: MessageFns<ResumeQueueRequest> = {
  encode(message: ResumeQueueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeQueueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeQueueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeQueueRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResumeQueueRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumeQueueRequest>): ResumeQueueRequest {
    return ResumeQueueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeQueueRequest>): ResumeQueueRequest {
    const message = createBaseResumeQueueRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUploadQueueYamlRequest(): UploadQueueYamlRequest {
  return { appId: "", httpBody: undefined };
}

export const UploadQueueYamlRequest: MessageFns<UploadQueueYamlRequest> = {
  encode(message: UploadQueueYamlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.httpBody !== undefined) {
      HttpBody.encode(message.httpBody, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadQueueYamlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadQueueYamlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.httpBody = HttpBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadQueueYamlRequest {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      httpBody: isSet(object.httpBody) ? HttpBody.fromJSON(object.httpBody) : undefined,
    };
  },

  toJSON(message: UploadQueueYamlRequest): unknown {
    const obj: any = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.httpBody !== undefined) {
      obj.httpBody = HttpBody.toJSON(message.httpBody);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadQueueYamlRequest>): UploadQueueYamlRequest {
    return UploadQueueYamlRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadQueueYamlRequest>): UploadQueueYamlRequest {
    const message = createBaseUploadQueueYamlRequest();
    message.appId = object.appId ?? "";
    message.httpBody = (object.httpBody !== undefined && object.httpBody !== null)
      ? HttpBody.fromPartial(object.httpBody)
      : undefined;
    return message;
  },
};

function createBaseListTasksRequest(): ListTasksRequest {
  return { parent: "", responseView: 0, pageSize: 0, pageToken: "" };
}

export const ListTasksRequest: MessageFns<ListTasksRequest> = {
  encode(message: ListTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTasksRequest>): ListTasksRequest {
    return ListTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTasksRequest>): ListTasksRequest {
    const message = createBaseListTasksRequest();
    message.parent = object.parent ?? "";
    message.responseView = object.responseView ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTasksResponse(): ListTasksResponse {
  return { tasks: [], nextPageToken: "" };
}

export const ListTasksResponse: MessageFns<ListTasksResponse> = {
  encode(message: ListTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksResponse {
    return {
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTasksResponse>): ListTasksResponse {
    return ListTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTasksResponse>): ListTasksResponse {
    const message = createBaseListTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { name: "", responseView: 0 };
}

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  encode(message: GetTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: GetTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTaskRequest>): GetTaskRequest {
    return GetTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTaskRequest>): GetTaskRequest {
    const message = createBaseGetTaskRequest();
    message.name = object.name ?? "";
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseCreateTaskRequest(): CreateTaskRequest {
  return { parent: "", task: undefined, responseView: 0 };
}

export const CreateTaskRequest: MessageFns<CreateTaskRequest> = {
  encode(message: CreateTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(18).fork()).join();
    }
    if (message.responseView !== 0) {
      writer.uint32(24).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: CreateTaskRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskRequest>): CreateTaskRequest {
    return CreateTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskRequest>): CreateTaskRequest {
    const message = createBaseCreateTaskRequest();
    message.parent = object.parent ?? "";
    message.task = (object.task !== undefined && object.task !== null) ? Task.fromPartial(object.task) : undefined;
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseDeleteTaskRequest(): DeleteTaskRequest {
  return { name: "" };
}

export const DeleteTaskRequest: MessageFns<DeleteTaskRequest> = {
  encode(message: DeleteTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTaskRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTaskRequest>): DeleteTaskRequest {
    return DeleteTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTaskRequest>): DeleteTaskRequest {
    const message = createBaseDeleteTaskRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLeaseTasksRequest(): LeaseTasksRequest {
  return { parent: "", maxTasks: 0, leaseDuration: undefined, responseView: 0, filter: "" };
}

export const LeaseTasksRequest: MessageFns<LeaseTasksRequest> = {
  encode(message: LeaseTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.maxTasks !== 0) {
      writer.uint32(16).int32(message.maxTasks);
    }
    if (message.leaseDuration !== undefined) {
      Duration.encode(message.leaseDuration, writer.uint32(26).fork()).join();
    }
    if (message.responseView !== 0) {
      writer.uint32(32).int32(message.responseView);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaseTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaseTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTasks = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaseDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaseTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      maxTasks: isSet(object.maxTasks) ? globalThis.Number(object.maxTasks) : 0,
      leaseDuration: isSet(object.leaseDuration) ? Duration.fromJSON(object.leaseDuration) : undefined,
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: LeaseTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.maxTasks !== 0) {
      obj.maxTasks = Math.round(message.maxTasks);
    }
    if (message.leaseDuration !== undefined) {
      obj.leaseDuration = Duration.toJSON(message.leaseDuration);
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<LeaseTasksRequest>): LeaseTasksRequest {
    return LeaseTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaseTasksRequest>): LeaseTasksRequest {
    const message = createBaseLeaseTasksRequest();
    message.parent = object.parent ?? "";
    message.maxTasks = object.maxTasks ?? 0;
    message.leaseDuration = (object.leaseDuration !== undefined && object.leaseDuration !== null)
      ? Duration.fromPartial(object.leaseDuration)
      : undefined;
    message.responseView = object.responseView ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseLeaseTasksResponse(): LeaseTasksResponse {
  return { tasks: [] };
}

export const LeaseTasksResponse: MessageFns<LeaseTasksResponse> = {
  encode(message: LeaseTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaseTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaseTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaseTasksResponse {
    return { tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [] };
  },

  toJSON(message: LeaseTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LeaseTasksResponse>): LeaseTasksResponse {
    return LeaseTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaseTasksResponse>): LeaseTasksResponse {
    const message = createBaseLeaseTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAcknowledgeTaskRequest(): AcknowledgeTaskRequest {
  return { name: "", scheduleTime: undefined };
}

export const AcknowledgeTaskRequest: MessageFns<AcknowledgeTaskRequest> = {
  encode(message: AcknowledgeTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
    };
  },

  toJSON(message: AcknowledgeTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AcknowledgeTaskRequest>): AcknowledgeTaskRequest {
    return AcknowledgeTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcknowledgeTaskRequest>): AcknowledgeTaskRequest {
    const message = createBaseAcknowledgeTaskRequest();
    message.name = object.name ?? "";
    message.scheduleTime = object.scheduleTime ?? undefined;
    return message;
  },
};

function createBaseRenewLeaseRequest(): RenewLeaseRequest {
  return { name: "", scheduleTime: undefined, leaseDuration: undefined, responseView: 0 };
}

export const RenewLeaseRequest: MessageFns<RenewLeaseRequest> = {
  encode(message: RenewLeaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(18).fork()).join();
    }
    if (message.leaseDuration !== undefined) {
      Duration.encode(message.leaseDuration, writer.uint32(26).fork()).join();
    }
    if (message.responseView !== 0) {
      writer.uint32(32).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewLeaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaseDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewLeaseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      leaseDuration: isSet(object.leaseDuration) ? Duration.fromJSON(object.leaseDuration) : undefined,
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: RenewLeaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.leaseDuration !== undefined) {
      obj.leaseDuration = Duration.toJSON(message.leaseDuration);
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewLeaseRequest>): RenewLeaseRequest {
    return RenewLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewLeaseRequest>): RenewLeaseRequest {
    const message = createBaseRenewLeaseRequest();
    message.name = object.name ?? "";
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.leaseDuration = (object.leaseDuration !== undefined && object.leaseDuration !== null)
      ? Duration.fromPartial(object.leaseDuration)
      : undefined;
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseCancelLeaseRequest(): CancelLeaseRequest {
  return { name: "", scheduleTime: undefined, responseView: 0 };
}

export const CancelLeaseRequest: MessageFns<CancelLeaseRequest> = {
  encode(message: CancelLeaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(18).fork()).join();
    }
    if (message.responseView !== 0) {
      writer.uint32(24).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelLeaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelLeaseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: CancelLeaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelLeaseRequest>): CancelLeaseRequest {
    return CancelLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelLeaseRequest>): CancelLeaseRequest {
    const message = createBaseCancelLeaseRequest();
    message.name = object.name ?? "";
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

function createBaseRunTaskRequest(): RunTaskRequest {
  return { name: "", responseView: 0 };
}

export const RunTaskRequest: MessageFns<RunTaskRequest> = {
  encode(message: RunTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.responseView !== 0) {
      writer.uint32(16).int32(message.responseView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.responseView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      responseView: isSet(object.responseView) ? task_ViewFromJSON(object.responseView) : 0,
    };
  },

  toJSON(message: RunTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.responseView !== 0) {
      obj.responseView = task_ViewToJSON(message.responseView);
    }
    return obj;
  },

  create(base?: DeepPartial<RunTaskRequest>): RunTaskRequest {
    return RunTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunTaskRequest>): RunTaskRequest {
    const message = createBaseRunTaskRequest();
    message.name = object.name ?? "";
    message.responseView = object.responseView ?? 0;
    return message;
  },
};

/**
 * Cloud Tasks allows developers to manage the execution of background
 * work in their applications.
 */
export type CloudTasksDefinition = typeof CloudTasksDefinition;
export const CloudTasksDefinition = {
  name: "CloudTasks",
  fullName: "google.cloud.tasks.v2beta2.CloudTasks",
  methods: {
    /**
     * Lists queues.
     *
     * Queues are returned in lexicographical order.
     */
    listQueues: {
      name: "ListQueues",
      requestType: ListQueuesRequest,
      requestStream: false,
      responseType: ListQueuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a queue. */
    getQueue: {
      name: "GetQueue",
      requestType: GetQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a queue.
     *
     * Queues created with this method allow tasks to live for a maximum of 31
     * days. After a task is 31 days old, the task will be deleted regardless of
     * whether it was dispatched or not.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    createQueue: {
      name: "CreateQueue",
      requestType: CreateQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 117, 101])],
          578365826: [
            Buffer.from([
              56,
              58,
              5,
              113,
              117,
              101,
              117,
              101,
              34,
              47,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a queue.
     *
     * This method creates the queue if it does not exist and updates
     * the queue if it does exist.
     *
     * Queues created with this method allow tasks to live for a maximum of 31
     * days. After a task is 31 days old, the task will be deleted regardless of
     * whether it was dispatched or not.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    updateQueue: {
      name: "UpdateQueue",
      requestType: UpdateQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 113, 117, 101, 117, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              62,
              58,
              5,
              113,
              117,
              101,
              117,
              101,
              50,
              53,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              113,
              117,
              101,
              117,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a queue.
     *
     * This command will delete the queue even if it has tasks in it.
     *
     * Note: If you delete a queue, a queue with the same name can't be created
     * for 7 days.
     *
     * WARNING: Using this method may have unintended side effects if you are
     * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
     * Read
     * [Overview of Queue Management and
     * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
     * this method.
     */
    deleteQueue: {
      name: "DeleteQueue",
      requestType: DeleteQueueRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Purges a queue by deleting all of its tasks.
     *
     * All tasks created before this method is called are permanently deleted.
     *
     * Purge operations can take up to one minute to take effect. Tasks
     * might be dispatched before the purge takes effect. A purge is irreversible.
     */
    purgeQueue: {
      name: "PurgeQueue",
      requestType: PurgeQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              112,
              117,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Pauses the queue.
     *
     * If a queue is paused then the system will stop dispatching tasks
     * until the queue is resumed via
     * [ResumeQueue][google.cloud.tasks.v2beta2.CloudTasks.ResumeQueue]. Tasks can
     * still be added when the queue is paused. A queue is paused if its
     * [state][google.cloud.tasks.v2beta2.Queue.state] is
     * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
     */
    pauseQueue: {
      name: "PauseQueue",
      requestType: PauseQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              112,
              97,
              117,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Resume a queue.
     *
     * This method resumes a queue after it has been
     * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED] or
     * [DISABLED][google.cloud.tasks.v2beta2.Queue.State.DISABLED]. The state of a
     * queue is stored in the queue's
     * [state][google.cloud.tasks.v2beta2.Queue.state]; after calling this method
     * it will be set to
     * [RUNNING][google.cloud.tasks.v2beta2.Queue.State.RUNNING].
     *
     * WARNING: Resuming many high-QPS queues at the same time can
     * lead to target overloading. If you are resuming high-QPS
     * queues, follow the 500/50/5 pattern described in
     * [Managing Cloud Tasks Scaling
     * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
     */
    resumeQueue: {
      name: "ResumeQueue",
      requestType: ResumeQueueRequest,
      requestStream: false,
      responseType: Queue,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              117,
              109,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Update queue list by uploading a queue.yaml file.
     *
     * The queue.yaml file is supplied in the request body as a YAML encoded
     * string. This method was added to support gcloud clients versions before
     * 322.0.0. New clients should use CreateQueue instead of this method.
     */
    uploadQueueYaml: {
      name: "UploadQueueYaml",
      requestType: UploadQueueYamlRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Gets the access control policy for a
     * [Queue][google.cloud.tasks.v2beta2.Queue]. Returns an empty policy if the
     * resource exists and does not have a policy set.
     *
     * Authorization requires the following
     * [Google IAM](https://cloud.google.com/iam) permission on the specified
     * resource parent:
     *
     * * `cloudtasks.queues.getIamPolicy`
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy for a
     * [Queue][google.cloud.tasks.v2beta2.Queue]. Replaces any existing policy.
     *
     * Note: The Cloud Console does not check queue-level IAM permissions yet.
     * Project-level permissions are required to use the Cloud Console.
     *
     * Authorization requires the following
     * [Google IAM](https://cloud.google.com/iam) permission on the specified
     * resource parent:
     *
     * * `cloudtasks.queues.setIamPolicy`
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on a
     * [Queue][google.cloud.tasks.v2beta2.Queue]. If the resource does not exist,
     * this will return an empty set of permissions, not a
     * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
     *
     * Note: This operation is designed to be used for building permission-aware
     * UIs and command-line tools, not for authorization checking. This operation
     * may "fail open" without warning.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the tasks in a queue.
     *
     * By default, only the [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]
     * view is retrieved due to performance considerations;
     * [response_view][google.cloud.tasks.v2beta2.ListTasksRequest.response_view]
     * controls the subset of information which is returned.
     *
     * The tasks may be returned in any order. The ordering may change at any
     * time.
     */
    listTasks: {
      name: "ListTasks",
      requestType: ListTasksRequest,
      requestStream: false,
      responseType: ListTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a task. */
    getTask: {
      name: "GetTask",
      requestType: GetTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a task and adds it to a queue.
     *
     * Tasks cannot be updated after creation; there is no UpdateTask command.
     *
     * * For [App Engine queues][google.cloud.tasks.v2beta2.AppEngineHttpTarget],
     * the maximum task size is
     *   100KB.
     * * For [pull queues][google.cloud.tasks.v2beta2.PullTarget], the maximum
     * task size is 1MB.
     */
    createTask: {
      name: "CreateTask",
      requestType: CreateTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 116, 97, 115, 107])],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a task.
     *
     * A task can be deleted if it is scheduled or dispatched. A task
     * cannot be deleted if it has completed successfully or permanently
     * failed.
     */
    deleteTask: {
      name: "DeleteTask",
      requestType: DeleteTaskRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              42,
              55,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Leases tasks from a pull queue for
     * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration].
     *
     * This method is invoked by the worker to obtain a lease. The
     * worker must acknowledge the task via
     * [AcknowledgeTask][google.cloud.tasks.v2beta2.CloudTasks.AcknowledgeTask]
     * after they have performed the work associated with the task.
     *
     * The [payload][google.cloud.tasks.v2beta2.PullMessage.payload] is intended
     * to store data that the worker needs to perform the work associated with the
     * task. To return the payloads in the
     * [response][google.cloud.tasks.v2beta2.LeaseTasksResponse], set
     * [response_view][google.cloud.tasks.v2beta2.LeaseTasksRequest.response_view]
     * to [FULL][google.cloud.tasks.v2beta2.Task.View.FULL].
     *
     * A maximum of 10 qps of
     * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] requests are
     * allowed per queue. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
     * is returned when this limit is
     * exceeded. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
     * is also returned when
     * [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second]
     * is exceeded.
     */
    leaseTasks: {
      name: "LeaseTasks",
      requestType: LeaseTasksRequest,
      requestStream: false,
      responseType: LeaseTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              108,
              101,
              97,
              115,
              101,
              95,
              100,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
              58,
              108,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Acknowledges a pull task.
     *
     * The worker, that is, the entity that
     * [leased][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] this task must
     * call this method to indicate that the work associated with the task has
     * finished.
     *
     * The worker must acknowledge a task within the
     * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration]
     * or the lease will expire and the task will become available to be leased
     * again. After the task is acknowledged, it will not be returned
     * by a later [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks],
     * [GetTask][google.cloud.tasks.v2beta2.CloudTasks.GetTask], or
     * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks].
     */
    acknowledgeTask: {
      name: "AcknowledgeTask",
      requestType: AcknowledgeTaskRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 110, 97, 109, 101, 44, 115, 99, 104, 101, 100, 117, 108, 101, 95, 116, 105, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              97,
              99,
              107,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Renew the current lease of a pull task.
     *
     * The worker can use this method to extend the lease by a new
     * duration, starting from now. The new task lease will be
     * returned in the task's
     * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time].
     */
    renewLease: {
      name: "RenewLease",
      requestType: RenewLeaseRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              110,
              97,
              109,
              101,
              44,
              115,
              99,
              104,
              101,
              100,
              117,
              108,
              101,
              95,
              116,
              105,
              109,
              101,
              44,
              108,
              101,
              97,
              115,
              101,
              95,
              100,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              110,
              101,
              119,
              76,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Cancel a pull task's lease.
     *
     * The worker can use this method to cancel a task's lease by
     * setting its [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time]
     * to now. This will make the task available to be leased to the next caller
     * of [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks].
     */
    cancelLease: {
      name: "CancelLease",
      requestType: CancelLeaseRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 110, 97, 109, 101, 44, 115, 99, 104, 101, 100, 117, 108, 101, 95, 116, 105, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
              76,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Forces a task to run now.
     *
     * When this method is called, Cloud Tasks will dispatch the task, even if
     * the task is already running, the queue has reached its
     * [RateLimits][google.cloud.tasks.v2beta2.RateLimits] or is
     * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
     *
     * This command is meant to be used for manual debugging. For
     * example, [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] can be
     * used to retry a failed task after a fix has been made or to manually force
     * a task to be dispatched now.
     *
     * The dispatched task is returned. That is, the task that is returned
     * contains the [status][google.cloud.tasks.v2beta2.Task.status] after the
     * task is dispatched but before the task is received by its target.
     *
     * If Cloud Tasks receives a successful response from the task's
     * target, then the task will be deleted; otherwise the task's
     * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] will be
     * reset to the time that
     * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] was called plus
     * the retry delay specified in the queue's
     * [RetryConfig][google.cloud.tasks.v2beta2.RetryConfig].
     *
     * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] returns
     * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
     * task that has already succeeded or permanently failed.
     *
     * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] cannot be called
     * on a [pull task][google.cloud.tasks.v2beta2.PullMessage].
     */
    runTask: {
      name: "RunTask",
      requestType: RunTaskRequest,
      requestStream: false,
      responseType: Task,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudTasksServiceImplementation<CallContextExt = {}> {
  /**
   * Lists queues.
   *
   * Queues are returned in lexicographical order.
   */
  listQueues(
    request: ListQueuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListQueuesResponse>>;
  /** Gets a queue. */
  getQueue(request: GetQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Creates a queue.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  createQueue(request: CreateQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Updates a queue.
   *
   * This method creates the queue if it does not exist and updates
   * the queue if it does exist.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  updateQueue(request: UpdateQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Deletes a queue.
   *
   * This command will delete the queue even if it has tasks in it.
   *
   * Note: If you delete a queue, a queue with the same name can't be created
   * for 7 days.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  deleteQueue(request: DeleteQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Purges a queue by deleting all of its tasks.
   *
   * All tasks created before this method is called are permanently deleted.
   *
   * Purge operations can take up to one minute to take effect. Tasks
   * might be dispatched before the purge takes effect. A purge is irreversible.
   */
  purgeQueue(request: PurgeQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Pauses the queue.
   *
   * If a queue is paused then the system will stop dispatching tasks
   * until the queue is resumed via
   * [ResumeQueue][google.cloud.tasks.v2beta2.CloudTasks.ResumeQueue]. Tasks can
   * still be added when the queue is paused. A queue is paused if its
   * [state][google.cloud.tasks.v2beta2.Queue.state] is
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
   */
  pauseQueue(request: PauseQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Resume a queue.
   *
   * This method resumes a queue after it has been
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED] or
   * [DISABLED][google.cloud.tasks.v2beta2.Queue.State.DISABLED]. The state of a
   * queue is stored in the queue's
   * [state][google.cloud.tasks.v2beta2.Queue.state]; after calling this method
   * it will be set to
   * [RUNNING][google.cloud.tasks.v2beta2.Queue.State.RUNNING].
   *
   * WARNING: Resuming many high-QPS queues at the same time can
   * lead to target overloading. If you are resuming high-QPS
   * queues, follow the 500/50/5 pattern described in
   * [Managing Cloud Tasks Scaling
   * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
   */
  resumeQueue(request: ResumeQueueRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Queue>>;
  /**
   * Update queue list by uploading a queue.yaml file.
   *
   * The queue.yaml file is supplied in the request body as a YAML encoded
   * string. This method was added to support gcloud clients versions before
   * 322.0.0. New clients should use CreateQueue instead of this method.
   */
  uploadQueueYaml(request: UploadQueueYamlRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Gets the access control policy for a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. Returns an empty policy if the
   * resource exists and does not have a policy set.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.getIamPolicy`
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy for a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. Replaces any existing policy.
   *
   * Note: The Cloud Console does not check queue-level IAM permissions yet.
   * Project-level permissions are required to use the Cloud Console.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.setIamPolicy`
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. If the resource does not exist,
   * this will return an empty set of permissions, not a
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /**
   * Lists the tasks in a queue.
   *
   * By default, only the [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]
   * view is retrieved due to performance considerations;
   * [response_view][google.cloud.tasks.v2beta2.ListTasksRequest.response_view]
   * controls the subset of information which is returned.
   *
   * The tasks may be returned in any order. The ordering may change at any
   * time.
   */
  listTasks(request: ListTasksRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListTasksResponse>>;
  /** Gets a task. */
  getTask(request: GetTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Creates a task and adds it to a queue.
   *
   * Tasks cannot be updated after creation; there is no UpdateTask command.
   *
   * * For [App Engine queues][google.cloud.tasks.v2beta2.AppEngineHttpTarget],
   * the maximum task size is
   *   100KB.
   * * For [pull queues][google.cloud.tasks.v2beta2.PullTarget], the maximum
   * task size is 1MB.
   */
  createTask(request: CreateTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Deletes a task.
   *
   * A task can be deleted if it is scheduled or dispatched. A task
   * cannot be deleted if it has completed successfully or permanently
   * failed.
   */
  deleteTask(request: DeleteTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Leases tasks from a pull queue for
   * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration].
   *
   * This method is invoked by the worker to obtain a lease. The
   * worker must acknowledge the task via
   * [AcknowledgeTask][google.cloud.tasks.v2beta2.CloudTasks.AcknowledgeTask]
   * after they have performed the work associated with the task.
   *
   * The [payload][google.cloud.tasks.v2beta2.PullMessage.payload] is intended
   * to store data that the worker needs to perform the work associated with the
   * task. To return the payloads in the
   * [response][google.cloud.tasks.v2beta2.LeaseTasksResponse], set
   * [response_view][google.cloud.tasks.v2beta2.LeaseTasksRequest.response_view]
   * to [FULL][google.cloud.tasks.v2beta2.Task.View.FULL].
   *
   * A maximum of 10 qps of
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] requests are
   * allowed per queue. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
   * is returned when this limit is
   * exceeded. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
   * is also returned when
   * [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second]
   * is exceeded.
   */
  leaseTasks(
    request: LeaseTasksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LeaseTasksResponse>>;
  /**
   * Acknowledges a pull task.
   *
   * The worker, that is, the entity that
   * [leased][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] this task must
   * call this method to indicate that the work associated with the task has
   * finished.
   *
   * The worker must acknowledge a task within the
   * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration]
   * or the lease will expire and the task will become available to be leased
   * again. After the task is acknowledged, it will not be returned
   * by a later [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks],
   * [GetTask][google.cloud.tasks.v2beta2.CloudTasks.GetTask], or
   * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks].
   */
  acknowledgeTask(request: AcknowledgeTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Renew the current lease of a pull task.
   *
   * The worker can use this method to extend the lease by a new
   * duration, starting from now. The new task lease will be
   * returned in the task's
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time].
   */
  renewLease(request: RenewLeaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Cancel a pull task's lease.
   *
   * The worker can use this method to cancel a task's lease by
   * setting its [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time]
   * to now. This will make the task available to be leased to the next caller
   * of [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks].
   */
  cancelLease(request: CancelLeaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
  /**
   * Forces a task to run now.
   *
   * When this method is called, Cloud Tasks will dispatch the task, even if
   * the task is already running, the queue has reached its
   * [RateLimits][google.cloud.tasks.v2beta2.RateLimits] or is
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
   *
   * This command is meant to be used for manual debugging. For
   * example, [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] can be
   * used to retry a failed task after a fix has been made or to manually force
   * a task to be dispatched now.
   *
   * The dispatched task is returned. That is, the task that is returned
   * contains the [status][google.cloud.tasks.v2beta2.Task.status] after the
   * task is dispatched but before the task is received by its target.
   *
   * If Cloud Tasks receives a successful response from the task's
   * target, then the task will be deleted; otherwise the task's
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] will be
   * reset to the time that
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] was called plus
   * the retry delay specified in the queue's
   * [RetryConfig][google.cloud.tasks.v2beta2.RetryConfig].
   *
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] returns
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
   * task that has already succeeded or permanently failed.
   *
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] cannot be called
   * on a [pull task][google.cloud.tasks.v2beta2.PullMessage].
   */
  runTask(request: RunTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Task>>;
}

export interface CloudTasksClient<CallOptionsExt = {}> {
  /**
   * Lists queues.
   *
   * Queues are returned in lexicographical order.
   */
  listQueues(
    request: DeepPartial<ListQueuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListQueuesResponse>;
  /** Gets a queue. */
  getQueue(request: DeepPartial<GetQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Creates a queue.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  createQueue(request: DeepPartial<CreateQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Updates a queue.
   *
   * This method creates the queue if it does not exist and updates
   * the queue if it does exist.
   *
   * Queues created with this method allow tasks to live for a maximum of 31
   * days. After a task is 31 days old, the task will be deleted regardless of
   * whether it was dispatched or not.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  updateQueue(request: DeepPartial<UpdateQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Deletes a queue.
   *
   * This command will delete the queue even if it has tasks in it.
   *
   * Note: If you delete a queue, a queue with the same name can't be created
   * for 7 days.
   *
   * WARNING: Using this method may have unintended side effects if you are
   * using an App Engine `queue.yaml` or `queue.xml` file to manage your queues.
   * Read
   * [Overview of Queue Management and
   * queue.yaml](https://cloud.google.com/tasks/docs/queue-yaml) before using
   * this method.
   */
  deleteQueue(request: DeepPartial<DeleteQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Purges a queue by deleting all of its tasks.
   *
   * All tasks created before this method is called are permanently deleted.
   *
   * Purge operations can take up to one minute to take effect. Tasks
   * might be dispatched before the purge takes effect. A purge is irreversible.
   */
  purgeQueue(request: DeepPartial<PurgeQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Pauses the queue.
   *
   * If a queue is paused then the system will stop dispatching tasks
   * until the queue is resumed via
   * [ResumeQueue][google.cloud.tasks.v2beta2.CloudTasks.ResumeQueue]. Tasks can
   * still be added when the queue is paused. A queue is paused if its
   * [state][google.cloud.tasks.v2beta2.Queue.state] is
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
   */
  pauseQueue(request: DeepPartial<PauseQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Resume a queue.
   *
   * This method resumes a queue after it has been
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED] or
   * [DISABLED][google.cloud.tasks.v2beta2.Queue.State.DISABLED]. The state of a
   * queue is stored in the queue's
   * [state][google.cloud.tasks.v2beta2.Queue.state]; after calling this method
   * it will be set to
   * [RUNNING][google.cloud.tasks.v2beta2.Queue.State.RUNNING].
   *
   * WARNING: Resuming many high-QPS queues at the same time can
   * lead to target overloading. If you are resuming high-QPS
   * queues, follow the 500/50/5 pattern described in
   * [Managing Cloud Tasks Scaling
   * Risks](https://cloud.google.com/tasks/docs/manage-cloud-task-scaling).
   */
  resumeQueue(request: DeepPartial<ResumeQueueRequest>, options?: CallOptions & CallOptionsExt): Promise<Queue>;
  /**
   * Update queue list by uploading a queue.yaml file.
   *
   * The queue.yaml file is supplied in the request body as a YAML encoded
   * string. This method was added to support gcloud clients versions before
   * 322.0.0. New clients should use CreateQueue instead of this method.
   */
  uploadQueueYaml(request: DeepPartial<UploadQueueYamlRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Gets the access control policy for a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. Returns an empty policy if the
   * resource exists and does not have a policy set.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.getIamPolicy`
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy for a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. Replaces any existing policy.
   *
   * Note: The Cloud Console does not check queue-level IAM permissions yet.
   * Project-level permissions are required to use the Cloud Console.
   *
   * Authorization requires the following
   * [Google IAM](https://cloud.google.com/iam) permission on the specified
   * resource parent:
   *
   * * `cloudtasks.queues.setIamPolicy`
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on a
   * [Queue][google.cloud.tasks.v2beta2.Queue]. If the resource does not exist,
   * this will return an empty set of permissions, not a
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /**
   * Lists the tasks in a queue.
   *
   * By default, only the [BASIC][google.cloud.tasks.v2beta2.Task.View.BASIC]
   * view is retrieved due to performance considerations;
   * [response_view][google.cloud.tasks.v2beta2.ListTasksRequest.response_view]
   * controls the subset of information which is returned.
   *
   * The tasks may be returned in any order. The ordering may change at any
   * time.
   */
  listTasks(request: DeepPartial<ListTasksRequest>, options?: CallOptions & CallOptionsExt): Promise<ListTasksResponse>;
  /** Gets a task. */
  getTask(request: DeepPartial<GetTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Creates a task and adds it to a queue.
   *
   * Tasks cannot be updated after creation; there is no UpdateTask command.
   *
   * * For [App Engine queues][google.cloud.tasks.v2beta2.AppEngineHttpTarget],
   * the maximum task size is
   *   100KB.
   * * For [pull queues][google.cloud.tasks.v2beta2.PullTarget], the maximum
   * task size is 1MB.
   */
  createTask(request: DeepPartial<CreateTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Deletes a task.
   *
   * A task can be deleted if it is scheduled or dispatched. A task
   * cannot be deleted if it has completed successfully or permanently
   * failed.
   */
  deleteTask(request: DeepPartial<DeleteTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Leases tasks from a pull queue for
   * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration].
   *
   * This method is invoked by the worker to obtain a lease. The
   * worker must acknowledge the task via
   * [AcknowledgeTask][google.cloud.tasks.v2beta2.CloudTasks.AcknowledgeTask]
   * after they have performed the work associated with the task.
   *
   * The [payload][google.cloud.tasks.v2beta2.PullMessage.payload] is intended
   * to store data that the worker needs to perform the work associated with the
   * task. To return the payloads in the
   * [response][google.cloud.tasks.v2beta2.LeaseTasksResponse], set
   * [response_view][google.cloud.tasks.v2beta2.LeaseTasksRequest.response_view]
   * to [FULL][google.cloud.tasks.v2beta2.Task.View.FULL].
   *
   * A maximum of 10 qps of
   * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] requests are
   * allowed per queue. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
   * is returned when this limit is
   * exceeded. [RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED]
   * is also returned when
   * [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second]
   * is exceeded.
   */
  leaseTasks(
    request: DeepPartial<LeaseTasksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LeaseTasksResponse>;
  /**
   * Acknowledges a pull task.
   *
   * The worker, that is, the entity that
   * [leased][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] this task must
   * call this method to indicate that the work associated with the task has
   * finished.
   *
   * The worker must acknowledge a task within the
   * [lease_duration][google.cloud.tasks.v2beta2.LeaseTasksRequest.lease_duration]
   * or the lease will expire and the task will become available to be leased
   * again. After the task is acknowledged, it will not be returned
   * by a later [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks],
   * [GetTask][google.cloud.tasks.v2beta2.CloudTasks.GetTask], or
   * [ListTasks][google.cloud.tasks.v2beta2.CloudTasks.ListTasks].
   */
  acknowledgeTask(request: DeepPartial<AcknowledgeTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Renew the current lease of a pull task.
   *
   * The worker can use this method to extend the lease by a new
   * duration, starting from now. The new task lease will be
   * returned in the task's
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time].
   */
  renewLease(request: DeepPartial<RenewLeaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Cancel a pull task's lease.
   *
   * The worker can use this method to cancel a task's lease by
   * setting its [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time]
   * to now. This will make the task available to be leased to the next caller
   * of [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks].
   */
  cancelLease(request: DeepPartial<CancelLeaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
  /**
   * Forces a task to run now.
   *
   * When this method is called, Cloud Tasks will dispatch the task, even if
   * the task is already running, the queue has reached its
   * [RateLimits][google.cloud.tasks.v2beta2.RateLimits] or is
   * [PAUSED][google.cloud.tasks.v2beta2.Queue.State.PAUSED].
   *
   * This command is meant to be used for manual debugging. For
   * example, [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] can be
   * used to retry a failed task after a fix has been made or to manually force
   * a task to be dispatched now.
   *
   * The dispatched task is returned. That is, the task that is returned
   * contains the [status][google.cloud.tasks.v2beta2.Task.status] after the
   * task is dispatched but before the task is received by its target.
   *
   * If Cloud Tasks receives a successful response from the task's
   * target, then the task will be deleted; otherwise the task's
   * [schedule_time][google.cloud.tasks.v2beta2.Task.schedule_time] will be
   * reset to the time that
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] was called plus
   * the retry delay specified in the queue's
   * [RetryConfig][google.cloud.tasks.v2beta2.RetryConfig].
   *
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] returns
   * [NOT_FOUND][google.rpc.Code.NOT_FOUND] when it is called on a
   * task that has already succeeded or permanently failed.
   *
   * [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask] cannot be called
   * on a [pull task][google.cloud.tasks.v2beta2.PullMessage].
   */
  runTask(request: DeepPartial<RunTaskRequest>, options?: CallOptions & CallOptionsExt): Promise<Task>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
