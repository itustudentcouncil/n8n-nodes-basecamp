// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/sql/v1/cloud_sql_backup_runs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DiskEncryptionConfiguration, DiskEncryptionStatus, Operation, OperationError } from "./cloud_sql_resources.js";

export const protobufPackage = "google.cloud.sql.v1";

/** The status of a backup run. */
export enum SqlBackupRunStatus {
  /** SQL_BACKUP_RUN_STATUS_UNSPECIFIED - The status of the run is unknown. */
  SQL_BACKUP_RUN_STATUS_UNSPECIFIED = 0,
  /** ENQUEUED - The backup operation was enqueued. */
  ENQUEUED = 1,
  /**
   * OVERDUE - The backup is overdue across a given backup window. Indicates a
   * problem. Example: Long-running operation in progress during
   * the whole window.
   */
  OVERDUE = 2,
  /** RUNNING - The backup is in progress. */
  RUNNING = 3,
  /** FAILED - The backup failed. */
  FAILED = 4,
  /** SUCCESSFUL - The backup was successful. */
  SUCCESSFUL = 5,
  /**
   * SKIPPED - The backup was skipped (without problems) for a given backup
   * window. Example: Instance was idle.
   */
  SKIPPED = 6,
  /** DELETION_PENDING - The backup is about to be deleted. */
  DELETION_PENDING = 7,
  /** DELETION_FAILED - The backup deletion failed. */
  DELETION_FAILED = 8,
  /** DELETED - The backup has been deleted. */
  DELETED = 9,
  UNRECOGNIZED = -1,
}

export function sqlBackupRunStatusFromJSON(object: any): SqlBackupRunStatus {
  switch (object) {
    case 0:
    case "SQL_BACKUP_RUN_STATUS_UNSPECIFIED":
      return SqlBackupRunStatus.SQL_BACKUP_RUN_STATUS_UNSPECIFIED;
    case 1:
    case "ENQUEUED":
      return SqlBackupRunStatus.ENQUEUED;
    case 2:
    case "OVERDUE":
      return SqlBackupRunStatus.OVERDUE;
    case 3:
    case "RUNNING":
      return SqlBackupRunStatus.RUNNING;
    case 4:
    case "FAILED":
      return SqlBackupRunStatus.FAILED;
    case 5:
    case "SUCCESSFUL":
      return SqlBackupRunStatus.SUCCESSFUL;
    case 6:
    case "SKIPPED":
      return SqlBackupRunStatus.SKIPPED;
    case 7:
    case "DELETION_PENDING":
      return SqlBackupRunStatus.DELETION_PENDING;
    case 8:
    case "DELETION_FAILED":
      return SqlBackupRunStatus.DELETION_FAILED;
    case 9:
    case "DELETED":
      return SqlBackupRunStatus.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SqlBackupRunStatus.UNRECOGNIZED;
  }
}

export function sqlBackupRunStatusToJSON(object: SqlBackupRunStatus): string {
  switch (object) {
    case SqlBackupRunStatus.SQL_BACKUP_RUN_STATUS_UNSPECIFIED:
      return "SQL_BACKUP_RUN_STATUS_UNSPECIFIED";
    case SqlBackupRunStatus.ENQUEUED:
      return "ENQUEUED";
    case SqlBackupRunStatus.OVERDUE:
      return "OVERDUE";
    case SqlBackupRunStatus.RUNNING:
      return "RUNNING";
    case SqlBackupRunStatus.FAILED:
      return "FAILED";
    case SqlBackupRunStatus.SUCCESSFUL:
      return "SUCCESSFUL";
    case SqlBackupRunStatus.SKIPPED:
      return "SKIPPED";
    case SqlBackupRunStatus.DELETION_PENDING:
      return "DELETION_PENDING";
    case SqlBackupRunStatus.DELETION_FAILED:
      return "DELETION_FAILED";
    case SqlBackupRunStatus.DELETED:
      return "DELETED";
    case SqlBackupRunStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the supported backup kinds. */
export enum SqlBackupKind {
  /** SQL_BACKUP_KIND_UNSPECIFIED - This is an unknown BackupKind. */
  SQL_BACKUP_KIND_UNSPECIFIED = 0,
  /** SNAPSHOT - The snapshot based backups */
  SNAPSHOT = 1,
  /** PHYSICAL - Physical backups */
  PHYSICAL = 2,
  UNRECOGNIZED = -1,
}

export function sqlBackupKindFromJSON(object: any): SqlBackupKind {
  switch (object) {
    case 0:
    case "SQL_BACKUP_KIND_UNSPECIFIED":
      return SqlBackupKind.SQL_BACKUP_KIND_UNSPECIFIED;
    case 1:
    case "SNAPSHOT":
      return SqlBackupKind.SNAPSHOT;
    case 2:
    case "PHYSICAL":
      return SqlBackupKind.PHYSICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SqlBackupKind.UNRECOGNIZED;
  }
}

export function sqlBackupKindToJSON(object: SqlBackupKind): string {
  switch (object) {
    case SqlBackupKind.SQL_BACKUP_KIND_UNSPECIFIED:
      return "SQL_BACKUP_KIND_UNSPECIFIED";
    case SqlBackupKind.SNAPSHOT:
      return "SNAPSHOT";
    case SqlBackupKind.PHYSICAL:
      return "PHYSICAL";
    case SqlBackupKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of backup (i.e. automated, on demand, etc). */
export enum SqlBackupRunType {
  /** SQL_BACKUP_RUN_TYPE_UNSPECIFIED - This is an unknown BackupRun type. */
  SQL_BACKUP_RUN_TYPE_UNSPECIFIED = 0,
  /** AUTOMATED - The backup schedule automatically triggers a backup. */
  AUTOMATED = 1,
  /** ON_DEMAND - The user manually triggers a backup. */
  ON_DEMAND = 2,
  UNRECOGNIZED = -1,
}

export function sqlBackupRunTypeFromJSON(object: any): SqlBackupRunType {
  switch (object) {
    case 0:
    case "SQL_BACKUP_RUN_TYPE_UNSPECIFIED":
      return SqlBackupRunType.SQL_BACKUP_RUN_TYPE_UNSPECIFIED;
    case 1:
    case "AUTOMATED":
      return SqlBackupRunType.AUTOMATED;
    case 2:
    case "ON_DEMAND":
      return SqlBackupRunType.ON_DEMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SqlBackupRunType.UNRECOGNIZED;
  }
}

export function sqlBackupRunTypeToJSON(object: SqlBackupRunType): string {
  switch (object) {
    case SqlBackupRunType.SQL_BACKUP_RUN_TYPE_UNSPECIFIED:
      return "SQL_BACKUP_RUN_TYPE_UNSPECIFIED";
    case SqlBackupRunType.AUTOMATED:
      return "AUTOMATED";
    case SqlBackupRunType.ON_DEMAND:
      return "ON_DEMAND";
    case SqlBackupRunType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Backup runs delete request. */
export interface SqlBackupRunsDeleteRequest {
  /**
   * The ID of the backup run to delete. To find a backup run ID, use the
   * [list](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/backupRuns/list)
   * method.
   */
  id: Long;
  /** Cloud SQL instance ID. This does not include the project ID. */
  instance: string;
  /** Project ID of the project that contains the instance. */
  project: string;
}

/** Backup runs get request. */
export interface SqlBackupRunsGetRequest {
  /** The ID of this backup run. */
  id: Long;
  /** Cloud SQL instance ID. This does not include the project ID. */
  instance: string;
  /** Project ID of the project that contains the instance. */
  project: string;
}

/** Backup runs insert request. */
export interface SqlBackupRunsInsertRequest {
  /** Cloud SQL instance ID. This does not include the project ID. */
  instance: string;
  /** Project ID of the project that contains the instance. */
  project: string;
  body: BackupRun | undefined;
}

/** Backup runs list request. */
export interface SqlBackupRunsListRequest {
  /**
   * Cloud SQL instance ID, or "-" for all instances. This does not include
   * the project ID.
   */
  instance: string;
  /** Maximum number of backup runs per response. */
  maxResults: number;
  /**
   * A previously-returned page token representing part of the larger set of
   * results to view.
   */
  pageToken: string;
  /** Project ID of the project that contains the instance. */
  project: string;
}

/** A BackupRun resource. */
export interface BackupRun {
  /** This is always `sql#backupRun`. */
  kind: string;
  /** The status of this run. */
  status: SqlBackupRunStatus;
  /**
   * The time the run was enqueued in UTC timezone in
   * [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
   * `2012-11-15T16:19:00.094Z`.
   */
  enqueuedTime:
    | Date
    | undefined;
  /**
   * The identifier for this backup run. Unique only for a specific Cloud SQL
   * instance.
   */
  id: Long;
  /**
   * The time the backup operation actually started in UTC timezone in
   * [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
   * `2012-11-15T16:19:00.094Z`.
   */
  startTime:
    | Date
    | undefined;
  /**
   * The time the backup operation completed in UTC timezone in
   * [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
   * `2012-11-15T16:19:00.094Z`.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Information about why the backup operation failed. This is only present if
   * the run has the FAILED status.
   */
  error:
    | OperationError
    | undefined;
  /**
   * The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
   * This field defaults to "ON_DEMAND" and is ignored, when specified for
   * insert requests.
   */
  type: SqlBackupRunType;
  /** The description of this run, only applicable to on-demand backups. */
  description: string;
  /**
   * The start time of the backup window during which this the backup was
   * attempted in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for
   * example `2012-11-15T16:19:00.094Z`.
   */
  windowStartTime:
    | Date
    | undefined;
  /** Name of the database instance. */
  instance: string;
  /** The URI of this resource. */
  selfLink: string;
  /** Location of the backups. */
  location: string;
  /** Encryption configuration specific to a backup. */
  diskEncryptionConfiguration:
    | DiskEncryptionConfiguration
    | undefined;
  /** Encryption status specific to a backup. */
  diskEncryptionStatus:
    | DiskEncryptionStatus
    | undefined;
  /** Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT. */
  backupKind: SqlBackupKind;
  /**
   * Backup time zone to prevent restores to an instance with
   * a different time zone. Now relevant only for SQL Server.
   */
  timeZone: string;
  /** Output only. The maximum chargeable bytes for the backup. */
  maxChargeableBytes?: Long | undefined;
}

/** Backup run list results. */
export interface BackupRunsListResponse {
  /** This is always `sql#backupRunsList`. */
  kind: string;
  /** A list of backup runs in reverse chronological order of the enqueued time. */
  items: BackupRun[];
  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   */
  nextPageToken: string;
}

function createBaseSqlBackupRunsDeleteRequest(): SqlBackupRunsDeleteRequest {
  return { id: Long.ZERO, instance: "", project: "" };
}

export const SqlBackupRunsDeleteRequest: MessageFns<SqlBackupRunsDeleteRequest> = {
  encode(message: SqlBackupRunsDeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.id.toString());
    }
    if (message.instance !== "") {
      writer.uint32(18).string(message.instance);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlBackupRunsDeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlBackupRunsDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlBackupRunsDeleteRequest {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
    };
  },

  toJSON(message: SqlBackupRunsDeleteRequest): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    return obj;
  },

  create(base?: DeepPartial<SqlBackupRunsDeleteRequest>): SqlBackupRunsDeleteRequest {
    return SqlBackupRunsDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SqlBackupRunsDeleteRequest>): SqlBackupRunsDeleteRequest {
    const message = createBaseSqlBackupRunsDeleteRequest();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.instance = object.instance ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseSqlBackupRunsGetRequest(): SqlBackupRunsGetRequest {
  return { id: Long.ZERO, instance: "", project: "" };
}

export const SqlBackupRunsGetRequest: MessageFns<SqlBackupRunsGetRequest> = {
  encode(message: SqlBackupRunsGetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.id.toString());
    }
    if (message.instance !== "") {
      writer.uint32(18).string(message.instance);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlBackupRunsGetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlBackupRunsGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlBackupRunsGetRequest {
    return {
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
    };
  },

  toJSON(message: SqlBackupRunsGetRequest): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    return obj;
  },

  create(base?: DeepPartial<SqlBackupRunsGetRequest>): SqlBackupRunsGetRequest {
    return SqlBackupRunsGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SqlBackupRunsGetRequest>): SqlBackupRunsGetRequest {
    const message = createBaseSqlBackupRunsGetRequest();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.instance = object.instance ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseSqlBackupRunsInsertRequest(): SqlBackupRunsInsertRequest {
  return { instance: "", project: "", body: undefined };
}

export const SqlBackupRunsInsertRequest: MessageFns<SqlBackupRunsInsertRequest> = {
  encode(message: SqlBackupRunsInsertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.body !== undefined) {
      BackupRun.encode(message.body, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlBackupRunsInsertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlBackupRunsInsertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.body = BackupRun.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlBackupRunsInsertRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      body: isSet(object.body) ? BackupRun.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: SqlBackupRunsInsertRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.body !== undefined) {
      obj.body = BackupRun.toJSON(message.body);
    }
    return obj;
  },

  create(base?: DeepPartial<SqlBackupRunsInsertRequest>): SqlBackupRunsInsertRequest {
    return SqlBackupRunsInsertRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SqlBackupRunsInsertRequest>): SqlBackupRunsInsertRequest {
    const message = createBaseSqlBackupRunsInsertRequest();
    message.instance = object.instance ?? "";
    message.project = object.project ?? "";
    message.body = (object.body !== undefined && object.body !== null) ? BackupRun.fromPartial(object.body) : undefined;
    return message;
  },
};

function createBaseSqlBackupRunsListRequest(): SqlBackupRunsListRequest {
  return { instance: "", maxResults: 0, pageToken: "", project: "" };
}

export const SqlBackupRunsListRequest: MessageFns<SqlBackupRunsListRequest> = {
  encode(message: SqlBackupRunsListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.maxResults !== 0) {
      writer.uint32(16).int32(message.maxResults);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.project !== "") {
      writer.uint32(34).string(message.project);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlBackupRunsListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlBackupRunsListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxResults = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.project = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlBackupRunsListRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      maxResults: isSet(object.maxResults) ? globalThis.Number(object.maxResults) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
    };
  },

  toJSON(message: SqlBackupRunsListRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.maxResults !== 0) {
      obj.maxResults = Math.round(message.maxResults);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    return obj;
  },

  create(base?: DeepPartial<SqlBackupRunsListRequest>): SqlBackupRunsListRequest {
    return SqlBackupRunsListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SqlBackupRunsListRequest>): SqlBackupRunsListRequest {
    const message = createBaseSqlBackupRunsListRequest();
    message.instance = object.instance ?? "";
    message.maxResults = object.maxResults ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseBackupRun(): BackupRun {
  return {
    kind: "",
    status: 0,
    enqueuedTime: undefined,
    id: Long.ZERO,
    startTime: undefined,
    endTime: undefined,
    error: undefined,
    type: 0,
    description: "",
    windowStartTime: undefined,
    instance: "",
    selfLink: "",
    location: "",
    diskEncryptionConfiguration: undefined,
    diskEncryptionStatus: undefined,
    backupKind: 0,
    timeZone: "",
    maxChargeableBytes: undefined,
  };
}

export const BackupRun: MessageFns<BackupRun> = {
  encode(message: BackupRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.enqueuedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.enqueuedTime), writer.uint32(26).fork()).join();
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.id.toString());
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    if (message.error !== undefined) {
      OperationError.encode(message.error, writer.uint32(58).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.windowStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStartTime), writer.uint32(82).fork()).join();
    }
    if (message.instance !== "") {
      writer.uint32(90).string(message.instance);
    }
    if (message.selfLink !== "") {
      writer.uint32(98).string(message.selfLink);
    }
    if (message.location !== "") {
      writer.uint32(106).string(message.location);
    }
    if (message.diskEncryptionConfiguration !== undefined) {
      DiskEncryptionConfiguration.encode(message.diskEncryptionConfiguration, writer.uint32(130).fork()).join();
    }
    if (message.diskEncryptionStatus !== undefined) {
      DiskEncryptionStatus.encode(message.diskEncryptionStatus, writer.uint32(138).fork()).join();
    }
    if (message.backupKind !== 0) {
      writer.uint32(152).int32(message.backupKind);
    }
    if (message.timeZone !== "") {
      writer.uint32(186).string(message.timeZone);
    }
    if (message.maxChargeableBytes !== undefined) {
      writer.uint32(192).int64(message.maxChargeableBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.enqueuedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = OperationError.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.windowStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.location = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.diskEncryptionConfiguration = DiskEncryptionConfiguration.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.diskEncryptionStatus = DiskEncryptionStatus.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.backupKind = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.maxChargeableBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupRun {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      status: isSet(object.status) ? sqlBackupRunStatusFromJSON(object.status) : 0,
      enqueuedTime: isSet(object.enqueuedTime) ? fromJsonTimestamp(object.enqueuedTime) : undefined,
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      error: isSet(object.error) ? OperationError.fromJSON(object.error) : undefined,
      type: isSet(object.type) ? sqlBackupRunTypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      windowStartTime: isSet(object.windowStartTime) ? fromJsonTimestamp(object.windowStartTime) : undefined,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      diskEncryptionConfiguration: isSet(object.diskEncryptionConfiguration)
        ? DiskEncryptionConfiguration.fromJSON(object.diskEncryptionConfiguration)
        : undefined,
      diskEncryptionStatus: isSet(object.diskEncryptionStatus)
        ? DiskEncryptionStatus.fromJSON(object.diskEncryptionStatus)
        : undefined,
      backupKind: isSet(object.backupKind) ? sqlBackupKindFromJSON(object.backupKind) : 0,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      maxChargeableBytes: isSet(object.maxChargeableBytes) ? Long.fromValue(object.maxChargeableBytes) : undefined,
    };
  },

  toJSON(message: BackupRun): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.status !== 0) {
      obj.status = sqlBackupRunStatusToJSON(message.status);
    }
    if (message.enqueuedTime !== undefined) {
      obj.enqueuedTime = message.enqueuedTime.toISOString();
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = OperationError.toJSON(message.error);
    }
    if (message.type !== 0) {
      obj.type = sqlBackupRunTypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.windowStartTime !== undefined) {
      obj.windowStartTime = message.windowStartTime.toISOString();
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.diskEncryptionConfiguration !== undefined) {
      obj.diskEncryptionConfiguration = DiskEncryptionConfiguration.toJSON(message.diskEncryptionConfiguration);
    }
    if (message.diskEncryptionStatus !== undefined) {
      obj.diskEncryptionStatus = DiskEncryptionStatus.toJSON(message.diskEncryptionStatus);
    }
    if (message.backupKind !== 0) {
      obj.backupKind = sqlBackupKindToJSON(message.backupKind);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.maxChargeableBytes !== undefined) {
      obj.maxChargeableBytes = (message.maxChargeableBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BackupRun>): BackupRun {
    return BackupRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupRun>): BackupRun {
    const message = createBaseBackupRun();
    message.kind = object.kind ?? "";
    message.status = object.status ?? 0;
    message.enqueuedTime = object.enqueuedTime ?? undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? OperationError.fromPartial(object.error)
      : undefined;
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.windowStartTime = object.windowStartTime ?? undefined;
    message.instance = object.instance ?? "";
    message.selfLink = object.selfLink ?? "";
    message.location = object.location ?? "";
    message.diskEncryptionConfiguration =
      (object.diskEncryptionConfiguration !== undefined && object.diskEncryptionConfiguration !== null)
        ? DiskEncryptionConfiguration.fromPartial(object.diskEncryptionConfiguration)
        : undefined;
    message.diskEncryptionStatus = (object.diskEncryptionStatus !== undefined && object.diskEncryptionStatus !== null)
      ? DiskEncryptionStatus.fromPartial(object.diskEncryptionStatus)
      : undefined;
    message.backupKind = object.backupKind ?? 0;
    message.timeZone = object.timeZone ?? "";
    message.maxChargeableBytes = (object.maxChargeableBytes !== undefined && object.maxChargeableBytes !== null)
      ? Long.fromValue(object.maxChargeableBytes)
      : undefined;
    return message;
  },
};

function createBaseBackupRunsListResponse(): BackupRunsListResponse {
  return { kind: "", items: [], nextPageToken: "" };
}

export const BackupRunsListResponse: MessageFns<BackupRunsListResponse> = {
  encode(message: BackupRunsListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    for (const v of message.items) {
      BackupRun.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupRunsListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupRunsListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(BackupRun.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupRunsListResponse {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => BackupRun.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: BackupRunsListResponse): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => BackupRun.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupRunsListResponse>): BackupRunsListResponse {
    return BackupRunsListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupRunsListResponse>): BackupRunsListResponse {
    const message = createBaseBackupRunsListResponse();
    message.kind = object.kind ?? "";
    message.items = object.items?.map((e) => BackupRun.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** Service for managing database backups. */
export type SqlBackupRunsServiceDefinition = typeof SqlBackupRunsServiceDefinition;
export const SqlBackupRunsServiceDefinition = {
  name: "SqlBackupRunsService",
  fullName: "google.cloud.sql.v1.SqlBackupRunsService",
  methods: {
    /** Deletes the backup taken by a backup run. */
    delete: {
      name: "Delete",
      requestType: SqlBackupRunsDeleteRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              42,
              59,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              82,
              117,
              110,
              115,
              47,
              123,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /** Retrieves a resource containing information about a backup run. */
    get: {
      name: "Get",
      requestType: SqlBackupRunsGetRequest,
      requestStream: false,
      responseType: BackupRun,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              82,
              117,
              110,
              115,
              47,
              123,
              105,
              100,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new backup run on demand. */
    insert: {
      name: "Insert",
      requestType: SqlBackupRunsInsertRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              4,
              98,
              111,
              100,
              121,
              34,
              54,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              82,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all backup runs associated with the project or a given instance
     * and configuration in the reverse chronological order of the backup
     * initiation time.
     */
    list: {
      name: "List",
      requestType: SqlBackupRunsListRequest,
      requestStream: false,
      responseType: BackupRunsListResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              82,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SqlBackupRunsServiceImplementation<CallContextExt = {}> {
  /** Deletes the backup taken by a backup run. */
  delete(request: SqlBackupRunsDeleteRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Retrieves a resource containing information about a backup run. */
  get(request: SqlBackupRunsGetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<BackupRun>>;
  /** Creates a new backup run on demand. */
  insert(request: SqlBackupRunsInsertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Lists all backup runs associated with the project or a given instance
   * and configuration in the reverse chronological order of the backup
   * initiation time.
   */
  list(
    request: SqlBackupRunsListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BackupRunsListResponse>>;
}

export interface SqlBackupRunsServiceClient<CallOptionsExt = {}> {
  /** Deletes the backup taken by a backup run. */
  delete(request: DeepPartial<SqlBackupRunsDeleteRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Retrieves a resource containing information about a backup run. */
  get(request: DeepPartial<SqlBackupRunsGetRequest>, options?: CallOptions & CallOptionsExt): Promise<BackupRun>;
  /** Creates a new backup run on demand. */
  insert(request: DeepPartial<SqlBackupRunsInsertRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Lists all backup runs associated with the project or a given instance
   * and configuration in the reverse chronological order of the backup
   * initiation time.
   */
  list(
    request: DeepPartial<SqlBackupRunsListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BackupRunsListResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
