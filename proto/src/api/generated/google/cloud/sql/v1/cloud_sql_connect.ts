// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/sql/v1/cloud_sql_connect.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  IpMapping,
  SqlBackendType,
  sqlBackendTypeFromJSON,
  sqlBackendTypeToJSON,
  SqlDatabaseVersion,
  sqlDatabaseVersionFromJSON,
  sqlDatabaseVersionToJSON,
  SslCert,
} from "./cloud_sql_resources.js";

export const protobufPackage = "google.cloud.sql.v1";

/** Connect settings retrieval request. */
export interface GetConnectSettingsRequest {
  /** Cloud SQL instance ID. This does not include the project ID. */
  instance: string;
  /** Project ID of the project that contains the instance. */
  project: string;
  /**
   * Optional. Optional snapshot read timestamp to trade freshness for
   * performance.
   */
  readTime: Date | undefined;
}

/** Connect settings retrieval response. */
export interface ConnectSettings {
  /** This is always `sql#connectSettings`. */
  kind: string;
  /** SSL configuration. */
  serverCaCert:
    | SslCert
    | undefined;
  /** The assigned IP addresses for the instance. */
  ipAddresses: IpMapping[];
  /**
   * The cloud region for the instance. For example, `us-central1`,
   * `europe-west1`. The region cannot be changed after instance creation.
   */
  region: string;
  /**
   * The database engine type and version. The `databaseVersion`
   * field cannot be changed after instance creation.
   *   MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
   * or `MYSQL_5_6`.
   *   PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
   * `POSTGRES_11`, `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
   *   SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
   * `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
   * `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
   * `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
   * `SQLSERVER_2019_WEB`.
   */
  databaseVersion: SqlDatabaseVersion;
  /**
   * `SECOND_GEN`: Cloud SQL database instance.
   * `EXTERNAL`: A database server that is not managed by Google.
   * This property is read-only; use the `tier` property in the `settings`
   * object to determine the database type.
   */
  backendType: SqlBackendType;
  /** Whether PSC connectivity is enabled for this instance. */
  pscEnabled: boolean;
  /** The dns name of the instance. */
  dnsName: string;
  /** Specify what type of CA is used for the server certificate. */
  serverCaMode: ConnectSettings_CaMode;
}

/** Various Certificate Authority (CA) modes for certificate signing. */
export enum ConnectSettings_CaMode {
  /** CA_MODE_UNSPECIFIED - CA mode is unknown. */
  CA_MODE_UNSPECIFIED = 0,
  /** GOOGLE_MANAGED_INTERNAL_CA - Google-managed self-signed internal CA. */
  GOOGLE_MANAGED_INTERNAL_CA = 1,
  /**
   * GOOGLE_MANAGED_CAS_CA - Google-managed regional CA part of root CA hierarchy hosted on Google
   * Cloud's Certificate Authority Service (CAS).
   */
  GOOGLE_MANAGED_CAS_CA = 2,
  UNRECOGNIZED = -1,
}

export function connectSettings_CaModeFromJSON(object: any): ConnectSettings_CaMode {
  switch (object) {
    case 0:
    case "CA_MODE_UNSPECIFIED":
      return ConnectSettings_CaMode.CA_MODE_UNSPECIFIED;
    case 1:
    case "GOOGLE_MANAGED_INTERNAL_CA":
      return ConnectSettings_CaMode.GOOGLE_MANAGED_INTERNAL_CA;
    case 2:
    case "GOOGLE_MANAGED_CAS_CA":
      return ConnectSettings_CaMode.GOOGLE_MANAGED_CAS_CA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectSettings_CaMode.UNRECOGNIZED;
  }
}

export function connectSettings_CaModeToJSON(object: ConnectSettings_CaMode): string {
  switch (object) {
    case ConnectSettings_CaMode.CA_MODE_UNSPECIFIED:
      return "CA_MODE_UNSPECIFIED";
    case ConnectSettings_CaMode.GOOGLE_MANAGED_INTERNAL_CA:
      return "GOOGLE_MANAGED_INTERNAL_CA";
    case ConnectSettings_CaMode.GOOGLE_MANAGED_CAS_CA:
      return "GOOGLE_MANAGED_CAS_CA";
    case ConnectSettings_CaMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Ephemeral certificate creation request. */
export interface GenerateEphemeralCertRequest {
  /** Cloud SQL instance ID. This does not include the project ID. */
  instance: string;
  /** Project ID of the project that contains the instance. */
  project: string;
  /** PEM encoded public key to include in the signed certificate. */
  publicKey: string;
  /** Optional. Access token to include in the signed certificate. */
  accessToken: string;
  /**
   * Optional. Optional snapshot read timestamp to trade freshness for
   * performance.
   */
  readTime:
    | Date
    | undefined;
  /** Optional. If set, it will contain the cert valid duration. */
  validDuration: Duration | undefined;
}

/** Ephemeral certificate creation request. */
export interface GenerateEphemeralCertResponse {
  /** Generated cert */
  ephemeralCert: SslCert | undefined;
}

function createBaseGetConnectSettingsRequest(): GetConnectSettingsRequest {
  return { instance: "", project: "", readTime: undefined };
}

export const GetConnectSettingsRequest: MessageFns<GetConnectSettingsRequest> = {
  encode(message: GetConnectSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectSettingsRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
    };
  },

  toJSON(message: GetConnectSettingsRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectSettingsRequest>): GetConnectSettingsRequest {
    return GetConnectSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectSettingsRequest>): GetConnectSettingsRequest {
    const message = createBaseGetConnectSettingsRequest();
    message.instance = object.instance ?? "";
    message.project = object.project ?? "";
    message.readTime = object.readTime ?? undefined;
    return message;
  },
};

function createBaseConnectSettings(): ConnectSettings {
  return {
    kind: "",
    serverCaCert: undefined,
    ipAddresses: [],
    region: "",
    databaseVersion: 0,
    backendType: 0,
    pscEnabled: false,
    dnsName: "",
    serverCaMode: 0,
  };
}

export const ConnectSettings: MessageFns<ConnectSettings> = {
  encode(message: ConnectSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.serverCaCert !== undefined) {
      SslCert.encode(message.serverCaCert, writer.uint32(18).fork()).join();
    }
    for (const v of message.ipAddresses) {
      IpMapping.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    if (message.databaseVersion !== 0) {
      writer.uint32(248).int32(message.databaseVersion);
    }
    if (message.backendType !== 0) {
      writer.uint32(256).int32(message.backendType);
    }
    if (message.pscEnabled !== false) {
      writer.uint32(264).bool(message.pscEnabled);
    }
    if (message.dnsName !== "") {
      writer.uint32(274).string(message.dnsName);
    }
    if (message.serverCaMode !== 0) {
      writer.uint32(280).int32(message.serverCaMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serverCaCert = SslCert.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddresses.push(IpMapping.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.region = reader.string();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.databaseVersion = reader.int32() as any;
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.backendType = reader.int32() as any;
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.pscEnabled = reader.bool();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.dnsName = reader.string();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.serverCaMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectSettings {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      serverCaCert: isSet(object.serverCaCert) ? SslCert.fromJSON(object.serverCaCert) : undefined,
      ipAddresses: globalThis.Array.isArray(object?.ipAddresses)
        ? object.ipAddresses.map((e: any) => IpMapping.fromJSON(e))
        : [],
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      databaseVersion: isSet(object.databaseVersion) ? sqlDatabaseVersionFromJSON(object.databaseVersion) : 0,
      backendType: isSet(object.backendType) ? sqlBackendTypeFromJSON(object.backendType) : 0,
      pscEnabled: isSet(object.pscEnabled) ? globalThis.Boolean(object.pscEnabled) : false,
      dnsName: isSet(object.dnsName) ? globalThis.String(object.dnsName) : "",
      serverCaMode: isSet(object.serverCaMode) ? connectSettings_CaModeFromJSON(object.serverCaMode) : 0,
    };
  },

  toJSON(message: ConnectSettings): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.serverCaCert !== undefined) {
      obj.serverCaCert = SslCert.toJSON(message.serverCaCert);
    }
    if (message.ipAddresses?.length) {
      obj.ipAddresses = message.ipAddresses.map((e) => IpMapping.toJSON(e));
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.databaseVersion !== 0) {
      obj.databaseVersion = sqlDatabaseVersionToJSON(message.databaseVersion);
    }
    if (message.backendType !== 0) {
      obj.backendType = sqlBackendTypeToJSON(message.backendType);
    }
    if (message.pscEnabled !== false) {
      obj.pscEnabled = message.pscEnabled;
    }
    if (message.dnsName !== "") {
      obj.dnsName = message.dnsName;
    }
    if (message.serverCaMode !== 0) {
      obj.serverCaMode = connectSettings_CaModeToJSON(message.serverCaMode);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectSettings>): ConnectSettings {
    return ConnectSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectSettings>): ConnectSettings {
    const message = createBaseConnectSettings();
    message.kind = object.kind ?? "";
    message.serverCaCert = (object.serverCaCert !== undefined && object.serverCaCert !== null)
      ? SslCert.fromPartial(object.serverCaCert)
      : undefined;
    message.ipAddresses = object.ipAddresses?.map((e) => IpMapping.fromPartial(e)) || [];
    message.region = object.region ?? "";
    message.databaseVersion = object.databaseVersion ?? 0;
    message.backendType = object.backendType ?? 0;
    message.pscEnabled = object.pscEnabled ?? false;
    message.dnsName = object.dnsName ?? "";
    message.serverCaMode = object.serverCaMode ?? 0;
    return message;
  },
};

function createBaseGenerateEphemeralCertRequest(): GenerateEphemeralCertRequest {
  return { instance: "", project: "", publicKey: "", accessToken: "", readTime: undefined, validDuration: undefined };
}

export const GenerateEphemeralCertRequest: MessageFns<GenerateEphemeralCertRequest> = {
  encode(message: GenerateEphemeralCertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.accessToken !== "") {
      writer.uint32(34).string(message.accessToken);
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(58).fork()).join();
    }
    if (message.validDuration !== undefined) {
      Duration.encode(message.validDuration, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateEphemeralCertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateEphemeralCertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.validDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateEphemeralCertRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      validDuration: isSet(object.validDuration) ? Duration.fromJSON(object.validDuration) : undefined,
    };
  },

  toJSON(message: GenerateEphemeralCertRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.validDuration !== undefined) {
      obj.validDuration = Duration.toJSON(message.validDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateEphemeralCertRequest>): GenerateEphemeralCertRequest {
    return GenerateEphemeralCertRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateEphemeralCertRequest>): GenerateEphemeralCertRequest {
    const message = createBaseGenerateEphemeralCertRequest();
    message.instance = object.instance ?? "";
    message.project = object.project ?? "";
    message.publicKey = object.publicKey ?? "";
    message.accessToken = object.accessToken ?? "";
    message.readTime = object.readTime ?? undefined;
    message.validDuration = (object.validDuration !== undefined && object.validDuration !== null)
      ? Duration.fromPartial(object.validDuration)
      : undefined;
    return message;
  },
};

function createBaseGenerateEphemeralCertResponse(): GenerateEphemeralCertResponse {
  return { ephemeralCert: undefined };
}

export const GenerateEphemeralCertResponse: MessageFns<GenerateEphemeralCertResponse> = {
  encode(message: GenerateEphemeralCertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ephemeralCert !== undefined) {
      SslCert.encode(message.ephemeralCert, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateEphemeralCertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateEphemeralCertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ephemeralCert = SslCert.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateEphemeralCertResponse {
    return { ephemeralCert: isSet(object.ephemeralCert) ? SslCert.fromJSON(object.ephemeralCert) : undefined };
  },

  toJSON(message: GenerateEphemeralCertResponse): unknown {
    const obj: any = {};
    if (message.ephemeralCert !== undefined) {
      obj.ephemeralCert = SslCert.toJSON(message.ephemeralCert);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateEphemeralCertResponse>): GenerateEphemeralCertResponse {
    return GenerateEphemeralCertResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateEphemeralCertResponse>): GenerateEphemeralCertResponse {
    const message = createBaseGenerateEphemeralCertResponse();
    message.ephemeralCert = (object.ephemeralCert !== undefined && object.ephemeralCert !== null)
      ? SslCert.fromPartial(object.ephemeralCert)
      : undefined;
    return message;
  },
};

/** Cloud SQL connect service. */
export type SqlConnectServiceDefinition = typeof SqlConnectServiceDefinition;
export const SqlConnectServiceDefinition = {
  name: "SqlConnectService",
  fullName: "google.cloud.sql.v1.SqlConnectService",
  methods: {
    /** Retrieves connect settings about a Cloud SQL instance. */
    getConnectSettings: {
      name: "GetConnectSettings",
      requestType: GetConnectSettingsRequest,
      requestStream: false,
      responseType: ConnectSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Generates a short-lived X509 certificate containing the provided public key
     * and signed by a private key specific to the target instance. Users may use
     * the certificate to authenticate as themselves when connecting to the
     * database.
     */
    generateEphemeralCert: {
      name: "GenerateEphemeralCert",
      requestType: GenerateEphemeralCertRequest,
      requestStream: false,
      responseType: GenerateEphemeralCertResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              69,
              112,
              104,
              101,
              109,
              101,
              114,
              97,
              108,
              67,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SqlConnectServiceImplementation<CallContextExt = {}> {
  /** Retrieves connect settings about a Cloud SQL instance. */
  getConnectSettings(
    request: GetConnectSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ConnectSettings>>;
  /**
   * Generates a short-lived X509 certificate containing the provided public key
   * and signed by a private key specific to the target instance. Users may use
   * the certificate to authenticate as themselves when connecting to the
   * database.
   */
  generateEphemeralCert(
    request: GenerateEphemeralCertRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateEphemeralCertResponse>>;
}

export interface SqlConnectServiceClient<CallOptionsExt = {}> {
  /** Retrieves connect settings about a Cloud SQL instance. */
  getConnectSettings(
    request: DeepPartial<GetConnectSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ConnectSettings>;
  /**
   * Generates a short-lived X509 certificate containing the provided public key
   * and signed by a private key specific to the target instance. Users may use
   * the certificate to authenticate as themselves when connecting to the
   * database.
   */
  generateEphemeralCert(
    request: DeepPartial<GenerateEphemeralCertRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateEphemeralCertResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
