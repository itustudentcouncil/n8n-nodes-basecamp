// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/advisorynotifications/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.advisorynotifications.v1";

/** Notification view. */
export enum NotificationView {
  /** NOTIFICATION_VIEW_UNSPECIFIED - Not specified, equivalent to BASIC. */
  NOTIFICATION_VIEW_UNSPECIFIED = 0,
  /**
   * BASIC - Server responses only include title, creation time and Notification ID.
   * Note: for internal use responses also include the last update time,
   * the latest message text and whether notification has attachments.
   */
  BASIC = 1,
  /** FULL - Include everything. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function notificationViewFromJSON(object: any): NotificationView {
  switch (object) {
    case 0:
    case "NOTIFICATION_VIEW_UNSPECIFIED":
      return NotificationView.NOTIFICATION_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return NotificationView.BASIC;
    case 2:
    case "FULL":
      return NotificationView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationView.UNRECOGNIZED;
  }
}

export function notificationViewToJSON(object: NotificationView): string {
  switch (object) {
    case NotificationView.NOTIFICATION_VIEW_UNSPECIFIED:
      return "NOTIFICATION_VIEW_UNSPECIFIED";
    case NotificationView.BASIC:
      return "BASIC";
    case NotificationView.FULL:
      return "FULL";
    case NotificationView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of localized text. */
export enum LocalizationState {
  /** LOCALIZATION_STATE_UNSPECIFIED - Not used. */
  LOCALIZATION_STATE_UNSPECIFIED = 0,
  /**
   * LOCALIZATION_STATE_NOT_APPLICABLE - Localization is not applicable for requested language. This can happen
   * when:
   * - The requested language was not supported by Advisory Notifications at the
   * time of localization (including notifications created before the
   * localization feature was launched).
   * - The requested language is English, so only the English text is returned.
   */
  LOCALIZATION_STATE_NOT_APPLICABLE = 1,
  /** LOCALIZATION_STATE_PENDING - Localization for requested language is in progress, and not ready yet. */
  LOCALIZATION_STATE_PENDING = 2,
  /** LOCALIZATION_STATE_COMPLETED - Localization for requested language is completed. */
  LOCALIZATION_STATE_COMPLETED = 3,
  UNRECOGNIZED = -1,
}

export function localizationStateFromJSON(object: any): LocalizationState {
  switch (object) {
    case 0:
    case "LOCALIZATION_STATE_UNSPECIFIED":
      return LocalizationState.LOCALIZATION_STATE_UNSPECIFIED;
    case 1:
    case "LOCALIZATION_STATE_NOT_APPLICABLE":
      return LocalizationState.LOCALIZATION_STATE_NOT_APPLICABLE;
    case 2:
    case "LOCALIZATION_STATE_PENDING":
      return LocalizationState.LOCALIZATION_STATE_PENDING;
    case 3:
    case "LOCALIZATION_STATE_COMPLETED":
      return LocalizationState.LOCALIZATION_STATE_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocalizationState.UNRECOGNIZED;
  }
}

export function localizationStateToJSON(object: LocalizationState): string {
  switch (object) {
    case LocalizationState.LOCALIZATION_STATE_UNSPECIFIED:
      return "LOCALIZATION_STATE_UNSPECIFIED";
    case LocalizationState.LOCALIZATION_STATE_NOT_APPLICABLE:
      return "LOCALIZATION_STATE_NOT_APPLICABLE";
    case LocalizationState.LOCALIZATION_STATE_PENDING:
      return "LOCALIZATION_STATE_PENDING";
    case LocalizationState.LOCALIZATION_STATE_COMPLETED:
      return "LOCALIZATION_STATE_COMPLETED";
    case LocalizationState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of notification */
export enum NotificationType {
  /** NOTIFICATION_TYPE_UNSPECIFIED - Default type */
  NOTIFICATION_TYPE_UNSPECIFIED = 0,
  /** NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY - Security and privacy advisory notifications */
  NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY = 1,
  /** NOTIFICATION_TYPE_SENSITIVE_ACTIONS - Sensitive action notifications */
  NOTIFICATION_TYPE_SENSITIVE_ACTIONS = 2,
  /** NOTIFICATION_TYPE_SECURITY_MSA - General security MSA */
  NOTIFICATION_TYPE_SECURITY_MSA = 3,
  /** NOTIFICATION_TYPE_THREAT_HORIZONS - Threat horizons MSA */
  NOTIFICATION_TYPE_THREAT_HORIZONS = 4,
  UNRECOGNIZED = -1,
}

export function notificationTypeFromJSON(object: any): NotificationType {
  switch (object) {
    case 0:
    case "NOTIFICATION_TYPE_UNSPECIFIED":
      return NotificationType.NOTIFICATION_TYPE_UNSPECIFIED;
    case 1:
    case "NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY":
      return NotificationType.NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY;
    case 2:
    case "NOTIFICATION_TYPE_SENSITIVE_ACTIONS":
      return NotificationType.NOTIFICATION_TYPE_SENSITIVE_ACTIONS;
    case 3:
    case "NOTIFICATION_TYPE_SECURITY_MSA":
      return NotificationType.NOTIFICATION_TYPE_SECURITY_MSA;
    case 4:
    case "NOTIFICATION_TYPE_THREAT_HORIZONS":
      return NotificationType.NOTIFICATION_TYPE_THREAT_HORIZONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationType.UNRECOGNIZED;
  }
}

export function notificationTypeToJSON(object: NotificationType): string {
  switch (object) {
    case NotificationType.NOTIFICATION_TYPE_UNSPECIFIED:
      return "NOTIFICATION_TYPE_UNSPECIFIED";
    case NotificationType.NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY:
      return "NOTIFICATION_TYPE_SECURITY_PRIVACY_ADVISORY";
    case NotificationType.NOTIFICATION_TYPE_SENSITIVE_ACTIONS:
      return "NOTIFICATION_TYPE_SENSITIVE_ACTIONS";
    case NotificationType.NOTIFICATION_TYPE_SECURITY_MSA:
      return "NOTIFICATION_TYPE_SECURITY_MSA";
    case NotificationType.NOTIFICATION_TYPE_THREAT_HORIZONS:
      return "NOTIFICATION_TYPE_THREAT_HORIZONS";
    case NotificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A notification object for notifying customers about security and privacy
 * issues.
 */
export interface Notification {
  /**
   * The resource name of the notification.
   * Format:
   * organizations/{organization}/locations/{location}/notifications/{notification}
   * or projects/{project}/locations/{location}/notifications/{notification}.
   */
  name: string;
  /** The subject line of the notification. */
  subject:
    | Subject
    | undefined;
  /** A list of messages in the notification. */
  messages: Message[];
  /** Output only. Time the notification was created. */
  createTime:
    | Date
    | undefined;
  /** Type of notification */
  notificationType: NotificationType;
}

/** A text object containing the English text and its localized copies. */
export interface Text {
  /** The English copy. */
  enText: string;
  /** The requested localized copy (if applicable). */
  localizedText: string;
  /** Status of the localization. */
  localizationState: LocalizationState;
}

/** A subject line of a notification. */
export interface Subject {
  /** The text content. */
  text: Text | undefined;
}

/** A message which contains notification details. */
export interface Message {
  /** The message content. */
  body:
    | Message_Body
    | undefined;
  /** The attachments to download. */
  attachments: Attachment[];
  /** The Message creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Time when Message was localized */
  localizationTime: Date | undefined;
}

/** A message body containing text. */
export interface Message_Body {
  /** The text content of the message body. */
  text: Text | undefined;
}

/** Attachment with specific information about the issue. */
export interface Attachment {
  /** A CSV file attachment. Max size is 10 MB. */
  csv?:
    | Csv
    | undefined;
  /** The title of the attachment. */
  displayName: string;
}

/**
 * A representation of a CSV file attachment, as a list of column headers and
 * a list of data rows.
 */
export interface Csv {
  /** The list of headers for data columns in a CSV file. */
  headers: string[];
  /**
   * The list of data rows in a CSV file, as string arrays rather than as a
   * single comma-separated string.
   */
  dataRows: Csv_CsvRow[];
}

/** A representation of a single data row in a CSV file. */
export interface Csv_CsvRow {
  /**
   * The data entries in a CSV file row, as a string array rather than a
   * single comma-separated string.
   */
  entries: string[];
}

/** Request for fetching all notifications for a given parent. */
export interface ListNotificationsRequest {
  /**
   * Required. The parent, which owns this collection of notifications.
   * Must be of the form "organizations/{organization}/locations/{location}"
   * or "projects/{project}/locations/{location}".
   */
  parent: string;
  /**
   * The maximum number of notifications to return. The service may return
   * fewer than this value. If unspecified or equal to 0, at most 50
   * notifications will be returned. The maximum value is 50; values above 50
   * will be coerced to 50.
   */
  pageSize: number;
  /**
   * A page token returned from a previous request.
   * When paginating, all other parameters provided in the request
   * must match the call that returned the page token.
   */
  pageToken: string;
  /**
   * Specifies which parts of the notification resource should be returned
   * in the response.
   */
  view: NotificationView;
  /**
   * ISO code for requested localization language.  If unset, will be
   * interpereted as "en". If the requested language is valid, but not supported
   * for this notification, English will be returned with an "Not applicable"
   * LocalizationState. If the ISO code is invalid (i.e. not a real language),
   * this RPC will throw an error.
   */
  languageCode: string;
}

/** Response of ListNotifications endpoint. */
export interface ListNotificationsResponse {
  /** List of notifications under a given parent. */
  notifications: Notification[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Estimation of a total number of notifications. */
  totalSize: number;
}

/** Request for fetching a notification. */
export interface GetNotificationRequest {
  /**
   * Required. A name of the notification to retrieve.
   * Format:
   * organizations/{organization}/locations/{location}/notifications/{notification}
   * or projects/{projects}/locations/{location}/notifications/{notification}.
   */
  name: string;
  /**
   * ISO code for requested localization language. If unset, will be
   * interpereted as "en". If the requested language is valid, but not supported
   * for this notification, English will be returned with an "Not applicable"
   * LocalizationState. If the ISO code is invalid (i.e. not a real language),
   * this RPC will throw an error.
   */
  languageCode: string;
}

/** Settings for Advisory Notifications. */
export interface Settings {
  /**
   * Identifier. The resource name of the settings to retrieve.
   * Format:
   * organizations/{organization}/locations/{location}/settings or
   * projects/{projects}/locations/{location}/settings.
   */
  name: string;
  /**
   * Required. Map of each notification type and its settings to get/set all
   * settings at once. The server will validate the value for each notification
   * type.
   */
  notificationSettings: { [key: string]: NotificationSettings };
  /**
   * Required. Fingerprint for optimistic concurrency returned in Get requests.
   * Must be provided for Update requests. If the value provided does not match
   * the value known to the server, ABORTED will be thrown, and the client
   * should retry the read-modify-write cycle.
   */
  etag: string;
}

export interface Settings_NotificationSettingsEntry {
  key: string;
  value: NotificationSettings | undefined;
}

/** Settings for each NotificationType. */
export interface NotificationSettings {
  /** Whether the associated NotificationType is enabled. */
  enabled: boolean;
}

/** Request of GetSettings endpoint. */
export interface GetSettingsRequest {
  /**
   * Required. The resource name of the settings to retrieve.
   * Format:
   * organizations/{organization}/locations/{location}/settings or
   * projects/{projects}/locations/{location}/settings.
   */
  name: string;
}

/** Request of UpdateSettings endpoint. */
export interface UpdateSettingsRequest {
  /** Required. New settings. */
  settings: Settings | undefined;
}

function createBaseNotification(): Notification {
  return { name: "", subject: undefined, messages: [], createTime: undefined, notificationType: 0 };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(18).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.notificationType !== 0) {
      writer.uint32(96).int32(message.notificationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.notificationType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      notificationType: isSet(object.notificationType) ? notificationTypeFromJSON(object.notificationType) : 0,
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.notificationType !== 0) {
      obj.notificationType = notificationTypeToJSON(message.notificationType);
    }
    return obj;
  },

  create(base?: DeepPartial<Notification>): Notification {
    return Notification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Notification>): Notification {
    const message = createBaseNotification();
    message.name = object.name ?? "";
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.notificationType = object.notificationType ?? 0;
    return message;
  },
};

function createBaseText(): Text {
  return { enText: "", localizedText: "", localizationState: 0 };
}

export const Text: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enText !== "") {
      writer.uint32(10).string(message.enText);
    }
    if (message.localizedText !== "") {
      writer.uint32(18).string(message.localizedText);
    }
    if (message.localizationState !== 0) {
      writer.uint32(24).int32(message.localizationState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.enText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localizedText = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.localizationState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text {
    return {
      enText: isSet(object.enText) ? globalThis.String(object.enText) : "",
      localizedText: isSet(object.localizedText) ? globalThis.String(object.localizedText) : "",
      localizationState: isSet(object.localizationState) ? localizationStateFromJSON(object.localizationState) : 0,
    };
  },

  toJSON(message: Text): unknown {
    const obj: any = {};
    if (message.enText !== "") {
      obj.enText = message.enText;
    }
    if (message.localizedText !== "") {
      obj.localizedText = message.localizedText;
    }
    if (message.localizationState !== 0) {
      obj.localizationState = localizationStateToJSON(message.localizationState);
    }
    return obj;
  },

  create(base?: DeepPartial<Text>): Text {
    return Text.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Text>): Text {
    const message = createBaseText();
    message.enText = object.enText ?? "";
    message.localizedText = object.localizedText ?? "";
    message.localizationState = object.localizationState ?? 0;
    return message;
  },
};

function createBaseSubject(): Subject {
  return { text: undefined };
}

export const Subject: MessageFns<Subject> = {
  encode(message: Subject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subject {
    return { text: isSet(object.text) ? Text.fromJSON(object.text) : undefined };
  },

  toJSON(message: Subject): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = Text.toJSON(message.text);
    }
    return obj;
  },

  create(base?: DeepPartial<Subject>): Subject {
    return Subject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subject>): Subject {
    const message = createBaseSubject();
    message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { body: undefined, attachments: [], createTime: undefined, localizationTime: undefined };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      Message_Body.encode(message.body, writer.uint32(10).fork()).join();
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.localizationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.localizationTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = Message_Body.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.localizationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      body: isSet(object.body) ? Message_Body.fromJSON(object.body) : undefined,
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      localizationTime: isSet(object.localizationTime) ? fromJsonTimestamp(object.localizationTime) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = Message_Body.toJSON(message.body);
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.localizationTime !== undefined) {
      obj.localizationTime = message.localizationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Message>): Message {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message>): Message {
    const message = createBaseMessage();
    message.body = (object.body !== undefined && object.body !== null)
      ? Message_Body.fromPartial(object.body)
      : undefined;
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.localizationTime = object.localizationTime ?? undefined;
    return message;
  },
};

function createBaseMessage_Body(): Message_Body {
  return { text: undefined };
}

export const Message_Body: MessageFns<Message_Body> = {
  encode(message: Message_Body, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message_Body {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage_Body();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message_Body {
    return { text: isSet(object.text) ? Text.fromJSON(object.text) : undefined };
  },

  toJSON(message: Message_Body): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = Text.toJSON(message.text);
    }
    return obj;
  },

  create(base?: DeepPartial<Message_Body>): Message_Body {
    return Message_Body.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message_Body>): Message_Body {
    const message = createBaseMessage_Body();
    message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
    return message;
  },
};

function createBaseAttachment(): Attachment {
  return { csv: undefined, displayName: "" };
}

export const Attachment: MessageFns<Attachment> = {
  encode(message: Attachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csv !== undefined) {
      Csv.encode(message.csv, writer.uint32(18).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.csv = Csv.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attachment {
    return {
      csv: isSet(object.csv) ? Csv.fromJSON(object.csv) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Attachment): unknown {
    const obj: any = {};
    if (message.csv !== undefined) {
      obj.csv = Csv.toJSON(message.csv);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<Attachment>): Attachment {
    return Attachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attachment>): Attachment {
    const message = createBaseAttachment();
    message.csv = (object.csv !== undefined && object.csv !== null) ? Csv.fromPartial(object.csv) : undefined;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseCsv(): Csv {
  return { headers: [], dataRows: [] };
}

export const Csv: MessageFns<Csv> = {
  encode(message: Csv, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.headers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.dataRows) {
      Csv_CsvRow.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Csv {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headers.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataRows.push(Csv_CsvRow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Csv {
    return {
      headers: globalThis.Array.isArray(object?.headers) ? object.headers.map((e: any) => globalThis.String(e)) : [],
      dataRows: globalThis.Array.isArray(object?.dataRows)
        ? object.dataRows.map((e: any) => Csv_CsvRow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Csv): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers;
    }
    if (message.dataRows?.length) {
      obj.dataRows = message.dataRows.map((e) => Csv_CsvRow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Csv>): Csv {
    return Csv.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Csv>): Csv {
    const message = createBaseCsv();
    message.headers = object.headers?.map((e) => e) || [];
    message.dataRows = object.dataRows?.map((e) => Csv_CsvRow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCsv_CsvRow(): Csv_CsvRow {
  return { entries: [] };
}

export const Csv_CsvRow: MessageFns<Csv_CsvRow> = {
  encode(message: Csv_CsvRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Csv_CsvRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsv_CsvRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Csv_CsvRow {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Csv_CsvRow): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries;
    }
    return obj;
  },

  create(base?: DeepPartial<Csv_CsvRow>): Csv_CsvRow {
    return Csv_CsvRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Csv_CsvRow>): Csv_CsvRow {
    const message = createBaseCsv_CsvRow();
    message.entries = object.entries?.map((e) => e) || [];
    return message;
  },
};

function createBaseListNotificationsRequest(): ListNotificationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0, languageCode: "" };
}

export const ListNotificationsRequest: MessageFns<ListNotificationsRequest> = {
  encode(message: ListNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? notificationViewFromJSON(object.view) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListNotificationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = notificationViewToJSON(message.view);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationsRequest>): ListNotificationsRequest {
    return ListNotificationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotificationsRequest>): ListNotificationsRequest {
    const message = createBaseListNotificationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListNotificationsResponse(): ListNotificationsResponse {
  return { notifications: [], nextPageToken: "", totalSize: 0 };
}

export const ListNotificationsResponse: MessageFns<ListNotificationsResponse> = {
  encode(message: ListNotificationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsResponse {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Notification.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListNotificationsResponse): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationsResponse>): ListNotificationsResponse {
    return ListNotificationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotificationsResponse>): ListNotificationsResponse {
    const message = createBaseListNotificationsResponse();
    message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetNotificationRequest(): GetNotificationRequest {
  return { name: "", languageCode: "" };
}

export const GetNotificationRequest: MessageFns<GetNotificationRequest> = {
  encode(message: GetNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: GetNotificationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNotificationRequest>): GetNotificationRequest {
    return GetNotificationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNotificationRequest>): GetNotificationRequest {
    const message = createBaseGetNotificationRequest();
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseSettings(): Settings {
  return { name: "", notificationSettings: {}, etag: "" };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.notificationSettings).forEach(([key, value]) => {
      Settings_NotificationSettingsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Settings_NotificationSettingsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.notificationSettings[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      notificationSettings: isObject(object.notificationSettings)
        ? Object.entries(object.notificationSettings).reduce<{ [key: string]: NotificationSettings }>(
          (acc, [key, value]) => {
            acc[key] = NotificationSettings.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.notificationSettings) {
      const entries = Object.entries(message.notificationSettings);
      if (entries.length > 0) {
        obj.notificationSettings = {};
        entries.forEach(([k, v]) => {
          obj.notificationSettings[k] = NotificationSettings.toJSON(v);
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.name = object.name ?? "";
    message.notificationSettings = Object.entries(object.notificationSettings ?? {}).reduce<
      { [key: string]: NotificationSettings }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = NotificationSettings.fromPartial(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseSettings_NotificationSettingsEntry(): Settings_NotificationSettingsEntry {
  return { key: "", value: undefined };
}

export const Settings_NotificationSettingsEntry: MessageFns<Settings_NotificationSettingsEntry> = {
  encode(message: Settings_NotificationSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NotificationSettings.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_NotificationSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_NotificationSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NotificationSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_NotificationSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? NotificationSettings.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Settings_NotificationSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = NotificationSettings.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_NotificationSettingsEntry>): Settings_NotificationSettingsEntry {
    return Settings_NotificationSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_NotificationSettingsEntry>): Settings_NotificationSettingsEntry {
    const message = createBaseSettings_NotificationSettingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NotificationSettings.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNotificationSettings(): NotificationSettings {
  return { enabled: false };
}

export const NotificationSettings: MessageFns<NotificationSettings> = {
  encode(message: NotificationSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSettings {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: NotificationSettings): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationSettings>): NotificationSettings {
    return NotificationSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationSettings>): NotificationSettings {
    const message = createBaseNotificationSettings();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGetSettingsRequest(): GetSettingsRequest {
  return { name: "" };
}

export const GetSettingsRequest: MessageFns<GetSettingsRequest> = {
  encode(message: GetSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSettingsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    return GetSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    const message = createBaseGetSettingsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
  return { settings: undefined };
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
  encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingsRequest {
    return { settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined };
  },

  toJSON(message: UpdateSettingsRequest): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    return UpdateSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    const message = createBaseUpdateSettingsRequest();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

/** Service to manage Security and Privacy Notifications. */
export type AdvisoryNotificationsServiceDefinition = typeof AdvisoryNotificationsServiceDefinition;
export const AdvisoryNotificationsServiceDefinition = {
  name: "AdvisoryNotificationsService",
  fullName: "google.cloud.advisorynotifications.v1.AdvisoryNotificationsService",
  methods: {
    /** Lists notifications under a given parent. */
    listNotifications: {
      name: "ListNotifications",
      requestType: ListNotificationsRequest,
      requestStream: false,
      responseType: ListNotificationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              109,
              90,
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a notification. */
    getNotification: {
      name: "GetNotification",
      requestType: GetNotificationRequest,
      requestStream: false,
      responseType: Notification,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              109,
              90,
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get notification settings. */
    getSettings: {
      name: "GetSettings",
      requestType: GetSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              95,
              90,
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /** Update notification settings. */
    updateSettings: {
      name: "UpdateSettings",
      requestType: UpdateSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 115, 101, 116, 116, 105, 110, 103, 115])],
          578365826: [
            Buffer.from([
              133,
              1,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              90,
              63,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              51,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              50,
              56,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AdvisoryNotificationsServiceImplementation<CallContextExt = {}> {
  /** Lists notifications under a given parent. */
  listNotifications(
    request: ListNotificationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNotificationsResponse>>;
  /** Gets a notification. */
  getNotification(
    request: GetNotificationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Notification>>;
  /** Get notification settings. */
  getSettings(request: GetSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
  /** Update notification settings. */
  updateSettings(request: UpdateSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
}

export interface AdvisoryNotificationsServiceClient<CallOptionsExt = {}> {
  /** Lists notifications under a given parent. */
  listNotifications(
    request: DeepPartial<ListNotificationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNotificationsResponse>;
  /** Gets a notification. */
  getNotification(
    request: DeepPartial<GetNotificationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Notification>;
  /** Get notification settings. */
  getSettings(request: DeepPartial<GetSettingsRequest>, options?: CallOptions & CallOptionsExt): Promise<Settings>;
  /** Update notification settings. */
  updateSettings(
    request: DeepPartial<UpdateSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Settings>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
