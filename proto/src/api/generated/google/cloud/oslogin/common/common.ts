// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/oslogin/common/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.oslogin.common";

/** The operating system options for account entries. */
export enum OperatingSystemType {
  /**
   * OPERATING_SYSTEM_TYPE_UNSPECIFIED - The operating system type associated with the user account information is
   * unspecified.
   */
  OPERATING_SYSTEM_TYPE_UNSPECIFIED = 0,
  /** LINUX - Linux user account information. */
  LINUX = 1,
  /** WINDOWS - Windows user account information. */
  WINDOWS = 2,
  UNRECOGNIZED = -1,
}

export function operatingSystemTypeFromJSON(object: any): OperatingSystemType {
  switch (object) {
    case 0:
    case "OPERATING_SYSTEM_TYPE_UNSPECIFIED":
      return OperatingSystemType.OPERATING_SYSTEM_TYPE_UNSPECIFIED;
    case 1:
    case "LINUX":
      return OperatingSystemType.LINUX;
    case 2:
    case "WINDOWS":
      return OperatingSystemType.WINDOWS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperatingSystemType.UNRECOGNIZED;
  }
}

export function operatingSystemTypeToJSON(object: OperatingSystemType): string {
  switch (object) {
    case OperatingSystemType.OPERATING_SYSTEM_TYPE_UNSPECIFIED:
      return "OPERATING_SYSTEM_TYPE_UNSPECIFIED";
    case OperatingSystemType.LINUX:
      return "LINUX";
    case OperatingSystemType.WINDOWS:
      return "WINDOWS";
    case OperatingSystemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The POSIX account information associated with a Google account. */
export interface PosixAccount {
  /** Only one POSIX account can be marked as primary. */
  primary: boolean;
  /** The username of the POSIX account. */
  username: string;
  /** The user ID. */
  uid: Long;
  /** The default group ID. */
  gid: Long;
  /** The path to the home directory for this account. */
  homeDirectory: string;
  /** The path to the logic shell for this account. */
  shell: string;
  /** The GECOS (user information) entry for this account. */
  gecos: string;
  /**
   * System identifier for which account the username or uid applies to.
   * By default, the empty value is used.
   */
  systemId: string;
  /** Output only. A POSIX account identifier. */
  accountId: string;
  /** The operating system type where this account applies. */
  operatingSystemType: OperatingSystemType;
  /** Output only. The canonical resource name. */
  name: string;
}

/** The SSH public key information associated with a Google account. */
export interface SshPublicKey {
  /**
   * Public key text in SSH format, defined by
   * <a href="https://www.ietf.org/rfc/rfc4253.txt" target="_blank">RFC4253</a>
   * section 6.6.
   */
  key: string;
  /** An expiration time in microseconds since epoch. */
  expirationTimeUsec: Long;
  /** Output only. The SHA-256 fingerprint of the SSH public key. */
  fingerprint: string;
  /** Output only. The canonical resource name. */
  name: string;
}

function createBasePosixAccount(): PosixAccount {
  return {
    primary: false,
    username: "",
    uid: Long.ZERO,
    gid: Long.ZERO,
    homeDirectory: "",
    shell: "",
    gecos: "",
    systemId: "",
    accountId: "",
    operatingSystemType: 0,
    name: "",
  };
}

export const PosixAccount: MessageFns<PosixAccount> = {
  encode(message: PosixAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primary !== false) {
      writer.uint32(8).bool(message.primary);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (!message.uid.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.uid.toString());
    }
    if (!message.gid.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.gid.toString());
    }
    if (message.homeDirectory !== "") {
      writer.uint32(42).string(message.homeDirectory);
    }
    if (message.shell !== "") {
      writer.uint32(50).string(message.shell);
    }
    if (message.gecos !== "") {
      writer.uint32(58).string(message.gecos);
    }
    if (message.systemId !== "") {
      writer.uint32(66).string(message.systemId);
    }
    if (message.accountId !== "") {
      writer.uint32(74).string(message.accountId);
    }
    if (message.operatingSystemType !== 0) {
      writer.uint32(80).int32(message.operatingSystemType);
    }
    if (message.name !== "") {
      writer.uint32(90).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PosixAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosixAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.primary = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.uid = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gid = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.homeDirectory = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shell = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gecos = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.systemId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.operatingSystemType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PosixAccount {
    return {
      primary: isSet(object.primary) ? globalThis.Boolean(object.primary) : false,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      uid: isSet(object.uid) ? Long.fromValue(object.uid) : Long.ZERO,
      gid: isSet(object.gid) ? Long.fromValue(object.gid) : Long.ZERO,
      homeDirectory: isSet(object.homeDirectory) ? globalThis.String(object.homeDirectory) : "",
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      gecos: isSet(object.gecos) ? globalThis.String(object.gecos) : "",
      systemId: isSet(object.systemId) ? globalThis.String(object.systemId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      operatingSystemType: isSet(object.operatingSystemType)
        ? operatingSystemTypeFromJSON(object.operatingSystemType)
        : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: PosixAccount): unknown {
    const obj: any = {};
    if (message.primary !== false) {
      obj.primary = message.primary;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (!message.uid.equals(Long.ZERO)) {
      obj.uid = (message.uid || Long.ZERO).toString();
    }
    if (!message.gid.equals(Long.ZERO)) {
      obj.gid = (message.gid || Long.ZERO).toString();
    }
    if (message.homeDirectory !== "") {
      obj.homeDirectory = message.homeDirectory;
    }
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.gecos !== "") {
      obj.gecos = message.gecos;
    }
    if (message.systemId !== "") {
      obj.systemId = message.systemId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.operatingSystemType !== 0) {
      obj.operatingSystemType = operatingSystemTypeToJSON(message.operatingSystemType);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PosixAccount>): PosixAccount {
    return PosixAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PosixAccount>): PosixAccount {
    const message = createBasePosixAccount();
    message.primary = object.primary ?? false;
    message.username = object.username ?? "";
    message.uid = (object.uid !== undefined && object.uid !== null) ? Long.fromValue(object.uid) : Long.ZERO;
    message.gid = (object.gid !== undefined && object.gid !== null) ? Long.fromValue(object.gid) : Long.ZERO;
    message.homeDirectory = object.homeDirectory ?? "";
    message.shell = object.shell ?? "";
    message.gecos = object.gecos ?? "";
    message.systemId = object.systemId ?? "";
    message.accountId = object.accountId ?? "";
    message.operatingSystemType = object.operatingSystemType ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSshPublicKey(): SshPublicKey {
  return { key: "", expirationTimeUsec: Long.ZERO, fingerprint: "", name: "" };
}

export const SshPublicKey: MessageFns<SshPublicKey> = {
  encode(message: SshPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.expirationTimeUsec.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expirationTimeUsec.toString());
    }
    if (message.fingerprint !== "") {
      writer.uint32(26).string(message.fingerprint);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SshPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSshPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expirationTimeUsec = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SshPublicKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      expirationTimeUsec: isSet(object.expirationTimeUsec) ? Long.fromValue(object.expirationTimeUsec) : Long.ZERO,
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SshPublicKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.expirationTimeUsec.equals(Long.ZERO)) {
      obj.expirationTimeUsec = (message.expirationTimeUsec || Long.ZERO).toString();
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SshPublicKey>): SshPublicKey {
    return SshPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SshPublicKey>): SshPublicKey {
    const message = createBaseSshPublicKey();
    message.key = object.key ?? "";
    message.expirationTimeUsec = (object.expirationTimeUsec !== undefined && object.expirationTimeUsec !== null)
      ? Long.fromValue(object.expirationTimeUsec)
      : Long.ZERO;
    message.fingerprint = object.fingerprint ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
