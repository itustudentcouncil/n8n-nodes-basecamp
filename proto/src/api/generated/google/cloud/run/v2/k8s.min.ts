// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/run/v2/k8s.min.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.run.v2";

/**
 * A single application container.
 * This specifies both the container to run, the command to run in the container
 * and the arguments to supply to it.
 * Note that additional arguments can be supplied by the system to the container
 * at runtime.
 */
export interface Container {
  /** Name of the container specified as a DNS_LABEL (RFC 1123). */
  name: string;
  /**
   * Required. Name of the container image in Dockerhub, Google Artifact
   * Registry, or Google Container Registry. If the host is not provided,
   * Dockerhub is assumed.
   */
  image: string;
  /**
   * Entrypoint array. Not executed within a shell.
   * The docker image's ENTRYPOINT is used if this is not provided.
   */
  command: string[];
  /**
   * Arguments to the entrypoint.
   * The docker image's CMD is used if this is not provided.
   */
  args: string[];
  /** List of environment variables to set in the container. */
  env: EnvVar[];
  /** Compute Resource requirements by this container. */
  resources:
    | ResourceRequirements
    | undefined;
  /**
   * List of ports to expose from the container. Only a single port can be
   * specified. The specified ports must be listening on all interfaces
   * (0.0.0.0) within the container to be accessible.
   *
   * If omitted, a port number will be chosen and passed to the container
   * through the PORT environment variable for the container to listen on.
   */
  ports: ContainerPort[];
  /** Volume to mount into the container's filesystem. */
  volumeMounts: VolumeMount[];
  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   */
  workingDir: string;
  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   */
  livenessProbe:
    | Probe
    | undefined;
  /**
   * Startup probe of application within the container.
   * All other probes are disabled if a startup probe is provided, until it
   * succeeds. Container will not be added to service endpoints if the probe
   * fails.
   */
  startupProbe:
    | Probe
    | undefined;
  /** Names of the containers that must start before this container. */
  dependsOn: string[];
}

/** ResourceRequirements describes the compute resource requirements. */
export interface ResourceRequirements {
  /**
   * Only `memory` and `cpu` keys in the map are supported.
   *
   * <p>Notes:
   *  * The only supported values for CPU are '1', '2', '4', and '8'. Setting 4
   * CPU requires at least 2Gi of memory. For more information, go to
   * https://cloud.google.com/run/docs/configuring/cpu.
   *   * For supported 'memory' values and syntax, go to
   *  https://cloud.google.com/run/docs/configuring/memory-limits
   */
  limits: { [key: string]: string };
  /**
   * Determines whether CPU is only allocated during requests (true by default).
   * However, if ResourceRequirements is set, the caller must explicitly
   * set this field to true to preserve the default behavior.
   */
  cpuIdle: boolean;
  /**
   * Determines whether CPU should be boosted on startup of a new container
   * instance above the requested CPU threshold, this can help reduce cold-start
   * latency.
   */
  startupCpuBoost: boolean;
}

export interface ResourceRequirements_LimitsEntry {
  key: string;
  value: string;
}

/** EnvVar represents an environment variable present in a Container. */
export interface EnvVar {
  /**
   * Required. Name of the environment variable. Must not exceed 32768
   * characters.
   */
  name: string;
  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previous defined environment variables in the container and
   * any route environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. The $(VAR_NAME)
   * syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
   * references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "", and the maximum length is 32768 bytes.
   */
  value?:
    | string
    | undefined;
  /** Source for the environment variable's value. */
  valueSource?: EnvVarSource | undefined;
}

/** EnvVarSource represents a source for the value of an EnvVar. */
export interface EnvVarSource {
  /** Selects a secret and a specific version from Cloud Secret Manager. */
  secretKeyRef: SecretKeySelector | undefined;
}

/** SecretEnvVarSource represents a source for the value of an EnvVar. */
export interface SecretKeySelector {
  /**
   * Required. The name of the secret in Cloud Secret Manager.
   * Format: {secret_name} if the secret is in the same project.
   * projects/{project}/secrets/{secret_name} if the secret is
   * in a different project.
   */
  secret: string;
  /**
   * The Cloud Secret Manager secret version.
   * Can be 'latest' for the latest version, an integer for a specific version,
   * or a version alias.
   */
  version: string;
}

/** ContainerPort represents a network port in a single container. */
export interface ContainerPort {
  /**
   * If specified, used to specify which protocol to use.
   * Allowed values are "http1" and "h2c".
   */
  name: string;
  /**
   * Port number the container listens on.
   * This must be a valid TCP port number, 0 < container_port < 65536.
   */
  containerPort: number;
}

/** VolumeMount describes a mounting of a Volume within a container. */
export interface VolumeMount {
  /** Required. This must match the Name of a Volume. */
  name: string;
  /**
   * Required. Path within the container at which the volume should be mounted.
   * Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must
   * otherwise be `/cloudsql`. All instances defined in the Volume will be
   * available as `/cloudsql/[instance]`. For more information on Cloud SQL
   * volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run
   */
  mountPath: string;
}

/** Volume represents a named volume in a container. */
export interface Volume {
  /** Required. Volume's name. */
  name: string;
  /** Secret represents a secret that should populate this volume. */
  secret?:
    | SecretVolumeSource
    | undefined;
  /**
   * For Cloud SQL volumes, contains the specific instances that should be
   * mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for
   * more information on how to connect Cloud SQL and Cloud Run.
   */
  cloudSqlInstance?:
    | CloudSqlInstance
    | undefined;
  /** Ephemeral storage used as a shared volume. */
  emptyDir?:
    | EmptyDirVolumeSource
    | undefined;
  /** For NFS Voumes, contains the path to the nfs Volume */
  nfs?:
    | NFSVolumeSource
    | undefined;
  /** Persistent storage backed by a Google Cloud Storage bucket. */
  gcs?: GCSVolumeSource | undefined;
}

/**
 * The secret's value will be presented as the content of a file whose
 * name is defined in the item path. If no items are defined, the name of
 * the file is the secret.
 */
export interface SecretVolumeSource {
  /**
   * Required. The name of the secret in Cloud Secret Manager.
   * Format: {secret} if the secret is in the same project.
   * projects/{project}/secrets/{secret} if the secret is
   * in a different project.
   */
  secret: string;
  /**
   * If unspecified, the volume will expose a file whose name is the
   * secret, relative to VolumeMount.mount_path.
   * If specified, the key will be used as the version to fetch from Cloud
   * Secret Manager and the path will be the name of the file exposed in the
   * volume. When items are defined, they must specify a path and a version.
   */
  items: VersionToPath[];
  /**
   * Integer representation of mode bits to use on created files by default.
   * Must be a value between 0000 and 0777 (octal), defaulting to 0444.
   * Directories within the path are not affected by  this setting.
   *
   * Notes
   *
   * * Internally, a umask of 0222 will be applied to any non-zero value.
   * * This is an integer representation of the mode bits. So, the octal
   * integer value should look exactly as the chmod numeric notation with a
   * leading zero. Some examples: for chmod 777 (a=rwx), set to 0777 (octal) or
   * 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or
   * 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493
   * (base-10).
   * * This might be in conflict with other options that affect the
   * file mode, like fsGroup, and the result can be other mode bits set.
   *
   * This might be in conflict with other options that affect the
   * file mode, like fsGroup, and as a result, other mode bits could be set.
   */
  defaultMode: number;
}

/**
 * VersionToPath maps a specific version of a secret to a relative file to mount
 * to, relative to VolumeMount's mount_path.
 */
export interface VersionToPath {
  /** Required. The relative path of the secret in the container. */
  path: string;
  /**
   * The Cloud Secret Manager secret version.
   * Can be 'latest' for the latest value, or an integer or a secret alias for a
   * specific version.
   */
  version: string;
  /**
   * Integer octal mode bits to use on this file, must be a value between
   * 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be
   * used.
   *
   * Notes
   *
   * * Internally, a umask of 0222 will be applied to any non-zero value.
   * * This is an integer representation of the mode bits. So, the octal
   * integer value should look exactly as the chmod numeric notation with a
   * leading zero. Some examples: for chmod 777 (a=rwx), set to 0777 (octal) or
   * 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or
   * 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493
   * (base-10).
   * * This might be in conflict with other options that affect the
   * file mode, like fsGroup, and the result can be other mode bits set.
   */
  mode: number;
}

/**
 * Represents a set of Cloud SQL instances. Each one will be available under
 * /cloudsql/[instance]. Visit
 * https://cloud.google.com/sql/docs/mysql/connect-run for more information on
 * how to connect Cloud SQL and Cloud Run.
 */
export interface CloudSqlInstance {
  /**
   * The Cloud SQL instance connection names, as can be found in
   * https://console.cloud.google.com/sql/instances. Visit
   * https://cloud.google.com/sql/docs/mysql/connect-run for more information on
   * how to connect Cloud SQL and Cloud Run. Format:
   * {project}:{location}:{instance}
   */
  instances: string[];
}

/**
 * In memory (tmpfs) ephemeral storage.
 * It is ephemeral in the sense that when the sandbox is taken down, the data is
 * destroyed with it (it does not persist across sandbox runs).
 */
export interface EmptyDirVolumeSource {
  /**
   * The medium on which the data is stored. Acceptable values today is only
   * MEMORY or none. When none, the default will currently be backed by memory
   * but could change over time. +optional
   */
  medium: EmptyDirVolumeSource_Medium;
  /**
   * Limit on the storage usable by this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value
   * between the SizeLimit specified here and the sum of memory limits of all
   * containers. The default is nil which means that the limit is undefined.
   * More info:
   * https://cloud.google.com/run/docs/configuring/in-memory-volumes#configure-volume.
   * Info in Kubernetes:
   * https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   */
  sizeLimit: string;
}

/** The different types of medium supported for EmptyDir. */
export enum EmptyDirVolumeSource_Medium {
  /**
   * MEDIUM_UNSPECIFIED - When not specified, falls back to the default implementation which
   * is currently in memory (this may change over time).
   */
  MEDIUM_UNSPECIFIED = 0,
  /** MEMORY - Explicitly set the EmptyDir to be in memory. Uses tmpfs. */
  MEMORY = 1,
  UNRECOGNIZED = -1,
}

export function emptyDirVolumeSource_MediumFromJSON(object: any): EmptyDirVolumeSource_Medium {
  switch (object) {
    case 0:
    case "MEDIUM_UNSPECIFIED":
      return EmptyDirVolumeSource_Medium.MEDIUM_UNSPECIFIED;
    case 1:
    case "MEMORY":
      return EmptyDirVolumeSource_Medium.MEMORY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmptyDirVolumeSource_Medium.UNRECOGNIZED;
  }
}

export function emptyDirVolumeSource_MediumToJSON(object: EmptyDirVolumeSource_Medium): string {
  switch (object) {
    case EmptyDirVolumeSource_Medium.MEDIUM_UNSPECIFIED:
      return "MEDIUM_UNSPECIFIED";
    case EmptyDirVolumeSource_Medium.MEMORY:
      return "MEMORY";
    case EmptyDirVolumeSource_Medium.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents an NFS mount. */
export interface NFSVolumeSource {
  /** Hostname or IP address of the NFS server */
  server: string;
  /** Path that is exported by the NFS server. */
  path: string;
  /** If true, the volume will be mounted as read only for all mounts. */
  readOnly: boolean;
}

/**
 * Represents a volume backed by a Cloud Storage bucket using Cloud Storage
 * FUSE.
 */
export interface GCSVolumeSource {
  /** Cloud Storage Bucket name. */
  bucket: string;
  /** If true, the volume will be mounted as read only for all mounts. */
  readOnly: boolean;
}

/**
 * Probe describes a health check to be performed against a container to
 * determine whether it is alive or ready to receive traffic.
 */
export interface Probe {
  /**
   * Optional. Number of seconds after the container has started before the
   * probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum
   * value for liveness probe is 3600. Maximum value for startup probe is 240.
   */
  initialDelaySeconds: number;
  /**
   * Optional. Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
   * Must be smaller than period_seconds.
   */
  timeoutSeconds: number;
  /**
   * Optional. How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe
   * is 3600. Maximum value for startup probe is 240.
   * Must be greater or equal than timeout_seconds.
   */
  periodSeconds: number;
  /**
   * Optional. Minimum consecutive failures for the probe to be considered
   * failed after having succeeded. Defaults to 3. Minimum value is 1.
   */
  failureThreshold: number;
  /**
   * Optional. HTTPGet specifies the http request to perform.
   * Exactly one of httpGet, tcpSocket, or grpc must be specified.
   */
  httpGet?:
    | HTTPGetAction
    | undefined;
  /**
   * Optional. TCPSocket specifies an action involving a TCP port.
   * Exactly one of httpGet, tcpSocket, or grpc must be specified.
   */
  tcpSocket?:
    | TCPSocketAction
    | undefined;
  /**
   * Optional. GRPC specifies an action involving a gRPC port.
   * Exactly one of httpGet, tcpSocket, or grpc must be specified.
   */
  grpc?: GRPCAction | undefined;
}

/** HTTPGetAction describes an action based on HTTP Get requests. */
export interface HTTPGetAction {
  /** Optional. Path to access on the HTTP server. Defaults to '/'. */
  path: string;
  /**
   * Optional. Custom headers to set in the request. HTTP allows repeated
   * headers.
   */
  httpHeaders: HTTPHeader[];
  /**
   * Optional. Port number to access on the container. Must be in the range 1 to
   * 65535. If not specified, defaults to the exposed port of the container,
   * which is the value of container.ports[0].containerPort.
   */
  port: number;
}

/** HTTPHeader describes a custom header to be used in HTTP probes */
export interface HTTPHeader {
  /** Required. The header field name */
  name: string;
  /** Optional. The header field value */
  value: string;
}

/** TCPSocketAction describes an action based on opening a socket */
export interface TCPSocketAction {
  /**
   * Optional. Port number to access on the container. Must be in the range 1 to
   * 65535. If not specified, defaults to the exposed port of the container,
   * which is the value of container.ports[0].containerPort.
   */
  port: number;
}

/** GRPCAction describes an action involving a GRPC port. */
export interface GRPCAction {
  /**
   * Optional. Port number of the gRPC service. Number must be in the range 1 to
   * 65535. If not specified, defaults to the exposed port of the container,
   * which is the value of container.ports[0].containerPort.
   */
  port: number;
  /**
   * Optional. Service is the name of the service to place in the gRPC
   * HealthCheckRequest (see
   * https://github.com/grpc/grpc/blob/master/doc/health-checking.md ). If this
   * is not specified, the default behavior is defined by gRPC.
   */
  service: string;
}

function createBaseContainer(): Container {
  return {
    name: "",
    image: "",
    command: [],
    args: [],
    env: [],
    resources: undefined,
    ports: [],
    volumeMounts: [],
    workingDir: "",
    livenessProbe: undefined,
    startupProbe: undefined,
    dependsOn: [],
  };
}

export const Container: MessageFns<Container> = {
  encode(message: Container, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.image !== "") {
      writer.uint32(18).string(message.image);
    }
    for (const v of message.command) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.args) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.env) {
      EnvVar.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.resources !== undefined) {
      ResourceRequirements.encode(message.resources, writer.uint32(50).fork()).join();
    }
    for (const v of message.ports) {
      ContainerPort.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.volumeMounts) {
      VolumeMount.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.workingDir !== "") {
      writer.uint32(74).string(message.workingDir);
    }
    if (message.livenessProbe !== undefined) {
      Probe.encode(message.livenessProbe, writer.uint32(82).fork()).join();
    }
    if (message.startupProbe !== undefined) {
      Probe.encode(message.startupProbe, writer.uint32(90).fork()).join();
    }
    for (const v of message.dependsOn) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Container {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.env.push(EnvVar.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resources = ResourceRequirements.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ports.push(ContainerPort.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.volumeMounts.push(VolumeMount.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.workingDir = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.livenessProbe = Probe.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.startupProbe = Probe.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.dependsOn.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Container {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e: any) => globalThis.String(e)) : [],
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      env: globalThis.Array.isArray(object?.env) ? object.env.map((e: any) => EnvVar.fromJSON(e)) : [],
      resources: isSet(object.resources) ? ResourceRequirements.fromJSON(object.resources) : undefined,
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => ContainerPort.fromJSON(e)) : [],
      volumeMounts: globalThis.Array.isArray(object?.volumeMounts)
        ? object.volumeMounts.map((e: any) => VolumeMount.fromJSON(e))
        : [],
      workingDir: isSet(object.workingDir) ? globalThis.String(object.workingDir) : "",
      livenessProbe: isSet(object.livenessProbe) ? Probe.fromJSON(object.livenessProbe) : undefined,
      startupProbe: isSet(object.startupProbe) ? Probe.fromJSON(object.startupProbe) : undefined,
      dependsOn: globalThis.Array.isArray(object?.dependsOn)
        ? object.dependsOn.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Container): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.env?.length) {
      obj.env = message.env.map((e) => EnvVar.toJSON(e));
    }
    if (message.resources !== undefined) {
      obj.resources = ResourceRequirements.toJSON(message.resources);
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => ContainerPort.toJSON(e));
    }
    if (message.volumeMounts?.length) {
      obj.volumeMounts = message.volumeMounts.map((e) => VolumeMount.toJSON(e));
    }
    if (message.workingDir !== "") {
      obj.workingDir = message.workingDir;
    }
    if (message.livenessProbe !== undefined) {
      obj.livenessProbe = Probe.toJSON(message.livenessProbe);
    }
    if (message.startupProbe !== undefined) {
      obj.startupProbe = Probe.toJSON(message.startupProbe);
    }
    if (message.dependsOn?.length) {
      obj.dependsOn = message.dependsOn;
    }
    return obj;
  },

  create(base?: DeepPartial<Container>): Container {
    return Container.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Container>): Container {
    const message = createBaseContainer();
    message.name = object.name ?? "";
    message.image = object.image ?? "";
    message.command = object.command?.map((e) => e) || [];
    message.args = object.args?.map((e) => e) || [];
    message.env = object.env?.map((e) => EnvVar.fromPartial(e)) || [];
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? ResourceRequirements.fromPartial(object.resources)
      : undefined;
    message.ports = object.ports?.map((e) => ContainerPort.fromPartial(e)) || [];
    message.volumeMounts = object.volumeMounts?.map((e) => VolumeMount.fromPartial(e)) || [];
    message.workingDir = object.workingDir ?? "";
    message.livenessProbe = (object.livenessProbe !== undefined && object.livenessProbe !== null)
      ? Probe.fromPartial(object.livenessProbe)
      : undefined;
    message.startupProbe = (object.startupProbe !== undefined && object.startupProbe !== null)
      ? Probe.fromPartial(object.startupProbe)
      : undefined;
    message.dependsOn = object.dependsOn?.map((e) => e) || [];
    return message;
  },
};

function createBaseResourceRequirements(): ResourceRequirements {
  return { limits: {}, cpuIdle: false, startupCpuBoost: false };
}

export const ResourceRequirements: MessageFns<ResourceRequirements> = {
  encode(message: ResourceRequirements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.limits).forEach(([key, value]) => {
      ResourceRequirements_LimitsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.cpuIdle !== false) {
      writer.uint32(16).bool(message.cpuIdle);
    }
    if (message.startupCpuBoost !== false) {
      writer.uint32(24).bool(message.startupCpuBoost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRequirements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ResourceRequirements_LimitsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.limits[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpuIdle = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.startupCpuBoost = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRequirements {
    return {
      limits: isObject(object.limits)
        ? Object.entries(object.limits).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      cpuIdle: isSet(object.cpuIdle) ? globalThis.Boolean(object.cpuIdle) : false,
      startupCpuBoost: isSet(object.startupCpuBoost) ? globalThis.Boolean(object.startupCpuBoost) : false,
    };
  },

  toJSON(message: ResourceRequirements): unknown {
    const obj: any = {};
    if (message.limits) {
      const entries = Object.entries(message.limits);
      if (entries.length > 0) {
        obj.limits = {};
        entries.forEach(([k, v]) => {
          obj.limits[k] = v;
        });
      }
    }
    if (message.cpuIdle !== false) {
      obj.cpuIdle = message.cpuIdle;
    }
    if (message.startupCpuBoost !== false) {
      obj.startupCpuBoost = message.startupCpuBoost;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRequirements>): ResourceRequirements {
    return ResourceRequirements.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRequirements>): ResourceRequirements {
    const message = createBaseResourceRequirements();
    message.limits = Object.entries(object.limits ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.cpuIdle = object.cpuIdle ?? false;
    message.startupCpuBoost = object.startupCpuBoost ?? false;
    return message;
  },
};

function createBaseResourceRequirements_LimitsEntry(): ResourceRequirements_LimitsEntry {
  return { key: "", value: "" };
}

export const ResourceRequirements_LimitsEntry: MessageFns<ResourceRequirements_LimitsEntry> = {
  encode(message: ResourceRequirements_LimitsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRequirements_LimitsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRequirements_LimitsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRequirements_LimitsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceRequirements_LimitsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRequirements_LimitsEntry>): ResourceRequirements_LimitsEntry {
    return ResourceRequirements_LimitsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRequirements_LimitsEntry>): ResourceRequirements_LimitsEntry {
    const message = createBaseResourceRequirements_LimitsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnvVar(): EnvVar {
  return { name: "", value: undefined, valueSource: undefined };
}

export const EnvVar: MessageFns<EnvVar> = {
  encode(message: EnvVar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    if (message.valueSource !== undefined) {
      EnvVarSource.encode(message.valueSource, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvVar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.valueSource = EnvVarSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvVar {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      valueSource: isSet(object.valueSource) ? EnvVarSource.fromJSON(object.valueSource) : undefined,
    };
  },

  toJSON(message: EnvVar): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.valueSource !== undefined) {
      obj.valueSource = EnvVarSource.toJSON(message.valueSource);
    }
    return obj;
  },

  create(base?: DeepPartial<EnvVar>): EnvVar {
    return EnvVar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvVar>): EnvVar {
    const message = createBaseEnvVar();
    message.name = object.name ?? "";
    message.value = object.value ?? undefined;
    message.valueSource = (object.valueSource !== undefined && object.valueSource !== null)
      ? EnvVarSource.fromPartial(object.valueSource)
      : undefined;
    return message;
  },
};

function createBaseEnvVarSource(): EnvVarSource {
  return { secretKeyRef: undefined };
}

export const EnvVarSource: MessageFns<EnvVarSource> = {
  encode(message: EnvVarSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretKeyRef !== undefined) {
      SecretKeySelector.encode(message.secretKeyRef, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvVarSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvVarSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secretKeyRef = SecretKeySelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvVarSource {
    return { secretKeyRef: isSet(object.secretKeyRef) ? SecretKeySelector.fromJSON(object.secretKeyRef) : undefined };
  },

  toJSON(message: EnvVarSource): unknown {
    const obj: any = {};
    if (message.secretKeyRef !== undefined) {
      obj.secretKeyRef = SecretKeySelector.toJSON(message.secretKeyRef);
    }
    return obj;
  },

  create(base?: DeepPartial<EnvVarSource>): EnvVarSource {
    return EnvVarSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvVarSource>): EnvVarSource {
    const message = createBaseEnvVarSource();
    message.secretKeyRef = (object.secretKeyRef !== undefined && object.secretKeyRef !== null)
      ? SecretKeySelector.fromPartial(object.secretKeyRef)
      : undefined;
    return message;
  },
};

function createBaseSecretKeySelector(): SecretKeySelector {
  return { secret: "", version: "" };
}

export const SecretKeySelector: MessageFns<SecretKeySelector> = {
  encode(message: SecretKeySelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== "") {
      writer.uint32(10).string(message.secret);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretKeySelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretKeySelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secret = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretKeySelector {
    return {
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: SecretKeySelector): unknown {
    const obj: any = {};
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<SecretKeySelector>): SecretKeySelector {
    return SecretKeySelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretKeySelector>): SecretKeySelector {
    const message = createBaseSecretKeySelector();
    message.secret = object.secret ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseContainerPort(): ContainerPort {
  return { name: "", containerPort: 0 };
}

export const ContainerPort: MessageFns<ContainerPort> = {
  encode(message: ContainerPort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.containerPort !== 0) {
      writer.uint32(24).int32(message.containerPort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerPort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerPort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.containerPort = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerPort {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      containerPort: isSet(object.containerPort) ? globalThis.Number(object.containerPort) : 0,
    };
  },

  toJSON(message: ContainerPort): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.containerPort !== 0) {
      obj.containerPort = Math.round(message.containerPort);
    }
    return obj;
  },

  create(base?: DeepPartial<ContainerPort>): ContainerPort {
    return ContainerPort.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContainerPort>): ContainerPort {
    const message = createBaseContainerPort();
    message.name = object.name ?? "";
    message.containerPort = object.containerPort ?? 0;
    return message;
  },
};

function createBaseVolumeMount(): VolumeMount {
  return { name: "", mountPath: "" };
}

export const VolumeMount: MessageFns<VolumeMount> = {
  encode(message: VolumeMount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mountPath !== "") {
      writer.uint32(26).string(message.mountPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeMount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeMount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mountPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeMount {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : "",
    };
  },

  toJSON(message: VolumeMount): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    return obj;
  },

  create(base?: DeepPartial<VolumeMount>): VolumeMount {
    return VolumeMount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VolumeMount>): VolumeMount {
    const message = createBaseVolumeMount();
    message.name = object.name ?? "";
    message.mountPath = object.mountPath ?? "";
    return message;
  },
};

function createBaseVolume(): Volume {
  return {
    name: "",
    secret: undefined,
    cloudSqlInstance: undefined,
    emptyDir: undefined,
    nfs: undefined,
    gcs: undefined,
  };
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.secret !== undefined) {
      SecretVolumeSource.encode(message.secret, writer.uint32(18).fork()).join();
    }
    if (message.cloudSqlInstance !== undefined) {
      CloudSqlInstance.encode(message.cloudSqlInstance, writer.uint32(26).fork()).join();
    }
    if (message.emptyDir !== undefined) {
      EmptyDirVolumeSource.encode(message.emptyDir, writer.uint32(34).fork()).join();
    }
    if (message.nfs !== undefined) {
      NFSVolumeSource.encode(message.nfs, writer.uint32(42).fork()).join();
    }
    if (message.gcs !== undefined) {
      GCSVolumeSource.encode(message.gcs, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secret = SecretVolumeSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudSqlInstance = CloudSqlInstance.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.emptyDir = EmptyDirVolumeSource.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nfs = NFSVolumeSource.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gcs = GCSVolumeSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      secret: isSet(object.secret) ? SecretVolumeSource.fromJSON(object.secret) : undefined,
      cloudSqlInstance: isSet(object.cloudSqlInstance) ? CloudSqlInstance.fromJSON(object.cloudSqlInstance) : undefined,
      emptyDir: isSet(object.emptyDir) ? EmptyDirVolumeSource.fromJSON(object.emptyDir) : undefined,
      nfs: isSet(object.nfs) ? NFSVolumeSource.fromJSON(object.nfs) : undefined,
      gcs: isSet(object.gcs) ? GCSVolumeSource.fromJSON(object.gcs) : undefined,
    };
  },

  toJSON(message: Volume): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.secret !== undefined) {
      obj.secret = SecretVolumeSource.toJSON(message.secret);
    }
    if (message.cloudSqlInstance !== undefined) {
      obj.cloudSqlInstance = CloudSqlInstance.toJSON(message.cloudSqlInstance);
    }
    if (message.emptyDir !== undefined) {
      obj.emptyDir = EmptyDirVolumeSource.toJSON(message.emptyDir);
    }
    if (message.nfs !== undefined) {
      obj.nfs = NFSVolumeSource.toJSON(message.nfs);
    }
    if (message.gcs !== undefined) {
      obj.gcs = GCSVolumeSource.toJSON(message.gcs);
    }
    return obj;
  },

  create(base?: DeepPartial<Volume>): Volume {
    return Volume.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume>): Volume {
    const message = createBaseVolume();
    message.name = object.name ?? "";
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? SecretVolumeSource.fromPartial(object.secret)
      : undefined;
    message.cloudSqlInstance = (object.cloudSqlInstance !== undefined && object.cloudSqlInstance !== null)
      ? CloudSqlInstance.fromPartial(object.cloudSqlInstance)
      : undefined;
    message.emptyDir = (object.emptyDir !== undefined && object.emptyDir !== null)
      ? EmptyDirVolumeSource.fromPartial(object.emptyDir)
      : undefined;
    message.nfs = (object.nfs !== undefined && object.nfs !== null)
      ? NFSVolumeSource.fromPartial(object.nfs)
      : undefined;
    message.gcs = (object.gcs !== undefined && object.gcs !== null)
      ? GCSVolumeSource.fromPartial(object.gcs)
      : undefined;
    return message;
  },
};

function createBaseSecretVolumeSource(): SecretVolumeSource {
  return { secret: "", items: [], defaultMode: 0 };
}

export const SecretVolumeSource: MessageFns<SecretVolumeSource> = {
  encode(message: SecretVolumeSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== "") {
      writer.uint32(10).string(message.secret);
    }
    for (const v of message.items) {
      VersionToPath.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.defaultMode !== 0) {
      writer.uint32(24).int32(message.defaultMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretVolumeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretVolumeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secret = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(VersionToPath.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultMode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretVolumeSource {
    return {
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => VersionToPath.fromJSON(e)) : [],
      defaultMode: isSet(object.defaultMode) ? globalThis.Number(object.defaultMode) : 0,
    };
  },

  toJSON(message: SecretVolumeSource): unknown {
    const obj: any = {};
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => VersionToPath.toJSON(e));
    }
    if (message.defaultMode !== 0) {
      obj.defaultMode = Math.round(message.defaultMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SecretVolumeSource>): SecretVolumeSource {
    return SecretVolumeSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretVolumeSource>): SecretVolumeSource {
    const message = createBaseSecretVolumeSource();
    message.secret = object.secret ?? "";
    message.items = object.items?.map((e) => VersionToPath.fromPartial(e)) || [];
    message.defaultMode = object.defaultMode ?? 0;
    return message;
  },
};

function createBaseVersionToPath(): VersionToPath {
  return { path: "", version: "", mode: 0 };
}

export const VersionToPath: MessageFns<VersionToPath> = {
  encode(message: VersionToPath, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionToPath {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionToPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionToPath {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: VersionToPath): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<VersionToPath>): VersionToPath {
    return VersionToPath.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VersionToPath>): VersionToPath {
    const message = createBaseVersionToPath();
    message.path = object.path ?? "";
    message.version = object.version ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseCloudSqlInstance(): CloudSqlInstance {
  return { instances: [] };
}

export const CloudSqlInstance: MessageFns<CloudSqlInstance> = {
  encode(message: CloudSqlInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlInstance {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CloudSqlInstance): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlInstance>): CloudSqlInstance {
    return CloudSqlInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlInstance>): CloudSqlInstance {
    const message = createBaseCloudSqlInstance();
    message.instances = object.instances?.map((e) => e) || [];
    return message;
  },
};

function createBaseEmptyDirVolumeSource(): EmptyDirVolumeSource {
  return { medium: 0, sizeLimit: "" };
}

export const EmptyDirVolumeSource: MessageFns<EmptyDirVolumeSource> = {
  encode(message: EmptyDirVolumeSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.medium !== 0) {
      writer.uint32(8).int32(message.medium);
    }
    if (message.sizeLimit !== "") {
      writer.uint32(18).string(message.sizeLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyDirVolumeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyDirVolumeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.medium = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sizeLimit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmptyDirVolumeSource {
    return {
      medium: isSet(object.medium) ? emptyDirVolumeSource_MediumFromJSON(object.medium) : 0,
      sizeLimit: isSet(object.sizeLimit) ? globalThis.String(object.sizeLimit) : "",
    };
  },

  toJSON(message: EmptyDirVolumeSource): unknown {
    const obj: any = {};
    if (message.medium !== 0) {
      obj.medium = emptyDirVolumeSource_MediumToJSON(message.medium);
    }
    if (message.sizeLimit !== "") {
      obj.sizeLimit = message.sizeLimit;
    }
    return obj;
  },

  create(base?: DeepPartial<EmptyDirVolumeSource>): EmptyDirVolumeSource {
    return EmptyDirVolumeSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmptyDirVolumeSource>): EmptyDirVolumeSource {
    const message = createBaseEmptyDirVolumeSource();
    message.medium = object.medium ?? 0;
    message.sizeLimit = object.sizeLimit ?? "";
    return message;
  },
};

function createBaseNFSVolumeSource(): NFSVolumeSource {
  return { server: "", path: "", readOnly: false };
}

export const NFSVolumeSource: MessageFns<NFSVolumeSource> = {
  encode(message: NFSVolumeSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server !== "") {
      writer.uint32(10).string(message.server);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.readOnly !== false) {
      writer.uint32(24).bool(message.readOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NFSVolumeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFSVolumeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.server = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFSVolumeSource {
    return {
      server: isSet(object.server) ? globalThis.String(object.server) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
    };
  },

  toJSON(message: NFSVolumeSource): unknown {
    const obj: any = {};
    if (message.server !== "") {
      obj.server = message.server;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<NFSVolumeSource>): NFSVolumeSource {
    return NFSVolumeSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NFSVolumeSource>): NFSVolumeSource {
    const message = createBaseNFSVolumeSource();
    message.server = object.server ?? "";
    message.path = object.path ?? "";
    message.readOnly = object.readOnly ?? false;
    return message;
  },
};

function createBaseGCSVolumeSource(): GCSVolumeSource {
  return { bucket: "", readOnly: false };
}

export const GCSVolumeSource: MessageFns<GCSVolumeSource> = {
  encode(message: GCSVolumeSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.readOnly !== false) {
      writer.uint32(16).bool(message.readOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GCSVolumeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGCSVolumeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GCSVolumeSource {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
    };
  },

  toJSON(message: GCSVolumeSource): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<GCSVolumeSource>): GCSVolumeSource {
    return GCSVolumeSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GCSVolumeSource>): GCSVolumeSource {
    const message = createBaseGCSVolumeSource();
    message.bucket = object.bucket ?? "";
    message.readOnly = object.readOnly ?? false;
    return message;
  },
};

function createBaseProbe(): Probe {
  return {
    initialDelaySeconds: 0,
    timeoutSeconds: 0,
    periodSeconds: 0,
    failureThreshold: 0,
    httpGet: undefined,
    tcpSocket: undefined,
    grpc: undefined,
  };
}

export const Probe: MessageFns<Probe> = {
  encode(message: Probe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialDelaySeconds !== 0) {
      writer.uint32(8).int32(message.initialDelaySeconds);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(16).int32(message.timeoutSeconds);
    }
    if (message.periodSeconds !== 0) {
      writer.uint32(24).int32(message.periodSeconds);
    }
    if (message.failureThreshold !== 0) {
      writer.uint32(32).int32(message.failureThreshold);
    }
    if (message.httpGet !== undefined) {
      HTTPGetAction.encode(message.httpGet, writer.uint32(42).fork()).join();
    }
    if (message.tcpSocket !== undefined) {
      TCPSocketAction.encode(message.tcpSocket, writer.uint32(50).fork()).join();
    }
    if (message.grpc !== undefined) {
      GRPCAction.encode(message.grpc, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Probe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProbe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.initialDelaySeconds = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.periodSeconds = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureThreshold = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.httpGet = HTTPGetAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tcpSocket = TCPSocketAction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.grpc = GRPCAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Probe {
    return {
      initialDelaySeconds: isSet(object.initialDelaySeconds) ? globalThis.Number(object.initialDelaySeconds) : 0,
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      periodSeconds: isSet(object.periodSeconds) ? globalThis.Number(object.periodSeconds) : 0,
      failureThreshold: isSet(object.failureThreshold) ? globalThis.Number(object.failureThreshold) : 0,
      httpGet: isSet(object.httpGet) ? HTTPGetAction.fromJSON(object.httpGet) : undefined,
      tcpSocket: isSet(object.tcpSocket) ? TCPSocketAction.fromJSON(object.tcpSocket) : undefined,
      grpc: isSet(object.grpc) ? GRPCAction.fromJSON(object.grpc) : undefined,
    };
  },

  toJSON(message: Probe): unknown {
    const obj: any = {};
    if (message.initialDelaySeconds !== 0) {
      obj.initialDelaySeconds = Math.round(message.initialDelaySeconds);
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.periodSeconds !== 0) {
      obj.periodSeconds = Math.round(message.periodSeconds);
    }
    if (message.failureThreshold !== 0) {
      obj.failureThreshold = Math.round(message.failureThreshold);
    }
    if (message.httpGet !== undefined) {
      obj.httpGet = HTTPGetAction.toJSON(message.httpGet);
    }
    if (message.tcpSocket !== undefined) {
      obj.tcpSocket = TCPSocketAction.toJSON(message.tcpSocket);
    }
    if (message.grpc !== undefined) {
      obj.grpc = GRPCAction.toJSON(message.grpc);
    }
    return obj;
  },

  create(base?: DeepPartial<Probe>): Probe {
    return Probe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Probe>): Probe {
    const message = createBaseProbe();
    message.initialDelaySeconds = object.initialDelaySeconds ?? 0;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.periodSeconds = object.periodSeconds ?? 0;
    message.failureThreshold = object.failureThreshold ?? 0;
    message.httpGet = (object.httpGet !== undefined && object.httpGet !== null)
      ? HTTPGetAction.fromPartial(object.httpGet)
      : undefined;
    message.tcpSocket = (object.tcpSocket !== undefined && object.tcpSocket !== null)
      ? TCPSocketAction.fromPartial(object.tcpSocket)
      : undefined;
    message.grpc = (object.grpc !== undefined && object.grpc !== null)
      ? GRPCAction.fromPartial(object.grpc)
      : undefined;
    return message;
  },
};

function createBaseHTTPGetAction(): HTTPGetAction {
  return { path: "", httpHeaders: [], port: 0 };
}

export const HTTPGetAction: MessageFns<HTTPGetAction> = {
  encode(message: HTTPGetAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    for (const v of message.httpHeaders) {
      HTTPHeader.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(40).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPGetAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPGetAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.httpHeaders.push(HTTPHeader.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPGetAction {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      httpHeaders: globalThis.Array.isArray(object?.httpHeaders)
        ? object.httpHeaders.map((e: any) => HTTPHeader.fromJSON(e))
        : [],
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: HTTPGetAction): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.httpHeaders?.length) {
      obj.httpHeaders = message.httpHeaders.map((e) => HTTPHeader.toJSON(e));
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<HTTPGetAction>): HTTPGetAction {
    return HTTPGetAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HTTPGetAction>): HTTPGetAction {
    const message = createBaseHTTPGetAction();
    message.path = object.path ?? "";
    message.httpHeaders = object.httpHeaders?.map((e) => HTTPHeader.fromPartial(e)) || [];
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseHTTPHeader(): HTTPHeader {
  return { name: "", value: "" };
}

export const HTTPHeader: MessageFns<HTTPHeader> = {
  encode(message: HTTPHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTTPHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPHeader {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTTPHeader): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HTTPHeader>): HTTPHeader {
    return HTTPHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HTTPHeader>): HTTPHeader {
    const message = createBaseHTTPHeader();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTCPSocketAction(): TCPSocketAction {
  return { port: 0 };
}

export const TCPSocketAction: MessageFns<TCPSocketAction> = {
  encode(message: TCPSocketAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TCPSocketAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTCPSocketAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TCPSocketAction {
    return { port: isSet(object.port) ? globalThis.Number(object.port) : 0 };
  },

  toJSON(message: TCPSocketAction): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<TCPSocketAction>): TCPSocketAction {
    return TCPSocketAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TCPSocketAction>): TCPSocketAction {
    const message = createBaseTCPSocketAction();
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseGRPCAction(): GRPCAction {
  return { port: 0, service: "" };
}

export const GRPCAction: MessageFns<GRPCAction> = {
  encode(message: GRPCAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GRPCAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGRPCAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GRPCAction {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      service: isSet(object.service) ? globalThis.String(object.service) : "",
    };
  },

  toJSON(message: GRPCAction): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<GRPCAction>): GRPCAction {
    return GRPCAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GRPCAction>): GRPCAction {
    const message = createBaseGRPCAction();
    message.port = object.port ?? 0;
    message.service = object.service ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
