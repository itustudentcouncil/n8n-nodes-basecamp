// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datacatalog/v1/physical_schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.datacatalog.v1";

/**
 * Native schema used by a resource represented as an entry. Used by query
 * engines for deserializing and parsing source data.
 */
export interface PhysicalSchema {
  /** Schema in Avro JSON format. */
  avro?:
    | PhysicalSchema_AvroSchema
    | undefined;
  /** Schema in Thrift format. */
  thrift?:
    | PhysicalSchema_ThriftSchema
    | undefined;
  /** Schema in protocol buffer format. */
  protobuf?:
    | PhysicalSchema_ProtobufSchema
    | undefined;
  /** Marks a Parquet-encoded data source. */
  parquet?:
    | PhysicalSchema_ParquetSchema
    | undefined;
  /** Marks an ORC-encoded data source. */
  orc?:
    | PhysicalSchema_OrcSchema
    | undefined;
  /** Marks a CSV-encoded data source. */
  csv?: PhysicalSchema_CsvSchema | undefined;
}

/** Schema in Avro JSON format. */
export interface PhysicalSchema_AvroSchema {
  /** JSON source of the Avro schema. */
  text: string;
}

/** Schema in Thrift format. */
export interface PhysicalSchema_ThriftSchema {
  /** Thrift IDL source of the schema. */
  text: string;
}

/** Schema in protocol buffer format. */
export interface PhysicalSchema_ProtobufSchema {
  /** Protocol buffer source of the schema. */
  text: string;
}

/** Marks a Parquet-encoded data source. */
export interface PhysicalSchema_ParquetSchema {
}

/** Marks an ORC-encoded data source. */
export interface PhysicalSchema_OrcSchema {
}

/** Marks a CSV-encoded data source. */
export interface PhysicalSchema_CsvSchema {
}

function createBasePhysicalSchema(): PhysicalSchema {
  return {
    avro: undefined,
    thrift: undefined,
    protobuf: undefined,
    parquet: undefined,
    orc: undefined,
    csv: undefined,
  };
}

export const PhysicalSchema: MessageFns<PhysicalSchema> = {
  encode(message: PhysicalSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avro !== undefined) {
      PhysicalSchema_AvroSchema.encode(message.avro, writer.uint32(10).fork()).join();
    }
    if (message.thrift !== undefined) {
      PhysicalSchema_ThriftSchema.encode(message.thrift, writer.uint32(18).fork()).join();
    }
    if (message.protobuf !== undefined) {
      PhysicalSchema_ProtobufSchema.encode(message.protobuf, writer.uint32(26).fork()).join();
    }
    if (message.parquet !== undefined) {
      PhysicalSchema_ParquetSchema.encode(message.parquet, writer.uint32(34).fork()).join();
    }
    if (message.orc !== undefined) {
      PhysicalSchema_OrcSchema.encode(message.orc, writer.uint32(42).fork()).join();
    }
    if (message.csv !== undefined) {
      PhysicalSchema_CsvSchema.encode(message.csv, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.avro = PhysicalSchema_AvroSchema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.thrift = PhysicalSchema_ThriftSchema.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.protobuf = PhysicalSchema_ProtobufSchema.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parquet = PhysicalSchema_ParquetSchema.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orc = PhysicalSchema_OrcSchema.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.csv = PhysicalSchema_CsvSchema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalSchema {
    return {
      avro: isSet(object.avro) ? PhysicalSchema_AvroSchema.fromJSON(object.avro) : undefined,
      thrift: isSet(object.thrift) ? PhysicalSchema_ThriftSchema.fromJSON(object.thrift) : undefined,
      protobuf: isSet(object.protobuf) ? PhysicalSchema_ProtobufSchema.fromJSON(object.protobuf) : undefined,
      parquet: isSet(object.parquet) ? PhysicalSchema_ParquetSchema.fromJSON(object.parquet) : undefined,
      orc: isSet(object.orc) ? PhysicalSchema_OrcSchema.fromJSON(object.orc) : undefined,
      csv: isSet(object.csv) ? PhysicalSchema_CsvSchema.fromJSON(object.csv) : undefined,
    };
  },

  toJSON(message: PhysicalSchema): unknown {
    const obj: any = {};
    if (message.avro !== undefined) {
      obj.avro = PhysicalSchema_AvroSchema.toJSON(message.avro);
    }
    if (message.thrift !== undefined) {
      obj.thrift = PhysicalSchema_ThriftSchema.toJSON(message.thrift);
    }
    if (message.protobuf !== undefined) {
      obj.protobuf = PhysicalSchema_ProtobufSchema.toJSON(message.protobuf);
    }
    if (message.parquet !== undefined) {
      obj.parquet = PhysicalSchema_ParquetSchema.toJSON(message.parquet);
    }
    if (message.orc !== undefined) {
      obj.orc = PhysicalSchema_OrcSchema.toJSON(message.orc);
    }
    if (message.csv !== undefined) {
      obj.csv = PhysicalSchema_CsvSchema.toJSON(message.csv);
    }
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema>): PhysicalSchema {
    return PhysicalSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhysicalSchema>): PhysicalSchema {
    const message = createBasePhysicalSchema();
    message.avro = (object.avro !== undefined && object.avro !== null)
      ? PhysicalSchema_AvroSchema.fromPartial(object.avro)
      : undefined;
    message.thrift = (object.thrift !== undefined && object.thrift !== null)
      ? PhysicalSchema_ThriftSchema.fromPartial(object.thrift)
      : undefined;
    message.protobuf = (object.protobuf !== undefined && object.protobuf !== null)
      ? PhysicalSchema_ProtobufSchema.fromPartial(object.protobuf)
      : undefined;
    message.parquet = (object.parquet !== undefined && object.parquet !== null)
      ? PhysicalSchema_ParquetSchema.fromPartial(object.parquet)
      : undefined;
    message.orc = (object.orc !== undefined && object.orc !== null)
      ? PhysicalSchema_OrcSchema.fromPartial(object.orc)
      : undefined;
    message.csv = (object.csv !== undefined && object.csv !== null)
      ? PhysicalSchema_CsvSchema.fromPartial(object.csv)
      : undefined;
    return message;
  },
};

function createBasePhysicalSchema_AvroSchema(): PhysicalSchema_AvroSchema {
  return { text: "" };
}

export const PhysicalSchema_AvroSchema: MessageFns<PhysicalSchema_AvroSchema> = {
  encode(message: PhysicalSchema_AvroSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_AvroSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_AvroSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalSchema_AvroSchema {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: PhysicalSchema_AvroSchema): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_AvroSchema>): PhysicalSchema_AvroSchema {
    return PhysicalSchema_AvroSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhysicalSchema_AvroSchema>): PhysicalSchema_AvroSchema {
    const message = createBasePhysicalSchema_AvroSchema();
    message.text = object.text ?? "";
    return message;
  },
};

function createBasePhysicalSchema_ThriftSchema(): PhysicalSchema_ThriftSchema {
  return { text: "" };
}

export const PhysicalSchema_ThriftSchema: MessageFns<PhysicalSchema_ThriftSchema> = {
  encode(message: PhysicalSchema_ThriftSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_ThriftSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_ThriftSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalSchema_ThriftSchema {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: PhysicalSchema_ThriftSchema): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_ThriftSchema>): PhysicalSchema_ThriftSchema {
    return PhysicalSchema_ThriftSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhysicalSchema_ThriftSchema>): PhysicalSchema_ThriftSchema {
    const message = createBasePhysicalSchema_ThriftSchema();
    message.text = object.text ?? "";
    return message;
  },
};

function createBasePhysicalSchema_ProtobufSchema(): PhysicalSchema_ProtobufSchema {
  return { text: "" };
}

export const PhysicalSchema_ProtobufSchema: MessageFns<PhysicalSchema_ProtobufSchema> = {
  encode(message: PhysicalSchema_ProtobufSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_ProtobufSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_ProtobufSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalSchema_ProtobufSchema {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: PhysicalSchema_ProtobufSchema): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_ProtobufSchema>): PhysicalSchema_ProtobufSchema {
    return PhysicalSchema_ProtobufSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhysicalSchema_ProtobufSchema>): PhysicalSchema_ProtobufSchema {
    const message = createBasePhysicalSchema_ProtobufSchema();
    message.text = object.text ?? "";
    return message;
  },
};

function createBasePhysicalSchema_ParquetSchema(): PhysicalSchema_ParquetSchema {
  return {};
}

export const PhysicalSchema_ParquetSchema: MessageFns<PhysicalSchema_ParquetSchema> = {
  encode(_: PhysicalSchema_ParquetSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_ParquetSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_ParquetSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PhysicalSchema_ParquetSchema {
    return {};
  },

  toJSON(_: PhysicalSchema_ParquetSchema): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_ParquetSchema>): PhysicalSchema_ParquetSchema {
    return PhysicalSchema_ParquetSchema.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PhysicalSchema_ParquetSchema>): PhysicalSchema_ParquetSchema {
    const message = createBasePhysicalSchema_ParquetSchema();
    return message;
  },
};

function createBasePhysicalSchema_OrcSchema(): PhysicalSchema_OrcSchema {
  return {};
}

export const PhysicalSchema_OrcSchema: MessageFns<PhysicalSchema_OrcSchema> = {
  encode(_: PhysicalSchema_OrcSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_OrcSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_OrcSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PhysicalSchema_OrcSchema {
    return {};
  },

  toJSON(_: PhysicalSchema_OrcSchema): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_OrcSchema>): PhysicalSchema_OrcSchema {
    return PhysicalSchema_OrcSchema.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PhysicalSchema_OrcSchema>): PhysicalSchema_OrcSchema {
    const message = createBasePhysicalSchema_OrcSchema();
    return message;
  },
};

function createBasePhysicalSchema_CsvSchema(): PhysicalSchema_CsvSchema {
  return {};
}

export const PhysicalSchema_CsvSchema: MessageFns<PhysicalSchema_CsvSchema> = {
  encode(_: PhysicalSchema_CsvSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalSchema_CsvSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalSchema_CsvSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PhysicalSchema_CsvSchema {
    return {};
  },

  toJSON(_: PhysicalSchema_CsvSchema): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PhysicalSchema_CsvSchema>): PhysicalSchema_CsvSchema {
    return PhysicalSchema_CsvSchema.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PhysicalSchema_CsvSchema>): PhysicalSchema_CsvSchema {
    const message = createBasePhysicalSchema_CsvSchema();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
