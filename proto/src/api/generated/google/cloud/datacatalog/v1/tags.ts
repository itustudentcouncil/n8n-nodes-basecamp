// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datacatalog/v1/tags.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.datacatalog.v1";

/**
 * Tags contain custom metadata and are attached to Data Catalog resources. Tags
 * conform with the specification of their tag template.
 *
 * See [Data Catalog
 * IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
 * on the permissions needed to create or view tags.
 */
export interface Tag {
  /**
   * The resource name of the tag in URL format where tag ID is a
   * system-generated identifier.
   *
   * Note: The tag itself might not be stored in the location specified in its
   * name.
   */
  name: string;
  /**
   * Required. The resource name of the tag template this tag uses. Example:
   *
   * `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE_ID}`
   *
   * This field cannot be modified after creation.
   */
  template: string;
  /** Output only. The display name of the tag template. */
  templateDisplayName: string;
  /**
   * Resources like entry can have schemas associated with them. This scope
   * allows you to attach tags to an individual column based on that schema.
   *
   * To attach a tag to a nested column, separate column names with a dot
   * (`.`). Example: `column.nested_column`.
   */
  column?:
    | string
    | undefined;
  /**
   * Required. Maps the ID of a tag field to its value and additional
   * information about that field.
   *
   * Tag template defines valid field IDs. A tag
   * must have at least 1 field and at most 500 fields.
   */
  fields: { [key: string]: TagField };
}

export interface Tag_FieldsEntry {
  key: string;
  value: TagField | undefined;
}

/**
 * Contains the value and additional information on a field within
 * a [Tag][google.cloud.datacatalog.v1.Tag].
 */
export interface TagField {
  /** Output only. The display name of this field. */
  displayName: string;
  /** The value of a tag field with a double type. */
  doubleValue?:
    | number
    | undefined;
  /**
   * The value of a tag field with a string type.
   *
   * The maximum length is 2000 UTF-8 characters.
   */
  stringValue?:
    | string
    | undefined;
  /** The value of a tag field with a boolean type. */
  boolValue?:
    | boolean
    | undefined;
  /** The value of a tag field with a timestamp type. */
  timestampValue?:
    | Date
    | undefined;
  /**
   * The value of a tag field with an enum type.
   *
   * This value must be one of the allowed values listed in this enum.
   */
  enumValue?:
    | TagField_EnumValue
    | undefined;
  /**
   * The value of a tag field with a rich text type.
   *
   * The maximum length is 10 MiB as this value holds HTML descriptions
   * including encoded images. The maximum length of the text without images
   * is 100 KiB.
   */
  richtextValue?:
    | string
    | undefined;
  /**
   * Output only. The order of this field with respect to other fields in this
   * tag. Can be set by
   * [Tag][google.cloud.datacatalog.v1.TagTemplateField.order].
   *
   * For example, a higher value can indicate a more important field.
   * The value can be negative. Multiple fields can have the same order, and
   * field orders within a tag don't have to be sequential.
   */
  order: number;
}

/** An enum value. */
export interface TagField_EnumValue {
  /** The display name of the enum value. */
  displayName: string;
}

/**
 * A tag template defines a tag that can have one or more typed fields.
 *
 * The template is used to create tags that are attached to Google Cloud
 *  resources. [Tag template roles]
 * (https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles)
 * provide permissions to create, edit, and use the template. For example,
 * see the [TagTemplate User]
 * (https://cloud.google.com/data-catalog/docs/how-to/template-user) role
 * that includes a permission to use the tag template to tag resources.
 */
export interface TagTemplate {
  /**
   * The resource name of the tag template in URL format.
   *
   * Note: The tag template itself and its child resources might not be
   * stored in the location specified in its name.
   */
  name: string;
  /**
   * Display name for this template. Defaults to an empty string.
   *
   * The name must contain only Unicode letters, numbers (0-9), underscores (_),
   * dashes (-), spaces ( ), and can't start or end with spaces.
   * The maximum length is 200 characters.
   */
  displayName: string;
  /**
   * Indicates whether tags created with this template are public. Public tags
   * do not require tag template access to appear in
   * [ListTags][google.cloud.datacatalog.v1.ListTags] API response.
   *
   * Additionally, you can search for a public tag by value with a
   * simple search query in addition to using a ``tag:`` predicate.
   */
  isPubliclyReadable: boolean;
  /**
   * Required. Map of tag template field IDs to the settings for the field.
   * This map is an exhaustive list of the allowed fields. The map must contain
   * at least one field and at most 500 fields.
   *
   * The keys to this map are tag template field IDs. The IDs have the
   * following limitations:
   *
   * * Can contain uppercase and lowercase letters, numbers (0-9) and
   *   underscores (_).
   * * Must be at least 1 character and at most 64 characters long.
   * * Must start with a letter or underscore.
   */
  fields: { [key: string]: TagTemplateField };
}

export interface TagTemplate_FieldsEntry {
  key: string;
  value: TagTemplateField | undefined;
}

/** The template for an individual field within a tag template. */
export interface TagTemplateField {
  /**
   * Output only. The resource name of the tag template field in URL format.
   * Example:
   *
   * `projects/{PROJECT_ID}/locations/{LOCATION}/tagTemplates/{TAG_TEMPLATE}/fields/{FIELD}`
   *
   * Note: The tag template field itself might not be stored in the location
   * specified in its name.
   *
   * The name must contain only letters (a-z, A-Z), numbers (0-9),
   * or underscores (_), and must start with a letter or underscore.
   * The maximum length is 64 characters.
   */
  name: string;
  /**
   * The display name for this field. Defaults to an empty string.
   *
   * The name must contain only Unicode letters, numbers (0-9), underscores (_),
   * dashes (-), spaces ( ), and can't start or end with spaces.
   * The maximum length is 200 characters.
   */
  displayName: string;
  /** Required. The type of value this tag field can contain. */
  type:
    | FieldType
    | undefined;
  /** If true, this field is required. Defaults to false. */
  isRequired: boolean;
  /** The description for this field. Defaults to an empty string. */
  description: string;
  /**
   * The order of this field with respect to other fields in this tag
   * template.
   *
   * For example, a higher value can indicate a more important field.
   * The value can be negative. Multiple fields can have the same order and
   * field orders within a tag don't have to be sequential.
   */
  order: number;
}

export interface FieldType {
  /** Primitive types, such as string, boolean, etc. */
  primitiveType?:
    | FieldType_PrimitiveType
    | undefined;
  /** An enum type. */
  enumType?: FieldType_EnumType | undefined;
}

export enum FieldType_PrimitiveType {
  /** PRIMITIVE_TYPE_UNSPECIFIED - The default invalid value for a type. */
  PRIMITIVE_TYPE_UNSPECIFIED = 0,
  /** DOUBLE - A double precision number. */
  DOUBLE = 1,
  /** STRING - An UTF-8 string. */
  STRING = 2,
  /** BOOL - A boolean value. */
  BOOL = 3,
  /** TIMESTAMP - A timestamp. */
  TIMESTAMP = 4,
  /** RICHTEXT - A Richtext description. */
  RICHTEXT = 5,
  UNRECOGNIZED = -1,
}

export function fieldType_PrimitiveTypeFromJSON(object: any): FieldType_PrimitiveType {
  switch (object) {
    case 0:
    case "PRIMITIVE_TYPE_UNSPECIFIED":
      return FieldType_PrimitiveType.PRIMITIVE_TYPE_UNSPECIFIED;
    case 1:
    case "DOUBLE":
      return FieldType_PrimitiveType.DOUBLE;
    case 2:
    case "STRING":
      return FieldType_PrimitiveType.STRING;
    case 3:
    case "BOOL":
      return FieldType_PrimitiveType.BOOL;
    case 4:
    case "TIMESTAMP":
      return FieldType_PrimitiveType.TIMESTAMP;
    case 5:
    case "RICHTEXT":
      return FieldType_PrimitiveType.RICHTEXT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldType_PrimitiveType.UNRECOGNIZED;
  }
}

export function fieldType_PrimitiveTypeToJSON(object: FieldType_PrimitiveType): string {
  switch (object) {
    case FieldType_PrimitiveType.PRIMITIVE_TYPE_UNSPECIFIED:
      return "PRIMITIVE_TYPE_UNSPECIFIED";
    case FieldType_PrimitiveType.DOUBLE:
      return "DOUBLE";
    case FieldType_PrimitiveType.STRING:
      return "STRING";
    case FieldType_PrimitiveType.BOOL:
      return "BOOL";
    case FieldType_PrimitiveType.TIMESTAMP:
      return "TIMESTAMP";
    case FieldType_PrimitiveType.RICHTEXT:
      return "RICHTEXT";
    case FieldType_PrimitiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FieldType_EnumType {
  /**
   * The set of allowed values for this enum.
   *
   * This set must not be empty and can include up to 100 allowed values.
   * The display names of the values in this set must not be empty and must
   * be case-insensitively unique within this set.
   *
   * The order of items in this set is preserved. This field can be used to
   * create, remove, and reorder enum values. To rename enum values, use the
   * `RenameTagTemplateFieldEnumValue` method.
   */
  allowedValues: FieldType_EnumType_EnumValue[];
}

export interface FieldType_EnumType_EnumValue {
  /**
   * Required. The display name of the enum value. Must not be an empty
   * string.
   *
   * The name must contain only Unicode letters, numbers (0-9), underscores
   * (_), dashes (-), spaces ( ), and can't start or end with spaces. The
   * maximum length is 200 characters.
   */
  displayName: string;
}

function createBaseTag(): Tag {
  return { name: "", template: "", templateDisplayName: "", column: undefined, fields: {} };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.template !== "") {
      writer.uint32(18).string(message.template);
    }
    if (message.templateDisplayName !== "") {
      writer.uint32(42).string(message.templateDisplayName);
    }
    if (message.column !== undefined) {
      writer.uint32(34).string(message.column);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      Tag_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.template = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.templateDisplayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.column = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Tag_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      templateDisplayName: isSet(object.templateDisplayName) ? globalThis.String(object.templateDisplayName) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : undefined,
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: TagField }>((acc, [key, value]) => {
          acc[key] = TagField.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.template !== "") {
      obj.template = message.template;
    }
    if (message.templateDisplayName !== "") {
      obj.templateDisplayName = message.templateDisplayName;
    }
    if (message.column !== undefined) {
      obj.column = message.column;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = TagField.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Tag>): Tag {
    return Tag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag>): Tag {
    const message = createBaseTag();
    message.name = object.name ?? "";
    message.template = object.template ?? "";
    message.templateDisplayName = object.templateDisplayName ?? "";
    message.column = object.column ?? undefined;
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: TagField }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TagField.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTag_FieldsEntry(): Tag_FieldsEntry {
  return { key: "", value: undefined };
}

export const Tag_FieldsEntry: MessageFns<Tag_FieldsEntry> = {
  encode(message: Tag_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TagField.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TagField.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TagField.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Tag_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TagField.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Tag_FieldsEntry>): Tag_FieldsEntry {
    return Tag_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag_FieldsEntry>): Tag_FieldsEntry {
    const message = createBaseTag_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TagField.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTagField(): TagField {
  return {
    displayName: "",
    doubleValue: undefined,
    stringValue: undefined,
    boolValue: undefined,
    timestampValue: undefined,
    enumValue: undefined,
    richtextValue: undefined,
    order: 0,
  };
}

export const TagField: MessageFns<TagField> = {
  encode(message: TagField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.timestampValue !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(42).fork()).join();
    }
    if (message.enumValue !== undefined) {
      TagField_EnumValue.encode(message.enumValue, writer.uint32(50).fork()).join();
    }
    if (message.richtextValue !== undefined) {
      writer.uint32(66).string(message.richtextValue);
    }
    if (message.order !== 0) {
      writer.uint32(56).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.enumValue = TagField_EnumValue.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.richtextValue = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagField {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined,
      enumValue: isSet(object.enumValue) ? TagField_EnumValue.fromJSON(object.enumValue) : undefined,
      richtextValue: isSet(object.richtextValue) ? globalThis.String(object.richtextValue) : undefined,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: TagField): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = message.timestampValue.toISOString();
    }
    if (message.enumValue !== undefined) {
      obj.enumValue = TagField_EnumValue.toJSON(message.enumValue);
    }
    if (message.richtextValue !== undefined) {
      obj.richtextValue = message.richtextValue;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<TagField>): TagField {
    return TagField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagField>): TagField {
    const message = createBaseTagField();
    message.displayName = object.displayName ?? "";
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.timestampValue = object.timestampValue ?? undefined;
    message.enumValue = (object.enumValue !== undefined && object.enumValue !== null)
      ? TagField_EnumValue.fromPartial(object.enumValue)
      : undefined;
    message.richtextValue = object.richtextValue ?? undefined;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseTagField_EnumValue(): TagField_EnumValue {
  return { displayName: "" };
}

export const TagField_EnumValue: MessageFns<TagField_EnumValue> = {
  encode(message: TagField_EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagField_EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagField_EnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagField_EnumValue {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: TagField_EnumValue): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<TagField_EnumValue>): TagField_EnumValue {
    return TagField_EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagField_EnumValue>): TagField_EnumValue {
    const message = createBaseTagField_EnumValue();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseTagTemplate(): TagTemplate {
  return { name: "", displayName: "", isPubliclyReadable: false, fields: {} };
}

export const TagTemplate: MessageFns<TagTemplate> = {
  encode(message: TagTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.isPubliclyReadable !== false) {
      writer.uint32(40).bool(message.isPubliclyReadable);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      TagTemplate_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isPubliclyReadable = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TagTemplate_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      isPubliclyReadable: isSet(object.isPubliclyReadable) ? globalThis.Boolean(object.isPubliclyReadable) : false,
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: TagTemplateField }>((acc, [key, value]) => {
          acc[key] = TagTemplateField.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TagTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.isPubliclyReadable !== false) {
      obj.isPubliclyReadable = message.isPubliclyReadable;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = TagTemplateField.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplate>): TagTemplate {
    return TagTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplate>): TagTemplate {
    const message = createBaseTagTemplate();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.isPubliclyReadable = object.isPubliclyReadable ?? false;
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: TagTemplateField }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TagTemplateField.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTagTemplate_FieldsEntry(): TagTemplate_FieldsEntry {
  return { key: "", value: undefined };
}

export const TagTemplate_FieldsEntry: MessageFns<TagTemplate_FieldsEntry> = {
  encode(message: TagTemplate_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TagTemplateField.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplate_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplate_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TagTemplateField.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplate_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TagTemplateField.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TagTemplate_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TagTemplateField.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplate_FieldsEntry>): TagTemplate_FieldsEntry {
    return TagTemplate_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplate_FieldsEntry>): TagTemplate_FieldsEntry {
    const message = createBaseTagTemplate_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TagTemplateField.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTagTemplateField(): TagTemplateField {
  return { name: "", displayName: "", type: undefined, isRequired: false, description: "", order: 0 };
}

export const TagTemplateField: MessageFns<TagTemplateField> = {
  encode(message: TagTemplateField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.type !== undefined) {
      FieldType.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.isRequired !== false) {
      writer.uint32(24).bool(message.isRequired);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplateField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplateField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = FieldType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplateField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      type: isSet(object.type) ? FieldType.fromJSON(object.type) : undefined,
      isRequired: isSet(object.isRequired) ? globalThis.Boolean(object.isRequired) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: TagTemplateField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.type !== undefined) {
      obj.type = FieldType.toJSON(message.type);
    }
    if (message.isRequired !== false) {
      obj.isRequired = message.isRequired;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplateField>): TagTemplateField {
    return TagTemplateField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplateField>): TagTemplateField {
    const message = createBaseTagTemplateField();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.type = (object.type !== undefined && object.type !== null) ? FieldType.fromPartial(object.type) : undefined;
    message.isRequired = object.isRequired ?? false;
    message.description = object.description ?? "";
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseFieldType(): FieldType {
  return { primitiveType: undefined, enumType: undefined };
}

export const FieldType: MessageFns<FieldType> = {
  encode(message: FieldType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primitiveType !== undefined) {
      writer.uint32(8).int32(message.primitiveType);
    }
    if (message.enumType !== undefined) {
      FieldType_EnumType.encode(message.enumType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.primitiveType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.enumType = FieldType_EnumType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType {
    return {
      primitiveType: isSet(object.primitiveType) ? fieldType_PrimitiveTypeFromJSON(object.primitiveType) : undefined,
      enumType: isSet(object.enumType) ? FieldType_EnumType.fromJSON(object.enumType) : undefined,
    };
  },

  toJSON(message: FieldType): unknown {
    const obj: any = {};
    if (message.primitiveType !== undefined) {
      obj.primitiveType = fieldType_PrimitiveTypeToJSON(message.primitiveType);
    }
    if (message.enumType !== undefined) {
      obj.enumType = FieldType_EnumType.toJSON(message.enumType);
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType>): FieldType {
    return FieldType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType>): FieldType {
    const message = createBaseFieldType();
    message.primitiveType = object.primitiveType ?? undefined;
    message.enumType = (object.enumType !== undefined && object.enumType !== null)
      ? FieldType_EnumType.fromPartial(object.enumType)
      : undefined;
    return message;
  },
};

function createBaseFieldType_EnumType(): FieldType_EnumType {
  return { allowedValues: [] };
}

export const FieldType_EnumType: MessageFns<FieldType_EnumType> = {
  encode(message: FieldType_EnumType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedValues) {
      FieldType_EnumType_EnumValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType_EnumType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_EnumType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedValues.push(FieldType_EnumType_EnumValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_EnumType {
    return {
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => FieldType_EnumType_EnumValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FieldType_EnumType): unknown {
    const obj: any = {};
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues.map((e) => FieldType_EnumType_EnumValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType_EnumType>): FieldType_EnumType {
    return FieldType_EnumType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType_EnumType>): FieldType_EnumType {
    const message = createBaseFieldType_EnumType();
    message.allowedValues = object.allowedValues?.map((e) => FieldType_EnumType_EnumValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldType_EnumType_EnumValue(): FieldType_EnumType_EnumValue {
  return { displayName: "" };
}

export const FieldType_EnumType_EnumValue: MessageFns<FieldType_EnumType_EnumValue> = {
  encode(message: FieldType_EnumType_EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType_EnumType_EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_EnumType_EnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_EnumType_EnumValue {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: FieldType_EnumType_EnumValue): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType_EnumType_EnumValue>): FieldType_EnumType_EnumValue {
    return FieldType_EnumType_EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType_EnumType_EnumValue>): FieldType_EnumType_EnumValue {
    const message = createBaseFieldType_EnumType_EnumValue();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
