// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securesourcemanager/v1/secure_source_manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.securesourcemanager.v1";

/** A resource that represents a Secure Source Manager instance. */
export interface Instance {
  /**
   * Optional. A unique identifier for an instance. The name should be of the
   * format:
   * `projects/{project_number}/locations/{location_id}/instances/{instance_id}`
   *
   * `project_number`: Maps to a unique int64 id assigned to each project.
   *
   * `location_id`: Refers to the region where the instance will be deployed.
   * Since Secure Source Manager is a regional service, it must be one of the
   * valid GCP regions.
   *
   * `instance_id`: User provided name for the instance, must be unique for a
   * project_number and location_id combination.
   */
  name: string;
  /** Output only. Create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Optional. Private settings for private instance. */
  privateConfig:
    | Instance_PrivateConfig
    | undefined;
  /** Output only. Current state of the instance. */
  state: Instance_State;
  /**
   * Output only. An optional field providing information about the current
   * instance state.
   */
  stateNote: Instance_StateNote;
  /**
   * Optional. Immutable. Customer-managed encryption key name, in the format
   * projects/* /locations/* /keyRings/* /cryptoKeys/*.
   */
  kmsKey: string;
  /** Output only. A list of hostnames for this instance. */
  hostConfig: Instance_HostConfig | undefined;
}

/** Secure Source Manager instance state. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - Not set. This should only be the case for incoming requests. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Instance is being created. */
  CREATING = 1,
  /** ACTIVE - Instance is ready. */
  ACTIVE = 2,
  /** DELETING - Instance is being deleted. */
  DELETING = 3,
  /** PAUSED - Instance is paused. */
  PAUSED = 4,
  /** UNKNOWN - Instance is unknown, we are not sure if it's functioning. */
  UNKNOWN = 6,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Instance_State.CREATING;
    case 2:
    case "ACTIVE":
      return Instance_State.ACTIVE;
    case 3:
    case "DELETING":
      return Instance_State.DELETING;
    case 4:
    case "PAUSED":
      return Instance_State.PAUSED;
    case 6:
    case "UNKNOWN":
      return Instance_State.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.ACTIVE:
      return "ACTIVE";
    case Instance_State.DELETING:
      return "DELETING";
    case Instance_State.PAUSED:
      return "PAUSED";
    case Instance_State.UNKNOWN:
      return "UNKNOWN";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Provides information about the current instance state. */
export enum Instance_StateNote {
  /** STATE_NOTE_UNSPECIFIED - STATE_NOTE_UNSPECIFIED as the first value of State. */
  STATE_NOTE_UNSPECIFIED = 0,
  /** PAUSED_CMEK_UNAVAILABLE - CMEK access is unavailable. */
  PAUSED_CMEK_UNAVAILABLE = 1,
  /**
   * INSTANCE_RESUMING - INSTANCE_RESUMING indicates that the instance was previously paused
   * and is under the process of being brought back.
   *
   * @deprecated
   */
  INSTANCE_RESUMING = 2,
  UNRECOGNIZED = -1,
}

export function instance_StateNoteFromJSON(object: any): Instance_StateNote {
  switch (object) {
    case 0:
    case "STATE_NOTE_UNSPECIFIED":
      return Instance_StateNote.STATE_NOTE_UNSPECIFIED;
    case 1:
    case "PAUSED_CMEK_UNAVAILABLE":
      return Instance_StateNote.PAUSED_CMEK_UNAVAILABLE;
    case 2:
    case "INSTANCE_RESUMING":
      return Instance_StateNote.INSTANCE_RESUMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_StateNote.UNRECOGNIZED;
  }
}

export function instance_StateNoteToJSON(object: Instance_StateNote): string {
  switch (object) {
    case Instance_StateNote.STATE_NOTE_UNSPECIFIED:
      return "STATE_NOTE_UNSPECIFIED";
    case Instance_StateNote.PAUSED_CMEK_UNAVAILABLE:
      return "PAUSED_CMEK_UNAVAILABLE";
    case Instance_StateNote.INSTANCE_RESUMING:
      return "INSTANCE_RESUMING";
    case Instance_StateNote.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HostConfig has different instance endpoints. */
export interface Instance_HostConfig {
  /** Output only. HTML hostname. */
  html: string;
  /**
   * Output only. API hostname. This is the hostname to use for **Host: Data
   * Plane** endpoints.
   */
  api: string;
  /** Output only. Git HTTP hostname. */
  gitHttp: string;
  /** Output only. Git SSH hostname. */
  gitSsh: string;
}

/** PrivateConfig includes settings for private instance. */
export interface Instance_PrivateConfig {
  /** Required. Immutable. Indicate if it's private instance. */
  isPrivate: boolean;
  /**
   * Required. Immutable. CA pool resource, resource must in the format of
   * `projects/{project}/locations/{location}/caPools/{ca_pool}`.
   */
  caPool: string;
  /**
   * Output only. Service Attachment for HTTP, resource is in the format of
   * `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
   */
  httpServiceAttachment: string;
  /**
   * Output only. Service Attachment for SSH, resource is in the format of
   * `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
   */
  sshServiceAttachment: string;
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

/** Metadata of a Secure Source Manager repository. */
export interface Repository {
  /**
   * Optional. A unique identifier for a repository. The name should be of the
   * format:
   * `projects/{project}/locations/{location_id}/repositories/{repository_id}`
   */
  name: string;
  /**
   * Optional. Description of the repository, which cannot exceed 500
   * characters.
   */
  description: string;
  /**
   * Optional. The name of the instance in which the repository is hosted,
   * formatted as
   * `projects/{project_number}/locations/{location_id}/instances/{instance_id}`
   * For data plane CreateRepository requests, this field is output only.
   * For control plane CreateRepository requests, this field is used as input.
   */
  instance: string;
  /** Output only. Unique identifier of the repository. */
  uid: string;
  /** Output only. Create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /** Output only. URIs for the repository. */
  uris:
    | Repository_URIs
    | undefined;
  /** Input only. Initial configurations for the repository. */
  initialConfig: Repository_InitialConfig | undefined;
}

/** URIs for the repository. */
export interface Repository_URIs {
  /**
   * Output only. HTML is the URI for user to view the repository in a
   * browser.
   */
  html: string;
  /** Output only. git_https is the git HTTPS URI for git operations. */
  gitHttps: string;
  /** Output only. API is the URI for API access. */
  api: string;
}

/** Repository initialization configuration. */
export interface Repository_InitialConfig {
  /** Default branch name of the repository. */
  defaultBranch: string;
  /**
   * List of gitignore template names user can choose from.
   * Valid values: actionscript, ada, agda, android,
   * anjuta, ansible, appcelerator-titanium, app-engine, archives,
   * arch-linux-packages, atmel-studio, autotools, backup, bazaar, bazel,
   * bitrix, bricx-cc, c, cake-php, calabash, cf-wheels, chef-cookbook,
   * clojure, cloud9, c-make, code-igniter, code-kit, code-sniffer,
   * common-lisp, composer, concrete5, coq, cordova, cpp, craft-cms, cuda,
   * cvs, d, dart, dart-editor, delphi, diff, dm, dreamweaver, dropbox,
   * drupal, drupal-7, eagle, eclipse, eiffel-studio, elisp, elixir, elm,
   * emacs, ensime, epi-server, erlang, esp-idf, espresso, exercism,
   * expression-engine, ext-js, fancy, finale, flex-builder, force-dot-com,
   * fortran, fuel-php, gcov, git-book, gnome-shell-extension, go, godot, gpg,
   * gradle, grails, gwt, haskell, hugo, iar-ewarm, idris, igor-pro, images,
   * infor-cms, java, jboss, jboss-4, jboss-6, jdeveloper, jekyll,
   * jenkins-home, jenv, jet-brains, jigsaw, joomla, julia, jupyter-notebooks,
   * kate, kdevelop4, kentico, ki-cad, kohana, kotlin, lab-view, laravel,
   * lazarus, leiningen, lemon-stand, libre-office, lilypond, linux, lithium,
   * logtalk, lua, lyx, mac-os, magento, magento-1, magento-2, matlab, maven,
   * mercurial, mercury, metals, meta-programming-system, meteor,
   * microsoft-office, model-sim, momentics, mono-develop, nanoc, net-beans,
   * nikola, nim, ninja, node, notepad-pp, nwjs, objective--c, ocaml, octave,
   * opa, open-cart, openssl, oracle-forms, otto, packer, patch, perl, perl6,
   * phalcon, phoenix, pimcore, play-framework, plone, prestashop, processing,
   * psoc-creator, puppet, pure-script, putty, python, qooxdoo, qt, r, racket,
   * rails, raku, red, redcar, redis, rhodes-rhomobile, ros, ruby, rust, sam,
   * sass, sbt, scala, scheme, scons, scrivener, sdcc, seam-gen, sketch-up,
   * slick-edit, smalltalk, snap, splunk, stata, stella, sublime-text,
   * sugar-crm, svn, swift, symfony, symphony-cms, synopsys-vcs, tags,
   * terraform, tex, text-mate, textpattern, think-php, tortoise-git,
   * turbo-gears-2, typo3, umbraco, unity, unreal-engine, vagrant, vim,
   * virtual-env, virtuoso, visual-studio, visual-studio-code, vue, vvvv, waf,
   * web-methods, windows, word-press, xcode, xilinx, xilinx-ise, xojo,
   * yeoman, yii, zend-framework, zephir.
   */
  gitignores: string[];
  /**
   * License template name user can choose from.
   * Valid values: license-0bsd, license-389-exception, aal, abstyles,
   * adobe-2006, adobe-glyph, adsl, afl-1-1, afl-1-2, afl-2-0, afl-2-1,
   * afl-3-0, afmparse, agpl-1-0, agpl-1-0-only, agpl-1-0-or-later,
   * agpl-3-0-only, agpl-3-0-or-later, aladdin, amdplpa, aml, ampas, antlr-pd,
   * antlr-pd-fallback, apache-1-0, apache-1-1, apache-2-0, apafml, apl-1-0,
   * apsl-1-0, apsl-1-1, apsl-1-2, apsl-2-0, artistic-1-0, artistic-1-0-cl8,
   * artistic-1-0-perl, artistic-2-0, autoconf-exception-2-0,
   * autoconf-exception-3-0, bahyph, barr, beerware, bison-exception-2-2,
   * bittorrent-1-0, bittorrent-1-1, blessing, blueoak-1-0-0,
   * bootloader-exception, borceux, bsd-1-clause, bsd-2-clause,
   * bsd-2-clause-freebsd, bsd-2-clause-netbsd, bsd-2-clause-patent,
   * bsd-2-clause-views, bsd-3-clause, bsd-3-clause-attribution,
   * bsd-3-clause-clear, bsd-3-clause-lbnl, bsd-3-clause-modification,
   * bsd-3-clause-no-nuclear-license, bsd-3-clause-no-nuclear-license-2014,
   * bsd-3-clause-no-nuclear-warranty, bsd-3-clause-open-mpi, bsd-4-clause,
   * bsd-4-clause-shortened, bsd-4-clause-uc, bsd-protection, bsd-source-code,
   * bsl-1-0, busl-1-1, cal-1-0, cal-1-0-combined-work-exception, caldera,
   * catosl-1-1, cc0-1-0, cc-by-1-0, cc-by-2-0, cc-by-3-0, cc-by-3-0-at,
   * cc-by-3-0-us, cc-by-4-0, cc-by-nc-1-0, cc-by-nc-2-0, cc-by-nc-3-0,
   * cc-by-nc-4-0, cc-by-nc-nd-1-0, cc-by-nc-nd-2-0, cc-by-nc-nd-3-0,
   * cc-by-nc-nd-3-0-igo, cc-by-nc-nd-4-0, cc-by-nc-sa-1-0, cc-by-nc-sa-2-0,
   * cc-by-nc-sa-3-0, cc-by-nc-sa-4-0, cc-by-nd-1-0, cc-by-nd-2-0,
   * cc-by-nd-3-0, cc-by-nd-4-0, cc-by-sa-1-0, cc-by-sa-2-0, cc-by-sa-2-0-uk,
   * cc-by-sa-2-1-jp, cc-by-sa-3-0, cc-by-sa-3-0-at, cc-by-sa-4-0, cc-pddc,
   * cddl-1-0, cddl-1-1, cdla-permissive-1-0, cdla-sharing-1-0, cecill-1-0,
   * cecill-1-1, cecill-2-0, cecill-2-1, cecill-b, cecill-c, cern-ohl-1-1,
   * cern-ohl-1-2, cern-ohl-p-2-0, cern-ohl-s-2-0, cern-ohl-w-2-0, clartistic,
   * classpath-exception-2-0, clisp-exception-2-0, cnri-jython, cnri-python,
   * cnri-python-gpl-compatible, condor-1-1, copyleft-next-0-3-0,
   * copyleft-next-0-3-1, cpal-1-0, cpl-1-0, cpol-1-02, crossword,
   * crystal-stacker, cua-opl-1-0, cube, c-uda-1-0, curl, d-fsl-1-0, diffmark,
   * digirule-foss-exception, doc, dotseqn, drl-1-0, dsdp, dvipdfm, ecl-1-0,
   * ecl-2-0, ecos-exception-2-0, efl-1-0, efl-2-0, egenix, entessa, epics,
   * epl-1-0, epl-2-0, erlpl-1-1, etalab-2-0, eu-datagrid, eupl-1-0, eupl-1-1,
   * eupl-1-2, eurosym, fair, fawkes-runtime-exception, fltk-exception,
   * font-exception-2-0, frameworx-1-0, freebsd-doc, freeimage,
   * freertos-exception-2-0, fsfap, fsful, fsfullr, ftl, gcc-exception-2-0,
   * gcc-exception-3-1, gd, gfdl-1-1-invariants-only,
   * gfdl-1-1-invariants-or-later, gfdl-1-1-no-invariants-only,
   * gfdl-1-1-no-invariants-or-later, gfdl-1-1-only, gfdl-1-1-or-later,
   * gfdl-1-2-invariants-only, gfdl-1-2-invariants-or-later,
   * gfdl-1-2-no-invariants-only, gfdl-1-2-no-invariants-or-later,
   * gfdl-1-2-only, gfdl-1-2-or-later, gfdl-1-3-invariants-only,
   * gfdl-1-3-invariants-or-later, gfdl-1-3-no-invariants-only,
   * gfdl-1-3-no-invariants-or-later, gfdl-1-3-only, gfdl-1-3-or-later,
   * giftware, gl2ps, glide, glulxe, glwtpl, gnu-javamail-exception, gnuplot,
   * gpl-1-0-only, gpl-1-0-or-later, gpl-2-0-only, gpl-2-0-or-later,
   * gpl-3-0-linking-exception, gpl-3-0-linking-source-exception,
   * gpl-3-0-only, gpl-3-0-or-later, gpl-cc-1-0, gsoap-1-3b, haskell-report,
   * hippocratic-2-1, hpnd, hpnd-sell-variant, htmltidy,
   * i2p-gpl-java-exception, ibm-pibs, icu, ijg, image-magick, imatix, imlib2,
   * info-zip, intel, intel-acpi, interbase-1-0, ipa, ipl-1-0, isc,
   * jasper-2-0, jpnic, json, lal-1-2, lal-1-3, latex2e, leptonica,
   * lgpl-2-0-only, lgpl-2-0-or-later, lgpl-2-1-only, lgpl-2-1-or-later,
   * lgpl-3-0-linking-exception, lgpl-3-0-only, lgpl-3-0-or-later, lgpllr,
   * libpng, libpng-2-0, libselinux-1-0, libtiff, libtool-exception,
   * liliq-p-1-1, liliq-r-1-1, liliq-rplus-1-1, linux-openib,
   * linux-syscall-note, llvm-exception, lpl-1-0, lpl-1-02, lppl-1-0,
   * lppl-1-1, lppl-1-2, lppl-1-3a, lppl-1-3c, lzma-exception, make-index,
   * mif-exception, miros, mit, mit-0, mit-advertising, mit-cmu, mit-enna,
   * mit-feh, mit-modern-variant, mitnfa, mit-open-group, motosoto, mpich2,
   * mpl-1-0, mpl-1-1, mpl-2-0, mpl-2-0-no-copyleft-exception, ms-pl, ms-rl,
   * mtll, mulanpsl-1-0, mulanpsl-2-0, multics, mup, naist-2003, nasa-1-3,
   * naumen, nbpl-1-0, ncgl-uk-2-0, ncsa, netcdf, net-snmp, newsletr, ngpl,
   * nist-pd, nist-pd-fallback, nlod-1-0, nlpl, nokia, nokia-qt-exception-1-1,
   * nosl, noweb, npl-1-0, npl-1-1, nposl-3-0, nrl, ntp, ntp-0,
   * ocaml-lgpl-linking-exception, occt-exception-1-0, occt-pl, oclc-2-0,
   * odbl-1-0, odc-by-1-0, ofl-1-0, ofl-1-0-no-rfn, ofl-1-0-rfn, ofl-1-1,
   * ofl-1-1-no-rfn, ofl-1-1-rfn, ogc-1-0, ogdl-taiwan-1-0, ogl-canada-2-0,
   * ogl-uk-1-0, ogl-uk-2-0, ogl-uk-3-0, ogtsl, oldap-1-1, oldap-1-2,
   * oldap-1-3, oldap-1-4, oldap-2-0, oldap-2-0-1, oldap-2-1, oldap-2-2,
   * oldap-2-2-1, oldap-2-2-2, oldap-2-3, oldap-2-4, oldap-2-7, oml,
   * openjdk-assembly-exception-1-0, openssl, openvpn-openssl-exception,
   * opl-1-0, oset-pl-2-1, osl-1-0, osl-1-1, osl-2-0, osl-2-1, osl-3-0,
   * o-uda-1-0, parity-6-0-0, parity-7-0-0, pddl-1-0, php-3-0, php-3-01,
   * plexus, polyform-noncommercial-1-0-0, polyform-small-business-1-0-0,
   * postgresql, psf-2-0, psfrag, ps-or-pdf-font-exception-20170817, psutils,
   * python-2-0, qhull, qpl-1-0, qt-gpl-exception-1-0, qt-lgpl-exception-1-1,
   * qwt-exception-1-0, rdisc, rhecos-1-1, rpl-1-1, rpsl-1-0, rsa-md, rscpl,
   * ruby, saxpath, sax-pd, scea, sendmail, sendmail-8-23, sgi-b-1-0,
   * sgi-b-1-1, sgi-b-2-0, shl-0-51, shl-2-0, shl-2-1, simpl-2-0, sissl,
   * sissl-1-2, sleepycat, smlnj, smppl, snia, spencer-86, spencer-94,
   * spencer-99, spl-1-0, ssh-openssh, ssh-short, sspl-1-0, sugarcrm-1-1-3,
   * swift-exception, swl, tapr-ohl-1-0, tcl, tcp-wrappers, tmate, torque-1-1,
   * tosl, tu-berlin-1-0, tu-berlin-2-0, u-boot-exception-2-0, ucl-1-0,
   * unicode-dfs-2015, unicode-dfs-2016, unicode-tou,
   * universal-foss-exception-1-0, unlicense, upl-1-0, vim, vostrom, vsl-1-0,
   * w3c, w3c-19980720, w3c-20150513, watcom-1-0, wsuipa, wtfpl,
   * wxwindows-exception-3-1, x11, xerox, xfree86-1-1, xinetd, xnet, xpp,
   * xskat, ypl-1-0, ypl-1-1, zed, zend-2-0, zimbra-1-3, zimbra-1-4, zlib,
   * zlib-acknowledgement, zpl-1-1, zpl-2-0, zpl-2-1.
   */
  license: string;
  /**
   * README template name.
   * Valid template name(s) are: default.
   */
  readme: string;
}

/** ListInstancesRequest is the request to list instances. */
export interface ListInstancesRequest {
  /** Required. Parent value for ListInstancesRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filter for filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

export interface ListInstancesResponse {
  /** The list of instances. */
  instances: Instance[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** GetInstanceRequest is the request for getting an instance. */
export interface GetInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** CreateInstanceRequest is the request for creating an instance. */
export interface CreateInstanceRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. ID of the instance to be created. */
  instanceId: string;
  /** Required. The resource being created. */
  instance:
    | Instance
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** DeleteInstanceRequest is the request for deleting an instance. */
export interface DeleteInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** ListRepositoriesRequest is request to list repositories. */
export interface ListRepositoriesRequest {
  /** Required. Parent value for ListRepositoriesRequest. */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filter results. */
  filter: string;
}

export interface ListRepositoriesResponse {
  /** The list of repositories. */
  repositories: Repository[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
}

/** GetRepositoryRequest is the request for getting a repository. */
export interface GetRepositoryRequest {
  /**
   * Required. Name of the repository to retrieve.
   * The format is
   * `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`.
   */
  name: string;
}

/** CreateRepositoryRequest is the request for creating a repository. */
export interface CreateRepositoryRequest {
  /**
   * Required. The project in which to create the repository. Values are of the
   * form `projects/{project_number}/locations/{location_id}`
   */
  parent: string;
  /** Required. The resource being created. */
  repository:
    | Repository
    | undefined;
  /**
   * Required. The ID to use for the repository, which will become the final
   * component of the repository's resource name. This value should be 4-63
   * characters, and valid characters are /[a-z][0-9]-/.
   */
  repositoryId: string;
}

/** DeleteRepositoryRequest is the request to delete a repository. */
export interface DeleteRepositoryRequest {
  /**
   * Required. Name of the repository to delete.
   * The format is
   * projects/{project_number}/locations/{location_id}/repositories/{repository_id}.
   */
  name: string;
  /**
   * Optional. If set to true, and the repository is not found, the request will
   * succeed but no action will be taken on the server.
   */
  allowMissing: boolean;
}

function createBaseInstance(): Instance {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    privateConfig: undefined,
    state: 0,
    stateNote: 0,
    kmsKey: "",
    hostConfig: undefined,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.privateConfig !== undefined) {
      Instance_PrivateConfig.encode(message.privateConfig, writer.uint32(106).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.stateNote !== 0) {
      writer.uint32(80).int32(message.stateNote);
    }
    if (message.kmsKey !== "") {
      writer.uint32(90).string(message.kmsKey);
    }
    if (message.hostConfig !== undefined) {
      Instance_HostConfig.encode(message.hostConfig, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.privateConfig = Instance_PrivateConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stateNote = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hostConfig = Instance_HostConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      privateConfig: isSet(object.privateConfig) ? Instance_PrivateConfig.fromJSON(object.privateConfig) : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      stateNote: isSet(object.stateNote) ? instance_StateNoteFromJSON(object.stateNote) : 0,
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      hostConfig: isSet(object.hostConfig) ? Instance_HostConfig.fromJSON(object.hostConfig) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.privateConfig !== undefined) {
      obj.privateConfig = Instance_PrivateConfig.toJSON(message.privateConfig);
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.stateNote !== 0) {
      obj.stateNote = instance_StateNoteToJSON(message.stateNote);
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.hostConfig !== undefined) {
      obj.hostConfig = Instance_HostConfig.toJSON(message.hostConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.privateConfig = (object.privateConfig !== undefined && object.privateConfig !== null)
      ? Instance_PrivateConfig.fromPartial(object.privateConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.stateNote = object.stateNote ?? 0;
    message.kmsKey = object.kmsKey ?? "";
    message.hostConfig = (object.hostConfig !== undefined && object.hostConfig !== null)
      ? Instance_HostConfig.fromPartial(object.hostConfig)
      : undefined;
    return message;
  },
};

function createBaseInstance_HostConfig(): Instance_HostConfig {
  return { html: "", api: "", gitHttp: "", gitSsh: "" };
}

export const Instance_HostConfig: MessageFns<Instance_HostConfig> = {
  encode(message: Instance_HostConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.html !== "") {
      writer.uint32(10).string(message.html);
    }
    if (message.api !== "") {
      writer.uint32(18).string(message.api);
    }
    if (message.gitHttp !== "") {
      writer.uint32(26).string(message.gitHttp);
    }
    if (message.gitSsh !== "") {
      writer.uint32(34).string(message.gitSsh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_HostConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_HostConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.html = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.api = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gitHttp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gitSsh = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_HostConfig {
    return {
      html: isSet(object.html) ? globalThis.String(object.html) : "",
      api: isSet(object.api) ? globalThis.String(object.api) : "",
      gitHttp: isSet(object.gitHttp) ? globalThis.String(object.gitHttp) : "",
      gitSsh: isSet(object.gitSsh) ? globalThis.String(object.gitSsh) : "",
    };
  },

  toJSON(message: Instance_HostConfig): unknown {
    const obj: any = {};
    if (message.html !== "") {
      obj.html = message.html;
    }
    if (message.api !== "") {
      obj.api = message.api;
    }
    if (message.gitHttp !== "") {
      obj.gitHttp = message.gitHttp;
    }
    if (message.gitSsh !== "") {
      obj.gitSsh = message.gitSsh;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_HostConfig>): Instance_HostConfig {
    return Instance_HostConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_HostConfig>): Instance_HostConfig {
    const message = createBaseInstance_HostConfig();
    message.html = object.html ?? "";
    message.api = object.api ?? "";
    message.gitHttp = object.gitHttp ?? "";
    message.gitSsh = object.gitSsh ?? "";
    return message;
  },
};

function createBaseInstance_PrivateConfig(): Instance_PrivateConfig {
  return { isPrivate: false, caPool: "", httpServiceAttachment: "", sshServiceAttachment: "" };
}

export const Instance_PrivateConfig: MessageFns<Instance_PrivateConfig> = {
  encode(message: Instance_PrivateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isPrivate !== false) {
      writer.uint32(8).bool(message.isPrivate);
    }
    if (message.caPool !== "") {
      writer.uint32(18).string(message.caPool);
    }
    if (message.httpServiceAttachment !== "") {
      writer.uint32(26).string(message.httpServiceAttachment);
    }
    if (message.sshServiceAttachment !== "") {
      writer.uint32(34).string(message.sshServiceAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_PrivateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_PrivateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isPrivate = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.caPool = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.httpServiceAttachment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sshServiceAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_PrivateConfig {
    return {
      isPrivate: isSet(object.isPrivate) ? globalThis.Boolean(object.isPrivate) : false,
      caPool: isSet(object.caPool) ? globalThis.String(object.caPool) : "",
      httpServiceAttachment: isSet(object.httpServiceAttachment) ? globalThis.String(object.httpServiceAttachment) : "",
      sshServiceAttachment: isSet(object.sshServiceAttachment) ? globalThis.String(object.sshServiceAttachment) : "",
    };
  },

  toJSON(message: Instance_PrivateConfig): unknown {
    const obj: any = {};
    if (message.isPrivate !== false) {
      obj.isPrivate = message.isPrivate;
    }
    if (message.caPool !== "") {
      obj.caPool = message.caPool;
    }
    if (message.httpServiceAttachment !== "") {
      obj.httpServiceAttachment = message.httpServiceAttachment;
    }
    if (message.sshServiceAttachment !== "") {
      obj.sshServiceAttachment = message.sshServiceAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_PrivateConfig>): Instance_PrivateConfig {
    return Instance_PrivateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_PrivateConfig>): Instance_PrivateConfig {
    const message = createBaseInstance_PrivateConfig();
    message.isPrivate = object.isPrivate ?? false;
    message.caPool = object.caPool ?? "";
    message.httpServiceAttachment = object.httpServiceAttachment ?? "";
    message.sshServiceAttachment = object.sshServiceAttachment ?? "";
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRepository(): Repository {
  return {
    name: "",
    description: "",
    instance: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    etag: "",
    uris: undefined,
    initialConfig: undefined,
  };
}

export const Repository: MessageFns<Repository> = {
  encode(message: Repository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.uid !== "") {
      writer.uint32(34).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    if (message.uris !== undefined) {
      Repository_URIs.encode(message.uris, writer.uint32(74).fork()).join();
    }
    if (message.initialConfig !== undefined) {
      Repository_InitialConfig.encode(message.initialConfig, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Repository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uris = Repository_URIs.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.initialConfig = Repository_InitialConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Repository {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      uris: isSet(object.uris) ? Repository_URIs.fromJSON(object.uris) : undefined,
      initialConfig: isSet(object.initialConfig) ? Repository_InitialConfig.fromJSON(object.initialConfig) : undefined,
    };
  },

  toJSON(message: Repository): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.uris !== undefined) {
      obj.uris = Repository_URIs.toJSON(message.uris);
    }
    if (message.initialConfig !== undefined) {
      obj.initialConfig = Repository_InitialConfig.toJSON(message.initialConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Repository>): Repository {
    return Repository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Repository>): Repository {
    const message = createBaseRepository();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.instance = object.instance ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    message.uris = (object.uris !== undefined && object.uris !== null)
      ? Repository_URIs.fromPartial(object.uris)
      : undefined;
    message.initialConfig = (object.initialConfig !== undefined && object.initialConfig !== null)
      ? Repository_InitialConfig.fromPartial(object.initialConfig)
      : undefined;
    return message;
  },
};

function createBaseRepository_URIs(): Repository_URIs {
  return { html: "", gitHttps: "", api: "" };
}

export const Repository_URIs: MessageFns<Repository_URIs> = {
  encode(message: Repository_URIs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.html !== "") {
      writer.uint32(10).string(message.html);
    }
    if (message.gitHttps !== "") {
      writer.uint32(18).string(message.gitHttps);
    }
    if (message.api !== "") {
      writer.uint32(26).string(message.api);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Repository_URIs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepository_URIs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.html = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gitHttps = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.api = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Repository_URIs {
    return {
      html: isSet(object.html) ? globalThis.String(object.html) : "",
      gitHttps: isSet(object.gitHttps) ? globalThis.String(object.gitHttps) : "",
      api: isSet(object.api) ? globalThis.String(object.api) : "",
    };
  },

  toJSON(message: Repository_URIs): unknown {
    const obj: any = {};
    if (message.html !== "") {
      obj.html = message.html;
    }
    if (message.gitHttps !== "") {
      obj.gitHttps = message.gitHttps;
    }
    if (message.api !== "") {
      obj.api = message.api;
    }
    return obj;
  },

  create(base?: DeepPartial<Repository_URIs>): Repository_URIs {
    return Repository_URIs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Repository_URIs>): Repository_URIs {
    const message = createBaseRepository_URIs();
    message.html = object.html ?? "";
    message.gitHttps = object.gitHttps ?? "";
    message.api = object.api ?? "";
    return message;
  },
};

function createBaseRepository_InitialConfig(): Repository_InitialConfig {
  return { defaultBranch: "", gitignores: [], license: "", readme: "" };
}

export const Repository_InitialConfig: MessageFns<Repository_InitialConfig> = {
  encode(message: Repository_InitialConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultBranch !== "") {
      writer.uint32(10).string(message.defaultBranch);
    }
    for (const v of message.gitignores) {
      writer.uint32(18).string(v!);
    }
    if (message.license !== "") {
      writer.uint32(26).string(message.license);
    }
    if (message.readme !== "") {
      writer.uint32(34).string(message.readme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Repository_InitialConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepository_InitialConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultBranch = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gitignores.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.license = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readme = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Repository_InitialConfig {
    return {
      defaultBranch: isSet(object.defaultBranch) ? globalThis.String(object.defaultBranch) : "",
      gitignores: globalThis.Array.isArray(object?.gitignores)
        ? object.gitignores.map((e: any) => globalThis.String(e))
        : [],
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      readme: isSet(object.readme) ? globalThis.String(object.readme) : "",
    };
  },

  toJSON(message: Repository_InitialConfig): unknown {
    const obj: any = {};
    if (message.defaultBranch !== "") {
      obj.defaultBranch = message.defaultBranch;
    }
    if (message.gitignores?.length) {
      obj.gitignores = message.gitignores;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.readme !== "") {
      obj.readme = message.readme;
    }
    return obj;
  },

  create(base?: DeepPartial<Repository_InitialConfig>): Repository_InitialConfig {
    return Repository_InitialConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Repository_InitialConfig>): Repository_InitialConfig {
    const message = createBaseRepository_InitialConfig();
    message.defaultBranch = object.defaultBranch ?? "";
    message.gitignores = object.gitignores?.map((e) => e) || [];
    message.license = object.license ?? "";
    message.readme = object.readme ?? "";
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateInstanceRequest(): CreateInstanceRequest {
  return { parent: "", instanceId: "", instance: undefined, requestId: "" };
}

export const CreateInstanceRequest: MessageFns<CreateInstanceRequest> = {
  encode(message: CreateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateInstanceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    return CreateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    const message = createBaseCreateInstanceRequest();
    message.parent = object.parent ?? "";
    message.instanceId = object.instanceId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteInstanceRequest(): DeleteInstanceRequest {
  return { name: "", requestId: "" };
}

export const DeleteInstanceRequest: MessageFns<DeleteInstanceRequest> = {
  encode(message: DeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    return DeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    const message = createBaseDeleteInstanceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseListRepositoriesRequest(): ListRepositoriesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRepositoriesRequest: MessageFns<ListRepositoriesRequest> = {
  encode(message: ListRepositoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepositoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepositoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepositoriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRepositoriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepositoriesRequest>): ListRepositoriesRequest {
    return ListRepositoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepositoriesRequest>): ListRepositoriesRequest {
    const message = createBaseListRepositoriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRepositoriesResponse(): ListRepositoriesResponse {
  return { repositories: [], nextPageToken: "" };
}

export const ListRepositoriesResponse: MessageFns<ListRepositoriesResponse> = {
  encode(message: ListRepositoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repositories) {
      Repository.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepositoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepositoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repositories.push(Repository.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepositoriesResponse {
    return {
      repositories: globalThis.Array.isArray(object?.repositories)
        ? object.repositories.map((e: any) => Repository.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRepositoriesResponse): unknown {
    const obj: any = {};
    if (message.repositories?.length) {
      obj.repositories = message.repositories.map((e) => Repository.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepositoriesResponse>): ListRepositoriesResponse {
    return ListRepositoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepositoriesResponse>): ListRepositoriesResponse {
    const message = createBaseListRepositoriesResponse();
    message.repositories = object.repositories?.map((e) => Repository.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetRepositoryRequest(): GetRepositoryRequest {
  return { name: "" };
}

export const GetRepositoryRequest: MessageFns<GetRepositoryRequest> = {
  encode(message: GetRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepositoryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRepositoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRepositoryRequest>): GetRepositoryRequest {
    return GetRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRepositoryRequest>): GetRepositoryRequest {
    const message = createBaseGetRepositoryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateRepositoryRequest(): CreateRepositoryRequest {
  return { parent: "", repository: undefined, repositoryId: "" };
}

export const CreateRepositoryRequest: MessageFns<CreateRepositoryRequest> = {
  encode(message: CreateRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.repository !== undefined) {
      Repository.encode(message.repository, writer.uint32(18).fork()).join();
    }
    if (message.repositoryId !== "") {
      writer.uint32(26).string(message.repositoryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repository = Repository.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repositoryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRepositoryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      repository: isSet(object.repository) ? Repository.fromJSON(object.repository) : undefined,
      repositoryId: isSet(object.repositoryId) ? globalThis.String(object.repositoryId) : "",
    };
  },

  toJSON(message: CreateRepositoryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.repository !== undefined) {
      obj.repository = Repository.toJSON(message.repository);
    }
    if (message.repositoryId !== "") {
      obj.repositoryId = message.repositoryId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRepositoryRequest>): CreateRepositoryRequest {
    return CreateRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRepositoryRequest>): CreateRepositoryRequest {
    const message = createBaseCreateRepositoryRequest();
    message.parent = object.parent ?? "";
    message.repository = (object.repository !== undefined && object.repository !== null)
      ? Repository.fromPartial(object.repository)
      : undefined;
    message.repositoryId = object.repositoryId ?? "";
    return message;
  },
};

function createBaseDeleteRepositoryRequest(): DeleteRepositoryRequest {
  return { name: "", allowMissing: false };
}

export const DeleteRepositoryRequest: MessageFns<DeleteRepositoryRequest> = {
  encode(message: DeleteRepositoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.allowMissing !== false) {
      writer.uint32(16).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRepositoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRepositoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRepositoryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: DeleteRepositoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRepositoryRequest>): DeleteRepositoryRequest {
    return DeleteRepositoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRepositoryRequest>): DeleteRepositoryRequest {
    const message = createBaseDeleteRepositoryRequest();
    message.name = object.name ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

/**
 * Secure Source Manager API
 *
 * Access Secure Source Manager instances, resources, and repositories.
 *
 * This API is split across two servers: the Control Plane and the Data Plane.
 *
 * Data Plane endpoints are hosted directly by your Secure Source Manager
 * instance, so you must connect to your instance's API hostname to access
 * them. The API hostname looks like the following:
 *
 *    https://[instance-id]-[project-number]-api.[location].sourcemanager.dev
 *
 * For example,
 *
 *    https://my-instance-702770452863-api.us-central1.sourcemanager.dev
 *
 * Data Plane endpoints are denoted with **Host: Data Plane**.
 *
 * All other endpoints are found in the normal Cloud API location, namely,
 * `securcesourcemanager.googleapis.com`.
 */
export type SecureSourceManagerDefinition = typeof SecureSourceManagerDefinition;
export const SecureSourceManagerDefinition = {
  name: "SecureSourceManager",
  fullName: "google.cloud.securesourcemanager.v1.SecureSourceManager",
  methods: {
    /** Lists Instances in a given project and location. */
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single instance. */
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new instance in a given project and location. */
    createInstance: {
      name: "CreateInstance",
      requestType: CreateInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              29,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              8,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single instance. */
    deleteInstance: {
      name: "DeleteInstance",
      requestType: DeleteInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              42,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists Repositories in a given project and location.
     *
     * **Host: Data Plane**
     */
    listRepositories: {
      name: "ListRepositories",
      requestType: ListRepositoriesRequest,
      requestStream: false,
      responseType: ListRepositoriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets metadata of a repository.
     *
     * **Host: Data Plane**
     */
    getRepository: {
      name: "GetRepository",
      requestType: GetRepositoryRequest,
      requestStream: false,
      responseType: Repository,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new repository in a given project and location.
     *
     * **Host: Data Plane**
     */
    createRepository: {
      name: "CreateRepository",
      requestType: CreateRepositoryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              82,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              44,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              10,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              121,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a Repository.
     *
     * **Host: Data Plane**
     */
    deleteRepository: {
      name: "DeleteRepository",
      requestType: DeleteRepositoryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get IAM policy for a repository. */
    getIamPolicyRepo: {
      name: "GetIamPolicyRepo",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              67,
              18,
              65,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Set IAM policy on a repository. */
    setIamPolicyRepo: {
      name: "SetIamPolicyRepo",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Test IAM permissions on a repository.
     * IAM permission checks are not required on this method.
     */
    testIamPermissionsRepo: {
      name: "TestIamPermissionsRepo",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              115,
              105,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SecureSourceManagerServiceImplementation<CallContextExt = {}> {
  /** Lists Instances in a given project and location. */
  listInstances(
    request: ListInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancesResponse>>;
  /** Gets details of a single instance. */
  getInstance(request: GetInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Instance>>;
  /** Creates a new instance in a given project and location. */
  createInstance(
    request: CreateInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single instance. */
  deleteInstance(
    request: DeleteInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists Repositories in a given project and location.
   *
   * **Host: Data Plane**
   */
  listRepositories(
    request: ListRepositoriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRepositoriesResponse>>;
  /**
   * Gets metadata of a repository.
   *
   * **Host: Data Plane**
   */
  getRepository(request: GetRepositoryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Repository>>;
  /**
   * Creates a new repository in a given project and location.
   *
   * **Host: Data Plane**
   */
  createRepository(
    request: CreateRepositoryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a Repository.
   *
   * **Host: Data Plane**
   */
  deleteRepository(
    request: DeleteRepositoryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Get IAM policy for a repository. */
  getIamPolicyRepo(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /** Set IAM policy on a repository. */
  setIamPolicyRepo(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Test IAM permissions on a repository.
   * IAM permission checks are not required on this method.
   */
  testIamPermissionsRepo(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface SecureSourceManagerClient<CallOptionsExt = {}> {
  /** Lists Instances in a given project and location. */
  listInstances(
    request: DeepPartial<ListInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancesResponse>;
  /** Gets details of a single instance. */
  getInstance(request: DeepPartial<GetInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Instance>;
  /** Creates a new instance in a given project and location. */
  createInstance(
    request: DeepPartial<CreateInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single instance. */
  deleteInstance(
    request: DeepPartial<DeleteInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists Repositories in a given project and location.
   *
   * **Host: Data Plane**
   */
  listRepositories(
    request: DeepPartial<ListRepositoriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRepositoriesResponse>;
  /**
   * Gets metadata of a repository.
   *
   * **Host: Data Plane**
   */
  getRepository(
    request: DeepPartial<GetRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Repository>;
  /**
   * Creates a new repository in a given project and location.
   *
   * **Host: Data Plane**
   */
  createRepository(
    request: DeepPartial<CreateRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a Repository.
   *
   * **Host: Data Plane**
   */
  deleteRepository(
    request: DeepPartial<DeleteRepositoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Get IAM policy for a repository. */
  getIamPolicyRepo(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /** Set IAM policy on a repository. */
  setIamPolicyRepo(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Test IAM permissions on a repository.
   * IAM permission checks are not required on this method.
   */
  testIamPermissionsRepo(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
