// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/channel/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { BillingAccount } from "./billing_accounts.js";
import {
  ChannelPartnerLink,
  ChannelPartnerLinkView,
  channelPartnerLinkViewFromJSON,
  channelPartnerLinkViewToJSON,
} from "./channel_partner_links.js";
import { AdminUser, CloudIdentityInfo } from "./common.js";
import { Customer } from "./customers.js";
import { EntitlementChange } from "./entitlement_changes.js";
import { Entitlement, Parameter, RenewalSettings, TransferableSku } from "./entitlements.js";
import { Offer } from "./offers.js";
import { Product, Sku } from "./products.js";
import { ChannelPartnerRepricingConfig, CustomerRepricingConfig } from "./repricing.js";

export const protobufPackage = "google.cloud.channel.v1";

/**
 * Request message for
 * [CloudChannelService.CheckCloudIdentityAccountsExist][google.cloud.channel.v1.CloudChannelService.CheckCloudIdentityAccountsExist].
 */
export interface CheckCloudIdentityAccountsExistRequest {
  /**
   * Required. The reseller account's resource name.
   * Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /** Required. Domain to fetch for Cloud Identity account customer. */
  domain: string;
}

/**
 * Entity representing a Cloud Identity account that may be
 * associated with a Channel Services API partner.
 */
export interface CloudIdentityCustomerAccount {
  /** Returns true if a Cloud Identity account exists for a specific domain. */
  existing: boolean;
  /**
   * Returns true if the Cloud Identity account is associated with a customer
   * of the Channel Services partner.
   */
  owned: boolean;
  /**
   * If owned = true, the name of the customer that owns the Cloud Identity
   * account.
   * Customer_name uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  customerName: string;
  /** If existing = true, the Cloud Identity ID of the customer. */
  customerCloudIdentityId: string;
}

/**
 * Response message for
 * [CloudChannelService.CheckCloudIdentityAccountsExist][google.cloud.channel.v1.CloudChannelService.CheckCloudIdentityAccountsExist].
 */
export interface CheckCloudIdentityAccountsExistResponse {
  /** The Cloud Identity accounts associated with the domain. */
  cloudIdentityAccounts: CloudIdentityCustomerAccount[];
}

/**
 * Request message for
 * [CloudChannelService.ListCustomers][google.cloud.channel.v1.CloudChannelService.ListCustomers]
 */
export interface ListCustomersRequest {
  /**
   * Required. The resource name of the reseller account to list customers from.
   * Parent uses the format: accounts/{account_id}.
   */
  parent: string;
  /**
   * Optional. The maximum number of customers to return. The service may return
   * fewer than this value. If unspecified, returns at most 10 customers. The
   * maximum value is 50.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results other than the first page.
   * Obtained through
   * [ListCustomersResponse.next_page_token][google.cloud.channel.v1.ListCustomersResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListCustomers][google.cloud.channel.v1.CloudChannelService.ListCustomers]
   * call.
   */
  pageToken: string;
  /**
   * Optional. Filters applied to the [CloudChannelService.ListCustomers]
   * results. See
   * https://cloud.google.com/channel/docs/concepts/google-cloud/filter-customers
   * for more information.
   */
  filter: string;
}

/**
 * Response message for
 * [CloudChannelService.ListCustomers][google.cloud.channel.v1.CloudChannelService.ListCustomers].
 */
export interface ListCustomersResponse {
  /** The customers belonging to a reseller or distributor. */
  customers: Customer[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListCustomersRequest.page_token][google.cloud.channel.v1.ListCustomersRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.GetCustomer][google.cloud.channel.v1.CloudChannelService.GetCustomer].
 */
export interface GetCustomerRequest {
  /**
   * Required. The resource name of the customer to retrieve.
   * Name uses the format: accounts/{account_id}/customers/{customer_id}
   */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.CreateCustomer][google.cloud.channel.v1.CloudChannelService.CreateCustomer]
 */
export interface CreateCustomerRequest {
  /**
   * Required. The resource name of reseller account in which to create the
   * customer. Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /** Required. The customer to create. */
  customer: Customer | undefined;
}

/**
 * Request message for
 * [CloudChannelService.UpdateCustomer][google.cloud.channel.v1.CloudChannelService.UpdateCustomer].
 */
export interface UpdateCustomerRequest {
  /** Required. New contents of the customer. */
  customer:
    | Customer
    | undefined;
  /**
   * The update mask that applies to the resource.
   * Optional.
   */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [CloudChannelService.DeleteCustomer][google.cloud.channel.v1.CloudChannelService.DeleteCustomer].
 */
export interface DeleteCustomerRequest {
  /** Required. The resource name of the customer to delete. */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.ImportCustomer][google.cloud.channel.v1.CloudChannelService.ImportCustomer]
 */
export interface ImportCustomerRequest {
  /** Required. Customer domain. */
  domain?:
    | string
    | undefined;
  /** Required. Customer's Cloud Identity ID */
  cloudIdentityId?:
    | string
    | undefined;
  /**
   * Required. The resource name of the reseller's account.
   * Parent takes the format: accounts/{account_id} or
   * accounts/{account_id}/channelPartnerLinks/{channel_partner_id}
   */
  parent: string;
  /**
   * Optional. The super admin of the resold customer generates this token to
   * authorize a reseller to access their Cloud Identity and purchase
   * entitlements on their behalf. You can omit this token after authorization.
   * See https://support.google.com/a/answer/7643790 for more details.
   */
  authToken: string;
  /**
   * Required. Choose to overwrite an existing customer if found.
   * This must be set to true if there is an existing customer with a
   * conflicting region code or domain.
   */
  overwriteIfExists: boolean;
  /**
   * Optional. Cloud Identity ID of a channel partner who will be the direct
   * reseller for the customer's order. This field is required for 2-tier
   * transfer scenarios and can be provided via the request Parent binding as
   * well.
   */
  channelPartnerId: string;
  /**
   * Optional. Specifies the customer that will receive imported Cloud Identity
   * information.
   * Format: accounts/{account_id}/customers/{customer_id}
   */
  customer: string;
}

/**
 * Request message for
 * [CloudChannelService.ProvisionCloudIdentity][google.cloud.channel.v1.CloudChannelService.ProvisionCloudIdentity]
 */
export interface ProvisionCloudIdentityRequest {
  /**
   * Required. Resource name of the customer.
   * Format: accounts/{account_id}/customers/{customer_id}
   */
  customer: string;
  /** CloudIdentity-specific customer information. */
  cloudIdentityInfo:
    | CloudIdentityInfo
    | undefined;
  /** Admin user information. */
  user:
    | AdminUser
    | undefined;
  /** Validate the request and preview the review, but do not post it. */
  validateOnly: boolean;
}

/**
 * Request message for
 * [CloudChannelService.ListEntitlements][google.cloud.channel.v1.CloudChannelService.ListEntitlements]
 */
export interface ListEntitlementsRequest {
  /**
   * Required. The resource name of the reseller's customer account to list
   * entitlements for.
   * Parent uses the format: accounts/{account_id}/customers/{customer_id}
   */
  parent: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, return at most 50 entitlements. The maximum
   * value is 100; the server will coerce values above 100.
   */
  pageSize: number;
  /**
   * Optional. A token for a page of results other than the first page.
   * Obtained using
   * [ListEntitlementsResponse.next_page_token][google.cloud.channel.v1.ListEntitlementsResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListEntitlements][google.cloud.channel.v1.CloudChannelService.ListEntitlements]
   * call.
   */
  pageToken: string;
}

/**
 * Response message for
 * [CloudChannelService.ListEntitlements][google.cloud.channel.v1.CloudChannelService.ListEntitlements].
 */
export interface ListEntitlementsResponse {
  /** The reseller customer's entitlements. */
  entitlements: Entitlement[];
  /**
   * A token to list the next page of results.
   * Pass to
   * [ListEntitlementsRequest.page_token][google.cloud.channel.v1.ListEntitlementsRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.ListTransferableSkus][google.cloud.channel.v1.CloudChannelService.ListTransferableSkus]
 */
export interface ListTransferableSkusRequest {
  /** Customer's Cloud Identity ID */
  cloudIdentityId?:
    | string
    | undefined;
  /**
   * A reseller is required to create a customer and use the resource name of
   * the created customer here.
   * Customer_name uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  customerName?:
    | string
    | undefined;
  /**
   * Required. The reseller account's resource name.
   * Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /**
   * The requested page size. Server might return fewer results than requested.
   * If unspecified, returns at most 100 SKUs.
   * The maximum value is 1000; the server will coerce values above 1000.
   * Optional.
   */
  pageSize: number;
  /**
   * A token for a page of results other than the first page.
   * Obtained using
   * [ListTransferableSkusResponse.next_page_token][google.cloud.channel.v1.ListTransferableSkusResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListTransferableSkus][google.cloud.channel.v1.CloudChannelService.ListTransferableSkus]
   * call. Optional.
   */
  pageToken: string;
  /**
   * Optional. The super admin of the resold customer generates this token to
   * authorize a reseller to access their Cloud Identity and purchase
   * entitlements on their behalf. You can omit this token after authorization.
   * See https://support.google.com/a/answer/7643790 for more details.
   */
  authToken: string;
  /**
   * The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   * Optional.
   */
  languageCode: string;
}

/**
 * Response message for
 * [CloudChannelService.ListTransferableSkus][google.cloud.channel.v1.CloudChannelService.ListTransferableSkus].
 */
export interface ListTransferableSkusResponse {
  /** Information about existing SKUs for a customer that needs a transfer. */
  transferableSkus: TransferableSku[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListTransferableSkusRequest.page_token][google.cloud.channel.v1.ListTransferableSkusRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.ListTransferableOffers][google.cloud.channel.v1.CloudChannelService.ListTransferableOffers]
 */
export interface ListTransferableOffersRequest {
  /** Customer's Cloud Identity ID */
  cloudIdentityId?:
    | string
    | undefined;
  /**
   * A reseller should create a customer and use the resource name of
   * that customer here.
   */
  customerName?:
    | string
    | undefined;
  /** Required. The resource name of the reseller's account. */
  parent: string;
  /**
   * Requested page size. Server might return fewer results than requested.
   * If unspecified, returns at most 100 offers.
   * The maximum value is 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /**
   * A token for a page of results other than the first page.
   * Obtained using
   * [ListTransferableOffersResponse.next_page_token][google.cloud.channel.v1.ListTransferableOffersResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListTransferableOffers][google.cloud.channel.v1.CloudChannelService.ListTransferableOffers]
   * call.
   */
  pageToken: string;
  /** Required. The SKU to look up Offers for. */
  sku: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
  /**
   * Optional. The Billing Account to look up Offers for. Format:
   * accounts/{account_id}/billingAccounts/{billing_account_id}.
   *
   * This field is only relevant for multi-currency accounts. It should be left
   * empty for single currency accounts.
   */
  billingAccount: string;
}

/**
 * Response message for
 * [CloudChannelService.ListTransferableOffers][google.cloud.channel.v1.CloudChannelService.ListTransferableOffers].
 */
export interface ListTransferableOffersResponse {
  /**
   * Information about Offers for a customer that can be used for
   * transfer.
   */
  transferableOffers: TransferableOffer[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListTransferableOffersRequest.page_token][google.cloud.channel.v1.ListTransferableOffersRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * TransferableOffer represents an Offer that can be used in Transfer.
 * Read-only.
 */
export interface TransferableOffer {
  /** Offer with parameter constraints updated to allow the Transfer. */
  offer: Offer | undefined;
}

/**
 * Request message for
 * [CloudChannelService.GetEntitlement][google.cloud.channel.v1.CloudChannelService.GetEntitlement].
 */
export interface GetEntitlementRequest {
  /**
   * Required. The resource name of the entitlement to retrieve.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.ListChannelPartnerLinks][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerLinks]
 */
export interface ListChannelPartnerLinksRequest {
  /**
   * Required. The resource name of the reseller account for listing channel
   * partner links. Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, server will pick a default size (25). The
   * maximum value is 200; the server will coerce values above 200.
   */
  pageSize: number;
  /**
   * Optional. A token for a page of results other than the first page.
   * Obtained using
   * [ListChannelPartnerLinksResponse.next_page_token][google.cloud.channel.v1.ListChannelPartnerLinksResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListChannelPartnerLinks][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerLinks]
   * call.
   */
  pageToken: string;
  /** Optional. The level of granularity the ChannelPartnerLink will display. */
  view: ChannelPartnerLinkView;
}

/**
 * Response message for
 * [CloudChannelService.ListChannelPartnerLinks][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerLinks].
 */
export interface ListChannelPartnerLinksResponse {
  /** The Channel partner links for a reseller. */
  channelPartnerLinks: ChannelPartnerLink[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListChannelPartnerLinksRequest.page_token][google.cloud.channel.v1.ListChannelPartnerLinksRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.GetChannelPartnerLink][google.cloud.channel.v1.CloudChannelService.GetChannelPartnerLink].
 */
export interface GetChannelPartnerLinkRequest {
  /**
   * Required. The resource name of the channel partner link to retrieve.
   * Name uses the format: accounts/{account_id}/channelPartnerLinks/{id}
   * where {id} is the Cloud Identity ID of the partner.
   */
  name: string;
  /** Optional. The level of granularity the ChannelPartnerLink will display. */
  view: ChannelPartnerLinkView;
}

/**
 * Request message for
 * [CloudChannelService.CreateChannelPartnerLink][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerLink]
 */
export interface CreateChannelPartnerLinkRequest {
  /**
   * Required. Create a channel partner link for the provided reseller account's
   * resource name.
   * Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /**
   * Required. The channel partner link to create.
   * Either channel_partner_link.reseller_cloud_identity_id or domain can be
   * used to create a link.
   */
  channelPartnerLink: ChannelPartnerLink | undefined;
}

/**
 * Request message for
 * [CloudChannelService.UpdateChannelPartnerLink][google.cloud.channel.v1.CloudChannelService.UpdateChannelPartnerLink]
 */
export interface UpdateChannelPartnerLinkRequest {
  /**
   * Required. The resource name of the channel partner link to cancel.
   * Name uses the format: accounts/{account_id}/channelPartnerLinks/{id}
   * where {id} is the Cloud Identity ID of the partner.
   */
  name: string;
  /**
   * Required. The channel partner link to update. Only
   * channel_partner_link.link_state is allowed for updates.
   */
  channelPartnerLink:
    | ChannelPartnerLink
    | undefined;
  /**
   * Required. The update mask that applies to the resource.
   * The only allowable value for an update mask is
   * channel_partner_link.link_state.
   */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [CloudChannelService.GetCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.GetCustomerRepricingConfig].
 */
export interface GetCustomerRepricingConfigRequest {
  /**
   * Required. The resource name of the CustomerRepricingConfig.
   * Format:
   * accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
   */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.ListCustomerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListCustomerRepricingConfigs].
 */
export interface ListCustomerRepricingConfigsRequest {
  /**
   * Required. The resource name of the customer.
   * Parent uses the format: accounts/{account_id}/customers/{customer_id}.
   * Supports accounts/{account_id}/customers/- to retrieve configs for all
   * customers.
   */
  parent: string;
  /**
   * Optional. The maximum number of repricing configs to return. The service
   * may return fewer than this value. If unspecified, returns a maximum of 50
   * rules. The maximum value is 100; values above 100 will be coerced to 100.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results beyond the first page.
   * Obtained through
   * [ListCustomerRepricingConfigsResponse.next_page_token][google.cloud.channel.v1.ListCustomerRepricingConfigsResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListCustomerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListCustomerRepricingConfigs]
   * call.
   */
  pageToken: string;
  /**
   * Optional. A filter for [CloudChannelService.ListCustomerRepricingConfigs]
   * results (customer only). You can use this filter when you support
   * a BatchGet-like query.
   * To use the filter, you must set `parent=accounts/{account_id}/customers/-`.
   *
   * Example: customer = accounts/account_id/customers/c1 OR
   * customer = accounts/account_id/customers/c2.
   */
  filter: string;
}

/**
 * Response message for
 * [CloudChannelService.ListCustomerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListCustomerRepricingConfigs].
 */
export interface ListCustomerRepricingConfigsResponse {
  /** The repricing configs for this channel partner. */
  customerRepricingConfigs: CustomerRepricingConfig[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListCustomerRepricingConfigsRequest.page_token][google.cloud.channel.v1.ListCustomerRepricingConfigsRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.CreateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateCustomerRepricingConfig].
 */
export interface CreateCustomerRepricingConfigRequest {
  /**
   * Required. The resource name of the customer that will receive this
   * repricing config. Parent uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  parent: string;
  /** Required. The CustomerRepricingConfig object to update. */
  customerRepricingConfig: CustomerRepricingConfig | undefined;
}

/**
 * Request message for
 * [CloudChannelService.UpdateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.UpdateCustomerRepricingConfig].
 */
export interface UpdateCustomerRepricingConfigRequest {
  /** Required. The CustomerRepricingConfig object to update. */
  customerRepricingConfig: CustomerRepricingConfig | undefined;
}

/**
 * Request message for
 * [CloudChannelService.DeleteCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.DeleteCustomerRepricingConfig].
 */
export interface DeleteCustomerRepricingConfigRequest {
  /**
   * Required. The resource name of the customer repricing config rule to
   * delete. Format:
   * accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
   */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.GetChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.GetChannelPartnerRepricingConfig]
 */
export interface GetChannelPartnerRepricingConfigRequest {
  /**
   * Required. The resource name of the ChannelPartnerRepricingConfig
   * Format:
   * accounts/{account_id}/channelPartnerLinks/{channel_partner_id}/channelPartnerRepricingConfigs/{id}.
   */
  name: string;
}

/**
 * Request message for
 * [CloudChannelService.ListChannelPartnerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerRepricingConfigs].
 */
export interface ListChannelPartnerRepricingConfigsRequest {
  /**
   * Required. The resource name of the account's
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]. Parent
   * uses the format:
   * accounts/{account_id}/channelPartnerLinks/{channel_partner_id}.
   * Supports accounts/{account_id}/channelPartnerLinks/- to retrieve configs
   * for all channel partners.
   */
  parent: string;
  /**
   * Optional. The maximum number of repricing configs to return. The service
   * may return fewer than this value. If unspecified, returns a maximum of 50
   * rules. The maximum value is 100; values above 100 will be coerced to 100.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results beyond the first page.
   * Obtained through
   * [ListChannelPartnerRepricingConfigsResponse.next_page_token][google.cloud.channel.v1.ListChannelPartnerRepricingConfigsResponse.next_page_token]
   * of the previous
   * [CloudChannelService.ListChannelPartnerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerRepricingConfigs]
   * call.
   */
  pageToken: string;
  /**
   * Optional. A filter for
   * [CloudChannelService.ListChannelPartnerRepricingConfigs] results
   * (channel_partner_link only). You can use this filter when you support a
   * BatchGet-like query. To use the filter, you must set
   * `parent=accounts/{account_id}/channelPartnerLinks/-`.
   *
   * Example: `channel_partner_link =
   * accounts/account_id/channelPartnerLinks/c1` OR `channel_partner_link =
   * accounts/account_id/channelPartnerLinks/c2`.
   */
  filter: string;
}

/**
 * Response message for
 * [CloudChannelService.ListChannelPartnerRepricingConfigs][google.cloud.channel.v1.CloudChannelService.ListChannelPartnerRepricingConfigs].
 */
export interface ListChannelPartnerRepricingConfigsResponse {
  /** The repricing configs for this channel partner. */
  channelPartnerRepricingConfigs: ChannelPartnerRepricingConfig[];
  /**
   * A token to retrieve the next page of results.
   * Pass to
   * [ListChannelPartnerRepricingConfigsRequest.page_token][google.cloud.channel.v1.ListChannelPartnerRepricingConfigsRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.CreateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerRepricingConfig].
 */
export interface CreateChannelPartnerRepricingConfigRequest {
  /**
   * Required. The resource name of the ChannelPartner that will receive the
   * repricing config. Parent uses the format:
   * accounts/{account_id}/channelPartnerLinks/{channel_partner_id}
   */
  parent: string;
  /** Required. The ChannelPartnerRepricingConfig object to update. */
  channelPartnerRepricingConfig: ChannelPartnerRepricingConfig | undefined;
}

/**
 * Request message for
 * [CloudChannelService.UpdateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.UpdateChannelPartnerRepricingConfig].
 */
export interface UpdateChannelPartnerRepricingConfigRequest {
  /** Required. The ChannelPartnerRepricingConfig object to update. */
  channelPartnerRepricingConfig: ChannelPartnerRepricingConfig | undefined;
}

/** Request message for DeleteChannelPartnerRepricingConfig. */
export interface DeleteChannelPartnerRepricingConfigRequest {
  /**
   * Required. The resource name of the channel partner repricing config rule to
   * delete.
   */
  name: string;
}

/** Request message for ListSkuGroups. */
export interface ListSkuGroupsRequest {
  /**
   * Required. The resource name of the account from which to list SKU groups.
   * Parent uses the format: accounts/{account}.
   */
  parent: string;
  /**
   * Optional. The maximum number of SKU groups to return. The service may
   * return fewer than this value. If unspecified, returns a maximum of 1000 SKU
   * groups. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results beyond the first page.
   * Obtained through
   * [ListSkuGroups.next_page_token][] of the previous
   * [CloudChannelService.ListSkuGroups][google.cloud.channel.v1.CloudChannelService.ListSkuGroups]
   * call.
   */
  pageToken: string;
}

/** Request message for ListSkuGroupBillableSkus. */
export interface ListSkuGroupBillableSkusRequest {
  /**
   * Required. Resource name of the SKU group.
   * Format: accounts/{account}/skuGroups/{sku_group}.
   */
  parent: string;
  /**
   * Optional. The maximum number of SKUs to return. The service may return
   * fewer than this value. If unspecified, returns a maximum of 100000 SKUs.
   * The maximum value is 100000; values above 100000 will be coerced to 100000.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results beyond the first page.
   * Obtained through
   * [ListSkuGroupBillableSkus.next_page_token][] of the previous
   * [CloudChannelService.ListSkuGroupBillableSkus][google.cloud.channel.v1.CloudChannelService.ListSkuGroupBillableSkus]
   * call.
   */
  pageToken: string;
}

/** Response message for ListSkuGroups. */
export interface ListSkuGroupsResponse {
  /** The list of SKU groups requested. */
  skuGroups: SkuGroup[];
  /**
   * A token to retrieve the next page of results.
   * Pass to [ListSkuGroups.page_token][] to obtain that
   * page.
   */
  nextPageToken: string;
}

/** Response message for ListSkuGroupBillableSkus. */
export interface ListSkuGroupBillableSkusResponse {
  /** The list of billable SKUs in the requested SKU group. */
  billableSkus: BillableSku[];
  /**
   * A token to retrieve the next page of results.
   * Pass to [ListSkuGroupBillableSkus.page_token][] to obtain that
   * page.
   */
  nextPageToken: string;
}

/** Represents the SKU group information. */
export interface SkuGroup {
  /**
   * Resource name of SKU group. Format:
   * accounts/{account}/skuGroups/{sku_group}.
   * Example:
   * "accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041".
   */
  name: string;
  /** Unique human readable identifier for the SKU group. */
  displayName: string;
}

/** Represents the Billable SKU information. */
export interface BillableSku {
  /**
   * Resource name of Billable SKU. Format:
   * billableSkus/{sku}.
   * Example:
   * billableSkus/6E1B-6634-470F".
   */
  sku: string;
  /** Unique human readable name for the SKU. */
  skuDisplayName: string;
  /**
   * Resource name of Service which contains Repricing SKU. Format:
   * services/{service}.
   * Example:
   * "services/B7D9-FDCB-15D8".
   */
  service: string;
  /** Unique human readable name for the Service. */
  serviceDisplayName: string;
}

/**
 * Request message for
 * [CloudChannelService.CreateEntitlement][google.cloud.channel.v1.CloudChannelService.CreateEntitlement]
 */
export interface CreateEntitlementRequest {
  /**
   * Required. The resource name of the reseller's customer account in which to
   * create the entitlement. Parent uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  parent: string;
  /** Required. The entitlement to create. */
  entitlement:
    | Entitlement
    | undefined;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Request message for
 * [CloudChannelService.TransferEntitlements][google.cloud.channel.v1.CloudChannelService.TransferEntitlements].
 */
export interface TransferEntitlementsRequest {
  /**
   * Required. The resource name of the reseller's customer account that will
   * receive transferred entitlements. Parent uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  parent: string;
  /** Required. The new entitlements to create or transfer. */
  entitlements: Entitlement[];
  /**
   * The super admin of the resold customer generates this token to
   * authorize a reseller to access their Cloud Identity and purchase
   * entitlements on their behalf. You can omit this token after authorization.
   * See https://support.google.com/a/answer/7643790 for more details.
   */
  authToken: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Response message for
 * [CloudChannelService.TransferEntitlements][google.cloud.channel.v1.CloudChannelService.TransferEntitlements].
 * This is put in the response field of google.longrunning.Operation.
 */
export interface TransferEntitlementsResponse {
  /** The transferred entitlements. */
  entitlements: Entitlement[];
}

/**
 * Request message for
 * [CloudChannelService.TransferEntitlementsToGoogle][google.cloud.channel.v1.CloudChannelService.TransferEntitlementsToGoogle].
 */
export interface TransferEntitlementsToGoogleRequest {
  /**
   * Required. The resource name of the reseller's customer account where the
   * entitlements transfer from. Parent uses the format:
   * accounts/{account_id}/customers/{customer_id}
   */
  parent: string;
  /** Required. The entitlements to transfer to Google. */
  entitlements: Entitlement[];
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/** Request message for [CloudChannelService.ChangeParametersRequest][]. */
export interface ChangeParametersRequest {
  /**
   * Required. The name of the entitlement to update.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Required. Entitlement parameters to update. You can only change editable
   * parameters.
   *
   * To view the available Parameters for a request, refer to the
   * [Offer.parameter_definitions][google.cloud.channel.v1.Offer.parameter_definitions]
   * from the desired offer.
   */
  parameters: Parameter[];
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
  /** Optional. Purchase order ID provided by the reseller. */
  purchaseOrderId: string;
}

/**
 * Request message for
 * [CloudChannelService.ChangeRenewalSettings][google.cloud.channel.v1.CloudChannelService.ChangeRenewalSettings].
 */
export interface ChangeRenewalSettingsRequest {
  /**
   * Required. The name of the entitlement to update.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /** Required. New renewal settings. */
  renewalSettings:
    | RenewalSettings
    | undefined;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Request message for
 * [CloudChannelService.ChangeOffer][google.cloud.channel.v1.CloudChannelService.ChangeOffer].
 */
export interface ChangeOfferRequest {
  /**
   * Required. The resource name of the entitlement to update.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Required. New Offer.
   * Format: accounts/{account_id}/offers/{offer_id}.
   */
  offer: string;
  /**
   * Optional. Parameters needed to purchase the Offer. To view the available
   * Parameters refer to the
   * [Offer.parameter_definitions][google.cloud.channel.v1.Offer.parameter_definitions]
   * from the desired offer.
   */
  parameters: Parameter[];
  /** Optional. Purchase order id provided by the reseller. */
  purchaseOrderId: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
  /**
   * Optional. The billing account resource name that is used to pay for this
   * entitlement when setting up billing on a trial subscription.
   *
   * This field is only relevant for multi-currency accounts. It should be
   * left empty for single currency accounts.
   */
  billingAccount: string;
}

/**
 * Request message for
 * [CloudChannelService.StartPaidService][google.cloud.channel.v1.CloudChannelService.StartPaidService].
 */
export interface StartPaidServiceRequest {
  /**
   * Required. The name of the entitlement to start a paid service for.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Request message for
 * [CloudChannelService.CancelEntitlement][google.cloud.channel.v1.CloudChannelService.CancelEntitlement].
 */
export interface CancelEntitlementRequest {
  /**
   * Required. The resource name of the entitlement to cancel.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Request message for
 * [CloudChannelService.SuspendEntitlement][google.cloud.channel.v1.CloudChannelService.SuspendEntitlement].
 */
export interface SuspendEntitlementRequest {
  /**
   * Required. The resource name of the entitlement to suspend.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/**
 * Request message for
 * [CloudChannelService.ActivateEntitlement][google.cloud.channel.v1.CloudChannelService.ActivateEntitlement].
 */
export interface ActivateEntitlementRequest {
  /**
   * Required. The resource name of the entitlement to activate.
   * Name uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  name: string;
  /**
   * Optional. You can specify an optional unique request ID, and if you need to
   * retry your request, the server will know to ignore the request if it's
   * complete.
   *
   * For example, you make an initial request and the request times out. If you
   * make the request again with the same request ID, the server can check if
   * it received the original operation with the same request ID. If it did, it
   * will ignore the second request.
   *
   * The request ID must be a valid [UUID](https://tools.ietf.org/html/rfc4122)
   * with the exception that zero UUID is not supported
   * (`00000000-0000-0000-0000-000000000000`).
   */
  requestId: string;
}

/** Request message for LookupOffer. */
export interface LookupOfferRequest {
  /**
   * Required. The resource name of the entitlement to retrieve the Offer.
   * Entitlement uses the format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  entitlement: string;
}

/** Request message for ListProducts. */
export interface ListProductsRequest {
  /**
   * Required. The resource name of the reseller account.
   * Format: accounts/{account_id}.
   */
  account: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, returns at most 100 Products. The maximum value
   * is 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /** Optional. A token for a page of results other than the first page. */
  pageToken: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
}

/** Response message for ListProducts. */
export interface ListProductsResponse {
  /** List of Products requested. */
  products: Product[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
}

/** Request message for ListSkus. */
export interface ListSkusRequest {
  /**
   * Required. The resource name of the Product to list SKUs for.
   * Parent uses the format: products/{product_id}.
   * Supports products/- to retrieve SKUs for all products.
   */
  parent: string;
  /**
   * Required. Resource name of the reseller.
   * Format: accounts/{account_id}.
   */
  account: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, returns at most 100 SKUs. The maximum value is
   * 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /**
   * Optional. A token for a page of results other than the first page.
   * Optional.
   */
  pageToken: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
}

/** Response message for ListSkus. */
export interface ListSkusResponse {
  /** The list of SKUs requested. */
  skus: Sku[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
}

/** Request message for ListOffers. */
export interface ListOffersRequest {
  /**
   * Required. The resource name of the reseller account from which to list
   * Offers. Parent uses the format: accounts/{account_id}.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, returns at most 500 Offers. The maximum value is
   * 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /** Optional. A token for a page of results other than the first page. */
  pageToken: string;
  /**
   * Optional. The expression to filter results by name (name of
   * the Offer), sku.name (name of the SKU), or sku.product.name (name of the
   * Product).
   * Example 1: sku.product.name=products/p1 AND sku.name!=products/p1/skus/s1
   * Example 2: name=accounts/a1/offers/o1
   */
  filter: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
  /**
   * Optional. A boolean flag that determines if a response returns future
   * offers 30 days from now. If the show_future_offers is true, the response
   * will only contain offers that are scheduled to be available 30 days from
   * now.
   */
  showFutureOffers: boolean;
}

/** Response message for ListOffers. */
export interface ListOffersResponse {
  /** The list of Offers requested. */
  offers: Offer[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
}

/** Request message for ListPurchasableSkus. */
export interface ListPurchasableSkusRequest {
  /** List SKUs for CreateEntitlement purchase. */
  createEntitlementPurchase?:
    | ListPurchasableSkusRequest_CreateEntitlementPurchase
    | undefined;
  /** List SKUs for ChangeOffer purchase with a new SKU. */
  changeOfferPurchase?:
    | ListPurchasableSkusRequest_ChangeOfferPurchase
    | undefined;
  /**
   * Required. The resource name of the customer to list SKUs for.
   * Format: accounts/{account_id}/customers/{customer_id}.
   */
  customer: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, returns at most 100 SKUs. The maximum value is
   * 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /** Optional. A token for a page of results other than the first page. */
  pageToken: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
}

/**
 * List SKUs for a new entitlement. Make the purchase using
 * [CloudChannelService.CreateEntitlement][google.cloud.channel.v1.CloudChannelService.CreateEntitlement].
 */
export interface ListPurchasableSkusRequest_CreateEntitlementPurchase {
  /**
   * Required. List SKUs belonging to this Product.
   * Format: products/{product_id}.
   * Supports products/- to retrieve SKUs for all products.
   */
  product: string;
}

/**
 * List SKUs for upgrading or downgrading an entitlement. Make the purchase
 * using
 * [CloudChannelService.ChangeOffer][google.cloud.channel.v1.CloudChannelService.ChangeOffer].
 */
export interface ListPurchasableSkusRequest_ChangeOfferPurchase {
  /**
   * Required. Resource name of the entitlement.
   * Format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  entitlement: string;
  /** Required. Change Type for the entitlement. */
  changeType: ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType;
}

/** Change Type enum. */
export enum ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType {
  /** CHANGE_TYPE_UNSPECIFIED - Not used. */
  CHANGE_TYPE_UNSPECIFIED = 0,
  /** UPGRADE - SKU is an upgrade on the current entitlement. */
  UPGRADE = 1,
  /** DOWNGRADE - SKU is a downgrade on the current entitlement. */
  DOWNGRADE = 2,
  UNRECOGNIZED = -1,
}

export function listPurchasableSkusRequest_ChangeOfferPurchase_ChangeTypeFromJSON(
  object: any,
): ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType {
  switch (object) {
    case 0:
    case "CHANGE_TYPE_UNSPECIFIED":
      return ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "UPGRADE":
      return ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.UPGRADE;
    case 2:
    case "DOWNGRADE":
      return ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.DOWNGRADE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.UNRECOGNIZED;
  }
}

export function listPurchasableSkusRequest_ChangeOfferPurchase_ChangeTypeToJSON(
  object: ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType,
): string {
  switch (object) {
    case ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.CHANGE_TYPE_UNSPECIFIED:
      return "CHANGE_TYPE_UNSPECIFIED";
    case ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.UPGRADE:
      return "UPGRADE";
    case ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.DOWNGRADE:
      return "DOWNGRADE";
    case ListPurchasableSkusRequest_ChangeOfferPurchase_ChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response message for ListPurchasableSkus. */
export interface ListPurchasableSkusResponse {
  /** The list of SKUs requested. */
  purchasableSkus: PurchasableSku[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
}

/**
 * SKU that you can purchase. This is used in ListPurchasableSku API
 * response.
 */
export interface PurchasableSku {
  /** SKU */
  sku: Sku | undefined;
}

/** Request message for ListPurchasableOffers. */
export interface ListPurchasableOffersRequest {
  /** List Offers for CreateEntitlement purchase. */
  createEntitlementPurchase?:
    | ListPurchasableOffersRequest_CreateEntitlementPurchase
    | undefined;
  /** List Offers for ChangeOffer purchase. */
  changeOfferPurchase?:
    | ListPurchasableOffersRequest_ChangeOfferPurchase
    | undefined;
  /**
   * Required. The resource name of the customer to list Offers for.
   * Format: accounts/{account_id}/customers/{customer_id}.
   */
  customer: string;
  /**
   * Optional. Requested page size. Server might return fewer results than
   * requested. If unspecified, returns at most 100 Offers. The maximum value is
   * 1000; the server will coerce values above 1000.
   */
  pageSize: number;
  /** Optional. A token for a page of results other than the first page. */
  pageToken: string;
  /**
   * Optional. The BCP-47 language code. For example, "en-US". The
   * response will localize in the corresponding language code, if specified.
   * The default value is "en-US".
   */
  languageCode: string;
}

/** List Offers for CreateEntitlement purchase. */
export interface ListPurchasableOffersRequest_CreateEntitlementPurchase {
  /**
   * Required. SKU that the result should be restricted to.
   * Format: products/{product_id}/skus/{sku_id}.
   */
  sku: string;
  /**
   * Optional. Billing account that the result should be restricted to.
   * Format: accounts/{account_id}/billingAccounts/{billing_account_id}.
   */
  billingAccount: string;
}

/** List Offers for ChangeOffer purchase. */
export interface ListPurchasableOffersRequest_ChangeOfferPurchase {
  /**
   * Required. Resource name of the entitlement.
   * Format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  entitlement: string;
  /**
   * Optional. Resource name of the new target SKU. Provide this SKU when
   * upgrading or downgrading an entitlement. Format:
   * products/{product_id}/skus/{sku_id}
   */
  newSku: string;
  /**
   * Optional. Resource name of the new target Billing Account. Provide this
   * Billing Account when setting up billing for a trial subscription. Format:
   * accounts/{account_id}/billingAccounts/{billing_account_id}.
   *
   * This field is only relevant for multi-currency accounts. It should be
   * left empty for single currency accounts.
   */
  billingAccount: string;
}

/** Response message for ListPurchasableOffers. */
export interface ListPurchasableOffersResponse {
  /** The list of Offers requested. */
  purchasableOffers: PurchasableOffer[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
}

/**
 * Offer that you can purchase for a customer. This is used in the
 * ListPurchasableOffer API response.
 */
export interface PurchasableOffer {
  /** Offer. */
  offer: Offer | undefined;
}

/** Request message for QueryEligibleBillingAccounts. */
export interface QueryEligibleBillingAccountsRequest {
  /**
   * Required. The resource name of the customer to list eligible billing
   * accounts for. Format: accounts/{account_id}/customers/{customer_id}.
   */
  customer: string;
  /**
   * Required. List of SKUs to list eligible billing accounts for. At least one
   * SKU is required. Format: products/{product_id}/skus/{sku_id}.
   */
  skus: string[];
}

/** Response message for QueryEligibleBillingAccounts. */
export interface QueryEligibleBillingAccountsResponse {
  /**
   * List of SKU purchase groups where each group represents a set of SKUs that
   * must be purchased using the same billing account. Each SKU from
   * [QueryEligibleBillingAccountsRequest.skus] will appear in exactly one SKU
   * group.
   */
  skuPurchaseGroups: SkuPurchaseGroup[];
}

/**
 * Represents a set of SKUs that must be purchased using the same billing
 * account.
 */
export interface SkuPurchaseGroup {
  /**
   * Resource names of the SKUs included in this group.
   * Format: products/{product_id}/skus/{sku_id}.
   */
  skus: string[];
  /** List of billing accounts that are eligible to purhcase these SKUs. */
  billingAccountPurchaseInfos: BillingAccountPurchaseInfo[];
}

/** Represents a billing account that can be used to make a purchase. */
export interface BillingAccountPurchaseInfo {
  /** The billing account resource. */
  billingAccount: BillingAccount | undefined;
}

/** Request Message for RegisterSubscriber. */
export interface RegisterSubscriberRequest {
  /** Required. Resource name of the account. */
  account: string;
  /**
   * Required. Service account that provides subscriber access to the registered
   * topic.
   */
  serviceAccount: string;
}

/** Response Message for RegisterSubscriber. */
export interface RegisterSubscriberResponse {
  /** Name of the topic the subscriber will listen to. */
  topic: string;
}

/** Request Message for UnregisterSubscriber. */
export interface UnregisterSubscriberRequest {
  /** Required. Resource name of the account. */
  account: string;
  /**
   * Required. Service account to unregister from subscriber access to the
   * topic.
   */
  serviceAccount: string;
}

/** Response Message for UnregisterSubscriber. */
export interface UnregisterSubscriberResponse {
  /** Name of the topic the service account subscriber access was removed from. */
  topic: string;
}

/** Request Message for ListSubscribers. */
export interface ListSubscribersRequest {
  /** Required. Resource name of the account. */
  account: string;
  /**
   * Optional. The maximum number of service accounts to return. The service may
   * return fewer than this value. If unspecified, returns at most 100 service
   * accounts. The maximum value is 1000; the server will coerce values above
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListSubscribers` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSubscribers` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response Message for ListSubscribers. */
export interface ListSubscribersResponse {
  /** Name of the topic registered with the reseller. */
  topic: string;
  /** List of service accounts which have subscriber access to the topic. */
  serviceAccounts: string[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelService.ListEntitlementChanges][google.cloud.channel.v1.CloudChannelService.ListEntitlementChanges]
 */
export interface ListEntitlementChangesRequest {
  /**
   * Required. The resource name of the entitlement for which to list
   * entitlement changes. The `-` wildcard may be used to match entitlements
   * across a customer. Formats:
   *
   *   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   *   * accounts/{account_id}/customers/{customer_id}/entitlements/-
   */
  parent: string;
  /**
   * Optional. The maximum number of entitlement changes to return. The service
   * may return fewer than this value. If unspecified, returns at most 10
   * entitlement changes. The maximum value is 50; the server will coerce values
   * above 50.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * [CloudChannelService.ListEntitlementChanges][google.cloud.channel.v1.CloudChannelService.ListEntitlementChanges]
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * [CloudChannelService.ListEntitlementChanges][google.cloud.channel.v1.CloudChannelService.ListEntitlementChanges]
   * must match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. Filters applied to the list results. */
  filter: string;
}

/**
 * Response message for
 * [CloudChannelService.ListEntitlementChanges][google.cloud.channel.v1.CloudChannelService.ListEntitlementChanges]
 */
export interface ListEntitlementChangesResponse {
  /** The list of entitlement changes. */
  entitlementChanges: EntitlementChange[];
  /** A token to list the next page of results. */
  nextPageToken: string;
}

function createBaseCheckCloudIdentityAccountsExistRequest(): CheckCloudIdentityAccountsExistRequest {
  return { parent: "", domain: "" };
}

export const CheckCloudIdentityAccountsExistRequest: MessageFns<CheckCloudIdentityAccountsExistRequest> = {
  encode(message: CheckCloudIdentityAccountsExistRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.domain !== "") {
      writer.uint32(18).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckCloudIdentityAccountsExistRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckCloudIdentityAccountsExistRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckCloudIdentityAccountsExistRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
    };
  },

  toJSON(message: CheckCloudIdentityAccountsExistRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckCloudIdentityAccountsExistRequest>): CheckCloudIdentityAccountsExistRequest {
    return CheckCloudIdentityAccountsExistRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckCloudIdentityAccountsExistRequest>): CheckCloudIdentityAccountsExistRequest {
    const message = createBaseCheckCloudIdentityAccountsExistRequest();
    message.parent = object.parent ?? "";
    message.domain = object.domain ?? "";
    return message;
  },
};

function createBaseCloudIdentityCustomerAccount(): CloudIdentityCustomerAccount {
  return { existing: false, owned: false, customerName: "", customerCloudIdentityId: "" };
}

export const CloudIdentityCustomerAccount: MessageFns<CloudIdentityCustomerAccount> = {
  encode(message: CloudIdentityCustomerAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.existing !== false) {
      writer.uint32(8).bool(message.existing);
    }
    if (message.owned !== false) {
      writer.uint32(16).bool(message.owned);
    }
    if (message.customerName !== "") {
      writer.uint32(26).string(message.customerName);
    }
    if (message.customerCloudIdentityId !== "") {
      writer.uint32(34).string(message.customerCloudIdentityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudIdentityCustomerAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudIdentityCustomerAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.existing = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.owned = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerCloudIdentityId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudIdentityCustomerAccount {
    return {
      existing: isSet(object.existing) ? globalThis.Boolean(object.existing) : false,
      owned: isSet(object.owned) ? globalThis.Boolean(object.owned) : false,
      customerName: isSet(object.customerName) ? globalThis.String(object.customerName) : "",
      customerCloudIdentityId: isSet(object.customerCloudIdentityId)
        ? globalThis.String(object.customerCloudIdentityId)
        : "",
    };
  },

  toJSON(message: CloudIdentityCustomerAccount): unknown {
    const obj: any = {};
    if (message.existing !== false) {
      obj.existing = message.existing;
    }
    if (message.owned !== false) {
      obj.owned = message.owned;
    }
    if (message.customerName !== "") {
      obj.customerName = message.customerName;
    }
    if (message.customerCloudIdentityId !== "") {
      obj.customerCloudIdentityId = message.customerCloudIdentityId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudIdentityCustomerAccount>): CloudIdentityCustomerAccount {
    return CloudIdentityCustomerAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudIdentityCustomerAccount>): CloudIdentityCustomerAccount {
    const message = createBaseCloudIdentityCustomerAccount();
    message.existing = object.existing ?? false;
    message.owned = object.owned ?? false;
    message.customerName = object.customerName ?? "";
    message.customerCloudIdentityId = object.customerCloudIdentityId ?? "";
    return message;
  },
};

function createBaseCheckCloudIdentityAccountsExistResponse(): CheckCloudIdentityAccountsExistResponse {
  return { cloudIdentityAccounts: [] };
}

export const CheckCloudIdentityAccountsExistResponse: MessageFns<CheckCloudIdentityAccountsExistResponse> = {
  encode(message: CheckCloudIdentityAccountsExistResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cloudIdentityAccounts) {
      CloudIdentityCustomerAccount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckCloudIdentityAccountsExistResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckCloudIdentityAccountsExistResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudIdentityAccounts.push(CloudIdentityCustomerAccount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckCloudIdentityAccountsExistResponse {
    return {
      cloudIdentityAccounts: globalThis.Array.isArray(object?.cloudIdentityAccounts)
        ? object.cloudIdentityAccounts.map((e: any) => CloudIdentityCustomerAccount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CheckCloudIdentityAccountsExistResponse): unknown {
    const obj: any = {};
    if (message.cloudIdentityAccounts?.length) {
      obj.cloudIdentityAccounts = message.cloudIdentityAccounts.map((e) => CloudIdentityCustomerAccount.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CheckCloudIdentityAccountsExistResponse>): CheckCloudIdentityAccountsExistResponse {
    return CheckCloudIdentityAccountsExistResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckCloudIdentityAccountsExistResponse>): CheckCloudIdentityAccountsExistResponse {
    const message = createBaseCheckCloudIdentityAccountsExistResponse();
    message.cloudIdentityAccounts =
      object.cloudIdentityAccounts?.map((e) => CloudIdentityCustomerAccount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListCustomersRequest(): ListCustomersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListCustomersRequest: MessageFns<ListCustomersRequest> = {
  encode(message: ListCustomersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListCustomersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomersRequest>): ListCustomersRequest {
    return ListCustomersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomersRequest>): ListCustomersRequest {
    const message = createBaseListCustomersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListCustomersResponse(): ListCustomersResponse {
  return { customers: [], nextPageToken: "" };
}

export const ListCustomersResponse: MessageFns<ListCustomersResponse> = {
  encode(message: ListCustomersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.customers) {
      Customer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customers.push(Customer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomersResponse {
    return {
      customers: globalThis.Array.isArray(object?.customers)
        ? object.customers.map((e: any) => Customer.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCustomersResponse): unknown {
    const obj: any = {};
    if (message.customers?.length) {
      obj.customers = message.customers.map((e) => Customer.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomersResponse>): ListCustomersResponse {
    return ListCustomersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomersResponse>): ListCustomersResponse {
    const message = createBaseListCustomersResponse();
    message.customers = object.customers?.map((e) => Customer.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetCustomerRequest(): GetCustomerRequest {
  return { name: "" };
}

export const GetCustomerRequest: MessageFns<GetCustomerRequest> = {
  encode(message: GetCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomerRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCustomerRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCustomerRequest>): GetCustomerRequest {
    return GetCustomerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCustomerRequest>): GetCustomerRequest {
    const message = createBaseGetCustomerRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateCustomerRequest(): CreateCustomerRequest {
  return { parent: "", customer: undefined };
}

export const CreateCustomerRequest: MessageFns<CreateCustomerRequest> = {
  encode(message: CreateCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.customer !== undefined) {
      Customer.encode(message.customer, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customer = Customer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomerRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      customer: isSet(object.customer) ? Customer.fromJSON(object.customer) : undefined,
    };
  },

  toJSON(message: CreateCustomerRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.customer !== undefined) {
      obj.customer = Customer.toJSON(message.customer);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCustomerRequest>): CreateCustomerRequest {
    return CreateCustomerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCustomerRequest>): CreateCustomerRequest {
    const message = createBaseCreateCustomerRequest();
    message.parent = object.parent ?? "";
    message.customer = (object.customer !== undefined && object.customer !== null)
      ? Customer.fromPartial(object.customer)
      : undefined;
    return message;
  },
};

function createBaseUpdateCustomerRequest(): UpdateCustomerRequest {
  return { customer: undefined, updateMask: undefined };
}

export const UpdateCustomerRequest: MessageFns<UpdateCustomerRequest> = {
  encode(message: UpdateCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customer !== undefined) {
      Customer.encode(message.customer, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customer = Customer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustomerRequest {
    return {
      customer: isSet(object.customer) ? Customer.fromJSON(object.customer) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCustomerRequest): unknown {
    const obj: any = {};
    if (message.customer !== undefined) {
      obj.customer = Customer.toJSON(message.customer);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCustomerRequest>): UpdateCustomerRequest {
    return UpdateCustomerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCustomerRequest>): UpdateCustomerRequest {
    const message = createBaseUpdateCustomerRequest();
    message.customer = (object.customer !== undefined && object.customer !== null)
      ? Customer.fromPartial(object.customer)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCustomerRequest(): DeleteCustomerRequest {
  return { name: "" };
}

export const DeleteCustomerRequest: MessageFns<DeleteCustomerRequest> = {
  encode(message: DeleteCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCustomerRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCustomerRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCustomerRequest>): DeleteCustomerRequest {
    return DeleteCustomerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCustomerRequest>): DeleteCustomerRequest {
    const message = createBaseDeleteCustomerRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseImportCustomerRequest(): ImportCustomerRequest {
  return {
    domain: undefined,
    cloudIdentityId: undefined,
    parent: "",
    authToken: "",
    overwriteIfExists: false,
    channelPartnerId: "",
    customer: "",
  };
}

export const ImportCustomerRequest: MessageFns<ImportCustomerRequest> = {
  encode(message: ImportCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== undefined) {
      writer.uint32(18).string(message.domain);
    }
    if (message.cloudIdentityId !== undefined) {
      writer.uint32(26).string(message.cloudIdentityId);
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.authToken !== "") {
      writer.uint32(34).string(message.authToken);
    }
    if (message.overwriteIfExists !== false) {
      writer.uint32(40).bool(message.overwriteIfExists);
    }
    if (message.channelPartnerId !== "") {
      writer.uint32(50).string(message.channelPartnerId);
    }
    if (message.customer !== "") {
      writer.uint32(58).string(message.customer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudIdentityId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authToken = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.overwriteIfExists = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channelPartnerId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportCustomerRequest {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : undefined,
      cloudIdentityId: isSet(object.cloudIdentityId) ? globalThis.String(object.cloudIdentityId) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      authToken: isSet(object.authToken) ? globalThis.String(object.authToken) : "",
      overwriteIfExists: isSet(object.overwriteIfExists) ? globalThis.Boolean(object.overwriteIfExists) : false,
      channelPartnerId: isSet(object.channelPartnerId) ? globalThis.String(object.channelPartnerId) : "",
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
    };
  },

  toJSON(message: ImportCustomerRequest): unknown {
    const obj: any = {};
    if (message.domain !== undefined) {
      obj.domain = message.domain;
    }
    if (message.cloudIdentityId !== undefined) {
      obj.cloudIdentityId = message.cloudIdentityId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.overwriteIfExists !== false) {
      obj.overwriteIfExists = message.overwriteIfExists;
    }
    if (message.channelPartnerId !== "") {
      obj.channelPartnerId = message.channelPartnerId;
    }
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportCustomerRequest>): ImportCustomerRequest {
    return ImportCustomerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportCustomerRequest>): ImportCustomerRequest {
    const message = createBaseImportCustomerRequest();
    message.domain = object.domain ?? undefined;
    message.cloudIdentityId = object.cloudIdentityId ?? undefined;
    message.parent = object.parent ?? "";
    message.authToken = object.authToken ?? "";
    message.overwriteIfExists = object.overwriteIfExists ?? false;
    message.channelPartnerId = object.channelPartnerId ?? "";
    message.customer = object.customer ?? "";
    return message;
  },
};

function createBaseProvisionCloudIdentityRequest(): ProvisionCloudIdentityRequest {
  return { customer: "", cloudIdentityInfo: undefined, user: undefined, validateOnly: false };
}

export const ProvisionCloudIdentityRequest: MessageFns<ProvisionCloudIdentityRequest> = {
  encode(message: ProvisionCloudIdentityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customer !== "") {
      writer.uint32(10).string(message.customer);
    }
    if (message.cloudIdentityInfo !== undefined) {
      CloudIdentityInfo.encode(message.cloudIdentityInfo, writer.uint32(18).fork()).join();
    }
    if (message.user !== undefined) {
      AdminUser.encode(message.user, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvisionCloudIdentityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvisionCloudIdentityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudIdentityInfo = CloudIdentityInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user = AdminUser.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvisionCloudIdentityRequest {
    return {
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
      cloudIdentityInfo: isSet(object.cloudIdentityInfo)
        ? CloudIdentityInfo.fromJSON(object.cloudIdentityInfo)
        : undefined,
      user: isSet(object.user) ? AdminUser.fromJSON(object.user) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: ProvisionCloudIdentityRequest): unknown {
    const obj: any = {};
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.cloudIdentityInfo !== undefined) {
      obj.cloudIdentityInfo = CloudIdentityInfo.toJSON(message.cloudIdentityInfo);
    }
    if (message.user !== undefined) {
      obj.user = AdminUser.toJSON(message.user);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<ProvisionCloudIdentityRequest>): ProvisionCloudIdentityRequest {
    return ProvisionCloudIdentityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvisionCloudIdentityRequest>): ProvisionCloudIdentityRequest {
    const message = createBaseProvisionCloudIdentityRequest();
    message.customer = object.customer ?? "";
    message.cloudIdentityInfo = (object.cloudIdentityInfo !== undefined && object.cloudIdentityInfo !== null)
      ? CloudIdentityInfo.fromPartial(object.cloudIdentityInfo)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? AdminUser.fromPartial(object.user) : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseListEntitlementsRequest(): ListEntitlementsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListEntitlementsRequest: MessageFns<ListEntitlementsRequest> = {
  encode(message: ListEntitlementsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitlementsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitlementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitlementsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListEntitlementsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitlementsRequest>): ListEntitlementsRequest {
    return ListEntitlementsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitlementsRequest>): ListEntitlementsRequest {
    const message = createBaseListEntitlementsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListEntitlementsResponse(): ListEntitlementsResponse {
  return { entitlements: [], nextPageToken: "" };
}

export const ListEntitlementsResponse: MessageFns<ListEntitlementsResponse> = {
  encode(message: ListEntitlementsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entitlements) {
      Entitlement.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitlementsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitlementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlements.push(Entitlement.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitlementsResponse {
    return {
      entitlements: globalThis.Array.isArray(object?.entitlements)
        ? object.entitlements.map((e: any) => Entitlement.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEntitlementsResponse): unknown {
    const obj: any = {};
    if (message.entitlements?.length) {
      obj.entitlements = message.entitlements.map((e) => Entitlement.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitlementsResponse>): ListEntitlementsResponse {
    return ListEntitlementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitlementsResponse>): ListEntitlementsResponse {
    const message = createBaseListEntitlementsResponse();
    message.entitlements = object.entitlements?.map((e) => Entitlement.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListTransferableSkusRequest(): ListTransferableSkusRequest {
  return {
    cloudIdentityId: undefined,
    customerName: undefined,
    parent: "",
    pageSize: 0,
    pageToken: "",
    authToken: "",
    languageCode: "",
  };
}

export const ListTransferableSkusRequest: MessageFns<ListTransferableSkusRequest> = {
  encode(message: ListTransferableSkusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudIdentityId !== undefined) {
      writer.uint32(34).string(message.cloudIdentityId);
    }
    if (message.customerName !== undefined) {
      writer.uint32(58).string(message.customerName);
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.authToken !== "") {
      writer.uint32(42).string(message.authToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransferableSkusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransferableSkusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudIdentityId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customerName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransferableSkusRequest {
    return {
      cloudIdentityId: isSet(object.cloudIdentityId) ? globalThis.String(object.cloudIdentityId) : undefined,
      customerName: isSet(object.customerName) ? globalThis.String(object.customerName) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      authToken: isSet(object.authToken) ? globalThis.String(object.authToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListTransferableSkusRequest): unknown {
    const obj: any = {};
    if (message.cloudIdentityId !== undefined) {
      obj.cloudIdentityId = message.cloudIdentityId;
    }
    if (message.customerName !== undefined) {
      obj.customerName = message.customerName;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransferableSkusRequest>): ListTransferableSkusRequest {
    return ListTransferableSkusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransferableSkusRequest>): ListTransferableSkusRequest {
    const message = createBaseListTransferableSkusRequest();
    message.cloudIdentityId = object.cloudIdentityId ?? undefined;
    message.customerName = object.customerName ?? undefined;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.authToken = object.authToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListTransferableSkusResponse(): ListTransferableSkusResponse {
  return { transferableSkus: [], nextPageToken: "" };
}

export const ListTransferableSkusResponse: MessageFns<ListTransferableSkusResponse> = {
  encode(message: ListTransferableSkusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transferableSkus) {
      TransferableSku.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransferableSkusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransferableSkusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transferableSkus.push(TransferableSku.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransferableSkusResponse {
    return {
      transferableSkus: globalThis.Array.isArray(object?.transferableSkus)
        ? object.transferableSkus.map((e: any) => TransferableSku.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTransferableSkusResponse): unknown {
    const obj: any = {};
    if (message.transferableSkus?.length) {
      obj.transferableSkus = message.transferableSkus.map((e) => TransferableSku.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransferableSkusResponse>): ListTransferableSkusResponse {
    return ListTransferableSkusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransferableSkusResponse>): ListTransferableSkusResponse {
    const message = createBaseListTransferableSkusResponse();
    message.transferableSkus = object.transferableSkus?.map((e) => TransferableSku.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListTransferableOffersRequest(): ListTransferableOffersRequest {
  return {
    cloudIdentityId: undefined,
    customerName: undefined,
    parent: "",
    pageSize: 0,
    pageToken: "",
    sku: "",
    languageCode: "",
    billingAccount: "",
  };
}

export const ListTransferableOffersRequest: MessageFns<ListTransferableOffersRequest> = {
  encode(message: ListTransferableOffersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudIdentityId !== undefined) {
      writer.uint32(34).string(message.cloudIdentityId);
    }
    if (message.customerName !== undefined) {
      writer.uint32(42).string(message.customerName);
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.sku !== "") {
      writer.uint32(50).string(message.sku);
    }
    if (message.languageCode !== "") {
      writer.uint32(58).string(message.languageCode);
    }
    if (message.billingAccount !== "") {
      writer.uint32(66).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransferableOffersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransferableOffersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudIdentityId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customerName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sku = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransferableOffersRequest {
    return {
      cloudIdentityId: isSet(object.cloudIdentityId) ? globalThis.String(object.cloudIdentityId) : undefined,
      customerName: isSet(object.customerName) ? globalThis.String(object.customerName) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: ListTransferableOffersRequest): unknown {
    const obj: any = {};
    if (message.cloudIdentityId !== undefined) {
      obj.cloudIdentityId = message.cloudIdentityId;
    }
    if (message.customerName !== undefined) {
      obj.customerName = message.customerName;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransferableOffersRequest>): ListTransferableOffersRequest {
    return ListTransferableOffersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransferableOffersRequest>): ListTransferableOffersRequest {
    const message = createBaseListTransferableOffersRequest();
    message.cloudIdentityId = object.cloudIdentityId ?? undefined;
    message.customerName = object.customerName ?? undefined;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.sku = object.sku ?? "";
    message.languageCode = object.languageCode ?? "";
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBaseListTransferableOffersResponse(): ListTransferableOffersResponse {
  return { transferableOffers: [], nextPageToken: "" };
}

export const ListTransferableOffersResponse: MessageFns<ListTransferableOffersResponse> = {
  encode(message: ListTransferableOffersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transferableOffers) {
      TransferableOffer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransferableOffersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransferableOffersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transferableOffers.push(TransferableOffer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransferableOffersResponse {
    return {
      transferableOffers: globalThis.Array.isArray(object?.transferableOffers)
        ? object.transferableOffers.map((e: any) => TransferableOffer.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTransferableOffersResponse): unknown {
    const obj: any = {};
    if (message.transferableOffers?.length) {
      obj.transferableOffers = message.transferableOffers.map((e) => TransferableOffer.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTransferableOffersResponse>): ListTransferableOffersResponse {
    return ListTransferableOffersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTransferableOffersResponse>): ListTransferableOffersResponse {
    const message = createBaseListTransferableOffersResponse();
    message.transferableOffers = object.transferableOffers?.map((e) => TransferableOffer.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseTransferableOffer(): TransferableOffer {
  return { offer: undefined };
}

export const TransferableOffer: MessageFns<TransferableOffer> = {
  encode(message: TransferableOffer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offer !== undefined) {
      Offer.encode(message.offer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferableOffer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferableOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offer = Offer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferableOffer {
    return { offer: isSet(object.offer) ? Offer.fromJSON(object.offer) : undefined };
  },

  toJSON(message: TransferableOffer): unknown {
    const obj: any = {};
    if (message.offer !== undefined) {
      obj.offer = Offer.toJSON(message.offer);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferableOffer>): TransferableOffer {
    return TransferableOffer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferableOffer>): TransferableOffer {
    const message = createBaseTransferableOffer();
    message.offer = (object.offer !== undefined && object.offer !== null) ? Offer.fromPartial(object.offer) : undefined;
    return message;
  },
};

function createBaseGetEntitlementRequest(): GetEntitlementRequest {
  return { name: "" };
}

export const GetEntitlementRequest: MessageFns<GetEntitlementRequest> = {
  encode(message: GetEntitlementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEntitlementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntitlementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEntitlementRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEntitlementRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEntitlementRequest>): GetEntitlementRequest {
    return GetEntitlementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEntitlementRequest>): GetEntitlementRequest {
    const message = createBaseGetEntitlementRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListChannelPartnerLinksRequest(): ListChannelPartnerLinksRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0 };
}

export const ListChannelPartnerLinksRequest: MessageFns<ListChannelPartnerLinksRequest> = {
  encode(message: ListChannelPartnerLinksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelPartnerLinksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelPartnerLinksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelPartnerLinksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? channelPartnerLinkViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListChannelPartnerLinksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = channelPartnerLinkViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelPartnerLinksRequest>): ListChannelPartnerLinksRequest {
    return ListChannelPartnerLinksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelPartnerLinksRequest>): ListChannelPartnerLinksRequest {
    const message = createBaseListChannelPartnerLinksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListChannelPartnerLinksResponse(): ListChannelPartnerLinksResponse {
  return { channelPartnerLinks: [], nextPageToken: "" };
}

export const ListChannelPartnerLinksResponse: MessageFns<ListChannelPartnerLinksResponse> = {
  encode(message: ListChannelPartnerLinksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channelPartnerLinks) {
      ChannelPartnerLink.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelPartnerLinksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelPartnerLinksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelPartnerLinks.push(ChannelPartnerLink.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelPartnerLinksResponse {
    return {
      channelPartnerLinks: globalThis.Array.isArray(object?.channelPartnerLinks)
        ? object.channelPartnerLinks.map((e: any) => ChannelPartnerLink.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChannelPartnerLinksResponse): unknown {
    const obj: any = {};
    if (message.channelPartnerLinks?.length) {
      obj.channelPartnerLinks = message.channelPartnerLinks.map((e) => ChannelPartnerLink.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelPartnerLinksResponse>): ListChannelPartnerLinksResponse {
    return ListChannelPartnerLinksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelPartnerLinksResponse>): ListChannelPartnerLinksResponse {
    const message = createBaseListChannelPartnerLinksResponse();
    message.channelPartnerLinks = object.channelPartnerLinks?.map((e) => ChannelPartnerLink.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetChannelPartnerLinkRequest(): GetChannelPartnerLinkRequest {
  return { name: "", view: 0 };
}

export const GetChannelPartnerLinkRequest: MessageFns<GetChannelPartnerLinkRequest> = {
  encode(message: GetChannelPartnerLinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelPartnerLinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelPartnerLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelPartnerLinkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? channelPartnerLinkViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetChannelPartnerLinkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = channelPartnerLinkViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetChannelPartnerLinkRequest>): GetChannelPartnerLinkRequest {
    return GetChannelPartnerLinkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChannelPartnerLinkRequest>): GetChannelPartnerLinkRequest {
    const message = createBaseGetChannelPartnerLinkRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseCreateChannelPartnerLinkRequest(): CreateChannelPartnerLinkRequest {
  return { parent: "", channelPartnerLink: undefined };
}

export const CreateChannelPartnerLinkRequest: MessageFns<CreateChannelPartnerLinkRequest> = {
  encode(message: CreateChannelPartnerLinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.channelPartnerLink !== undefined) {
      ChannelPartnerLink.encode(message.channelPartnerLink, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChannelPartnerLinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelPartnerLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channelPartnerLink = ChannelPartnerLink.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChannelPartnerLinkRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      channelPartnerLink: isSet(object.channelPartnerLink)
        ? ChannelPartnerLink.fromJSON(object.channelPartnerLink)
        : undefined,
    };
  },

  toJSON(message: CreateChannelPartnerLinkRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.channelPartnerLink !== undefined) {
      obj.channelPartnerLink = ChannelPartnerLink.toJSON(message.channelPartnerLink);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateChannelPartnerLinkRequest>): CreateChannelPartnerLinkRequest {
    return CreateChannelPartnerLinkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateChannelPartnerLinkRequest>): CreateChannelPartnerLinkRequest {
    const message = createBaseCreateChannelPartnerLinkRequest();
    message.parent = object.parent ?? "";
    message.channelPartnerLink = (object.channelPartnerLink !== undefined && object.channelPartnerLink !== null)
      ? ChannelPartnerLink.fromPartial(object.channelPartnerLink)
      : undefined;
    return message;
  },
};

function createBaseUpdateChannelPartnerLinkRequest(): UpdateChannelPartnerLinkRequest {
  return { name: "", channelPartnerLink: undefined, updateMask: undefined };
}

export const UpdateChannelPartnerLinkRequest: MessageFns<UpdateChannelPartnerLinkRequest> = {
  encode(message: UpdateChannelPartnerLinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.channelPartnerLink !== undefined) {
      ChannelPartnerLink.encode(message.channelPartnerLink, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChannelPartnerLinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChannelPartnerLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channelPartnerLink = ChannelPartnerLink.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChannelPartnerLinkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      channelPartnerLink: isSet(object.channelPartnerLink)
        ? ChannelPartnerLink.fromJSON(object.channelPartnerLink)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateChannelPartnerLinkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.channelPartnerLink !== undefined) {
      obj.channelPartnerLink = ChannelPartnerLink.toJSON(message.channelPartnerLink);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateChannelPartnerLinkRequest>): UpdateChannelPartnerLinkRequest {
    return UpdateChannelPartnerLinkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateChannelPartnerLinkRequest>): UpdateChannelPartnerLinkRequest {
    const message = createBaseUpdateChannelPartnerLinkRequest();
    message.name = object.name ?? "";
    message.channelPartnerLink = (object.channelPartnerLink !== undefined && object.channelPartnerLink !== null)
      ? ChannelPartnerLink.fromPartial(object.channelPartnerLink)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetCustomerRepricingConfigRequest(): GetCustomerRepricingConfigRequest {
  return { name: "" };
}

export const GetCustomerRepricingConfigRequest: MessageFns<GetCustomerRepricingConfigRequest> = {
  encode(message: GetCustomerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomerRepricingConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCustomerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCustomerRepricingConfigRequest>): GetCustomerRepricingConfigRequest {
    return GetCustomerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCustomerRepricingConfigRequest>): GetCustomerRepricingConfigRequest {
    const message = createBaseGetCustomerRepricingConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListCustomerRepricingConfigsRequest(): ListCustomerRepricingConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListCustomerRepricingConfigsRequest: MessageFns<ListCustomerRepricingConfigsRequest> = {
  encode(message: ListCustomerRepricingConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomerRepricingConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomerRepricingConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomerRepricingConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListCustomerRepricingConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomerRepricingConfigsRequest>): ListCustomerRepricingConfigsRequest {
    return ListCustomerRepricingConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomerRepricingConfigsRequest>): ListCustomerRepricingConfigsRequest {
    const message = createBaseListCustomerRepricingConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListCustomerRepricingConfigsResponse(): ListCustomerRepricingConfigsResponse {
  return { customerRepricingConfigs: [], nextPageToken: "" };
}

export const ListCustomerRepricingConfigsResponse: MessageFns<ListCustomerRepricingConfigsResponse> = {
  encode(message: ListCustomerRepricingConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.customerRepricingConfigs) {
      CustomerRepricingConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomerRepricingConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomerRepricingConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerRepricingConfigs.push(CustomerRepricingConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomerRepricingConfigsResponse {
    return {
      customerRepricingConfigs: globalThis.Array.isArray(object?.customerRepricingConfigs)
        ? object.customerRepricingConfigs.map((e: any) => CustomerRepricingConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCustomerRepricingConfigsResponse): unknown {
    const obj: any = {};
    if (message.customerRepricingConfigs?.length) {
      obj.customerRepricingConfigs = message.customerRepricingConfigs.map((e) => CustomerRepricingConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomerRepricingConfigsResponse>): ListCustomerRepricingConfigsResponse {
    return ListCustomerRepricingConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomerRepricingConfigsResponse>): ListCustomerRepricingConfigsResponse {
    const message = createBaseListCustomerRepricingConfigsResponse();
    message.customerRepricingConfigs =
      object.customerRepricingConfigs?.map((e) => CustomerRepricingConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateCustomerRepricingConfigRequest(): CreateCustomerRepricingConfigRequest {
  return { parent: "", customerRepricingConfig: undefined };
}

export const CreateCustomerRepricingConfigRequest: MessageFns<CreateCustomerRepricingConfigRequest> = {
  encode(message: CreateCustomerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.customerRepricingConfig !== undefined) {
      CustomerRepricingConfig.encode(message.customerRepricingConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerRepricingConfig = CustomerRepricingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomerRepricingConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      customerRepricingConfig: isSet(object.customerRepricingConfig)
        ? CustomerRepricingConfig.fromJSON(object.customerRepricingConfig)
        : undefined,
    };
  },

  toJSON(message: CreateCustomerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.customerRepricingConfig !== undefined) {
      obj.customerRepricingConfig = CustomerRepricingConfig.toJSON(message.customerRepricingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCustomerRepricingConfigRequest>): CreateCustomerRepricingConfigRequest {
    return CreateCustomerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCustomerRepricingConfigRequest>): CreateCustomerRepricingConfigRequest {
    const message = createBaseCreateCustomerRepricingConfigRequest();
    message.parent = object.parent ?? "";
    message.customerRepricingConfig =
      (object.customerRepricingConfig !== undefined && object.customerRepricingConfig !== null)
        ? CustomerRepricingConfig.fromPartial(object.customerRepricingConfig)
        : undefined;
    return message;
  },
};

function createBaseUpdateCustomerRepricingConfigRequest(): UpdateCustomerRepricingConfigRequest {
  return { customerRepricingConfig: undefined };
}

export const UpdateCustomerRepricingConfigRequest: MessageFns<UpdateCustomerRepricingConfigRequest> = {
  encode(message: UpdateCustomerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerRepricingConfig !== undefined) {
      CustomerRepricingConfig.encode(message.customerRepricingConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCustomerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustomerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerRepricingConfig = CustomerRepricingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustomerRepricingConfigRequest {
    return {
      customerRepricingConfig: isSet(object.customerRepricingConfig)
        ? CustomerRepricingConfig.fromJSON(object.customerRepricingConfig)
        : undefined,
    };
  },

  toJSON(message: UpdateCustomerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.customerRepricingConfig !== undefined) {
      obj.customerRepricingConfig = CustomerRepricingConfig.toJSON(message.customerRepricingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCustomerRepricingConfigRequest>): UpdateCustomerRepricingConfigRequest {
    return UpdateCustomerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCustomerRepricingConfigRequest>): UpdateCustomerRepricingConfigRequest {
    const message = createBaseUpdateCustomerRepricingConfigRequest();
    message.customerRepricingConfig =
      (object.customerRepricingConfig !== undefined && object.customerRepricingConfig !== null)
        ? CustomerRepricingConfig.fromPartial(object.customerRepricingConfig)
        : undefined;
    return message;
  },
};

function createBaseDeleteCustomerRepricingConfigRequest(): DeleteCustomerRepricingConfigRequest {
  return { name: "" };
}

export const DeleteCustomerRepricingConfigRequest: MessageFns<DeleteCustomerRepricingConfigRequest> = {
  encode(message: DeleteCustomerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCustomerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCustomerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCustomerRepricingConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCustomerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCustomerRepricingConfigRequest>): DeleteCustomerRepricingConfigRequest {
    return DeleteCustomerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCustomerRepricingConfigRequest>): DeleteCustomerRepricingConfigRequest {
    const message = createBaseDeleteCustomerRepricingConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetChannelPartnerRepricingConfigRequest(): GetChannelPartnerRepricingConfigRequest {
  return { name: "" };
}

export const GetChannelPartnerRepricingConfigRequest: MessageFns<GetChannelPartnerRepricingConfigRequest> = {
  encode(message: GetChannelPartnerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelPartnerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelPartnerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelPartnerRepricingConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetChannelPartnerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChannelPartnerRepricingConfigRequest>): GetChannelPartnerRepricingConfigRequest {
    return GetChannelPartnerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChannelPartnerRepricingConfigRequest>): GetChannelPartnerRepricingConfigRequest {
    const message = createBaseGetChannelPartnerRepricingConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListChannelPartnerRepricingConfigsRequest(): ListChannelPartnerRepricingConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListChannelPartnerRepricingConfigsRequest: MessageFns<ListChannelPartnerRepricingConfigsRequest> = {
  encode(message: ListChannelPartnerRepricingConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelPartnerRepricingConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelPartnerRepricingConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelPartnerRepricingConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListChannelPartnerRepricingConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelPartnerRepricingConfigsRequest>): ListChannelPartnerRepricingConfigsRequest {
    return ListChannelPartnerRepricingConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListChannelPartnerRepricingConfigsRequest>,
  ): ListChannelPartnerRepricingConfigsRequest {
    const message = createBaseListChannelPartnerRepricingConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListChannelPartnerRepricingConfigsResponse(): ListChannelPartnerRepricingConfigsResponse {
  return { channelPartnerRepricingConfigs: [], nextPageToken: "" };
}

export const ListChannelPartnerRepricingConfigsResponse: MessageFns<ListChannelPartnerRepricingConfigsResponse> = {
  encode(message: ListChannelPartnerRepricingConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channelPartnerRepricingConfigs) {
      ChannelPartnerRepricingConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelPartnerRepricingConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelPartnerRepricingConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelPartnerRepricingConfigs.push(ChannelPartnerRepricingConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelPartnerRepricingConfigsResponse {
    return {
      channelPartnerRepricingConfigs: globalThis.Array.isArray(object?.channelPartnerRepricingConfigs)
        ? object.channelPartnerRepricingConfigs.map((e: any) => ChannelPartnerRepricingConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChannelPartnerRepricingConfigsResponse): unknown {
    const obj: any = {};
    if (message.channelPartnerRepricingConfigs?.length) {
      obj.channelPartnerRepricingConfigs = message.channelPartnerRepricingConfigs.map((e) =>
        ChannelPartnerRepricingConfig.toJSON(e)
      );
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelPartnerRepricingConfigsResponse>): ListChannelPartnerRepricingConfigsResponse {
    return ListChannelPartnerRepricingConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListChannelPartnerRepricingConfigsResponse>,
  ): ListChannelPartnerRepricingConfigsResponse {
    const message = createBaseListChannelPartnerRepricingConfigsResponse();
    message.channelPartnerRepricingConfigs =
      object.channelPartnerRepricingConfigs?.map((e) => ChannelPartnerRepricingConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateChannelPartnerRepricingConfigRequest(): CreateChannelPartnerRepricingConfigRequest {
  return { parent: "", channelPartnerRepricingConfig: undefined };
}

export const CreateChannelPartnerRepricingConfigRequest: MessageFns<CreateChannelPartnerRepricingConfigRequest> = {
  encode(message: CreateChannelPartnerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.channelPartnerRepricingConfig !== undefined) {
      ChannelPartnerRepricingConfig.encode(message.channelPartnerRepricingConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChannelPartnerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelPartnerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channelPartnerRepricingConfig = ChannelPartnerRepricingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChannelPartnerRepricingConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      channelPartnerRepricingConfig: isSet(object.channelPartnerRepricingConfig)
        ? ChannelPartnerRepricingConfig.fromJSON(object.channelPartnerRepricingConfig)
        : undefined,
    };
  },

  toJSON(message: CreateChannelPartnerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.channelPartnerRepricingConfig !== undefined) {
      obj.channelPartnerRepricingConfig = ChannelPartnerRepricingConfig.toJSON(message.channelPartnerRepricingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateChannelPartnerRepricingConfigRequest>): CreateChannelPartnerRepricingConfigRequest {
    return CreateChannelPartnerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateChannelPartnerRepricingConfigRequest>,
  ): CreateChannelPartnerRepricingConfigRequest {
    const message = createBaseCreateChannelPartnerRepricingConfigRequest();
    message.parent = object.parent ?? "";
    message.channelPartnerRepricingConfig =
      (object.channelPartnerRepricingConfig !== undefined && object.channelPartnerRepricingConfig !== null)
        ? ChannelPartnerRepricingConfig.fromPartial(object.channelPartnerRepricingConfig)
        : undefined;
    return message;
  },
};

function createBaseUpdateChannelPartnerRepricingConfigRequest(): UpdateChannelPartnerRepricingConfigRequest {
  return { channelPartnerRepricingConfig: undefined };
}

export const UpdateChannelPartnerRepricingConfigRequest: MessageFns<UpdateChannelPartnerRepricingConfigRequest> = {
  encode(message: UpdateChannelPartnerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelPartnerRepricingConfig !== undefined) {
      ChannelPartnerRepricingConfig.encode(message.channelPartnerRepricingConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChannelPartnerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChannelPartnerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelPartnerRepricingConfig = ChannelPartnerRepricingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChannelPartnerRepricingConfigRequest {
    return {
      channelPartnerRepricingConfig: isSet(object.channelPartnerRepricingConfig)
        ? ChannelPartnerRepricingConfig.fromJSON(object.channelPartnerRepricingConfig)
        : undefined,
    };
  },

  toJSON(message: UpdateChannelPartnerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.channelPartnerRepricingConfig !== undefined) {
      obj.channelPartnerRepricingConfig = ChannelPartnerRepricingConfig.toJSON(message.channelPartnerRepricingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateChannelPartnerRepricingConfigRequest>): UpdateChannelPartnerRepricingConfigRequest {
    return UpdateChannelPartnerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UpdateChannelPartnerRepricingConfigRequest>,
  ): UpdateChannelPartnerRepricingConfigRequest {
    const message = createBaseUpdateChannelPartnerRepricingConfigRequest();
    message.channelPartnerRepricingConfig =
      (object.channelPartnerRepricingConfig !== undefined && object.channelPartnerRepricingConfig !== null)
        ? ChannelPartnerRepricingConfig.fromPartial(object.channelPartnerRepricingConfig)
        : undefined;
    return message;
  },
};

function createBaseDeleteChannelPartnerRepricingConfigRequest(): DeleteChannelPartnerRepricingConfigRequest {
  return { name: "" };
}

export const DeleteChannelPartnerRepricingConfigRequest: MessageFns<DeleteChannelPartnerRepricingConfigRequest> = {
  encode(message: DeleteChannelPartnerRepricingConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChannelPartnerRepricingConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelPartnerRepricingConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelPartnerRepricingConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteChannelPartnerRepricingConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteChannelPartnerRepricingConfigRequest>): DeleteChannelPartnerRepricingConfigRequest {
    return DeleteChannelPartnerRepricingConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DeleteChannelPartnerRepricingConfigRequest>,
  ): DeleteChannelPartnerRepricingConfigRequest {
    const message = createBaseDeleteChannelPartnerRepricingConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListSkuGroupsRequest(): ListSkuGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSkuGroupsRequest: MessageFns<ListSkuGroupsRequest> = {
  encode(message: ListSkuGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkuGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkuGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSkuGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkuGroupsRequest>): ListSkuGroupsRequest {
    return ListSkuGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkuGroupsRequest>): ListSkuGroupsRequest {
    const message = createBaseListSkuGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSkuGroupBillableSkusRequest(): ListSkuGroupBillableSkusRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSkuGroupBillableSkusRequest: MessageFns<ListSkuGroupBillableSkusRequest> = {
  encode(message: ListSkuGroupBillableSkusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkuGroupBillableSkusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuGroupBillableSkusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkuGroupBillableSkusRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSkuGroupBillableSkusRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkuGroupBillableSkusRequest>): ListSkuGroupBillableSkusRequest {
    return ListSkuGroupBillableSkusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkuGroupBillableSkusRequest>): ListSkuGroupBillableSkusRequest {
    const message = createBaseListSkuGroupBillableSkusRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSkuGroupsResponse(): ListSkuGroupsResponse {
  return { skuGroups: [], nextPageToken: "" };
}

export const ListSkuGroupsResponse: MessageFns<ListSkuGroupsResponse> = {
  encode(message: ListSkuGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skuGroups) {
      SkuGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkuGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuGroups.push(SkuGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkuGroupsResponse {
    return {
      skuGroups: globalThis.Array.isArray(object?.skuGroups)
        ? object.skuGroups.map((e: any) => SkuGroup.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSkuGroupsResponse): unknown {
    const obj: any = {};
    if (message.skuGroups?.length) {
      obj.skuGroups = message.skuGroups.map((e) => SkuGroup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkuGroupsResponse>): ListSkuGroupsResponse {
    return ListSkuGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkuGroupsResponse>): ListSkuGroupsResponse {
    const message = createBaseListSkuGroupsResponse();
    message.skuGroups = object.skuGroups?.map((e) => SkuGroup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSkuGroupBillableSkusResponse(): ListSkuGroupBillableSkusResponse {
  return { billableSkus: [], nextPageToken: "" };
}

export const ListSkuGroupBillableSkusResponse: MessageFns<ListSkuGroupBillableSkusResponse> = {
  encode(message: ListSkuGroupBillableSkusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.billableSkus) {
      BillableSku.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkuGroupBillableSkusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuGroupBillableSkusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.billableSkus.push(BillableSku.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkuGroupBillableSkusResponse {
    return {
      billableSkus: globalThis.Array.isArray(object?.billableSkus)
        ? object.billableSkus.map((e: any) => BillableSku.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSkuGroupBillableSkusResponse): unknown {
    const obj: any = {};
    if (message.billableSkus?.length) {
      obj.billableSkus = message.billableSkus.map((e) => BillableSku.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkuGroupBillableSkusResponse>): ListSkuGroupBillableSkusResponse {
    return ListSkuGroupBillableSkusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkuGroupBillableSkusResponse>): ListSkuGroupBillableSkusResponse {
    const message = createBaseListSkuGroupBillableSkusResponse();
    message.billableSkus = object.billableSkus?.map((e) => BillableSku.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSkuGroup(): SkuGroup {
  return { name: "", displayName: "" };
}

export const SkuGroup: MessageFns<SkuGroup> = {
  encode(message: SkuGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkuGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkuGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: SkuGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<SkuGroup>): SkuGroup {
    return SkuGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkuGroup>): SkuGroup {
    const message = createBaseSkuGroup();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseBillableSku(): BillableSku {
  return { sku: "", skuDisplayName: "", service: "", serviceDisplayName: "" };
}

export const BillableSku: MessageFns<BillableSku> = {
  encode(message: BillableSku, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sku !== "") {
      writer.uint32(10).string(message.sku);
    }
    if (message.skuDisplayName !== "") {
      writer.uint32(18).string(message.skuDisplayName);
    }
    if (message.service !== "") {
      writer.uint32(26).string(message.service);
    }
    if (message.serviceDisplayName !== "") {
      writer.uint32(34).string(message.serviceDisplayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BillableSku {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillableSku();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sku = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuDisplayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.service = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceDisplayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BillableSku {
    return {
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      skuDisplayName: isSet(object.skuDisplayName) ? globalThis.String(object.skuDisplayName) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      serviceDisplayName: isSet(object.serviceDisplayName) ? globalThis.String(object.serviceDisplayName) : "",
    };
  },

  toJSON(message: BillableSku): unknown {
    const obj: any = {};
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.skuDisplayName !== "") {
      obj.skuDisplayName = message.skuDisplayName;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.serviceDisplayName !== "") {
      obj.serviceDisplayName = message.serviceDisplayName;
    }
    return obj;
  },

  create(base?: DeepPartial<BillableSku>): BillableSku {
    return BillableSku.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BillableSku>): BillableSku {
    const message = createBaseBillableSku();
    message.sku = object.sku ?? "";
    message.skuDisplayName = object.skuDisplayName ?? "";
    message.service = object.service ?? "";
    message.serviceDisplayName = object.serviceDisplayName ?? "";
    return message;
  },
};

function createBaseCreateEntitlementRequest(): CreateEntitlementRequest {
  return { parent: "", entitlement: undefined, requestId: "" };
}

export const CreateEntitlementRequest: MessageFns<CreateEntitlementRequest> = {
  encode(message: CreateEntitlementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entitlement !== undefined) {
      Entitlement.encode(message.entitlement, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEntitlementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEntitlementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entitlement = Entitlement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEntitlementRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entitlement: isSet(object.entitlement) ? Entitlement.fromJSON(object.entitlement) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateEntitlementRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entitlement !== undefined) {
      obj.entitlement = Entitlement.toJSON(message.entitlement);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEntitlementRequest>): CreateEntitlementRequest {
    return CreateEntitlementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEntitlementRequest>): CreateEntitlementRequest {
    const message = createBaseCreateEntitlementRequest();
    message.parent = object.parent ?? "";
    message.entitlement = (object.entitlement !== undefined && object.entitlement !== null)
      ? Entitlement.fromPartial(object.entitlement)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseTransferEntitlementsRequest(): TransferEntitlementsRequest {
  return { parent: "", entitlements: [], authToken: "", requestId: "" };
}

export const TransferEntitlementsRequest: MessageFns<TransferEntitlementsRequest> = {
  encode(message: TransferEntitlementsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.entitlements) {
      Entitlement.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.authToken !== "") {
      writer.uint32(34).string(message.authToken);
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEntitlementsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEntitlementsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entitlements.push(Entitlement.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEntitlementsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entitlements: globalThis.Array.isArray(object?.entitlements)
        ? object.entitlements.map((e: any) => Entitlement.fromJSON(e))
        : [],
      authToken: isSet(object.authToken) ? globalThis.String(object.authToken) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: TransferEntitlementsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entitlements?.length) {
      obj.entitlements = message.entitlements.map((e) => Entitlement.toJSON(e));
    }
    if (message.authToken !== "") {
      obj.authToken = message.authToken;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEntitlementsRequest>): TransferEntitlementsRequest {
    return TransferEntitlementsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEntitlementsRequest>): TransferEntitlementsRequest {
    const message = createBaseTransferEntitlementsRequest();
    message.parent = object.parent ?? "";
    message.entitlements = object.entitlements?.map((e) => Entitlement.fromPartial(e)) || [];
    message.authToken = object.authToken ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseTransferEntitlementsResponse(): TransferEntitlementsResponse {
  return { entitlements: [] };
}

export const TransferEntitlementsResponse: MessageFns<TransferEntitlementsResponse> = {
  encode(message: TransferEntitlementsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entitlements) {
      Entitlement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEntitlementsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEntitlementsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlements.push(Entitlement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEntitlementsResponse {
    return {
      entitlements: globalThis.Array.isArray(object?.entitlements)
        ? object.entitlements.map((e: any) => Entitlement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferEntitlementsResponse): unknown {
    const obj: any = {};
    if (message.entitlements?.length) {
      obj.entitlements = message.entitlements.map((e) => Entitlement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEntitlementsResponse>): TransferEntitlementsResponse {
    return TransferEntitlementsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEntitlementsResponse>): TransferEntitlementsResponse {
    const message = createBaseTransferEntitlementsResponse();
    message.entitlements = object.entitlements?.map((e) => Entitlement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferEntitlementsToGoogleRequest(): TransferEntitlementsToGoogleRequest {
  return { parent: "", entitlements: [], requestId: "" };
}

export const TransferEntitlementsToGoogleRequest: MessageFns<TransferEntitlementsToGoogleRequest> = {
  encode(message: TransferEntitlementsToGoogleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.entitlements) {
      Entitlement.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEntitlementsToGoogleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEntitlementsToGoogleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entitlements.push(Entitlement.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEntitlementsToGoogleRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entitlements: globalThis.Array.isArray(object?.entitlements)
        ? object.entitlements.map((e: any) => Entitlement.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: TransferEntitlementsToGoogleRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entitlements?.length) {
      obj.entitlements = message.entitlements.map((e) => Entitlement.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEntitlementsToGoogleRequest>): TransferEntitlementsToGoogleRequest {
    return TransferEntitlementsToGoogleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEntitlementsToGoogleRequest>): TransferEntitlementsToGoogleRequest {
    const message = createBaseTransferEntitlementsToGoogleRequest();
    message.parent = object.parent ?? "";
    message.entitlements = object.entitlements?.map((e) => Entitlement.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseChangeParametersRequest(): ChangeParametersRequest {
  return { name: "", parameters: [], requestId: "", purchaseOrderId: "" };
}

export const ChangeParametersRequest: MessageFns<ChangeParametersRequest> = {
  encode(message: ChangeParametersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.parameters) {
      Parameter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.purchaseOrderId !== "") {
      writer.uint32(42).string(message.purchaseOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeParametersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeParametersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters.push(Parameter.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.purchaseOrderId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeParametersRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Parameter.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      purchaseOrderId: isSet(object.purchaseOrderId) ? globalThis.String(object.purchaseOrderId) : "",
    };
  },

  toJSON(message: ChangeParametersRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Parameter.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.purchaseOrderId !== "") {
      obj.purchaseOrderId = message.purchaseOrderId;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeParametersRequest>): ChangeParametersRequest {
    return ChangeParametersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeParametersRequest>): ChangeParametersRequest {
    const message = createBaseChangeParametersRequest();
    message.name = object.name ?? "";
    message.parameters = object.parameters?.map((e) => Parameter.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    message.purchaseOrderId = object.purchaseOrderId ?? "";
    return message;
  },
};

function createBaseChangeRenewalSettingsRequest(): ChangeRenewalSettingsRequest {
  return { name: "", renewalSettings: undefined, requestId: "" };
}

export const ChangeRenewalSettingsRequest: MessageFns<ChangeRenewalSettingsRequest> = {
  encode(message: ChangeRenewalSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.renewalSettings !== undefined) {
      RenewalSettings.encode(message.renewalSettings, writer.uint32(34).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeRenewalSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeRenewalSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.renewalSettings = RenewalSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeRenewalSettingsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      renewalSettings: isSet(object.renewalSettings) ? RenewalSettings.fromJSON(object.renewalSettings) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ChangeRenewalSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.renewalSettings !== undefined) {
      obj.renewalSettings = RenewalSettings.toJSON(message.renewalSettings);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeRenewalSettingsRequest>): ChangeRenewalSettingsRequest {
    return ChangeRenewalSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeRenewalSettingsRequest>): ChangeRenewalSettingsRequest {
    const message = createBaseChangeRenewalSettingsRequest();
    message.name = object.name ?? "";
    message.renewalSettings = (object.renewalSettings !== undefined && object.renewalSettings !== null)
      ? RenewalSettings.fromPartial(object.renewalSettings)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseChangeOfferRequest(): ChangeOfferRequest {
  return { name: "", offer: "", parameters: [], purchaseOrderId: "", requestId: "", billingAccount: "" };
}

export const ChangeOfferRequest: MessageFns<ChangeOfferRequest> = {
  encode(message: ChangeOfferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.offer !== "") {
      writer.uint32(18).string(message.offer);
    }
    for (const v of message.parameters) {
      Parameter.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.purchaseOrderId !== "") {
      writer.uint32(42).string(message.purchaseOrderId);
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    if (message.billingAccount !== "") {
      writer.uint32(58).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeOfferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.offer = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parameters.push(Parameter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.purchaseOrderId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeOfferRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offer: isSet(object.offer) ? globalThis.String(object.offer) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Parameter.fromJSON(e))
        : [],
      purchaseOrderId: isSet(object.purchaseOrderId) ? globalThis.String(object.purchaseOrderId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: ChangeOfferRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.offer !== "") {
      obj.offer = message.offer;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Parameter.toJSON(e));
    }
    if (message.purchaseOrderId !== "") {
      obj.purchaseOrderId = message.purchaseOrderId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeOfferRequest>): ChangeOfferRequest {
    return ChangeOfferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeOfferRequest>): ChangeOfferRequest {
    const message = createBaseChangeOfferRequest();
    message.name = object.name ?? "";
    message.offer = object.offer ?? "";
    message.parameters = object.parameters?.map((e) => Parameter.fromPartial(e)) || [];
    message.purchaseOrderId = object.purchaseOrderId ?? "";
    message.requestId = object.requestId ?? "";
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBaseStartPaidServiceRequest(): StartPaidServiceRequest {
  return { name: "", requestId: "" };
}

export const StartPaidServiceRequest: MessageFns<StartPaidServiceRequest> = {
  encode(message: StartPaidServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartPaidServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartPaidServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartPaidServiceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: StartPaidServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<StartPaidServiceRequest>): StartPaidServiceRequest {
    return StartPaidServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartPaidServiceRequest>): StartPaidServiceRequest {
    const message = createBaseStartPaidServiceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCancelEntitlementRequest(): CancelEntitlementRequest {
  return { name: "", requestId: "" };
}

export const CancelEntitlementRequest: MessageFns<CancelEntitlementRequest> = {
  encode(message: CancelEntitlementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelEntitlementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelEntitlementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelEntitlementRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CancelEntitlementRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelEntitlementRequest>): CancelEntitlementRequest {
    return CancelEntitlementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelEntitlementRequest>): CancelEntitlementRequest {
    const message = createBaseCancelEntitlementRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseSuspendEntitlementRequest(): SuspendEntitlementRequest {
  return { name: "", requestId: "" };
}

export const SuspendEntitlementRequest: MessageFns<SuspendEntitlementRequest> = {
  encode(message: SuspendEntitlementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuspendEntitlementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuspendEntitlementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuspendEntitlementRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: SuspendEntitlementRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<SuspendEntitlementRequest>): SuspendEntitlementRequest {
    return SuspendEntitlementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuspendEntitlementRequest>): SuspendEntitlementRequest {
    const message = createBaseSuspendEntitlementRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseActivateEntitlementRequest(): ActivateEntitlementRequest {
  return { name: "", requestId: "" };
}

export const ActivateEntitlementRequest: MessageFns<ActivateEntitlementRequest> = {
  encode(message: ActivateEntitlementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateEntitlementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateEntitlementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivateEntitlementRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ActivateEntitlementRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ActivateEntitlementRequest>): ActivateEntitlementRequest {
    return ActivateEntitlementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivateEntitlementRequest>): ActivateEntitlementRequest {
    const message = createBaseActivateEntitlementRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseLookupOfferRequest(): LookupOfferRequest {
  return { entitlement: "" };
}

export const LookupOfferRequest: MessageFns<LookupOfferRequest> = {
  encode(message: LookupOfferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entitlement !== "") {
      writer.uint32(10).string(message.entitlement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupOfferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupOfferRequest {
    return { entitlement: isSet(object.entitlement) ? globalThis.String(object.entitlement) : "" };
  },

  toJSON(message: LookupOfferRequest): unknown {
    const obj: any = {};
    if (message.entitlement !== "") {
      obj.entitlement = message.entitlement;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupOfferRequest>): LookupOfferRequest {
    return LookupOfferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupOfferRequest>): LookupOfferRequest {
    const message = createBaseLookupOfferRequest();
    message.entitlement = object.entitlement ?? "";
    return message;
  },
};

function createBaseListProductsRequest(): ListProductsRequest {
  return { account: "", pageSize: 0, pageToken: "", languageCode: "" };
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(message: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListProductsRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsRequest>): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsRequest>): ListProductsRequest {
    const message = createBaseListProductsRequest();
    message.account = object.account ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [], nextPageToken: "" };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsResponse>): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsResponse>): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSkusRequest(): ListSkusRequest {
  return { parent: "", account: "", pageSize: 0, pageToken: "", languageCode: "" };
}

export const ListSkusRequest: MessageFns<ListSkusRequest> = {
  encode(message: ListSkusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkusRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListSkusRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkusRequest>): ListSkusRequest {
    return ListSkusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkusRequest>): ListSkusRequest {
    const message = createBaseListSkusRequest();
    message.parent = object.parent ?? "";
    message.account = object.account ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListSkusResponse(): ListSkusResponse {
  return { skus: [], nextPageToken: "" };
}

export const ListSkusResponse: MessageFns<ListSkusResponse> = {
  encode(message: ListSkusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skus) {
      Sku.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skus.push(Sku.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkusResponse {
    return {
      skus: globalThis.Array.isArray(object?.skus) ? object.skus.map((e: any) => Sku.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSkusResponse): unknown {
    const obj: any = {};
    if (message.skus?.length) {
      obj.skus = message.skus.map((e) => Sku.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkusResponse>): ListSkusResponse {
    return ListSkusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkusResponse>): ListSkusResponse {
    const message = createBaseListSkusResponse();
    message.skus = object.skus?.map((e) => Sku.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListOffersRequest(): ListOffersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", languageCode: "", showFutureOffers: false };
}

export const ListOffersRequest: MessageFns<ListOffersRequest> = {
  encode(message: ListOffersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    if (message.showFutureOffers !== false) {
      writer.uint32(56).bool(message.showFutureOffers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOffersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOffersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.showFutureOffers = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOffersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      showFutureOffers: isSet(object.showFutureOffers) ? globalThis.Boolean(object.showFutureOffers) : false,
    };
  },

  toJSON(message: ListOffersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.showFutureOffers !== false) {
      obj.showFutureOffers = message.showFutureOffers;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOffersRequest>): ListOffersRequest {
    return ListOffersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOffersRequest>): ListOffersRequest {
    const message = createBaseListOffersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.languageCode = object.languageCode ?? "";
    message.showFutureOffers = object.showFutureOffers ?? false;
    return message;
  },
};

function createBaseListOffersResponse(): ListOffersResponse {
  return { offers: [], nextPageToken: "" };
}

export const ListOffersResponse: MessageFns<ListOffersResponse> = {
  encode(message: ListOffersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.offers) {
      Offer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOffersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOffersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offers.push(Offer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOffersResponse {
    return {
      offers: globalThis.Array.isArray(object?.offers) ? object.offers.map((e: any) => Offer.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListOffersResponse): unknown {
    const obj: any = {};
    if (message.offers?.length) {
      obj.offers = message.offers.map((e) => Offer.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOffersResponse>): ListOffersResponse {
    return ListOffersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOffersResponse>): ListOffersResponse {
    const message = createBaseListOffersResponse();
    message.offers = object.offers?.map((e) => Offer.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListPurchasableSkusRequest(): ListPurchasableSkusRequest {
  return {
    createEntitlementPurchase: undefined,
    changeOfferPurchase: undefined,
    customer: "",
    pageSize: 0,
    pageToken: "",
    languageCode: "",
  };
}

export const ListPurchasableSkusRequest: MessageFns<ListPurchasableSkusRequest> = {
  encode(message: ListPurchasableSkusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createEntitlementPurchase !== undefined) {
      ListPurchasableSkusRequest_CreateEntitlementPurchase.encode(
        message.createEntitlementPurchase,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.changeOfferPurchase !== undefined) {
      ListPurchasableSkusRequest_ChangeOfferPurchase.encode(message.changeOfferPurchase, writer.uint32(26).fork())
        .join();
    }
    if (message.customer !== "") {
      writer.uint32(10).string(message.customer);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableSkusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableSkusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createEntitlementPurchase = ListPurchasableSkusRequest_CreateEntitlementPurchase.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOfferPurchase = ListPurchasableSkusRequest_ChangeOfferPurchase.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customer = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableSkusRequest {
    return {
      createEntitlementPurchase: isSet(object.createEntitlementPurchase)
        ? ListPurchasableSkusRequest_CreateEntitlementPurchase.fromJSON(object.createEntitlementPurchase)
        : undefined,
      changeOfferPurchase: isSet(object.changeOfferPurchase)
        ? ListPurchasableSkusRequest_ChangeOfferPurchase.fromJSON(object.changeOfferPurchase)
        : undefined,
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListPurchasableSkusRequest): unknown {
    const obj: any = {};
    if (message.createEntitlementPurchase !== undefined) {
      obj.createEntitlementPurchase = ListPurchasableSkusRequest_CreateEntitlementPurchase.toJSON(
        message.createEntitlementPurchase,
      );
    }
    if (message.changeOfferPurchase !== undefined) {
      obj.changeOfferPurchase = ListPurchasableSkusRequest_ChangeOfferPurchase.toJSON(message.changeOfferPurchase);
    }
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPurchasableSkusRequest>): ListPurchasableSkusRequest {
    return ListPurchasableSkusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPurchasableSkusRequest>): ListPurchasableSkusRequest {
    const message = createBaseListPurchasableSkusRequest();
    message.createEntitlementPurchase =
      (object.createEntitlementPurchase !== undefined && object.createEntitlementPurchase !== null)
        ? ListPurchasableSkusRequest_CreateEntitlementPurchase.fromPartial(object.createEntitlementPurchase)
        : undefined;
    message.changeOfferPurchase = (object.changeOfferPurchase !== undefined && object.changeOfferPurchase !== null)
      ? ListPurchasableSkusRequest_ChangeOfferPurchase.fromPartial(object.changeOfferPurchase)
      : undefined;
    message.customer = object.customer ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListPurchasableSkusRequest_CreateEntitlementPurchase(): ListPurchasableSkusRequest_CreateEntitlementPurchase {
  return { product: "" };
}

export const ListPurchasableSkusRequest_CreateEntitlementPurchase: MessageFns<
  ListPurchasableSkusRequest_CreateEntitlementPurchase
> = {
  encode(
    message: ListPurchasableSkusRequest_CreateEntitlementPurchase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.product !== "") {
      writer.uint32(10).string(message.product);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableSkusRequest_CreateEntitlementPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableSkusRequest_CreateEntitlementPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableSkusRequest_CreateEntitlementPurchase {
    return { product: isSet(object.product) ? globalThis.String(object.product) : "" };
  },

  toJSON(message: ListPurchasableSkusRequest_CreateEntitlementPurchase): unknown {
    const obj: any = {};
    if (message.product !== "") {
      obj.product = message.product;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListPurchasableSkusRequest_CreateEntitlementPurchase>,
  ): ListPurchasableSkusRequest_CreateEntitlementPurchase {
    return ListPurchasableSkusRequest_CreateEntitlementPurchase.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPurchasableSkusRequest_CreateEntitlementPurchase>,
  ): ListPurchasableSkusRequest_CreateEntitlementPurchase {
    const message = createBaseListPurchasableSkusRequest_CreateEntitlementPurchase();
    message.product = object.product ?? "";
    return message;
  },
};

function createBaseListPurchasableSkusRequest_ChangeOfferPurchase(): ListPurchasableSkusRequest_ChangeOfferPurchase {
  return { entitlement: "", changeType: 0 };
}

export const ListPurchasableSkusRequest_ChangeOfferPurchase: MessageFns<
  ListPurchasableSkusRequest_ChangeOfferPurchase
> = {
  encode(
    message: ListPurchasableSkusRequest_ChangeOfferPurchase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.entitlement !== "") {
      writer.uint32(10).string(message.entitlement);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableSkusRequest_ChangeOfferPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableSkusRequest_ChangeOfferPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlement = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableSkusRequest_ChangeOfferPurchase {
    return {
      entitlement: isSet(object.entitlement) ? globalThis.String(object.entitlement) : "",
      changeType: isSet(object.changeType)
        ? listPurchasableSkusRequest_ChangeOfferPurchase_ChangeTypeFromJSON(object.changeType)
        : 0,
    };
  },

  toJSON(message: ListPurchasableSkusRequest_ChangeOfferPurchase): unknown {
    const obj: any = {};
    if (message.entitlement !== "") {
      obj.entitlement = message.entitlement;
    }
    if (message.changeType !== 0) {
      obj.changeType = listPurchasableSkusRequest_ChangeOfferPurchase_ChangeTypeToJSON(message.changeType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListPurchasableSkusRequest_ChangeOfferPurchase>,
  ): ListPurchasableSkusRequest_ChangeOfferPurchase {
    return ListPurchasableSkusRequest_ChangeOfferPurchase.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPurchasableSkusRequest_ChangeOfferPurchase>,
  ): ListPurchasableSkusRequest_ChangeOfferPurchase {
    const message = createBaseListPurchasableSkusRequest_ChangeOfferPurchase();
    message.entitlement = object.entitlement ?? "";
    message.changeType = object.changeType ?? 0;
    return message;
  },
};

function createBaseListPurchasableSkusResponse(): ListPurchasableSkusResponse {
  return { purchasableSkus: [], nextPageToken: "" };
}

export const ListPurchasableSkusResponse: MessageFns<ListPurchasableSkusResponse> = {
  encode(message: ListPurchasableSkusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.purchasableSkus) {
      PurchasableSku.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableSkusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableSkusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.purchasableSkus.push(PurchasableSku.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableSkusResponse {
    return {
      purchasableSkus: globalThis.Array.isArray(object?.purchasableSkus)
        ? object.purchasableSkus.map((e: any) => PurchasableSku.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPurchasableSkusResponse): unknown {
    const obj: any = {};
    if (message.purchasableSkus?.length) {
      obj.purchasableSkus = message.purchasableSkus.map((e) => PurchasableSku.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPurchasableSkusResponse>): ListPurchasableSkusResponse {
    return ListPurchasableSkusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPurchasableSkusResponse>): ListPurchasableSkusResponse {
    const message = createBaseListPurchasableSkusResponse();
    message.purchasableSkus = object.purchasableSkus?.map((e) => PurchasableSku.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePurchasableSku(): PurchasableSku {
  return { sku: undefined };
}

export const PurchasableSku: MessageFns<PurchasableSku> = {
  encode(message: PurchasableSku, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sku !== undefined) {
      Sku.encode(message.sku, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchasableSku {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchasableSku();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sku = Sku.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchasableSku {
    return { sku: isSet(object.sku) ? Sku.fromJSON(object.sku) : undefined };
  },

  toJSON(message: PurchasableSku): unknown {
    const obj: any = {};
    if (message.sku !== undefined) {
      obj.sku = Sku.toJSON(message.sku);
    }
    return obj;
  },

  create(base?: DeepPartial<PurchasableSku>): PurchasableSku {
    return PurchasableSku.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchasableSku>): PurchasableSku {
    const message = createBasePurchasableSku();
    message.sku = (object.sku !== undefined && object.sku !== null) ? Sku.fromPartial(object.sku) : undefined;
    return message;
  },
};

function createBaseListPurchasableOffersRequest(): ListPurchasableOffersRequest {
  return {
    createEntitlementPurchase: undefined,
    changeOfferPurchase: undefined,
    customer: "",
    pageSize: 0,
    pageToken: "",
    languageCode: "",
  };
}

export const ListPurchasableOffersRequest: MessageFns<ListPurchasableOffersRequest> = {
  encode(message: ListPurchasableOffersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createEntitlementPurchase !== undefined) {
      ListPurchasableOffersRequest_CreateEntitlementPurchase.encode(
        message.createEntitlementPurchase,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.changeOfferPurchase !== undefined) {
      ListPurchasableOffersRequest_ChangeOfferPurchase.encode(message.changeOfferPurchase, writer.uint32(26).fork())
        .join();
    }
    if (message.customer !== "") {
      writer.uint32(10).string(message.customer);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableOffersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableOffersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createEntitlementPurchase = ListPurchasableOffersRequest_CreateEntitlementPurchase.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOfferPurchase = ListPurchasableOffersRequest_ChangeOfferPurchase.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customer = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableOffersRequest {
    return {
      createEntitlementPurchase: isSet(object.createEntitlementPurchase)
        ? ListPurchasableOffersRequest_CreateEntitlementPurchase.fromJSON(object.createEntitlementPurchase)
        : undefined,
      changeOfferPurchase: isSet(object.changeOfferPurchase)
        ? ListPurchasableOffersRequest_ChangeOfferPurchase.fromJSON(object.changeOfferPurchase)
        : undefined,
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListPurchasableOffersRequest): unknown {
    const obj: any = {};
    if (message.createEntitlementPurchase !== undefined) {
      obj.createEntitlementPurchase = ListPurchasableOffersRequest_CreateEntitlementPurchase.toJSON(
        message.createEntitlementPurchase,
      );
    }
    if (message.changeOfferPurchase !== undefined) {
      obj.changeOfferPurchase = ListPurchasableOffersRequest_ChangeOfferPurchase.toJSON(message.changeOfferPurchase);
    }
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPurchasableOffersRequest>): ListPurchasableOffersRequest {
    return ListPurchasableOffersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPurchasableOffersRequest>): ListPurchasableOffersRequest {
    const message = createBaseListPurchasableOffersRequest();
    message.createEntitlementPurchase =
      (object.createEntitlementPurchase !== undefined && object.createEntitlementPurchase !== null)
        ? ListPurchasableOffersRequest_CreateEntitlementPurchase.fromPartial(object.createEntitlementPurchase)
        : undefined;
    message.changeOfferPurchase = (object.changeOfferPurchase !== undefined && object.changeOfferPurchase !== null)
      ? ListPurchasableOffersRequest_ChangeOfferPurchase.fromPartial(object.changeOfferPurchase)
      : undefined;
    message.customer = object.customer ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListPurchasableOffersRequest_CreateEntitlementPurchase(): ListPurchasableOffersRequest_CreateEntitlementPurchase {
  return { sku: "", billingAccount: "" };
}

export const ListPurchasableOffersRequest_CreateEntitlementPurchase: MessageFns<
  ListPurchasableOffersRequest_CreateEntitlementPurchase
> = {
  encode(
    message: ListPurchasableOffersRequest_CreateEntitlementPurchase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sku !== "") {
      writer.uint32(10).string(message.sku);
    }
    if (message.billingAccount !== "") {
      writer.uint32(18).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableOffersRequest_CreateEntitlementPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableOffersRequest_CreateEntitlementPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sku = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableOffersRequest_CreateEntitlementPurchase {
    return {
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: ListPurchasableOffersRequest_CreateEntitlementPurchase): unknown {
    const obj: any = {};
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListPurchasableOffersRequest_CreateEntitlementPurchase>,
  ): ListPurchasableOffersRequest_CreateEntitlementPurchase {
    return ListPurchasableOffersRequest_CreateEntitlementPurchase.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPurchasableOffersRequest_CreateEntitlementPurchase>,
  ): ListPurchasableOffersRequest_CreateEntitlementPurchase {
    const message = createBaseListPurchasableOffersRequest_CreateEntitlementPurchase();
    message.sku = object.sku ?? "";
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBaseListPurchasableOffersRequest_ChangeOfferPurchase(): ListPurchasableOffersRequest_ChangeOfferPurchase {
  return { entitlement: "", newSku: "", billingAccount: "" };
}

export const ListPurchasableOffersRequest_ChangeOfferPurchase: MessageFns<
  ListPurchasableOffersRequest_ChangeOfferPurchase
> = {
  encode(
    message: ListPurchasableOffersRequest_ChangeOfferPurchase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.entitlement !== "") {
      writer.uint32(10).string(message.entitlement);
    }
    if (message.newSku !== "") {
      writer.uint32(18).string(message.newSku);
    }
    if (message.billingAccount !== "") {
      writer.uint32(26).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableOffersRequest_ChangeOfferPurchase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableOffersRequest_ChangeOfferPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlement = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newSku = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableOffersRequest_ChangeOfferPurchase {
    return {
      entitlement: isSet(object.entitlement) ? globalThis.String(object.entitlement) : "",
      newSku: isSet(object.newSku) ? globalThis.String(object.newSku) : "",
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: ListPurchasableOffersRequest_ChangeOfferPurchase): unknown {
    const obj: any = {};
    if (message.entitlement !== "") {
      obj.entitlement = message.entitlement;
    }
    if (message.newSku !== "") {
      obj.newSku = message.newSku;
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListPurchasableOffersRequest_ChangeOfferPurchase>,
  ): ListPurchasableOffersRequest_ChangeOfferPurchase {
    return ListPurchasableOffersRequest_ChangeOfferPurchase.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPurchasableOffersRequest_ChangeOfferPurchase>,
  ): ListPurchasableOffersRequest_ChangeOfferPurchase {
    const message = createBaseListPurchasableOffersRequest_ChangeOfferPurchase();
    message.entitlement = object.entitlement ?? "";
    message.newSku = object.newSku ?? "";
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBaseListPurchasableOffersResponse(): ListPurchasableOffersResponse {
  return { purchasableOffers: [], nextPageToken: "" };
}

export const ListPurchasableOffersResponse: MessageFns<ListPurchasableOffersResponse> = {
  encode(message: ListPurchasableOffersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.purchasableOffers) {
      PurchasableOffer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurchasableOffersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurchasableOffersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.purchasableOffers.push(PurchasableOffer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurchasableOffersResponse {
    return {
      purchasableOffers: globalThis.Array.isArray(object?.purchasableOffers)
        ? object.purchasableOffers.map((e: any) => PurchasableOffer.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPurchasableOffersResponse): unknown {
    const obj: any = {};
    if (message.purchasableOffers?.length) {
      obj.purchasableOffers = message.purchasableOffers.map((e) => PurchasableOffer.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPurchasableOffersResponse>): ListPurchasableOffersResponse {
    return ListPurchasableOffersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPurchasableOffersResponse>): ListPurchasableOffersResponse {
    const message = createBaseListPurchasableOffersResponse();
    message.purchasableOffers = object.purchasableOffers?.map((e) => PurchasableOffer.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePurchasableOffer(): PurchasableOffer {
  return { offer: undefined };
}

export const PurchasableOffer: MessageFns<PurchasableOffer> = {
  encode(message: PurchasableOffer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offer !== undefined) {
      Offer.encode(message.offer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchasableOffer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchasableOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offer = Offer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchasableOffer {
    return { offer: isSet(object.offer) ? Offer.fromJSON(object.offer) : undefined };
  },

  toJSON(message: PurchasableOffer): unknown {
    const obj: any = {};
    if (message.offer !== undefined) {
      obj.offer = Offer.toJSON(message.offer);
    }
    return obj;
  },

  create(base?: DeepPartial<PurchasableOffer>): PurchasableOffer {
    return PurchasableOffer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchasableOffer>): PurchasableOffer {
    const message = createBasePurchasableOffer();
    message.offer = (object.offer !== undefined && object.offer !== null) ? Offer.fromPartial(object.offer) : undefined;
    return message;
  },
};

function createBaseQueryEligibleBillingAccountsRequest(): QueryEligibleBillingAccountsRequest {
  return { customer: "", skus: [] };
}

export const QueryEligibleBillingAccountsRequest: MessageFns<QueryEligibleBillingAccountsRequest> = {
  encode(message: QueryEligibleBillingAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customer !== "") {
      writer.uint32(10).string(message.customer);
    }
    for (const v of message.skus) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEligibleBillingAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEligibleBillingAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skus.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEligibleBillingAccountsRequest {
    return {
      customer: isSet(object.customer) ? globalThis.String(object.customer) : "",
      skus: globalThis.Array.isArray(object?.skus) ? object.skus.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryEligibleBillingAccountsRequest): unknown {
    const obj: any = {};
    if (message.customer !== "") {
      obj.customer = message.customer;
    }
    if (message.skus?.length) {
      obj.skus = message.skus;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryEligibleBillingAccountsRequest>): QueryEligibleBillingAccountsRequest {
    return QueryEligibleBillingAccountsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryEligibleBillingAccountsRequest>): QueryEligibleBillingAccountsRequest {
    const message = createBaseQueryEligibleBillingAccountsRequest();
    message.customer = object.customer ?? "";
    message.skus = object.skus?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryEligibleBillingAccountsResponse(): QueryEligibleBillingAccountsResponse {
  return { skuPurchaseGroups: [] };
}

export const QueryEligibleBillingAccountsResponse: MessageFns<QueryEligibleBillingAccountsResponse> = {
  encode(message: QueryEligibleBillingAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skuPurchaseGroups) {
      SkuPurchaseGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEligibleBillingAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEligibleBillingAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuPurchaseGroups.push(SkuPurchaseGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEligibleBillingAccountsResponse {
    return {
      skuPurchaseGroups: globalThis.Array.isArray(object?.skuPurchaseGroups)
        ? object.skuPurchaseGroups.map((e: any) => SkuPurchaseGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryEligibleBillingAccountsResponse): unknown {
    const obj: any = {};
    if (message.skuPurchaseGroups?.length) {
      obj.skuPurchaseGroups = message.skuPurchaseGroups.map((e) => SkuPurchaseGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryEligibleBillingAccountsResponse>): QueryEligibleBillingAccountsResponse {
    return QueryEligibleBillingAccountsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryEligibleBillingAccountsResponse>): QueryEligibleBillingAccountsResponse {
    const message = createBaseQueryEligibleBillingAccountsResponse();
    message.skuPurchaseGroups = object.skuPurchaseGroups?.map((e) => SkuPurchaseGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkuPurchaseGroup(): SkuPurchaseGroup {
  return { skus: [], billingAccountPurchaseInfos: [] };
}

export const SkuPurchaseGroup: MessageFns<SkuPurchaseGroup> = {
  encode(message: SkuPurchaseGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skus) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.billingAccountPurchaseInfos) {
      BillingAccountPurchaseInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkuPurchaseGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuPurchaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skus.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billingAccountPurchaseInfos.push(BillingAccountPurchaseInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkuPurchaseGroup {
    return {
      skus: globalThis.Array.isArray(object?.skus) ? object.skus.map((e: any) => globalThis.String(e)) : [],
      billingAccountPurchaseInfos: globalThis.Array.isArray(object?.billingAccountPurchaseInfos)
        ? object.billingAccountPurchaseInfos.map((e: any) => BillingAccountPurchaseInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SkuPurchaseGroup): unknown {
    const obj: any = {};
    if (message.skus?.length) {
      obj.skus = message.skus;
    }
    if (message.billingAccountPurchaseInfos?.length) {
      obj.billingAccountPurchaseInfos = message.billingAccountPurchaseInfos.map((e) =>
        BillingAccountPurchaseInfo.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SkuPurchaseGroup>): SkuPurchaseGroup {
    return SkuPurchaseGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkuPurchaseGroup>): SkuPurchaseGroup {
    const message = createBaseSkuPurchaseGroup();
    message.skus = object.skus?.map((e) => e) || [];
    message.billingAccountPurchaseInfos =
      object.billingAccountPurchaseInfos?.map((e) => BillingAccountPurchaseInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBillingAccountPurchaseInfo(): BillingAccountPurchaseInfo {
  return { billingAccount: undefined };
}

export const BillingAccountPurchaseInfo: MessageFns<BillingAccountPurchaseInfo> = {
  encode(message: BillingAccountPurchaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.billingAccount !== undefined) {
      BillingAccount.encode(message.billingAccount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BillingAccountPurchaseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingAccountPurchaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.billingAccount = BillingAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BillingAccountPurchaseInfo {
    return {
      billingAccount: isSet(object.billingAccount) ? BillingAccount.fromJSON(object.billingAccount) : undefined,
    };
  },

  toJSON(message: BillingAccountPurchaseInfo): unknown {
    const obj: any = {};
    if (message.billingAccount !== undefined) {
      obj.billingAccount = BillingAccount.toJSON(message.billingAccount);
    }
    return obj;
  },

  create(base?: DeepPartial<BillingAccountPurchaseInfo>): BillingAccountPurchaseInfo {
    return BillingAccountPurchaseInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BillingAccountPurchaseInfo>): BillingAccountPurchaseInfo {
    const message = createBaseBillingAccountPurchaseInfo();
    message.billingAccount = (object.billingAccount !== undefined && object.billingAccount !== null)
      ? BillingAccount.fromPartial(object.billingAccount)
      : undefined;
    return message;
  },
};

function createBaseRegisterSubscriberRequest(): RegisterSubscriberRequest {
  return { account: "", serviceAccount: "" };
}

export const RegisterSubscriberRequest: MessageFns<RegisterSubscriberRequest> = {
  encode(message: RegisterSubscriberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterSubscriberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterSubscriberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterSubscriberRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: RegisterSubscriberRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterSubscriberRequest>): RegisterSubscriberRequest {
    return RegisterSubscriberRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterSubscriberRequest>): RegisterSubscriberRequest {
    const message = createBaseRegisterSubscriberRequest();
    message.account = object.account ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseRegisterSubscriberResponse(): RegisterSubscriberResponse {
  return { topic: "" };
}

export const RegisterSubscriberResponse: MessageFns<RegisterSubscriberResponse> = {
  encode(message: RegisterSubscriberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterSubscriberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterSubscriberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterSubscriberResponse {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: RegisterSubscriberResponse): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterSubscriberResponse>): RegisterSubscriberResponse {
    return RegisterSubscriberResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterSubscriberResponse>): RegisterSubscriberResponse {
    const message = createBaseRegisterSubscriberResponse();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseUnregisterSubscriberRequest(): UnregisterSubscriberRequest {
  return { account: "", serviceAccount: "" };
}

export const UnregisterSubscriberRequest: MessageFns<UnregisterSubscriberRequest> = {
  encode(message: UnregisterSubscriberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterSubscriberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterSubscriberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterSubscriberRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: UnregisterSubscriberRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<UnregisterSubscriberRequest>): UnregisterSubscriberRequest {
    return UnregisterSubscriberRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnregisterSubscriberRequest>): UnregisterSubscriberRequest {
    const message = createBaseUnregisterSubscriberRequest();
    message.account = object.account ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseUnregisterSubscriberResponse(): UnregisterSubscriberResponse {
  return { topic: "" };
}

export const UnregisterSubscriberResponse: MessageFns<UnregisterSubscriberResponse> = {
  encode(message: UnregisterSubscriberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterSubscriberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterSubscriberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterSubscriberResponse {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: UnregisterSubscriberResponse): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<UnregisterSubscriberResponse>): UnregisterSubscriberResponse {
    return UnregisterSubscriberResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnregisterSubscriberResponse>): UnregisterSubscriberResponse {
    const message = createBaseUnregisterSubscriberResponse();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseListSubscribersRequest(): ListSubscribersRequest {
  return { account: "", pageSize: 0, pageToken: "" };
}

export const ListSubscribersRequest: MessageFns<ListSubscribersRequest> = {
  encode(message: ListSubscribersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscribersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscribersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscribersRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSubscribersRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscribersRequest>): ListSubscribersRequest {
    return ListSubscribersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscribersRequest>): ListSubscribersRequest {
    const message = createBaseListSubscribersRequest();
    message.account = object.account ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSubscribersResponse(): ListSubscribersResponse {
  return { topic: "", serviceAccounts: [], nextPageToken: "" };
}

export const ListSubscribersResponse: MessageFns<ListSubscribersResponse> = {
  encode(message: ListSubscribersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    for (const v of message.serviceAccounts) {
      writer.uint32(18).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscribersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscribersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccounts.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscribersResponse {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      serviceAccounts: globalThis.Array.isArray(object?.serviceAccounts)
        ? object.serviceAccounts.map((e: any) => globalThis.String(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSubscribersResponse): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.serviceAccounts?.length) {
      obj.serviceAccounts = message.serviceAccounts;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscribersResponse>): ListSubscribersResponse {
    return ListSubscribersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscribersResponse>): ListSubscribersResponse {
    const message = createBaseListSubscribersResponse();
    message.topic = object.topic ?? "";
    message.serviceAccounts = object.serviceAccounts?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListEntitlementChangesRequest(): ListEntitlementChangesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListEntitlementChangesRequest: MessageFns<ListEntitlementChangesRequest> = {
  encode(message: ListEntitlementChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitlementChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitlementChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitlementChangesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListEntitlementChangesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitlementChangesRequest>): ListEntitlementChangesRequest {
    return ListEntitlementChangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitlementChangesRequest>): ListEntitlementChangesRequest {
    const message = createBaseListEntitlementChangesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListEntitlementChangesResponse(): ListEntitlementChangesResponse {
  return { entitlementChanges: [], nextPageToken: "" };
}

export const ListEntitlementChangesResponse: MessageFns<ListEntitlementChangesResponse> = {
  encode(message: ListEntitlementChangesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entitlementChanges) {
      EntitlementChange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntitlementChangesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntitlementChangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlementChanges.push(EntitlementChange.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntitlementChangesResponse {
    return {
      entitlementChanges: globalThis.Array.isArray(object?.entitlementChanges)
        ? object.entitlementChanges.map((e: any) => EntitlementChange.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEntitlementChangesResponse): unknown {
    const obj: any = {};
    if (message.entitlementChanges?.length) {
      obj.entitlementChanges = message.entitlementChanges.map((e) => EntitlementChange.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntitlementChangesResponse>): ListEntitlementChangesResponse {
    return ListEntitlementChangesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntitlementChangesResponse>): ListEntitlementChangesResponse {
    const message = createBaseListEntitlementChangesResponse();
    message.entitlementChanges = object.entitlementChanges?.map((e) => EntitlementChange.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * CloudChannelService lets Google cloud resellers and distributors manage
 * their customers, channel partners, entitlements, and reports.
 *
 * Using this service:
 * 1. Resellers and distributors can manage a customer entity.
 * 2. Distributors can register an authorized reseller in their channel and
 *    provide them with delegated admin access.
 * 3. Resellers and distributors can manage customer entitlements.
 *
 * CloudChannelService exposes the following resources:
 * - [Customer][google.cloud.channel.v1.Customer]s: An entity-usually an
 * enterprise-managed by a reseller or distributor.
 *
 * - [Entitlement][google.cloud.channel.v1.Entitlement]s: An entity that
 * provides a customer with the means to use a service. Entitlements are created
 * or updated as a result of a successful fulfillment.
 *
 * - [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s: An
 * entity that identifies links between distributors and their indirect
 * resellers in a channel.
 */
export type CloudChannelServiceDefinition = typeof CloudChannelServiceDefinition;
export const CloudChannelServiceDefinition = {
  name: "CloudChannelService",
  fullName: "google.cloud.channel.v1.CloudChannelService",
  methods: {
    /**
     * List [Customer][google.cloud.channel.v1.Customer]s.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * List of [Customer][google.cloud.channel.v1.Customer]s, or an empty list if
     * there are no customers.
     */
    listCustomers: {
      name: "ListCustomers",
      requestType: ListCustomersRequest,
      requestStream: false,
      responseType: ListCustomersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              94,
              90,
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the requested [Customer][google.cloud.channel.v1.Customer]
     * resource.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The customer resource doesn't exist. Usually the result of an
     * invalid name parameter.
     *
     * Return value:
     * The [Customer][google.cloud.channel.v1.Customer] resource.
     */
    getCustomer: {
      name: "GetCustomer",
      requestType: GetCustomerRequest,
      requestStream: false,
      responseType: Customer,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              94,
              90,
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Confirms the existence of Cloud Identity accounts based on the domain and
     * if the Cloud Identity accounts are owned by the reseller.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * INVALID_VALUE: Invalid domain value in the request.
     *
     * Return value:
     * A list of
     * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
     * resources for the domain (may be empty)
     *
     * Note: in the v1alpha1 version of the API, a NOT_FOUND error returns if
     * no
     * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
     * resources match the domain.
     */
    checkCloudIdentityAccountsExist: {
      name: "CheckCloudIdentityAccountsExist",
      requestType: CheckCloudIdentityAccountsExistRequest,
      requestStream: false,
      responseType: CheckCloudIdentityAccountsExistResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
              67,
              108,
              111,
              117,
              100,
              73,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              69,
              120,
              105,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new [Customer][google.cloud.channel.v1.Customer] resource under
     * the reseller or distributor account.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The reseller account making the request is different from the
     *     reseller account in the API request.
     *     * You are not authorized to create a customer. See
     *     https://support.google.com/channelservices/answer/9759265
     * * INVALID_ARGUMENT:
     *     * Required request parameters are missing or invalid.
     *     * Domain field value doesn't match the primary email domain.
     *
     * Return value:
     * The newly created [Customer][google.cloud.channel.v1.Customer] resource.
     */
    createCustomer: {
      name: "CreateCustomer",
      requestType: CreateCustomerRequest,
      requestStream: false,
      responseType: Customer,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              114,
              58,
              8,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              90,
              67,
              58,
              8,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              34,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an existing [Customer][google.cloud.channel.v1.Customer] resource
     * for the reseller or distributor.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
     * for the name in the request.
     *
     * Return value:
     * The updated [Customer][google.cloud.channel.v1.Customer] resource.
     */
    updateCustomer: {
      name: "UpdateCustomer",
      requestType: UpdateCustomerRequest,
      requestStream: false,
      responseType: Customer,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              132,
              1,
              58,
              8,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              90,
              76,
              58,
              8,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              50,
              64,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              50,
              42,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the given [Customer][google.cloud.channel.v1.Customer] permanently.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The account making the request does not own
     * this customer.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * FAILED_PRECONDITION: The customer has existing entitlements.
     * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
     * for the name in the request.
     */
    deleteCustomer: {
      name: "DeleteCustomer",
      requestType: DeleteCustomerRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              94,
              90,
              57,
              42,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              42,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Imports a [Customer][google.cloud.channel.v1.Customer] from the Cloud
     * Identity associated with the provided Cloud Identity ID or domain before a
     * TransferEntitlements call. If a linked Customer already exists and
     * overwrite_if_exists is true, it will update that Customer's data.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The reseller account making the request is different from the
     *     reseller account in the API request.
     *     * You are not authorized to import the customer. See
     *     https://support.google.com/channelservices/answer/9759265
     * * NOT_FOUND: Cloud Identity doesn't exist or was deleted.
     * * INVALID_ARGUMENT: Required parameters are missing, or the auth_token is
     * expired or invalid.
     * * ALREADY_EXISTS: A customer already exists and has conflicting critical
     * fields. Requires an overwrite.
     *
     * Return value:
     * The [Customer][google.cloud.channel.v1.Customer].
     */
    importCustomer: {
      name: "ImportCustomer",
      requestType: ImportCustomerRequest,
      requestStream: false,
      responseType: Customer,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              114,
              58,
              1,
              42,
              90,
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a Cloud Identity for the given customer using the customer's
     * information, or the information provided here.
     *
     * Possible error codes:
     *
     * *  PERMISSION_DENIED:
     *      * The customer doesn't belong to the reseller.
     *      * You are not authorized to provision cloud identity id. See
     *      https://support.google.com/channelservices/answer/9759265
     * *  INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * *  NOT_FOUND: The customer was not found.
     * *  ALREADY_EXISTS: The customer's primary email already exists. Retry
     *    after changing the customer's primary contact email.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata contains an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    provisionCloudIdentity: {
      name: "ProvisionCloudIdentity",
      requestType: ProvisionCloudIdentityRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              29,
              10,
              8,
              67,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              112,
              114,
              111,
              118,
              105,
              115,
              105,
              111,
              110,
              67,
              108,
              111,
              117,
              100,
              73,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Lists [Entitlement][google.cloud.channel.v1.Entitlement]s belonging to a
     * customer.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * A list of the customer's
     * [Entitlement][google.cloud.channel.v1.Entitlement]s.
     */
    listEntitlements: {
      name: "ListEntitlements",
      requestType: ListEntitlementsRequest,
      requestStream: false,
      responseType: ListEntitlementsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * List [TransferableSku][google.cloud.channel.v1.TransferableSku]s of a
     * customer based on the Cloud Identity ID or Customer Name in the request.
     *
     * Use this method to list the entitlements information of an
     * unowned customer. You should provide the customer's
     * Cloud Identity ID or Customer Name.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The customer doesn't belong to the reseller and has no auth token.
     *     * The supplied auth token is invalid.
     *     * The reseller account making the request is different
     *     from the reseller account in the query.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * A list of the customer's
     * [TransferableSku][google.cloud.channel.v1.TransferableSku].
     */
    listTransferableSkus: {
      name: "ListTransferableSkus",
      requestType: ListTransferableSkusRequest,
      requestStream: false,
      responseType: ListTransferableSkusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              84,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              97,
              98,
              108,
              101,
              83,
              107,
              117,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * List [TransferableOffer][google.cloud.channel.v1.TransferableOffer]s of a
     * customer based on Cloud Identity ID or Customer Name in the request.
     *
     * Use this method when a reseller gets the entitlement information of an
     * unowned customer. The reseller should provide the customer's
     * Cloud Identity ID or Customer Name.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The customer doesn't belong to the reseller and has no auth token.
     *     * The customer provided incorrect reseller information when generating
     *     auth token.
     *     * The reseller account making the request is different
     *     from the reseller account in the query.
     *     * The reseller is not authorized to transact on this Product. See
     *     https://support.google.com/channelservices/answer/9759265
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * List of [TransferableOffer][google.cloud.channel.v1.TransferableOffer] for
     * the given customer and SKU.
     */
    listTransferableOffers: {
      name: "ListTransferableOffers",
      requestType: ListTransferableOffersRequest,
      requestStream: false,
      responseType: ListTransferableOffersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              84,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              97,
              98,
              108,
              101,
              79,
              102,
              102,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the requested [Entitlement][google.cloud.channel.v1.Entitlement]
     * resource.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The customer entitlement was not found.
     *
     * Return value:
     * The requested [Entitlement][google.cloud.channel.v1.Entitlement] resource.
     */
    getEntitlement: {
      name: "GetEntitlement",
      requestType: GetEntitlementRequest,
      requestStream: false,
      responseType: Entitlement,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an entitlement for a customer.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The customer doesn't belong to the reseller.
     *     * The reseller is not authorized to transact on this Product. See
     *     https://support.google.com/channelservices/answer/9759265
     * * INVALID_ARGUMENT:
     *     * Required request parameters are missing or invalid.
     *     * There is already a customer entitlement for a SKU from the same
     *     product family.
     * * INVALID_VALUE: Make sure the OfferId is valid. If it is, contact
     * Google Channel support for further troubleshooting.
     * * NOT_FOUND: The customer or offer resource was not found.
     * * ALREADY_EXISTS:
     *     * The SKU was already purchased for the customer.
     *     * The customer's primary email already exists. Retry
     *     after changing the customer's primary contact email.
     * * CONDITION_NOT_MET or FAILED_PRECONDITION:
     *     * The domain required for purchasing a SKU has not been verified.
     *     * A pre-requisite SKU required to purchase an Add-On SKU is missing.
     *     For example, Google Workspace Business Starter is required to purchase
     *     Vault or Drive.
     *     * (Developer accounts only) Reseller and resold domain must meet the
     *     following naming requirements:
     *         * Domain names must start with goog-test.
     *         * Domain names must include the reseller domain.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    createEntitlement: {
      name: "CreateEntitlement",
      requestType: CreateEntitlementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Change parameters of the entitlement.
     *
     * An entitlement update is a long-running operation and it updates the
     * entitlement as a result of fulfillment.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * For example, the number of seats being changed is greater than the allowed
     * number of max seats, or decreasing seats for a commitment based plan.
     * * NOT_FOUND: Entitlement resource not found.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    changeParameters: {
      name: "ChangeParameters",
      requestType: ChangeParametersRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              97,
              110,
              103,
              101,
              80,
              97,
              114,
              97,
              109,
              101,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the renewal settings for an existing customer entitlement.
     *
     * An entitlement update is a long-running operation and it updates the
     * entitlement as a result of fulfillment.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement resource not found.
     * * NOT_COMMITMENT_PLAN: Renewal Settings are only applicable for a
     * commitment plan. Can't enable or disable renewals for non-commitment plans.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     *   Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    changeRenewalSettings: {
      name: "ChangeRenewalSettings",
      requestType: ChangeRenewalSettingsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              97,
              110,
              103,
              101,
              82,
              101,
              110,
              101,
              119,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the Offer for an existing customer entitlement.
     *
     * An entitlement update is a long-running operation and it updates the
     * entitlement as a result of fulfillment.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Offer or Entitlement resource not found.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    changeOffer: {
      name: "ChangeOffer",
      requestType: ChangeOfferRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              97,
              110,
              103,
              101,
              79,
              102,
              102,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Starts paid service for a trial entitlement.
     *
     * Starts paid service for a trial entitlement immediately. This method is
     * only applicable if a plan is set up for a trial entitlement but has some
     * trial days remaining.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement resource not found.
     * * FAILED_PRECONDITION/NOT_IN_TRIAL: This method only works for
     * entitlement on trial plans.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    startPaidService: {
      name: "StartPaidService",
      requestType: StartPaidServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
              80,
              97,
              105,
              100,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Suspends a previously fulfilled entitlement.
     *
     * An entitlement suspension is a long-running operation.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement resource not found.
     * * NOT_ACTIVE: Entitlement is not active.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    suspendEntitlement: {
      name: "SuspendEntitlement",
      requestType: SuspendEntitlementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              117,
              115,
              112,
              101,
              110,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Cancels a previously fulfilled entitlement.
     *
     * An entitlement cancellation is a long-running operation.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * FAILED_PRECONDITION: There are Google Cloud projects linked to the
     * Google Cloud entitlement's Cloud Billing subaccount.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement resource not found.
     * * DELETION_TYPE_NOT_ALLOWED: Cancel is only allowed for Google Workspace
     * add-ons, or entitlements for Google Cloud's development platform.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The response will contain
     * google.protobuf.Empty on success. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    cancelEntitlement: {
      name: "CancelEntitlement",
      requestType: CancelEntitlementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /**
     * Activates a previously suspended entitlement. Entitlements suspended for
     * pending ToS acceptance can't be activated using this method.
     *
     * An entitlement activation is a long-running operation and it updates
     * the state of the customer entitlement.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement resource not found.
     * * SUSPENSION_NOT_RESELLER_INITIATED: Can only activate reseller-initiated
     * suspensions and entitlements that have accepted the TOS.
     * * NOT_SUSPENDED: Can only activate suspended entitlements not in an ACTIVE
     * state.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    activateEntitlement: {
      name: "ActivateEntitlement",
      requestType: ActivateEntitlementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              99,
              116,
              105,
              118,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Transfers customer entitlements to new reseller.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The customer doesn't belong to the reseller.
     *     * The reseller is not authorized to transact on this Product. See
     *     https://support.google.com/channelservices/answer/9759265
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The customer or offer resource was not found.
     * * ALREADY_EXISTS: The SKU was already transferred for the customer.
     * * CONDITION_NOT_MET or FAILED_PRECONDITION:
     *     * The SKU requires domain verification to transfer, but the domain is
     *     not verified.
     *     * An Add-On SKU (example, Vault or Drive) is missing the
     *     pre-requisite SKU (example, G Suite Basic).
     *     * (Developer accounts only) Reseller and resold domain must meet the
     *     following naming requirements:
     *         * Domain names must start with goog-test.
     *         * Domain names must include the reseller domain.
     *     * Specify all transferring entitlements.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    transferEntitlements: {
      name: "TransferEntitlements",
      requestType: TransferEntitlementsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              28,
              84,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Transfers customer entitlements from their current reseller to Google.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The customer or offer resource was not found.
     * * ALREADY_EXISTS: The SKU was already transferred for the customer.
     * * CONDITION_NOT_MET or FAILED_PRECONDITION:
     *     * The SKU requires domain verification to transfer, but the domain is
     *     not verified.
     *     * An Add-On SKU (example, Vault or Drive) is missing the
     *     pre-requisite SKU (example, G Suite Basic).
     *     * (Developer accounts only) Reseller and resold domain must meet the
     *     following naming requirements:
     *         * Domain names must start with goog-test.
     *         * Domain names must include the reseller domain.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The response will contain
     * google.protobuf.Empty on success. The Operation metadata will contain an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     */
    transferEntitlementsToGoogle: {
      name: "TransferEntitlementsToGoogle",
      requestType: TransferEntitlementsToGoogleRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              84,
              111,
              71,
              111,
              111,
              103,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * List [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s
     * belonging to a distributor. You must be a distributor to call this method.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * The list of the distributor account's
     * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resources.
     */
    listChannelPartnerLinks: {
      name: "ListChannelPartnerLinks",
      requestType: ListChannelPartnerLinksRequest,
      requestStream: false,
      responseType: ListChannelPartnerLinksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the requested
     * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
     * You must be a distributor to call this method.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: ChannelPartnerLink resource not found because of an
     * invalid channel partner link name.
     *
     * Return value:
     * The [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
     * resource.
     */
    getChannelPartnerLink: {
      name: "GetChannelPartnerLink",
      requestType: GetChannelPartnerLinkRequest,
      requestStream: false,
      responseType: ChannelPartnerLink,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Initiates a channel partner link between a distributor and a reseller, or
     * between resellers in an n-tier reseller channel.
     * Invited partners need to follow the invite_link_uri provided in the
     * response to accept. After accepting the invitation, a link is set up
     * between the two parties.
     * You must be a distributor to call this method.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * ALREADY_EXISTS: The ChannelPartnerLink sent in the request already
     * exists.
     * * NOT_FOUND: No Cloud Identity customer exists for provided domain.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The new [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
     * resource.
     */
    createChannelPartnerLink: {
      name: "CreateChannelPartnerLink",
      requestType: CreateChannelPartnerLinkRequest,
      requestStream: false,
      responseType: ChannelPartnerLink,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              67,
              58,
              20,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              108,
              105,
              110,
              107,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a channel partner link. Distributors call this method to change a
     * link's status. For example, to suspend a partner link.
     * You must be a distributor to call this method.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request is different
     * from the reseller account in the API request.
     * * INVALID_ARGUMENT:
     *     * Required request parameters are missing or invalid.
     *     * Link state cannot change from invited to active or suspended.
     *     * Cannot send reseller_cloud_identity_id, invite_url, or name in update
     *     mask.
     * * NOT_FOUND: ChannelPartnerLink resource not found.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The updated
     * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
     */
    updateChannelPartnerLink: {
      name: "UpdateChannelPartnerLink",
      requestType: UpdateChannelPartnerLinkRequest,
      requestStream: false,
      responseType: ChannelPartnerLink,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              58,
              1,
              42,
              50,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets information about how a Reseller modifies their bill before sending
     * it to a Customer.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * NOT_FOUND: The
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * was not found.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * resource, otherwise returns an error.
     */
    getCustomerRepricingConfig: {
      name: "GetCustomerRepricingConfig",
      requestType: GetCustomerRepricingConfigRequest,
      requestStream: false,
      responseType: CustomerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists information about how a Reseller modifies their bill before sending
     * it to a Customer.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * NOT_FOUND: The
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * resources. The data for each resource is displayed in the ascending order
     * of:
     *
     * * Customer ID
     * * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement]
     * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * * [CustomerRepricingConfig.update_time][google.cloud.channel.v1.CustomerRepricingConfig.update_time]
     *
     * If unsuccessful, returns an error.
     */
    listCustomerRepricingConfigs: {
      name: "ListCustomerRepricingConfigs",
      requestType: ListCustomerRepricingConfigsRequest,
      requestStream: false,
      responseType: ListCustomerRepricingConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a CustomerRepricingConfig. Call this method to set modifications
     * for a specific customer's bill. You can only create configs if the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is a future month. If needed, you can create a config for the current
     * month, with some restrictions.
     *
     * When creating a config for a future month, make sure there are no existing
     * configs for that
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     *
     * The following restrictions are for creating configs in the current month.
     *
     * * This functionality is reserved for recovering from an erroneous config,
     * and should not be used for regular business cases.
     * * The new config will not modify exports used with other configs.
     * Changes to the config may be immediate, but may take up to 24 hours.
     * * There is a limit of ten configs for any
     * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
     * for any
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     * * The contained
     * [CustomerRepricingConfig.repricing_config][google.cloud.channel.v1.CustomerRepricingConfig.repricing_config]
     * value must be different from the value used in the current config for a
     * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement].
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * INVALID_ARGUMENT: Missing or invalid required parameters in the
     * request. Also displays if the updated config is for the current month or
     * past months.
     * * NOT_FOUND: The
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the updated
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * resource, otherwise returns an error.
     */
    createCustomerRepricingConfig: {
      name: "CreateCustomerRepricingConfig",
      requestType: CreateCustomerRepricingConfigRequest,
      requestStream: false,
      responseType: CustomerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              32,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              89,
              58,
              25,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a CustomerRepricingConfig. Call this method to set modifications
     * for a specific customer's bill. This method overwrites the existing
     * CustomerRepricingConfig.
     *
     * You can only update configs if the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is a future month. To make changes to configs for the current month, use
     * [CreateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateCustomerRepricingConfig],
     * taking note of its restrictions. You cannot update the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     *
     * When updating a config in the future:
     *
     * * This config must already exist.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * INVALID_ARGUMENT: Missing or invalid required parameters in the
     * request. Also displays if the updated config is for the current month or
     * past months.
     * * NOT_FOUND: The
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the updated
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * resource, otherwise returns an error.
     */
    updateCustomerRepricingConfig: {
      name: "UpdateCustomerRepricingConfig",
      requestType: UpdateCustomerRepricingConfigRequest,
      requestStream: false,
      responseType: CustomerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              115,
              58,
              25,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              86,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the given
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * permanently. You can only delete configs if their
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is set to a date after the current month.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The account making the request does not own
     * this customer.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * FAILED_PRECONDITION: The
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * is active or in the past.
     * * NOT_FOUND: No
     * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
     * found for the name in the request.
     */
    deleteCustomerRepricingConfig: {
      name: "DeleteCustomerRepricingConfig",
      requestType: DeleteCustomerRepricingConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              42,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets information about how a Distributor modifies their bill before sending
     * it to a ChannelPartner.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * NOT_FOUND: The
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * was not found.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * resource, otherwise returns an error.
     */
    getChannelPartnerRepricingConfig: {
      name: "GetChannelPartnerRepricingConfig",
      requestType: GetChannelPartnerRepricingConfigRequest,
      requestStream: false,
      responseType: ChannelPartnerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists information about how a Reseller modifies their bill before sending
     * it to a ChannelPartner.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * NOT_FOUND: The
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * resources. The data for each resource is displayed in the ascending order
     * of:
     *
     * * Channel Partner ID
     * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * * [ChannelPartnerRepricingConfig.update_time][google.cloud.channel.v1.ChannelPartnerRepricingConfig.update_time]
     *
     * If unsuccessful, returns an error.
     */
    listChannelPartnerRepricingConfigs: {
      name: "ListChannelPartnerRepricingConfigs",
      requestType: ListChannelPartnerRepricingConfigsRequest,
      requestStream: false,
      responseType: ListChannelPartnerRepricingConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a ChannelPartnerRepricingConfig. Call this method to set
     * modifications for a specific ChannelPartner's bill. You can only create
     * configs if the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is a future month. If needed, you can create a config for the current
     * month, with some restrictions.
     *
     * When creating a config for a future month, make sure there are no existing
     * configs for that
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     *
     * The following restrictions are for creating configs in the current month.
     *
     * * This functionality is reserved for recovering from an erroneous config,
     * and should not be used for regular business cases.
     * * The new config will not modify exports used with other configs.
     * Changes to the config may be immediate, but may take up to 24 hours.
     * * There is a limit of ten configs for any ChannelPartner or
     * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
     * for any
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     * * The contained
     * [ChannelPartnerRepricingConfig.repricing_config][google.cloud.channel.v1.ChannelPartnerRepricingConfig.repricing_config]
     * value must be different from the value used in the current config for a
     * ChannelPartner.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * INVALID_ARGUMENT: Missing or invalid required parameters in the
     * request. Also displays if the updated config is for the current month or
     * past months.
     * * NOT_FOUND: The
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the updated
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * resource, otherwise returns an error.
     */
    createChannelPartnerRepricingConfig: {
      name: "CreateChannelPartnerRepricingConfig",
      requestType: CreateChannelPartnerRepricingConfigRequest,
      requestStream: false,
      responseType: ChannelPartnerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              112,
              58,
              32,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              76,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a ChannelPartnerRepricingConfig. Call this method to set
     * modifications for a specific ChannelPartner's bill. This method overwrites
     * the existing CustomerRepricingConfig.
     *
     * You can only update configs if the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is a future month. To make changes to configs for the current month, use
     * [CreateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerRepricingConfig],
     * taking note of its restrictions. You cannot update the
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
     *
     * When updating a config in the future:
     *
     * * This config must already exist.
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different.
     * * INVALID_ARGUMENT: Missing or invalid required parameters in the
     * request. Also displays if the updated config is for the current month or
     * past months.
     * * NOT_FOUND: The
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * specified does not exist or is not associated with the given account.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the updated
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * resource, otherwise returns an error.
     */
    updateChannelPartnerRepricingConfig: {
      name: "UpdateChannelPartnerRepricingConfig",
      requestType: UpdateChannelPartnerRepricingConfigRequest,
      requestStream: false,
      responseType: ChannelPartnerRepricingConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              32,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              145,
              1,
              58,
              32,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              109,
              47,
              118,
              49,
              47,
              123,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              112,
              97,
              114,
              116,
              110,
              101,
              114,
              95,
              114,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the given
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * permanently. You can only delete configs if their
     * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
     * is set to a date after the current month.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The account making the request does not own
     * this customer.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * FAILED_PRECONDITION: The
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * is active or in the past.
     * * NOT_FOUND: No
     * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
     * found for the name in the request.
     */
    deleteChannelPartnerRepricingConfig: {
      name: "DeleteChannelPartnerRepricingConfig",
      requestType: DeleteChannelPartnerRepricingConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              78,
              42,
              76,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              76,
              105,
              110,
              107,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              80,
              97,
              114,
              116,
              110,
              101,
              114,
              82,
              101,
              112,
              114,
              105,
              99,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Rebilling supported SKU groups the account is authorized to
     * sell.
     * Reference: https://cloud.google.com/skus/sku-groups
     *
     * Possible Error Codes:
     *
     * * PERMISSION_DENIED: If the account making the request and the account
     * being queried are different, or the account doesn't exist.
     * * INTERNAL: Any non-user error related to technical issues in the
     * backend. In this case, contact Cloud Channel support.
     *
     * Return Value:
     * If successful, the [SkuGroup][google.cloud.channel.v1.SkuGroup] resources.
     * The data for each resource is displayed in the alphabetical order of SKU
     * group display name.
     * The data for each resource is displayed in the ascending order of
     * [SkuGroup.display_name][google.cloud.channel.v1.SkuGroup.display_name]
     *
     * If unsuccessful, returns an error.
     */
    listSkuGroups: {
      name: "ListSkuGroups",
      requestType: ListSkuGroupsRequest,
      requestStream: false,
      responseType: ListSkuGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              107,
              117,
              71,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Billable SKUs in a given SKU group.
     *
     * Possible error codes:
     * PERMISSION_DENIED: If the account making the request and the account
     * being queried for are different, or the account doesn't exist.
     * INVALID_ARGUMENT: Missing or invalid required parameters in the
     * request.
     * INTERNAL: Any non-user error related to technical issue in the
     * backend. In this case, contact cloud channel support.
     *
     * Return Value:
     * If successful, the [BillableSku][google.cloud.channel.v1.BillableSku]
     * resources. The data for each resource is displayed in the ascending order
     * of:
     *
     * * [BillableSku.service_display_name][google.cloud.channel.v1.BillableSku.service_display_name]
     * * [BillableSku.sku_display_name][google.cloud.channel.v1.BillableSku.sku_display_name]
     *
     * If unsuccessful, returns an error.
     */
    listSkuGroupBillableSkus: {
      name: "ListSkuGroupBillableSkus",
      requestType: ListSkuGroupBillableSkusRequest,
      requestStream: false,
      responseType: ListSkuGroupBillableSkusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              115,
              107,
              117,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              98,
              105,
              108,
              108,
              97,
              98,
              108,
              101,
              83,
              107,
              117,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the requested [Offer][google.cloud.channel.v1.Offer] resource.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The entitlement doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: Entitlement or offer was not found.
     *
     * Return value:
     * The [Offer][google.cloud.channel.v1.Offer] resource.
     */
    lookupOffer: {
      name: "LookupOffer",
      requestType: LookupOfferRequest,
      requestStream: false,
      responseType: Offer,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              111,
              111,
              107,
              117,
              112,
              79,
              102,
              102,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Products the reseller is authorized to sell.
     *
     * Possible error codes:
     *
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     */
    listProducts: {
      name: "ListProducts",
      requestType: ListProductsRequest,
      requestStream: false,
      responseType: ListProductsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [Buffer.from([14, 18, 12, 47, 118, 49, 47, 112, 114, 111, 100, 117, 99, 116, 115])],
        },
      },
    },
    /**
     * Lists the SKUs for a product the reseller is authorized to sell.
     *
     * Possible error codes:
     *
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     */
    listSkus: {
      name: "ListSkus",
      requestType: ListSkusRequest,
      requestStream: false,
      responseType: ListSkusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              107,
              117,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Offers the reseller can sell.
     *
     * Possible error codes:
     *
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     */
    listOffers: {
      name: "ListOffers",
      requestType: ListOffersRequest,
      requestStream: false,
      responseType: ListOffersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              111,
              102,
              102,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the following:
     *
     * * SKUs that you can purchase for a customer
     * * SKUs that you can upgrade or downgrade for an entitlement.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     */
    listPurchasableSkus: {
      name: "ListPurchasableSkus",
      requestType: ListPurchasableSkusRequest,
      requestStream: false,
      responseType: ListPurchasableSkusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              80,
              117,
              114,
              99,
              104,
              97,
              115,
              97,
              98,
              108,
              101,
              83,
              107,
              117,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the following:
     *
     * * Offers that you can purchase for a customer.
     * * Offers that you can change for an entitlement.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED:
     *     * The customer doesn't belong to the reseller
     *     * The reseller is not authorized to transact on this Product. See
     *     https://support.google.com/channelservices/answer/9759265
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     */
    listPurchasableOffers: {
      name: "ListPurchasableOffers",
      requestType: ListPurchasableOffersRequest,
      requestStream: false,
      responseType: ListPurchasableOffersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              80,
              117,
              114,
              99,
              104,
              97,
              115,
              97,
              98,
              108,
              101,
              79,
              102,
              102,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the billing accounts that are eligible to purchase particular SKUs
     * for a given customer.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     *
     * Return value:
     * Based on the provided list of SKUs, returns a list of SKU groups that must
     * be purchased using the same billing account and the billing accounts
     * eligible to purchase each SKU group.
     */
    queryEligibleBillingAccounts: {
      name: "QueryEligibleBillingAccounts",
      requestType: QueryEligibleBillingAccountsRequest,
      requestStream: false,
      responseType: QueryEligibleBillingAccountsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
              69,
              108,
              105,
              103,
              105,
              98,
              108,
              101,
              66,
              105,
              108,
              108,
              105,
              110,
              103,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Registers a service account with subscriber privileges on the Cloud Pub/Sub
     * topic for this Channel Services account. After you create a
     * subscriber, you get the events through
     * [SubscriberEvent][google.cloud.channel.v1.SubscriberEvent]
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request and the
     * provided reseller account are different, or the impersonated user
     * is not a super admin.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The topic name with the registered service email address.
     */
    registerSubscriber: {
      name: "RegisterSubscriber",
      requestType: RegisterSubscriberRequest,
      requestStream: false,
      responseType: RegisterSubscriberResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              58,
              1,
              42,
              34,
              33,
              47,
              118,
              49,
              47,
              123,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              103,
              105,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Unregisters a service account with subscriber privileges on the Cloud
     * Pub/Sub topic created for this Channel Services account. If there are no
     * service accounts left with subscriber privileges, this deletes the topic.
     * You can call ListSubscribers to check for these accounts.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request and the
     * provided reseller account are different, or the impersonated user
     * is not a super admin.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The topic resource doesn't exist.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * The topic name that unregistered the service email address.
     * Returns a success response if the service email address wasn't registered
     * with the topic.
     */
    unregisterSubscriber: {
      name: "UnregisterSubscriber",
      requestType: UnregisterSubscriberRequest,
      requestStream: false,
      responseType: UnregisterSubscriberResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              40,
              58,
              1,
              42,
              34,
              35,
              47,
              118,
              49,
              47,
              123,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              114,
              101,
              103,
              105,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Lists service accounts with subscriber privileges on the Cloud Pub/Sub
     * topic created for this Channel Services account.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request and the
     * provided reseller account are different, or the impersonated user
     * is not a super admin.
     * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
     * * NOT_FOUND: The topic resource doesn't exist.
     * * INTERNAL: Any non-user error related to a technical issue in the
     * backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * Contact Cloud Channel support.
     *
     * Return value:
     * A list of service email addresses.
     */
    listSubscribers: {
      name: "ListSubscribers",
      requestType: ListSubscribersRequest,
      requestStream: false,
      responseType: ListSubscribersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              83,
              117,
              98,
              115,
              99,
              114,
              105,
              98,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * List entitlement history.
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The reseller account making the request and the
     * provided reseller account are different.
     * * INVALID_ARGUMENT: Missing or invalid required fields in the request.
     * * NOT_FOUND: The parent resource doesn't exist. Usually the result of an
     * invalid name parameter.
     * * INTERNAL: Any non-user error related to a technical issue in the backend.
     * In this case, contact CloudChannel support.
     * * UNKNOWN: Any non-user error related to a technical issue in the backend.
     * In this case, contact Cloud Channel support.
     *
     * Return value:
     * List of [EntitlementChange][google.cloud.channel.v1.EntitlementChange]s.
     */
    listEntitlementChanges: {
      name: "ListEntitlementChanges",
      requestType: ListEntitlementChangesRequest,
      requestStream: false,
      responseType: ListEntitlementChangesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              75,
              18,
              73,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              69,
              110,
              116,
              105,
              116,
              108,
              101,
              109,
              101,
              110,
              116,
              67,
              104,
              97,
              110,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudChannelServiceImplementation<CallContextExt = {}> {
  /**
   * List [Customer][google.cloud.channel.v1.Customer]s.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * List of [Customer][google.cloud.channel.v1.Customer]s, or an empty list if
   * there are no customers.
   */
  listCustomers(
    request: ListCustomersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCustomersResponse>>;
  /**
   * Returns the requested [Customer][google.cloud.channel.v1.Customer]
   * resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer resource doesn't exist. Usually the result of an
   * invalid name parameter.
   *
   * Return value:
   * The [Customer][google.cloud.channel.v1.Customer] resource.
   */
  getCustomer(request: GetCustomerRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Customer>>;
  /**
   * Confirms the existence of Cloud Identity accounts based on the domain and
   * if the Cloud Identity accounts are owned by the reseller.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * INVALID_VALUE: Invalid domain value in the request.
   *
   * Return value:
   * A list of
   * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
   * resources for the domain (may be empty)
   *
   * Note: in the v1alpha1 version of the API, a NOT_FOUND error returns if
   * no
   * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
   * resources match the domain.
   */
  checkCloudIdentityAccountsExist(
    request: CheckCloudIdentityAccountsExistRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckCloudIdentityAccountsExistResponse>>;
  /**
   * Creates a new [Customer][google.cloud.channel.v1.Customer] resource under
   * the reseller or distributor account.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The reseller account making the request is different from the
   *     reseller account in the API request.
   *     * You are not authorized to create a customer. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * Domain field value doesn't match the primary email domain.
   *
   * Return value:
   * The newly created [Customer][google.cloud.channel.v1.Customer] resource.
   */
  createCustomer(request: CreateCustomerRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Customer>>;
  /**
   * Updates an existing [Customer][google.cloud.channel.v1.Customer] resource
   * for the reseller or distributor.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
   * for the name in the request.
   *
   * Return value:
   * The updated [Customer][google.cloud.channel.v1.Customer] resource.
   */
  updateCustomer(request: UpdateCustomerRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Customer>>;
  /**
   * Deletes the given [Customer][google.cloud.channel.v1.Customer] permanently.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The customer has existing entitlements.
   * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
   * for the name in the request.
   */
  deleteCustomer(request: DeleteCustomerRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Imports a [Customer][google.cloud.channel.v1.Customer] from the Cloud
   * Identity associated with the provided Cloud Identity ID or domain before a
   * TransferEntitlements call. If a linked Customer already exists and
   * overwrite_if_exists is true, it will update that Customer's data.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The reseller account making the request is different from the
   *     reseller account in the API request.
   *     * You are not authorized to import the customer. See
   *     https://support.google.com/channelservices/answer/9759265
   * * NOT_FOUND: Cloud Identity doesn't exist or was deleted.
   * * INVALID_ARGUMENT: Required parameters are missing, or the auth_token is
   * expired or invalid.
   * * ALREADY_EXISTS: A customer already exists and has conflicting critical
   * fields. Requires an overwrite.
   *
   * Return value:
   * The [Customer][google.cloud.channel.v1.Customer].
   */
  importCustomer(request: ImportCustomerRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Customer>>;
  /**
   * Creates a Cloud Identity for the given customer using the customer's
   * information, or the information provided here.
   *
   * Possible error codes:
   *
   * *  PERMISSION_DENIED:
   *      * The customer doesn't belong to the reseller.
   *      * You are not authorized to provision cloud identity id. See
   *      https://support.google.com/channelservices/answer/9759265
   * *  INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * *  NOT_FOUND: The customer was not found.
   * *  ALREADY_EXISTS: The customer's primary email already exists. Retry
   *    after changing the customer's primary contact email.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata contains an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  provisionCloudIdentity(
    request: ProvisionCloudIdentityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists [Entitlement][google.cloud.channel.v1.Entitlement]s belonging to a
   * customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * A list of the customer's
   * [Entitlement][google.cloud.channel.v1.Entitlement]s.
   */
  listEntitlements(
    request: ListEntitlementsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntitlementsResponse>>;
  /**
   * List [TransferableSku][google.cloud.channel.v1.TransferableSku]s of a
   * customer based on the Cloud Identity ID or Customer Name in the request.
   *
   * Use this method to list the entitlements information of an
   * unowned customer. You should provide the customer's
   * Cloud Identity ID or Customer Name.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller and has no auth token.
   *     * The supplied auth token is invalid.
   *     * The reseller account making the request is different
   *     from the reseller account in the query.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * A list of the customer's
   * [TransferableSku][google.cloud.channel.v1.TransferableSku].
   */
  listTransferableSkus(
    request: ListTransferableSkusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTransferableSkusResponse>>;
  /**
   * List [TransferableOffer][google.cloud.channel.v1.TransferableOffer]s of a
   * customer based on Cloud Identity ID or Customer Name in the request.
   *
   * Use this method when a reseller gets the entitlement information of an
   * unowned customer. The reseller should provide the customer's
   * Cloud Identity ID or Customer Name.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller and has no auth token.
   *     * The customer provided incorrect reseller information when generating
   *     auth token.
   *     * The reseller account making the request is different
   *     from the reseller account in the query.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * List of [TransferableOffer][google.cloud.channel.v1.TransferableOffer] for
   * the given customer and SKU.
   */
  listTransferableOffers(
    request: ListTransferableOffersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTransferableOffersResponse>>;
  /**
   * Returns the requested [Entitlement][google.cloud.channel.v1.Entitlement]
   * resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer entitlement was not found.
   *
   * Return value:
   * The requested [Entitlement][google.cloud.channel.v1.Entitlement] resource.
   */
  getEntitlement(
    request: GetEntitlementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Entitlement>>;
  /**
   * Creates an entitlement for a customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * There is already a customer entitlement for a SKU from the same
   *     product family.
   * * INVALID_VALUE: Make sure the OfferId is valid. If it is, contact
   * Google Channel support for further troubleshooting.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS:
   *     * The SKU was already purchased for the customer.
   *     * The customer's primary email already exists. Retry
   *     after changing the customer's primary contact email.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The domain required for purchasing a SKU has not been verified.
   *     * A pre-requisite SKU required to purchase an Add-On SKU is missing.
   *     For example, Google Workspace Business Starter is required to purchase
   *     Vault or Drive.
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  createEntitlement(
    request: CreateEntitlementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Change parameters of the entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * For example, the number of seats being changed is greater than the allowed
   * number of max seats, or decreasing seats for a commitment based plan.
   * * NOT_FOUND: Entitlement resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeParameters(
    request: ChangeParametersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the renewal settings for an existing customer entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * NOT_COMMITMENT_PLAN: Renewal Settings are only applicable for a
   * commitment plan. Can't enable or disable renewals for non-commitment plans.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   *   Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeRenewalSettings(
    request: ChangeRenewalSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the Offer for an existing customer entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Offer or Entitlement resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeOffer(request: ChangeOfferRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Starts paid service for a trial entitlement.
   *
   * Starts paid service for a trial entitlement immediately. This method is
   * only applicable if a plan is set up for a trial entitlement but has some
   * trial days remaining.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * FAILED_PRECONDITION/NOT_IN_TRIAL: This method only works for
   * entitlement on trial plans.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  startPaidService(
    request: StartPaidServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Suspends a previously fulfilled entitlement.
   *
   * An entitlement suspension is a long-running operation.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * NOT_ACTIVE: Entitlement is not active.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  suspendEntitlement(
    request: SuspendEntitlementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Cancels a previously fulfilled entitlement.
   *
   * An entitlement cancellation is a long-running operation.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * FAILED_PRECONDITION: There are Google Cloud projects linked to the
   * Google Cloud entitlement's Cloud Billing subaccount.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * DELETION_TYPE_NOT_ALLOWED: Cancel is only allowed for Google Workspace
   * add-ons, or entitlements for Google Cloud's development platform.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The response will contain
   * google.protobuf.Empty on success. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  cancelEntitlement(
    request: CancelEntitlementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Activates a previously suspended entitlement. Entitlements suspended for
   * pending ToS acceptance can't be activated using this method.
   *
   * An entitlement activation is a long-running operation and it updates
   * the state of the customer entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * SUSPENSION_NOT_RESELLER_INITIATED: Can only activate reseller-initiated
   * suspensions and entitlements that have accepted the TOS.
   * * NOT_SUSPENDED: Can only activate suspended entitlements not in an ACTIVE
   * state.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  activateEntitlement(
    request: ActivateEntitlementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Transfers customer entitlements to new reseller.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS: The SKU was already transferred for the customer.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The SKU requires domain verification to transfer, but the domain is
   *     not verified.
   *     * An Add-On SKU (example, Vault or Drive) is missing the
   *     pre-requisite SKU (example, G Suite Basic).
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   *     * Specify all transferring entitlements.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  transferEntitlements(
    request: TransferEntitlementsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Transfers customer entitlements from their current reseller to Google.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS: The SKU was already transferred for the customer.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The SKU requires domain verification to transfer, but the domain is
   *     not verified.
   *     * An Add-On SKU (example, Vault or Drive) is missing the
   *     pre-requisite SKU (example, G Suite Basic).
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The response will contain
   * google.protobuf.Empty on success. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  transferEntitlementsToGoogle(
    request: TransferEntitlementsToGoogleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * List [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s
   * belonging to a distributor. You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * The list of the distributor account's
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resources.
   */
  listChannelPartnerLinks(
    request: ListChannelPartnerLinksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListChannelPartnerLinksResponse>>;
  /**
   * Returns the requested
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: ChannelPartnerLink resource not found because of an
   * invalid channel partner link name.
   *
   * Return value:
   * The [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
   * resource.
   */
  getChannelPartnerLink(
    request: GetChannelPartnerLinkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerLink>>;
  /**
   * Initiates a channel partner link between a distributor and a reseller, or
   * between resellers in an n-tier reseller channel.
   * Invited partners need to follow the invite_link_uri provided in the
   * response to accept. After accepting the invitation, a link is set up
   * between the two parties.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * ALREADY_EXISTS: The ChannelPartnerLink sent in the request already
   * exists.
   * * NOT_FOUND: No Cloud Identity customer exists for provided domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The new [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
   * resource.
   */
  createChannelPartnerLink(
    request: CreateChannelPartnerLinkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerLink>>;
  /**
   * Updates a channel partner link. Distributors call this method to change a
   * link's status. For example, to suspend a partner link.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * Link state cannot change from invited to active or suspended.
   *     * Cannot send reseller_cloud_identity_id, invite_url, or name in update
   *     mask.
   * * NOT_FOUND: ChannelPartnerLink resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The updated
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
   */
  updateChannelPartnerLink(
    request: UpdateChannelPartnerLinkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerLink>>;
  /**
   * Gets information about how a Reseller modifies their bill before sending
   * it to a Customer.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * was not found.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  getCustomerRepricingConfig(
    request: GetCustomerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CustomerRepricingConfig>>;
  /**
   * Lists information about how a Reseller modifies their bill before sending
   * it to a Customer.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * Customer ID
   * * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement]
   * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * * [CustomerRepricingConfig.update_time][google.cloud.channel.v1.CustomerRepricingConfig.update_time]
   *
   * If unsuccessful, returns an error.
   */
  listCustomerRepricingConfigs(
    request: ListCustomerRepricingConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCustomerRepricingConfigsResponse>>;
  /**
   * Creates a CustomerRepricingConfig. Call this method to set modifications
   * for a specific customer's bill. You can only create configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. If needed, you can create a config for the current
   * month, with some restrictions.
   *
   * When creating a config for a future month, make sure there are no existing
   * configs for that
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * The following restrictions are for creating configs in the current month.
   *
   * * This functionality is reserved for recovering from an erroneous config,
   * and should not be used for regular business cases.
   * * The new config will not modify exports used with other configs.
   * Changes to the config may be immediate, but may take up to 24 hours.
   * * There is a limit of ten configs for any
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
   * for any
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   * * The contained
   * [CustomerRepricingConfig.repricing_config][google.cloud.channel.v1.CustomerRepricingConfig.repricing_config]
   * value must be different from the value used in the current config for a
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement].
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  createCustomerRepricingConfig(
    request: CreateCustomerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CustomerRepricingConfig>>;
  /**
   * Updates a CustomerRepricingConfig. Call this method to set modifications
   * for a specific customer's bill. This method overwrites the existing
   * CustomerRepricingConfig.
   *
   * You can only update configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. To make changes to configs for the current month, use
   * [CreateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateCustomerRepricingConfig],
   * taking note of its restrictions. You cannot update the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * When updating a config in the future:
   *
   * * This config must already exist.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  updateCustomerRepricingConfig(
    request: UpdateCustomerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CustomerRepricingConfig>>;
  /**
   * Deletes the given
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * permanently. You can only delete configs if their
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is set to a date after the current month.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * is active or in the past.
   * * NOT_FOUND: No
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * found for the name in the request.
   */
  deleteCustomerRepricingConfig(
    request: DeleteCustomerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Gets information about how a Distributor modifies their bill before sending
   * it to a ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * was not found.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  getChannelPartnerRepricingConfig(
    request: GetChannelPartnerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerRepricingConfig>>;
  /**
   * Lists information about how a Reseller modifies their bill before sending
   * it to a ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * Channel Partner ID
   * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * * [ChannelPartnerRepricingConfig.update_time][google.cloud.channel.v1.ChannelPartnerRepricingConfig.update_time]
   *
   * If unsuccessful, returns an error.
   */
  listChannelPartnerRepricingConfigs(
    request: ListChannelPartnerRepricingConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListChannelPartnerRepricingConfigsResponse>>;
  /**
   * Creates a ChannelPartnerRepricingConfig. Call this method to set
   * modifications for a specific ChannelPartner's bill. You can only create
   * configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. If needed, you can create a config for the current
   * month, with some restrictions.
   *
   * When creating a config for a future month, make sure there are no existing
   * configs for that
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * The following restrictions are for creating configs in the current month.
   *
   * * This functionality is reserved for recovering from an erroneous config,
   * and should not be used for regular business cases.
   * * The new config will not modify exports used with other configs.
   * Changes to the config may be immediate, but may take up to 24 hours.
   * * There is a limit of ten configs for any ChannelPartner or
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
   * for any
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   * * The contained
   * [ChannelPartnerRepricingConfig.repricing_config][google.cloud.channel.v1.ChannelPartnerRepricingConfig.repricing_config]
   * value must be different from the value used in the current config for a
   * ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  createChannelPartnerRepricingConfig(
    request: CreateChannelPartnerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerRepricingConfig>>;
  /**
   * Updates a ChannelPartnerRepricingConfig. Call this method to set
   * modifications for a specific ChannelPartner's bill. This method overwrites
   * the existing CustomerRepricingConfig.
   *
   * You can only update configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. To make changes to configs for the current month, use
   * [CreateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerRepricingConfig],
   * taking note of its restrictions. You cannot update the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * When updating a config in the future:
   *
   * * This config must already exist.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  updateChannelPartnerRepricingConfig(
    request: UpdateChannelPartnerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ChannelPartnerRepricingConfig>>;
  /**
   * Deletes the given
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * permanently. You can only delete configs if their
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is set to a date after the current month.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * is active or in the past.
   * * NOT_FOUND: No
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * found for the name in the request.
   */
  deleteChannelPartnerRepricingConfig(
    request: DeleteChannelPartnerRepricingConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Lists the Rebilling supported SKU groups the account is authorized to
   * sell.
   * Reference: https://cloud.google.com/skus/sku-groups
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different, or the account doesn't exist.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the [SkuGroup][google.cloud.channel.v1.SkuGroup] resources.
   * The data for each resource is displayed in the alphabetical order of SKU
   * group display name.
   * The data for each resource is displayed in the ascending order of
   * [SkuGroup.display_name][google.cloud.channel.v1.SkuGroup.display_name]
   *
   * If unsuccessful, returns an error.
   */
  listSkuGroups(
    request: ListSkuGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSkuGroupsResponse>>;
  /**
   * Lists the Billable SKUs in a given SKU group.
   *
   * Possible error codes:
   * PERMISSION_DENIED: If the account making the request and the account
   * being queried for are different, or the account doesn't exist.
   * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request.
   * INTERNAL: Any non-user error related to technical issue in the
   * backend. In this case, contact cloud channel support.
   *
   * Return Value:
   * If successful, the [BillableSku][google.cloud.channel.v1.BillableSku]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * [BillableSku.service_display_name][google.cloud.channel.v1.BillableSku.service_display_name]
   * * [BillableSku.sku_display_name][google.cloud.channel.v1.BillableSku.sku_display_name]
   *
   * If unsuccessful, returns an error.
   */
  listSkuGroupBillableSkus(
    request: ListSkuGroupBillableSkusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSkuGroupBillableSkusResponse>>;
  /**
   * Returns the requested [Offer][google.cloud.channel.v1.Offer] resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The entitlement doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement or offer was not found.
   *
   * Return value:
   * The [Offer][google.cloud.channel.v1.Offer] resource.
   */
  lookupOffer(request: LookupOfferRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Offer>>;
  /**
   * Lists the Products the reseller is authorized to sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listProducts(
    request: ListProductsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProductsResponse>>;
  /**
   * Lists the SKUs for a product the reseller is authorized to sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listSkus(request: ListSkusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListSkusResponse>>;
  /**
   * Lists the Offers the reseller can sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listOffers(
    request: ListOffersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOffersResponse>>;
  /**
   * Lists the following:
   *
   * * SKUs that you can purchase for a customer
   * * SKUs that you can upgrade or downgrade for an entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listPurchasableSkus(
    request: ListPurchasableSkusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPurchasableSkusResponse>>;
  /**
   * Lists the following:
   *
   * * Offers that you can purchase for a customer.
   * * Offers that you can change for an entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listPurchasableOffers(
    request: ListPurchasableOffersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPurchasableOffersResponse>>;
  /**
   * Lists the billing accounts that are eligible to purchase particular SKUs
   * for a given customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * Based on the provided list of SKUs, returns a list of SKU groups that must
   * be purchased using the same billing account and the billing accounts
   * eligible to purchase each SKU group.
   */
  queryEligibleBillingAccounts(
    request: QueryEligibleBillingAccountsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryEligibleBillingAccountsResponse>>;
  /**
   * Registers a service account with subscriber privileges on the Cloud Pub/Sub
   * topic for this Channel Services account. After you create a
   * subscriber, you get the events through
   * [SubscriberEvent][google.cloud.channel.v1.SubscriberEvent]
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The topic name with the registered service email address.
   */
  registerSubscriber(
    request: RegisterSubscriberRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RegisterSubscriberResponse>>;
  /**
   * Unregisters a service account with subscriber privileges on the Cloud
   * Pub/Sub topic created for this Channel Services account. If there are no
   * service accounts left with subscriber privileges, this deletes the topic.
   * You can call ListSubscribers to check for these accounts.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The topic resource doesn't exist.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The topic name that unregistered the service email address.
   * Returns a success response if the service email address wasn't registered
   * with the topic.
   */
  unregisterSubscriber(
    request: UnregisterSubscriberRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UnregisterSubscriberResponse>>;
  /**
   * Lists service accounts with subscriber privileges on the Cloud Pub/Sub
   * topic created for this Channel Services account.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The topic resource doesn't exist.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * A list of service email addresses.
   */
  listSubscribers(
    request: ListSubscribersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubscribersResponse>>;
  /**
   * List entitlement history.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different.
   * * INVALID_ARGUMENT: Missing or invalid required fields in the request.
   * * NOT_FOUND: The parent resource doesn't exist. Usually the result of an
   * invalid name parameter.
   * * INTERNAL: Any non-user error related to a technical issue in the backend.
   * In this case, contact CloudChannel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * In this case, contact Cloud Channel support.
   *
   * Return value:
   * List of [EntitlementChange][google.cloud.channel.v1.EntitlementChange]s.
   */
  listEntitlementChanges(
    request: ListEntitlementChangesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntitlementChangesResponse>>;
}

export interface CloudChannelServiceClient<CallOptionsExt = {}> {
  /**
   * List [Customer][google.cloud.channel.v1.Customer]s.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * List of [Customer][google.cloud.channel.v1.Customer]s, or an empty list if
   * there are no customers.
   */
  listCustomers(
    request: DeepPartial<ListCustomersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCustomersResponse>;
  /**
   * Returns the requested [Customer][google.cloud.channel.v1.Customer]
   * resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer resource doesn't exist. Usually the result of an
   * invalid name parameter.
   *
   * Return value:
   * The [Customer][google.cloud.channel.v1.Customer] resource.
   */
  getCustomer(request: DeepPartial<GetCustomerRequest>, options?: CallOptions & CallOptionsExt): Promise<Customer>;
  /**
   * Confirms the existence of Cloud Identity accounts based on the domain and
   * if the Cloud Identity accounts are owned by the reseller.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * INVALID_VALUE: Invalid domain value in the request.
   *
   * Return value:
   * A list of
   * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
   * resources for the domain (may be empty)
   *
   * Note: in the v1alpha1 version of the API, a NOT_FOUND error returns if
   * no
   * [CloudIdentityCustomerAccount][google.cloud.channel.v1.CloudIdentityCustomerAccount]
   * resources match the domain.
   */
  checkCloudIdentityAccountsExist(
    request: DeepPartial<CheckCloudIdentityAccountsExistRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckCloudIdentityAccountsExistResponse>;
  /**
   * Creates a new [Customer][google.cloud.channel.v1.Customer] resource under
   * the reseller or distributor account.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The reseller account making the request is different from the
   *     reseller account in the API request.
   *     * You are not authorized to create a customer. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * Domain field value doesn't match the primary email domain.
   *
   * Return value:
   * The newly created [Customer][google.cloud.channel.v1.Customer] resource.
   */
  createCustomer(
    request: DeepPartial<CreateCustomerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Customer>;
  /**
   * Updates an existing [Customer][google.cloud.channel.v1.Customer] resource
   * for the reseller or distributor.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
   * for the name in the request.
   *
   * Return value:
   * The updated [Customer][google.cloud.channel.v1.Customer] resource.
   */
  updateCustomer(
    request: DeepPartial<UpdateCustomerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Customer>;
  /**
   * Deletes the given [Customer][google.cloud.channel.v1.Customer] permanently.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The customer has existing entitlements.
   * * NOT_FOUND: No [Customer][google.cloud.channel.v1.Customer] resource found
   * for the name in the request.
   */
  deleteCustomer(request: DeepPartial<DeleteCustomerRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Imports a [Customer][google.cloud.channel.v1.Customer] from the Cloud
   * Identity associated with the provided Cloud Identity ID or domain before a
   * TransferEntitlements call. If a linked Customer already exists and
   * overwrite_if_exists is true, it will update that Customer's data.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The reseller account making the request is different from the
   *     reseller account in the API request.
   *     * You are not authorized to import the customer. See
   *     https://support.google.com/channelservices/answer/9759265
   * * NOT_FOUND: Cloud Identity doesn't exist or was deleted.
   * * INVALID_ARGUMENT: Required parameters are missing, or the auth_token is
   * expired or invalid.
   * * ALREADY_EXISTS: A customer already exists and has conflicting critical
   * fields. Requires an overwrite.
   *
   * Return value:
   * The [Customer][google.cloud.channel.v1.Customer].
   */
  importCustomer(
    request: DeepPartial<ImportCustomerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Customer>;
  /**
   * Creates a Cloud Identity for the given customer using the customer's
   * information, or the information provided here.
   *
   * Possible error codes:
   *
   * *  PERMISSION_DENIED:
   *      * The customer doesn't belong to the reseller.
   *      * You are not authorized to provision cloud identity id. See
   *      https://support.google.com/channelservices/answer/9759265
   * *  INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * *  NOT_FOUND: The customer was not found.
   * *  ALREADY_EXISTS: The customer's primary email already exists. Retry
   *    after changing the customer's primary contact email.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata contains an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  provisionCloudIdentity(
    request: DeepPartial<ProvisionCloudIdentityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists [Entitlement][google.cloud.channel.v1.Entitlement]s belonging to a
   * customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * A list of the customer's
   * [Entitlement][google.cloud.channel.v1.Entitlement]s.
   */
  listEntitlements(
    request: DeepPartial<ListEntitlementsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntitlementsResponse>;
  /**
   * List [TransferableSku][google.cloud.channel.v1.TransferableSku]s of a
   * customer based on the Cloud Identity ID or Customer Name in the request.
   *
   * Use this method to list the entitlements information of an
   * unowned customer. You should provide the customer's
   * Cloud Identity ID or Customer Name.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller and has no auth token.
   *     * The supplied auth token is invalid.
   *     * The reseller account making the request is different
   *     from the reseller account in the query.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * A list of the customer's
   * [TransferableSku][google.cloud.channel.v1.TransferableSku].
   */
  listTransferableSkus(
    request: DeepPartial<ListTransferableSkusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTransferableSkusResponse>;
  /**
   * List [TransferableOffer][google.cloud.channel.v1.TransferableOffer]s of a
   * customer based on Cloud Identity ID or Customer Name in the request.
   *
   * Use this method when a reseller gets the entitlement information of an
   * unowned customer. The reseller should provide the customer's
   * Cloud Identity ID or Customer Name.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller and has no auth token.
   *     * The customer provided incorrect reseller information when generating
   *     auth token.
   *     * The reseller account making the request is different
   *     from the reseller account in the query.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * List of [TransferableOffer][google.cloud.channel.v1.TransferableOffer] for
   * the given customer and SKU.
   */
  listTransferableOffers(
    request: DeepPartial<ListTransferableOffersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTransferableOffersResponse>;
  /**
   * Returns the requested [Entitlement][google.cloud.channel.v1.Entitlement]
   * resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer entitlement was not found.
   *
   * Return value:
   * The requested [Entitlement][google.cloud.channel.v1.Entitlement] resource.
   */
  getEntitlement(
    request: DeepPartial<GetEntitlementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Entitlement>;
  /**
   * Creates an entitlement for a customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * There is already a customer entitlement for a SKU from the same
   *     product family.
   * * INVALID_VALUE: Make sure the OfferId is valid. If it is, contact
   * Google Channel support for further troubleshooting.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS:
   *     * The SKU was already purchased for the customer.
   *     * The customer's primary email already exists. Retry
   *     after changing the customer's primary contact email.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The domain required for purchasing a SKU has not been verified.
   *     * A pre-requisite SKU required to purchase an Add-On SKU is missing.
   *     For example, Google Workspace Business Starter is required to purchase
   *     Vault or Drive.
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  createEntitlement(
    request: DeepPartial<CreateEntitlementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Change parameters of the entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * For example, the number of seats being changed is greater than the allowed
   * number of max seats, or decreasing seats for a commitment based plan.
   * * NOT_FOUND: Entitlement resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeParameters(
    request: DeepPartial<ChangeParametersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the renewal settings for an existing customer entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * NOT_COMMITMENT_PLAN: Renewal Settings are only applicable for a
   * commitment plan. Can't enable or disable renewals for non-commitment plans.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   *   Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeRenewalSettings(
    request: DeepPartial<ChangeRenewalSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the Offer for an existing customer entitlement.
   *
   * An entitlement update is a long-running operation and it updates the
   * entitlement as a result of fulfillment.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Offer or Entitlement resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  changeOffer(request: DeepPartial<ChangeOfferRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Starts paid service for a trial entitlement.
   *
   * Starts paid service for a trial entitlement immediately. This method is
   * only applicable if a plan is set up for a trial entitlement but has some
   * trial days remaining.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * FAILED_PRECONDITION/NOT_IN_TRIAL: This method only works for
   * entitlement on trial plans.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  startPaidService(
    request: DeepPartial<StartPaidServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Suspends a previously fulfilled entitlement.
   *
   * An entitlement suspension is a long-running operation.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * NOT_ACTIVE: Entitlement is not active.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  suspendEntitlement(
    request: DeepPartial<SuspendEntitlementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Cancels a previously fulfilled entitlement.
   *
   * An entitlement cancellation is a long-running operation.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * FAILED_PRECONDITION: There are Google Cloud projects linked to the
   * Google Cloud entitlement's Cloud Billing subaccount.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * DELETION_TYPE_NOT_ALLOWED: Cancel is only allowed for Google Workspace
   * add-ons, or entitlements for Google Cloud's development platform.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The response will contain
   * google.protobuf.Empty on success. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  cancelEntitlement(
    request: DeepPartial<CancelEntitlementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Activates a previously suspended entitlement. Entitlements suspended for
   * pending ToS acceptance can't be activated using this method.
   *
   * An entitlement activation is a long-running operation and it updates
   * the state of the customer entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement resource not found.
   * * SUSPENSION_NOT_RESELLER_INITIATED: Can only activate reseller-initiated
   * suspensions and entitlements that have accepted the TOS.
   * * NOT_SUSPENDED: Can only activate suspended entitlements not in an ACTIVE
   * state.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  activateEntitlement(
    request: DeepPartial<ActivateEntitlementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Transfers customer entitlements to new reseller.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller.
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS: The SKU was already transferred for the customer.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The SKU requires domain verification to transfer, but the domain is
   *     not verified.
   *     * An Add-On SKU (example, Vault or Drive) is missing the
   *     pre-requisite SKU (example, G Suite Basic).
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   *     * Specify all transferring entitlements.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  transferEntitlements(
    request: DeepPartial<TransferEntitlementsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Transfers customer entitlements from their current reseller to Google.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The customer or offer resource was not found.
   * * ALREADY_EXISTS: The SKU was already transferred for the customer.
   * * CONDITION_NOT_MET or FAILED_PRECONDITION:
   *     * The SKU requires domain verification to transfer, but the domain is
   *     not verified.
   *     * An Add-On SKU (example, Vault or Drive) is missing the
   *     pre-requisite SKU (example, G Suite Basic).
   *     * (Developer accounts only) Reseller and resold domain must meet the
   *     following naming requirements:
   *         * Domain names must start with goog-test.
   *         * Domain names must include the reseller domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The response will contain
   * google.protobuf.Empty on success. The Operation metadata will contain an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   */
  transferEntitlementsToGoogle(
    request: DeepPartial<TransferEntitlementsToGoogleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * List [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]s
   * belonging to a distributor. You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * The list of the distributor account's
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resources.
   */
  listChannelPartnerLinks(
    request: DeepPartial<ListChannelPartnerLinksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListChannelPartnerLinksResponse>;
  /**
   * Returns the requested
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: ChannelPartnerLink resource not found because of an
   * invalid channel partner link name.
   *
   * Return value:
   * The [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
   * resource.
   */
  getChannelPartnerLink(
    request: DeepPartial<GetChannelPartnerLinkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerLink>;
  /**
   * Initiates a channel partner link between a distributor and a reseller, or
   * between resellers in an n-tier reseller channel.
   * Invited partners need to follow the invite_link_uri provided in the
   * response to accept. After accepting the invitation, a link is set up
   * between the two parties.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * ALREADY_EXISTS: The ChannelPartnerLink sent in the request already
   * exists.
   * * NOT_FOUND: No Cloud Identity customer exists for provided domain.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The new [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink]
   * resource.
   */
  createChannelPartnerLink(
    request: DeepPartial<CreateChannelPartnerLinkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerLink>;
  /**
   * Updates a channel partner link. Distributors call this method to change a
   * link's status. For example, to suspend a partner link.
   * You must be a distributor to call this method.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request is different
   * from the reseller account in the API request.
   * * INVALID_ARGUMENT:
   *     * Required request parameters are missing or invalid.
   *     * Link state cannot change from invited to active or suspended.
   *     * Cannot send reseller_cloud_identity_id, invite_url, or name in update
   *     mask.
   * * NOT_FOUND: ChannelPartnerLink resource not found.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The updated
   * [ChannelPartnerLink][google.cloud.channel.v1.ChannelPartnerLink] resource.
   */
  updateChannelPartnerLink(
    request: DeepPartial<UpdateChannelPartnerLinkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerLink>;
  /**
   * Gets information about how a Reseller modifies their bill before sending
   * it to a Customer.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * was not found.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  getCustomerRepricingConfig(
    request: DeepPartial<GetCustomerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CustomerRepricingConfig>;
  /**
   * Lists information about how a Reseller modifies their bill before sending
   * it to a Customer.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * Customer ID
   * * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement]
   * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * * [CustomerRepricingConfig.update_time][google.cloud.channel.v1.CustomerRepricingConfig.update_time]
   *
   * If unsuccessful, returns an error.
   */
  listCustomerRepricingConfigs(
    request: DeepPartial<ListCustomerRepricingConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCustomerRepricingConfigsResponse>;
  /**
   * Creates a CustomerRepricingConfig. Call this method to set modifications
   * for a specific customer's bill. You can only create configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. If needed, you can create a config for the current
   * month, with some restrictions.
   *
   * When creating a config for a future month, make sure there are no existing
   * configs for that
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * The following restrictions are for creating configs in the current month.
   *
   * * This functionality is reserved for recovering from an erroneous config,
   * and should not be used for regular business cases.
   * * The new config will not modify exports used with other configs.
   * Changes to the config may be immediate, but may take up to 24 hours.
   * * There is a limit of ten configs for any
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
   * for any
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   * * The contained
   * [CustomerRepricingConfig.repricing_config][google.cloud.channel.v1.CustomerRepricingConfig.repricing_config]
   * value must be different from the value used in the current config for a
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement].
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  createCustomerRepricingConfig(
    request: DeepPartial<CreateCustomerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CustomerRepricingConfig>;
  /**
   * Updates a CustomerRepricingConfig. Call this method to set modifications
   * for a specific customer's bill. This method overwrites the existing
   * CustomerRepricingConfig.
   *
   * You can only update configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. To make changes to configs for the current month, use
   * [CreateCustomerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateCustomerRepricingConfig],
   * taking note of its restrictions. You cannot update the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * When updating a config in the future:
   *
   * * This config must already exist.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * resource, otherwise returns an error.
   */
  updateCustomerRepricingConfig(
    request: DeepPartial<UpdateCustomerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CustomerRepricingConfig>;
  /**
   * Deletes the given
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * permanently. You can only delete configs if their
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is set to a date after the current month.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * is active or in the past.
   * * NOT_FOUND: No
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * found for the name in the request.
   */
  deleteCustomerRepricingConfig(
    request: DeepPartial<DeleteCustomerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Gets information about how a Distributor modifies their bill before sending
   * it to a ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * was not found.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  getChannelPartnerRepricingConfig(
    request: DeepPartial<GetChannelPartnerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerRepricingConfig>;
  /**
   * Lists information about how a Reseller modifies their bill before sending
   * it to a ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * Channel Partner ID
   * * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * * [ChannelPartnerRepricingConfig.update_time][google.cloud.channel.v1.ChannelPartnerRepricingConfig.update_time]
   *
   * If unsuccessful, returns an error.
   */
  listChannelPartnerRepricingConfigs(
    request: DeepPartial<ListChannelPartnerRepricingConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListChannelPartnerRepricingConfigsResponse>;
  /**
   * Creates a ChannelPartnerRepricingConfig. Call this method to set
   * modifications for a specific ChannelPartner's bill. You can only create
   * configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. If needed, you can create a config for the current
   * month, with some restrictions.
   *
   * When creating a config for a future month, make sure there are no existing
   * configs for that
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * The following restrictions are for creating configs in the current month.
   *
   * * This functionality is reserved for recovering from an erroneous config,
   * and should not be used for regular business cases.
   * * The new config will not modify exports used with other configs.
   * Changes to the config may be immediate, but may take up to 24 hours.
   * * There is a limit of ten configs for any ChannelPartner or
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement],
   * for any
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   * * The contained
   * [ChannelPartnerRepricingConfig.repricing_config][google.cloud.channel.v1.ChannelPartnerRepricingConfig.repricing_config]
   * value must be different from the value used in the current config for a
   * ChannelPartner.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  createChannelPartnerRepricingConfig(
    request: DeepPartial<CreateChannelPartnerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerRepricingConfig>;
  /**
   * Updates a ChannelPartnerRepricingConfig. Call this method to set
   * modifications for a specific ChannelPartner's bill. This method overwrites
   * the existing CustomerRepricingConfig.
   *
   * You can only update configs if the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is a future month. To make changes to configs for the current month, use
   * [CreateChannelPartnerRepricingConfig][google.cloud.channel.v1.CloudChannelService.CreateChannelPartnerRepricingConfig],
   * taking note of its restrictions. You cannot update the
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month].
   *
   * When updating a config in the future:
   *
   * * This config must already exist.
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different.
   * * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request. Also displays if the updated config is for the current month or
   * past months.
   * * NOT_FOUND: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * specified does not exist or is not associated with the given account.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the updated
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * resource, otherwise returns an error.
   */
  updateChannelPartnerRepricingConfig(
    request: DeepPartial<UpdateChannelPartnerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ChannelPartnerRepricingConfig>;
  /**
   * Deletes the given
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * permanently. You can only delete configs if their
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * is set to a date after the current month.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The account making the request does not own
   * this customer.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * FAILED_PRECONDITION: The
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * is active or in the past.
   * * NOT_FOUND: No
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * found for the name in the request.
   */
  deleteChannelPartnerRepricingConfig(
    request: DeepPartial<DeleteChannelPartnerRepricingConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Lists the Rebilling supported SKU groups the account is authorized to
   * sell.
   * Reference: https://cloud.google.com/skus/sku-groups
   *
   * Possible Error Codes:
   *
   * * PERMISSION_DENIED: If the account making the request and the account
   * being queried are different, or the account doesn't exist.
   * * INTERNAL: Any non-user error related to technical issues in the
   * backend. In this case, contact Cloud Channel support.
   *
   * Return Value:
   * If successful, the [SkuGroup][google.cloud.channel.v1.SkuGroup] resources.
   * The data for each resource is displayed in the alphabetical order of SKU
   * group display name.
   * The data for each resource is displayed in the ascending order of
   * [SkuGroup.display_name][google.cloud.channel.v1.SkuGroup.display_name]
   *
   * If unsuccessful, returns an error.
   */
  listSkuGroups(
    request: DeepPartial<ListSkuGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSkuGroupsResponse>;
  /**
   * Lists the Billable SKUs in a given SKU group.
   *
   * Possible error codes:
   * PERMISSION_DENIED: If the account making the request and the account
   * being queried for are different, or the account doesn't exist.
   * INVALID_ARGUMENT: Missing or invalid required parameters in the
   * request.
   * INTERNAL: Any non-user error related to technical issue in the
   * backend. In this case, contact cloud channel support.
   *
   * Return Value:
   * If successful, the [BillableSku][google.cloud.channel.v1.BillableSku]
   * resources. The data for each resource is displayed in the ascending order
   * of:
   *
   * * [BillableSku.service_display_name][google.cloud.channel.v1.BillableSku.service_display_name]
   * * [BillableSku.sku_display_name][google.cloud.channel.v1.BillableSku.sku_display_name]
   *
   * If unsuccessful, returns an error.
   */
  listSkuGroupBillableSkus(
    request: DeepPartial<ListSkuGroupBillableSkusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSkuGroupBillableSkusResponse>;
  /**
   * Returns the requested [Offer][google.cloud.channel.v1.Offer] resource.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The entitlement doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: Entitlement or offer was not found.
   *
   * Return value:
   * The [Offer][google.cloud.channel.v1.Offer] resource.
   */
  lookupOffer(request: DeepPartial<LookupOfferRequest>, options?: CallOptions & CallOptionsExt): Promise<Offer>;
  /**
   * Lists the Products the reseller is authorized to sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listProducts(
    request: DeepPartial<ListProductsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProductsResponse>;
  /**
   * Lists the SKUs for a product the reseller is authorized to sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listSkus(request: DeepPartial<ListSkusRequest>, options?: CallOptions & CallOptionsExt): Promise<ListSkusResponse>;
  /**
   * Lists the Offers the reseller can sell.
   *
   * Possible error codes:
   *
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listOffers(
    request: DeepPartial<ListOffersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOffersResponse>;
  /**
   * Lists the following:
   *
   * * SKUs that you can purchase for a customer
   * * SKUs that you can upgrade or downgrade for an entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listPurchasableSkus(
    request: DeepPartial<ListPurchasableSkusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPurchasableSkusResponse>;
  /**
   * Lists the following:
   *
   * * Offers that you can purchase for a customer.
   * * Offers that you can change for an entitlement.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED:
   *     * The customer doesn't belong to the reseller
   *     * The reseller is not authorized to transact on this Product. See
   *     https://support.google.com/channelservices/answer/9759265
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   */
  listPurchasableOffers(
    request: DeepPartial<ListPurchasableOffersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPurchasableOffersResponse>;
  /**
   * Lists the billing accounts that are eligible to purchase particular SKUs
   * for a given customer.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The customer doesn't belong to the reseller.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   *
   * Return value:
   * Based on the provided list of SKUs, returns a list of SKU groups that must
   * be purchased using the same billing account and the billing accounts
   * eligible to purchase each SKU group.
   */
  queryEligibleBillingAccounts(
    request: DeepPartial<QueryEligibleBillingAccountsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryEligibleBillingAccountsResponse>;
  /**
   * Registers a service account with subscriber privileges on the Cloud Pub/Sub
   * topic for this Channel Services account. After you create a
   * subscriber, you get the events through
   * [SubscriberEvent][google.cloud.channel.v1.SubscriberEvent]
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The topic name with the registered service email address.
   */
  registerSubscriber(
    request: DeepPartial<RegisterSubscriberRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RegisterSubscriberResponse>;
  /**
   * Unregisters a service account with subscriber privileges on the Cloud
   * Pub/Sub topic created for this Channel Services account. If there are no
   * service accounts left with subscriber privileges, this deletes the topic.
   * You can call ListSubscribers to check for these accounts.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The topic resource doesn't exist.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * The topic name that unregistered the service email address.
   * Returns a success response if the service email address wasn't registered
   * with the topic.
   */
  unregisterSubscriber(
    request: DeepPartial<UnregisterSubscriberRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UnregisterSubscriberResponse>;
  /**
   * Lists service accounts with subscriber privileges on the Cloud Pub/Sub
   * topic created for this Channel Services account.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different, or the impersonated user
   * is not a super admin.
   * * INVALID_ARGUMENT: Required request parameters are missing or invalid.
   * * NOT_FOUND: The topic resource doesn't exist.
   * * INTERNAL: Any non-user error related to a technical issue in the
   * backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * Contact Cloud Channel support.
   *
   * Return value:
   * A list of service email addresses.
   */
  listSubscribers(
    request: DeepPartial<ListSubscribersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubscribersResponse>;
  /**
   * List entitlement history.
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The reseller account making the request and the
   * provided reseller account are different.
   * * INVALID_ARGUMENT: Missing or invalid required fields in the request.
   * * NOT_FOUND: The parent resource doesn't exist. Usually the result of an
   * invalid name parameter.
   * * INTERNAL: Any non-user error related to a technical issue in the backend.
   * In this case, contact CloudChannel support.
   * * UNKNOWN: Any non-user error related to a technical issue in the backend.
   * In this case, contact Cloud Channel support.
   *
   * Return value:
   * List of [EntitlementChange][google.cloud.channel.v1.EntitlementChange]s.
   */
  listEntitlementChanges(
    request: DeepPartial<ListEntitlementChangesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntitlementChangesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
