// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/kms/v1/autokey_admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";

export const protobufPackage = "google.cloud.kms.v1";

/**
 * Request message for
 * [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig].
 */
export interface UpdateAutokeyConfigRequest {
  /**
   * Required. [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] with values to
   * update.
   */
  autokeyConfig:
    | AutokeyConfig
    | undefined;
  /**
   * Required. Masks which fields of the
   * [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] to update, e.g.
   * `keyProject`.
   */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [GetAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.GetAutokeyConfig].
 */
export interface GetAutokeyConfigRequest {
  /**
   * Required. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
   * resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
   */
  name: string;
}

/** Cloud KMS Autokey configuration for a folder. */
export interface AutokeyConfig {
  /**
   * Identifier. Name of the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig]
   * resource, e.g. `folders/{FOLDER_NUMBER}/autokeyConfig`.
   */
  name: string;
  /**
   * Optional. Name of the key project, e.g. `projects/{PROJECT_ID}` or
   * `projects/{PROJECT_NUMBER}`, where Cloud KMS Autokey will provision a new
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] when a
   * [KeyHandle][google.cloud.kms.v1.KeyHandle] is created. On
   * [UpdateAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.UpdateAutokeyConfig],
   * the caller will require `cloudkms.cryptoKeys.setIamPolicy` permission on
   * this key project. Once configured, for Cloud KMS Autokey to function
   * properly, this key project must have the Cloud KMS API activated and the
   * Cloud KMS Service Agent for this key project must be granted the
   * `cloudkms.admin` role (or pertinent permissions). A request with an empty
   * key project field will clear the configuration.
   */
  keyProject: string;
  /** Output only. The state for the AutokeyConfig. */
  state: AutokeyConfig_State;
}

/** The states AutokeyConfig can be in. */
export enum AutokeyConfig_State {
  /** STATE_UNSPECIFIED - The state of the AutokeyConfig is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The AutokeyConfig is currently active. */
  ACTIVE = 1,
  /**
   * KEY_PROJECT_DELETED - A previously configured key project has been deleted and the current
   * AutokeyConfig is unusable.
   */
  KEY_PROJECT_DELETED = 2,
  /**
   * UNINITIALIZED - The AutokeyConfig is not yet initialized or has been reset to its default
   * uninitialized state.
   */
  UNINITIALIZED = 3,
  UNRECOGNIZED = -1,
}

export function autokeyConfig_StateFromJSON(object: any): AutokeyConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AutokeyConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return AutokeyConfig_State.ACTIVE;
    case 2:
    case "KEY_PROJECT_DELETED":
      return AutokeyConfig_State.KEY_PROJECT_DELETED;
    case 3:
    case "UNINITIALIZED":
      return AutokeyConfig_State.UNINITIALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutokeyConfig_State.UNRECOGNIZED;
  }
}

export function autokeyConfig_StateToJSON(object: AutokeyConfig_State): string {
  switch (object) {
    case AutokeyConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AutokeyConfig_State.ACTIVE:
      return "ACTIVE";
    case AutokeyConfig_State.KEY_PROJECT_DELETED:
      return "KEY_PROJECT_DELETED";
    case AutokeyConfig_State.UNINITIALIZED:
      return "UNINITIALIZED";
    case AutokeyConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request message for
 * [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
 */
export interface ShowEffectiveAutokeyConfigRequest {
  /**
   * Required. Name of the resource project to the show effective Cloud KMS
   * Autokey configuration for. This may be helpful for interrogating the effect
   * of nested folder configurations on a given resource project.
   */
  parent: string;
}

/**
 * Response message for
 * [ShowEffectiveAutokeyConfig][google.cloud.kms.v1.AutokeyAdmin.ShowEffectiveAutokeyConfig].
 */
export interface ShowEffectiveAutokeyConfigResponse {
  /**
   * Name of the key project configured in the resource project's folder
   * ancestry.
   */
  keyProject: string;
}

function createBaseUpdateAutokeyConfigRequest(): UpdateAutokeyConfigRequest {
  return { autokeyConfig: undefined, updateMask: undefined };
}

export const UpdateAutokeyConfigRequest: MessageFns<UpdateAutokeyConfigRequest> = {
  encode(message: UpdateAutokeyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autokeyConfig !== undefined) {
      AutokeyConfig.encode(message.autokeyConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAutokeyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAutokeyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.autokeyConfig = AutokeyConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAutokeyConfigRequest {
    return {
      autokeyConfig: isSet(object.autokeyConfig) ? AutokeyConfig.fromJSON(object.autokeyConfig) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAutokeyConfigRequest): unknown {
    const obj: any = {};
    if (message.autokeyConfig !== undefined) {
      obj.autokeyConfig = AutokeyConfig.toJSON(message.autokeyConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAutokeyConfigRequest>): UpdateAutokeyConfigRequest {
    return UpdateAutokeyConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAutokeyConfigRequest>): UpdateAutokeyConfigRequest {
    const message = createBaseUpdateAutokeyConfigRequest();
    message.autokeyConfig = (object.autokeyConfig !== undefined && object.autokeyConfig !== null)
      ? AutokeyConfig.fromPartial(object.autokeyConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetAutokeyConfigRequest(): GetAutokeyConfigRequest {
  return { name: "" };
}

export const GetAutokeyConfigRequest: MessageFns<GetAutokeyConfigRequest> = {
  encode(message: GetAutokeyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutokeyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutokeyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutokeyConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAutokeyConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutokeyConfigRequest>): GetAutokeyConfigRequest {
    return GetAutokeyConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutokeyConfigRequest>): GetAutokeyConfigRequest {
    const message = createBaseGetAutokeyConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAutokeyConfig(): AutokeyConfig {
  return { name: "", keyProject: "", state: 0 };
}

export const AutokeyConfig: MessageFns<AutokeyConfig> = {
  encode(message: AutokeyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.keyProject !== "") {
      writer.uint32(18).string(message.keyProject);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutokeyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutokeyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyProject = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutokeyConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      keyProject: isSet(object.keyProject) ? globalThis.String(object.keyProject) : "",
      state: isSet(object.state) ? autokeyConfig_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: AutokeyConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.keyProject !== "") {
      obj.keyProject = message.keyProject;
    }
    if (message.state !== 0) {
      obj.state = autokeyConfig_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<AutokeyConfig>): AutokeyConfig {
    return AutokeyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutokeyConfig>): AutokeyConfig {
    const message = createBaseAutokeyConfig();
    message.name = object.name ?? "";
    message.keyProject = object.keyProject ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseShowEffectiveAutokeyConfigRequest(): ShowEffectiveAutokeyConfigRequest {
  return { parent: "" };
}

export const ShowEffectiveAutokeyConfigRequest: MessageFns<ShowEffectiveAutokeyConfigRequest> = {
  encode(message: ShowEffectiveAutokeyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowEffectiveAutokeyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowEffectiveAutokeyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowEffectiveAutokeyConfigRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: ShowEffectiveAutokeyConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowEffectiveAutokeyConfigRequest>): ShowEffectiveAutokeyConfigRequest {
    return ShowEffectiveAutokeyConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowEffectiveAutokeyConfigRequest>): ShowEffectiveAutokeyConfigRequest {
    const message = createBaseShowEffectiveAutokeyConfigRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseShowEffectiveAutokeyConfigResponse(): ShowEffectiveAutokeyConfigResponse {
  return { keyProject: "" };
}

export const ShowEffectiveAutokeyConfigResponse: MessageFns<ShowEffectiveAutokeyConfigResponse> = {
  encode(message: ShowEffectiveAutokeyConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyProject !== "") {
      writer.uint32(10).string(message.keyProject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowEffectiveAutokeyConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowEffectiveAutokeyConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyProject = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowEffectiveAutokeyConfigResponse {
    return { keyProject: isSet(object.keyProject) ? globalThis.String(object.keyProject) : "" };
  },

  toJSON(message: ShowEffectiveAutokeyConfigResponse): unknown {
    const obj: any = {};
    if (message.keyProject !== "") {
      obj.keyProject = message.keyProject;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowEffectiveAutokeyConfigResponse>): ShowEffectiveAutokeyConfigResponse {
    return ShowEffectiveAutokeyConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowEffectiveAutokeyConfigResponse>): ShowEffectiveAutokeyConfigResponse {
    const message = createBaseShowEffectiveAutokeyConfigResponse();
    message.keyProject = object.keyProject ?? "";
    return message;
  },
};

/**
 * Provides interfaces for managing [Cloud KMS
 * Autokey](https://cloud.google.com/kms/help/autokey) folder-level
 * configurations. A configuration is inherited by all descendent projects. A
 * configuration at one folder overrides any other configurations in its
 * ancestry. Setting a configuration on a folder is a prerequisite for Cloud KMS
 * Autokey, so that users working in a descendant project can request
 * provisioned [CryptoKeys][google.cloud.kms.v1.CryptoKey], ready for Customer
 * Managed Encryption Key (CMEK) use, on-demand.
 */
export type AutokeyAdminDefinition = typeof AutokeyAdminDefinition;
export const AutokeyAdminDefinition = {
  name: "AutokeyAdmin",
  fullName: "google.cloud.kms.v1.AutokeyAdmin",
  methods: {
    /**
     * Updates the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
     * folder. The caller must have both `cloudkms.autokeyConfigs.update`
     * permission on the parent folder and `cloudkms.cryptoKeys.setIamPolicy`
     * permission on the provided key project. A
     * [KeyHandle][google.cloud.kms.v1.KeyHandle] creation in the folder's
     * descendant projects will use this configuration to determine where to
     * create the resulting [CryptoKey][google.cloud.kms.v1.CryptoKey].
     */
    updateAutokeyConfig: {
      name: "UpdateAutokeyConfig",
      requestType: UpdateAutokeyConfigRequest,
      requestStream: false,
      responseType: AutokeyConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              97,
              117,
              116,
              111,
              107,
              101,
              121,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              14,
              97,
              117,
              116,
              111,
              107,
              101,
              121,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              49,
              47,
              118,
              49,
              47,
              123,
              97,
              117,
              116,
              111,
              107,
              101,
              121,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              107,
              101,
              121,
              67,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
     * folder.
     */
    getAutokeyConfig: {
      name: "GetAutokeyConfig",
      requestType: GetAutokeyConfigRequest,
      requestStream: false,
      responseType: AutokeyConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              107,
              101,
              121,
              67,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the effective Cloud KMS Autokey configuration for a given project. */
    showEffectiveAutokeyConfig: {
      name: "ShowEffectiveAutokeyConfig",
      requestType: ShowEffectiveAutokeyConfigRequest,
      requestStream: false,
      responseType: ShowEffectiveAutokeyConfigResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              104,
              111,
              119,
              69,
              102,
              102,
              101,
              99,
              116,
              105,
              118,
              101,
              65,
              117,
              116,
              111,
              107,
              101,
              121,
              67,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AutokeyAdminServiceImplementation<CallContextExt = {}> {
  /**
   * Updates the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
   * folder. The caller must have both `cloudkms.autokeyConfigs.update`
   * permission on the parent folder and `cloudkms.cryptoKeys.setIamPolicy`
   * permission on the provided key project. A
   * [KeyHandle][google.cloud.kms.v1.KeyHandle] creation in the folder's
   * descendant projects will use this configuration to determine where to
   * create the resulting [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  updateAutokeyConfig(
    request: UpdateAutokeyConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AutokeyConfig>>;
  /**
   * Returns the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
   * folder.
   */
  getAutokeyConfig(
    request: GetAutokeyConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AutokeyConfig>>;
  /** Returns the effective Cloud KMS Autokey configuration for a given project. */
  showEffectiveAutokeyConfig(
    request: ShowEffectiveAutokeyConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ShowEffectiveAutokeyConfigResponse>>;
}

export interface AutokeyAdminClient<CallOptionsExt = {}> {
  /**
   * Updates the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
   * folder. The caller must have both `cloudkms.autokeyConfigs.update`
   * permission on the parent folder and `cloudkms.cryptoKeys.setIamPolicy`
   * permission on the provided key project. A
   * [KeyHandle][google.cloud.kms.v1.KeyHandle] creation in the folder's
   * descendant projects will use this configuration to determine where to
   * create the resulting [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  updateAutokeyConfig(
    request: DeepPartial<UpdateAutokeyConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AutokeyConfig>;
  /**
   * Returns the [AutokeyConfig][google.cloud.kms.v1.AutokeyConfig] for a
   * folder.
   */
  getAutokeyConfig(
    request: DeepPartial<GetAutokeyConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AutokeyConfig>;
  /** Returns the effective Cloud KMS Autokey configuration for a given project. */
  showEffectiveAutokeyConfig(
    request: DeepPartial<ShowEffectiveAutokeyConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ShowEffectiveAutokeyConfigResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
