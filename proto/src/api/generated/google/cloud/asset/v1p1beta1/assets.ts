// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/asset/v1p1beta1/assets.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Policy } from "../../../iam/v1/policy.js";

export const protobufPackage = "google.cloud.asset.v1p1beta1";

/** The standard metadata of a cloud resource. */
export interface StandardResourceMetadata {
  /**
   * The full resource name. For example:
   * `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
   * See [Resource
   * Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
   * for more information.
   */
  name: string;
  /**
   * The type of this resource.
   * For example: "compute.googleapis.com/Disk".
   */
  assetType: string;
  /**
   * The project that this resource belongs to, in the form of
   * `projects/{project_number}`.
   */
  project: string;
  /** The display name of this resource. */
  displayName: string;
  /**
   * One or more paragraphs of text description of this resource. Maximum length
   * could be up to 1M bytes.
   */
  description: string;
  /**
   * Additional searchable attributes of this resource.
   * Informational only. The exact set of attributes is subject to change.
   * For example: project id, DNS name etc.
   */
  additionalAttributes: string[];
  /**
   * Location can be "global", regional like "us-east1", or zonal like
   * "us-west1-b".
   */
  location: string;
  /**
   * Labels associated with this resource. See [Labelling and grouping Google
   * Cloud
   * resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
   * for more information.
   */
  labels: { [key: string]: string };
  /**
   * Network tags associated with this resource. Like labels, network tags are a
   * type of annotations used to group Google Cloud resources. See [Labelling
   * Google Cloud
   * resources](lhttps://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
   * for more information.
   */
  networkTags: string[];
}

export interface StandardResourceMetadata_LabelsEntry {
  key: string;
  value: string;
}

/** The result for an IAM policy search. */
export interface IamPolicySearchResult {
  /**
   * The
   * [full resource
   * name](https://cloud.google.com/apis/design/resource_names#full_resource_name)
   * of the resource associated with this IAM policy.
   */
  resource: string;
  /**
   * The project that the associated Google Cloud resource belongs to, in the
   * form of `projects/{project_number}`. If an IAM policy is set on a resource
   * -- such as a Compute Engine instance or a Cloud Storage bucket -- the
   * project field will indicate the project that contains the resource. If an
   * IAM policy is set on a folder or orgnization, the project field will be
   * empty.
   */
  project: string;
  /**
   * The IAM policy attached to the specified resource. Note that the original
   * IAM policy can contain multiple bindings. This only contains the bindings
   * that match the given query. For queries that don't contain a constraint on
   * policies (e.g. an empty query), this contains all the bindings.
   */
  policy:
    | Policy
    | undefined;
  /**
   * Explanation about the IAM policy search result. It contains additional
   * information that explains why the search result matches the query.
   */
  explanation: IamPolicySearchResult_Explanation | undefined;
}

/** Explanation about the IAM policy search result. */
export interface IamPolicySearchResult_Explanation {
  /**
   * The map from roles to their included permission matching the permission
   * query (e.g. containing `policy.role.permissions:`). Example role string:
   * "roles/compute.instanceAdmin". The roles can also be found in the
   * returned `policy` bindings. Note that the map is populated only if
   * requesting with a permission query.
   */
  matchedPermissions: { [key: string]: Permissions };
}

export interface IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
  key: string;
  value: Permissions | undefined;
}

/** IAM permissions. */
export interface Permissions {
  /** A list of permissions. Example permission string: "compute.disk.get". */
  permissions: string[];
}

function createBaseStandardResourceMetadata(): StandardResourceMetadata {
  return {
    name: "",
    assetType: "",
    project: "",
    displayName: "",
    description: "",
    additionalAttributes: [],
    location: "",
    labels: {},
    networkTags: [],
  };
}

export const StandardResourceMetadata: MessageFns<StandardResourceMetadata> = {
  encode(message: StandardResourceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assetType !== "") {
      writer.uint32(18).string(message.assetType);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.additionalAttributes) {
      writer.uint32(82).string(v!);
    }
    if (message.location !== "") {
      writer.uint32(90).string(message.location);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      StandardResourceMetadata_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    for (const v of message.networkTags) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardResourceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardResourceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.additionalAttributes.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.location = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = StandardResourceMetadata_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardResourceMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      additionalAttributes: globalThis.Array.isArray(object?.additionalAttributes)
        ? object.additionalAttributes.map((e: any) => globalThis.String(e))
        : [],
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StandardResourceMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.additionalAttributes?.length) {
      obj.additionalAttributes = message.additionalAttributes;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    return obj;
  },

  create(base?: DeepPartial<StandardResourceMetadata>): StandardResourceMetadata {
    return StandardResourceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardResourceMetadata>): StandardResourceMetadata {
    const message = createBaseStandardResourceMetadata();
    message.name = object.name ?? "";
    message.assetType = object.assetType ?? "";
    message.project = object.project ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.additionalAttributes = object.additionalAttributes?.map((e) => e) || [];
    message.location = object.location ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.networkTags = object.networkTags?.map((e) => e) || [];
    return message;
  },
};

function createBaseStandardResourceMetadata_LabelsEntry(): StandardResourceMetadata_LabelsEntry {
  return { key: "", value: "" };
}

export const StandardResourceMetadata_LabelsEntry: MessageFns<StandardResourceMetadata_LabelsEntry> = {
  encode(message: StandardResourceMetadata_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardResourceMetadata_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardResourceMetadata_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardResourceMetadata_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StandardResourceMetadata_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StandardResourceMetadata_LabelsEntry>): StandardResourceMetadata_LabelsEntry {
    return StandardResourceMetadata_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardResourceMetadata_LabelsEntry>): StandardResourceMetadata_LabelsEntry {
    const message = createBaseStandardResourceMetadata_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIamPolicySearchResult(): IamPolicySearchResult {
  return { resource: "", project: "", policy: undefined, explanation: undefined };
}

export const IamPolicySearchResult: MessageFns<IamPolicySearchResult> = {
  encode(message: IamPolicySearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(34).fork()).join();
    }
    if (message.explanation !== undefined) {
      IamPolicySearchResult_Explanation.encode(message.explanation, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.explanation = IamPolicySearchResult_Explanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      explanation: isSet(object.explanation)
        ? IamPolicySearchResult_Explanation.fromJSON(object.explanation)
        : undefined,
    };
  },

  toJSON(message: IamPolicySearchResult): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.explanation !== undefined) {
      obj.explanation = IamPolicySearchResult_Explanation.toJSON(message.explanation);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicySearchResult>): IamPolicySearchResult {
    return IamPolicySearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicySearchResult>): IamPolicySearchResult {
    const message = createBaseIamPolicySearchResult();
    message.resource = object.resource ?? "";
    message.project = object.project ?? "";
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.explanation = (object.explanation !== undefined && object.explanation !== null)
      ? IamPolicySearchResult_Explanation.fromPartial(object.explanation)
      : undefined;
    return message;
  },
};

function createBaseIamPolicySearchResult_Explanation(): IamPolicySearchResult_Explanation {
  return { matchedPermissions: {} };
}

export const IamPolicySearchResult_Explanation: MessageFns<IamPolicySearchResult_Explanation> = {
  encode(message: IamPolicySearchResult_Explanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.matchedPermissions).forEach(([key, value]) => {
      IamPolicySearchResult_Explanation_MatchedPermissionsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult_Explanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult_Explanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = IamPolicySearchResult_Explanation_MatchedPermissionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.matchedPermissions[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult_Explanation {
    return {
      matchedPermissions: isObject(object.matchedPermissions)
        ? Object.entries(object.matchedPermissions).reduce<{ [key: string]: Permissions }>((acc, [key, value]) => {
          acc[key] = Permissions.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IamPolicySearchResult_Explanation): unknown {
    const obj: any = {};
    if (message.matchedPermissions) {
      const entries = Object.entries(message.matchedPermissions);
      if (entries.length > 0) {
        obj.matchedPermissions = {};
        entries.forEach(([k, v]) => {
          obj.matchedPermissions[k] = Permissions.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicySearchResult_Explanation>): IamPolicySearchResult_Explanation {
    return IamPolicySearchResult_Explanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicySearchResult_Explanation>): IamPolicySearchResult_Explanation {
    const message = createBaseIamPolicySearchResult_Explanation();
    message.matchedPermissions = Object.entries(object.matchedPermissions ?? {}).reduce<{ [key: string]: Permissions }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Permissions.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry(): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
  return { key: "", value: undefined };
}

export const IamPolicySearchResult_Explanation_MatchedPermissionsEntry: MessageFns<
  IamPolicySearchResult_Explanation_MatchedPermissionsEntry
> = {
  encode(
    message: IamPolicySearchResult_Explanation_MatchedPermissionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Permissions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Permissions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Permissions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IamPolicySearchResult_Explanation_MatchedPermissionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Permissions.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<IamPolicySearchResult_Explanation_MatchedPermissionsEntry>,
  ): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    return IamPolicySearchResult_Explanation_MatchedPermissionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<IamPolicySearchResult_Explanation_MatchedPermissionsEntry>,
  ): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    const message = createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Permissions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePermissions(): Permissions {
  return { permissions: [] };
}

export const Permissions: MessageFns<Permissions> = {
  encode(message: Permissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.permissions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permissions {
    return {
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Permissions): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    return obj;
  },

  create(base?: DeepPartial<Permissions>): Permissions {
    return Permissions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Permissions>): Permissions {
    const message = createBasePermissions();
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
