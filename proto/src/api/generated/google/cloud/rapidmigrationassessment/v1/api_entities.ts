// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/rapidmigrationassessment/v1/api_entities.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.rapidmigrationassessment.v1";

/** Message describing a MC Source of type Guest OS Scan. */
export interface GuestOsScan {
  /** reference to the corresponding Guest OS Scan in MC Source. */
  coreSource: string;
}

/** Message describing a MC Source of type VSphere Scan. */
export interface VSphereScan {
  /** reference to the corresponding VSphere Scan in MC Source. */
  coreSource: string;
}

/** Message describing Collector object. */
export interface Collector {
  /** name of resource. */
  name: string;
  /** Output only. Create time stamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update time stamp. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** User specified name of the Collector. */
  displayName: string;
  /** User specified description of the Collector. */
  description: string;
  /** Service Account email used to ingest data to this Collector. */
  serviceAccount: string;
  /**
   * Output only. Store cloud storage bucket name (which is a guid) created with
   * this Collector.
   */
  bucket: string;
  /** User specified expected asset count. */
  expectedAssetCount: Long;
  /** Output only. State of the Collector. */
  state: Collector_State;
  /** Output only. Client version. */
  clientVersion: string;
  /** Output only. Reference to MC Source Guest Os Scan. */
  guestOsScan:
    | GuestOsScan
    | undefined;
  /** Output only. Reference to MC Source vsphere_scan. */
  vsphereScan:
    | VSphereScan
    | undefined;
  /** How many days to collect data. */
  collectionDays: number;
  /** Uri for EULA (End User License Agreement) from customer. */
  eulaUri: string;
}

/**
 * -- Using suggestion from API Linter Analyzer for nesting enum --
 * -- https://linter.aip.dev/216/nesting --
 * State of a Collector (server_side).
 * States are used for internal purposes and named to keep
 * convention of legacy product:
 * https://cloud.google.com/migrate/stratozone/docs/about-stratoprobe.
 */
export enum Collector_State {
  /** STATE_UNSPECIFIED - Collector state is not recognized. */
  STATE_UNSPECIFIED = 0,
  /**
   * STATE_INITIALIZING - Collector started to create, but hasn't been completed MC source creation
   * and db object creation.
   */
  STATE_INITIALIZING = 1,
  /**
   * STATE_READY_TO_USE - Collector has been created, MC source creation and db object creation
   * completed.
   */
  STATE_READY_TO_USE = 2,
  /** STATE_REGISTERED - Collector client has been registered with client. */
  STATE_REGISTERED = 3,
  /** STATE_ACTIVE - Collector client is actively scanning. */
  STATE_ACTIVE = 4,
  /** STATE_PAUSED - Collector is not actively scanning. */
  STATE_PAUSED = 5,
  /** STATE_DELETING - Collector is starting background job for deletion. */
  STATE_DELETING = 6,
  /** STATE_DECOMMISSIONED - Collector completed all tasks for deletion. */
  STATE_DECOMMISSIONED = 7,
  /** STATE_ERROR - Collector is in error state. */
  STATE_ERROR = 8,
  UNRECOGNIZED = -1,
}

export function collector_StateFromJSON(object: any): Collector_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Collector_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_INITIALIZING":
      return Collector_State.STATE_INITIALIZING;
    case 2:
    case "STATE_READY_TO_USE":
      return Collector_State.STATE_READY_TO_USE;
    case 3:
    case "STATE_REGISTERED":
      return Collector_State.STATE_REGISTERED;
    case 4:
    case "STATE_ACTIVE":
      return Collector_State.STATE_ACTIVE;
    case 5:
    case "STATE_PAUSED":
      return Collector_State.STATE_PAUSED;
    case 6:
    case "STATE_DELETING":
      return Collector_State.STATE_DELETING;
    case 7:
    case "STATE_DECOMMISSIONED":
      return Collector_State.STATE_DECOMMISSIONED;
    case 8:
    case "STATE_ERROR":
      return Collector_State.STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Collector_State.UNRECOGNIZED;
  }
}

export function collector_StateToJSON(object: Collector_State): string {
  switch (object) {
    case Collector_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Collector_State.STATE_INITIALIZING:
      return "STATE_INITIALIZING";
    case Collector_State.STATE_READY_TO_USE:
      return "STATE_READY_TO_USE";
    case Collector_State.STATE_REGISTERED:
      return "STATE_REGISTERED";
    case Collector_State.STATE_ACTIVE:
      return "STATE_ACTIVE";
    case Collector_State.STATE_PAUSED:
      return "STATE_PAUSED";
    case Collector_State.STATE_DELETING:
      return "STATE_DELETING";
    case Collector_State.STATE_DECOMMISSIONED:
      return "STATE_DECOMMISSIONED";
    case Collector_State.STATE_ERROR:
      return "STATE_ERROR";
    case Collector_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Collector_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing an Annotation */
export interface Annotation {
  /** name of resource. */
  name: string;
  /** Output only. Create time stamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update time stamp. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Type of an annotation. */
  type: Annotation_Type;
}

/** Types for project level setting. */
export enum Annotation_Type {
  /** TYPE_UNSPECIFIED - Unknown type */
  TYPE_UNSPECIFIED = 0,
  /** TYPE_LEGACY_EXPORT_CONSENT - Indicates that this project has opted into StratoZone export. */
  TYPE_LEGACY_EXPORT_CONSENT = 1,
  /** TYPE_QWIKLAB - Indicates that this project is created by Qwiklab. */
  TYPE_QWIKLAB = 2,
  UNRECOGNIZED = -1,
}

export function annotation_TypeFromJSON(object: any): Annotation_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Annotation_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_LEGACY_EXPORT_CONSENT":
      return Annotation_Type.TYPE_LEGACY_EXPORT_CONSENT;
    case 2:
    case "TYPE_QWIKLAB":
      return Annotation_Type.TYPE_QWIKLAB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Annotation_Type.UNRECOGNIZED;
  }
}

export function annotation_TypeToJSON(object: Annotation_Type): string {
  switch (object) {
    case Annotation_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Annotation_Type.TYPE_LEGACY_EXPORT_CONSENT:
      return "TYPE_LEGACY_EXPORT_CONSENT";
    case Annotation_Type.TYPE_QWIKLAB:
      return "TYPE_QWIKLAB";
    case Annotation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Annotation_LabelsEntry {
  key: string;
  value: string;
}

function createBaseGuestOsScan(): GuestOsScan {
  return { coreSource: "" };
}

export const GuestOsScan: MessageFns<GuestOsScan> = {
  encode(message: GuestOsScan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coreSource !== "") {
      writer.uint32(10).string(message.coreSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestOsScan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestOsScan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coreSource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestOsScan {
    return { coreSource: isSet(object.coreSource) ? globalThis.String(object.coreSource) : "" };
  },

  toJSON(message: GuestOsScan): unknown {
    const obj: any = {};
    if (message.coreSource !== "") {
      obj.coreSource = message.coreSource;
    }
    return obj;
  },

  create(base?: DeepPartial<GuestOsScan>): GuestOsScan {
    return GuestOsScan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestOsScan>): GuestOsScan {
    const message = createBaseGuestOsScan();
    message.coreSource = object.coreSource ?? "";
    return message;
  },
};

function createBaseVSphereScan(): VSphereScan {
  return { coreSource: "" };
}

export const VSphereScan: MessageFns<VSphereScan> = {
  encode(message: VSphereScan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coreSource !== "") {
      writer.uint32(10).string(message.coreSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VSphereScan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVSphereScan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coreSource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VSphereScan {
    return { coreSource: isSet(object.coreSource) ? globalThis.String(object.coreSource) : "" };
  },

  toJSON(message: VSphereScan): unknown {
    const obj: any = {};
    if (message.coreSource !== "") {
      obj.coreSource = message.coreSource;
    }
    return obj;
  },

  create(base?: DeepPartial<VSphereScan>): VSphereScan {
    return VSphereScan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VSphereScan>): VSphereScan {
    const message = createBaseVSphereScan();
    message.coreSource = object.coreSource ?? "";
    return message;
  },
};

function createBaseCollector(): Collector {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    serviceAccount: "",
    bucket: "",
    expectedAssetCount: Long.ZERO,
    state: 0,
    clientVersion: "",
    guestOsScan: undefined,
    vsphereScan: undefined,
    collectionDays: 0,
    eulaUri: "",
  };
}

export const Collector: MessageFns<Collector> = {
  encode(message: Collector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Collector_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(58).string(message.serviceAccount);
    }
    if (message.bucket !== "") {
      writer.uint32(66).string(message.bucket);
    }
    if (!message.expectedAssetCount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.expectedAssetCount.toString());
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.clientVersion !== "") {
      writer.uint32(90).string(message.clientVersion);
    }
    if (message.guestOsScan !== undefined) {
      GuestOsScan.encode(message.guestOsScan, writer.uint32(98).fork()).join();
    }
    if (message.vsphereScan !== undefined) {
      VSphereScan.encode(message.vsphereScan, writer.uint32(106).fork()).join();
    }
    if (message.collectionDays !== 0) {
      writer.uint32(112).int32(message.collectionDays);
    }
    if (message.eulaUri !== "") {
      writer.uint32(122).string(message.eulaUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Collector_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.expectedAssetCount = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.guestOsScan = GuestOsScan.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.vsphereScan = VSphereScan.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.collectionDays = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.eulaUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collector {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      expectedAssetCount: isSet(object.expectedAssetCount) ? Long.fromValue(object.expectedAssetCount) : Long.ZERO,
      state: isSet(object.state) ? collector_StateFromJSON(object.state) : 0,
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      guestOsScan: isSet(object.guestOsScan) ? GuestOsScan.fromJSON(object.guestOsScan) : undefined,
      vsphereScan: isSet(object.vsphereScan) ? VSphereScan.fromJSON(object.vsphereScan) : undefined,
      collectionDays: isSet(object.collectionDays) ? globalThis.Number(object.collectionDays) : 0,
      eulaUri: isSet(object.eulaUri) ? globalThis.String(object.eulaUri) : "",
    };
  },

  toJSON(message: Collector): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (!message.expectedAssetCount.equals(Long.ZERO)) {
      obj.expectedAssetCount = (message.expectedAssetCount || Long.ZERO).toString();
    }
    if (message.state !== 0) {
      obj.state = collector_StateToJSON(message.state);
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.guestOsScan !== undefined) {
      obj.guestOsScan = GuestOsScan.toJSON(message.guestOsScan);
    }
    if (message.vsphereScan !== undefined) {
      obj.vsphereScan = VSphereScan.toJSON(message.vsphereScan);
    }
    if (message.collectionDays !== 0) {
      obj.collectionDays = Math.round(message.collectionDays);
    }
    if (message.eulaUri !== "") {
      obj.eulaUri = message.eulaUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Collector>): Collector {
    return Collector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Collector>): Collector {
    const message = createBaseCollector();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.bucket = object.bucket ?? "";
    message.expectedAssetCount = (object.expectedAssetCount !== undefined && object.expectedAssetCount !== null)
      ? Long.fromValue(object.expectedAssetCount)
      : Long.ZERO;
    message.state = object.state ?? 0;
    message.clientVersion = object.clientVersion ?? "";
    message.guestOsScan = (object.guestOsScan !== undefined && object.guestOsScan !== null)
      ? GuestOsScan.fromPartial(object.guestOsScan)
      : undefined;
    message.vsphereScan = (object.vsphereScan !== undefined && object.vsphereScan !== null)
      ? VSphereScan.fromPartial(object.vsphereScan)
      : undefined;
    message.collectionDays = object.collectionDays ?? 0;
    message.eulaUri = object.eulaUri ?? "";
    return message;
  },
};

function createBaseCollector_LabelsEntry(): Collector_LabelsEntry {
  return { key: "", value: "" };
}

export const Collector_LabelsEntry: MessageFns<Collector_LabelsEntry> = {
  encode(message: Collector_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collector_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollector_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collector_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Collector_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Collector_LabelsEntry>): Collector_LabelsEntry {
    return Collector_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Collector_LabelsEntry>): Collector_LabelsEntry {
    const message = createBaseCollector_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, type: 0 };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Annotation_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Annotation_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      type: isSet(object.type) ? annotation_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.type !== 0) {
      obj.type = annotation_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseAnnotation_LabelsEntry(): Annotation_LabelsEntry {
  return { key: "", value: "" };
}

export const Annotation_LabelsEntry: MessageFns<Annotation_LabelsEntry> = {
  encode(message: Annotation_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Annotation_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation_LabelsEntry>): Annotation_LabelsEntry {
    return Annotation_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation_LabelsEntry>): Annotation_LabelsEntry {
    const message = createBaseAnnotation_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
