// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/data_labeling_job.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { Money } from "../../../type/money.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { JobState, jobStateFromJSON, jobStateToJSON } from "./job_state.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * DataLabelingJob is used to trigger a human labeling job on unlabeled data
 * from the following Dataset:
 */
export interface DataLabelingJob {
  /** Output only. Resource name of the DataLabelingJob. */
  name: string;
  /**
   * Required. The user-defined name of the DataLabelingJob.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   * Display name of a DataLabelingJob.
   */
  displayName: string;
  /**
   * Required. Dataset resource names. Right now we only support labeling from a
   * single Dataset. Format:
   * `projects/{project}/locations/{location}/datasets/{dataset}`
   */
  datasets: string[];
  /**
   * Labels to assign to annotations generated by this DataLabelingJob.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with "aiplatform.googleapis.com/"
   * and are immutable.
   */
  annotationLabels: { [key: string]: string };
  /** Required. Number of labelers to work on each DataItem. */
  labelerCount: number;
  /**
   * Required. The Google Cloud Storage location of the instruction pdf. This
   * pdf is shared with labelers, and provides detailed description on how to
   * label DataItems in Datasets.
   */
  instructionUri: string;
  /**
   * Required. Points to a YAML file stored on Google Cloud Storage describing
   * the config for a specific type of DataLabelingJob. The schema files that
   * can be used here are found in the
   * https://storage.googleapis.com/google-cloud-aiplatform bucket in the
   * /schema/datalabelingjob/inputs/ folder.
   */
  inputsSchemaUri: string;
  /** Required. Input config parameters for the DataLabelingJob. */
  inputs:
    | any
    | undefined;
  /** Output only. The detailed state of the job. */
  state: JobState;
  /**
   * Output only. Current labeling job progress percentage scaled in interval
   * [0, 100], indicating the percentage of DataItems that has been finished.
   */
  labelingProgress: number;
  /**
   * Output only. Estimated cost(in US dollars) that the DataLabelingJob has
   * incurred to date.
   */
  currentSpend:
    | Money
    | undefined;
  /** Output only. Timestamp when this DataLabelingJob was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this DataLabelingJob was updated most recently. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. DataLabelingJob errors. It is only populated when job's state
   * is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
   */
  error:
    | Status
    | undefined;
  /**
   * The labels with user-defined metadata to organize your DataLabelingJobs.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with "aiplatform.googleapis.com/"
   * and are immutable. Following system labels exist for each DataLabelingJob:
   *
   * * "aiplatform.googleapis.com/schema": output only, its value is the
   *   [inputs_schema][google.cloud.aiplatform.v1.DataLabelingJob.inputs_schema_uri]'s
   *   title.
   */
  labels: { [key: string]: string };
  /** The SpecialistPools' resource names associated with this job. */
  specialistPools: string[];
  /**
   * Customer-managed encryption key spec for a DataLabelingJob. If set, this
   * DataLabelingJob will be secured by this key.
   *
   * Note: Annotations created in the DataLabelingJob are associated with
   * the EncryptionSpec of the Dataset they are exported to.
   */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /**
   * Parameters that configure the active learning pipeline. Active learning
   * will label the data incrementally via several iterations. For every
   * iteration, it will select a batch of data based on the sampling strategy.
   */
  activeLearningConfig: ActiveLearningConfig | undefined;
}

export interface DataLabelingJob_AnnotationLabelsEntry {
  key: string;
  value: string;
}

export interface DataLabelingJob_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Parameters that configure the active learning pipeline. Active learning will
 *  label the data incrementally by several iterations. For every iteration, it
 *  will select a batch of data based on the sampling strategy.
 */
export interface ActiveLearningConfig {
  /** Max number of human labeled DataItems. */
  maxDataItemCount?:
    | Long
    | undefined;
  /** Max percent of total DataItems for human labeling. */
  maxDataItemPercentage?:
    | number
    | undefined;
  /**
   * Active learning data sampling config. For every active learning labeling
   * iteration, it will select a batch of data based on the sampling strategy.
   */
  sampleConfig:
    | SampleConfig
    | undefined;
  /**
   * CMLE training config. For every active learning labeling iteration, system
   * will train a machine learning model on CMLE. The trained model will be used
   * by data sampling algorithm to select DataItems.
   */
  trainingConfig: TrainingConfig | undefined;
}

/**
 * Active learning data sampling config. For every active learning labeling
 * iteration, it will select a batch of data based on the sampling strategy.
 */
export interface SampleConfig {
  /** The percentage of data needed to be labeled in the first batch. */
  initialBatchSamplePercentage?:
    | number
    | undefined;
  /**
   * The percentage of data needed to be labeled in each following batch
   * (except the first batch).
   */
  followingBatchSamplePercentage?:
    | number
    | undefined;
  /**
   * Field to choose sampling strategy. Sampling strategy will decide which data
   * should be selected for human labeling in every batch.
   */
  sampleStrategy: SampleConfig_SampleStrategy;
}

/**
 * Sample strategy decides which subset of DataItems should be selected for
 * human labeling in every batch.
 */
export enum SampleConfig_SampleStrategy {
  /** SAMPLE_STRATEGY_UNSPECIFIED - Default will be treated as UNCERTAINTY. */
  SAMPLE_STRATEGY_UNSPECIFIED = 0,
  /** UNCERTAINTY - Sample the most uncertain data to label. */
  UNCERTAINTY = 1,
  UNRECOGNIZED = -1,
}

export function sampleConfig_SampleStrategyFromJSON(object: any): SampleConfig_SampleStrategy {
  switch (object) {
    case 0:
    case "SAMPLE_STRATEGY_UNSPECIFIED":
      return SampleConfig_SampleStrategy.SAMPLE_STRATEGY_UNSPECIFIED;
    case 1:
    case "UNCERTAINTY":
      return SampleConfig_SampleStrategy.UNCERTAINTY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SampleConfig_SampleStrategy.UNRECOGNIZED;
  }
}

export function sampleConfig_SampleStrategyToJSON(object: SampleConfig_SampleStrategy): string {
  switch (object) {
    case SampleConfig_SampleStrategy.SAMPLE_STRATEGY_UNSPECIFIED:
      return "SAMPLE_STRATEGY_UNSPECIFIED";
    case SampleConfig_SampleStrategy.UNCERTAINTY:
      return "UNCERTAINTY";
    case SampleConfig_SampleStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * CMLE training config. For every active learning labeling iteration, system
 * will train a machine learning model on CMLE. The trained model will be used
 * by data sampling algorithm to select DataItems.
 */
export interface TrainingConfig {
  /**
   * The timeout hours for the CMLE training job, expressed in milli hours
   * i.e. 1,000 value in this field means 1 hour.
   */
  timeoutTrainingMilliHours: Long;
}

function createBaseDataLabelingJob(): DataLabelingJob {
  return {
    name: "",
    displayName: "",
    datasets: [],
    annotationLabels: {},
    labelerCount: 0,
    instructionUri: "",
    inputsSchemaUri: "",
    inputs: undefined,
    state: 0,
    labelingProgress: 0,
    currentSpend: undefined,
    createTime: undefined,
    updateTime: undefined,
    error: undefined,
    labels: {},
    specialistPools: [],
    encryptionSpec: undefined,
    activeLearningConfig: undefined,
  };
}

export const DataLabelingJob: MessageFns<DataLabelingJob> = {
  encode(message: DataLabelingJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.datasets) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.annotationLabels).forEach(([key, value]) => {
      DataLabelingJob_AnnotationLabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.labelerCount !== 0) {
      writer.uint32(32).int32(message.labelerCount);
    }
    if (message.instructionUri !== "") {
      writer.uint32(42).string(message.instructionUri);
    }
    if (message.inputsSchemaUri !== "") {
      writer.uint32(50).string(message.inputsSchemaUri);
    }
    if (message.inputs !== undefined) {
      Value.encode(Value.wrap(message.inputs), writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.labelingProgress !== 0) {
      writer.uint32(104).int32(message.labelingProgress);
    }
    if (message.currentSpend !== undefined) {
      Money.encode(message.currentSpend, writer.uint32(114).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(178).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DataLabelingJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    for (const v of message.specialistPools) {
      writer.uint32(130).string(v!);
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(162).fork()).join();
    }
    if (message.activeLearningConfig !== undefined) {
      ActiveLearningConfig.encode(message.activeLearningConfig, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataLabelingJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLabelingJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.datasets.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = DataLabelingJob_AnnotationLabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.annotationLabels[entry12.key] = entry12.value;
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.labelerCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instructionUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputsSchemaUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.inputs = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.labelingProgress = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.currentSpend = Money.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = DataLabelingJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.specialistPools.push(reader.string());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.activeLearningConfig = ActiveLearningConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLabelingJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => globalThis.String(e)) : [],
      annotationLabels: isObject(object.annotationLabels)
        ? Object.entries(object.annotationLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labelerCount: isSet(object.labelerCount) ? globalThis.Number(object.labelerCount) : 0,
      instructionUri: isSet(object.instructionUri) ? globalThis.String(object.instructionUri) : "",
      inputsSchemaUri: isSet(object.inputsSchemaUri) ? globalThis.String(object.inputsSchemaUri) : "",
      inputs: isSet(object?.inputs) ? object.inputs : undefined,
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      labelingProgress: isSet(object.labelingProgress) ? globalThis.Number(object.labelingProgress) : 0,
      currentSpend: isSet(object.currentSpend) ? Money.fromJSON(object.currentSpend) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      specialistPools: globalThis.Array.isArray(object?.specialistPools)
        ? object.specialistPools.map((e: any) => globalThis.String(e))
        : [],
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      activeLearningConfig: isSet(object.activeLearningConfig)
        ? ActiveLearningConfig.fromJSON(object.activeLearningConfig)
        : undefined,
    };
  },

  toJSON(message: DataLabelingJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.datasets?.length) {
      obj.datasets = message.datasets;
    }
    if (message.annotationLabels) {
      const entries = Object.entries(message.annotationLabels);
      if (entries.length > 0) {
        obj.annotationLabels = {};
        entries.forEach(([k, v]) => {
          obj.annotationLabels[k] = v;
        });
      }
    }
    if (message.labelerCount !== 0) {
      obj.labelerCount = Math.round(message.labelerCount);
    }
    if (message.instructionUri !== "") {
      obj.instructionUri = message.instructionUri;
    }
    if (message.inputsSchemaUri !== "") {
      obj.inputsSchemaUri = message.inputsSchemaUri;
    }
    if (message.inputs !== undefined) {
      obj.inputs = message.inputs;
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.labelingProgress !== 0) {
      obj.labelingProgress = Math.round(message.labelingProgress);
    }
    if (message.currentSpend !== undefined) {
      obj.currentSpend = Money.toJSON(message.currentSpend);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.specialistPools?.length) {
      obj.specialistPools = message.specialistPools;
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.activeLearningConfig !== undefined) {
      obj.activeLearningConfig = ActiveLearningConfig.toJSON(message.activeLearningConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<DataLabelingJob>): DataLabelingJob {
    return DataLabelingJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataLabelingJob>): DataLabelingJob {
    const message = createBaseDataLabelingJob();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.datasets = object.datasets?.map((e) => e) || [];
    message.annotationLabels = Object.entries(object.annotationLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labelerCount = object.labelerCount ?? 0;
    message.instructionUri = object.instructionUri ?? "";
    message.inputsSchemaUri = object.inputsSchemaUri ?? "";
    message.inputs = object.inputs ?? undefined;
    message.state = object.state ?? 0;
    message.labelingProgress = object.labelingProgress ?? 0;
    message.currentSpend = (object.currentSpend !== undefined && object.currentSpend !== null)
      ? Money.fromPartial(object.currentSpend)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.specialistPools = object.specialistPools?.map((e) => e) || [];
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.activeLearningConfig = (object.activeLearningConfig !== undefined && object.activeLearningConfig !== null)
      ? ActiveLearningConfig.fromPartial(object.activeLearningConfig)
      : undefined;
    return message;
  },
};

function createBaseDataLabelingJob_AnnotationLabelsEntry(): DataLabelingJob_AnnotationLabelsEntry {
  return { key: "", value: "" };
}

export const DataLabelingJob_AnnotationLabelsEntry: MessageFns<DataLabelingJob_AnnotationLabelsEntry> = {
  encode(message: DataLabelingJob_AnnotationLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataLabelingJob_AnnotationLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLabelingJob_AnnotationLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLabelingJob_AnnotationLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataLabelingJob_AnnotationLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataLabelingJob_AnnotationLabelsEntry>): DataLabelingJob_AnnotationLabelsEntry {
    return DataLabelingJob_AnnotationLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataLabelingJob_AnnotationLabelsEntry>): DataLabelingJob_AnnotationLabelsEntry {
    const message = createBaseDataLabelingJob_AnnotationLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDataLabelingJob_LabelsEntry(): DataLabelingJob_LabelsEntry {
  return { key: "", value: "" };
}

export const DataLabelingJob_LabelsEntry: MessageFns<DataLabelingJob_LabelsEntry> = {
  encode(message: DataLabelingJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataLabelingJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLabelingJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLabelingJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataLabelingJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataLabelingJob_LabelsEntry>): DataLabelingJob_LabelsEntry {
    return DataLabelingJob_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataLabelingJob_LabelsEntry>): DataLabelingJob_LabelsEntry {
    const message = createBaseDataLabelingJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseActiveLearningConfig(): ActiveLearningConfig {
  return {
    maxDataItemCount: undefined,
    maxDataItemPercentage: undefined,
    sampleConfig: undefined,
    trainingConfig: undefined,
  };
}

export const ActiveLearningConfig: MessageFns<ActiveLearningConfig> = {
  encode(message: ActiveLearningConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxDataItemCount !== undefined) {
      writer.uint32(8).int64(message.maxDataItemCount.toString());
    }
    if (message.maxDataItemPercentage !== undefined) {
      writer.uint32(16).int32(message.maxDataItemPercentage);
    }
    if (message.sampleConfig !== undefined) {
      SampleConfig.encode(message.sampleConfig, writer.uint32(26).fork()).join();
    }
    if (message.trainingConfig !== undefined) {
      TrainingConfig.encode(message.trainingConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveLearningConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveLearningConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxDataItemCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDataItemPercentage = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sampleConfig = SampleConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trainingConfig = TrainingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveLearningConfig {
    return {
      maxDataItemCount: isSet(object.maxDataItemCount) ? Long.fromValue(object.maxDataItemCount) : undefined,
      maxDataItemPercentage: isSet(object.maxDataItemPercentage)
        ? globalThis.Number(object.maxDataItemPercentage)
        : undefined,
      sampleConfig: isSet(object.sampleConfig) ? SampleConfig.fromJSON(object.sampleConfig) : undefined,
      trainingConfig: isSet(object.trainingConfig) ? TrainingConfig.fromJSON(object.trainingConfig) : undefined,
    };
  },

  toJSON(message: ActiveLearningConfig): unknown {
    const obj: any = {};
    if (message.maxDataItemCount !== undefined) {
      obj.maxDataItemCount = (message.maxDataItemCount || Long.ZERO).toString();
    }
    if (message.maxDataItemPercentage !== undefined) {
      obj.maxDataItemPercentage = Math.round(message.maxDataItemPercentage);
    }
    if (message.sampleConfig !== undefined) {
      obj.sampleConfig = SampleConfig.toJSON(message.sampleConfig);
    }
    if (message.trainingConfig !== undefined) {
      obj.trainingConfig = TrainingConfig.toJSON(message.trainingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveLearningConfig>): ActiveLearningConfig {
    return ActiveLearningConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveLearningConfig>): ActiveLearningConfig {
    const message = createBaseActiveLearningConfig();
    message.maxDataItemCount = (object.maxDataItemCount !== undefined && object.maxDataItemCount !== null)
      ? Long.fromValue(object.maxDataItemCount)
      : undefined;
    message.maxDataItemPercentage = object.maxDataItemPercentage ?? undefined;
    message.sampleConfig = (object.sampleConfig !== undefined && object.sampleConfig !== null)
      ? SampleConfig.fromPartial(object.sampleConfig)
      : undefined;
    message.trainingConfig = (object.trainingConfig !== undefined && object.trainingConfig !== null)
      ? TrainingConfig.fromPartial(object.trainingConfig)
      : undefined;
    return message;
  },
};

function createBaseSampleConfig(): SampleConfig {
  return { initialBatchSamplePercentage: undefined, followingBatchSamplePercentage: undefined, sampleStrategy: 0 };
}

export const SampleConfig: MessageFns<SampleConfig> = {
  encode(message: SampleConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialBatchSamplePercentage !== undefined) {
      writer.uint32(8).int32(message.initialBatchSamplePercentage);
    }
    if (message.followingBatchSamplePercentage !== undefined) {
      writer.uint32(24).int32(message.followingBatchSamplePercentage);
    }
    if (message.sampleStrategy !== 0) {
      writer.uint32(40).int32(message.sampleStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SampleConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSampleConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.initialBatchSamplePercentage = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.followingBatchSamplePercentage = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sampleStrategy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SampleConfig {
    return {
      initialBatchSamplePercentage: isSet(object.initialBatchSamplePercentage)
        ? globalThis.Number(object.initialBatchSamplePercentage)
        : undefined,
      followingBatchSamplePercentage: isSet(object.followingBatchSamplePercentage)
        ? globalThis.Number(object.followingBatchSamplePercentage)
        : undefined,
      sampleStrategy: isSet(object.sampleStrategy) ? sampleConfig_SampleStrategyFromJSON(object.sampleStrategy) : 0,
    };
  },

  toJSON(message: SampleConfig): unknown {
    const obj: any = {};
    if (message.initialBatchSamplePercentage !== undefined) {
      obj.initialBatchSamplePercentage = Math.round(message.initialBatchSamplePercentage);
    }
    if (message.followingBatchSamplePercentage !== undefined) {
      obj.followingBatchSamplePercentage = Math.round(message.followingBatchSamplePercentage);
    }
    if (message.sampleStrategy !== 0) {
      obj.sampleStrategy = sampleConfig_SampleStrategyToJSON(message.sampleStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<SampleConfig>): SampleConfig {
    return SampleConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SampleConfig>): SampleConfig {
    const message = createBaseSampleConfig();
    message.initialBatchSamplePercentage = object.initialBatchSamplePercentage ?? undefined;
    message.followingBatchSamplePercentage = object.followingBatchSamplePercentage ?? undefined;
    message.sampleStrategy = object.sampleStrategy ?? 0;
    return message;
  },
};

function createBaseTrainingConfig(): TrainingConfig {
  return { timeoutTrainingMilliHours: Long.ZERO };
}

export const TrainingConfig: MessageFns<TrainingConfig> = {
  encode(message: TrainingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.timeoutTrainingMilliHours.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.timeoutTrainingMilliHours.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrainingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrainingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timeoutTrainingMilliHours = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrainingConfig {
    return {
      timeoutTrainingMilliHours: isSet(object.timeoutTrainingMilliHours)
        ? Long.fromValue(object.timeoutTrainingMilliHours)
        : Long.ZERO,
    };
  },

  toJSON(message: TrainingConfig): unknown {
    const obj: any = {};
    if (!message.timeoutTrainingMilliHours.equals(Long.ZERO)) {
      obj.timeoutTrainingMilliHours = (message.timeoutTrainingMilliHours || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TrainingConfig>): TrainingConfig {
    return TrainingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrainingConfig>): TrainingConfig {
    const message = createBaseTrainingConfig();
    message.timeoutTrainingMilliHours =
      (object.timeoutTrainingMilliHours !== undefined && object.timeoutTrainingMilliHours !== null)
        ? Long.fromValue(object.timeoutTrainingMilliHours)
        : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
