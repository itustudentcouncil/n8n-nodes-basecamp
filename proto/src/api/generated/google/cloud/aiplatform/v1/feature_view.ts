// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/feature_view.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * FeatureView is representation of values that the FeatureOnlineStore will
 * serve based on its syncConfig.
 */
export interface FeatureView {
  /**
   * Optional. Configures how data is supposed to be extracted from a BigQuery
   * source to be loaded onto the FeatureOnlineStore.
   */
  bigQuerySource?:
    | FeatureView_BigQuerySource
    | undefined;
  /**
   * Optional. Configures the features from a Feature Registry source that
   * need to be loaded onto the FeatureOnlineStore.
   */
  featureRegistrySource?:
    | FeatureView_FeatureRegistrySource
    | undefined;
  /** Optional. The Vertex RAG Source that the FeatureView is linked to. */
  vertexRagSource?:
    | FeatureView_VertexRagSource
    | undefined;
  /**
   * Identifier. Name of the FeatureView. Format:
   * `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
   */
  name: string;
  /** Output only. Timestamp when this FeatureView was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this FeatureView was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Used to perform consistent read-modify-write updates. If not set,
   * a blind "overwrite" update happens.
   */
  etag: string;
  /**
   * Optional. The labels with user-defined metadata to organize your
   * FeatureViews.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information on and examples of labels.
   * No more than 64 user labels can be associated with one
   * FeatureOnlineStore(System labels are excluded)." System reserved label keys
   * are prefixed with "aiplatform.googleapis.com/" and are immutable.
   */
  labels: { [key: string]: string };
  /**
   * Configures when data is to be synced/updated for this FeatureView. At the
   * end of the sync the latest featureValues for each entityId of this
   * FeatureView are made ready for online serving.
   */
  syncConfig:
    | FeatureView_SyncConfig
    | undefined;
  /**
   * Optional. Configuration for index preparation for vector search. It
   * contains the required configurations to create an index from source data,
   * so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
   * performed during online serving.
   */
  indexConfig:
    | FeatureView_IndexConfig
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

export interface FeatureView_BigQuerySource {
  /**
   * Required. The BigQuery view URI that will be materialized on each sync
   * trigger based on FeatureView.SyncConfig.
   */
  uri: string;
  /** Required. Columns to construct entity_id / row keys. */
  entityIdColumns: string[];
}

/** Configuration for Sync. Only one option is set. */
export interface FeatureView_SyncConfig {
  /**
   * Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
   * runs. To explicitly set a timezone to the cron tab, apply a prefix in
   * the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
   * The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
   * database. For example, "CRON_TZ=America/New_York 1 * * * *", or
   * "TZ=America/New_York 1 * * * *".
   */
  cron: string;
}

/** Configuration for vector indexing. */
export interface FeatureView_IndexConfig {
  /**
   * Optional. Configuration options for the tree-AH algorithm (Shallow tree
   * + Asymmetric Hashing). Please refer to this paper for more details:
   * https://arxiv.org/abs/1908.10396
   */
  treeAhConfig?:
    | FeatureView_IndexConfig_TreeAHConfig
    | undefined;
  /**
   * Optional. Configuration options for using brute force search, which
   * simply implements the standard linear search in the database for each
   * query. It is primarily meant for benchmarking and to generate the
   * ground truth for approximate search.
   */
  bruteForceConfig?:
    | FeatureView_IndexConfig_BruteForceConfig
    | undefined;
  /**
   * Optional. Column of embedding. This column contains the source data to
   * create index for vector search. embedding_column must be set when using
   * vector search.
   */
  embeddingColumn: string;
  /**
   * Optional. Columns of features that're used to filter vector search
   * results.
   */
  filterColumns: string[];
  /**
   * Optional. Column of crowding. This column contains crowding attribute
   * which is a constraint on a neighbor list produced by
   * [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1.FeatureOnlineStoreService.SearchNearestEntities]
   * to diversify search results. If
   * [NearestNeighborQuery.per_crowding_attribute_neighbor_count][google.cloud.aiplatform.v1.NearestNeighborQuery.per_crowding_attribute_neighbor_count]
   * is set to K in
   * [SearchNearestEntitiesRequest][google.cloud.aiplatform.v1.SearchNearestEntitiesRequest],
   * it's guaranteed that no more than K entities of the same crowding
   * attribute are returned in the response.
   */
  crowdingColumn: string;
  /** Optional. The number of dimensions of the input embedding. */
  embeddingDimension?:
    | number
    | undefined;
  /** Optional. The distance measure used in nearest neighbor search. */
  distanceMeasureType: FeatureView_IndexConfig_DistanceMeasureType;
}

/** The distance measure used in nearest neighbor search. */
export enum FeatureView_IndexConfig_DistanceMeasureType {
  /** DISTANCE_MEASURE_TYPE_UNSPECIFIED - Should not be set. */
  DISTANCE_MEASURE_TYPE_UNSPECIFIED = 0,
  /** SQUARED_L2_DISTANCE - Euclidean (L_2) Distance. */
  SQUARED_L2_DISTANCE = 1,
  /**
   * COSINE_DISTANCE - Cosine Distance. Defined as 1 - cosine similarity.
   *
   * We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
   * of COSINE distance. Our algorithms have been more optimized for
   * DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
   * mathematically equivalent to COSINE distance and results in the same
   * ranking.
   */
  COSINE_DISTANCE = 2,
  /** DOT_PRODUCT_DISTANCE - Dot Product Distance. Defined as a negative of the dot product. */
  DOT_PRODUCT_DISTANCE = 3,
  UNRECOGNIZED = -1,
}

export function featureView_IndexConfig_DistanceMeasureTypeFromJSON(
  object: any,
): FeatureView_IndexConfig_DistanceMeasureType {
  switch (object) {
    case 0:
    case "DISTANCE_MEASURE_TYPE_UNSPECIFIED":
      return FeatureView_IndexConfig_DistanceMeasureType.DISTANCE_MEASURE_TYPE_UNSPECIFIED;
    case 1:
    case "SQUARED_L2_DISTANCE":
      return FeatureView_IndexConfig_DistanceMeasureType.SQUARED_L2_DISTANCE;
    case 2:
    case "COSINE_DISTANCE":
      return FeatureView_IndexConfig_DistanceMeasureType.COSINE_DISTANCE;
    case 3:
    case "DOT_PRODUCT_DISTANCE":
      return FeatureView_IndexConfig_DistanceMeasureType.DOT_PRODUCT_DISTANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureView_IndexConfig_DistanceMeasureType.UNRECOGNIZED;
  }
}

export function featureView_IndexConfig_DistanceMeasureTypeToJSON(
  object: FeatureView_IndexConfig_DistanceMeasureType,
): string {
  switch (object) {
    case FeatureView_IndexConfig_DistanceMeasureType.DISTANCE_MEASURE_TYPE_UNSPECIFIED:
      return "DISTANCE_MEASURE_TYPE_UNSPECIFIED";
    case FeatureView_IndexConfig_DistanceMeasureType.SQUARED_L2_DISTANCE:
      return "SQUARED_L2_DISTANCE";
    case FeatureView_IndexConfig_DistanceMeasureType.COSINE_DISTANCE:
      return "COSINE_DISTANCE";
    case FeatureView_IndexConfig_DistanceMeasureType.DOT_PRODUCT_DISTANCE:
      return "DOT_PRODUCT_DISTANCE";
    case FeatureView_IndexConfig_DistanceMeasureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration options for using brute force search. */
export interface FeatureView_IndexConfig_BruteForceConfig {
}

/** Configuration options for the tree-AH algorithm. */
export interface FeatureView_IndexConfig_TreeAHConfig {
  /**
   * Optional. Number of embeddings on each leaf node. The default value is
   * 1000 if not set.
   */
  leafNodeEmbeddingCount?: Long | undefined;
}

/**
 * A Feature Registry source for features that need to be synced to Online
 * Store.
 */
export interface FeatureView_FeatureRegistrySource {
  /** Required. List of features that need to be synced to Online Store. */
  featureGroups: FeatureView_FeatureRegistrySource_FeatureGroup[];
  /** Optional. The project number of the parent project of the Feature Groups. */
  projectNumber?: Long | undefined;
}

/**
 * Features belonging to a single feature group that will be
 * synced to Online Store.
 */
export interface FeatureView_FeatureRegistrySource_FeatureGroup {
  /** Required. Identifier of the feature group. */
  featureGroupId: string;
  /** Required. Identifiers of features under the feature group. */
  featureIds: string[];
}

/**
 * A Vertex Rag source for features that need to be synced to Online
 * Store.
 */
export interface FeatureView_VertexRagSource {
  /**
   * Required. The BigQuery view/table URI that will be materialized on each
   * manual sync trigger. The table/view is expected to have the following
   * columns and types at least:
   *  - `corpus_id` (STRING, NULLABLE/REQUIRED)
   *  - `file_id` (STRING, NULLABLE/REQUIRED)
   *  - `chunk_id` (STRING, NULLABLE/REQUIRED)
   *  - `chunk_data_type` (STRING, NULLABLE/REQUIRED)
   *  - `chunk_data` (STRING, NULLABLE/REQUIRED)
   *  - `embeddings` (FLOAT, REPEATED)
   *  - `file_original_uri` (STRING, NULLABLE/REQUIRED)
   */
  uri: string;
  /** Optional. The RAG corpus id corresponding to this FeatureView. */
  ragCorpusId: Long;
}

export interface FeatureView_LabelsEntry {
  key: string;
  value: string;
}

function createBaseFeatureView(): FeatureView {
  return {
    bigQuerySource: undefined,
    featureRegistrySource: undefined,
    vertexRagSource: undefined,
    name: "",
    createTime: undefined,
    updateTime: undefined,
    etag: "",
    labels: {},
    syncConfig: undefined,
    indexConfig: undefined,
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const FeatureView: MessageFns<FeatureView> = {
  encode(message: FeatureView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bigQuerySource !== undefined) {
      FeatureView_BigQuerySource.encode(message.bigQuerySource, writer.uint32(50).fork()).join();
    }
    if (message.featureRegistrySource !== undefined) {
      FeatureView_FeatureRegistrySource.encode(message.featureRegistrySource, writer.uint32(74).fork()).join();
    }
    if (message.vertexRagSource !== undefined) {
      FeatureView_VertexRagSource.encode(message.vertexRagSource, writer.uint32(146).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      FeatureView_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.syncConfig !== undefined) {
      FeatureView_SyncConfig.encode(message.syncConfig, writer.uint32(58).fork()).join();
    }
    if (message.indexConfig !== undefined) {
      FeatureView_IndexConfig.encode(message.indexConfig, writer.uint32(122).fork()).join();
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(152).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(160).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bigQuerySource = FeatureView_BigQuerySource.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.featureRegistrySource = FeatureView_FeatureRegistrySource.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.vertexRagSource = FeatureView_VertexRagSource.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = FeatureView_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.syncConfig = FeatureView_SyncConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.indexConfig = FeatureView_IndexConfig.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView {
    return {
      bigQuerySource: isSet(object.bigQuerySource)
        ? FeatureView_BigQuerySource.fromJSON(object.bigQuerySource)
        : undefined,
      featureRegistrySource: isSet(object.featureRegistrySource)
        ? FeatureView_FeatureRegistrySource.fromJSON(object.featureRegistrySource)
        : undefined,
      vertexRagSource: isSet(object.vertexRagSource)
        ? FeatureView_VertexRagSource.fromJSON(object.vertexRagSource)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      syncConfig: isSet(object.syncConfig) ? FeatureView_SyncConfig.fromJSON(object.syncConfig) : undefined,
      indexConfig: isSet(object.indexConfig) ? FeatureView_IndexConfig.fromJSON(object.indexConfig) : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: FeatureView): unknown {
    const obj: any = {};
    if (message.bigQuerySource !== undefined) {
      obj.bigQuerySource = FeatureView_BigQuerySource.toJSON(message.bigQuerySource);
    }
    if (message.featureRegistrySource !== undefined) {
      obj.featureRegistrySource = FeatureView_FeatureRegistrySource.toJSON(message.featureRegistrySource);
    }
    if (message.vertexRagSource !== undefined) {
      obj.vertexRagSource = FeatureView_VertexRagSource.toJSON(message.vertexRagSource);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.syncConfig !== undefined) {
      obj.syncConfig = FeatureView_SyncConfig.toJSON(message.syncConfig);
    }
    if (message.indexConfig !== undefined) {
      obj.indexConfig = FeatureView_IndexConfig.toJSON(message.indexConfig);
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView>): FeatureView {
    return FeatureView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView>): FeatureView {
    const message = createBaseFeatureView();
    message.bigQuerySource = (object.bigQuerySource !== undefined && object.bigQuerySource !== null)
      ? FeatureView_BigQuerySource.fromPartial(object.bigQuerySource)
      : undefined;
    message.featureRegistrySource =
      (object.featureRegistrySource !== undefined && object.featureRegistrySource !== null)
        ? FeatureView_FeatureRegistrySource.fromPartial(object.featureRegistrySource)
        : undefined;
    message.vertexRagSource = (object.vertexRagSource !== undefined && object.vertexRagSource !== null)
      ? FeatureView_VertexRagSource.fromPartial(object.vertexRagSource)
      : undefined;
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.syncConfig = (object.syncConfig !== undefined && object.syncConfig !== null)
      ? FeatureView_SyncConfig.fromPartial(object.syncConfig)
      : undefined;
    message.indexConfig = (object.indexConfig !== undefined && object.indexConfig !== null)
      ? FeatureView_IndexConfig.fromPartial(object.indexConfig)
      : undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

function createBaseFeatureView_BigQuerySource(): FeatureView_BigQuerySource {
  return { uri: "", entityIdColumns: [] };
}

export const FeatureView_BigQuerySource: MessageFns<FeatureView_BigQuerySource> = {
  encode(message: FeatureView_BigQuerySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    for (const v of message.entityIdColumns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_BigQuerySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_BigQuerySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityIdColumns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_BigQuerySource {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      entityIdColumns: globalThis.Array.isArray(object?.entityIdColumns)
        ? object.entityIdColumns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FeatureView_BigQuerySource): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.entityIdColumns?.length) {
      obj.entityIdColumns = message.entityIdColumns;
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_BigQuerySource>): FeatureView_BigQuerySource {
    return FeatureView_BigQuerySource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_BigQuerySource>): FeatureView_BigQuerySource {
    const message = createBaseFeatureView_BigQuerySource();
    message.uri = object.uri ?? "";
    message.entityIdColumns = object.entityIdColumns?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeatureView_SyncConfig(): FeatureView_SyncConfig {
  return { cron: "" };
}

export const FeatureView_SyncConfig: MessageFns<FeatureView_SyncConfig> = {
  encode(message: FeatureView_SyncConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cron !== "") {
      writer.uint32(10).string(message.cron);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_SyncConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_SyncConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cron = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_SyncConfig {
    return { cron: isSet(object.cron) ? globalThis.String(object.cron) : "" };
  },

  toJSON(message: FeatureView_SyncConfig): unknown {
    const obj: any = {};
    if (message.cron !== "") {
      obj.cron = message.cron;
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_SyncConfig>): FeatureView_SyncConfig {
    return FeatureView_SyncConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_SyncConfig>): FeatureView_SyncConfig {
    const message = createBaseFeatureView_SyncConfig();
    message.cron = object.cron ?? "";
    return message;
  },
};

function createBaseFeatureView_IndexConfig(): FeatureView_IndexConfig {
  return {
    treeAhConfig: undefined,
    bruteForceConfig: undefined,
    embeddingColumn: "",
    filterColumns: [],
    crowdingColumn: "",
    embeddingDimension: undefined,
    distanceMeasureType: 0,
  };
}

export const FeatureView_IndexConfig: MessageFns<FeatureView_IndexConfig> = {
  encode(message: FeatureView_IndexConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeAhConfig !== undefined) {
      FeatureView_IndexConfig_TreeAHConfig.encode(message.treeAhConfig, writer.uint32(50).fork()).join();
    }
    if (message.bruteForceConfig !== undefined) {
      FeatureView_IndexConfig_BruteForceConfig.encode(message.bruteForceConfig, writer.uint32(58).fork()).join();
    }
    if (message.embeddingColumn !== "") {
      writer.uint32(10).string(message.embeddingColumn);
    }
    for (const v of message.filterColumns) {
      writer.uint32(18).string(v!);
    }
    if (message.crowdingColumn !== "") {
      writer.uint32(26).string(message.crowdingColumn);
    }
    if (message.embeddingDimension !== undefined) {
      writer.uint32(32).int32(message.embeddingDimension);
    }
    if (message.distanceMeasureType !== 0) {
      writer.uint32(40).int32(message.distanceMeasureType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_IndexConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_IndexConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.treeAhConfig = FeatureView_IndexConfig_TreeAHConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bruteForceConfig = FeatureView_IndexConfig_BruteForceConfig.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.embeddingColumn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filterColumns.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.crowdingColumn = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.embeddingDimension = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.distanceMeasureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_IndexConfig {
    return {
      treeAhConfig: isSet(object.treeAhConfig)
        ? FeatureView_IndexConfig_TreeAHConfig.fromJSON(object.treeAhConfig)
        : undefined,
      bruteForceConfig: isSet(object.bruteForceConfig)
        ? FeatureView_IndexConfig_BruteForceConfig.fromJSON(object.bruteForceConfig)
        : undefined,
      embeddingColumn: isSet(object.embeddingColumn) ? globalThis.String(object.embeddingColumn) : "",
      filterColumns: globalThis.Array.isArray(object?.filterColumns)
        ? object.filterColumns.map((e: any) => globalThis.String(e))
        : [],
      crowdingColumn: isSet(object.crowdingColumn) ? globalThis.String(object.crowdingColumn) : "",
      embeddingDimension: isSet(object.embeddingDimension) ? globalThis.Number(object.embeddingDimension) : undefined,
      distanceMeasureType: isSet(object.distanceMeasureType)
        ? featureView_IndexConfig_DistanceMeasureTypeFromJSON(object.distanceMeasureType)
        : 0,
    };
  },

  toJSON(message: FeatureView_IndexConfig): unknown {
    const obj: any = {};
    if (message.treeAhConfig !== undefined) {
      obj.treeAhConfig = FeatureView_IndexConfig_TreeAHConfig.toJSON(message.treeAhConfig);
    }
    if (message.bruteForceConfig !== undefined) {
      obj.bruteForceConfig = FeatureView_IndexConfig_BruteForceConfig.toJSON(message.bruteForceConfig);
    }
    if (message.embeddingColumn !== "") {
      obj.embeddingColumn = message.embeddingColumn;
    }
    if (message.filterColumns?.length) {
      obj.filterColumns = message.filterColumns;
    }
    if (message.crowdingColumn !== "") {
      obj.crowdingColumn = message.crowdingColumn;
    }
    if (message.embeddingDimension !== undefined) {
      obj.embeddingDimension = Math.round(message.embeddingDimension);
    }
    if (message.distanceMeasureType !== 0) {
      obj.distanceMeasureType = featureView_IndexConfig_DistanceMeasureTypeToJSON(message.distanceMeasureType);
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_IndexConfig>): FeatureView_IndexConfig {
    return FeatureView_IndexConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_IndexConfig>): FeatureView_IndexConfig {
    const message = createBaseFeatureView_IndexConfig();
    message.treeAhConfig = (object.treeAhConfig !== undefined && object.treeAhConfig !== null)
      ? FeatureView_IndexConfig_TreeAHConfig.fromPartial(object.treeAhConfig)
      : undefined;
    message.bruteForceConfig = (object.bruteForceConfig !== undefined && object.bruteForceConfig !== null)
      ? FeatureView_IndexConfig_BruteForceConfig.fromPartial(object.bruteForceConfig)
      : undefined;
    message.embeddingColumn = object.embeddingColumn ?? "";
    message.filterColumns = object.filterColumns?.map((e) => e) || [];
    message.crowdingColumn = object.crowdingColumn ?? "";
    message.embeddingDimension = object.embeddingDimension ?? undefined;
    message.distanceMeasureType = object.distanceMeasureType ?? 0;
    return message;
  },
};

function createBaseFeatureView_IndexConfig_BruteForceConfig(): FeatureView_IndexConfig_BruteForceConfig {
  return {};
}

export const FeatureView_IndexConfig_BruteForceConfig: MessageFns<FeatureView_IndexConfig_BruteForceConfig> = {
  encode(_: FeatureView_IndexConfig_BruteForceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_IndexConfig_BruteForceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_IndexConfig_BruteForceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FeatureView_IndexConfig_BruteForceConfig {
    return {};
  },

  toJSON(_: FeatureView_IndexConfig_BruteForceConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FeatureView_IndexConfig_BruteForceConfig>): FeatureView_IndexConfig_BruteForceConfig {
    return FeatureView_IndexConfig_BruteForceConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FeatureView_IndexConfig_BruteForceConfig>): FeatureView_IndexConfig_BruteForceConfig {
    const message = createBaseFeatureView_IndexConfig_BruteForceConfig();
    return message;
  },
};

function createBaseFeatureView_IndexConfig_TreeAHConfig(): FeatureView_IndexConfig_TreeAHConfig {
  return { leafNodeEmbeddingCount: undefined };
}

export const FeatureView_IndexConfig_TreeAHConfig: MessageFns<FeatureView_IndexConfig_TreeAHConfig> = {
  encode(message: FeatureView_IndexConfig_TreeAHConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafNodeEmbeddingCount !== undefined) {
      writer.uint32(8).int64(message.leafNodeEmbeddingCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_IndexConfig_TreeAHConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_IndexConfig_TreeAHConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leafNodeEmbeddingCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_IndexConfig_TreeAHConfig {
    return {
      leafNodeEmbeddingCount: isSet(object.leafNodeEmbeddingCount)
        ? Long.fromValue(object.leafNodeEmbeddingCount)
        : undefined,
    };
  },

  toJSON(message: FeatureView_IndexConfig_TreeAHConfig): unknown {
    const obj: any = {};
    if (message.leafNodeEmbeddingCount !== undefined) {
      obj.leafNodeEmbeddingCount = (message.leafNodeEmbeddingCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_IndexConfig_TreeAHConfig>): FeatureView_IndexConfig_TreeAHConfig {
    return FeatureView_IndexConfig_TreeAHConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_IndexConfig_TreeAHConfig>): FeatureView_IndexConfig_TreeAHConfig {
    const message = createBaseFeatureView_IndexConfig_TreeAHConfig();
    message.leafNodeEmbeddingCount =
      (object.leafNodeEmbeddingCount !== undefined && object.leafNodeEmbeddingCount !== null)
        ? Long.fromValue(object.leafNodeEmbeddingCount)
        : undefined;
    return message;
  },
};

function createBaseFeatureView_FeatureRegistrySource(): FeatureView_FeatureRegistrySource {
  return { featureGroups: [], projectNumber: undefined };
}

export const FeatureView_FeatureRegistrySource: MessageFns<FeatureView_FeatureRegistrySource> = {
  encode(message: FeatureView_FeatureRegistrySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.featureGroups) {
      FeatureView_FeatureRegistrySource_FeatureGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.projectNumber !== undefined) {
      writer.uint32(16).int64(message.projectNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_FeatureRegistrySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_FeatureRegistrySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureGroups.push(FeatureView_FeatureRegistrySource_FeatureGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.projectNumber = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_FeatureRegistrySource {
    return {
      featureGroups: globalThis.Array.isArray(object?.featureGroups)
        ? object.featureGroups.map((e: any) => FeatureView_FeatureRegistrySource_FeatureGroup.fromJSON(e))
        : [],
      projectNumber: isSet(object.projectNumber) ? Long.fromValue(object.projectNumber) : undefined,
    };
  },

  toJSON(message: FeatureView_FeatureRegistrySource): unknown {
    const obj: any = {};
    if (message.featureGroups?.length) {
      obj.featureGroups = message.featureGroups.map((e) => FeatureView_FeatureRegistrySource_FeatureGroup.toJSON(e));
    }
    if (message.projectNumber !== undefined) {
      obj.projectNumber = (message.projectNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_FeatureRegistrySource>): FeatureView_FeatureRegistrySource {
    return FeatureView_FeatureRegistrySource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_FeatureRegistrySource>): FeatureView_FeatureRegistrySource {
    const message = createBaseFeatureView_FeatureRegistrySource();
    message.featureGroups =
      object.featureGroups?.map((e) => FeatureView_FeatureRegistrySource_FeatureGroup.fromPartial(e)) || [];
    message.projectNumber = (object.projectNumber !== undefined && object.projectNumber !== null)
      ? Long.fromValue(object.projectNumber)
      : undefined;
    return message;
  },
};

function createBaseFeatureView_FeatureRegistrySource_FeatureGroup(): FeatureView_FeatureRegistrySource_FeatureGroup {
  return { featureGroupId: "", featureIds: [] };
}

export const FeatureView_FeatureRegistrySource_FeatureGroup: MessageFns<
  FeatureView_FeatureRegistrySource_FeatureGroup
> = {
  encode(
    message: FeatureView_FeatureRegistrySource_FeatureGroup,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.featureGroupId !== "") {
      writer.uint32(10).string(message.featureGroupId);
    }
    for (const v of message.featureIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_FeatureRegistrySource_FeatureGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_FeatureRegistrySource_FeatureGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureGroupId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.featureIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_FeatureRegistrySource_FeatureGroup {
    return {
      featureGroupId: isSet(object.featureGroupId) ? globalThis.String(object.featureGroupId) : "",
      featureIds: globalThis.Array.isArray(object?.featureIds)
        ? object.featureIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FeatureView_FeatureRegistrySource_FeatureGroup): unknown {
    const obj: any = {};
    if (message.featureGroupId !== "") {
      obj.featureGroupId = message.featureGroupId;
    }
    if (message.featureIds?.length) {
      obj.featureIds = message.featureIds;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FeatureView_FeatureRegistrySource_FeatureGroup>,
  ): FeatureView_FeatureRegistrySource_FeatureGroup {
    return FeatureView_FeatureRegistrySource_FeatureGroup.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FeatureView_FeatureRegistrySource_FeatureGroup>,
  ): FeatureView_FeatureRegistrySource_FeatureGroup {
    const message = createBaseFeatureView_FeatureRegistrySource_FeatureGroup();
    message.featureGroupId = object.featureGroupId ?? "";
    message.featureIds = object.featureIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeatureView_VertexRagSource(): FeatureView_VertexRagSource {
  return { uri: "", ragCorpusId: Long.ZERO };
}

export const FeatureView_VertexRagSource: MessageFns<FeatureView_VertexRagSource> = {
  encode(message: FeatureView_VertexRagSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (!message.ragCorpusId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.ragCorpusId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_VertexRagSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_VertexRagSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ragCorpusId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_VertexRagSource {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      ragCorpusId: isSet(object.ragCorpusId) ? Long.fromValue(object.ragCorpusId) : Long.ZERO,
    };
  },

  toJSON(message: FeatureView_VertexRagSource): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (!message.ragCorpusId.equals(Long.ZERO)) {
      obj.ragCorpusId = (message.ragCorpusId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_VertexRagSource>): FeatureView_VertexRagSource {
    return FeatureView_VertexRagSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_VertexRagSource>): FeatureView_VertexRagSource {
    const message = createBaseFeatureView_VertexRagSource();
    message.uri = object.uri ?? "";
    message.ragCorpusId = (object.ragCorpusId !== undefined && object.ragCorpusId !== null)
      ? Long.fromValue(object.ragCorpusId)
      : Long.ZERO;
    return message;
  },
};

function createBaseFeatureView_LabelsEntry(): FeatureView_LabelsEntry {
  return { key: "", value: "" };
}

export const FeatureView_LabelsEntry: MessageFns<FeatureView_LabelsEntry> = {
  encode(message: FeatureView_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureView_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureView_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureView_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FeatureView_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureView_LabelsEntry>): FeatureView_LabelsEntry {
    return FeatureView_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureView_LabelsEntry>): FeatureView_LabelsEntry {
    const message = createBaseFeatureView_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
