// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/evaluation_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";

export const protobufPackage = "google.cloud.aiplatform.v1";

/** Pairwise prediction autorater preference. */
export enum PairwiseChoice {
  /** PAIRWISE_CHOICE_UNSPECIFIED - Unspecified prediction choice. */
  PAIRWISE_CHOICE_UNSPECIFIED = 0,
  /** BASELINE - Baseline prediction wins */
  BASELINE = 1,
  /** CANDIDATE - Candidate prediction wins */
  CANDIDATE = 2,
  /** TIE - Winner cannot be determined */
  TIE = 3,
  UNRECOGNIZED = -1,
}

export function pairwiseChoiceFromJSON(object: any): PairwiseChoice {
  switch (object) {
    case 0:
    case "PAIRWISE_CHOICE_UNSPECIFIED":
      return PairwiseChoice.PAIRWISE_CHOICE_UNSPECIFIED;
    case 1:
    case "BASELINE":
      return PairwiseChoice.BASELINE;
    case 2:
    case "CANDIDATE":
      return PairwiseChoice.CANDIDATE;
    case 3:
    case "TIE":
      return PairwiseChoice.TIE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PairwiseChoice.UNRECOGNIZED;
  }
}

export function pairwiseChoiceToJSON(object: PairwiseChoice): string {
  switch (object) {
    case PairwiseChoice.PAIRWISE_CHOICE_UNSPECIFIED:
      return "PAIRWISE_CHOICE_UNSPECIFIED";
    case PairwiseChoice.BASELINE:
      return "BASELINE";
    case PairwiseChoice.CANDIDATE:
      return "CANDIDATE";
    case PairwiseChoice.TIE:
      return "TIE";
    case PairwiseChoice.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for EvaluationService.EvaluateInstances. */
export interface EvaluateInstancesRequest {
  /**
   * Auto metric instances.
   * Instances and metric spec for exact match metric.
   */
  exactMatchInput?:
    | ExactMatchInput
    | undefined;
  /** Instances and metric spec for bleu metric. */
  bleuInput?:
    | BleuInput
    | undefined;
  /** Instances and metric spec for rouge metric. */
  rougeInput?:
    | RougeInput
    | undefined;
  /**
   * LLM-based metric instance.
   * General text generation metrics, applicable to other categories.
   * Input for fluency metric.
   */
  fluencyInput?:
    | FluencyInput
    | undefined;
  /** Input for coherence metric. */
  coherenceInput?:
    | CoherenceInput
    | undefined;
  /** Input for safety metric. */
  safetyInput?:
    | SafetyInput
    | undefined;
  /** Input for groundedness metric. */
  groundednessInput?:
    | GroundednessInput
    | undefined;
  /** Input for fulfillment metric. */
  fulfillmentInput?:
    | FulfillmentInput
    | undefined;
  /** Input for summarization quality metric. */
  summarizationQualityInput?:
    | SummarizationQualityInput
    | undefined;
  /** Input for pairwise summarization quality metric. */
  pairwiseSummarizationQualityInput?:
    | PairwiseSummarizationQualityInput
    | undefined;
  /** Input for summarization helpfulness metric. */
  summarizationHelpfulnessInput?:
    | SummarizationHelpfulnessInput
    | undefined;
  /** Input for summarization verbosity metric. */
  summarizationVerbosityInput?:
    | SummarizationVerbosityInput
    | undefined;
  /** Input for question answering quality metric. */
  questionAnsweringQualityInput?:
    | QuestionAnsweringQualityInput
    | undefined;
  /** Input for pairwise question answering quality metric. */
  pairwiseQuestionAnsweringQualityInput?:
    | PairwiseQuestionAnsweringQualityInput
    | undefined;
  /** Input for question answering relevance metric. */
  questionAnsweringRelevanceInput?:
    | QuestionAnsweringRelevanceInput
    | undefined;
  /**
   * Input for question answering helpfulness
   * metric.
   */
  questionAnsweringHelpfulnessInput?:
    | QuestionAnsweringHelpfulnessInput
    | undefined;
  /**
   * Input for question answering correctness
   * metric.
   */
  questionAnsweringCorrectnessInput?:
    | QuestionAnsweringCorrectnessInput
    | undefined;
  /** Input for pointwise metric. */
  pointwiseMetricInput?:
    | PointwiseMetricInput
    | undefined;
  /** Input for pairwise metric. */
  pairwiseMetricInput?:
    | PairwiseMetricInput
    | undefined;
  /**
   * Tool call metric instances.
   * Input for tool call valid metric.
   */
  toolCallValidInput?:
    | ToolCallValidInput
    | undefined;
  /** Input for tool name match metric. */
  toolNameMatchInput?:
    | ToolNameMatchInput
    | undefined;
  /** Input for tool parameter key match metric. */
  toolParameterKeyMatchInput?:
    | ToolParameterKeyMatchInput
    | undefined;
  /** Input for tool parameter key value match metric. */
  toolParameterKvMatchInput?:
    | ToolParameterKVMatchInput
    | undefined;
  /**
   * Required. The resource name of the Location to evaluate the instances.
   * Format: `projects/{project}/locations/{location}`
   */
  location: string;
}

/** Response message for EvaluationService.EvaluateInstances. */
export interface EvaluateInstancesResponse {
  /**
   * Auto metric evaluation results.
   * Results for exact match metric.
   */
  exactMatchResults?:
    | ExactMatchResults
    | undefined;
  /** Results for bleu metric. */
  bleuResults?:
    | BleuResults
    | undefined;
  /** Results for rouge metric. */
  rougeResults?:
    | RougeResults
    | undefined;
  /**
   * LLM-based metric evaluation result.
   * General text generation metrics, applicable to other categories.
   * Result for fluency metric.
   */
  fluencyResult?:
    | FluencyResult
    | undefined;
  /** Result for coherence metric. */
  coherenceResult?:
    | CoherenceResult
    | undefined;
  /** Result for safety metric. */
  safetyResult?:
    | SafetyResult
    | undefined;
  /** Result for groundedness metric. */
  groundednessResult?:
    | GroundednessResult
    | undefined;
  /** Result for fulfillment metric. */
  fulfillmentResult?:
    | FulfillmentResult
    | undefined;
  /**
   * Summarization only metrics.
   * Result for summarization quality metric.
   */
  summarizationQualityResult?:
    | SummarizationQualityResult
    | undefined;
  /** Result for pairwise summarization quality metric. */
  pairwiseSummarizationQualityResult?:
    | PairwiseSummarizationQualityResult
    | undefined;
  /** Result for summarization helpfulness metric. */
  summarizationHelpfulnessResult?:
    | SummarizationHelpfulnessResult
    | undefined;
  /** Result for summarization verbosity metric. */
  summarizationVerbosityResult?:
    | SummarizationVerbosityResult
    | undefined;
  /**
   * Question answering only metrics.
   * Result for question answering quality metric.
   */
  questionAnsweringQualityResult?:
    | QuestionAnsweringQualityResult
    | undefined;
  /** Result for pairwise question answering quality metric. */
  pairwiseQuestionAnsweringQualityResult?:
    | PairwiseQuestionAnsweringQualityResult
    | undefined;
  /** Result for question answering relevance metric. */
  questionAnsweringRelevanceResult?:
    | QuestionAnsweringRelevanceResult
    | undefined;
  /** Result for question answering helpfulness metric. */
  questionAnsweringHelpfulnessResult?:
    | QuestionAnsweringHelpfulnessResult
    | undefined;
  /** Result for question answering correctness metric. */
  questionAnsweringCorrectnessResult?:
    | QuestionAnsweringCorrectnessResult
    | undefined;
  /**
   * Generic metrics.
   * Result for pointwise metric.
   */
  pointwiseMetricResult?:
    | PointwiseMetricResult
    | undefined;
  /** Result for pairwise metric. */
  pairwiseMetricResult?:
    | PairwiseMetricResult
    | undefined;
  /**
   * Tool call metrics.
   *  Results for tool call valid metric.
   */
  toolCallValidResults?:
    | ToolCallValidResults
    | undefined;
  /** Results for tool name match metric. */
  toolNameMatchResults?:
    | ToolNameMatchResults
    | undefined;
  /** Results for tool parameter key match  metric. */
  toolParameterKeyMatchResults?:
    | ToolParameterKeyMatchResults
    | undefined;
  /** Results for tool parameter key value match metric. */
  toolParameterKvMatchResults?: ToolParameterKVMatchResults | undefined;
}

/** Input for exact match metric. */
export interface ExactMatchInput {
  /** Required. Spec for exact match metric. */
  metricSpec:
    | ExactMatchSpec
    | undefined;
  /** Required. Repeated exact match instances. */
  instances: ExactMatchInstance[];
}

/** Spec for exact match instance. */
export interface ExactMatchInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/**
 * Spec for exact match metric - returns 1 if prediction and reference exactly
 * matches, otherwise 0.
 */
export interface ExactMatchSpec {
}

/** Results for exact match metric. */
export interface ExactMatchResults {
  /** Output only. Exact match metric values. */
  exactMatchMetricValues: ExactMatchMetricValue[];
}

/** Exact match metric value for an instance. */
export interface ExactMatchMetricValue {
  /** Output only. Exact match score. */
  score?: number | undefined;
}

/** Input for bleu metric. */
export interface BleuInput {
  /** Required. Spec for bleu score metric. */
  metricSpec:
    | BleuSpec
    | undefined;
  /** Required. Repeated bleu instances. */
  instances: BleuInstance[];
}

/** Spec for bleu instance. */
export interface BleuInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/**
 * Spec for bleu score metric - calculates the precision of n-grams in the
 * prediction as compared to reference - returns a score ranging between 0 to 1.
 */
export interface BleuSpec {
  /** Optional. Whether to use_effective_order to compute bleu score. */
  useEffectiveOrder: boolean;
}

/** Results for bleu metric. */
export interface BleuResults {
  /** Output only. Bleu metric values. */
  bleuMetricValues: BleuMetricValue[];
}

/** Bleu metric value for an instance. */
export interface BleuMetricValue {
  /** Output only. Bleu score. */
  score?: number | undefined;
}

/** Input for rouge metric. */
export interface RougeInput {
  /** Required. Spec for rouge score metric. */
  metricSpec:
    | RougeSpec
    | undefined;
  /** Required. Repeated rouge instances. */
  instances: RougeInstance[];
}

/** Spec for rouge instance. */
export interface RougeInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/**
 * Spec for rouge score metric - calculates the recall of n-grams in prediction
 * as compared to reference - returns a score ranging between 0 and 1.
 */
export interface RougeSpec {
  /** Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum. */
  rougeType: string;
  /** Optional. Whether to use stemmer to compute rouge score. */
  useStemmer: boolean;
  /** Optional. Whether to split summaries while using rougeLsum. */
  splitSummaries: boolean;
}

/** Results for rouge metric. */
export interface RougeResults {
  /** Output only. Rouge metric values. */
  rougeMetricValues: RougeMetricValue[];
}

/** Rouge metric value for an instance. */
export interface RougeMetricValue {
  /** Output only. Rouge score. */
  score?: number | undefined;
}

/** Input for coherence metric. */
export interface CoherenceInput {
  /** Required. Spec for coherence score metric. */
  metricSpec:
    | CoherenceSpec
    | undefined;
  /** Required. Coherence instance. */
  instance: CoherenceInstance | undefined;
}

/** Spec for coherence instance. */
export interface CoherenceInstance {
  /** Required. Output of the evaluated model. */
  prediction?: string | undefined;
}

/** Spec for coherence score metric. */
export interface CoherenceSpec {
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for coherence result. */
export interface CoherenceResult {
  /** Output only. Coherence score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for coherence score. */
  explanation: string;
  /** Output only. Confidence for coherence score. */
  confidence?: number | undefined;
}

/** Input for fluency metric. */
export interface FluencyInput {
  /** Required. Spec for fluency score metric. */
  metricSpec:
    | FluencySpec
    | undefined;
  /** Required. Fluency instance. */
  instance: FluencyInstance | undefined;
}

/** Spec for fluency instance. */
export interface FluencyInstance {
  /** Required. Output of the evaluated model. */
  prediction?: string | undefined;
}

/** Spec for fluency score metric. */
export interface FluencySpec {
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for fluency result. */
export interface FluencyResult {
  /** Output only. Fluency score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for fluency score. */
  explanation: string;
  /** Output only. Confidence for fluency score. */
  confidence?: number | undefined;
}

/** Input for safety metric. */
export interface SafetyInput {
  /** Required. Spec for safety metric. */
  metricSpec:
    | SafetySpec
    | undefined;
  /** Required. Safety instance. */
  instance: SafetyInstance | undefined;
}

/** Spec for safety instance. */
export interface SafetyInstance {
  /** Required. Output of the evaluated model. */
  prediction?: string | undefined;
}

/** Spec for safety metric. */
export interface SafetySpec {
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for safety result. */
export interface SafetyResult {
  /** Output only. Safety score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for safety score. */
  explanation: string;
  /** Output only. Confidence for safety score. */
  confidence?: number | undefined;
}

/** Input for groundedness metric. */
export interface GroundednessInput {
  /** Required. Spec for groundedness metric. */
  metricSpec:
    | GroundednessSpec
    | undefined;
  /** Required. Groundedness instance. */
  instance: GroundednessInstance | undefined;
}

/** Spec for groundedness instance. */
export interface GroundednessInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /**
   * Required. Background information provided in context used to compare
   * against the prediction.
   */
  context?: string | undefined;
}

/** Spec for groundedness metric. */
export interface GroundednessSpec {
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for groundedness result. */
export interface GroundednessResult {
  /** Output only. Groundedness score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for groundedness score. */
  explanation: string;
  /** Output only. Confidence for groundedness score. */
  confidence?: number | undefined;
}

/** Input for fulfillment metric. */
export interface FulfillmentInput {
  /** Required. Spec for fulfillment score metric. */
  metricSpec:
    | FulfillmentSpec
    | undefined;
  /** Required. Fulfillment instance. */
  instance: FulfillmentInstance | undefined;
}

/** Spec for fulfillment instance. */
export interface FulfillmentInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Inference instruction prompt to compare prediction with. */
  instruction?: string | undefined;
}

/** Spec for fulfillment metric. */
export interface FulfillmentSpec {
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for fulfillment result. */
export interface FulfillmentResult {
  /** Output only. Fulfillment score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for fulfillment score. */
  explanation: string;
  /** Output only. Confidence for fulfillment score. */
  confidence?: number | undefined;
}

/** Input for summarization quality metric. */
export interface SummarizationQualityInput {
  /** Required. Spec for summarization quality score metric. */
  metricSpec:
    | SummarizationQualitySpec
    | undefined;
  /** Required. Summarization quality instance. */
  instance: SummarizationQualityInstance | undefined;
}

/** Spec for summarization quality instance. */
export interface SummarizationQualityInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to be summarized. */
  context?:
    | string
    | undefined;
  /** Required. Summarization prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for summarization quality score metric. */
export interface SummarizationQualitySpec {
  /**
   * Optional. Whether to use instance.reference to compute summarization
   * quality.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for summarization quality result. */
export interface SummarizationQualityResult {
  /** Output only. Summarization Quality score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for summarization quality score. */
  explanation: string;
  /** Output only. Confidence for summarization quality score. */
  confidence?: number | undefined;
}

/** Input for pairwise summarization quality metric. */
export interface PairwiseSummarizationQualityInput {
  /** Required. Spec for pairwise summarization quality score metric. */
  metricSpec:
    | PairwiseSummarizationQualitySpec
    | undefined;
  /** Required. Pairwise summarization quality instance. */
  instance: PairwiseSummarizationQualityInstance | undefined;
}

/** Spec for pairwise summarization quality instance. */
export interface PairwiseSummarizationQualityInstance {
  /** Required. Output of the candidate model. */
  prediction?:
    | string
    | undefined;
  /** Required. Output of the baseline model. */
  baselinePrediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to be summarized. */
  context?:
    | string
    | undefined;
  /** Required. Summarization prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for pairwise summarization quality score metric. */
export interface PairwiseSummarizationQualitySpec {
  /**
   * Optional. Whether to use instance.reference to compute pairwise
   * summarization quality.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for pairwise summarization quality result. */
export interface PairwiseSummarizationQualityResult {
  /** Output only. Pairwise summarization prediction choice. */
  pairwiseChoice: PairwiseChoice;
  /** Output only. Explanation for summarization quality score. */
  explanation: string;
  /** Output only. Confidence for summarization quality score. */
  confidence?: number | undefined;
}

/** Input for summarization helpfulness metric. */
export interface SummarizationHelpfulnessInput {
  /** Required. Spec for summarization helpfulness score metric. */
  metricSpec:
    | SummarizationHelpfulnessSpec
    | undefined;
  /** Required. Summarization helpfulness instance. */
  instance: SummarizationHelpfulnessInstance | undefined;
}

/** Spec for summarization helpfulness instance. */
export interface SummarizationHelpfulnessInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to be summarized. */
  context?:
    | string
    | undefined;
  /** Optional. Summarization prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for summarization helpfulness score metric. */
export interface SummarizationHelpfulnessSpec {
  /**
   * Optional. Whether to use instance.reference to compute summarization
   * helpfulness.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for summarization helpfulness result. */
export interface SummarizationHelpfulnessResult {
  /** Output only. Summarization Helpfulness score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for summarization helpfulness score. */
  explanation: string;
  /** Output only. Confidence for summarization helpfulness score. */
  confidence?: number | undefined;
}

/** Input for summarization verbosity metric. */
export interface SummarizationVerbosityInput {
  /** Required. Spec for summarization verbosity score metric. */
  metricSpec:
    | SummarizationVerbositySpec
    | undefined;
  /** Required. Summarization verbosity instance. */
  instance: SummarizationVerbosityInstance | undefined;
}

/** Spec for summarization verbosity instance. */
export interface SummarizationVerbosityInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to be summarized. */
  context?:
    | string
    | undefined;
  /** Optional. Summarization prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for summarization verbosity score metric. */
export interface SummarizationVerbositySpec {
  /**
   * Optional. Whether to use instance.reference to compute summarization
   * verbosity.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for summarization verbosity result. */
export interface SummarizationVerbosityResult {
  /** Output only. Summarization Verbosity score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for summarization verbosity score. */
  explanation: string;
  /** Output only. Confidence for summarization verbosity score. */
  confidence?: number | undefined;
}

/** Input for question answering quality metric. */
export interface QuestionAnsweringQualityInput {
  /** Required. Spec for question answering quality score metric. */
  metricSpec:
    | QuestionAnsweringQualitySpec
    | undefined;
  /** Required. Question answering quality instance. */
  instance: QuestionAnsweringQualityInstance | undefined;
}

/** Spec for question answering quality instance. */
export interface QuestionAnsweringQualityInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to answer the question. */
  context?:
    | string
    | undefined;
  /** Required. Question Answering prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for question answering quality score metric. */
export interface QuestionAnsweringQualitySpec {
  /**
   * Optional. Whether to use instance.reference to compute question answering
   * quality.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for question answering quality result. */
export interface QuestionAnsweringQualityResult {
  /** Output only. Question Answering Quality score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for question answering quality score. */
  explanation: string;
  /** Output only. Confidence for question answering quality score. */
  confidence?: number | undefined;
}

/** Input for pairwise question answering quality metric. */
export interface PairwiseQuestionAnsweringQualityInput {
  /** Required. Spec for pairwise question answering quality score metric. */
  metricSpec:
    | PairwiseQuestionAnsweringQualitySpec
    | undefined;
  /** Required. Pairwise question answering quality instance. */
  instance: PairwiseQuestionAnsweringQualityInstance | undefined;
}

/** Spec for pairwise question answering quality instance. */
export interface PairwiseQuestionAnsweringQualityInstance {
  /** Required. Output of the candidate model. */
  prediction?:
    | string
    | undefined;
  /** Required. Output of the baseline model. */
  baselinePrediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Required. Text to answer the question. */
  context?:
    | string
    | undefined;
  /** Required. Question Answering prompt for LLM. */
  instruction?: string | undefined;
}

/** Spec for pairwise question answering quality score metric. */
export interface PairwiseQuestionAnsweringQualitySpec {
  /**
   * Optional. Whether to use instance.reference to compute question answering
   * quality.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for pairwise question answering quality result. */
export interface PairwiseQuestionAnsweringQualityResult {
  /** Output only. Pairwise question answering prediction choice. */
  pairwiseChoice: PairwiseChoice;
  /** Output only. Explanation for question answering quality score. */
  explanation: string;
  /** Output only. Confidence for question answering quality score. */
  confidence?: number | undefined;
}

/** Input for question answering relevance metric. */
export interface QuestionAnsweringRelevanceInput {
  /** Required. Spec for question answering relevance score metric. */
  metricSpec:
    | QuestionAnsweringRelevanceSpec
    | undefined;
  /** Required. Question answering relevance instance. */
  instance: QuestionAnsweringRelevanceInstance | undefined;
}

/** Spec for question answering relevance instance. */
export interface QuestionAnsweringRelevanceInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Optional. Text provided as context to answer the question. */
  context?:
    | string
    | undefined;
  /** Required. The question asked and other instruction in the inference prompt. */
  instruction?: string | undefined;
}

/** Spec for question answering relevance metric. */
export interface QuestionAnsweringRelevanceSpec {
  /**
   * Optional. Whether to use instance.reference to compute question answering
   * relevance.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for question answering relevance result. */
export interface QuestionAnsweringRelevanceResult {
  /** Output only. Question Answering Relevance score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for question answering relevance score. */
  explanation: string;
  /** Output only. Confidence for question answering relevance score. */
  confidence?: number | undefined;
}

/** Input for question answering helpfulness metric. */
export interface QuestionAnsweringHelpfulnessInput {
  /** Required. Spec for question answering helpfulness score metric. */
  metricSpec:
    | QuestionAnsweringHelpfulnessSpec
    | undefined;
  /** Required. Question answering helpfulness instance. */
  instance: QuestionAnsweringHelpfulnessInstance | undefined;
}

/** Spec for question answering helpfulness instance. */
export interface QuestionAnsweringHelpfulnessInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Optional. Text provided as context to answer the question. */
  context?:
    | string
    | undefined;
  /** Required. The question asked and other instruction in the inference prompt. */
  instruction?: string | undefined;
}

/** Spec for question answering helpfulness metric. */
export interface QuestionAnsweringHelpfulnessSpec {
  /**
   * Optional. Whether to use instance.reference to compute question answering
   * helpfulness.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for question answering helpfulness result. */
export interface QuestionAnsweringHelpfulnessResult {
  /** Output only. Question Answering Helpfulness score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for question answering helpfulness score. */
  explanation: string;
  /** Output only. Confidence for question answering helpfulness score. */
  confidence?: number | undefined;
}

/** Input for question answering correctness metric. */
export interface QuestionAnsweringCorrectnessInput {
  /** Required. Spec for question answering correctness score metric. */
  metricSpec:
    | QuestionAnsweringCorrectnessSpec
    | undefined;
  /** Required. Question answering correctness instance. */
  instance: QuestionAnsweringCorrectnessInstance | undefined;
}

/** Spec for question answering correctness instance. */
export interface QuestionAnsweringCorrectnessInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Optional. Ground truth used to compare against the prediction. */
  reference?:
    | string
    | undefined;
  /** Optional. Text provided as context to answer the question. */
  context?:
    | string
    | undefined;
  /** Required. The question asked and other instruction in the inference prompt. */
  instruction?: string | undefined;
}

/** Spec for question answering correctness metric. */
export interface QuestionAnsweringCorrectnessSpec {
  /**
   * Optional. Whether to use instance.reference to compute question answering
   * correctness.
   */
  useReference: boolean;
  /** Optional. Which version to use for evaluation. */
  version: number;
}

/** Spec for question answering correctness result. */
export interface QuestionAnsweringCorrectnessResult {
  /** Output only. Question Answering Correctness score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for question answering correctness score. */
  explanation: string;
  /** Output only. Confidence for question answering correctness score. */
  confidence?: number | undefined;
}

/** Input for pointwise metric. */
export interface PointwiseMetricInput {
  /** Required. Spec for pointwise metric. */
  metricSpec:
    | PointwiseMetricSpec
    | undefined;
  /** Required. Pointwise metric instance. */
  instance: PointwiseMetricInstance | undefined;
}

/**
 * Pointwise metric instance. Usually one instance corresponds to one row in an
 * evaluation dataset.
 */
export interface PointwiseMetricInstance {
  /**
   * Instance specified as a json string. String key-value pairs are expected
   * in the json_instance to render
   * PointwiseMetricSpec.instance_prompt_template.
   */
  jsonInstance?: string | undefined;
}

/** Spec for pointwise metric. */
export interface PointwiseMetricSpec {
  /** Required. Metric prompt template for pointwise metric. */
  metricPromptTemplate?: string | undefined;
}

/** Spec for pointwise metric result. */
export interface PointwiseMetricResult {
  /** Output only. Pointwise metric score. */
  score?:
    | number
    | undefined;
  /** Output only. Explanation for pointwise metric score. */
  explanation: string;
}

/** Input for pairwise metric. */
export interface PairwiseMetricInput {
  /** Required. Spec for pairwise metric. */
  metricSpec:
    | PairwiseMetricSpec
    | undefined;
  /** Required. Pairwise metric instance. */
  instance: PairwiseMetricInstance | undefined;
}

/**
 * Pairwise metric instance. Usually one instance corresponds to one row in an
 * evaluation dataset.
 */
export interface PairwiseMetricInstance {
  /**
   * Instance specified as a json string. String key-value pairs are expected
   * in the json_instance to render
   * PairwiseMetricSpec.instance_prompt_template.
   */
  jsonInstance?: string | undefined;
}

/** Spec for pairwise metric. */
export interface PairwiseMetricSpec {
  /** Required. Metric prompt template for pairwise metric. */
  metricPromptTemplate?: string | undefined;
}

/** Spec for pairwise metric result. */
export interface PairwiseMetricResult {
  /** Output only. Pairwise metric choice. */
  pairwiseChoice: PairwiseChoice;
  /** Output only. Explanation for pairwise metric score. */
  explanation: string;
}

/** Input for tool call valid metric. */
export interface ToolCallValidInput {
  /** Required. Spec for tool call valid metric. */
  metricSpec:
    | ToolCallValidSpec
    | undefined;
  /** Required. Repeated tool call valid instances. */
  instances: ToolCallValidInstance[];
}

/** Spec for tool call valid metric. */
export interface ToolCallValidSpec {
}

/** Spec for tool call valid instance. */
export interface ToolCallValidInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/** Results for tool call valid metric. */
export interface ToolCallValidResults {
  /** Output only. Tool call valid metric values. */
  toolCallValidMetricValues: ToolCallValidMetricValue[];
}

/** Tool call valid metric value for an instance. */
export interface ToolCallValidMetricValue {
  /** Output only. Tool call valid score. */
  score?: number | undefined;
}

/** Input for tool name match metric. */
export interface ToolNameMatchInput {
  /** Required. Spec for tool name match metric. */
  metricSpec:
    | ToolNameMatchSpec
    | undefined;
  /** Required. Repeated tool name match instances. */
  instances: ToolNameMatchInstance[];
}

/** Spec for tool name match metric. */
export interface ToolNameMatchSpec {
}

/** Spec for tool name match instance. */
export interface ToolNameMatchInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/** Results for tool name match metric. */
export interface ToolNameMatchResults {
  /** Output only. Tool name match metric values. */
  toolNameMatchMetricValues: ToolNameMatchMetricValue[];
}

/** Tool name match metric value for an instance. */
export interface ToolNameMatchMetricValue {
  /** Output only. Tool name match score. */
  score?: number | undefined;
}

/** Input for tool parameter key match metric. */
export interface ToolParameterKeyMatchInput {
  /** Required. Spec for tool parameter key match metric. */
  metricSpec:
    | ToolParameterKeyMatchSpec
    | undefined;
  /** Required. Repeated tool parameter key match instances. */
  instances: ToolParameterKeyMatchInstance[];
}

/** Spec for tool parameter key match metric. */
export interface ToolParameterKeyMatchSpec {
}

/** Spec for tool parameter key match instance. */
export interface ToolParameterKeyMatchInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/** Results for tool parameter key match metric. */
export interface ToolParameterKeyMatchResults {
  /** Output only. Tool parameter key match metric values. */
  toolParameterKeyMatchMetricValues: ToolParameterKeyMatchMetricValue[];
}

/** Tool parameter key match metric value for an instance. */
export interface ToolParameterKeyMatchMetricValue {
  /** Output only. Tool parameter key match score. */
  score?: number | undefined;
}

/** Input for tool parameter key value match metric. */
export interface ToolParameterKVMatchInput {
  /** Required. Spec for tool parameter key value match metric. */
  metricSpec:
    | ToolParameterKVMatchSpec
    | undefined;
  /** Required. Repeated tool parameter key value match instances. */
  instances: ToolParameterKVMatchInstance[];
}

/** Spec for tool parameter key value match metric. */
export interface ToolParameterKVMatchSpec {
  /** Optional. Whether to use STRCIT string match on parameter values. */
  useStrictStringMatch: boolean;
}

/** Spec for tool parameter key value match instance. */
export interface ToolParameterKVMatchInstance {
  /** Required. Output of the evaluated model. */
  prediction?:
    | string
    | undefined;
  /** Required. Ground truth used to compare against the prediction. */
  reference?: string | undefined;
}

/** Results for tool parameter key value match metric. */
export interface ToolParameterKVMatchResults {
  /** Output only. Tool parameter key value match metric values. */
  toolParameterKvMatchMetricValues: ToolParameterKVMatchMetricValue[];
}

/** Tool parameter key value match metric value for an instance. */
export interface ToolParameterKVMatchMetricValue {
  /** Output only. Tool parameter key value match score. */
  score?: number | undefined;
}

function createBaseEvaluateInstancesRequest(): EvaluateInstancesRequest {
  return {
    exactMatchInput: undefined,
    bleuInput: undefined,
    rougeInput: undefined,
    fluencyInput: undefined,
    coherenceInput: undefined,
    safetyInput: undefined,
    groundednessInput: undefined,
    fulfillmentInput: undefined,
    summarizationQualityInput: undefined,
    pairwiseSummarizationQualityInput: undefined,
    summarizationHelpfulnessInput: undefined,
    summarizationVerbosityInput: undefined,
    questionAnsweringQualityInput: undefined,
    pairwiseQuestionAnsweringQualityInput: undefined,
    questionAnsweringRelevanceInput: undefined,
    questionAnsweringHelpfulnessInput: undefined,
    questionAnsweringCorrectnessInput: undefined,
    pointwiseMetricInput: undefined,
    pairwiseMetricInput: undefined,
    toolCallValidInput: undefined,
    toolNameMatchInput: undefined,
    toolParameterKeyMatchInput: undefined,
    toolParameterKvMatchInput: undefined,
    location: "",
  };
}

export const EvaluateInstancesRequest: MessageFns<EvaluateInstancesRequest> = {
  encode(message: EvaluateInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatchInput !== undefined) {
      ExactMatchInput.encode(message.exactMatchInput, writer.uint32(18).fork()).join();
    }
    if (message.bleuInput !== undefined) {
      BleuInput.encode(message.bleuInput, writer.uint32(26).fork()).join();
    }
    if (message.rougeInput !== undefined) {
      RougeInput.encode(message.rougeInput, writer.uint32(34).fork()).join();
    }
    if (message.fluencyInput !== undefined) {
      FluencyInput.encode(message.fluencyInput, writer.uint32(42).fork()).join();
    }
    if (message.coherenceInput !== undefined) {
      CoherenceInput.encode(message.coherenceInput, writer.uint32(50).fork()).join();
    }
    if (message.safetyInput !== undefined) {
      SafetyInput.encode(message.safetyInput, writer.uint32(66).fork()).join();
    }
    if (message.groundednessInput !== undefined) {
      GroundednessInput.encode(message.groundednessInput, writer.uint32(74).fork()).join();
    }
    if (message.fulfillmentInput !== undefined) {
      FulfillmentInput.encode(message.fulfillmentInput, writer.uint32(98).fork()).join();
    }
    if (message.summarizationQualityInput !== undefined) {
      SummarizationQualityInput.encode(message.summarizationQualityInput, writer.uint32(58).fork()).join();
    }
    if (message.pairwiseSummarizationQualityInput !== undefined) {
      PairwiseSummarizationQualityInput.encode(message.pairwiseSummarizationQualityInput, writer.uint32(186).fork())
        .join();
    }
    if (message.summarizationHelpfulnessInput !== undefined) {
      SummarizationHelpfulnessInput.encode(message.summarizationHelpfulnessInput, writer.uint32(114).fork()).join();
    }
    if (message.summarizationVerbosityInput !== undefined) {
      SummarizationVerbosityInput.encode(message.summarizationVerbosityInput, writer.uint32(122).fork()).join();
    }
    if (message.questionAnsweringQualityInput !== undefined) {
      QuestionAnsweringQualityInput.encode(message.questionAnsweringQualityInput, writer.uint32(82).fork()).join();
    }
    if (message.pairwiseQuestionAnsweringQualityInput !== undefined) {
      PairwiseQuestionAnsweringQualityInput.encode(
        message.pairwiseQuestionAnsweringQualityInput,
        writer.uint32(194).fork(),
      ).join();
    }
    if (message.questionAnsweringRelevanceInput !== undefined) {
      QuestionAnsweringRelevanceInput.encode(message.questionAnsweringRelevanceInput, writer.uint32(130).fork()).join();
    }
    if (message.questionAnsweringHelpfulnessInput !== undefined) {
      QuestionAnsweringHelpfulnessInput.encode(message.questionAnsweringHelpfulnessInput, writer.uint32(138).fork())
        .join();
    }
    if (message.questionAnsweringCorrectnessInput !== undefined) {
      QuestionAnsweringCorrectnessInput.encode(message.questionAnsweringCorrectnessInput, writer.uint32(146).fork())
        .join();
    }
    if (message.pointwiseMetricInput !== undefined) {
      PointwiseMetricInput.encode(message.pointwiseMetricInput, writer.uint32(226).fork()).join();
    }
    if (message.pairwiseMetricInput !== undefined) {
      PairwiseMetricInput.encode(message.pairwiseMetricInput, writer.uint32(234).fork()).join();
    }
    if (message.toolCallValidInput !== undefined) {
      ToolCallValidInput.encode(message.toolCallValidInput, writer.uint32(154).fork()).join();
    }
    if (message.toolNameMatchInput !== undefined) {
      ToolNameMatchInput.encode(message.toolNameMatchInput, writer.uint32(162).fork()).join();
    }
    if (message.toolParameterKeyMatchInput !== undefined) {
      ToolParameterKeyMatchInput.encode(message.toolParameterKeyMatchInput, writer.uint32(170).fork()).join();
    }
    if (message.toolParameterKvMatchInput !== undefined) {
      ToolParameterKVMatchInput.encode(message.toolParameterKvMatchInput, writer.uint32(178).fork()).join();
    }
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exactMatchInput = ExactMatchInput.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bleuInput = BleuInput.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rougeInput = RougeInput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fluencyInput = FluencyInput.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.coherenceInput = CoherenceInput.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.safetyInput = SafetyInput.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.groundednessInput = GroundednessInput.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.fulfillmentInput = FulfillmentInput.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.summarizationQualityInput = SummarizationQualityInput.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.pairwiseSummarizationQualityInput = PairwiseSummarizationQualityInput.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.summarizationHelpfulnessInput = SummarizationHelpfulnessInput.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.summarizationVerbosityInput = SummarizationVerbosityInput.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.questionAnsweringQualityInput = QuestionAnsweringQualityInput.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.pairwiseQuestionAnsweringQualityInput = PairwiseQuestionAnsweringQualityInput.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.questionAnsweringRelevanceInput = QuestionAnsweringRelevanceInput.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.questionAnsweringHelpfulnessInput = QuestionAnsweringHelpfulnessInput.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.questionAnsweringCorrectnessInput = QuestionAnsweringCorrectnessInput.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.pointwiseMetricInput = PointwiseMetricInput.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.pairwiseMetricInput = PairwiseMetricInput.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.toolCallValidInput = ToolCallValidInput.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.toolNameMatchInput = ToolNameMatchInput.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.toolParameterKeyMatchInput = ToolParameterKeyMatchInput.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.toolParameterKvMatchInput = ToolParameterKVMatchInput.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateInstancesRequest {
    return {
      exactMatchInput: isSet(object.exactMatchInput) ? ExactMatchInput.fromJSON(object.exactMatchInput) : undefined,
      bleuInput: isSet(object.bleuInput) ? BleuInput.fromJSON(object.bleuInput) : undefined,
      rougeInput: isSet(object.rougeInput) ? RougeInput.fromJSON(object.rougeInput) : undefined,
      fluencyInput: isSet(object.fluencyInput) ? FluencyInput.fromJSON(object.fluencyInput) : undefined,
      coherenceInput: isSet(object.coherenceInput) ? CoherenceInput.fromJSON(object.coherenceInput) : undefined,
      safetyInput: isSet(object.safetyInput) ? SafetyInput.fromJSON(object.safetyInput) : undefined,
      groundednessInput: isSet(object.groundednessInput)
        ? GroundednessInput.fromJSON(object.groundednessInput)
        : undefined,
      fulfillmentInput: isSet(object.fulfillmentInput) ? FulfillmentInput.fromJSON(object.fulfillmentInput) : undefined,
      summarizationQualityInput: isSet(object.summarizationQualityInput)
        ? SummarizationQualityInput.fromJSON(object.summarizationQualityInput)
        : undefined,
      pairwiseSummarizationQualityInput: isSet(object.pairwiseSummarizationQualityInput)
        ? PairwiseSummarizationQualityInput.fromJSON(object.pairwiseSummarizationQualityInput)
        : undefined,
      summarizationHelpfulnessInput: isSet(object.summarizationHelpfulnessInput)
        ? SummarizationHelpfulnessInput.fromJSON(object.summarizationHelpfulnessInput)
        : undefined,
      summarizationVerbosityInput: isSet(object.summarizationVerbosityInput)
        ? SummarizationVerbosityInput.fromJSON(object.summarizationVerbosityInput)
        : undefined,
      questionAnsweringQualityInput: isSet(object.questionAnsweringQualityInput)
        ? QuestionAnsweringQualityInput.fromJSON(object.questionAnsweringQualityInput)
        : undefined,
      pairwiseQuestionAnsweringQualityInput: isSet(object.pairwiseQuestionAnsweringQualityInput)
        ? PairwiseQuestionAnsweringQualityInput.fromJSON(object.pairwiseQuestionAnsweringQualityInput)
        : undefined,
      questionAnsweringRelevanceInput: isSet(object.questionAnsweringRelevanceInput)
        ? QuestionAnsweringRelevanceInput.fromJSON(object.questionAnsweringRelevanceInput)
        : undefined,
      questionAnsweringHelpfulnessInput: isSet(object.questionAnsweringHelpfulnessInput)
        ? QuestionAnsweringHelpfulnessInput.fromJSON(object.questionAnsweringHelpfulnessInput)
        : undefined,
      questionAnsweringCorrectnessInput: isSet(object.questionAnsweringCorrectnessInput)
        ? QuestionAnsweringCorrectnessInput.fromJSON(object.questionAnsweringCorrectnessInput)
        : undefined,
      pointwiseMetricInput: isSet(object.pointwiseMetricInput)
        ? PointwiseMetricInput.fromJSON(object.pointwiseMetricInput)
        : undefined,
      pairwiseMetricInput: isSet(object.pairwiseMetricInput)
        ? PairwiseMetricInput.fromJSON(object.pairwiseMetricInput)
        : undefined,
      toolCallValidInput: isSet(object.toolCallValidInput)
        ? ToolCallValidInput.fromJSON(object.toolCallValidInput)
        : undefined,
      toolNameMatchInput: isSet(object.toolNameMatchInput)
        ? ToolNameMatchInput.fromJSON(object.toolNameMatchInput)
        : undefined,
      toolParameterKeyMatchInput: isSet(object.toolParameterKeyMatchInput)
        ? ToolParameterKeyMatchInput.fromJSON(object.toolParameterKeyMatchInput)
        : undefined,
      toolParameterKvMatchInput: isSet(object.toolParameterKvMatchInput)
        ? ToolParameterKVMatchInput.fromJSON(object.toolParameterKvMatchInput)
        : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: EvaluateInstancesRequest): unknown {
    const obj: any = {};
    if (message.exactMatchInput !== undefined) {
      obj.exactMatchInput = ExactMatchInput.toJSON(message.exactMatchInput);
    }
    if (message.bleuInput !== undefined) {
      obj.bleuInput = BleuInput.toJSON(message.bleuInput);
    }
    if (message.rougeInput !== undefined) {
      obj.rougeInput = RougeInput.toJSON(message.rougeInput);
    }
    if (message.fluencyInput !== undefined) {
      obj.fluencyInput = FluencyInput.toJSON(message.fluencyInput);
    }
    if (message.coherenceInput !== undefined) {
      obj.coherenceInput = CoherenceInput.toJSON(message.coherenceInput);
    }
    if (message.safetyInput !== undefined) {
      obj.safetyInput = SafetyInput.toJSON(message.safetyInput);
    }
    if (message.groundednessInput !== undefined) {
      obj.groundednessInput = GroundednessInput.toJSON(message.groundednessInput);
    }
    if (message.fulfillmentInput !== undefined) {
      obj.fulfillmentInput = FulfillmentInput.toJSON(message.fulfillmentInput);
    }
    if (message.summarizationQualityInput !== undefined) {
      obj.summarizationQualityInput = SummarizationQualityInput.toJSON(message.summarizationQualityInput);
    }
    if (message.pairwiseSummarizationQualityInput !== undefined) {
      obj.pairwiseSummarizationQualityInput = PairwiseSummarizationQualityInput.toJSON(
        message.pairwiseSummarizationQualityInput,
      );
    }
    if (message.summarizationHelpfulnessInput !== undefined) {
      obj.summarizationHelpfulnessInput = SummarizationHelpfulnessInput.toJSON(message.summarizationHelpfulnessInput);
    }
    if (message.summarizationVerbosityInput !== undefined) {
      obj.summarizationVerbosityInput = SummarizationVerbosityInput.toJSON(message.summarizationVerbosityInput);
    }
    if (message.questionAnsweringQualityInput !== undefined) {
      obj.questionAnsweringQualityInput = QuestionAnsweringQualityInput.toJSON(message.questionAnsweringQualityInput);
    }
    if (message.pairwiseQuestionAnsweringQualityInput !== undefined) {
      obj.pairwiseQuestionAnsweringQualityInput = PairwiseQuestionAnsweringQualityInput.toJSON(
        message.pairwiseQuestionAnsweringQualityInput,
      );
    }
    if (message.questionAnsweringRelevanceInput !== undefined) {
      obj.questionAnsweringRelevanceInput = QuestionAnsweringRelevanceInput.toJSON(
        message.questionAnsweringRelevanceInput,
      );
    }
    if (message.questionAnsweringHelpfulnessInput !== undefined) {
      obj.questionAnsweringHelpfulnessInput = QuestionAnsweringHelpfulnessInput.toJSON(
        message.questionAnsweringHelpfulnessInput,
      );
    }
    if (message.questionAnsweringCorrectnessInput !== undefined) {
      obj.questionAnsweringCorrectnessInput = QuestionAnsweringCorrectnessInput.toJSON(
        message.questionAnsweringCorrectnessInput,
      );
    }
    if (message.pointwiseMetricInput !== undefined) {
      obj.pointwiseMetricInput = PointwiseMetricInput.toJSON(message.pointwiseMetricInput);
    }
    if (message.pairwiseMetricInput !== undefined) {
      obj.pairwiseMetricInput = PairwiseMetricInput.toJSON(message.pairwiseMetricInput);
    }
    if (message.toolCallValidInput !== undefined) {
      obj.toolCallValidInput = ToolCallValidInput.toJSON(message.toolCallValidInput);
    }
    if (message.toolNameMatchInput !== undefined) {
      obj.toolNameMatchInput = ToolNameMatchInput.toJSON(message.toolNameMatchInput);
    }
    if (message.toolParameterKeyMatchInput !== undefined) {
      obj.toolParameterKeyMatchInput = ToolParameterKeyMatchInput.toJSON(message.toolParameterKeyMatchInput);
    }
    if (message.toolParameterKvMatchInput !== undefined) {
      obj.toolParameterKvMatchInput = ToolParameterKVMatchInput.toJSON(message.toolParameterKvMatchInput);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateInstancesRequest>): EvaluateInstancesRequest {
    return EvaluateInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateInstancesRequest>): EvaluateInstancesRequest {
    const message = createBaseEvaluateInstancesRequest();
    message.exactMatchInput = (object.exactMatchInput !== undefined && object.exactMatchInput !== null)
      ? ExactMatchInput.fromPartial(object.exactMatchInput)
      : undefined;
    message.bleuInput = (object.bleuInput !== undefined && object.bleuInput !== null)
      ? BleuInput.fromPartial(object.bleuInput)
      : undefined;
    message.rougeInput = (object.rougeInput !== undefined && object.rougeInput !== null)
      ? RougeInput.fromPartial(object.rougeInput)
      : undefined;
    message.fluencyInput = (object.fluencyInput !== undefined && object.fluencyInput !== null)
      ? FluencyInput.fromPartial(object.fluencyInput)
      : undefined;
    message.coherenceInput = (object.coherenceInput !== undefined && object.coherenceInput !== null)
      ? CoherenceInput.fromPartial(object.coherenceInput)
      : undefined;
    message.safetyInput = (object.safetyInput !== undefined && object.safetyInput !== null)
      ? SafetyInput.fromPartial(object.safetyInput)
      : undefined;
    message.groundednessInput = (object.groundednessInput !== undefined && object.groundednessInput !== null)
      ? GroundednessInput.fromPartial(object.groundednessInput)
      : undefined;
    message.fulfillmentInput = (object.fulfillmentInput !== undefined && object.fulfillmentInput !== null)
      ? FulfillmentInput.fromPartial(object.fulfillmentInput)
      : undefined;
    message.summarizationQualityInput =
      (object.summarizationQualityInput !== undefined && object.summarizationQualityInput !== null)
        ? SummarizationQualityInput.fromPartial(object.summarizationQualityInput)
        : undefined;
    message.pairwiseSummarizationQualityInput =
      (object.pairwiseSummarizationQualityInput !== undefined && object.pairwiseSummarizationQualityInput !== null)
        ? PairwiseSummarizationQualityInput.fromPartial(object.pairwiseSummarizationQualityInput)
        : undefined;
    message.summarizationHelpfulnessInput =
      (object.summarizationHelpfulnessInput !== undefined && object.summarizationHelpfulnessInput !== null)
        ? SummarizationHelpfulnessInput.fromPartial(object.summarizationHelpfulnessInput)
        : undefined;
    message.summarizationVerbosityInput =
      (object.summarizationVerbosityInput !== undefined && object.summarizationVerbosityInput !== null)
        ? SummarizationVerbosityInput.fromPartial(object.summarizationVerbosityInput)
        : undefined;
    message.questionAnsweringQualityInput =
      (object.questionAnsweringQualityInput !== undefined && object.questionAnsweringQualityInput !== null)
        ? QuestionAnsweringQualityInput.fromPartial(object.questionAnsweringQualityInput)
        : undefined;
    message.pairwiseQuestionAnsweringQualityInput =
      (object.pairwiseQuestionAnsweringQualityInput !== undefined &&
          object.pairwiseQuestionAnsweringQualityInput !== null)
        ? PairwiseQuestionAnsweringQualityInput.fromPartial(object.pairwiseQuestionAnsweringQualityInput)
        : undefined;
    message.questionAnsweringRelevanceInput =
      (object.questionAnsweringRelevanceInput !== undefined && object.questionAnsweringRelevanceInput !== null)
        ? QuestionAnsweringRelevanceInput.fromPartial(object.questionAnsweringRelevanceInput)
        : undefined;
    message.questionAnsweringHelpfulnessInput =
      (object.questionAnsweringHelpfulnessInput !== undefined && object.questionAnsweringHelpfulnessInput !== null)
        ? QuestionAnsweringHelpfulnessInput.fromPartial(object.questionAnsweringHelpfulnessInput)
        : undefined;
    message.questionAnsweringCorrectnessInput =
      (object.questionAnsweringCorrectnessInput !== undefined && object.questionAnsweringCorrectnessInput !== null)
        ? QuestionAnsweringCorrectnessInput.fromPartial(object.questionAnsweringCorrectnessInput)
        : undefined;
    message.pointwiseMetricInput = (object.pointwiseMetricInput !== undefined && object.pointwiseMetricInput !== null)
      ? PointwiseMetricInput.fromPartial(object.pointwiseMetricInput)
      : undefined;
    message.pairwiseMetricInput = (object.pairwiseMetricInput !== undefined && object.pairwiseMetricInput !== null)
      ? PairwiseMetricInput.fromPartial(object.pairwiseMetricInput)
      : undefined;
    message.toolCallValidInput = (object.toolCallValidInput !== undefined && object.toolCallValidInput !== null)
      ? ToolCallValidInput.fromPartial(object.toolCallValidInput)
      : undefined;
    message.toolNameMatchInput = (object.toolNameMatchInput !== undefined && object.toolNameMatchInput !== null)
      ? ToolNameMatchInput.fromPartial(object.toolNameMatchInput)
      : undefined;
    message.toolParameterKeyMatchInput =
      (object.toolParameterKeyMatchInput !== undefined && object.toolParameterKeyMatchInput !== null)
        ? ToolParameterKeyMatchInput.fromPartial(object.toolParameterKeyMatchInput)
        : undefined;
    message.toolParameterKvMatchInput =
      (object.toolParameterKvMatchInput !== undefined && object.toolParameterKvMatchInput !== null)
        ? ToolParameterKVMatchInput.fromPartial(object.toolParameterKvMatchInput)
        : undefined;
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseEvaluateInstancesResponse(): EvaluateInstancesResponse {
  return {
    exactMatchResults: undefined,
    bleuResults: undefined,
    rougeResults: undefined,
    fluencyResult: undefined,
    coherenceResult: undefined,
    safetyResult: undefined,
    groundednessResult: undefined,
    fulfillmentResult: undefined,
    summarizationQualityResult: undefined,
    pairwiseSummarizationQualityResult: undefined,
    summarizationHelpfulnessResult: undefined,
    summarizationVerbosityResult: undefined,
    questionAnsweringQualityResult: undefined,
    pairwiseQuestionAnsweringQualityResult: undefined,
    questionAnsweringRelevanceResult: undefined,
    questionAnsweringHelpfulnessResult: undefined,
    questionAnsweringCorrectnessResult: undefined,
    pointwiseMetricResult: undefined,
    pairwiseMetricResult: undefined,
    toolCallValidResults: undefined,
    toolNameMatchResults: undefined,
    toolParameterKeyMatchResults: undefined,
    toolParameterKvMatchResults: undefined,
  };
}

export const EvaluateInstancesResponse: MessageFns<EvaluateInstancesResponse> = {
  encode(message: EvaluateInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatchResults !== undefined) {
      ExactMatchResults.encode(message.exactMatchResults, writer.uint32(10).fork()).join();
    }
    if (message.bleuResults !== undefined) {
      BleuResults.encode(message.bleuResults, writer.uint32(18).fork()).join();
    }
    if (message.rougeResults !== undefined) {
      RougeResults.encode(message.rougeResults, writer.uint32(26).fork()).join();
    }
    if (message.fluencyResult !== undefined) {
      FluencyResult.encode(message.fluencyResult, writer.uint32(34).fork()).join();
    }
    if (message.coherenceResult !== undefined) {
      CoherenceResult.encode(message.coherenceResult, writer.uint32(42).fork()).join();
    }
    if (message.safetyResult !== undefined) {
      SafetyResult.encode(message.safetyResult, writer.uint32(58).fork()).join();
    }
    if (message.groundednessResult !== undefined) {
      GroundednessResult.encode(message.groundednessResult, writer.uint32(66).fork()).join();
    }
    if (message.fulfillmentResult !== undefined) {
      FulfillmentResult.encode(message.fulfillmentResult, writer.uint32(90).fork()).join();
    }
    if (message.summarizationQualityResult !== undefined) {
      SummarizationQualityResult.encode(message.summarizationQualityResult, writer.uint32(50).fork()).join();
    }
    if (message.pairwiseSummarizationQualityResult !== undefined) {
      PairwiseSummarizationQualityResult.encode(message.pairwiseSummarizationQualityResult, writer.uint32(178).fork())
        .join();
    }
    if (message.summarizationHelpfulnessResult !== undefined) {
      SummarizationHelpfulnessResult.encode(message.summarizationHelpfulnessResult, writer.uint32(106).fork()).join();
    }
    if (message.summarizationVerbosityResult !== undefined) {
      SummarizationVerbosityResult.encode(message.summarizationVerbosityResult, writer.uint32(114).fork()).join();
    }
    if (message.questionAnsweringQualityResult !== undefined) {
      QuestionAnsweringQualityResult.encode(message.questionAnsweringQualityResult, writer.uint32(74).fork()).join();
    }
    if (message.pairwiseQuestionAnsweringQualityResult !== undefined) {
      PairwiseQuestionAnsweringQualityResult.encode(
        message.pairwiseQuestionAnsweringQualityResult,
        writer.uint32(186).fork(),
      ).join();
    }
    if (message.questionAnsweringRelevanceResult !== undefined) {
      QuestionAnsweringRelevanceResult.encode(message.questionAnsweringRelevanceResult, writer.uint32(122).fork())
        .join();
    }
    if (message.questionAnsweringHelpfulnessResult !== undefined) {
      QuestionAnsweringHelpfulnessResult.encode(message.questionAnsweringHelpfulnessResult, writer.uint32(130).fork())
        .join();
    }
    if (message.questionAnsweringCorrectnessResult !== undefined) {
      QuestionAnsweringCorrectnessResult.encode(message.questionAnsweringCorrectnessResult, writer.uint32(138).fork())
        .join();
    }
    if (message.pointwiseMetricResult !== undefined) {
      PointwiseMetricResult.encode(message.pointwiseMetricResult, writer.uint32(218).fork()).join();
    }
    if (message.pairwiseMetricResult !== undefined) {
      PairwiseMetricResult.encode(message.pairwiseMetricResult, writer.uint32(226).fork()).join();
    }
    if (message.toolCallValidResults !== undefined) {
      ToolCallValidResults.encode(message.toolCallValidResults, writer.uint32(146).fork()).join();
    }
    if (message.toolNameMatchResults !== undefined) {
      ToolNameMatchResults.encode(message.toolNameMatchResults, writer.uint32(154).fork()).join();
    }
    if (message.toolParameterKeyMatchResults !== undefined) {
      ToolParameterKeyMatchResults.encode(message.toolParameterKeyMatchResults, writer.uint32(162).fork()).join();
    }
    if (message.toolParameterKvMatchResults !== undefined) {
      ToolParameterKVMatchResults.encode(message.toolParameterKvMatchResults, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exactMatchResults = ExactMatchResults.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bleuResults = BleuResults.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rougeResults = RougeResults.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fluencyResult = FluencyResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.coherenceResult = CoherenceResult.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.safetyResult = SafetyResult.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.groundednessResult = GroundednessResult.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fulfillmentResult = FulfillmentResult.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.summarizationQualityResult = SummarizationQualityResult.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.pairwiseSummarizationQualityResult = PairwiseSummarizationQualityResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.summarizationHelpfulnessResult = SummarizationHelpfulnessResult.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.summarizationVerbosityResult = SummarizationVerbosityResult.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.questionAnsweringQualityResult = QuestionAnsweringQualityResult.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.pairwiseQuestionAnsweringQualityResult = PairwiseQuestionAnsweringQualityResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.questionAnsweringRelevanceResult = QuestionAnsweringRelevanceResult.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.questionAnsweringHelpfulnessResult = QuestionAnsweringHelpfulnessResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.questionAnsweringCorrectnessResult = QuestionAnsweringCorrectnessResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.pointwiseMetricResult = PointwiseMetricResult.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.pairwiseMetricResult = PairwiseMetricResult.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.toolCallValidResults = ToolCallValidResults.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.toolNameMatchResults = ToolNameMatchResults.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.toolParameterKeyMatchResults = ToolParameterKeyMatchResults.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.toolParameterKvMatchResults = ToolParameterKVMatchResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateInstancesResponse {
    return {
      exactMatchResults: isSet(object.exactMatchResults)
        ? ExactMatchResults.fromJSON(object.exactMatchResults)
        : undefined,
      bleuResults: isSet(object.bleuResults) ? BleuResults.fromJSON(object.bleuResults) : undefined,
      rougeResults: isSet(object.rougeResults) ? RougeResults.fromJSON(object.rougeResults) : undefined,
      fluencyResult: isSet(object.fluencyResult) ? FluencyResult.fromJSON(object.fluencyResult) : undefined,
      coherenceResult: isSet(object.coherenceResult) ? CoherenceResult.fromJSON(object.coherenceResult) : undefined,
      safetyResult: isSet(object.safetyResult) ? SafetyResult.fromJSON(object.safetyResult) : undefined,
      groundednessResult: isSet(object.groundednessResult)
        ? GroundednessResult.fromJSON(object.groundednessResult)
        : undefined,
      fulfillmentResult: isSet(object.fulfillmentResult)
        ? FulfillmentResult.fromJSON(object.fulfillmentResult)
        : undefined,
      summarizationQualityResult: isSet(object.summarizationQualityResult)
        ? SummarizationQualityResult.fromJSON(object.summarizationQualityResult)
        : undefined,
      pairwiseSummarizationQualityResult: isSet(object.pairwiseSummarizationQualityResult)
        ? PairwiseSummarizationQualityResult.fromJSON(object.pairwiseSummarizationQualityResult)
        : undefined,
      summarizationHelpfulnessResult: isSet(object.summarizationHelpfulnessResult)
        ? SummarizationHelpfulnessResult.fromJSON(object.summarizationHelpfulnessResult)
        : undefined,
      summarizationVerbosityResult: isSet(object.summarizationVerbosityResult)
        ? SummarizationVerbosityResult.fromJSON(object.summarizationVerbosityResult)
        : undefined,
      questionAnsweringQualityResult: isSet(object.questionAnsweringQualityResult)
        ? QuestionAnsweringQualityResult.fromJSON(object.questionAnsweringQualityResult)
        : undefined,
      pairwiseQuestionAnsweringQualityResult: isSet(object.pairwiseQuestionAnsweringQualityResult)
        ? PairwiseQuestionAnsweringQualityResult.fromJSON(object.pairwiseQuestionAnsweringQualityResult)
        : undefined,
      questionAnsweringRelevanceResult: isSet(object.questionAnsweringRelevanceResult)
        ? QuestionAnsweringRelevanceResult.fromJSON(object.questionAnsweringRelevanceResult)
        : undefined,
      questionAnsweringHelpfulnessResult: isSet(object.questionAnsweringHelpfulnessResult)
        ? QuestionAnsweringHelpfulnessResult.fromJSON(object.questionAnsweringHelpfulnessResult)
        : undefined,
      questionAnsweringCorrectnessResult: isSet(object.questionAnsweringCorrectnessResult)
        ? QuestionAnsweringCorrectnessResult.fromJSON(object.questionAnsweringCorrectnessResult)
        : undefined,
      pointwiseMetricResult: isSet(object.pointwiseMetricResult)
        ? PointwiseMetricResult.fromJSON(object.pointwiseMetricResult)
        : undefined,
      pairwiseMetricResult: isSet(object.pairwiseMetricResult)
        ? PairwiseMetricResult.fromJSON(object.pairwiseMetricResult)
        : undefined,
      toolCallValidResults: isSet(object.toolCallValidResults)
        ? ToolCallValidResults.fromJSON(object.toolCallValidResults)
        : undefined,
      toolNameMatchResults: isSet(object.toolNameMatchResults)
        ? ToolNameMatchResults.fromJSON(object.toolNameMatchResults)
        : undefined,
      toolParameterKeyMatchResults: isSet(object.toolParameterKeyMatchResults)
        ? ToolParameterKeyMatchResults.fromJSON(object.toolParameterKeyMatchResults)
        : undefined,
      toolParameterKvMatchResults: isSet(object.toolParameterKvMatchResults)
        ? ToolParameterKVMatchResults.fromJSON(object.toolParameterKvMatchResults)
        : undefined,
    };
  },

  toJSON(message: EvaluateInstancesResponse): unknown {
    const obj: any = {};
    if (message.exactMatchResults !== undefined) {
      obj.exactMatchResults = ExactMatchResults.toJSON(message.exactMatchResults);
    }
    if (message.bleuResults !== undefined) {
      obj.bleuResults = BleuResults.toJSON(message.bleuResults);
    }
    if (message.rougeResults !== undefined) {
      obj.rougeResults = RougeResults.toJSON(message.rougeResults);
    }
    if (message.fluencyResult !== undefined) {
      obj.fluencyResult = FluencyResult.toJSON(message.fluencyResult);
    }
    if (message.coherenceResult !== undefined) {
      obj.coherenceResult = CoherenceResult.toJSON(message.coherenceResult);
    }
    if (message.safetyResult !== undefined) {
      obj.safetyResult = SafetyResult.toJSON(message.safetyResult);
    }
    if (message.groundednessResult !== undefined) {
      obj.groundednessResult = GroundednessResult.toJSON(message.groundednessResult);
    }
    if (message.fulfillmentResult !== undefined) {
      obj.fulfillmentResult = FulfillmentResult.toJSON(message.fulfillmentResult);
    }
    if (message.summarizationQualityResult !== undefined) {
      obj.summarizationQualityResult = SummarizationQualityResult.toJSON(message.summarizationQualityResult);
    }
    if (message.pairwiseSummarizationQualityResult !== undefined) {
      obj.pairwiseSummarizationQualityResult = PairwiseSummarizationQualityResult.toJSON(
        message.pairwiseSummarizationQualityResult,
      );
    }
    if (message.summarizationHelpfulnessResult !== undefined) {
      obj.summarizationHelpfulnessResult = SummarizationHelpfulnessResult.toJSON(
        message.summarizationHelpfulnessResult,
      );
    }
    if (message.summarizationVerbosityResult !== undefined) {
      obj.summarizationVerbosityResult = SummarizationVerbosityResult.toJSON(message.summarizationVerbosityResult);
    }
    if (message.questionAnsweringQualityResult !== undefined) {
      obj.questionAnsweringQualityResult = QuestionAnsweringQualityResult.toJSON(
        message.questionAnsweringQualityResult,
      );
    }
    if (message.pairwiseQuestionAnsweringQualityResult !== undefined) {
      obj.pairwiseQuestionAnsweringQualityResult = PairwiseQuestionAnsweringQualityResult.toJSON(
        message.pairwiseQuestionAnsweringQualityResult,
      );
    }
    if (message.questionAnsweringRelevanceResult !== undefined) {
      obj.questionAnsweringRelevanceResult = QuestionAnsweringRelevanceResult.toJSON(
        message.questionAnsweringRelevanceResult,
      );
    }
    if (message.questionAnsweringHelpfulnessResult !== undefined) {
      obj.questionAnsweringHelpfulnessResult = QuestionAnsweringHelpfulnessResult.toJSON(
        message.questionAnsweringHelpfulnessResult,
      );
    }
    if (message.questionAnsweringCorrectnessResult !== undefined) {
      obj.questionAnsweringCorrectnessResult = QuestionAnsweringCorrectnessResult.toJSON(
        message.questionAnsweringCorrectnessResult,
      );
    }
    if (message.pointwiseMetricResult !== undefined) {
      obj.pointwiseMetricResult = PointwiseMetricResult.toJSON(message.pointwiseMetricResult);
    }
    if (message.pairwiseMetricResult !== undefined) {
      obj.pairwiseMetricResult = PairwiseMetricResult.toJSON(message.pairwiseMetricResult);
    }
    if (message.toolCallValidResults !== undefined) {
      obj.toolCallValidResults = ToolCallValidResults.toJSON(message.toolCallValidResults);
    }
    if (message.toolNameMatchResults !== undefined) {
      obj.toolNameMatchResults = ToolNameMatchResults.toJSON(message.toolNameMatchResults);
    }
    if (message.toolParameterKeyMatchResults !== undefined) {
      obj.toolParameterKeyMatchResults = ToolParameterKeyMatchResults.toJSON(message.toolParameterKeyMatchResults);
    }
    if (message.toolParameterKvMatchResults !== undefined) {
      obj.toolParameterKvMatchResults = ToolParameterKVMatchResults.toJSON(message.toolParameterKvMatchResults);
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluateInstancesResponse>): EvaluateInstancesResponse {
    return EvaluateInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluateInstancesResponse>): EvaluateInstancesResponse {
    const message = createBaseEvaluateInstancesResponse();
    message.exactMatchResults = (object.exactMatchResults !== undefined && object.exactMatchResults !== null)
      ? ExactMatchResults.fromPartial(object.exactMatchResults)
      : undefined;
    message.bleuResults = (object.bleuResults !== undefined && object.bleuResults !== null)
      ? BleuResults.fromPartial(object.bleuResults)
      : undefined;
    message.rougeResults = (object.rougeResults !== undefined && object.rougeResults !== null)
      ? RougeResults.fromPartial(object.rougeResults)
      : undefined;
    message.fluencyResult = (object.fluencyResult !== undefined && object.fluencyResult !== null)
      ? FluencyResult.fromPartial(object.fluencyResult)
      : undefined;
    message.coherenceResult = (object.coherenceResult !== undefined && object.coherenceResult !== null)
      ? CoherenceResult.fromPartial(object.coherenceResult)
      : undefined;
    message.safetyResult = (object.safetyResult !== undefined && object.safetyResult !== null)
      ? SafetyResult.fromPartial(object.safetyResult)
      : undefined;
    message.groundednessResult = (object.groundednessResult !== undefined && object.groundednessResult !== null)
      ? GroundednessResult.fromPartial(object.groundednessResult)
      : undefined;
    message.fulfillmentResult = (object.fulfillmentResult !== undefined && object.fulfillmentResult !== null)
      ? FulfillmentResult.fromPartial(object.fulfillmentResult)
      : undefined;
    message.summarizationQualityResult =
      (object.summarizationQualityResult !== undefined && object.summarizationQualityResult !== null)
        ? SummarizationQualityResult.fromPartial(object.summarizationQualityResult)
        : undefined;
    message.pairwiseSummarizationQualityResult =
      (object.pairwiseSummarizationQualityResult !== undefined && object.pairwiseSummarizationQualityResult !== null)
        ? PairwiseSummarizationQualityResult.fromPartial(object.pairwiseSummarizationQualityResult)
        : undefined;
    message.summarizationHelpfulnessResult =
      (object.summarizationHelpfulnessResult !== undefined && object.summarizationHelpfulnessResult !== null)
        ? SummarizationHelpfulnessResult.fromPartial(object.summarizationHelpfulnessResult)
        : undefined;
    message.summarizationVerbosityResult =
      (object.summarizationVerbosityResult !== undefined && object.summarizationVerbosityResult !== null)
        ? SummarizationVerbosityResult.fromPartial(object.summarizationVerbosityResult)
        : undefined;
    message.questionAnsweringQualityResult =
      (object.questionAnsweringQualityResult !== undefined && object.questionAnsweringQualityResult !== null)
        ? QuestionAnsweringQualityResult.fromPartial(object.questionAnsweringQualityResult)
        : undefined;
    message.pairwiseQuestionAnsweringQualityResult =
      (object.pairwiseQuestionAnsweringQualityResult !== undefined &&
          object.pairwiseQuestionAnsweringQualityResult !== null)
        ? PairwiseQuestionAnsweringQualityResult.fromPartial(object.pairwiseQuestionAnsweringQualityResult)
        : undefined;
    message.questionAnsweringRelevanceResult =
      (object.questionAnsweringRelevanceResult !== undefined && object.questionAnsweringRelevanceResult !== null)
        ? QuestionAnsweringRelevanceResult.fromPartial(object.questionAnsweringRelevanceResult)
        : undefined;
    message.questionAnsweringHelpfulnessResult =
      (object.questionAnsweringHelpfulnessResult !== undefined && object.questionAnsweringHelpfulnessResult !== null)
        ? QuestionAnsweringHelpfulnessResult.fromPartial(object.questionAnsweringHelpfulnessResult)
        : undefined;
    message.questionAnsweringCorrectnessResult =
      (object.questionAnsweringCorrectnessResult !== undefined && object.questionAnsweringCorrectnessResult !== null)
        ? QuestionAnsweringCorrectnessResult.fromPartial(object.questionAnsweringCorrectnessResult)
        : undefined;
    message.pointwiseMetricResult =
      (object.pointwiseMetricResult !== undefined && object.pointwiseMetricResult !== null)
        ? PointwiseMetricResult.fromPartial(object.pointwiseMetricResult)
        : undefined;
    message.pairwiseMetricResult = (object.pairwiseMetricResult !== undefined && object.pairwiseMetricResult !== null)
      ? PairwiseMetricResult.fromPartial(object.pairwiseMetricResult)
      : undefined;
    message.toolCallValidResults = (object.toolCallValidResults !== undefined && object.toolCallValidResults !== null)
      ? ToolCallValidResults.fromPartial(object.toolCallValidResults)
      : undefined;
    message.toolNameMatchResults = (object.toolNameMatchResults !== undefined && object.toolNameMatchResults !== null)
      ? ToolNameMatchResults.fromPartial(object.toolNameMatchResults)
      : undefined;
    message.toolParameterKeyMatchResults =
      (object.toolParameterKeyMatchResults !== undefined && object.toolParameterKeyMatchResults !== null)
        ? ToolParameterKeyMatchResults.fromPartial(object.toolParameterKeyMatchResults)
        : undefined;
    message.toolParameterKvMatchResults =
      (object.toolParameterKvMatchResults !== undefined && object.toolParameterKvMatchResults !== null)
        ? ToolParameterKVMatchResults.fromPartial(object.toolParameterKvMatchResults)
        : undefined;
    return message;
  },
};

function createBaseExactMatchInput(): ExactMatchInput {
  return { metricSpec: undefined, instances: [] };
}

export const ExactMatchInput: MessageFns<ExactMatchInput> = {
  encode(message: ExactMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      ExactMatchSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      ExactMatchInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = ExactMatchSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(ExactMatchInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExactMatchInput {
    return {
      metricSpec: isSet(object.metricSpec) ? ExactMatchSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => ExactMatchInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExactMatchInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = ExactMatchSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => ExactMatchInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExactMatchInput>): ExactMatchInput {
    return ExactMatchInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExactMatchInput>): ExactMatchInput {
    const message = createBaseExactMatchInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? ExactMatchSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => ExactMatchInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExactMatchInstance(): ExactMatchInstance {
  return { prediction: undefined, reference: undefined };
}

export const ExactMatchInstance: MessageFns<ExactMatchInstance> = {
  encode(message: ExactMatchInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExactMatchInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: ExactMatchInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<ExactMatchInstance>): ExactMatchInstance {
    return ExactMatchInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExactMatchInstance>): ExactMatchInstance {
    const message = createBaseExactMatchInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseExactMatchSpec(): ExactMatchSpec {
  return {};
}

export const ExactMatchSpec: MessageFns<ExactMatchSpec> = {
  encode(_: ExactMatchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExactMatchSpec {
    return {};
  },

  toJSON(_: ExactMatchSpec): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExactMatchSpec>): ExactMatchSpec {
    return ExactMatchSpec.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExactMatchSpec>): ExactMatchSpec {
    const message = createBaseExactMatchSpec();
    return message;
  },
};

function createBaseExactMatchResults(): ExactMatchResults {
  return { exactMatchMetricValues: [] };
}

export const ExactMatchResults: MessageFns<ExactMatchResults> = {
  encode(message: ExactMatchResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.exactMatchMetricValues) {
      ExactMatchMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exactMatchMetricValues.push(ExactMatchMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExactMatchResults {
    return {
      exactMatchMetricValues: globalThis.Array.isArray(object?.exactMatchMetricValues)
        ? object.exactMatchMetricValues.map((e: any) => ExactMatchMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExactMatchResults): unknown {
    const obj: any = {};
    if (message.exactMatchMetricValues?.length) {
      obj.exactMatchMetricValues = message.exactMatchMetricValues.map((e) => ExactMatchMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExactMatchResults>): ExactMatchResults {
    return ExactMatchResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExactMatchResults>): ExactMatchResults {
    const message = createBaseExactMatchResults();
    message.exactMatchMetricValues = object.exactMatchMetricValues?.map((e) => ExactMatchMetricValue.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseExactMatchMetricValue(): ExactMatchMetricValue {
  return { score: undefined };
}

export const ExactMatchMetricValue: MessageFns<ExactMatchMetricValue> = {
  encode(message: ExactMatchMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExactMatchMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: ExactMatchMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ExactMatchMetricValue>): ExactMatchMetricValue {
    return ExactMatchMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExactMatchMetricValue>): ExactMatchMetricValue {
    const message = createBaseExactMatchMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseBleuInput(): BleuInput {
  return { metricSpec: undefined, instances: [] };
}

export const BleuInput: MessageFns<BleuInput> = {
  encode(message: BleuInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      BleuSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      BleuInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BleuInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBleuInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = BleuSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(BleuInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BleuInput {
    return {
      metricSpec: isSet(object.metricSpec) ? BleuSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => BleuInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BleuInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = BleuSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => BleuInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BleuInput>): BleuInput {
    return BleuInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BleuInput>): BleuInput {
    const message = createBaseBleuInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? BleuSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => BleuInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBleuInstance(): BleuInstance {
  return { prediction: undefined, reference: undefined };
}

export const BleuInstance: MessageFns<BleuInstance> = {
  encode(message: BleuInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BleuInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBleuInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BleuInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: BleuInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<BleuInstance>): BleuInstance {
    return BleuInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BleuInstance>): BleuInstance {
    const message = createBaseBleuInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseBleuSpec(): BleuSpec {
  return { useEffectiveOrder: false };
}

export const BleuSpec: MessageFns<BleuSpec> = {
  encode(message: BleuSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useEffectiveOrder !== false) {
      writer.uint32(8).bool(message.useEffectiveOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BleuSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBleuSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useEffectiveOrder = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BleuSpec {
    return {
      useEffectiveOrder: isSet(object.useEffectiveOrder) ? globalThis.Boolean(object.useEffectiveOrder) : false,
    };
  },

  toJSON(message: BleuSpec): unknown {
    const obj: any = {};
    if (message.useEffectiveOrder !== false) {
      obj.useEffectiveOrder = message.useEffectiveOrder;
    }
    return obj;
  },

  create(base?: DeepPartial<BleuSpec>): BleuSpec {
    return BleuSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BleuSpec>): BleuSpec {
    const message = createBaseBleuSpec();
    message.useEffectiveOrder = object.useEffectiveOrder ?? false;
    return message;
  },
};

function createBaseBleuResults(): BleuResults {
  return { bleuMetricValues: [] };
}

export const BleuResults: MessageFns<BleuResults> = {
  encode(message: BleuResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bleuMetricValues) {
      BleuMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BleuResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBleuResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bleuMetricValues.push(BleuMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BleuResults {
    return {
      bleuMetricValues: globalThis.Array.isArray(object?.bleuMetricValues)
        ? object.bleuMetricValues.map((e: any) => BleuMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BleuResults): unknown {
    const obj: any = {};
    if (message.bleuMetricValues?.length) {
      obj.bleuMetricValues = message.bleuMetricValues.map((e) => BleuMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BleuResults>): BleuResults {
    return BleuResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BleuResults>): BleuResults {
    const message = createBaseBleuResults();
    message.bleuMetricValues = object.bleuMetricValues?.map((e) => BleuMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBleuMetricValue(): BleuMetricValue {
  return { score: undefined };
}

export const BleuMetricValue: MessageFns<BleuMetricValue> = {
  encode(message: BleuMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BleuMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBleuMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BleuMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: BleuMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<BleuMetricValue>): BleuMetricValue {
    return BleuMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BleuMetricValue>): BleuMetricValue {
    const message = createBaseBleuMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseRougeInput(): RougeInput {
  return { metricSpec: undefined, instances: [] };
}

export const RougeInput: MessageFns<RougeInput> = {
  encode(message: RougeInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      RougeSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      RougeInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RougeInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRougeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = RougeSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(RougeInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RougeInput {
    return {
      metricSpec: isSet(object.metricSpec) ? RougeSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => RougeInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RougeInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = RougeSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => RougeInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RougeInput>): RougeInput {
    return RougeInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RougeInput>): RougeInput {
    const message = createBaseRougeInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? RougeSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => RougeInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRougeInstance(): RougeInstance {
  return { prediction: undefined, reference: undefined };
}

export const RougeInstance: MessageFns<RougeInstance> = {
  encode(message: RougeInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RougeInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRougeInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RougeInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: RougeInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<RougeInstance>): RougeInstance {
    return RougeInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RougeInstance>): RougeInstance {
    const message = createBaseRougeInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseRougeSpec(): RougeSpec {
  return { rougeType: "", useStemmer: false, splitSummaries: false };
}

export const RougeSpec: MessageFns<RougeSpec> = {
  encode(message: RougeSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rougeType !== "") {
      writer.uint32(10).string(message.rougeType);
    }
    if (message.useStemmer !== false) {
      writer.uint32(16).bool(message.useStemmer);
    }
    if (message.splitSummaries !== false) {
      writer.uint32(24).bool(message.splitSummaries);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RougeSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRougeSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rougeType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.useStemmer = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.splitSummaries = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RougeSpec {
    return {
      rougeType: isSet(object.rougeType) ? globalThis.String(object.rougeType) : "",
      useStemmer: isSet(object.useStemmer) ? globalThis.Boolean(object.useStemmer) : false,
      splitSummaries: isSet(object.splitSummaries) ? globalThis.Boolean(object.splitSummaries) : false,
    };
  },

  toJSON(message: RougeSpec): unknown {
    const obj: any = {};
    if (message.rougeType !== "") {
      obj.rougeType = message.rougeType;
    }
    if (message.useStemmer !== false) {
      obj.useStemmer = message.useStemmer;
    }
    if (message.splitSummaries !== false) {
      obj.splitSummaries = message.splitSummaries;
    }
    return obj;
  },

  create(base?: DeepPartial<RougeSpec>): RougeSpec {
    return RougeSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RougeSpec>): RougeSpec {
    const message = createBaseRougeSpec();
    message.rougeType = object.rougeType ?? "";
    message.useStemmer = object.useStemmer ?? false;
    message.splitSummaries = object.splitSummaries ?? false;
    return message;
  },
};

function createBaseRougeResults(): RougeResults {
  return { rougeMetricValues: [] };
}

export const RougeResults: MessageFns<RougeResults> = {
  encode(message: RougeResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rougeMetricValues) {
      RougeMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RougeResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRougeResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rougeMetricValues.push(RougeMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RougeResults {
    return {
      rougeMetricValues: globalThis.Array.isArray(object?.rougeMetricValues)
        ? object.rougeMetricValues.map((e: any) => RougeMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RougeResults): unknown {
    const obj: any = {};
    if (message.rougeMetricValues?.length) {
      obj.rougeMetricValues = message.rougeMetricValues.map((e) => RougeMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RougeResults>): RougeResults {
    return RougeResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RougeResults>): RougeResults {
    const message = createBaseRougeResults();
    message.rougeMetricValues = object.rougeMetricValues?.map((e) => RougeMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRougeMetricValue(): RougeMetricValue {
  return { score: undefined };
}

export const RougeMetricValue: MessageFns<RougeMetricValue> = {
  encode(message: RougeMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RougeMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRougeMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RougeMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: RougeMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<RougeMetricValue>): RougeMetricValue {
    return RougeMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RougeMetricValue>): RougeMetricValue {
    const message = createBaseRougeMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseCoherenceInput(): CoherenceInput {
  return { metricSpec: undefined, instance: undefined };
}

export const CoherenceInput: MessageFns<CoherenceInput> = {
  encode(message: CoherenceInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      CoherenceSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      CoherenceInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoherenceInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoherenceInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = CoherenceSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = CoherenceInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoherenceInput {
    return {
      metricSpec: isSet(object.metricSpec) ? CoherenceSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? CoherenceInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: CoherenceInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = CoherenceSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = CoherenceInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<CoherenceInput>): CoherenceInput {
    return CoherenceInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoherenceInput>): CoherenceInput {
    const message = createBaseCoherenceInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? CoherenceSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? CoherenceInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseCoherenceInstance(): CoherenceInstance {
  return { prediction: undefined };
}

export const CoherenceInstance: MessageFns<CoherenceInstance> = {
  encode(message: CoherenceInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoherenceInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoherenceInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoherenceInstance {
    return { prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined };
  },

  toJSON(message: CoherenceInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    return obj;
  },

  create(base?: DeepPartial<CoherenceInstance>): CoherenceInstance {
    return CoherenceInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoherenceInstance>): CoherenceInstance {
    const message = createBaseCoherenceInstance();
    message.prediction = object.prediction ?? undefined;
    return message;
  },
};

function createBaseCoherenceSpec(): CoherenceSpec {
  return { version: 0 };
}

export const CoherenceSpec: MessageFns<CoherenceSpec> = {
  encode(message: CoherenceSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoherenceSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoherenceSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoherenceSpec {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: CoherenceSpec): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<CoherenceSpec>): CoherenceSpec {
    return CoherenceSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoherenceSpec>): CoherenceSpec {
    const message = createBaseCoherenceSpec();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseCoherenceResult(): CoherenceResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const CoherenceResult: MessageFns<CoherenceResult> = {
  encode(message: CoherenceResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoherenceResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoherenceResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoherenceResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: CoherenceResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<CoherenceResult>): CoherenceResult {
    return CoherenceResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoherenceResult>): CoherenceResult {
    const message = createBaseCoherenceResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseFluencyInput(): FluencyInput {
  return { metricSpec: undefined, instance: undefined };
}

export const FluencyInput: MessageFns<FluencyInput> = {
  encode(message: FluencyInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      FluencySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      FluencyInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FluencyInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFluencyInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = FluencySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = FluencyInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FluencyInput {
    return {
      metricSpec: isSet(object.metricSpec) ? FluencySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? FluencyInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: FluencyInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = FluencySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = FluencyInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<FluencyInput>): FluencyInput {
    return FluencyInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FluencyInput>): FluencyInput {
    const message = createBaseFluencyInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? FluencySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? FluencyInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseFluencyInstance(): FluencyInstance {
  return { prediction: undefined };
}

export const FluencyInstance: MessageFns<FluencyInstance> = {
  encode(message: FluencyInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FluencyInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFluencyInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FluencyInstance {
    return { prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined };
  },

  toJSON(message: FluencyInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    return obj;
  },

  create(base?: DeepPartial<FluencyInstance>): FluencyInstance {
    return FluencyInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FluencyInstance>): FluencyInstance {
    const message = createBaseFluencyInstance();
    message.prediction = object.prediction ?? undefined;
    return message;
  },
};

function createBaseFluencySpec(): FluencySpec {
  return { version: 0 };
}

export const FluencySpec: MessageFns<FluencySpec> = {
  encode(message: FluencySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FluencySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFluencySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FluencySpec {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: FluencySpec): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<FluencySpec>): FluencySpec {
    return FluencySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FluencySpec>): FluencySpec {
    const message = createBaseFluencySpec();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseFluencyResult(): FluencyResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const FluencyResult: MessageFns<FluencyResult> = {
  encode(message: FluencyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FluencyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFluencyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FluencyResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: FluencyResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<FluencyResult>): FluencyResult {
    return FluencyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FluencyResult>): FluencyResult {
    const message = createBaseFluencyResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseSafetyInput(): SafetyInput {
  return { metricSpec: undefined, instance: undefined };
}

export const SafetyInput: MessageFns<SafetyInput> = {
  encode(message: SafetyInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      SafetySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      SafetyInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetyInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetyInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = SafetySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = SafetyInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetyInput {
    return {
      metricSpec: isSet(object.metricSpec) ? SafetySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? SafetyInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: SafetyInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = SafetySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = SafetyInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<SafetyInput>): SafetyInput {
    return SafetyInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetyInput>): SafetyInput {
    const message = createBaseSafetyInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? SafetySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? SafetyInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseSafetyInstance(): SafetyInstance {
  return { prediction: undefined };
}

export const SafetyInstance: MessageFns<SafetyInstance> = {
  encode(message: SafetyInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetyInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetyInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetyInstance {
    return { prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined };
  },

  toJSON(message: SafetyInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    return obj;
  },

  create(base?: DeepPartial<SafetyInstance>): SafetyInstance {
    return SafetyInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetyInstance>): SafetyInstance {
    const message = createBaseSafetyInstance();
    message.prediction = object.prediction ?? undefined;
    return message;
  },
};

function createBaseSafetySpec(): SafetySpec {
  return { version: 0 };
}

export const SafetySpec: MessageFns<SafetySpec> = {
  encode(message: SafetySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetySpec {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: SafetySpec): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<SafetySpec>): SafetySpec {
    return SafetySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetySpec>): SafetySpec {
    const message = createBaseSafetySpec();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSafetyResult(): SafetyResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const SafetyResult: MessageFns<SafetyResult> = {
  encode(message: SafetyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetyResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: SafetyResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<SafetyResult>): SafetyResult {
    return SafetyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetyResult>): SafetyResult {
    const message = createBaseSafetyResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseGroundednessInput(): GroundednessInput {
  return { metricSpec: undefined, instance: undefined };
}

export const GroundednessInput: MessageFns<GroundednessInput> = {
  encode(message: GroundednessInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      GroundednessSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      GroundednessInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundednessInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundednessInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = GroundednessSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = GroundednessInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundednessInput {
    return {
      metricSpec: isSet(object.metricSpec) ? GroundednessSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? GroundednessInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: GroundednessInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = GroundednessSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = GroundednessInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<GroundednessInput>): GroundednessInput {
    return GroundednessInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundednessInput>): GroundednessInput {
    const message = createBaseGroundednessInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? GroundednessSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? GroundednessInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseGroundednessInstance(): GroundednessInstance {
  return { prediction: undefined, context: undefined };
}

export const GroundednessInstance: MessageFns<GroundednessInstance> = {
  encode(message: GroundednessInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.context !== undefined) {
      writer.uint32(18).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundednessInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundednessInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundednessInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
    };
  },

  toJSON(message: GroundednessInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<GroundednessInstance>): GroundednessInstance {
    return GroundednessInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundednessInstance>): GroundednessInstance {
    const message = createBaseGroundednessInstance();
    message.prediction = object.prediction ?? undefined;
    message.context = object.context ?? undefined;
    return message;
  },
};

function createBaseGroundednessSpec(): GroundednessSpec {
  return { version: 0 };
}

export const GroundednessSpec: MessageFns<GroundednessSpec> = {
  encode(message: GroundednessSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundednessSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundednessSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundednessSpec {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: GroundednessSpec): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<GroundednessSpec>): GroundednessSpec {
    return GroundednessSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundednessSpec>): GroundednessSpec {
    const message = createBaseGroundednessSpec();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseGroundednessResult(): GroundednessResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const GroundednessResult: MessageFns<GroundednessResult> = {
  encode(message: GroundednessResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundednessResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundednessResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundednessResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: GroundednessResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<GroundednessResult>): GroundednessResult {
    return GroundednessResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundednessResult>): GroundednessResult {
    const message = createBaseGroundednessResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseFulfillmentInput(): FulfillmentInput {
  return { metricSpec: undefined, instance: undefined };
}

export const FulfillmentInput: MessageFns<FulfillmentInput> = {
  encode(message: FulfillmentInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      FulfillmentSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      FulfillmentInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = FulfillmentSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = FulfillmentInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentInput {
    return {
      metricSpec: isSet(object.metricSpec) ? FulfillmentSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? FulfillmentInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: FulfillmentInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = FulfillmentSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = FulfillmentInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<FulfillmentInput>): FulfillmentInput {
    return FulfillmentInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FulfillmentInput>): FulfillmentInput {
    const message = createBaseFulfillmentInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? FulfillmentSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? FulfillmentInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseFulfillmentInstance(): FulfillmentInstance {
  return { prediction: undefined, instruction: undefined };
}

export const FulfillmentInstance: MessageFns<FulfillmentInstance> = {
  encode(message: FulfillmentInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.instruction !== undefined) {
      writer.uint32(18).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: FulfillmentInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<FulfillmentInstance>): FulfillmentInstance {
    return FulfillmentInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FulfillmentInstance>): FulfillmentInstance {
    const message = createBaseFulfillmentInstance();
    message.prediction = object.prediction ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseFulfillmentSpec(): FulfillmentSpec {
  return { version: 0 };
}

export const FulfillmentSpec: MessageFns<FulfillmentSpec> = {
  encode(message: FulfillmentSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentSpec {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: FulfillmentSpec): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<FulfillmentSpec>): FulfillmentSpec {
    return FulfillmentSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FulfillmentSpec>): FulfillmentSpec {
    const message = createBaseFulfillmentSpec();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseFulfillmentResult(): FulfillmentResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const FulfillmentResult: MessageFns<FulfillmentResult> = {
  encode(message: FulfillmentResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: FulfillmentResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<FulfillmentResult>): FulfillmentResult {
    return FulfillmentResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FulfillmentResult>): FulfillmentResult {
    const message = createBaseFulfillmentResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseSummarizationQualityInput(): SummarizationQualityInput {
  return { metricSpec: undefined, instance: undefined };
}

export const SummarizationQualityInput: MessageFns<SummarizationQualityInput> = {
  encode(message: SummarizationQualityInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      SummarizationQualitySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      SummarizationQualityInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationQualityInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationQualityInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = SummarizationQualitySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = SummarizationQualityInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationQualityInput {
    return {
      metricSpec: isSet(object.metricSpec) ? SummarizationQualitySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? SummarizationQualityInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: SummarizationQualityInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = SummarizationQualitySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = SummarizationQualityInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationQualityInput>): SummarizationQualityInput {
    return SummarizationQualityInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationQualityInput>): SummarizationQualityInput {
    const message = createBaseSummarizationQualityInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? SummarizationQualitySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? SummarizationQualityInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseSummarizationQualityInstance(): SummarizationQualityInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const SummarizationQualityInstance: MessageFns<SummarizationQualityInstance> = {
  encode(message: SummarizationQualityInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationQualityInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationQualityInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationQualityInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: SummarizationQualityInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationQualityInstance>): SummarizationQualityInstance {
    return SummarizationQualityInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationQualityInstance>): SummarizationQualityInstance {
    const message = createBaseSummarizationQualityInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseSummarizationQualitySpec(): SummarizationQualitySpec {
  return { useReference: false, version: 0 };
}

export const SummarizationQualitySpec: MessageFns<SummarizationQualitySpec> = {
  encode(message: SummarizationQualitySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationQualitySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationQualitySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationQualitySpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: SummarizationQualitySpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationQualitySpec>): SummarizationQualitySpec {
    return SummarizationQualitySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationQualitySpec>): SummarizationQualitySpec {
    const message = createBaseSummarizationQualitySpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSummarizationQualityResult(): SummarizationQualityResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const SummarizationQualityResult: MessageFns<SummarizationQualityResult> = {
  encode(message: SummarizationQualityResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationQualityResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationQualityResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationQualityResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: SummarizationQualityResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationQualityResult>): SummarizationQualityResult {
    return SummarizationQualityResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationQualityResult>): SummarizationQualityResult {
    const message = createBaseSummarizationQualityResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBasePairwiseSummarizationQualityInput(): PairwiseSummarizationQualityInput {
  return { metricSpec: undefined, instance: undefined };
}

export const PairwiseSummarizationQualityInput: MessageFns<PairwiseSummarizationQualityInput> = {
  encode(message: PairwiseSummarizationQualityInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      PairwiseSummarizationQualitySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      PairwiseSummarizationQualityInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseSummarizationQualityInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseSummarizationQualityInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = PairwiseSummarizationQualitySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = PairwiseSummarizationQualityInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseSummarizationQualityInput {
    return {
      metricSpec: isSet(object.metricSpec) ? PairwiseSummarizationQualitySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? PairwiseSummarizationQualityInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: PairwiseSummarizationQualityInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = PairwiseSummarizationQualitySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = PairwiseSummarizationQualityInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseSummarizationQualityInput>): PairwiseSummarizationQualityInput {
    return PairwiseSummarizationQualityInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseSummarizationQualityInput>): PairwiseSummarizationQualityInput {
    const message = createBasePairwiseSummarizationQualityInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? PairwiseSummarizationQualitySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? PairwiseSummarizationQualityInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBasePairwiseSummarizationQualityInstance(): PairwiseSummarizationQualityInstance {
  return {
    prediction: undefined,
    baselinePrediction: undefined,
    reference: undefined,
    context: undefined,
    instruction: undefined,
  };
}

export const PairwiseSummarizationQualityInstance: MessageFns<PairwiseSummarizationQualityInstance> = {
  encode(message: PairwiseSummarizationQualityInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.baselinePrediction !== undefined) {
      writer.uint32(18).string(message.baselinePrediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(26).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(34).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(42).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseSummarizationQualityInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseSummarizationQualityInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baselinePrediction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseSummarizationQualityInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      baselinePrediction: isSet(object.baselinePrediction) ? globalThis.String(object.baselinePrediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: PairwiseSummarizationQualityInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.baselinePrediction !== undefined) {
      obj.baselinePrediction = message.baselinePrediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseSummarizationQualityInstance>): PairwiseSummarizationQualityInstance {
    return PairwiseSummarizationQualityInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseSummarizationQualityInstance>): PairwiseSummarizationQualityInstance {
    const message = createBasePairwiseSummarizationQualityInstance();
    message.prediction = object.prediction ?? undefined;
    message.baselinePrediction = object.baselinePrediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBasePairwiseSummarizationQualitySpec(): PairwiseSummarizationQualitySpec {
  return { useReference: false, version: 0 };
}

export const PairwiseSummarizationQualitySpec: MessageFns<PairwiseSummarizationQualitySpec> = {
  encode(message: PairwiseSummarizationQualitySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseSummarizationQualitySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseSummarizationQualitySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseSummarizationQualitySpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: PairwiseSummarizationQualitySpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseSummarizationQualitySpec>): PairwiseSummarizationQualitySpec {
    return PairwiseSummarizationQualitySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseSummarizationQualitySpec>): PairwiseSummarizationQualitySpec {
    const message = createBasePairwiseSummarizationQualitySpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBasePairwiseSummarizationQualityResult(): PairwiseSummarizationQualityResult {
  return { pairwiseChoice: 0, explanation: "", confidence: undefined };
}

export const PairwiseSummarizationQualityResult: MessageFns<PairwiseSummarizationQualityResult> = {
  encode(message: PairwiseSummarizationQualityResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairwiseChoice !== 0) {
      writer.uint32(8).int32(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseSummarizationQualityResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseSummarizationQualityResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pairwiseChoice = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseSummarizationQualityResult {
    return {
      pairwiseChoice: isSet(object.pairwiseChoice) ? pairwiseChoiceFromJSON(object.pairwiseChoice) : 0,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: PairwiseSummarizationQualityResult): unknown {
    const obj: any = {};
    if (message.pairwiseChoice !== 0) {
      obj.pairwiseChoice = pairwiseChoiceToJSON(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseSummarizationQualityResult>): PairwiseSummarizationQualityResult {
    return PairwiseSummarizationQualityResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseSummarizationQualityResult>): PairwiseSummarizationQualityResult {
    const message = createBasePairwiseSummarizationQualityResult();
    message.pairwiseChoice = object.pairwiseChoice ?? 0;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseSummarizationHelpfulnessInput(): SummarizationHelpfulnessInput {
  return { metricSpec: undefined, instance: undefined };
}

export const SummarizationHelpfulnessInput: MessageFns<SummarizationHelpfulnessInput> = {
  encode(message: SummarizationHelpfulnessInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      SummarizationHelpfulnessSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      SummarizationHelpfulnessInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationHelpfulnessInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationHelpfulnessInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = SummarizationHelpfulnessSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = SummarizationHelpfulnessInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationHelpfulnessInput {
    return {
      metricSpec: isSet(object.metricSpec) ? SummarizationHelpfulnessSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? SummarizationHelpfulnessInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: SummarizationHelpfulnessInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = SummarizationHelpfulnessSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = SummarizationHelpfulnessInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationHelpfulnessInput>): SummarizationHelpfulnessInput {
    return SummarizationHelpfulnessInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationHelpfulnessInput>): SummarizationHelpfulnessInput {
    const message = createBaseSummarizationHelpfulnessInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? SummarizationHelpfulnessSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? SummarizationHelpfulnessInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseSummarizationHelpfulnessInstance(): SummarizationHelpfulnessInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const SummarizationHelpfulnessInstance: MessageFns<SummarizationHelpfulnessInstance> = {
  encode(message: SummarizationHelpfulnessInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationHelpfulnessInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationHelpfulnessInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationHelpfulnessInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: SummarizationHelpfulnessInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationHelpfulnessInstance>): SummarizationHelpfulnessInstance {
    return SummarizationHelpfulnessInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationHelpfulnessInstance>): SummarizationHelpfulnessInstance {
    const message = createBaseSummarizationHelpfulnessInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseSummarizationHelpfulnessSpec(): SummarizationHelpfulnessSpec {
  return { useReference: false, version: 0 };
}

export const SummarizationHelpfulnessSpec: MessageFns<SummarizationHelpfulnessSpec> = {
  encode(message: SummarizationHelpfulnessSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationHelpfulnessSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationHelpfulnessSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationHelpfulnessSpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: SummarizationHelpfulnessSpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationHelpfulnessSpec>): SummarizationHelpfulnessSpec {
    return SummarizationHelpfulnessSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationHelpfulnessSpec>): SummarizationHelpfulnessSpec {
    const message = createBaseSummarizationHelpfulnessSpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSummarizationHelpfulnessResult(): SummarizationHelpfulnessResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const SummarizationHelpfulnessResult: MessageFns<SummarizationHelpfulnessResult> = {
  encode(message: SummarizationHelpfulnessResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationHelpfulnessResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationHelpfulnessResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationHelpfulnessResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: SummarizationHelpfulnessResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationHelpfulnessResult>): SummarizationHelpfulnessResult {
    return SummarizationHelpfulnessResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationHelpfulnessResult>): SummarizationHelpfulnessResult {
    const message = createBaseSummarizationHelpfulnessResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseSummarizationVerbosityInput(): SummarizationVerbosityInput {
  return { metricSpec: undefined, instance: undefined };
}

export const SummarizationVerbosityInput: MessageFns<SummarizationVerbosityInput> = {
  encode(message: SummarizationVerbosityInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      SummarizationVerbositySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      SummarizationVerbosityInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationVerbosityInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationVerbosityInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = SummarizationVerbositySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = SummarizationVerbosityInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationVerbosityInput {
    return {
      metricSpec: isSet(object.metricSpec) ? SummarizationVerbositySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? SummarizationVerbosityInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: SummarizationVerbosityInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = SummarizationVerbositySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = SummarizationVerbosityInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationVerbosityInput>): SummarizationVerbosityInput {
    return SummarizationVerbosityInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationVerbosityInput>): SummarizationVerbosityInput {
    const message = createBaseSummarizationVerbosityInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? SummarizationVerbositySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? SummarizationVerbosityInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseSummarizationVerbosityInstance(): SummarizationVerbosityInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const SummarizationVerbosityInstance: MessageFns<SummarizationVerbosityInstance> = {
  encode(message: SummarizationVerbosityInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationVerbosityInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationVerbosityInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationVerbosityInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: SummarizationVerbosityInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationVerbosityInstance>): SummarizationVerbosityInstance {
    return SummarizationVerbosityInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationVerbosityInstance>): SummarizationVerbosityInstance {
    const message = createBaseSummarizationVerbosityInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseSummarizationVerbositySpec(): SummarizationVerbositySpec {
  return { useReference: false, version: 0 };
}

export const SummarizationVerbositySpec: MessageFns<SummarizationVerbositySpec> = {
  encode(message: SummarizationVerbositySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationVerbositySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationVerbositySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationVerbositySpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: SummarizationVerbositySpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationVerbositySpec>): SummarizationVerbositySpec {
    return SummarizationVerbositySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationVerbositySpec>): SummarizationVerbositySpec {
    const message = createBaseSummarizationVerbositySpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSummarizationVerbosityResult(): SummarizationVerbosityResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const SummarizationVerbosityResult: MessageFns<SummarizationVerbosityResult> = {
  encode(message: SummarizationVerbosityResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SummarizationVerbosityResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummarizationVerbosityResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummarizationVerbosityResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: SummarizationVerbosityResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<SummarizationVerbosityResult>): SummarizationVerbosityResult {
    return SummarizationVerbosityResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SummarizationVerbosityResult>): SummarizationVerbosityResult {
    const message = createBaseSummarizationVerbosityResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringQualityInput(): QuestionAnsweringQualityInput {
  return { metricSpec: undefined, instance: undefined };
}

export const QuestionAnsweringQualityInput: MessageFns<QuestionAnsweringQualityInput> = {
  encode(message: QuestionAnsweringQualityInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      QuestionAnsweringQualitySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      QuestionAnsweringQualityInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringQualityInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringQualityInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = QuestionAnsweringQualitySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = QuestionAnsweringQualityInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringQualityInput {
    return {
      metricSpec: isSet(object.metricSpec) ? QuestionAnsweringQualitySpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? QuestionAnsweringQualityInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringQualityInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = QuestionAnsweringQualitySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = QuestionAnsweringQualityInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringQualityInput>): QuestionAnsweringQualityInput {
    return QuestionAnsweringQualityInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringQualityInput>): QuestionAnsweringQualityInput {
    const message = createBaseQuestionAnsweringQualityInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? QuestionAnsweringQualitySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? QuestionAnsweringQualityInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseQuestionAnsweringQualityInstance(): QuestionAnsweringQualityInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const QuestionAnsweringQualityInstance: MessageFns<QuestionAnsweringQualityInstance> = {
  encode(message: QuestionAnsweringQualityInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringQualityInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringQualityInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringQualityInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringQualityInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringQualityInstance>): QuestionAnsweringQualityInstance {
    return QuestionAnsweringQualityInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringQualityInstance>): QuestionAnsweringQualityInstance {
    const message = createBaseQuestionAnsweringQualityInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringQualitySpec(): QuestionAnsweringQualitySpec {
  return { useReference: false, version: 0 };
}

export const QuestionAnsweringQualitySpec: MessageFns<QuestionAnsweringQualitySpec> = {
  encode(message: QuestionAnsweringQualitySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringQualitySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringQualitySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringQualitySpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: QuestionAnsweringQualitySpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringQualitySpec>): QuestionAnsweringQualitySpec {
    return QuestionAnsweringQualitySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringQualitySpec>): QuestionAnsweringQualitySpec {
    const message = createBaseQuestionAnsweringQualitySpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseQuestionAnsweringQualityResult(): QuestionAnsweringQualityResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const QuestionAnsweringQualityResult: MessageFns<QuestionAnsweringQualityResult> = {
  encode(message: QuestionAnsweringQualityResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringQualityResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringQualityResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringQualityResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringQualityResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringQualityResult>): QuestionAnsweringQualityResult {
    return QuestionAnsweringQualityResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringQualityResult>): QuestionAnsweringQualityResult {
    const message = createBaseQuestionAnsweringQualityResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBasePairwiseQuestionAnsweringQualityInput(): PairwiseQuestionAnsweringQualityInput {
  return { metricSpec: undefined, instance: undefined };
}

export const PairwiseQuestionAnsweringQualityInput: MessageFns<PairwiseQuestionAnsweringQualityInput> = {
  encode(message: PairwiseQuestionAnsweringQualityInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      PairwiseQuestionAnsweringQualitySpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      PairwiseQuestionAnsweringQualityInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseQuestionAnsweringQualityInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseQuestionAnsweringQualityInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = PairwiseQuestionAnsweringQualitySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = PairwiseQuestionAnsweringQualityInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseQuestionAnsweringQualityInput {
    return {
      metricSpec: isSet(object.metricSpec)
        ? PairwiseQuestionAnsweringQualitySpec.fromJSON(object.metricSpec)
        : undefined,
      instance: isSet(object.instance) ? PairwiseQuestionAnsweringQualityInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: PairwiseQuestionAnsweringQualityInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = PairwiseQuestionAnsweringQualitySpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = PairwiseQuestionAnsweringQualityInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseQuestionAnsweringQualityInput>): PairwiseQuestionAnsweringQualityInput {
    return PairwiseQuestionAnsweringQualityInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseQuestionAnsweringQualityInput>): PairwiseQuestionAnsweringQualityInput {
    const message = createBasePairwiseQuestionAnsweringQualityInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? PairwiseQuestionAnsweringQualitySpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? PairwiseQuestionAnsweringQualityInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBasePairwiseQuestionAnsweringQualityInstance(): PairwiseQuestionAnsweringQualityInstance {
  return {
    prediction: undefined,
    baselinePrediction: undefined,
    reference: undefined,
    context: undefined,
    instruction: undefined,
  };
}

export const PairwiseQuestionAnsweringQualityInstance: MessageFns<PairwiseQuestionAnsweringQualityInstance> = {
  encode(message: PairwiseQuestionAnsweringQualityInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.baselinePrediction !== undefined) {
      writer.uint32(18).string(message.baselinePrediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(26).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(34).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(42).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseQuestionAnsweringQualityInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseQuestionAnsweringQualityInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baselinePrediction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseQuestionAnsweringQualityInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      baselinePrediction: isSet(object.baselinePrediction) ? globalThis.String(object.baselinePrediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: PairwiseQuestionAnsweringQualityInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.baselinePrediction !== undefined) {
      obj.baselinePrediction = message.baselinePrediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseQuestionAnsweringQualityInstance>): PairwiseQuestionAnsweringQualityInstance {
    return PairwiseQuestionAnsweringQualityInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseQuestionAnsweringQualityInstance>): PairwiseQuestionAnsweringQualityInstance {
    const message = createBasePairwiseQuestionAnsweringQualityInstance();
    message.prediction = object.prediction ?? undefined;
    message.baselinePrediction = object.baselinePrediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBasePairwiseQuestionAnsweringQualitySpec(): PairwiseQuestionAnsweringQualitySpec {
  return { useReference: false, version: 0 };
}

export const PairwiseQuestionAnsweringQualitySpec: MessageFns<PairwiseQuestionAnsweringQualitySpec> = {
  encode(message: PairwiseQuestionAnsweringQualitySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseQuestionAnsweringQualitySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseQuestionAnsweringQualitySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseQuestionAnsweringQualitySpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: PairwiseQuestionAnsweringQualitySpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseQuestionAnsweringQualitySpec>): PairwiseQuestionAnsweringQualitySpec {
    return PairwiseQuestionAnsweringQualitySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseQuestionAnsweringQualitySpec>): PairwiseQuestionAnsweringQualitySpec {
    const message = createBasePairwiseQuestionAnsweringQualitySpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBasePairwiseQuestionAnsweringQualityResult(): PairwiseQuestionAnsweringQualityResult {
  return { pairwiseChoice: 0, explanation: "", confidence: undefined };
}

export const PairwiseQuestionAnsweringQualityResult: MessageFns<PairwiseQuestionAnsweringQualityResult> = {
  encode(message: PairwiseQuestionAnsweringQualityResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairwiseChoice !== 0) {
      writer.uint32(8).int32(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseQuestionAnsweringQualityResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseQuestionAnsweringQualityResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pairwiseChoice = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseQuestionAnsweringQualityResult {
    return {
      pairwiseChoice: isSet(object.pairwiseChoice) ? pairwiseChoiceFromJSON(object.pairwiseChoice) : 0,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: PairwiseQuestionAnsweringQualityResult): unknown {
    const obj: any = {};
    if (message.pairwiseChoice !== 0) {
      obj.pairwiseChoice = pairwiseChoiceToJSON(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseQuestionAnsweringQualityResult>): PairwiseQuestionAnsweringQualityResult {
    return PairwiseQuestionAnsweringQualityResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseQuestionAnsweringQualityResult>): PairwiseQuestionAnsweringQualityResult {
    const message = createBasePairwiseQuestionAnsweringQualityResult();
    message.pairwiseChoice = object.pairwiseChoice ?? 0;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringRelevanceInput(): QuestionAnsweringRelevanceInput {
  return { metricSpec: undefined, instance: undefined };
}

export const QuestionAnsweringRelevanceInput: MessageFns<QuestionAnsweringRelevanceInput> = {
  encode(message: QuestionAnsweringRelevanceInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      QuestionAnsweringRelevanceSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      QuestionAnsweringRelevanceInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringRelevanceInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringRelevanceInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = QuestionAnsweringRelevanceSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = QuestionAnsweringRelevanceInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringRelevanceInput {
    return {
      metricSpec: isSet(object.metricSpec) ? QuestionAnsweringRelevanceSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? QuestionAnsweringRelevanceInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringRelevanceInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = QuestionAnsweringRelevanceSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = QuestionAnsweringRelevanceInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringRelevanceInput>): QuestionAnsweringRelevanceInput {
    return QuestionAnsweringRelevanceInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringRelevanceInput>): QuestionAnsweringRelevanceInput {
    const message = createBaseQuestionAnsweringRelevanceInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? QuestionAnsweringRelevanceSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? QuestionAnsweringRelevanceInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseQuestionAnsweringRelevanceInstance(): QuestionAnsweringRelevanceInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const QuestionAnsweringRelevanceInstance: MessageFns<QuestionAnsweringRelevanceInstance> = {
  encode(message: QuestionAnsweringRelevanceInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringRelevanceInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringRelevanceInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringRelevanceInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringRelevanceInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringRelevanceInstance>): QuestionAnsweringRelevanceInstance {
    return QuestionAnsweringRelevanceInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringRelevanceInstance>): QuestionAnsweringRelevanceInstance {
    const message = createBaseQuestionAnsweringRelevanceInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringRelevanceSpec(): QuestionAnsweringRelevanceSpec {
  return { useReference: false, version: 0 };
}

export const QuestionAnsweringRelevanceSpec: MessageFns<QuestionAnsweringRelevanceSpec> = {
  encode(message: QuestionAnsweringRelevanceSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringRelevanceSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringRelevanceSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringRelevanceSpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: QuestionAnsweringRelevanceSpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringRelevanceSpec>): QuestionAnsweringRelevanceSpec {
    return QuestionAnsweringRelevanceSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringRelevanceSpec>): QuestionAnsweringRelevanceSpec {
    const message = createBaseQuestionAnsweringRelevanceSpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseQuestionAnsweringRelevanceResult(): QuestionAnsweringRelevanceResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const QuestionAnsweringRelevanceResult: MessageFns<QuestionAnsweringRelevanceResult> = {
  encode(message: QuestionAnsweringRelevanceResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringRelevanceResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringRelevanceResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringRelevanceResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringRelevanceResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringRelevanceResult>): QuestionAnsweringRelevanceResult {
    return QuestionAnsweringRelevanceResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringRelevanceResult>): QuestionAnsweringRelevanceResult {
    const message = createBaseQuestionAnsweringRelevanceResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringHelpfulnessInput(): QuestionAnsweringHelpfulnessInput {
  return { metricSpec: undefined, instance: undefined };
}

export const QuestionAnsweringHelpfulnessInput: MessageFns<QuestionAnsweringHelpfulnessInput> = {
  encode(message: QuestionAnsweringHelpfulnessInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      QuestionAnsweringHelpfulnessSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      QuestionAnsweringHelpfulnessInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringHelpfulnessInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringHelpfulnessInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = QuestionAnsweringHelpfulnessSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = QuestionAnsweringHelpfulnessInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringHelpfulnessInput {
    return {
      metricSpec: isSet(object.metricSpec) ? QuestionAnsweringHelpfulnessSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? QuestionAnsweringHelpfulnessInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringHelpfulnessInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = QuestionAnsweringHelpfulnessSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = QuestionAnsweringHelpfulnessInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringHelpfulnessInput>): QuestionAnsweringHelpfulnessInput {
    return QuestionAnsweringHelpfulnessInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringHelpfulnessInput>): QuestionAnsweringHelpfulnessInput {
    const message = createBaseQuestionAnsweringHelpfulnessInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? QuestionAnsweringHelpfulnessSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? QuestionAnsweringHelpfulnessInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseQuestionAnsweringHelpfulnessInstance(): QuestionAnsweringHelpfulnessInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const QuestionAnsweringHelpfulnessInstance: MessageFns<QuestionAnsweringHelpfulnessInstance> = {
  encode(message: QuestionAnsweringHelpfulnessInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringHelpfulnessInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringHelpfulnessInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringHelpfulnessInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringHelpfulnessInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringHelpfulnessInstance>): QuestionAnsweringHelpfulnessInstance {
    return QuestionAnsweringHelpfulnessInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringHelpfulnessInstance>): QuestionAnsweringHelpfulnessInstance {
    const message = createBaseQuestionAnsweringHelpfulnessInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringHelpfulnessSpec(): QuestionAnsweringHelpfulnessSpec {
  return { useReference: false, version: 0 };
}

export const QuestionAnsweringHelpfulnessSpec: MessageFns<QuestionAnsweringHelpfulnessSpec> = {
  encode(message: QuestionAnsweringHelpfulnessSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringHelpfulnessSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringHelpfulnessSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringHelpfulnessSpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: QuestionAnsweringHelpfulnessSpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringHelpfulnessSpec>): QuestionAnsweringHelpfulnessSpec {
    return QuestionAnsweringHelpfulnessSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringHelpfulnessSpec>): QuestionAnsweringHelpfulnessSpec {
    const message = createBaseQuestionAnsweringHelpfulnessSpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseQuestionAnsweringHelpfulnessResult(): QuestionAnsweringHelpfulnessResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const QuestionAnsweringHelpfulnessResult: MessageFns<QuestionAnsweringHelpfulnessResult> = {
  encode(message: QuestionAnsweringHelpfulnessResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringHelpfulnessResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringHelpfulnessResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringHelpfulnessResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringHelpfulnessResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringHelpfulnessResult>): QuestionAnsweringHelpfulnessResult {
    return QuestionAnsweringHelpfulnessResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringHelpfulnessResult>): QuestionAnsweringHelpfulnessResult {
    const message = createBaseQuestionAnsweringHelpfulnessResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringCorrectnessInput(): QuestionAnsweringCorrectnessInput {
  return { metricSpec: undefined, instance: undefined };
}

export const QuestionAnsweringCorrectnessInput: MessageFns<QuestionAnsweringCorrectnessInput> = {
  encode(message: QuestionAnsweringCorrectnessInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      QuestionAnsweringCorrectnessSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      QuestionAnsweringCorrectnessInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringCorrectnessInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringCorrectnessInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = QuestionAnsweringCorrectnessSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = QuestionAnsweringCorrectnessInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringCorrectnessInput {
    return {
      metricSpec: isSet(object.metricSpec) ? QuestionAnsweringCorrectnessSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? QuestionAnsweringCorrectnessInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringCorrectnessInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = QuestionAnsweringCorrectnessSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = QuestionAnsweringCorrectnessInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringCorrectnessInput>): QuestionAnsweringCorrectnessInput {
    return QuestionAnsweringCorrectnessInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringCorrectnessInput>): QuestionAnsweringCorrectnessInput {
    const message = createBaseQuestionAnsweringCorrectnessInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? QuestionAnsweringCorrectnessSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? QuestionAnsweringCorrectnessInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseQuestionAnsweringCorrectnessInstance(): QuestionAnsweringCorrectnessInstance {
  return { prediction: undefined, reference: undefined, context: undefined, instruction: undefined };
}

export const QuestionAnsweringCorrectnessInstance: MessageFns<QuestionAnsweringCorrectnessInstance> = {
  encode(message: QuestionAnsweringCorrectnessInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    if (message.instruction !== undefined) {
      writer.uint32(34).string(message.instruction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringCorrectnessInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringCorrectnessInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instruction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringCorrectnessInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringCorrectnessInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.instruction !== undefined) {
      obj.instruction = message.instruction;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringCorrectnessInstance>): QuestionAnsweringCorrectnessInstance {
    return QuestionAnsweringCorrectnessInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringCorrectnessInstance>): QuestionAnsweringCorrectnessInstance {
    const message = createBaseQuestionAnsweringCorrectnessInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    message.context = object.context ?? undefined;
    message.instruction = object.instruction ?? undefined;
    return message;
  },
};

function createBaseQuestionAnsweringCorrectnessSpec(): QuestionAnsweringCorrectnessSpec {
  return { useReference: false, version: 0 };
}

export const QuestionAnsweringCorrectnessSpec: MessageFns<QuestionAnsweringCorrectnessSpec> = {
  encode(message: QuestionAnsweringCorrectnessSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useReference !== false) {
      writer.uint32(8).bool(message.useReference);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringCorrectnessSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringCorrectnessSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useReference = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringCorrectnessSpec {
    return {
      useReference: isSet(object.useReference) ? globalThis.Boolean(object.useReference) : false,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: QuestionAnsweringCorrectnessSpec): unknown {
    const obj: any = {};
    if (message.useReference !== false) {
      obj.useReference = message.useReference;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringCorrectnessSpec>): QuestionAnsweringCorrectnessSpec {
    return QuestionAnsweringCorrectnessSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringCorrectnessSpec>): QuestionAnsweringCorrectnessSpec {
    const message = createBaseQuestionAnsweringCorrectnessSpec();
    message.useReference = object.useReference ?? false;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseQuestionAnsweringCorrectnessResult(): QuestionAnsweringCorrectnessResult {
  return { score: undefined, explanation: "", confidence: undefined };
}

export const QuestionAnsweringCorrectnessResult: MessageFns<QuestionAnsweringCorrectnessResult> = {
  encode(message: QuestionAnsweringCorrectnessResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    if (message.confidence !== undefined) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionAnsweringCorrectnessResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionAnsweringCorrectnessResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionAnsweringCorrectnessResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
    };
  },

  toJSON(message: QuestionAnsweringCorrectnessResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<QuestionAnsweringCorrectnessResult>): QuestionAnsweringCorrectnessResult {
    return QuestionAnsweringCorrectnessResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuestionAnsweringCorrectnessResult>): QuestionAnsweringCorrectnessResult {
    const message = createBaseQuestionAnsweringCorrectnessResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    message.confidence = object.confidence ?? undefined;
    return message;
  },
};

function createBasePointwiseMetricInput(): PointwiseMetricInput {
  return { metricSpec: undefined, instance: undefined };
}

export const PointwiseMetricInput: MessageFns<PointwiseMetricInput> = {
  encode(message: PointwiseMetricInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      PointwiseMetricSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      PointwiseMetricInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointwiseMetricInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointwiseMetricInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = PointwiseMetricSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = PointwiseMetricInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointwiseMetricInput {
    return {
      metricSpec: isSet(object.metricSpec) ? PointwiseMetricSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? PointwiseMetricInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: PointwiseMetricInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = PointwiseMetricSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = PointwiseMetricInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<PointwiseMetricInput>): PointwiseMetricInput {
    return PointwiseMetricInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PointwiseMetricInput>): PointwiseMetricInput {
    const message = createBasePointwiseMetricInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? PointwiseMetricSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? PointwiseMetricInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBasePointwiseMetricInstance(): PointwiseMetricInstance {
  return { jsonInstance: undefined };
}

export const PointwiseMetricInstance: MessageFns<PointwiseMetricInstance> = {
  encode(message: PointwiseMetricInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonInstance !== undefined) {
      writer.uint32(10).string(message.jsonInstance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointwiseMetricInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointwiseMetricInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jsonInstance = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointwiseMetricInstance {
    return { jsonInstance: isSet(object.jsonInstance) ? globalThis.String(object.jsonInstance) : undefined };
  },

  toJSON(message: PointwiseMetricInstance): unknown {
    const obj: any = {};
    if (message.jsonInstance !== undefined) {
      obj.jsonInstance = message.jsonInstance;
    }
    return obj;
  },

  create(base?: DeepPartial<PointwiseMetricInstance>): PointwiseMetricInstance {
    return PointwiseMetricInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PointwiseMetricInstance>): PointwiseMetricInstance {
    const message = createBasePointwiseMetricInstance();
    message.jsonInstance = object.jsonInstance ?? undefined;
    return message;
  },
};

function createBasePointwiseMetricSpec(): PointwiseMetricSpec {
  return { metricPromptTemplate: undefined };
}

export const PointwiseMetricSpec: MessageFns<PointwiseMetricSpec> = {
  encode(message: PointwiseMetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricPromptTemplate !== undefined) {
      writer.uint32(10).string(message.metricPromptTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointwiseMetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointwiseMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricPromptTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointwiseMetricSpec {
    return {
      metricPromptTemplate: isSet(object.metricPromptTemplate)
        ? globalThis.String(object.metricPromptTemplate)
        : undefined,
    };
  },

  toJSON(message: PointwiseMetricSpec): unknown {
    const obj: any = {};
    if (message.metricPromptTemplate !== undefined) {
      obj.metricPromptTemplate = message.metricPromptTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<PointwiseMetricSpec>): PointwiseMetricSpec {
    return PointwiseMetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PointwiseMetricSpec>): PointwiseMetricSpec {
    const message = createBasePointwiseMetricSpec();
    message.metricPromptTemplate = object.metricPromptTemplate ?? undefined;
    return message;
  },
};

function createBasePointwiseMetricResult(): PointwiseMetricResult {
  return { score: undefined, explanation: "" };
}

export const PointwiseMetricResult: MessageFns<PointwiseMetricResult> = {
  encode(message: PointwiseMetricResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointwiseMetricResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointwiseMetricResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointwiseMetricResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
    };
  },

  toJSON(message: PointwiseMetricResult): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create(base?: DeepPartial<PointwiseMetricResult>): PointwiseMetricResult {
    return PointwiseMetricResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PointwiseMetricResult>): PointwiseMetricResult {
    const message = createBasePointwiseMetricResult();
    message.score = object.score ?? undefined;
    message.explanation = object.explanation ?? "";
    return message;
  },
};

function createBasePairwiseMetricInput(): PairwiseMetricInput {
  return { metricSpec: undefined, instance: undefined };
}

export const PairwiseMetricInput: MessageFns<PairwiseMetricInput> = {
  encode(message: PairwiseMetricInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      PairwiseMetricSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      PairwiseMetricInstance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseMetricInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseMetricInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = PairwiseMetricSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = PairwiseMetricInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseMetricInput {
    return {
      metricSpec: isSet(object.metricSpec) ? PairwiseMetricSpec.fromJSON(object.metricSpec) : undefined,
      instance: isSet(object.instance) ? PairwiseMetricInstance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: PairwiseMetricInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = PairwiseMetricSpec.toJSON(message.metricSpec);
    }
    if (message.instance !== undefined) {
      obj.instance = PairwiseMetricInstance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseMetricInput>): PairwiseMetricInput {
    return PairwiseMetricInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseMetricInput>): PairwiseMetricInput {
    const message = createBasePairwiseMetricInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? PairwiseMetricSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? PairwiseMetricInstance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBasePairwiseMetricInstance(): PairwiseMetricInstance {
  return { jsonInstance: undefined };
}

export const PairwiseMetricInstance: MessageFns<PairwiseMetricInstance> = {
  encode(message: PairwiseMetricInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonInstance !== undefined) {
      writer.uint32(10).string(message.jsonInstance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseMetricInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseMetricInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jsonInstance = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseMetricInstance {
    return { jsonInstance: isSet(object.jsonInstance) ? globalThis.String(object.jsonInstance) : undefined };
  },

  toJSON(message: PairwiseMetricInstance): unknown {
    const obj: any = {};
    if (message.jsonInstance !== undefined) {
      obj.jsonInstance = message.jsonInstance;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseMetricInstance>): PairwiseMetricInstance {
    return PairwiseMetricInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseMetricInstance>): PairwiseMetricInstance {
    const message = createBasePairwiseMetricInstance();
    message.jsonInstance = object.jsonInstance ?? undefined;
    return message;
  },
};

function createBasePairwiseMetricSpec(): PairwiseMetricSpec {
  return { metricPromptTemplate: undefined };
}

export const PairwiseMetricSpec: MessageFns<PairwiseMetricSpec> = {
  encode(message: PairwiseMetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricPromptTemplate !== undefined) {
      writer.uint32(10).string(message.metricPromptTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseMetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricPromptTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseMetricSpec {
    return {
      metricPromptTemplate: isSet(object.metricPromptTemplate)
        ? globalThis.String(object.metricPromptTemplate)
        : undefined,
    };
  },

  toJSON(message: PairwiseMetricSpec): unknown {
    const obj: any = {};
    if (message.metricPromptTemplate !== undefined) {
      obj.metricPromptTemplate = message.metricPromptTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseMetricSpec>): PairwiseMetricSpec {
    return PairwiseMetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseMetricSpec>): PairwiseMetricSpec {
    const message = createBasePairwiseMetricSpec();
    message.metricPromptTemplate = object.metricPromptTemplate ?? undefined;
    return message;
  },
};

function createBasePairwiseMetricResult(): PairwiseMetricResult {
  return { pairwiseChoice: 0, explanation: "" };
}

export const PairwiseMetricResult: MessageFns<PairwiseMetricResult> = {
  encode(message: PairwiseMetricResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairwiseChoice !== 0) {
      writer.uint32(8).int32(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      writer.uint32(18).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PairwiseMetricResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePairwiseMetricResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pairwiseChoice = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PairwiseMetricResult {
    return {
      pairwiseChoice: isSet(object.pairwiseChoice) ? pairwiseChoiceFromJSON(object.pairwiseChoice) : 0,
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
    };
  },

  toJSON(message: PairwiseMetricResult): unknown {
    const obj: any = {};
    if (message.pairwiseChoice !== 0) {
      obj.pairwiseChoice = pairwiseChoiceToJSON(message.pairwiseChoice);
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create(base?: DeepPartial<PairwiseMetricResult>): PairwiseMetricResult {
    return PairwiseMetricResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PairwiseMetricResult>): PairwiseMetricResult {
    const message = createBasePairwiseMetricResult();
    message.pairwiseChoice = object.pairwiseChoice ?? 0;
    message.explanation = object.explanation ?? "";
    return message;
  },
};

function createBaseToolCallValidInput(): ToolCallValidInput {
  return { metricSpec: undefined, instances: [] };
}

export const ToolCallValidInput: MessageFns<ToolCallValidInput> = {
  encode(message: ToolCallValidInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      ToolCallValidSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      ToolCallValidInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallValidInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallValidInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = ToolCallValidSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(ToolCallValidInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallValidInput {
    return {
      metricSpec: isSet(object.metricSpec) ? ToolCallValidSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => ToolCallValidInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolCallValidInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = ToolCallValidSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => ToolCallValidInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolCallValidInput>): ToolCallValidInput {
    return ToolCallValidInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolCallValidInput>): ToolCallValidInput {
    const message = createBaseToolCallValidInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? ToolCallValidSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => ToolCallValidInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolCallValidSpec(): ToolCallValidSpec {
  return {};
}

export const ToolCallValidSpec: MessageFns<ToolCallValidSpec> = {
  encode(_: ToolCallValidSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallValidSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallValidSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ToolCallValidSpec {
    return {};
  },

  toJSON(_: ToolCallValidSpec): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ToolCallValidSpec>): ToolCallValidSpec {
    return ToolCallValidSpec.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ToolCallValidSpec>): ToolCallValidSpec {
    const message = createBaseToolCallValidSpec();
    return message;
  },
};

function createBaseToolCallValidInstance(): ToolCallValidInstance {
  return { prediction: undefined, reference: undefined };
}

export const ToolCallValidInstance: MessageFns<ToolCallValidInstance> = {
  encode(message: ToolCallValidInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallValidInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallValidInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallValidInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: ToolCallValidInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolCallValidInstance>): ToolCallValidInstance {
    return ToolCallValidInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolCallValidInstance>): ToolCallValidInstance {
    const message = createBaseToolCallValidInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseToolCallValidResults(): ToolCallValidResults {
  return { toolCallValidMetricValues: [] };
}

export const ToolCallValidResults: MessageFns<ToolCallValidResults> = {
  encode(message: ToolCallValidResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.toolCallValidMetricValues) {
      ToolCallValidMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallValidResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallValidResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolCallValidMetricValues.push(ToolCallValidMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallValidResults {
    return {
      toolCallValidMetricValues: globalThis.Array.isArray(object?.toolCallValidMetricValues)
        ? object.toolCallValidMetricValues.map((e: any) => ToolCallValidMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolCallValidResults): unknown {
    const obj: any = {};
    if (message.toolCallValidMetricValues?.length) {
      obj.toolCallValidMetricValues = message.toolCallValidMetricValues.map((e) => ToolCallValidMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolCallValidResults>): ToolCallValidResults {
    return ToolCallValidResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolCallValidResults>): ToolCallValidResults {
    const message = createBaseToolCallValidResults();
    message.toolCallValidMetricValues =
      object.toolCallValidMetricValues?.map((e) => ToolCallValidMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolCallValidMetricValue(): ToolCallValidMetricValue {
  return { score: undefined };
}

export const ToolCallValidMetricValue: MessageFns<ToolCallValidMetricValue> = {
  encode(message: ToolCallValidMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallValidMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallValidMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallValidMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: ToolCallValidMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolCallValidMetricValue>): ToolCallValidMetricValue {
    return ToolCallValidMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolCallValidMetricValue>): ToolCallValidMetricValue {
    const message = createBaseToolCallValidMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseToolNameMatchInput(): ToolNameMatchInput {
  return { metricSpec: undefined, instances: [] };
}

export const ToolNameMatchInput: MessageFns<ToolNameMatchInput> = {
  encode(message: ToolNameMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      ToolNameMatchSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      ToolNameMatchInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolNameMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolNameMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = ToolNameMatchSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(ToolNameMatchInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolNameMatchInput {
    return {
      metricSpec: isSet(object.metricSpec) ? ToolNameMatchSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => ToolNameMatchInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolNameMatchInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = ToolNameMatchSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => ToolNameMatchInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolNameMatchInput>): ToolNameMatchInput {
    return ToolNameMatchInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolNameMatchInput>): ToolNameMatchInput {
    const message = createBaseToolNameMatchInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? ToolNameMatchSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => ToolNameMatchInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolNameMatchSpec(): ToolNameMatchSpec {
  return {};
}

export const ToolNameMatchSpec: MessageFns<ToolNameMatchSpec> = {
  encode(_: ToolNameMatchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolNameMatchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolNameMatchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ToolNameMatchSpec {
    return {};
  },

  toJSON(_: ToolNameMatchSpec): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ToolNameMatchSpec>): ToolNameMatchSpec {
    return ToolNameMatchSpec.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ToolNameMatchSpec>): ToolNameMatchSpec {
    const message = createBaseToolNameMatchSpec();
    return message;
  },
};

function createBaseToolNameMatchInstance(): ToolNameMatchInstance {
  return { prediction: undefined, reference: undefined };
}

export const ToolNameMatchInstance: MessageFns<ToolNameMatchInstance> = {
  encode(message: ToolNameMatchInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolNameMatchInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolNameMatchInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolNameMatchInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: ToolNameMatchInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolNameMatchInstance>): ToolNameMatchInstance {
    return ToolNameMatchInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolNameMatchInstance>): ToolNameMatchInstance {
    const message = createBaseToolNameMatchInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseToolNameMatchResults(): ToolNameMatchResults {
  return { toolNameMatchMetricValues: [] };
}

export const ToolNameMatchResults: MessageFns<ToolNameMatchResults> = {
  encode(message: ToolNameMatchResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.toolNameMatchMetricValues) {
      ToolNameMatchMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolNameMatchResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolNameMatchResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolNameMatchMetricValues.push(ToolNameMatchMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolNameMatchResults {
    return {
      toolNameMatchMetricValues: globalThis.Array.isArray(object?.toolNameMatchMetricValues)
        ? object.toolNameMatchMetricValues.map((e: any) => ToolNameMatchMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolNameMatchResults): unknown {
    const obj: any = {};
    if (message.toolNameMatchMetricValues?.length) {
      obj.toolNameMatchMetricValues = message.toolNameMatchMetricValues.map((e) => ToolNameMatchMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolNameMatchResults>): ToolNameMatchResults {
    return ToolNameMatchResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolNameMatchResults>): ToolNameMatchResults {
    const message = createBaseToolNameMatchResults();
    message.toolNameMatchMetricValues =
      object.toolNameMatchMetricValues?.map((e) => ToolNameMatchMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolNameMatchMetricValue(): ToolNameMatchMetricValue {
  return { score: undefined };
}

export const ToolNameMatchMetricValue: MessageFns<ToolNameMatchMetricValue> = {
  encode(message: ToolNameMatchMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolNameMatchMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolNameMatchMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolNameMatchMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: ToolNameMatchMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolNameMatchMetricValue>): ToolNameMatchMetricValue {
    return ToolNameMatchMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolNameMatchMetricValue>): ToolNameMatchMetricValue {
    const message = createBaseToolNameMatchMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseToolParameterKeyMatchInput(): ToolParameterKeyMatchInput {
  return { metricSpec: undefined, instances: [] };
}

export const ToolParameterKeyMatchInput: MessageFns<ToolParameterKeyMatchInput> = {
  encode(message: ToolParameterKeyMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      ToolParameterKeyMatchSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      ToolParameterKeyMatchInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKeyMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKeyMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = ToolParameterKeyMatchSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(ToolParameterKeyMatchInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKeyMatchInput {
    return {
      metricSpec: isSet(object.metricSpec) ? ToolParameterKeyMatchSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => ToolParameterKeyMatchInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolParameterKeyMatchInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = ToolParameterKeyMatchSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => ToolParameterKeyMatchInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKeyMatchInput>): ToolParameterKeyMatchInput {
    return ToolParameterKeyMatchInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKeyMatchInput>): ToolParameterKeyMatchInput {
    const message = createBaseToolParameterKeyMatchInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? ToolParameterKeyMatchSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => ToolParameterKeyMatchInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolParameterKeyMatchSpec(): ToolParameterKeyMatchSpec {
  return {};
}

export const ToolParameterKeyMatchSpec: MessageFns<ToolParameterKeyMatchSpec> = {
  encode(_: ToolParameterKeyMatchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKeyMatchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKeyMatchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ToolParameterKeyMatchSpec {
    return {};
  },

  toJSON(_: ToolParameterKeyMatchSpec): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKeyMatchSpec>): ToolParameterKeyMatchSpec {
    return ToolParameterKeyMatchSpec.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ToolParameterKeyMatchSpec>): ToolParameterKeyMatchSpec {
    const message = createBaseToolParameterKeyMatchSpec();
    return message;
  },
};

function createBaseToolParameterKeyMatchInstance(): ToolParameterKeyMatchInstance {
  return { prediction: undefined, reference: undefined };
}

export const ToolParameterKeyMatchInstance: MessageFns<ToolParameterKeyMatchInstance> = {
  encode(message: ToolParameterKeyMatchInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKeyMatchInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKeyMatchInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKeyMatchInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: ToolParameterKeyMatchInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKeyMatchInstance>): ToolParameterKeyMatchInstance {
    return ToolParameterKeyMatchInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKeyMatchInstance>): ToolParameterKeyMatchInstance {
    const message = createBaseToolParameterKeyMatchInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseToolParameterKeyMatchResults(): ToolParameterKeyMatchResults {
  return { toolParameterKeyMatchMetricValues: [] };
}

export const ToolParameterKeyMatchResults: MessageFns<ToolParameterKeyMatchResults> = {
  encode(message: ToolParameterKeyMatchResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.toolParameterKeyMatchMetricValues) {
      ToolParameterKeyMatchMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKeyMatchResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKeyMatchResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolParameterKeyMatchMetricValues.push(
            ToolParameterKeyMatchMetricValue.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKeyMatchResults {
    return {
      toolParameterKeyMatchMetricValues: globalThis.Array.isArray(object?.toolParameterKeyMatchMetricValues)
        ? object.toolParameterKeyMatchMetricValues.map((e: any) => ToolParameterKeyMatchMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolParameterKeyMatchResults): unknown {
    const obj: any = {};
    if (message.toolParameterKeyMatchMetricValues?.length) {
      obj.toolParameterKeyMatchMetricValues = message.toolParameterKeyMatchMetricValues.map((e) =>
        ToolParameterKeyMatchMetricValue.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKeyMatchResults>): ToolParameterKeyMatchResults {
    return ToolParameterKeyMatchResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKeyMatchResults>): ToolParameterKeyMatchResults {
    const message = createBaseToolParameterKeyMatchResults();
    message.toolParameterKeyMatchMetricValues =
      object.toolParameterKeyMatchMetricValues?.map((e) => ToolParameterKeyMatchMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolParameterKeyMatchMetricValue(): ToolParameterKeyMatchMetricValue {
  return { score: undefined };
}

export const ToolParameterKeyMatchMetricValue: MessageFns<ToolParameterKeyMatchMetricValue> = {
  encode(message: ToolParameterKeyMatchMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKeyMatchMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKeyMatchMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKeyMatchMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: ToolParameterKeyMatchMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKeyMatchMetricValue>): ToolParameterKeyMatchMetricValue {
    return ToolParameterKeyMatchMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKeyMatchMetricValue>): ToolParameterKeyMatchMetricValue {
    const message = createBaseToolParameterKeyMatchMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

function createBaseToolParameterKVMatchInput(): ToolParameterKVMatchInput {
  return { metricSpec: undefined, instances: [] };
}

export const ToolParameterKVMatchInput: MessageFns<ToolParameterKVMatchInput> = {
  encode(message: ToolParameterKVMatchInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricSpec !== undefined) {
      ToolParameterKVMatchSpec.encode(message.metricSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.instances) {
      ToolParameterKVMatchInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKVMatchInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKVMatchInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricSpec = ToolParameterKVMatchSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(ToolParameterKVMatchInstance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKVMatchInput {
    return {
      metricSpec: isSet(object.metricSpec) ? ToolParameterKVMatchSpec.fromJSON(object.metricSpec) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => ToolParameterKVMatchInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolParameterKVMatchInput): unknown {
    const obj: any = {};
    if (message.metricSpec !== undefined) {
      obj.metricSpec = ToolParameterKVMatchSpec.toJSON(message.metricSpec);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => ToolParameterKVMatchInstance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKVMatchInput>): ToolParameterKVMatchInput {
    return ToolParameterKVMatchInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKVMatchInput>): ToolParameterKVMatchInput {
    const message = createBaseToolParameterKVMatchInput();
    message.metricSpec = (object.metricSpec !== undefined && object.metricSpec !== null)
      ? ToolParameterKVMatchSpec.fromPartial(object.metricSpec)
      : undefined;
    message.instances = object.instances?.map((e) => ToolParameterKVMatchInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolParameterKVMatchSpec(): ToolParameterKVMatchSpec {
  return { useStrictStringMatch: false };
}

export const ToolParameterKVMatchSpec: MessageFns<ToolParameterKVMatchSpec> = {
  encode(message: ToolParameterKVMatchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useStrictStringMatch !== false) {
      writer.uint32(8).bool(message.useStrictStringMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKVMatchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKVMatchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useStrictStringMatch = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKVMatchSpec {
    return {
      useStrictStringMatch: isSet(object.useStrictStringMatch)
        ? globalThis.Boolean(object.useStrictStringMatch)
        : false,
    };
  },

  toJSON(message: ToolParameterKVMatchSpec): unknown {
    const obj: any = {};
    if (message.useStrictStringMatch !== false) {
      obj.useStrictStringMatch = message.useStrictStringMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKVMatchSpec>): ToolParameterKVMatchSpec {
    return ToolParameterKVMatchSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKVMatchSpec>): ToolParameterKVMatchSpec {
    const message = createBaseToolParameterKVMatchSpec();
    message.useStrictStringMatch = object.useStrictStringMatch ?? false;
    return message;
  },
};

function createBaseToolParameterKVMatchInstance(): ToolParameterKVMatchInstance {
  return { prediction: undefined, reference: undefined };
}

export const ToolParameterKVMatchInstance: MessageFns<ToolParameterKVMatchInstance> = {
  encode(message: ToolParameterKVMatchInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prediction !== undefined) {
      writer.uint32(10).string(message.prediction);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKVMatchInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKVMatchInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prediction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKVMatchInstance {
    return {
      prediction: isSet(object.prediction) ? globalThis.String(object.prediction) : undefined,
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
    };
  },

  toJSON(message: ToolParameterKVMatchInstance): unknown {
    const obj: any = {};
    if (message.prediction !== undefined) {
      obj.prediction = message.prediction;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKVMatchInstance>): ToolParameterKVMatchInstance {
    return ToolParameterKVMatchInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKVMatchInstance>): ToolParameterKVMatchInstance {
    const message = createBaseToolParameterKVMatchInstance();
    message.prediction = object.prediction ?? undefined;
    message.reference = object.reference ?? undefined;
    return message;
  },
};

function createBaseToolParameterKVMatchResults(): ToolParameterKVMatchResults {
  return { toolParameterKvMatchMetricValues: [] };
}

export const ToolParameterKVMatchResults: MessageFns<ToolParameterKVMatchResults> = {
  encode(message: ToolParameterKVMatchResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.toolParameterKvMatchMetricValues) {
      ToolParameterKVMatchMetricValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKVMatchResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKVMatchResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolParameterKvMatchMetricValues.push(
            ToolParameterKVMatchMetricValue.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKVMatchResults {
    return {
      toolParameterKvMatchMetricValues: globalThis.Array.isArray(object?.toolParameterKvMatchMetricValues)
        ? object.toolParameterKvMatchMetricValues.map((e: any) => ToolParameterKVMatchMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ToolParameterKVMatchResults): unknown {
    const obj: any = {};
    if (message.toolParameterKvMatchMetricValues?.length) {
      obj.toolParameterKvMatchMetricValues = message.toolParameterKvMatchMetricValues.map((e) =>
        ToolParameterKVMatchMetricValue.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKVMatchResults>): ToolParameterKVMatchResults {
    return ToolParameterKVMatchResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKVMatchResults>): ToolParameterKVMatchResults {
    const message = createBaseToolParameterKVMatchResults();
    message.toolParameterKvMatchMetricValues =
      object.toolParameterKvMatchMetricValues?.map((e) => ToolParameterKVMatchMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolParameterKVMatchMetricValue(): ToolParameterKVMatchMetricValue {
  return { score: undefined };
}

export const ToolParameterKVMatchMetricValue: MessageFns<ToolParameterKVMatchMetricValue> = {
  encode(message: ToolParameterKVMatchMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolParameterKVMatchMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolParameterKVMatchMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolParameterKVMatchMetricValue {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : undefined };
  },

  toJSON(message: ToolParameterKVMatchMetricValue): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolParameterKVMatchMetricValue>): ToolParameterKVMatchMetricValue {
    return ToolParameterKVMatchMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolParameterKVMatchMetricValue>): ToolParameterKVMatchMetricValue {
    const message = createBaseToolParameterKVMatchMetricValue();
    message.score = object.score ?? undefined;
    return message;
  },
};

/** Vertex AI Online Evaluation Service. */
export type EvaluationServiceDefinition = typeof EvaluationServiceDefinition;
export const EvaluationServiceDefinition = {
  name: "EvaluationService",
  fullName: "google.cloud.aiplatform.v1.EvaluationService",
  methods: {
    /** Evaluates instances based on a given metric. */
    evaluateInstances: {
      name: "EvaluateInstances",
      requestType: EvaluateInstancesRequest,
      requestStream: false,
      responseType: EvaluateInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              101,
              118,
              97,
              108,
              117,
              97,
              116,
              101,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface EvaluationServiceImplementation<CallContextExt = {}> {
  /** Evaluates instances based on a given metric. */
  evaluateInstances(
    request: EvaluateInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EvaluateInstancesResponse>>;
}

export interface EvaluationServiceClient<CallOptionsExt = {}> {
  /** Evaluates instances based on a given metric. */
  evaluateInstances(
    request: DeepPartial<EvaluateInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EvaluateInstancesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
