// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/tool.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";
import { Schema } from "./openapi.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * Tool details that the model may use to generate response.
 *
 * A `Tool` is a piece of code that enables the system to interact with
 * external systems to perform an action, or set of actions, outside of
 * knowledge and scope of the model. A Tool object should contain exactly
 * one type of Tool (e.g FunctionDeclaration, Retrieval or
 * GoogleSearchRetrieval).
 */
export interface Tool {
  /**
   * Optional. Function tool type.
   * One or more function declarations to be passed to the model along with the
   * current user query. Model may decide to call a subset of these functions
   * by populating [FunctionCall][content.part.function_call] in the response.
   * User should provide a [FunctionResponse][content.part.function_response]
   * for each function call in the next turn. Based on the function responses,
   * Model will generate the final response back to the user.
   * Maximum 64 function declarations can be provided.
   */
  functionDeclarations: FunctionDeclaration[];
  /**
   * Optional. Retrieval tool type.
   * System will always execute the provided retrieval tool(s) to get external
   * knowledge to answer the prompt. Retrieval results are presented to the
   * model for generation.
   */
  retrieval:
    | Retrieval
    | undefined;
  /**
   * Optional. GoogleSearchRetrieval tool type.
   * Specialized retrieval tool that is powered by Google search.
   */
  googleSearchRetrieval: GoogleSearchRetrieval | undefined;
}

/**
 * Structured representation of a function declaration as defined by the
 * [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
 * in this declaration are the function name and parameters. This
 * FunctionDeclaration is a representation of a block of code that can be used
 * as a `Tool` by the model and executed by the client.
 */
export interface FunctionDeclaration {
  /**
   * Required. The name of the function to call.
   * Must start with a letter or an underscore.
   * Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
   * maximum length of 64.
   */
  name: string;
  /**
   * Optional. Description and purpose of the function.
   * Model uses it to decide how and whether to call the function.
   */
  description: string;
  /**
   * Optional. Describes the parameters to this function in JSON Schema Object
   * format. Reflects the Open API 3.03 Parameter Object. string Key: the name
   * of the parameter. Parameter names are case sensitive. Schema Value: the
   * Schema defining the type used for the parameter. For function with no
   * parameters, this can be left unset. Parameter names must start with a
   * letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
   * underscores with a maximum length of 64. Example with 1 required and 1
   * optional parameter: type: OBJECT properties:
   *  param1:
   *    type: STRING
   *  param2:
   *    type: INTEGER
   * required:
   *  - param1
   */
  parameters: Schema | undefined;
}

/**
 * A predicted [FunctionCall] returned from the model that contains a string
 * representing the [FunctionDeclaration.name] and a structured JSON object
 * containing the parameters and their values.
 */
export interface FunctionCall {
  /**
   * Required. The name of the function to call.
   * Matches [FunctionDeclaration.name].
   */
  name: string;
  /**
   * Optional. Required. The function parameters and values in JSON object
   * format. See [FunctionDeclaration.parameters] for parameter details.
   */
  args: { [key: string]: any } | undefined;
}

/**
 * The result output from a [FunctionCall] that contains a string representing
 * the [FunctionDeclaration.name] and a structured JSON object containing any
 * output from the function is used as context to the model. This should contain
 * the result of a [FunctionCall] made based on model prediction.
 */
export interface FunctionResponse {
  /**
   * Required. The name of the function to call.
   * Matches [FunctionDeclaration.name] and [FunctionCall.name].
   */
  name: string;
  /** Required. The function response in JSON object format. */
  response: { [key: string]: any } | undefined;
}

/** Defines a retrieval tool that model can call to access external knowledge. */
export interface Retrieval {
  /** Set to use data source powered by Vertex AI Search. */
  vertexAiSearch?:
    | VertexAISearch
    | undefined;
  /**
   * Optional. Deprecated. This option is no longer supported.
   *
   * @deprecated
   */
  disableAttribution: boolean;
}

/**
 * Retrieve from Vertex AI Search datastore for grounding.
 * See https://cloud.google.com/vertex-ai-search-and-conversation
 */
export interface VertexAISearch {
  /**
   * Required. Fully-qualified Vertex AI Search's datastore resource ID.
   * Format:
   * `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
   */
  datastore: string;
}

/** Tool to retrieve public web data for grounding, powered by Google. */
export interface GoogleSearchRetrieval {
}

/** Tool config. This config is shared for all tools provided in the request. */
export interface ToolConfig {
  /** Optional. Function calling config. */
  functionCallingConfig: FunctionCallingConfig | undefined;
}

/** Function calling config. */
export interface FunctionCallingConfig {
  /** Optional. Function calling mode. */
  mode: FunctionCallingConfig_Mode;
  /**
   * Optional. Function names to call. Only set when the Mode is ANY. Function
   * names should match [FunctionDeclaration.name]. With mode set to ANY, model
   * will predict a function call from the set of function names provided.
   */
  allowedFunctionNames: string[];
}

/** Function calling mode. */
export enum FunctionCallingConfig_Mode {
  /** MODE_UNSPECIFIED - Unspecified function calling mode. This value should not be used. */
  MODE_UNSPECIFIED = 0,
  /**
   * AUTO - Default model behavior, model decides to predict either a function call
   * or a natural language response.
   */
  AUTO = 1,
  /**
   * ANY - Model is constrained to always predicting a function call only.
   * If "allowed_function_names" are set, the predicted function call will be
   * limited to any one of "allowed_function_names", else the predicted
   * function call will be any one of the provided "function_declarations".
   */
  ANY = 2,
  /**
   * NONE - Model will not predict any function call. Model behavior is same as when
   * not passing any function declarations.
   */
  NONE = 3,
  UNRECOGNIZED = -1,
}

export function functionCallingConfig_ModeFromJSON(object: any): FunctionCallingConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return FunctionCallingConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "AUTO":
      return FunctionCallingConfig_Mode.AUTO;
    case 2:
    case "ANY":
      return FunctionCallingConfig_Mode.ANY;
    case 3:
    case "NONE":
      return FunctionCallingConfig_Mode.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FunctionCallingConfig_Mode.UNRECOGNIZED;
  }
}

export function functionCallingConfig_ModeToJSON(object: FunctionCallingConfig_Mode): string {
  switch (object) {
    case FunctionCallingConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case FunctionCallingConfig_Mode.AUTO:
      return "AUTO";
    case FunctionCallingConfig_Mode.ANY:
      return "ANY";
    case FunctionCallingConfig_Mode.NONE:
      return "NONE";
    case FunctionCallingConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseTool(): Tool {
  return { functionDeclarations: [], retrieval: undefined, googleSearchRetrieval: undefined };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.functionDeclarations) {
      FunctionDeclaration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.retrieval !== undefined) {
      Retrieval.encode(message.retrieval, writer.uint32(18).fork()).join();
    }
    if (message.googleSearchRetrieval !== undefined) {
      GoogleSearchRetrieval.encode(message.googleSearchRetrieval, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionDeclarations.push(FunctionDeclaration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retrieval = Retrieval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.googleSearchRetrieval = GoogleSearchRetrieval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      functionDeclarations: globalThis.Array.isArray(object?.functionDeclarations)
        ? object.functionDeclarations.map((e: any) => FunctionDeclaration.fromJSON(e))
        : [],
      retrieval: isSet(object.retrieval) ? Retrieval.fromJSON(object.retrieval) : undefined,
      googleSearchRetrieval: isSet(object.googleSearchRetrieval)
        ? GoogleSearchRetrieval.fromJSON(object.googleSearchRetrieval)
        : undefined,
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.functionDeclarations?.length) {
      obj.functionDeclarations = message.functionDeclarations.map((e) => FunctionDeclaration.toJSON(e));
    }
    if (message.retrieval !== undefined) {
      obj.retrieval = Retrieval.toJSON(message.retrieval);
    }
    if (message.googleSearchRetrieval !== undefined) {
      obj.googleSearchRetrieval = GoogleSearchRetrieval.toJSON(message.googleSearchRetrieval);
    }
    return obj;
  },

  create(base?: DeepPartial<Tool>): Tool {
    return Tool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tool>): Tool {
    const message = createBaseTool();
    message.functionDeclarations = object.functionDeclarations?.map((e) => FunctionDeclaration.fromPartial(e)) || [];
    message.retrieval = (object.retrieval !== undefined && object.retrieval !== null)
      ? Retrieval.fromPartial(object.retrieval)
      : undefined;
    message.googleSearchRetrieval =
      (object.googleSearchRetrieval !== undefined && object.googleSearchRetrieval !== null)
        ? GoogleSearchRetrieval.fromPartial(object.googleSearchRetrieval)
        : undefined;
    return message;
  },
};

function createBaseFunctionDeclaration(): FunctionDeclaration {
  return { name: "", description: "", parameters: undefined };
}

export const FunctionDeclaration: MessageFns<FunctionDeclaration> = {
  encode(message: FunctionDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parameters !== undefined) {
      Schema.encode(message.parameters, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parameters = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDeclaration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isSet(object.parameters) ? Schema.fromJSON(object.parameters) : undefined,
    };
  },

  toJSON(message: FunctionDeclaration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters !== undefined) {
      obj.parameters = Schema.toJSON(message.parameters);
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    return FunctionDeclaration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    const message = createBaseFunctionDeclaration();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? Schema.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { name: "", args: undefined };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(message: FunctionCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== undefined) {
      Struct.encode(Struct.wrap(message.args), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isObject(object.args) ? object.args : undefined,
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== undefined) {
      obj.args = message.args;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall();
    message.name = object.name ?? "";
    message.args = object.args ?? undefined;
    return message;
  },
};

function createBaseFunctionResponse(): FunctionResponse {
  return { name: "", response: undefined };
}

export const FunctionResponse: MessageFns<FunctionResponse> = {
  encode(message: FunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.response !== undefined) {
      Struct.encode(Struct.wrap(message.response), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      response: isObject(object.response) ? object.response : undefined,
    };
  },

  toJSON(message: FunctionResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionResponse>): FunctionResponse {
    return FunctionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionResponse>): FunctionResponse {
    const message = createBaseFunctionResponse();
    message.name = object.name ?? "";
    message.response = object.response ?? undefined;
    return message;
  },
};

function createBaseRetrieval(): Retrieval {
  return { vertexAiSearch: undefined, disableAttribution: false };
}

export const Retrieval: MessageFns<Retrieval> = {
  encode(message: Retrieval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vertexAiSearch !== undefined) {
      VertexAISearch.encode(message.vertexAiSearch, writer.uint32(18).fork()).join();
    }
    if (message.disableAttribution !== false) {
      writer.uint32(24).bool(message.disableAttribution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Retrieval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vertexAiSearch = VertexAISearch.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.disableAttribution = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Retrieval {
    return {
      vertexAiSearch: isSet(object.vertexAiSearch) ? VertexAISearch.fromJSON(object.vertexAiSearch) : undefined,
      disableAttribution: isSet(object.disableAttribution) ? globalThis.Boolean(object.disableAttribution) : false,
    };
  },

  toJSON(message: Retrieval): unknown {
    const obj: any = {};
    if (message.vertexAiSearch !== undefined) {
      obj.vertexAiSearch = VertexAISearch.toJSON(message.vertexAiSearch);
    }
    if (message.disableAttribution !== false) {
      obj.disableAttribution = message.disableAttribution;
    }
    return obj;
  },

  create(base?: DeepPartial<Retrieval>): Retrieval {
    return Retrieval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Retrieval>): Retrieval {
    const message = createBaseRetrieval();
    message.vertexAiSearch = (object.vertexAiSearch !== undefined && object.vertexAiSearch !== null)
      ? VertexAISearch.fromPartial(object.vertexAiSearch)
      : undefined;
    message.disableAttribution = object.disableAttribution ?? false;
    return message;
  },
};

function createBaseVertexAISearch(): VertexAISearch {
  return { datastore: "" };
}

export const VertexAISearch: MessageFns<VertexAISearch> = {
  encode(message: VertexAISearch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datastore !== "") {
      writer.uint32(10).string(message.datastore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAISearch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAISearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datastore = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAISearch {
    return { datastore: isSet(object.datastore) ? globalThis.String(object.datastore) : "" };
  },

  toJSON(message: VertexAISearch): unknown {
    const obj: any = {};
    if (message.datastore !== "") {
      obj.datastore = message.datastore;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexAISearch>): VertexAISearch {
    return VertexAISearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexAISearch>): VertexAISearch {
    const message = createBaseVertexAISearch();
    message.datastore = object.datastore ?? "";
    return message;
  },
};

function createBaseGoogleSearchRetrieval(): GoogleSearchRetrieval {
  return {};
}

export const GoogleSearchRetrieval: MessageFns<GoogleSearchRetrieval> = {
  encode(_: GoogleSearchRetrieval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleSearchRetrieval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleSearchRetrieval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GoogleSearchRetrieval {
    return {};
  },

  toJSON(_: GoogleSearchRetrieval): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    return GoogleSearchRetrieval.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    const message = createBaseGoogleSearchRetrieval();
    return message;
  },
};

function createBaseToolConfig(): ToolConfig {
  return { functionCallingConfig: undefined };
}

export const ToolConfig: MessageFns<ToolConfig> = {
  encode(message: ToolConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionCallingConfig !== undefined) {
      FunctionCallingConfig.encode(message.functionCallingConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionCallingConfig = FunctionCallingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolConfig {
    return {
      functionCallingConfig: isSet(object.functionCallingConfig)
        ? FunctionCallingConfig.fromJSON(object.functionCallingConfig)
        : undefined,
    };
  },

  toJSON(message: ToolConfig): unknown {
    const obj: any = {};
    if (message.functionCallingConfig !== undefined) {
      obj.functionCallingConfig = FunctionCallingConfig.toJSON(message.functionCallingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ToolConfig>): ToolConfig {
    return ToolConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolConfig>): ToolConfig {
    const message = createBaseToolConfig();
    message.functionCallingConfig =
      (object.functionCallingConfig !== undefined && object.functionCallingConfig !== null)
        ? FunctionCallingConfig.fromPartial(object.functionCallingConfig)
        : undefined;
    return message;
  },
};

function createBaseFunctionCallingConfig(): FunctionCallingConfig {
  return { mode: 0, allowedFunctionNames: [] };
}

export const FunctionCallingConfig: MessageFns<FunctionCallingConfig> = {
  encode(message: FunctionCallingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    for (const v of message.allowedFunctionNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCallingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedFunctionNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCallingConfig {
    return {
      mode: isSet(object.mode) ? functionCallingConfig_ModeFromJSON(object.mode) : 0,
      allowedFunctionNames: globalThis.Array.isArray(object?.allowedFunctionNames)
        ? object.allowedFunctionNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FunctionCallingConfig): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = functionCallingConfig_ModeToJSON(message.mode);
    }
    if (message.allowedFunctionNames?.length) {
      obj.allowedFunctionNames = message.allowedFunctionNames;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    return FunctionCallingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    const message = createBaseFunctionCallingConfig();
    message.mode = object.mode ?? 0;
    message.allowedFunctionNames = object.allowedFunctionNames?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
