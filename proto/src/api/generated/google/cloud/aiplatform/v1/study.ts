// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/study.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue, Int32Value } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/** A message representing a Study. */
export interface Study {
  /**
   * Output only. The name of a study. The study's globally unique identifier.
   * Format: `projects/{project}/locations/{location}/studies/{study}`
   */
  name: string;
  /** Required. Describes the Study, default value is empty string. */
  displayName: string;
  /** Required. Configuration of the Study. */
  studySpec:
    | StudySpec
    | undefined;
  /** Output only. The detailed state of a Study. */
  state: Study_State;
  /** Output only. Time at which the study was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. A human readable reason why the Study is inactive.
   * This should be empty if a study is ACTIVE or COMPLETED.
   */
  inactiveReason: string;
}

/** Describes the Study state. */
export enum Study_State {
  /** STATE_UNSPECIFIED - The study state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The study is active. */
  ACTIVE = 1,
  /** INACTIVE - The study is stopped due to an internal error. */
  INACTIVE = 2,
  /**
   * COMPLETED - The study is done when the service exhausts the parameter search space
   * or max_trial_count is reached.
   */
  COMPLETED = 3,
  UNRECOGNIZED = -1,
}

export function study_StateFromJSON(object: any): Study_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Study_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Study_State.ACTIVE;
    case 2:
    case "INACTIVE":
      return Study_State.INACTIVE;
    case 3:
    case "COMPLETED":
      return Study_State.COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Study_State.UNRECOGNIZED;
  }
}

export function study_StateToJSON(object: Study_State): string {
  switch (object) {
    case Study_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Study_State.ACTIVE:
      return "ACTIVE";
    case Study_State.INACTIVE:
      return "INACTIVE";
    case Study_State.COMPLETED:
      return "COMPLETED";
    case Study_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A message representing a Trial. A Trial contains a unique set of Parameters
 * that has been or will be evaluated, along with the objective metrics got by
 * running the Trial.
 */
export interface Trial {
  /** Output only. Resource name of the Trial assigned by the service. */
  name: string;
  /** Output only. The identifier of the Trial assigned by the service. */
  id: string;
  /** Output only. The detailed state of the Trial. */
  state: Trial_State;
  /** Output only. The parameters of the Trial. */
  parameters: Trial_Parameter[];
  /** Output only. The final measurement containing the objective value. */
  finalMeasurement:
    | Measurement
    | undefined;
  /**
   * Output only. A list of measurements that are strictly lexicographically
   * ordered by their induced tuples (steps, elapsed_duration).
   * These are used for early stopping computations.
   */
  measurements: Measurement[];
  /** Output only. Time when the Trial was started. */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the Trial's status changed to `SUCCEEDED` or
   * `INFEASIBLE`.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Output only. The identifier of the client that originally requested this
   * Trial. Each client is identified by a unique client_id. When a client asks
   * for a suggestion, Vertex AI Vizier will assign it a Trial. The client
   * should evaluate the Trial, complete it, and report back to Vertex AI
   * Vizier. If suggestion is asked again by same client_id before the Trial is
   * completed, the same Trial will be returned. Multiple clients with
   * different client_ids can ask for suggestions simultaneously, each of them
   * will get their own Trial.
   */
  clientId: string;
  /**
   * Output only. A human readable string describing why the Trial is
   * infeasible. This is set only if Trial state is `INFEASIBLE`.
   */
  infeasibleReason: string;
  /**
   * Output only. The CustomJob name linked to the Trial.
   * It's set for a HyperparameterTuningJob's Trial.
   */
  customJob: string;
  /**
   * Output only. URIs for accessing [interactive
   * shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
   * (one URI for each training node). Only available if this trial is part of
   * a
   * [HyperparameterTuningJob][google.cloud.aiplatform.v1.HyperparameterTuningJob]
   * and the job's
   * [trial_job_spec.enable_web_access][google.cloud.aiplatform.v1.CustomJobSpec.enable_web_access]
   * field is `true`.
   *
   * The keys are names of each node used for the trial; for example,
   * `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
   * the second worker pool, and `workerpool1-1` for the second node in the
   * second worker pool.
   *
   * The values are the URIs for each node's interactive shell.
   */
  webAccessUris: { [key: string]: string };
}

/** Describes a Trial state. */
export enum Trial_State {
  /** STATE_UNSPECIFIED - The Trial state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * REQUESTED - Indicates that a specific Trial has been requested, but it has not yet
   * been suggested by the service.
   */
  REQUESTED = 1,
  /** ACTIVE - Indicates that the Trial has been suggested. */
  ACTIVE = 2,
  /** STOPPING - Indicates that the Trial should stop according to the service. */
  STOPPING = 3,
  /** SUCCEEDED - Indicates that the Trial is completed successfully. */
  SUCCEEDED = 4,
  /**
   * INFEASIBLE - Indicates that the Trial should not be attempted again.
   * The service will set a Trial to INFEASIBLE when it's done but missing
   * the final_measurement.
   */
  INFEASIBLE = 5,
  UNRECOGNIZED = -1,
}

export function trial_StateFromJSON(object: any): Trial_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Trial_State.STATE_UNSPECIFIED;
    case 1:
    case "REQUESTED":
      return Trial_State.REQUESTED;
    case 2:
    case "ACTIVE":
      return Trial_State.ACTIVE;
    case 3:
    case "STOPPING":
      return Trial_State.STOPPING;
    case 4:
    case "SUCCEEDED":
      return Trial_State.SUCCEEDED;
    case 5:
    case "INFEASIBLE":
      return Trial_State.INFEASIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trial_State.UNRECOGNIZED;
  }
}

export function trial_StateToJSON(object: Trial_State): string {
  switch (object) {
    case Trial_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Trial_State.REQUESTED:
      return "REQUESTED";
    case Trial_State.ACTIVE:
      return "ACTIVE";
    case Trial_State.STOPPING:
      return "STOPPING";
    case Trial_State.SUCCEEDED:
      return "SUCCEEDED";
    case Trial_State.INFEASIBLE:
      return "INFEASIBLE";
    case Trial_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A message representing a parameter to be tuned. */
export interface Trial_Parameter {
  /**
   * Output only. The ID of the parameter. The parameter should be defined in
   * [StudySpec's
   * Parameters][google.cloud.aiplatform.v1.StudySpec.parameters].
   */
  parameterId: string;
  /**
   * Output only. The value of the parameter.
   * `number_value` will be set if a parameter defined in StudySpec is
   * in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
   * `string_value` will be set if a parameter defined in StudySpec is
   * in type 'CATEGORICAL'.
   */
  value: any | undefined;
}

export interface Trial_WebAccessUrisEntry {
  key: string;
  value: string;
}

export interface TrialContext {
  /**
   * A human-readable field which can store a description of this context.
   * This will become part of the resulting Trial's description field.
   */
  description: string;
  /**
   * If/when a Trial is generated or selected from this Context,
   * its Parameters will match any parameters specified here.
   * (I.e. if this context specifies parameter name:'a' int_value:3,
   * then a resulting Trial will have int_value:3 for its parameter named
   * 'a'.) Note that we first attempt to match existing REQUESTED Trials with
   * contexts, and if there are no matches, we generate suggestions in the
   * subspace defined by the parameters specified here.
   * NOTE: a Context without any Parameters matches the entire feasible search
   *   space.
   */
  parameters: Trial_Parameter[];
}

/** Time-based Constraint for Study */
export interface StudyTimeConstraint {
  /** Counts the wallclock time passed since the creation of this Study. */
  maxDuration?:
    | Duration
    | undefined;
  /** Compares the wallclock time to this time. Must use UTC timezone. */
  endTime?: Date | undefined;
}

/** Represents specification of a Study. */
export interface StudySpec {
  /** The automated early stopping spec using decay curve rule. */
  decayCurveStoppingSpec?:
    | StudySpec_DecayCurveAutomatedStoppingSpec
    | undefined;
  /** The automated early stopping spec using median rule. */
  medianAutomatedStoppingSpec?:
    | StudySpec_MedianAutomatedStoppingSpec
    | undefined;
  /** The automated early stopping spec using convex stopping rule. */
  convexAutomatedStoppingSpec?:
    | StudySpec_ConvexAutomatedStoppingSpec
    | undefined;
  /** Required. Metric specs for the Study. */
  metrics: StudySpec_MetricSpec[];
  /** Required. The set of parameters to tune. */
  parameters: StudySpec_ParameterSpec[];
  /** The search algorithm specified for the Study. */
  algorithm: StudySpec_Algorithm;
  /**
   * The observation noise level of the study.
   * Currently only supported by the Vertex AI Vizier service. Not supported by
   * HyperparameterTuningJob or TrainingPipeline.
   */
  observationNoise: StudySpec_ObservationNoise;
  /** Describe which measurement selection type will be used */
  measurementSelectionType: StudySpec_MeasurementSelectionType;
  /**
   * Conditions for automated stopping of a Study. Enable automated stopping by
   * configuring at least one condition.
   */
  studyStoppingConfig?: StudySpec_StudyStoppingConfig | undefined;
}

/** The available search algorithms for the Study. */
export enum StudySpec_Algorithm {
  /**
   * ALGORITHM_UNSPECIFIED - The default algorithm used by Vertex AI for [hyperparameter
   * tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
   * and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
   */
  ALGORITHM_UNSPECIFIED = 0,
  /**
   * GRID_SEARCH - Simple grid search within the feasible space. To use grid search,
   * all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
   */
  GRID_SEARCH = 2,
  /** RANDOM_SEARCH - Simple random search within the feasible space. */
  RANDOM_SEARCH = 3,
  UNRECOGNIZED = -1,
}

export function studySpec_AlgorithmFromJSON(object: any): StudySpec_Algorithm {
  switch (object) {
    case 0:
    case "ALGORITHM_UNSPECIFIED":
      return StudySpec_Algorithm.ALGORITHM_UNSPECIFIED;
    case 2:
    case "GRID_SEARCH":
      return StudySpec_Algorithm.GRID_SEARCH;
    case 3:
    case "RANDOM_SEARCH":
      return StudySpec_Algorithm.RANDOM_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StudySpec_Algorithm.UNRECOGNIZED;
  }
}

export function studySpec_AlgorithmToJSON(object: StudySpec_Algorithm): string {
  switch (object) {
    case StudySpec_Algorithm.ALGORITHM_UNSPECIFIED:
      return "ALGORITHM_UNSPECIFIED";
    case StudySpec_Algorithm.GRID_SEARCH:
      return "GRID_SEARCH";
    case StudySpec_Algorithm.RANDOM_SEARCH:
      return "RANDOM_SEARCH";
    case StudySpec_Algorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes the noise level of the repeated observations.
 *
 * "Noisy" means that the repeated observations with the same Trial parameters
 * may lead to different metric evaluations.
 */
export enum StudySpec_ObservationNoise {
  /** OBSERVATION_NOISE_UNSPECIFIED - The default noise level chosen by Vertex AI. */
  OBSERVATION_NOISE_UNSPECIFIED = 0,
  /**
   * LOW - Vertex AI assumes that the objective function is (nearly)
   * perfectly reproducible, and will never repeat the same Trial
   * parameters.
   */
  LOW = 1,
  /**
   * HIGH - Vertex AI will estimate the amount of noise in metric
   * evaluations, it may repeat the same Trial parameters more than once.
   */
  HIGH = 2,
  UNRECOGNIZED = -1,
}

export function studySpec_ObservationNoiseFromJSON(object: any): StudySpec_ObservationNoise {
  switch (object) {
    case 0:
    case "OBSERVATION_NOISE_UNSPECIFIED":
      return StudySpec_ObservationNoise.OBSERVATION_NOISE_UNSPECIFIED;
    case 1:
    case "LOW":
      return StudySpec_ObservationNoise.LOW;
    case 2:
    case "HIGH":
      return StudySpec_ObservationNoise.HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StudySpec_ObservationNoise.UNRECOGNIZED;
  }
}

export function studySpec_ObservationNoiseToJSON(object: StudySpec_ObservationNoise): string {
  switch (object) {
    case StudySpec_ObservationNoise.OBSERVATION_NOISE_UNSPECIFIED:
      return "OBSERVATION_NOISE_UNSPECIFIED";
    case StudySpec_ObservationNoise.LOW:
      return "LOW";
    case StudySpec_ObservationNoise.HIGH:
      return "HIGH";
    case StudySpec_ObservationNoise.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This indicates which measurement to use if/when the service automatically
 * selects the final measurement from previously reported intermediate
 * measurements. Choose this based on two considerations:
 *  A) Do you expect your measurements to monotonically improve?
 *     If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
 *     situation where your system can "over-train" and you expect the
 *     performance to get better for a while but then start declining,
 *     choose BEST_MEASUREMENT.
 *  B) Are your measurements significantly noisy and/or irreproducible?
 *     If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
 *     may be better to choose LAST_MEASUREMENT.
 *  If both or neither of (A) and (B) apply, it doesn't matter which
 *  selection type is chosen.
 */
export enum StudySpec_MeasurementSelectionType {
  /** MEASUREMENT_SELECTION_TYPE_UNSPECIFIED - Will be treated as LAST_MEASUREMENT. */
  MEASUREMENT_SELECTION_TYPE_UNSPECIFIED = 0,
  /** LAST_MEASUREMENT - Use the last measurement reported. */
  LAST_MEASUREMENT = 1,
  /** BEST_MEASUREMENT - Use the best measurement reported. */
  BEST_MEASUREMENT = 2,
  UNRECOGNIZED = -1,
}

export function studySpec_MeasurementSelectionTypeFromJSON(object: any): StudySpec_MeasurementSelectionType {
  switch (object) {
    case 0:
    case "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED":
      return StudySpec_MeasurementSelectionType.MEASUREMENT_SELECTION_TYPE_UNSPECIFIED;
    case 1:
    case "LAST_MEASUREMENT":
      return StudySpec_MeasurementSelectionType.LAST_MEASUREMENT;
    case 2:
    case "BEST_MEASUREMENT":
      return StudySpec_MeasurementSelectionType.BEST_MEASUREMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StudySpec_MeasurementSelectionType.UNRECOGNIZED;
  }
}

export function studySpec_MeasurementSelectionTypeToJSON(object: StudySpec_MeasurementSelectionType): string {
  switch (object) {
    case StudySpec_MeasurementSelectionType.MEASUREMENT_SELECTION_TYPE_UNSPECIFIED:
      return "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED";
    case StudySpec_MeasurementSelectionType.LAST_MEASUREMENT:
      return "LAST_MEASUREMENT";
    case StudySpec_MeasurementSelectionType.BEST_MEASUREMENT:
      return "BEST_MEASUREMENT";
    case StudySpec_MeasurementSelectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a metric to optimize. */
export interface StudySpec_MetricSpec {
  /**
   * Required. The ID of the metric. Must not contain whitespaces and must be
   * unique amongst all MetricSpecs.
   */
  metricId: string;
  /** Required. The optimization goal of the metric. */
  goal: StudySpec_MetricSpec_GoalType;
  /**
   * Used for safe search. In the case, the metric will be a safety
   * metric. You must provide a separate metric for objective metric.
   */
  safetyConfig?: StudySpec_MetricSpec_SafetyMetricConfig | undefined;
}

/** The available types of optimization goals. */
export enum StudySpec_MetricSpec_GoalType {
  /** GOAL_TYPE_UNSPECIFIED - Goal Type will default to maximize. */
  GOAL_TYPE_UNSPECIFIED = 0,
  /** MAXIMIZE - Maximize the goal metric. */
  MAXIMIZE = 1,
  /** MINIMIZE - Minimize the goal metric. */
  MINIMIZE = 2,
  UNRECOGNIZED = -1,
}

export function studySpec_MetricSpec_GoalTypeFromJSON(object: any): StudySpec_MetricSpec_GoalType {
  switch (object) {
    case 0:
    case "GOAL_TYPE_UNSPECIFIED":
      return StudySpec_MetricSpec_GoalType.GOAL_TYPE_UNSPECIFIED;
    case 1:
    case "MAXIMIZE":
      return StudySpec_MetricSpec_GoalType.MAXIMIZE;
    case 2:
    case "MINIMIZE":
      return StudySpec_MetricSpec_GoalType.MINIMIZE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StudySpec_MetricSpec_GoalType.UNRECOGNIZED;
  }
}

export function studySpec_MetricSpec_GoalTypeToJSON(object: StudySpec_MetricSpec_GoalType): string {
  switch (object) {
    case StudySpec_MetricSpec_GoalType.GOAL_TYPE_UNSPECIFIED:
      return "GOAL_TYPE_UNSPECIFIED";
    case StudySpec_MetricSpec_GoalType.MAXIMIZE:
      return "MAXIMIZE";
    case StudySpec_MetricSpec_GoalType.MINIMIZE:
      return "MINIMIZE";
    case StudySpec_MetricSpec_GoalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Used in safe optimization to specify threshold levels and risk tolerance. */
export interface StudySpec_MetricSpec_SafetyMetricConfig {
  /**
   * Safety threshold (boundary value between safe and unsafe). NOTE that if
   * you leave SafetyMetricConfig unset, a default value of 0 will be used.
   */
  safetyThreshold: number;
  /**
   * Desired minimum fraction of safe trials (over total number of trials)
   * that should be targeted by the algorithm at any time during the
   * study (best effort). This should be between 0.0 and 1.0 and a value of
   * 0.0 means that there is no minimum and an algorithm proceeds without
   * targeting any specific fraction. A value of 1.0 means that the
   * algorithm attempts to only Suggest safe Trials.
   */
  desiredMinSafeTrialsFraction?: number | undefined;
}

/** Represents a single parameter to optimize. */
export interface StudySpec_ParameterSpec {
  /** The value spec for a 'DOUBLE' parameter. */
  doubleValueSpec?:
    | StudySpec_ParameterSpec_DoubleValueSpec
    | undefined;
  /** The value spec for an 'INTEGER' parameter. */
  integerValueSpec?:
    | StudySpec_ParameterSpec_IntegerValueSpec
    | undefined;
  /** The value spec for a 'CATEGORICAL' parameter. */
  categoricalValueSpec?:
    | StudySpec_ParameterSpec_CategoricalValueSpec
    | undefined;
  /** The value spec for a 'DISCRETE' parameter. */
  discreteValueSpec?:
    | StudySpec_ParameterSpec_DiscreteValueSpec
    | undefined;
  /**
   * Required. The ID of the parameter. Must not contain whitespaces and must
   * be unique amongst all ParameterSpecs.
   */
  parameterId: string;
  /**
   * How the parameter should be scaled.
   * Leave unset for `CATEGORICAL` parameters.
   */
  scaleType: StudySpec_ParameterSpec_ScaleType;
  /**
   * A conditional parameter node is active if the parameter's value matches
   * the conditional node's parent_value_condition.
   *
   * If two items in conditional_parameter_specs have the same name, they
   * must have disjoint parent_value_condition.
   */
  conditionalParameterSpecs: StudySpec_ParameterSpec_ConditionalParameterSpec[];
}

/** The type of scaling that should be applied to this parameter. */
export enum StudySpec_ParameterSpec_ScaleType {
  /** SCALE_TYPE_UNSPECIFIED - By default, no scaling is applied. */
  SCALE_TYPE_UNSPECIFIED = 0,
  /** UNIT_LINEAR_SCALE - Scales the feasible space to (0, 1) linearly. */
  UNIT_LINEAR_SCALE = 1,
  /**
   * UNIT_LOG_SCALE - Scales the feasible space logarithmically to (0, 1). The entire
   * feasible space must be strictly positive.
   */
  UNIT_LOG_SCALE = 2,
  /**
   * UNIT_REVERSE_LOG_SCALE - Scales the feasible space "reverse" logarithmically to (0, 1). The
   * result is that values close to the top of the feasible space are spread
   * out more than points near the bottom. The entire feasible space must be
   * strictly positive.
   */
  UNIT_REVERSE_LOG_SCALE = 3,
  UNRECOGNIZED = -1,
}

export function studySpec_ParameterSpec_ScaleTypeFromJSON(object: any): StudySpec_ParameterSpec_ScaleType {
  switch (object) {
    case 0:
    case "SCALE_TYPE_UNSPECIFIED":
      return StudySpec_ParameterSpec_ScaleType.SCALE_TYPE_UNSPECIFIED;
    case 1:
    case "UNIT_LINEAR_SCALE":
      return StudySpec_ParameterSpec_ScaleType.UNIT_LINEAR_SCALE;
    case 2:
    case "UNIT_LOG_SCALE":
      return StudySpec_ParameterSpec_ScaleType.UNIT_LOG_SCALE;
    case 3:
    case "UNIT_REVERSE_LOG_SCALE":
      return StudySpec_ParameterSpec_ScaleType.UNIT_REVERSE_LOG_SCALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StudySpec_ParameterSpec_ScaleType.UNRECOGNIZED;
  }
}

export function studySpec_ParameterSpec_ScaleTypeToJSON(object: StudySpec_ParameterSpec_ScaleType): string {
  switch (object) {
    case StudySpec_ParameterSpec_ScaleType.SCALE_TYPE_UNSPECIFIED:
      return "SCALE_TYPE_UNSPECIFIED";
    case StudySpec_ParameterSpec_ScaleType.UNIT_LINEAR_SCALE:
      return "UNIT_LINEAR_SCALE";
    case StudySpec_ParameterSpec_ScaleType.UNIT_LOG_SCALE:
      return "UNIT_LOG_SCALE";
    case StudySpec_ParameterSpec_ScaleType.UNIT_REVERSE_LOG_SCALE:
      return "UNIT_REVERSE_LOG_SCALE";
    case StudySpec_ParameterSpec_ScaleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Value specification for a parameter in `DOUBLE` type. */
export interface StudySpec_ParameterSpec_DoubleValueSpec {
  /** Required. Inclusive minimum value of the parameter. */
  minValue: number;
  /** Required. Inclusive maximum value of the parameter. */
  maxValue: number;
  /**
   * A default value for a `DOUBLE` parameter that is assumed to be a
   * relatively good starting point.  Unset value signals that there is no
   * offered starting point.
   *
   * Currently only supported by the Vertex AI Vizier service. Not supported
   * by HyperparameterTuningJob or TrainingPipeline.
   */
  defaultValue?: number | undefined;
}

/** Value specification for a parameter in `INTEGER` type. */
export interface StudySpec_ParameterSpec_IntegerValueSpec {
  /** Required. Inclusive minimum value of the parameter. */
  minValue: Long;
  /** Required. Inclusive maximum value of the parameter. */
  maxValue: Long;
  /**
   * A default value for an `INTEGER` parameter that is assumed to be a
   * relatively good starting point.  Unset value signals that there is no
   * offered starting point.
   *
   * Currently only supported by the Vertex AI Vizier service. Not supported
   * by HyperparameterTuningJob or TrainingPipeline.
   */
  defaultValue?: Long | undefined;
}

/** Value specification for a parameter in `CATEGORICAL` type. */
export interface StudySpec_ParameterSpec_CategoricalValueSpec {
  /** Required. The list of possible categories. */
  values: string[];
  /**
   * A default value for a `CATEGORICAL` parameter that is assumed to be a
   * relatively good starting point.  Unset value signals that there is no
   * offered starting point.
   *
   * Currently only supported by the Vertex AI Vizier service. Not supported
   * by HyperparameterTuningJob or TrainingPipeline.
   */
  defaultValue?: string | undefined;
}

/** Value specification for a parameter in `DISCRETE` type. */
export interface StudySpec_ParameterSpec_DiscreteValueSpec {
  /**
   * Required. A list of possible values.
   * The list should be in increasing order and at least 1e-10 apart.
   * For instance, this parameter might have possible settings of 1.5, 2.5,
   * and 4.0. This list should not contain more than 1,000 values.
   */
  values: number[];
  /**
   * A default value for a `DISCRETE` parameter that is assumed to be a
   * relatively good starting point.  Unset value signals that there is no
   * offered starting point.  It automatically rounds to the
   * nearest feasible discrete point.
   *
   * Currently only supported by the Vertex AI Vizier service. Not supported
   * by HyperparameterTuningJob or TrainingPipeline.
   */
  defaultValue?: number | undefined;
}

/** Represents a parameter spec with condition from its parent parameter. */
export interface StudySpec_ParameterSpec_ConditionalParameterSpec {
  /**
   * The spec for matching values from a parent parameter of
   * `DISCRETE` type.
   */
  parentDiscreteValues?:
    | StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition
    | undefined;
  /**
   * The spec for matching values from a parent parameter of `INTEGER`
   * type.
   */
  parentIntValues?:
    | StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition
    | undefined;
  /**
   * The spec for matching values from a parent parameter of
   * `CATEGORICAL` type.
   */
  parentCategoricalValues?:
    | StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
    | undefined;
  /** Required. The spec for a conditional parameter. */
  parameterSpec: StudySpec_ParameterSpec | undefined;
}

/** Represents the spec to match discrete values from parent parameter. */
export interface StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
  /**
   * Required. Matches values of the parent parameter of 'DISCRETE' type.
   * All values must exist in `discrete_value_spec` of parent parameter.
   *
   * The Epsilon of the value matching is 1e-10.
   */
  values: number[];
}

/** Represents the spec to match integer values from parent parameter. */
export interface StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
  /**
   * Required. Matches values of the parent parameter of 'INTEGER' type.
   * All values must lie in `integer_value_spec` of parent parameter.
   */
  values: Long[];
}

/** Represents the spec to match categorical values from parent parameter. */
export interface StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
  /**
   * Required. Matches values of the parent parameter of 'CATEGORICAL'
   * type. All values must exist in `categorical_value_spec` of parent
   * parameter.
   */
  values: string[];
}

/**
 * The decay curve automated stopping rule builds a Gaussian Process
 * Regressor to predict the final objective value of a Trial based on the
 * already completed Trials and the intermediate measurements of the current
 * Trial. Early stopping is requested for the current Trial if there is very
 * low probability to exceed the optimal value found so far.
 */
export interface StudySpec_DecayCurveAutomatedStoppingSpec {
  /**
   * True if
   * [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration]
   * is used as the x-axis of each Trials Decay Curve. Otherwise,
   * [Measurement.step_count][google.cloud.aiplatform.v1.Measurement.step_count]
   * will be used as the x-axis.
   */
  useElapsedDuration: boolean;
}

/**
 * The median automated stopping rule stops a pending Trial if the Trial's
 * best objective_value is strictly below the median 'performance' of all
 * completed Trials reported up to the Trial's last measurement.
 * Currently, 'performance' refers to the running average of the objective
 * values reported by the Trial in each measurement.
 */
export interface StudySpec_MedianAutomatedStoppingSpec {
  /**
   * True if median automated stopping rule applies on
   * [Measurement.elapsed_duration][google.cloud.aiplatform.v1.Measurement.elapsed_duration].
   * It means that elapsed_duration field of latest measurement of current
   * Trial is used to compute median objective value for each completed
   * Trials.
   */
  useElapsedDuration: boolean;
}

/**
 * Configuration for ConvexAutomatedStoppingSpec.
 * When there are enough completed trials (configured by
 * min_measurement_count), for pending trials with enough measurements and
 * steps, the policy first computes an overestimate of the objective value at
 * max_num_steps according to the slope of the incomplete objective value
 * curve. No prediction can be made if the curve is completely flat. If the
 * overestimation is worse than the best objective value of the completed
 * trials, this pending trial will be early-stopped, but a last measurement
 * will be added to the pending trial with max_num_steps and predicted
 * objective value from the autoregression model.
 */
export interface StudySpec_ConvexAutomatedStoppingSpec {
  /**
   * Steps used in predicting the final objective for early stopped trials. In
   * general, it's set to be the same as the defined steps in training /
   * tuning. If not defined, it will learn it from the completed trials. When
   * use_steps is false, this field is set to the maximum elapsed seconds.
   */
  maxStepCount: Long;
  /**
   * Minimum number of steps for a trial to complete. Trials which do not have
   * a measurement with step_count > min_step_count won't be considered for
   * early stopping. It's ok to set it to 0, and a trial can be early stopped
   * at any stage. By default, min_step_count is set to be one-tenth of the
   * max_step_count.
   * When use_elapsed_duration is true, this field is set to the minimum
   * elapsed seconds.
   */
  minStepCount: Long;
  /**
   * The minimal number of measurements in a Trial.  Early-stopping checks
   * will not trigger if less than min_measurement_count+1 completed trials or
   * pending trials with less than min_measurement_count measurements. If not
   * defined, the default value is 5.
   */
  minMeasurementCount: Long;
  /**
   * The hyper-parameter name used in the tuning job that stands for learning
   * rate. Leave it blank if learning rate is not in a parameter in tuning.
   * The learning_rate is used to estimate the objective value of the ongoing
   * trial.
   */
  learningRateParameterName: string;
  /**
   * This bool determines whether or not the rule is applied based on
   * elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
   * decision is made according to the predicted objective values according to
   * the target steps. If use_elapsed_duration==true, elapsed_secs is used
   * instead of steps. Also, in this case, the parameters max_num_steps and
   * min_num_steps are overloaded to contain max_elapsed_seconds and
   * min_elapsed_seconds.
   */
  useElapsedDuration: boolean;
  /**
   * ConvexAutomatedStoppingSpec by default only updates the trials that needs
   * to be early stopped using a newly trained auto-regressive model. When
   * this flag is set to True, all stopped trials from the beginning are
   * potentially updated in terms of their `final_measurement`. Also, note
   * that the training logic of autoregressive models is different in this
   * case. Enabling this option has shown better results and this may be the
   * default option in the future.
   */
  updateAllStoppedTrials?: boolean | undefined;
}

/**
 * The configuration (stopping conditions) for automated stopping of a Study.
 * Conditions include trial budgets, time budgets, and convergence detection.
 */
export interface StudySpec_StudyStoppingConfig {
  /**
   * If true, a Study enters STOPPING_ASAP whenever it would normally enters
   * STOPPING state.
   *
   * The bottom line is: set to true if you want to interrupt on-going
   * evaluations of Trials as soon as the study stopping condition is met.
   * (Please see Study.State documentation for the source of truth).
   */
  shouldStopAsap:
    | boolean
    | undefined;
  /**
   * Each "stopping rule" in this proto specifies an "if" condition. Before
   * Vizier would generate a new suggestion, it first checks each specified
   * stopping rule, from top to bottom in this list.
   * Note that the first few rules (e.g. minimum_runtime_constraint,
   * min_num_trials) will prevent other stopping rules from being evaluated
   * until they are met. For example, setting `min_num_trials=5` and
   * `always_stop_after= 1 hour` means that the Study will ONLY stop after it
   * has 5 COMPLETED trials, even if more than an hour has passed since its
   * creation. It follows the first applicable rule (whose "if" condition is
   * satisfied) to make a stopping decision. If none of the specified rules
   * are applicable, then Vizier decides that the study should not stop.
   * If Vizier decides that the study should stop, the study enters
   * STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
   * IMPORTANT: The automatic study state transition happens precisely as
   * described above; that is, deleting trials or updating StudyConfig NEVER
   * automatically moves the study state back to ACTIVE. If you want to
   * _resume_ a Study that was stopped, 1) change the stopping conditions if
   * necessary, 2) activate the study, and then 3) ask for suggestions.
   * If the specified time or duration has not passed, do not stop the
   * study.
   */
  minimumRuntimeConstraint:
    | StudyTimeConstraint
    | undefined;
  /** If the specified time or duration has passed, stop the study. */
  maximumRuntimeConstraint:
    | StudyTimeConstraint
    | undefined;
  /**
   * If there are fewer than this many COMPLETED trials, do not stop the
   * study.
   */
  minNumTrials:
    | number
    | undefined;
  /** If there are more than this many trials, stop the study. */
  maxNumTrials:
    | number
    | undefined;
  /**
   * If the objective value has not improved for this many consecutive
   * trials, stop the study.
   *
   * WARNING: Effective only for single-objective studies.
   */
  maxNumTrialsNoProgress:
    | number
    | undefined;
  /**
   * If the objective value has not improved for this much time, stop the
   * study.
   *
   * WARNING: Effective only for single-objective studies.
   */
  maxDurationNoProgress: Duration | undefined;
}

/**
 * A message representing a Measurement of a Trial. A Measurement contains
 * the Metrics got by executing a Trial using suggested hyperparameter
 * values.
 */
export interface Measurement {
  /**
   * Output only. Time that the Trial has been running at the point of this
   * Measurement.
   */
  elapsedDuration:
    | Duration
    | undefined;
  /**
   * Output only. The number of steps the machine learning model has been
   * trained for. Must be non-negative.
   */
  stepCount: Long;
  /**
   * Output only. A list of metrics got by evaluating the objective functions
   * using suggested Parameter values.
   */
  metrics: Measurement_Metric[];
}

/** A message representing a metric in the measurement. */
export interface Measurement_Metric {
  /**
   * Output only. The ID of the Metric. The Metric should be defined in
   * [StudySpec's Metrics][google.cloud.aiplatform.v1.StudySpec.metrics].
   */
  metricId: string;
  /** Output only. The value for this metric. */
  value: number;
}

function createBaseStudy(): Study {
  return { name: "", displayName: "", studySpec: undefined, state: 0, createTime: undefined, inactiveReason: "" };
}

export const Study: MessageFns<Study> = {
  encode(message: Study, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.studySpec !== undefined) {
      StudySpec.encode(message.studySpec, writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.inactiveReason !== "") {
      writer.uint32(50).string(message.inactiveReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Study {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.studySpec = StudySpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inactiveReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Study {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      studySpec: isSet(object.studySpec) ? StudySpec.fromJSON(object.studySpec) : undefined,
      state: isSet(object.state) ? study_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      inactiveReason: isSet(object.inactiveReason) ? globalThis.String(object.inactiveReason) : "",
    };
  },

  toJSON(message: Study): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.studySpec !== undefined) {
      obj.studySpec = StudySpec.toJSON(message.studySpec);
    }
    if (message.state !== 0) {
      obj.state = study_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.inactiveReason !== "") {
      obj.inactiveReason = message.inactiveReason;
    }
    return obj;
  },

  create(base?: DeepPartial<Study>): Study {
    return Study.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Study>): Study {
    const message = createBaseStudy();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.studySpec = (object.studySpec !== undefined && object.studySpec !== null)
      ? StudySpec.fromPartial(object.studySpec)
      : undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.inactiveReason = object.inactiveReason ?? "";
    return message;
  },
};

function createBaseTrial(): Trial {
  return {
    name: "",
    id: "",
    state: 0,
    parameters: [],
    finalMeasurement: undefined,
    measurements: [],
    startTime: undefined,
    endTime: undefined,
    clientId: "",
    infeasibleReason: "",
    customJob: "",
    webAccessUris: {},
  };
}

export const Trial: MessageFns<Trial> = {
  encode(message: Trial, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    for (const v of message.parameters) {
      Trial_Parameter.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.finalMeasurement !== undefined) {
      Measurement.encode(message.finalMeasurement, writer.uint32(42).fork()).join();
    }
    for (const v of message.measurements) {
      Measurement.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(58).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(66).fork()).join();
    }
    if (message.clientId !== "") {
      writer.uint32(74).string(message.clientId);
    }
    if (message.infeasibleReason !== "") {
      writer.uint32(82).string(message.infeasibleReason);
    }
    if (message.customJob !== "") {
      writer.uint32(90).string(message.customJob);
    }
    Object.entries(message.webAccessUris).forEach(([key, value]) => {
      Trial_WebAccessUrisEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trial {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parameters.push(Trial_Parameter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.finalMeasurement = Measurement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.measurements.push(Measurement.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.infeasibleReason = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.customJob = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Trial_WebAccessUrisEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.webAccessUris[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trial {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      state: isSet(object.state) ? trial_StateFromJSON(object.state) : 0,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Trial_Parameter.fromJSON(e))
        : [],
      finalMeasurement: isSet(object.finalMeasurement) ? Measurement.fromJSON(object.finalMeasurement) : undefined,
      measurements: globalThis.Array.isArray(object?.measurements)
        ? object.measurements.map((e: any) => Measurement.fromJSON(e))
        : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      infeasibleReason: isSet(object.infeasibleReason) ? globalThis.String(object.infeasibleReason) : "",
      customJob: isSet(object.customJob) ? globalThis.String(object.customJob) : "",
      webAccessUris: isObject(object.webAccessUris)
        ? Object.entries(object.webAccessUris).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Trial): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== 0) {
      obj.state = trial_StateToJSON(message.state);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Trial_Parameter.toJSON(e));
    }
    if (message.finalMeasurement !== undefined) {
      obj.finalMeasurement = Measurement.toJSON(message.finalMeasurement);
    }
    if (message.measurements?.length) {
      obj.measurements = message.measurements.map((e) => Measurement.toJSON(e));
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.infeasibleReason !== "") {
      obj.infeasibleReason = message.infeasibleReason;
    }
    if (message.customJob !== "") {
      obj.customJob = message.customJob;
    }
    if (message.webAccessUris) {
      const entries = Object.entries(message.webAccessUris);
      if (entries.length > 0) {
        obj.webAccessUris = {};
        entries.forEach(([k, v]) => {
          obj.webAccessUris[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Trial>): Trial {
    return Trial.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trial>): Trial {
    const message = createBaseTrial();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.state = object.state ?? 0;
    message.parameters = object.parameters?.map((e) => Trial_Parameter.fromPartial(e)) || [];
    message.finalMeasurement = (object.finalMeasurement !== undefined && object.finalMeasurement !== null)
      ? Measurement.fromPartial(object.finalMeasurement)
      : undefined;
    message.measurements = object.measurements?.map((e) => Measurement.fromPartial(e)) || [];
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.clientId = object.clientId ?? "";
    message.infeasibleReason = object.infeasibleReason ?? "";
    message.customJob = object.customJob ?? "";
    message.webAccessUris = Object.entries(object.webAccessUris ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTrial_Parameter(): Trial_Parameter {
  return { parameterId: "", value: undefined };
}

export const Trial_Parameter: MessageFns<Trial_Parameter> = {
  encode(message: Trial_Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameterId !== "") {
      writer.uint32(10).string(message.parameterId);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trial_Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrial_Parameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameterId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trial_Parameter {
    return {
      parameterId: isSet(object.parameterId) ? globalThis.String(object.parameterId) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Trial_Parameter): unknown {
    const obj: any = {};
    if (message.parameterId !== "") {
      obj.parameterId = message.parameterId;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Trial_Parameter>): Trial_Parameter {
    return Trial_Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trial_Parameter>): Trial_Parameter {
    const message = createBaseTrial_Parameter();
    message.parameterId = object.parameterId ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseTrial_WebAccessUrisEntry(): Trial_WebAccessUrisEntry {
  return { key: "", value: "" };
}

export const Trial_WebAccessUrisEntry: MessageFns<Trial_WebAccessUrisEntry> = {
  encode(message: Trial_WebAccessUrisEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trial_WebAccessUrisEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrial_WebAccessUrisEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trial_WebAccessUrisEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Trial_WebAccessUrisEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Trial_WebAccessUrisEntry>): Trial_WebAccessUrisEntry {
    return Trial_WebAccessUrisEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trial_WebAccessUrisEntry>): Trial_WebAccessUrisEntry {
    const message = createBaseTrial_WebAccessUrisEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrialContext(): TrialContext {
  return { description: "", parameters: [] };
}

export const TrialContext: MessageFns<TrialContext> = {
  encode(message: TrialContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    for (const v of message.parameters) {
      Trial_Parameter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrialContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrialContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters.push(Trial_Parameter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrialContext {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Trial_Parameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrialContext): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Trial_Parameter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TrialContext>): TrialContext {
    return TrialContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrialContext>): TrialContext {
    const message = createBaseTrialContext();
    message.description = object.description ?? "";
    message.parameters = object.parameters?.map((e) => Trial_Parameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStudyTimeConstraint(): StudyTimeConstraint {
  return { maxDuration: undefined, endTime: undefined };
}

export const StudyTimeConstraint: MessageFns<StudyTimeConstraint> = {
  encode(message: StudyTimeConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxDuration !== undefined) {
      Duration.encode(message.maxDuration, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudyTimeConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudyTimeConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.maxDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudyTimeConstraint {
    return {
      maxDuration: isSet(object.maxDuration) ? Duration.fromJSON(object.maxDuration) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: StudyTimeConstraint): unknown {
    const obj: any = {};
    if (message.maxDuration !== undefined) {
      obj.maxDuration = Duration.toJSON(message.maxDuration);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<StudyTimeConstraint>): StudyTimeConstraint {
    return StudyTimeConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudyTimeConstraint>): StudyTimeConstraint {
    const message = createBaseStudyTimeConstraint();
    message.maxDuration = (object.maxDuration !== undefined && object.maxDuration !== null)
      ? Duration.fromPartial(object.maxDuration)
      : undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseStudySpec(): StudySpec {
  return {
    decayCurveStoppingSpec: undefined,
    medianAutomatedStoppingSpec: undefined,
    convexAutomatedStoppingSpec: undefined,
    metrics: [],
    parameters: [],
    algorithm: 0,
    observationNoise: 0,
    measurementSelectionType: 0,
    studyStoppingConfig: undefined,
  };
}

export const StudySpec: MessageFns<StudySpec> = {
  encode(message: StudySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decayCurveStoppingSpec !== undefined) {
      StudySpec_DecayCurveAutomatedStoppingSpec.encode(message.decayCurveStoppingSpec, writer.uint32(34).fork()).join();
    }
    if (message.medianAutomatedStoppingSpec !== undefined) {
      StudySpec_MedianAutomatedStoppingSpec.encode(message.medianAutomatedStoppingSpec, writer.uint32(42).fork())
        .join();
    }
    if (message.convexAutomatedStoppingSpec !== undefined) {
      StudySpec_ConvexAutomatedStoppingSpec.encode(message.convexAutomatedStoppingSpec, writer.uint32(74).fork())
        .join();
    }
    for (const v of message.metrics) {
      StudySpec_MetricSpec.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.parameters) {
      StudySpec_ParameterSpec.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.algorithm !== 0) {
      writer.uint32(24).int32(message.algorithm);
    }
    if (message.observationNoise !== 0) {
      writer.uint32(48).int32(message.observationNoise);
    }
    if (message.measurementSelectionType !== 0) {
      writer.uint32(56).int32(message.measurementSelectionType);
    }
    if (message.studyStoppingConfig !== undefined) {
      StudySpec_StudyStoppingConfig.encode(message.studyStoppingConfig, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.decayCurveStoppingSpec = StudySpec_DecayCurveAutomatedStoppingSpec.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.medianAutomatedStoppingSpec = StudySpec_MedianAutomatedStoppingSpec.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.convexAutomatedStoppingSpec = StudySpec_ConvexAutomatedStoppingSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metrics.push(StudySpec_MetricSpec.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters.push(StudySpec_ParameterSpec.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.observationNoise = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.measurementSelectionType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.studyStoppingConfig = StudySpec_StudyStoppingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec {
    return {
      decayCurveStoppingSpec: isSet(object.decayCurveStoppingSpec)
        ? StudySpec_DecayCurveAutomatedStoppingSpec.fromJSON(object.decayCurveStoppingSpec)
        : undefined,
      medianAutomatedStoppingSpec: isSet(object.medianAutomatedStoppingSpec)
        ? StudySpec_MedianAutomatedStoppingSpec.fromJSON(object.medianAutomatedStoppingSpec)
        : undefined,
      convexAutomatedStoppingSpec: isSet(object.convexAutomatedStoppingSpec)
        ? StudySpec_ConvexAutomatedStoppingSpec.fromJSON(object.convexAutomatedStoppingSpec)
        : undefined,
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => StudySpec_MetricSpec.fromJSON(e))
        : [],
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => StudySpec_ParameterSpec.fromJSON(e))
        : [],
      algorithm: isSet(object.algorithm) ? studySpec_AlgorithmFromJSON(object.algorithm) : 0,
      observationNoise: isSet(object.observationNoise)
        ? studySpec_ObservationNoiseFromJSON(object.observationNoise)
        : 0,
      measurementSelectionType: isSet(object.measurementSelectionType)
        ? studySpec_MeasurementSelectionTypeFromJSON(object.measurementSelectionType)
        : 0,
      studyStoppingConfig: isSet(object.studyStoppingConfig)
        ? StudySpec_StudyStoppingConfig.fromJSON(object.studyStoppingConfig)
        : undefined,
    };
  },

  toJSON(message: StudySpec): unknown {
    const obj: any = {};
    if (message.decayCurveStoppingSpec !== undefined) {
      obj.decayCurveStoppingSpec = StudySpec_DecayCurveAutomatedStoppingSpec.toJSON(message.decayCurveStoppingSpec);
    }
    if (message.medianAutomatedStoppingSpec !== undefined) {
      obj.medianAutomatedStoppingSpec = StudySpec_MedianAutomatedStoppingSpec.toJSON(
        message.medianAutomatedStoppingSpec,
      );
    }
    if (message.convexAutomatedStoppingSpec !== undefined) {
      obj.convexAutomatedStoppingSpec = StudySpec_ConvexAutomatedStoppingSpec.toJSON(
        message.convexAutomatedStoppingSpec,
      );
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => StudySpec_MetricSpec.toJSON(e));
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => StudySpec_ParameterSpec.toJSON(e));
    }
    if (message.algorithm !== 0) {
      obj.algorithm = studySpec_AlgorithmToJSON(message.algorithm);
    }
    if (message.observationNoise !== 0) {
      obj.observationNoise = studySpec_ObservationNoiseToJSON(message.observationNoise);
    }
    if (message.measurementSelectionType !== 0) {
      obj.measurementSelectionType = studySpec_MeasurementSelectionTypeToJSON(message.measurementSelectionType);
    }
    if (message.studyStoppingConfig !== undefined) {
      obj.studyStoppingConfig = StudySpec_StudyStoppingConfig.toJSON(message.studyStoppingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec>): StudySpec {
    return StudySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec>): StudySpec {
    const message = createBaseStudySpec();
    message.decayCurveStoppingSpec =
      (object.decayCurveStoppingSpec !== undefined && object.decayCurveStoppingSpec !== null)
        ? StudySpec_DecayCurveAutomatedStoppingSpec.fromPartial(object.decayCurveStoppingSpec)
        : undefined;
    message.medianAutomatedStoppingSpec =
      (object.medianAutomatedStoppingSpec !== undefined && object.medianAutomatedStoppingSpec !== null)
        ? StudySpec_MedianAutomatedStoppingSpec.fromPartial(object.medianAutomatedStoppingSpec)
        : undefined;
    message.convexAutomatedStoppingSpec =
      (object.convexAutomatedStoppingSpec !== undefined && object.convexAutomatedStoppingSpec !== null)
        ? StudySpec_ConvexAutomatedStoppingSpec.fromPartial(object.convexAutomatedStoppingSpec)
        : undefined;
    message.metrics = object.metrics?.map((e) => StudySpec_MetricSpec.fromPartial(e)) || [];
    message.parameters = object.parameters?.map((e) => StudySpec_ParameterSpec.fromPartial(e)) || [];
    message.algorithm = object.algorithm ?? 0;
    message.observationNoise = object.observationNoise ?? 0;
    message.measurementSelectionType = object.measurementSelectionType ?? 0;
    message.studyStoppingConfig = (object.studyStoppingConfig !== undefined && object.studyStoppingConfig !== null)
      ? StudySpec_StudyStoppingConfig.fromPartial(object.studyStoppingConfig)
      : undefined;
    return message;
  },
};

function createBaseStudySpec_MetricSpec(): StudySpec_MetricSpec {
  return { metricId: "", goal: 0, safetyConfig: undefined };
}

export const StudySpec_MetricSpec: MessageFns<StudySpec_MetricSpec> = {
  encode(message: StudySpec_MetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricId !== "") {
      writer.uint32(10).string(message.metricId);
    }
    if (message.goal !== 0) {
      writer.uint32(16).int32(message.goal);
    }
    if (message.safetyConfig !== undefined) {
      StudySpec_MetricSpec_SafetyMetricConfig.encode(message.safetyConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_MetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_MetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.goal = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.safetyConfig = StudySpec_MetricSpec_SafetyMetricConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_MetricSpec {
    return {
      metricId: isSet(object.metricId) ? globalThis.String(object.metricId) : "",
      goal: isSet(object.goal) ? studySpec_MetricSpec_GoalTypeFromJSON(object.goal) : 0,
      safetyConfig: isSet(object.safetyConfig)
        ? StudySpec_MetricSpec_SafetyMetricConfig.fromJSON(object.safetyConfig)
        : undefined,
    };
  },

  toJSON(message: StudySpec_MetricSpec): unknown {
    const obj: any = {};
    if (message.metricId !== "") {
      obj.metricId = message.metricId;
    }
    if (message.goal !== 0) {
      obj.goal = studySpec_MetricSpec_GoalTypeToJSON(message.goal);
    }
    if (message.safetyConfig !== undefined) {
      obj.safetyConfig = StudySpec_MetricSpec_SafetyMetricConfig.toJSON(message.safetyConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_MetricSpec>): StudySpec_MetricSpec {
    return StudySpec_MetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_MetricSpec>): StudySpec_MetricSpec {
    const message = createBaseStudySpec_MetricSpec();
    message.metricId = object.metricId ?? "";
    message.goal = object.goal ?? 0;
    message.safetyConfig = (object.safetyConfig !== undefined && object.safetyConfig !== null)
      ? StudySpec_MetricSpec_SafetyMetricConfig.fromPartial(object.safetyConfig)
      : undefined;
    return message;
  },
};

function createBaseStudySpec_MetricSpec_SafetyMetricConfig(): StudySpec_MetricSpec_SafetyMetricConfig {
  return { safetyThreshold: 0, desiredMinSafeTrialsFraction: undefined };
}

export const StudySpec_MetricSpec_SafetyMetricConfig: MessageFns<StudySpec_MetricSpec_SafetyMetricConfig> = {
  encode(message: StudySpec_MetricSpec_SafetyMetricConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.safetyThreshold !== 0) {
      writer.uint32(9).double(message.safetyThreshold);
    }
    if (message.desiredMinSafeTrialsFraction !== undefined) {
      writer.uint32(17).double(message.desiredMinSafeTrialsFraction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_MetricSpec_SafetyMetricConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_MetricSpec_SafetyMetricConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.safetyThreshold = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.desiredMinSafeTrialsFraction = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_MetricSpec_SafetyMetricConfig {
    return {
      safetyThreshold: isSet(object.safetyThreshold) ? globalThis.Number(object.safetyThreshold) : 0,
      desiredMinSafeTrialsFraction: isSet(object.desiredMinSafeTrialsFraction)
        ? globalThis.Number(object.desiredMinSafeTrialsFraction)
        : undefined,
    };
  },

  toJSON(message: StudySpec_MetricSpec_SafetyMetricConfig): unknown {
    const obj: any = {};
    if (message.safetyThreshold !== 0) {
      obj.safetyThreshold = message.safetyThreshold;
    }
    if (message.desiredMinSafeTrialsFraction !== undefined) {
      obj.desiredMinSafeTrialsFraction = message.desiredMinSafeTrialsFraction;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_MetricSpec_SafetyMetricConfig>): StudySpec_MetricSpec_SafetyMetricConfig {
    return StudySpec_MetricSpec_SafetyMetricConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_MetricSpec_SafetyMetricConfig>): StudySpec_MetricSpec_SafetyMetricConfig {
    const message = createBaseStudySpec_MetricSpec_SafetyMetricConfig();
    message.safetyThreshold = object.safetyThreshold ?? 0;
    message.desiredMinSafeTrialsFraction = object.desiredMinSafeTrialsFraction ?? undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec(): StudySpec_ParameterSpec {
  return {
    doubleValueSpec: undefined,
    integerValueSpec: undefined,
    categoricalValueSpec: undefined,
    discreteValueSpec: undefined,
    parameterId: "",
    scaleType: 0,
    conditionalParameterSpecs: [],
  };
}

export const StudySpec_ParameterSpec: MessageFns<StudySpec_ParameterSpec> = {
  encode(message: StudySpec_ParameterSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.doubleValueSpec !== undefined) {
      StudySpec_ParameterSpec_DoubleValueSpec.encode(message.doubleValueSpec, writer.uint32(18).fork()).join();
    }
    if (message.integerValueSpec !== undefined) {
      StudySpec_ParameterSpec_IntegerValueSpec.encode(message.integerValueSpec, writer.uint32(26).fork()).join();
    }
    if (message.categoricalValueSpec !== undefined) {
      StudySpec_ParameterSpec_CategoricalValueSpec.encode(message.categoricalValueSpec, writer.uint32(34).fork())
        .join();
    }
    if (message.discreteValueSpec !== undefined) {
      StudySpec_ParameterSpec_DiscreteValueSpec.encode(message.discreteValueSpec, writer.uint32(42).fork()).join();
    }
    if (message.parameterId !== "") {
      writer.uint32(10).string(message.parameterId);
    }
    if (message.scaleType !== 0) {
      writer.uint32(48).int32(message.scaleType);
    }
    for (const v of message.conditionalParameterSpecs) {
      StudySpec_ParameterSpec_ConditionalParameterSpec.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.doubleValueSpec = StudySpec_ParameterSpec_DoubleValueSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.integerValueSpec = StudySpec_ParameterSpec_IntegerValueSpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.categoricalValueSpec = StudySpec_ParameterSpec_CategoricalValueSpec.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.discreteValueSpec = StudySpec_ParameterSpec_DiscreteValueSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameterId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.scaleType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.conditionalParameterSpecs.push(
            StudySpec_ParameterSpec_ConditionalParameterSpec.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec {
    return {
      doubleValueSpec: isSet(object.doubleValueSpec)
        ? StudySpec_ParameterSpec_DoubleValueSpec.fromJSON(object.doubleValueSpec)
        : undefined,
      integerValueSpec: isSet(object.integerValueSpec)
        ? StudySpec_ParameterSpec_IntegerValueSpec.fromJSON(object.integerValueSpec)
        : undefined,
      categoricalValueSpec: isSet(object.categoricalValueSpec)
        ? StudySpec_ParameterSpec_CategoricalValueSpec.fromJSON(object.categoricalValueSpec)
        : undefined,
      discreteValueSpec: isSet(object.discreteValueSpec)
        ? StudySpec_ParameterSpec_DiscreteValueSpec.fromJSON(object.discreteValueSpec)
        : undefined,
      parameterId: isSet(object.parameterId) ? globalThis.String(object.parameterId) : "",
      scaleType: isSet(object.scaleType) ? studySpec_ParameterSpec_ScaleTypeFromJSON(object.scaleType) : 0,
      conditionalParameterSpecs: globalThis.Array.isArray(object?.conditionalParameterSpecs)
        ? object.conditionalParameterSpecs.map((e: any) => StudySpec_ParameterSpec_ConditionalParameterSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StudySpec_ParameterSpec): unknown {
    const obj: any = {};
    if (message.doubleValueSpec !== undefined) {
      obj.doubleValueSpec = StudySpec_ParameterSpec_DoubleValueSpec.toJSON(message.doubleValueSpec);
    }
    if (message.integerValueSpec !== undefined) {
      obj.integerValueSpec = StudySpec_ParameterSpec_IntegerValueSpec.toJSON(message.integerValueSpec);
    }
    if (message.categoricalValueSpec !== undefined) {
      obj.categoricalValueSpec = StudySpec_ParameterSpec_CategoricalValueSpec.toJSON(message.categoricalValueSpec);
    }
    if (message.discreteValueSpec !== undefined) {
      obj.discreteValueSpec = StudySpec_ParameterSpec_DiscreteValueSpec.toJSON(message.discreteValueSpec);
    }
    if (message.parameterId !== "") {
      obj.parameterId = message.parameterId;
    }
    if (message.scaleType !== 0) {
      obj.scaleType = studySpec_ParameterSpec_ScaleTypeToJSON(message.scaleType);
    }
    if (message.conditionalParameterSpecs?.length) {
      obj.conditionalParameterSpecs = message.conditionalParameterSpecs.map((e) =>
        StudySpec_ParameterSpec_ConditionalParameterSpec.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_ParameterSpec>): StudySpec_ParameterSpec {
    return StudySpec_ParameterSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_ParameterSpec>): StudySpec_ParameterSpec {
    const message = createBaseStudySpec_ParameterSpec();
    message.doubleValueSpec = (object.doubleValueSpec !== undefined && object.doubleValueSpec !== null)
      ? StudySpec_ParameterSpec_DoubleValueSpec.fromPartial(object.doubleValueSpec)
      : undefined;
    message.integerValueSpec = (object.integerValueSpec !== undefined && object.integerValueSpec !== null)
      ? StudySpec_ParameterSpec_IntegerValueSpec.fromPartial(object.integerValueSpec)
      : undefined;
    message.categoricalValueSpec = (object.categoricalValueSpec !== undefined && object.categoricalValueSpec !== null)
      ? StudySpec_ParameterSpec_CategoricalValueSpec.fromPartial(object.categoricalValueSpec)
      : undefined;
    message.discreteValueSpec = (object.discreteValueSpec !== undefined && object.discreteValueSpec !== null)
      ? StudySpec_ParameterSpec_DiscreteValueSpec.fromPartial(object.discreteValueSpec)
      : undefined;
    message.parameterId = object.parameterId ?? "";
    message.scaleType = object.scaleType ?? 0;
    message.conditionalParameterSpecs =
      object.conditionalParameterSpecs?.map((e) => StudySpec_ParameterSpec_ConditionalParameterSpec.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_DoubleValueSpec(): StudySpec_ParameterSpec_DoubleValueSpec {
  return { minValue: 0, maxValue: 0, defaultValue: undefined };
}

export const StudySpec_ParameterSpec_DoubleValueSpec: MessageFns<StudySpec_ParameterSpec_DoubleValueSpec> = {
  encode(message: StudySpec_ParameterSpec_DoubleValueSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minValue !== 0) {
      writer.uint32(9).double(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(17).double(message.maxValue);
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(33).double(message.defaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec_DoubleValueSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_DoubleValueSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.minValue = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.maxValue = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.defaultValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_DoubleValueSpec {
    return {
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
      defaultValue: isSet(object.defaultValue) ? globalThis.Number(object.defaultValue) : undefined,
    };
  },

  toJSON(message: StudySpec_ParameterSpec_DoubleValueSpec): unknown {
    const obj: any = {};
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_ParameterSpec_DoubleValueSpec>): StudySpec_ParameterSpec_DoubleValueSpec {
    return StudySpec_ParameterSpec_DoubleValueSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_ParameterSpec_DoubleValueSpec>): StudySpec_ParameterSpec_DoubleValueSpec {
    const message = createBaseStudySpec_ParameterSpec_DoubleValueSpec();
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    message.defaultValue = object.defaultValue ?? undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_IntegerValueSpec(): StudySpec_ParameterSpec_IntegerValueSpec {
  return { minValue: Long.ZERO, maxValue: Long.ZERO, defaultValue: undefined };
}

export const StudySpec_ParameterSpec_IntegerValueSpec: MessageFns<StudySpec_ParameterSpec_IntegerValueSpec> = {
  encode(message: StudySpec_ParameterSpec_IntegerValueSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.minValue.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.minValue.toString());
    }
    if (!message.maxValue.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxValue.toString());
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(32).int64(message.defaultValue.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec_IntegerValueSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_IntegerValueSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxValue = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.defaultValue = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_IntegerValueSpec {
    return {
      minValue: isSet(object.minValue) ? Long.fromValue(object.minValue) : Long.ZERO,
      maxValue: isSet(object.maxValue) ? Long.fromValue(object.maxValue) : Long.ZERO,
      defaultValue: isSet(object.defaultValue) ? Long.fromValue(object.defaultValue) : undefined,
    };
  },

  toJSON(message: StudySpec_ParameterSpec_IntegerValueSpec): unknown {
    const obj: any = {};
    if (!message.minValue.equals(Long.ZERO)) {
      obj.minValue = (message.minValue || Long.ZERO).toString();
    }
    if (!message.maxValue.equals(Long.ZERO)) {
      obj.maxValue = (message.maxValue || Long.ZERO).toString();
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = (message.defaultValue || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_ParameterSpec_IntegerValueSpec>): StudySpec_ParameterSpec_IntegerValueSpec {
    return StudySpec_ParameterSpec_IntegerValueSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_ParameterSpec_IntegerValueSpec>): StudySpec_ParameterSpec_IntegerValueSpec {
    const message = createBaseStudySpec_ParameterSpec_IntegerValueSpec();
    message.minValue = (object.minValue !== undefined && object.minValue !== null)
      ? Long.fromValue(object.minValue)
      : Long.ZERO;
    message.maxValue = (object.maxValue !== undefined && object.maxValue !== null)
      ? Long.fromValue(object.maxValue)
      : Long.ZERO;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? Long.fromValue(object.defaultValue)
      : undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_CategoricalValueSpec(): StudySpec_ParameterSpec_CategoricalValueSpec {
  return { values: [], defaultValue: undefined };
}

export const StudySpec_ParameterSpec_CategoricalValueSpec: MessageFns<StudySpec_ParameterSpec_CategoricalValueSpec> = {
  encode(
    message: StudySpec_ParameterSpec_CategoricalValueSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(26).string(message.defaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec_CategoricalValueSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_CategoricalValueSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_CategoricalValueSpec {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : undefined,
    };
  },

  toJSON(message: StudySpec_ParameterSpec_CategoricalValueSpec): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<StudySpec_ParameterSpec_CategoricalValueSpec>,
  ): StudySpec_ParameterSpec_CategoricalValueSpec {
    return StudySpec_ParameterSpec_CategoricalValueSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_CategoricalValueSpec>,
  ): StudySpec_ParameterSpec_CategoricalValueSpec {
    const message = createBaseStudySpec_ParameterSpec_CategoricalValueSpec();
    message.values = object.values?.map((e) => e) || [];
    message.defaultValue = object.defaultValue ?? undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_DiscreteValueSpec(): StudySpec_ParameterSpec_DiscreteValueSpec {
  return { values: [], defaultValue: undefined };
}

export const StudySpec_ParameterSpec_DiscreteValueSpec: MessageFns<StudySpec_ParameterSpec_DiscreteValueSpec> = {
  encode(message: StudySpec_ParameterSpec_DiscreteValueSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    if (message.defaultValue !== undefined) {
      writer.uint32(25).double(message.defaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec_DiscreteValueSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_DiscreteValueSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.defaultValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_DiscreteValueSpec {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      defaultValue: isSet(object.defaultValue) ? globalThis.Number(object.defaultValue) : undefined,
    };
  },

  toJSON(message: StudySpec_ParameterSpec_DiscreteValueSpec): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_ParameterSpec_DiscreteValueSpec>): StudySpec_ParameterSpec_DiscreteValueSpec {
    return StudySpec_ParameterSpec_DiscreteValueSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_DiscreteValueSpec>,
  ): StudySpec_ParameterSpec_DiscreteValueSpec {
    const message = createBaseStudySpec_ParameterSpec_DiscreteValueSpec();
    message.values = object.values?.map((e) => e) || [];
    message.defaultValue = object.defaultValue ?? undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_ConditionalParameterSpec(): StudySpec_ParameterSpec_ConditionalParameterSpec {
  return {
    parentDiscreteValues: undefined,
    parentIntValues: undefined,
    parentCategoricalValues: undefined,
    parameterSpec: undefined,
  };
}

export const StudySpec_ParameterSpec_ConditionalParameterSpec: MessageFns<
  StudySpec_ParameterSpec_ConditionalParameterSpec
> = {
  encode(
    message: StudySpec_ParameterSpec_ConditionalParameterSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.parentDiscreteValues !== undefined) {
      StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.encode(
        message.parentDiscreteValues,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.parentIntValues !== undefined) {
      StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.encode(
        message.parentIntValues,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.parentCategoricalValues !== undefined) {
      StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.encode(
        message.parentCategoricalValues,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.parameterSpec !== undefined) {
      StudySpec_ParameterSpec.encode(message.parameterSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ParameterSpec_ConditionalParameterSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentDiscreteValues = StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentIntValues = StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parentCategoricalValues = StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
            .decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameterSpec = StudySpec_ParameterSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_ConditionalParameterSpec {
    return {
      parentDiscreteValues: isSet(object.parentDiscreteValues)
        ? StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromJSON(object.parentDiscreteValues)
        : undefined,
      parentIntValues: isSet(object.parentIntValues)
        ? StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromJSON(object.parentIntValues)
        : undefined,
      parentCategoricalValues: isSet(object.parentCategoricalValues)
        ? StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromJSON(
          object.parentCategoricalValues,
        )
        : undefined,
      parameterSpec: isSet(object.parameterSpec) ? StudySpec_ParameterSpec.fromJSON(object.parameterSpec) : undefined,
    };
  },

  toJSON(message: StudySpec_ParameterSpec_ConditionalParameterSpec): unknown {
    const obj: any = {};
    if (message.parentDiscreteValues !== undefined) {
      obj.parentDiscreteValues = StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.toJSON(
        message.parentDiscreteValues,
      );
    }
    if (message.parentIntValues !== undefined) {
      obj.parentIntValues = StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.toJSON(
        message.parentIntValues,
      );
    }
    if (message.parentCategoricalValues !== undefined) {
      obj.parentCategoricalValues = StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.toJSON(
        message.parentCategoricalValues,
      );
    }
    if (message.parameterSpec !== undefined) {
      obj.parameterSpec = StudySpec_ParameterSpec.toJSON(message.parameterSpec);
    }
    return obj;
  },

  create(
    base?: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec {
    return StudySpec_ParameterSpec_ConditionalParameterSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec {
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec();
    message.parentDiscreteValues = (object.parentDiscreteValues !== undefined && object.parentDiscreteValues !== null)
      ? StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromPartial(object.parentDiscreteValues)
      : undefined;
    message.parentIntValues = (object.parentIntValues !== undefined && object.parentIntValues !== null)
      ? StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromPartial(object.parentIntValues)
      : undefined;
    message.parentCategoricalValues =
      (object.parentCategoricalValues !== undefined && object.parentCategoricalValues !== null)
        ? StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromPartial(
          object.parentCategoricalValues,
        )
        : undefined;
    message.parameterSpec = (object.parameterSpec !== undefined && object.parameterSpec !== null)
      ? StudySpec_ParameterSpec.fromPartial(object.parameterSpec)
      : undefined;
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition(): StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
  return { values: [] };
}

export const StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition: MessageFns<
  StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition
> = {
  encode(
    message: StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(
    base?: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition {
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition(): StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
  return { values: [] };
}

export const StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition: MessageFns<
  StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition
> = {
  encode(
    message: StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Long.fromValue(e)) : [] };
  },

  toJSON(message: StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(
    base?: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition {
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition();
    message.values = object.values?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition(): StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
  return { values: [] };
}

export const StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition: MessageFns<
  StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
> = {
  encode(
    message: StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(
    base?: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition>,
  ): StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition {
    const message = createBaseStudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseStudySpec_DecayCurveAutomatedStoppingSpec(): StudySpec_DecayCurveAutomatedStoppingSpec {
  return { useElapsedDuration: false };
}

export const StudySpec_DecayCurveAutomatedStoppingSpec: MessageFns<StudySpec_DecayCurveAutomatedStoppingSpec> = {
  encode(message: StudySpec_DecayCurveAutomatedStoppingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useElapsedDuration !== false) {
      writer.uint32(8).bool(message.useElapsedDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_DecayCurveAutomatedStoppingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_DecayCurveAutomatedStoppingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useElapsedDuration = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_DecayCurveAutomatedStoppingSpec {
    return {
      useElapsedDuration: isSet(object.useElapsedDuration) ? globalThis.Boolean(object.useElapsedDuration) : false,
    };
  },

  toJSON(message: StudySpec_DecayCurveAutomatedStoppingSpec): unknown {
    const obj: any = {};
    if (message.useElapsedDuration !== false) {
      obj.useElapsedDuration = message.useElapsedDuration;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_DecayCurveAutomatedStoppingSpec>): StudySpec_DecayCurveAutomatedStoppingSpec {
    return StudySpec_DecayCurveAutomatedStoppingSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StudySpec_DecayCurveAutomatedStoppingSpec>,
  ): StudySpec_DecayCurveAutomatedStoppingSpec {
    const message = createBaseStudySpec_DecayCurveAutomatedStoppingSpec();
    message.useElapsedDuration = object.useElapsedDuration ?? false;
    return message;
  },
};

function createBaseStudySpec_MedianAutomatedStoppingSpec(): StudySpec_MedianAutomatedStoppingSpec {
  return { useElapsedDuration: false };
}

export const StudySpec_MedianAutomatedStoppingSpec: MessageFns<StudySpec_MedianAutomatedStoppingSpec> = {
  encode(message: StudySpec_MedianAutomatedStoppingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useElapsedDuration !== false) {
      writer.uint32(8).bool(message.useElapsedDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_MedianAutomatedStoppingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_MedianAutomatedStoppingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useElapsedDuration = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_MedianAutomatedStoppingSpec {
    return {
      useElapsedDuration: isSet(object.useElapsedDuration) ? globalThis.Boolean(object.useElapsedDuration) : false,
    };
  },

  toJSON(message: StudySpec_MedianAutomatedStoppingSpec): unknown {
    const obj: any = {};
    if (message.useElapsedDuration !== false) {
      obj.useElapsedDuration = message.useElapsedDuration;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_MedianAutomatedStoppingSpec>): StudySpec_MedianAutomatedStoppingSpec {
    return StudySpec_MedianAutomatedStoppingSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_MedianAutomatedStoppingSpec>): StudySpec_MedianAutomatedStoppingSpec {
    const message = createBaseStudySpec_MedianAutomatedStoppingSpec();
    message.useElapsedDuration = object.useElapsedDuration ?? false;
    return message;
  },
};

function createBaseStudySpec_ConvexAutomatedStoppingSpec(): StudySpec_ConvexAutomatedStoppingSpec {
  return {
    maxStepCount: Long.ZERO,
    minStepCount: Long.ZERO,
    minMeasurementCount: Long.ZERO,
    learningRateParameterName: "",
    useElapsedDuration: false,
    updateAllStoppedTrials: undefined,
  };
}

export const StudySpec_ConvexAutomatedStoppingSpec: MessageFns<StudySpec_ConvexAutomatedStoppingSpec> = {
  encode(message: StudySpec_ConvexAutomatedStoppingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxStepCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.maxStepCount.toString());
    }
    if (!message.minStepCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.minStepCount.toString());
    }
    if (!message.minMeasurementCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.minMeasurementCount.toString());
    }
    if (message.learningRateParameterName !== "") {
      writer.uint32(34).string(message.learningRateParameterName);
    }
    if (message.useElapsedDuration !== false) {
      writer.uint32(40).bool(message.useElapsedDuration);
    }
    if (message.updateAllStoppedTrials !== undefined) {
      writer.uint32(48).bool(message.updateAllStoppedTrials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_ConvexAutomatedStoppingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_ConvexAutomatedStoppingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxStepCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minStepCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minMeasurementCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.learningRateParameterName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useElapsedDuration = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.updateAllStoppedTrials = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_ConvexAutomatedStoppingSpec {
    return {
      maxStepCount: isSet(object.maxStepCount) ? Long.fromValue(object.maxStepCount) : Long.ZERO,
      minStepCount: isSet(object.minStepCount) ? Long.fromValue(object.minStepCount) : Long.ZERO,
      minMeasurementCount: isSet(object.minMeasurementCount) ? Long.fromValue(object.minMeasurementCount) : Long.ZERO,
      learningRateParameterName: isSet(object.learningRateParameterName)
        ? globalThis.String(object.learningRateParameterName)
        : "",
      useElapsedDuration: isSet(object.useElapsedDuration) ? globalThis.Boolean(object.useElapsedDuration) : false,
      updateAllStoppedTrials: isSet(object.updateAllStoppedTrials)
        ? globalThis.Boolean(object.updateAllStoppedTrials)
        : undefined,
    };
  },

  toJSON(message: StudySpec_ConvexAutomatedStoppingSpec): unknown {
    const obj: any = {};
    if (!message.maxStepCount.equals(Long.ZERO)) {
      obj.maxStepCount = (message.maxStepCount || Long.ZERO).toString();
    }
    if (!message.minStepCount.equals(Long.ZERO)) {
      obj.minStepCount = (message.minStepCount || Long.ZERO).toString();
    }
    if (!message.minMeasurementCount.equals(Long.ZERO)) {
      obj.minMeasurementCount = (message.minMeasurementCount || Long.ZERO).toString();
    }
    if (message.learningRateParameterName !== "") {
      obj.learningRateParameterName = message.learningRateParameterName;
    }
    if (message.useElapsedDuration !== false) {
      obj.useElapsedDuration = message.useElapsedDuration;
    }
    if (message.updateAllStoppedTrials !== undefined) {
      obj.updateAllStoppedTrials = message.updateAllStoppedTrials;
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_ConvexAutomatedStoppingSpec>): StudySpec_ConvexAutomatedStoppingSpec {
    return StudySpec_ConvexAutomatedStoppingSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_ConvexAutomatedStoppingSpec>): StudySpec_ConvexAutomatedStoppingSpec {
    const message = createBaseStudySpec_ConvexAutomatedStoppingSpec();
    message.maxStepCount = (object.maxStepCount !== undefined && object.maxStepCount !== null)
      ? Long.fromValue(object.maxStepCount)
      : Long.ZERO;
    message.minStepCount = (object.minStepCount !== undefined && object.minStepCount !== null)
      ? Long.fromValue(object.minStepCount)
      : Long.ZERO;
    message.minMeasurementCount = (object.minMeasurementCount !== undefined && object.minMeasurementCount !== null)
      ? Long.fromValue(object.minMeasurementCount)
      : Long.ZERO;
    message.learningRateParameterName = object.learningRateParameterName ?? "";
    message.useElapsedDuration = object.useElapsedDuration ?? false;
    message.updateAllStoppedTrials = object.updateAllStoppedTrials ?? undefined;
    return message;
  },
};

function createBaseStudySpec_StudyStoppingConfig(): StudySpec_StudyStoppingConfig {
  return {
    shouldStopAsap: undefined,
    minimumRuntimeConstraint: undefined,
    maximumRuntimeConstraint: undefined,
    minNumTrials: undefined,
    maxNumTrials: undefined,
    maxNumTrialsNoProgress: undefined,
    maxDurationNoProgress: undefined,
  };
}

export const StudySpec_StudyStoppingConfig: MessageFns<StudySpec_StudyStoppingConfig> = {
  encode(message: StudySpec_StudyStoppingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shouldStopAsap !== undefined) {
      BoolValue.encode({ value: message.shouldStopAsap! }, writer.uint32(10).fork()).join();
    }
    if (message.minimumRuntimeConstraint !== undefined) {
      StudyTimeConstraint.encode(message.minimumRuntimeConstraint, writer.uint32(18).fork()).join();
    }
    if (message.maximumRuntimeConstraint !== undefined) {
      StudyTimeConstraint.encode(message.maximumRuntimeConstraint, writer.uint32(26).fork()).join();
    }
    if (message.minNumTrials !== undefined) {
      Int32Value.encode({ value: message.minNumTrials! }, writer.uint32(34).fork()).join();
    }
    if (message.maxNumTrials !== undefined) {
      Int32Value.encode({ value: message.maxNumTrials! }, writer.uint32(42).fork()).join();
    }
    if (message.maxNumTrialsNoProgress !== undefined) {
      Int32Value.encode({ value: message.maxNumTrialsNoProgress! }, writer.uint32(50).fork()).join();
    }
    if (message.maxDurationNoProgress !== undefined) {
      Duration.encode(message.maxDurationNoProgress, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudySpec_StudyStoppingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudySpec_StudyStoppingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shouldStopAsap = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minimumRuntimeConstraint = StudyTimeConstraint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maximumRuntimeConstraint = StudyTimeConstraint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minNumTrials = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maxNumTrials = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxNumTrialsNoProgress = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.maxDurationNoProgress = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudySpec_StudyStoppingConfig {
    return {
      shouldStopAsap: isSet(object.shouldStopAsap) ? Boolean(object.shouldStopAsap) : undefined,
      minimumRuntimeConstraint: isSet(object.minimumRuntimeConstraint)
        ? StudyTimeConstraint.fromJSON(object.minimumRuntimeConstraint)
        : undefined,
      maximumRuntimeConstraint: isSet(object.maximumRuntimeConstraint)
        ? StudyTimeConstraint.fromJSON(object.maximumRuntimeConstraint)
        : undefined,
      minNumTrials: isSet(object.minNumTrials) ? Number(object.minNumTrials) : undefined,
      maxNumTrials: isSet(object.maxNumTrials) ? Number(object.maxNumTrials) : undefined,
      maxNumTrialsNoProgress: isSet(object.maxNumTrialsNoProgress) ? Number(object.maxNumTrialsNoProgress) : undefined,
      maxDurationNoProgress: isSet(object.maxDurationNoProgress)
        ? Duration.fromJSON(object.maxDurationNoProgress)
        : undefined,
    };
  },

  toJSON(message: StudySpec_StudyStoppingConfig): unknown {
    const obj: any = {};
    if (message.shouldStopAsap !== undefined) {
      obj.shouldStopAsap = message.shouldStopAsap;
    }
    if (message.minimumRuntimeConstraint !== undefined) {
      obj.minimumRuntimeConstraint = StudyTimeConstraint.toJSON(message.minimumRuntimeConstraint);
    }
    if (message.maximumRuntimeConstraint !== undefined) {
      obj.maximumRuntimeConstraint = StudyTimeConstraint.toJSON(message.maximumRuntimeConstraint);
    }
    if (message.minNumTrials !== undefined) {
      obj.minNumTrials = message.minNumTrials;
    }
    if (message.maxNumTrials !== undefined) {
      obj.maxNumTrials = message.maxNumTrials;
    }
    if (message.maxNumTrialsNoProgress !== undefined) {
      obj.maxNumTrialsNoProgress = message.maxNumTrialsNoProgress;
    }
    if (message.maxDurationNoProgress !== undefined) {
      obj.maxDurationNoProgress = Duration.toJSON(message.maxDurationNoProgress);
    }
    return obj;
  },

  create(base?: DeepPartial<StudySpec_StudyStoppingConfig>): StudySpec_StudyStoppingConfig {
    return StudySpec_StudyStoppingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StudySpec_StudyStoppingConfig>): StudySpec_StudyStoppingConfig {
    const message = createBaseStudySpec_StudyStoppingConfig();
    message.shouldStopAsap = object.shouldStopAsap ?? undefined;
    message.minimumRuntimeConstraint =
      (object.minimumRuntimeConstraint !== undefined && object.minimumRuntimeConstraint !== null)
        ? StudyTimeConstraint.fromPartial(object.minimumRuntimeConstraint)
        : undefined;
    message.maximumRuntimeConstraint =
      (object.maximumRuntimeConstraint !== undefined && object.maximumRuntimeConstraint !== null)
        ? StudyTimeConstraint.fromPartial(object.maximumRuntimeConstraint)
        : undefined;
    message.minNumTrials = object.minNumTrials ?? undefined;
    message.maxNumTrials = object.maxNumTrials ?? undefined;
    message.maxNumTrialsNoProgress = object.maxNumTrialsNoProgress ?? undefined;
    message.maxDurationNoProgress =
      (object.maxDurationNoProgress !== undefined && object.maxDurationNoProgress !== null)
        ? Duration.fromPartial(object.maxDurationNoProgress)
        : undefined;
    return message;
  },
};

function createBaseMeasurement(): Measurement {
  return { elapsedDuration: undefined, stepCount: Long.ZERO, metrics: [] };
}

export const Measurement: MessageFns<Measurement> = {
  encode(message: Measurement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.elapsedDuration !== undefined) {
      Duration.encode(message.elapsedDuration, writer.uint32(10).fork()).join();
    }
    if (!message.stepCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.stepCount.toString());
    }
    for (const v of message.metrics) {
      Measurement_Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Measurement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeasurement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elapsedDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stepCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Measurement_Metric.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Measurement {
    return {
      elapsedDuration: isSet(object.elapsedDuration) ? Duration.fromJSON(object.elapsedDuration) : undefined,
      stepCount: isSet(object.stepCount) ? Long.fromValue(object.stepCount) : Long.ZERO,
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => Measurement_Metric.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Measurement): unknown {
    const obj: any = {};
    if (message.elapsedDuration !== undefined) {
      obj.elapsedDuration = Duration.toJSON(message.elapsedDuration);
    }
    if (!message.stepCount.equals(Long.ZERO)) {
      obj.stepCount = (message.stepCount || Long.ZERO).toString();
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Measurement_Metric.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Measurement>): Measurement {
    return Measurement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Measurement>): Measurement {
    const message = createBaseMeasurement();
    message.elapsedDuration = (object.elapsedDuration !== undefined && object.elapsedDuration !== null)
      ? Duration.fromPartial(object.elapsedDuration)
      : undefined;
    message.stepCount = (object.stepCount !== undefined && object.stepCount !== null)
      ? Long.fromValue(object.stepCount)
      : Long.ZERO;
    message.metrics = object.metrics?.map((e) => Measurement_Metric.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMeasurement_Metric(): Measurement_Metric {
  return { metricId: "", value: 0 };
}

export const Measurement_Metric: MessageFns<Measurement_Metric> = {
  encode(message: Measurement_Metric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricId !== "") {
      writer.uint32(10).string(message.metricId);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Measurement_Metric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeasurement_Metric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricId = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Measurement_Metric {
    return {
      metricId: isSet(object.metricId) ? globalThis.String(object.metricId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Measurement_Metric): unknown {
    const obj: any = {};
    if (message.metricId !== "") {
      obj.metricId = message.metricId;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Measurement_Metric>): Measurement_Metric {
    return Measurement_Metric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Measurement_Metric>): Measurement_Metric {
    const message = createBaseMeasurement_Metric();
    message.metricId = object.metricId ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
