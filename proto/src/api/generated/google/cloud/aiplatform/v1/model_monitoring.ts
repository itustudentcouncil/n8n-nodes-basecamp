// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/model_monitoring.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { BigQueryDestination, BigQuerySource, GcsDestination, GcsSource } from "./io.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * The objective configuration for model monitoring, including the information
 * needed to detect anomalies for one particular model.
 */
export interface ModelMonitoringObjectiveConfig {
  /**
   * Training dataset for models. This field has to be set only if
   * TrainingPredictionSkewDetectionConfig is specified.
   */
  trainingDataset:
    | ModelMonitoringObjectiveConfig_TrainingDataset
    | undefined;
  /** The config for skew between training data and prediction data. */
  trainingPredictionSkewDetectionConfig:
    | ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
    | undefined;
  /** The config for drift of prediction data. */
  predictionDriftDetectionConfig:
    | ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig
    | undefined;
  /** The config for integrating with Vertex Explainable AI. */
  explanationConfig: ModelMonitoringObjectiveConfig_ExplanationConfig | undefined;
}

/** Training Dataset information. */
export interface ModelMonitoringObjectiveConfig_TrainingDataset {
  /** The resource name of the Dataset used to train this Model. */
  dataset?:
    | string
    | undefined;
  /**
   * The Google Cloud Storage uri of the unmanaged Dataset used to train
   * this Model.
   */
  gcsSource?:
    | GcsSource
    | undefined;
  /**
   * The BigQuery table of the unmanaged Dataset used to train this
   * Model.
   */
  bigquerySource?:
    | BigQuerySource
    | undefined;
  /**
   * Data format of the dataset, only applicable if the input is from
   * Google Cloud Storage.
   * The possible formats are:
   *
   * "tf-record"
   * The source file is a TFRecord file.
   *
   * "csv"
   * The source file is a CSV file.
   * "jsonl"
   * The source file is a JSONL file.
   */
  dataFormat: string;
  /**
   * The target field name the model is to predict.
   * This field will be excluded when doing Predict and (or) Explain for the
   * training data.
   */
  targetField: string;
  /**
   * Strategy to sample data from Training Dataset.
   * If not set, we process the whole dataset.
   */
  loggingSamplingStrategy: SamplingStrategy | undefined;
}

/**
 * The config for Training & Prediction data skew detection. It specifies the
 * training dataset sources and the skew detection parameters.
 */
export interface ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
  /**
   * Key is the feature name and value is the threshold. If a feature needs to
   * be monitored for skew, a value threshold must be configured for that
   * feature. The threshold here is against feature distribution distance
   * between the training and prediction feature.
   */
  skewThresholds: { [key: string]: ThresholdConfig };
  /**
   * Key is the feature name and value is the threshold. The threshold here is
   * against attribution score distance between the training and prediction
   * feature.
   */
  attributionScoreSkewThresholds: { [key: string]: ThresholdConfig };
  /**
   * Skew anomaly detection threshold used by all features.
   * When the per-feature thresholds are not set, this field can be used to
   * specify a threshold for all features.
   */
  defaultSkewThreshold: ThresholdConfig | undefined;
}

export interface ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
  key: string;
  value: ThresholdConfig | undefined;
}

export interface ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
  key: string;
  value: ThresholdConfig | undefined;
}

/** The config for Prediction data drift detection. */
export interface ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
  /**
   * Key is the feature name and value is the threshold. If a feature needs to
   * be monitored for drift, a value threshold must be configured for that
   * feature. The threshold here is against feature distribution distance
   * between different time windws.
   */
  driftThresholds: { [key: string]: ThresholdConfig };
  /**
   * Key is the feature name and value is the threshold. The threshold here is
   * against attribution score distance between different time windows.
   */
  attributionScoreDriftThresholds: { [key: string]: ThresholdConfig };
  /**
   * Drift anomaly detection threshold used by all features.
   * When the per-feature thresholds are not set, this field can be used to
   * specify a threshold for all features.
   */
  defaultDriftThreshold: ThresholdConfig | undefined;
}

export interface ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
  key: string;
  value: ThresholdConfig | undefined;
}

export interface ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
  key: string;
  value: ThresholdConfig | undefined;
}

/**
 * The config for integrating with Vertex Explainable AI. Only applicable if
 * the Model has explanation_spec populated.
 */
export interface ModelMonitoringObjectiveConfig_ExplanationConfig {
  /**
   * If want to analyze the Vertex Explainable AI feature attribute scores or
   * not. If set to true, Vertex AI will log the feature attributions from
   * explain response and do the skew/drift detection for them.
   */
  enableFeatureAttributes: boolean;
  /** Predictions generated by the BatchPredictionJob using baseline dataset. */
  explanationBaseline: ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline | undefined;
}

/**
 * Output from
 * [BatchPredictionJob][google.cloud.aiplatform.v1.BatchPredictionJob] for
 * Model Monitoring baseline dataset, which can be used to generate baseline
 * attribution scores.
 */
export interface ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
  /** Cloud Storage location for BatchExplain output. */
  gcs?:
    | GcsDestination
    | undefined;
  /** BigQuery location for BatchExplain output. */
  bigquery?:
    | BigQueryDestination
    | undefined;
  /** The storage format of the predictions generated BatchPrediction job. */
  predictionFormat: ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat;
}

/** The storage format of the predictions generated BatchPrediction job. */
export enum ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat {
  /** PREDICTION_FORMAT_UNSPECIFIED - Should not be set. */
  PREDICTION_FORMAT_UNSPECIFIED = 0,
  /** JSONL - Predictions are in JSONL files. */
  JSONL = 2,
  /** BIGQUERY - Predictions are in BigQuery. */
  BIGQUERY = 3,
  UNRECOGNIZED = -1,
}

export function modelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormatFromJSON(
  object: any,
): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat {
  switch (object) {
    case 0:
    case "PREDICTION_FORMAT_UNSPECIFIED":
      return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
        .PREDICTION_FORMAT_UNSPECIFIED;
    case 2:
    case "JSONL":
      return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.JSONL;
    case 3:
    case "BIGQUERY":
      return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.BIGQUERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.UNRECOGNIZED;
  }
}

export function modelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormatToJSON(
  object: ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat,
): string {
  switch (object) {
    case ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
      .PREDICTION_FORMAT_UNSPECIFIED:
      return "PREDICTION_FORMAT_UNSPECIFIED";
    case ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.JSONL:
      return "JSONL";
    case ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.BIGQUERY:
      return "BIGQUERY";
    case ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The alert config for model monitoring. */
export interface ModelMonitoringAlertConfig {
  /** Email alert config. */
  emailAlertConfig?:
    | ModelMonitoringAlertConfig_EmailAlertConfig
    | undefined;
  /**
   * Dump the anomalies to Cloud Logging. The anomalies will be put to json
   * payload encoded from proto
   * [google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry][].
   * This can be further sinked to Pub/Sub or any other services supported
   * by Cloud Logging.
   */
  enableLogging: boolean;
  /**
   * Resource names of the NotificationChannels to send alert.
   * Must be of the format
   * `projects/<project_id_or_number>/notificationChannels/<channel_id>`
   */
  notificationChannels: string[];
}

/** The config for email alert. */
export interface ModelMonitoringAlertConfig_EmailAlertConfig {
  /** The email addresses to send the alert. */
  userEmails: string[];
}

/** The config for feature monitoring threshold. */
export interface ThresholdConfig {
  /**
   * Specify a threshold value that can trigger the alert.
   * If this threshold config is for feature distribution distance:
   *   1. For categorical feature, the distribution distance is calculated by
   *      L-inifinity norm.
   *   2. For numerical feature, the distribution distance is calculated by
   *      Jensen–Shannon divergence.
   * Each feature must have a non-zero threshold if they need to be monitored.
   * Otherwise no alert will be triggered for that feature.
   */
  value?: number | undefined;
}

/**
 * Sampling Strategy for logging, can be for both training and prediction
 * dataset.
 */
export interface SamplingStrategy {
  /** Random sample config. Will support more sampling strategies later. */
  randomSampleConfig: SamplingStrategy_RandomSampleConfig | undefined;
}

/** Requests are randomly selected. */
export interface SamplingStrategy_RandomSampleConfig {
  /** Sample rate (0, 1] */
  sampleRate: number;
}

function createBaseModelMonitoringObjectiveConfig(): ModelMonitoringObjectiveConfig {
  return {
    trainingDataset: undefined,
    trainingPredictionSkewDetectionConfig: undefined,
    predictionDriftDetectionConfig: undefined,
    explanationConfig: undefined,
  };
}

export const ModelMonitoringObjectiveConfig: MessageFns<ModelMonitoringObjectiveConfig> = {
  encode(message: ModelMonitoringObjectiveConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trainingDataset !== undefined) {
      ModelMonitoringObjectiveConfig_TrainingDataset.encode(message.trainingDataset, writer.uint32(10).fork()).join();
    }
    if (message.trainingPredictionSkewDetectionConfig !== undefined) {
      ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.encode(
        message.trainingPredictionSkewDetectionConfig,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.predictionDriftDetectionConfig !== undefined) {
      ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.encode(
        message.predictionDriftDetectionConfig,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.explanationConfig !== undefined) {
      ModelMonitoringObjectiveConfig_ExplanationConfig.encode(message.explanationConfig, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trainingDataset = ModelMonitoringObjectiveConfig_TrainingDataset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainingPredictionSkewDetectionConfig =
            ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.predictionDriftDetectionConfig = ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.explanationConfig = ModelMonitoringObjectiveConfig_ExplanationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig {
    return {
      trainingDataset: isSet(object.trainingDataset)
        ? ModelMonitoringObjectiveConfig_TrainingDataset.fromJSON(object.trainingDataset)
        : undefined,
      trainingPredictionSkewDetectionConfig: isSet(object.trainingPredictionSkewDetectionConfig)
        ? ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromJSON(
          object.trainingPredictionSkewDetectionConfig,
        )
        : undefined,
      predictionDriftDetectionConfig: isSet(object.predictionDriftDetectionConfig)
        ? ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromJSON(object.predictionDriftDetectionConfig)
        : undefined,
      explanationConfig: isSet(object.explanationConfig)
        ? ModelMonitoringObjectiveConfig_ExplanationConfig.fromJSON(object.explanationConfig)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig): unknown {
    const obj: any = {};
    if (message.trainingDataset !== undefined) {
      obj.trainingDataset = ModelMonitoringObjectiveConfig_TrainingDataset.toJSON(message.trainingDataset);
    }
    if (message.trainingPredictionSkewDetectionConfig !== undefined) {
      obj.trainingPredictionSkewDetectionConfig = ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
        .toJSON(message.trainingPredictionSkewDetectionConfig);
    }
    if (message.predictionDriftDetectionConfig !== undefined) {
      obj.predictionDriftDetectionConfig = ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.toJSON(
        message.predictionDriftDetectionConfig,
      );
    }
    if (message.explanationConfig !== undefined) {
      obj.explanationConfig = ModelMonitoringObjectiveConfig_ExplanationConfig.toJSON(message.explanationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringObjectiveConfig>): ModelMonitoringObjectiveConfig {
    return ModelMonitoringObjectiveConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringObjectiveConfig>): ModelMonitoringObjectiveConfig {
    const message = createBaseModelMonitoringObjectiveConfig();
    message.trainingDataset = (object.trainingDataset !== undefined && object.trainingDataset !== null)
      ? ModelMonitoringObjectiveConfig_TrainingDataset.fromPartial(object.trainingDataset)
      : undefined;
    message.trainingPredictionSkewDetectionConfig =
      (object.trainingPredictionSkewDetectionConfig !== undefined &&
          object.trainingPredictionSkewDetectionConfig !== null)
        ? ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromPartial(
          object.trainingPredictionSkewDetectionConfig,
        )
        : undefined;
    message.predictionDriftDetectionConfig =
      (object.predictionDriftDetectionConfig !== undefined && object.predictionDriftDetectionConfig !== null)
        ? ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromPartial(
          object.predictionDriftDetectionConfig,
        )
        : undefined;
    message.explanationConfig = (object.explanationConfig !== undefined && object.explanationConfig !== null)
      ? ModelMonitoringObjectiveConfig_ExplanationConfig.fromPartial(object.explanationConfig)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_TrainingDataset(): ModelMonitoringObjectiveConfig_TrainingDataset {
  return {
    dataset: undefined,
    gcsSource: undefined,
    bigquerySource: undefined,
    dataFormat: "",
    targetField: "",
    loggingSamplingStrategy: undefined,
  };
}

export const ModelMonitoringObjectiveConfig_TrainingDataset: MessageFns<
  ModelMonitoringObjectiveConfig_TrainingDataset
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_TrainingDataset,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.dataset !== undefined) {
      writer.uint32(26).string(message.dataset);
    }
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(34).fork()).join();
    }
    if (message.bigquerySource !== undefined) {
      BigQuerySource.encode(message.bigquerySource, writer.uint32(42).fork()).join();
    }
    if (message.dataFormat !== "") {
      writer.uint32(18).string(message.dataFormat);
    }
    if (message.targetField !== "") {
      writer.uint32(50).string(message.targetField);
    }
    if (message.loggingSamplingStrategy !== undefined) {
      SamplingStrategy.encode(message.loggingSamplingStrategy, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveConfig_TrainingDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_TrainingDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bigquerySource = BigQuerySource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataFormat = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetField = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.loggingSamplingStrategy = SamplingStrategy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_TrainingDataset {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : undefined,
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      bigquerySource: isSet(object.bigquerySource) ? BigQuerySource.fromJSON(object.bigquerySource) : undefined,
      dataFormat: isSet(object.dataFormat) ? globalThis.String(object.dataFormat) : "",
      targetField: isSet(object.targetField) ? globalThis.String(object.targetField) : "",
      loggingSamplingStrategy: isSet(object.loggingSamplingStrategy)
        ? SamplingStrategy.fromJSON(object.loggingSamplingStrategy)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_TrainingDataset): unknown {
    const obj: any = {};
    if (message.dataset !== undefined) {
      obj.dataset = message.dataset;
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.bigquerySource !== undefined) {
      obj.bigquerySource = BigQuerySource.toJSON(message.bigquerySource);
    }
    if (message.dataFormat !== "") {
      obj.dataFormat = message.dataFormat;
    }
    if (message.targetField !== "") {
      obj.targetField = message.targetField;
    }
    if (message.loggingSamplingStrategy !== undefined) {
      obj.loggingSamplingStrategy = SamplingStrategy.toJSON(message.loggingSamplingStrategy);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_TrainingDataset>,
  ): ModelMonitoringObjectiveConfig_TrainingDataset {
    return ModelMonitoringObjectiveConfig_TrainingDataset.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_TrainingDataset>,
  ): ModelMonitoringObjectiveConfig_TrainingDataset {
    const message = createBaseModelMonitoringObjectiveConfig_TrainingDataset();
    message.dataset = object.dataset ?? undefined;
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.bigquerySource = (object.bigquerySource !== undefined && object.bigquerySource !== null)
      ? BigQuerySource.fromPartial(object.bigquerySource)
      : undefined;
    message.dataFormat = object.dataFormat ?? "";
    message.targetField = object.targetField ?? "";
    message.loggingSamplingStrategy =
      (object.loggingSamplingStrategy !== undefined && object.loggingSamplingStrategy !== null)
        ? SamplingStrategy.fromPartial(object.loggingSamplingStrategy)
        : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig(): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
  return { skewThresholds: {}, attributionScoreSkewThresholds: {}, defaultSkewThreshold: undefined };
}

export const ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig: MessageFns<
  ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.skewThresholds).forEach(([key, value]) => {
      ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry.encode({
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.attributionScoreSkewThresholds).forEach(([key, value]) => {
      ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry.encode({
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    if (message.defaultSkewThreshold !== undefined) {
      ThresholdConfig.encode(message.defaultSkewThreshold, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry
            .decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.skewThresholds[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 =
            ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry
              .decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributionScoreSkewThresholds[entry2.key] = entry2.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.defaultSkewThreshold = ThresholdConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
    return {
      skewThresholds: isObject(object.skewThresholds)
        ? Object.entries(object.skewThresholds).reduce<{ [key: string]: ThresholdConfig }>((acc, [key, value]) => {
          acc[key] = ThresholdConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      attributionScoreSkewThresholds: isObject(object.attributionScoreSkewThresholds)
        ? Object.entries(object.attributionScoreSkewThresholds).reduce<{ [key: string]: ThresholdConfig }>(
          (acc, [key, value]) => {
            acc[key] = ThresholdConfig.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      defaultSkewThreshold: isSet(object.defaultSkewThreshold)
        ? ThresholdConfig.fromJSON(object.defaultSkewThreshold)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig): unknown {
    const obj: any = {};
    if (message.skewThresholds) {
      const entries = Object.entries(message.skewThresholds);
      if (entries.length > 0) {
        obj.skewThresholds = {};
        entries.forEach(([k, v]) => {
          obj.skewThresholds[k] = ThresholdConfig.toJSON(v);
        });
      }
    }
    if (message.attributionScoreSkewThresholds) {
      const entries = Object.entries(message.attributionScoreSkewThresholds);
      if (entries.length > 0) {
        obj.attributionScoreSkewThresholds = {};
        entries.forEach(([k, v]) => {
          obj.attributionScoreSkewThresholds[k] = ThresholdConfig.toJSON(v);
        });
      }
    }
    if (message.defaultSkewThreshold !== undefined) {
      obj.defaultSkewThreshold = ThresholdConfig.toJSON(message.defaultSkewThreshold);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig>,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
    return ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig>,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig {
    const message = createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig();
    message.skewThresholds = Object.entries(object.skewThresholds ?? {}).reduce<{ [key: string]: ThresholdConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ThresholdConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.attributionScoreSkewThresholds = Object.entries(object.attributionScoreSkewThresholds ?? {}).reduce<
      { [key: string]: ThresholdConfig }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ThresholdConfig.fromPartial(value);
      }
      return acc;
    }, {});
    message.defaultSkewThreshold = (object.defaultSkewThreshold !== undefined && object.defaultSkewThreshold !== null)
      ? ThresholdConfig.fromPartial(object.defaultSkewThreshold)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry(): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry: MessageFns<
  ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThresholdConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThresholdConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ThresholdConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ThresholdConfig.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry>,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
    return ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry.fromPartial(
      base ?? {},
    );
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry>,
  ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry {
    const message =
      createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_SkewThresholdsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThresholdConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry(): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry:
  MessageFns<ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry> =
    {
      encode(
        message:
          ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry,
        writer: BinaryWriter = new BinaryWriter(),
      ): BinaryWriter {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
          ThresholdConfig.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },

      decode(
        input: BinaryReader | Uint8Array,
        length?: number,
      ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message =
          createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (tag !== 10) {
                break;
              }

              message.key = reader.string();
              continue;
            case 2:
              if (tag !== 18) {
                break;
              }

              message.value = ThresholdConfig.decode(reader, reader.uint32());
              continue;
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },

      fromJSON(
        object: any,
      ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
        return {
          key: isSet(object.key) ? globalThis.String(object.key) : "",
          value: isSet(object.value) ? ThresholdConfig.fromJSON(object.value) : undefined,
        };
      },

      toJSON(
        message:
          ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry,
      ): unknown {
        const obj: any = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== undefined) {
          obj.value = ThresholdConfig.toJSON(message.value);
        }
        return obj;
      },

      create(
        base?: DeepPartial<
          ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry
        >,
      ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
        return ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry
          .fromPartial(base ?? {});
      },
      fromPartial(
        object: DeepPartial<
          ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry
        >,
      ): ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry {
        const message =
          createBaseModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig_AttributionScoreSkewThresholdsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
          ? ThresholdConfig.fromPartial(object.value)
          : undefined;
        return message;
      },
    };

function createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig(): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
  return { driftThresholds: {}, attributionScoreDriftThresholds: {}, defaultDriftThreshold: undefined };
}

export const ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig: MessageFns<
  ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.driftThresholds).forEach(([key, value]) => {
      ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry.encode({
        key: key as any,
        value,
      }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.attributionScoreDriftThresholds).forEach(([key, value]) => {
      ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry.encode({
        key: key as any,
        value,
      }, writer.uint32(18).fork()).join();
    });
    if (message.defaultDriftThreshold !== undefined) {
      ThresholdConfig.encode(message.defaultDriftThreshold, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.driftThresholds[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 =
            ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry.decode(
              reader,
              reader.uint32(),
            );
          if (entry2.value !== undefined) {
            message.attributionScoreDriftThresholds[entry2.key] = entry2.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultDriftThreshold = ThresholdConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
    return {
      driftThresholds: isObject(object.driftThresholds)
        ? Object.entries(object.driftThresholds).reduce<{ [key: string]: ThresholdConfig }>((acc, [key, value]) => {
          acc[key] = ThresholdConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      attributionScoreDriftThresholds: isObject(object.attributionScoreDriftThresholds)
        ? Object.entries(object.attributionScoreDriftThresholds).reduce<{ [key: string]: ThresholdConfig }>(
          (acc, [key, value]) => {
            acc[key] = ThresholdConfig.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      defaultDriftThreshold: isSet(object.defaultDriftThreshold)
        ? ThresholdConfig.fromJSON(object.defaultDriftThreshold)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig): unknown {
    const obj: any = {};
    if (message.driftThresholds) {
      const entries = Object.entries(message.driftThresholds);
      if (entries.length > 0) {
        obj.driftThresholds = {};
        entries.forEach(([k, v]) => {
          obj.driftThresholds[k] = ThresholdConfig.toJSON(v);
        });
      }
    }
    if (message.attributionScoreDriftThresholds) {
      const entries = Object.entries(message.attributionScoreDriftThresholds);
      if (entries.length > 0) {
        obj.attributionScoreDriftThresholds = {};
        entries.forEach(([k, v]) => {
          obj.attributionScoreDriftThresholds[k] = ThresholdConfig.toJSON(v);
        });
      }
    }
    if (message.defaultDriftThreshold !== undefined) {
      obj.defaultDriftThreshold = ThresholdConfig.toJSON(message.defaultDriftThreshold);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig>,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
    return ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig>,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig {
    const message = createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig();
    message.driftThresholds = Object.entries(object.driftThresholds ?? {}).reduce<{ [key: string]: ThresholdConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ThresholdConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.attributionScoreDriftThresholds = Object.entries(object.attributionScoreDriftThresholds ?? {}).reduce<
      { [key: string]: ThresholdConfig }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ThresholdConfig.fromPartial(value);
      }
      return acc;
    }, {});
    message.defaultDriftThreshold =
      (object.defaultDriftThreshold !== undefined && object.defaultDriftThreshold !== null)
        ? ThresholdConfig.fromPartial(object.defaultDriftThreshold)
        : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry(): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry: MessageFns<
  ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ThresholdConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ThresholdConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ThresholdConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ThresholdConfig.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry>,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
    return ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry>,
  ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry {
    const message = createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_DriftThresholdsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ThresholdConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry(): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry:
  MessageFns<ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry> = {
    encode(
      message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        ThresholdConfig.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = ThresholdConfig.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? ThresholdConfig.fromJSON(object.value) : undefined,
      };
    },

    toJSON(
      message: ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry,
    ): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = ThresholdConfig.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<
        ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry
      >,
    ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
      return ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry
        .fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<
        ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry
      >,
    ): ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry {
      const message =
        createBaseModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig_AttributionScoreDriftThresholdsEntry();
      message.key = object.key ?? "";
      message.value = (object.value !== undefined && object.value !== null)
        ? ThresholdConfig.fromPartial(object.value)
        : undefined;
      return message;
    },
  };

function createBaseModelMonitoringObjectiveConfig_ExplanationConfig(): ModelMonitoringObjectiveConfig_ExplanationConfig {
  return { enableFeatureAttributes: false, explanationBaseline: undefined };
}

export const ModelMonitoringObjectiveConfig_ExplanationConfig: MessageFns<
  ModelMonitoringObjectiveConfig_ExplanationConfig
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_ExplanationConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enableFeatureAttributes !== false) {
      writer.uint32(8).bool(message.enableFeatureAttributes);
    }
    if (message.explanationBaseline !== undefined) {
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.encode(
        message.explanationBaseline,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveConfig_ExplanationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_ExplanationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableFeatureAttributes = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanationBaseline = ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_ExplanationConfig {
    return {
      enableFeatureAttributes: isSet(object.enableFeatureAttributes)
        ? globalThis.Boolean(object.enableFeatureAttributes)
        : false,
      explanationBaseline: isSet(object.explanationBaseline)
        ? ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromJSON(object.explanationBaseline)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_ExplanationConfig): unknown {
    const obj: any = {};
    if (message.enableFeatureAttributes !== false) {
      obj.enableFeatureAttributes = message.enableFeatureAttributes;
    }
    if (message.explanationBaseline !== undefined) {
      obj.explanationBaseline = ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.toJSON(
        message.explanationBaseline,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_ExplanationConfig>,
  ): ModelMonitoringObjectiveConfig_ExplanationConfig {
    return ModelMonitoringObjectiveConfig_ExplanationConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_ExplanationConfig>,
  ): ModelMonitoringObjectiveConfig_ExplanationConfig {
    const message = createBaseModelMonitoringObjectiveConfig_ExplanationConfig();
    message.enableFeatureAttributes = object.enableFeatureAttributes ?? false;
    message.explanationBaseline = (object.explanationBaseline !== undefined && object.explanationBaseline !== null)
      ? ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromPartial(object.explanationBaseline)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline(): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
  return { gcs: undefined, bigquery: undefined, predictionFormat: 0 };
}

export const ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline: MessageFns<
  ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline
> = {
  encode(
    message: ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gcs !== undefined) {
      GcsDestination.encode(message.gcs, writer.uint32(18).fork()).join();
    }
    if (message.bigquery !== undefined) {
      BigQueryDestination.encode(message.bigquery, writer.uint32(26).fork()).join();
    }
    if (message.predictionFormat !== 0) {
      writer.uint32(8).int32(message.predictionFormat);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcs = GcsDestination.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bigquery = BigQueryDestination.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.predictionFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
    return {
      gcs: isSet(object.gcs) ? GcsDestination.fromJSON(object.gcs) : undefined,
      bigquery: isSet(object.bigquery) ? BigQueryDestination.fromJSON(object.bigquery) : undefined,
      predictionFormat: isSet(object.predictionFormat)
        ? modelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormatFromJSON(
          object.predictionFormat,
        )
        : 0,
    };
  },

  toJSON(message: ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline): unknown {
    const obj: any = {};
    if (message.gcs !== undefined) {
      obj.gcs = GcsDestination.toJSON(message.gcs);
    }
    if (message.bigquery !== undefined) {
      obj.bigquery = BigQueryDestination.toJSON(message.bigquery);
    }
    if (message.predictionFormat !== 0) {
      obj.predictionFormat =
        modelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormatToJSON(
          message.predictionFormat,
        );
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline>,
  ): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
    return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline>,
  ): ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline {
    const message = createBaseModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline();
    message.gcs = (object.gcs !== undefined && object.gcs !== null)
      ? GcsDestination.fromPartial(object.gcs)
      : undefined;
    message.bigquery = (object.bigquery !== undefined && object.bigquery !== null)
      ? BigQueryDestination.fromPartial(object.bigquery)
      : undefined;
    message.predictionFormat = object.predictionFormat ?? 0;
    return message;
  },
};

function createBaseModelMonitoringAlertConfig(): ModelMonitoringAlertConfig {
  return { emailAlertConfig: undefined, enableLogging: false, notificationChannels: [] };
}

export const ModelMonitoringAlertConfig: MessageFns<ModelMonitoringAlertConfig> = {
  encode(message: ModelMonitoringAlertConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAlertConfig !== undefined) {
      ModelMonitoringAlertConfig_EmailAlertConfig.encode(message.emailAlertConfig, writer.uint32(10).fork()).join();
    }
    if (message.enableLogging !== false) {
      writer.uint32(16).bool(message.enableLogging);
    }
    for (const v of message.notificationChannels) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringAlertConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringAlertConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailAlertConfig = ModelMonitoringAlertConfig_EmailAlertConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableLogging = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notificationChannels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringAlertConfig {
    return {
      emailAlertConfig: isSet(object.emailAlertConfig)
        ? ModelMonitoringAlertConfig_EmailAlertConfig.fromJSON(object.emailAlertConfig)
        : undefined,
      enableLogging: isSet(object.enableLogging) ? globalThis.Boolean(object.enableLogging) : false,
      notificationChannels: globalThis.Array.isArray(object?.notificationChannels)
        ? object.notificationChannels.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelMonitoringAlertConfig): unknown {
    const obj: any = {};
    if (message.emailAlertConfig !== undefined) {
      obj.emailAlertConfig = ModelMonitoringAlertConfig_EmailAlertConfig.toJSON(message.emailAlertConfig);
    }
    if (message.enableLogging !== false) {
      obj.enableLogging = message.enableLogging;
    }
    if (message.notificationChannels?.length) {
      obj.notificationChannels = message.notificationChannels;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringAlertConfig>): ModelMonitoringAlertConfig {
    return ModelMonitoringAlertConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringAlertConfig>): ModelMonitoringAlertConfig {
    const message = createBaseModelMonitoringAlertConfig();
    message.emailAlertConfig = (object.emailAlertConfig !== undefined && object.emailAlertConfig !== null)
      ? ModelMonitoringAlertConfig_EmailAlertConfig.fromPartial(object.emailAlertConfig)
      : undefined;
    message.enableLogging = object.enableLogging ?? false;
    message.notificationChannels = object.notificationChannels?.map((e) => e) || [];
    return message;
  },
};

function createBaseModelMonitoringAlertConfig_EmailAlertConfig(): ModelMonitoringAlertConfig_EmailAlertConfig {
  return { userEmails: [] };
}

export const ModelMonitoringAlertConfig_EmailAlertConfig: MessageFns<ModelMonitoringAlertConfig_EmailAlertConfig> = {
  encode(
    message: ModelMonitoringAlertConfig_EmailAlertConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.userEmails) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringAlertConfig_EmailAlertConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringAlertConfig_EmailAlertConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userEmails.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringAlertConfig_EmailAlertConfig {
    return {
      userEmails: globalThis.Array.isArray(object?.userEmails)
        ? object.userEmails.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelMonitoringAlertConfig_EmailAlertConfig): unknown {
    const obj: any = {};
    if (message.userEmails?.length) {
      obj.userEmails = message.userEmails;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringAlertConfig_EmailAlertConfig>): ModelMonitoringAlertConfig_EmailAlertConfig {
    return ModelMonitoringAlertConfig_EmailAlertConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringAlertConfig_EmailAlertConfig>,
  ): ModelMonitoringAlertConfig_EmailAlertConfig {
    const message = createBaseModelMonitoringAlertConfig_EmailAlertConfig();
    message.userEmails = object.userEmails?.map((e) => e) || [];
    return message;
  },
};

function createBaseThresholdConfig(): ThresholdConfig {
  return { value: undefined };
}

export const ThresholdConfig: MessageFns<ThresholdConfig> = {
  encode(message: ThresholdConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThresholdConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThresholdConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThresholdConfig {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : undefined };
  },

  toJSON(message: ThresholdConfig): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ThresholdConfig>): ThresholdConfig {
    return ThresholdConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThresholdConfig>): ThresholdConfig {
    const message = createBaseThresholdConfig();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSamplingStrategy(): SamplingStrategy {
  return { randomSampleConfig: undefined };
}

export const SamplingStrategy: MessageFns<SamplingStrategy> = {
  encode(message: SamplingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.randomSampleConfig !== undefined) {
      SamplingStrategy_RandomSampleConfig.encode(message.randomSampleConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamplingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.randomSampleConfig = SamplingStrategy_RandomSampleConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingStrategy {
    return {
      randomSampleConfig: isSet(object.randomSampleConfig)
        ? SamplingStrategy_RandomSampleConfig.fromJSON(object.randomSampleConfig)
        : undefined,
    };
  },

  toJSON(message: SamplingStrategy): unknown {
    const obj: any = {};
    if (message.randomSampleConfig !== undefined) {
      obj.randomSampleConfig = SamplingStrategy_RandomSampleConfig.toJSON(message.randomSampleConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SamplingStrategy>): SamplingStrategy {
    return SamplingStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SamplingStrategy>): SamplingStrategy {
    const message = createBaseSamplingStrategy();
    message.randomSampleConfig = (object.randomSampleConfig !== undefined && object.randomSampleConfig !== null)
      ? SamplingStrategy_RandomSampleConfig.fromPartial(object.randomSampleConfig)
      : undefined;
    return message;
  },
};

function createBaseSamplingStrategy_RandomSampleConfig(): SamplingStrategy_RandomSampleConfig {
  return { sampleRate: 0 };
}

export const SamplingStrategy_RandomSampleConfig: MessageFns<SamplingStrategy_RandomSampleConfig> = {
  encode(message: SamplingStrategy_RandomSampleConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleRate !== 0) {
      writer.uint32(9).double(message.sampleRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SamplingStrategy_RandomSampleConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSamplingStrategy_RandomSampleConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.sampleRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SamplingStrategy_RandomSampleConfig {
    return { sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0 };
  },

  toJSON(message: SamplingStrategy_RandomSampleConfig): unknown {
    const obj: any = {};
    if (message.sampleRate !== 0) {
      obj.sampleRate = message.sampleRate;
    }
    return obj;
  },

  create(base?: DeepPartial<SamplingStrategy_RandomSampleConfig>): SamplingStrategy_RandomSampleConfig {
    return SamplingStrategy_RandomSampleConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SamplingStrategy_RandomSampleConfig>): SamplingStrategy_RandomSampleConfig {
    const message = createBaseSamplingStrategy_RandomSampleConfig();
    message.sampleRate = object.sampleRate ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
