// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/model_monitoring_spec.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Interval } from "../../../type/interval.js";
import { ExplanationSpec } from "./explanation.js";
import { GcsDestination } from "./io.js";
import { BatchDedicatedResources } from "./machine_resources.js";
import { ModelMonitoringAlertCondition } from "./model_monitoring_alert.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Monitoring monitoring job spec. It outlines the specifications for monitoring
 * objectives, notifications, and result exports.
 */
export interface ModelMonitoringSpec {
  /** The monitoring objective spec. */
  objectiveSpec:
    | ModelMonitoringObjectiveSpec
    | undefined;
  /** The model monitoring notification spec. */
  notificationSpec:
    | ModelMonitoringNotificationSpec
    | undefined;
  /** The Output destination spec for metrics, error logs, etc. */
  outputSpec: ModelMonitoringOutputSpec | undefined;
}

/** Monitoring objectives spec. */
export interface ModelMonitoringObjectiveSpec {
  /** Tabular monitoring objective. */
  tabularObjective?:
    | ModelMonitoringObjectiveSpec_TabularObjective
    | undefined;
  /**
   * The explanation spec.
   * This spec is required when the objectives spec includes feature attribution
   * objectives.
   */
  explanationSpec:
    | ExplanationSpec
    | undefined;
  /**
   * Baseline dataset.
   * It could be the training dataset or production serving dataset from a
   * previous period.
   */
  baselineDataset:
    | ModelMonitoringInput
    | undefined;
  /** Target dataset. */
  targetDataset: ModelMonitoringInput | undefined;
}

/**
 * Data drift monitoring spec.
 * Data drift measures the distribution distance between the current dataset
 * and a baseline dataset. A typical use case is to detect data drift between
 * the recent production serving dataset and the training dataset, or to
 * compare the recent production dataset with a dataset from a previous
 * period.
 */
export interface ModelMonitoringObjectiveSpec_DataDriftSpec {
  /**
   * Feature names / Prediction output names interested in monitoring.
   * These should be a subset of the input feature names or prediction output
   * names specified in the monitoring schema.
   * If the field is not specified all features / prediction outputs outlied
   * in the monitoring schema will be used.
   */
  features: string[];
  /**
   * Supported metrics type:
   *  * l_infinity
   *  * jensen_shannon_divergence
   */
  categoricalMetricType: string;
  /**
   * Supported metrics type:
   *  * jensen_shannon_divergence
   */
  numericMetricType: string;
  /** Default alert condition for all the categorical features. */
  defaultCategoricalAlertCondition:
    | ModelMonitoringAlertCondition
    | undefined;
  /** Default alert condition for all the numeric features. */
  defaultNumericAlertCondition:
    | ModelMonitoringAlertCondition
    | undefined;
  /** Per feature alert condition will override default alert condition. */
  featureAlertConditions: { [key: string]: ModelMonitoringAlertCondition };
}

export interface ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
  key: string;
  value: ModelMonitoringAlertCondition | undefined;
}

/** Feature attribution monitoring spec. */
export interface ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
  /**
   * Feature names interested in monitoring.
   * These should be a subset of the input feature names specified in the
   * monitoring schema. If the field is not specified all features outlied in
   * the monitoring schema will be used.
   */
  features: string[];
  /** Default alert condition for all the features. */
  defaultAlertCondition:
    | ModelMonitoringAlertCondition
    | undefined;
  /** Per feature alert condition will override default alert condition. */
  featureAlertConditions: { [key: string]: ModelMonitoringAlertCondition };
  /**
   * The config of resources used by the Model Monitoring during the batch
   * explanation for non-AutoML models. If not set, `n1-standard-2` machine
   * type will be used by default.
   */
  batchExplanationDedicatedResources: BatchDedicatedResources | undefined;
}

export interface ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
  key: string;
  value: ModelMonitoringAlertCondition | undefined;
}

/** Tabular monitoring objective. */
export interface ModelMonitoringObjectiveSpec_TabularObjective {
  /** Input feature distribution drift monitoring spec. */
  featureDriftSpec:
    | ModelMonitoringObjectiveSpec_DataDriftSpec
    | undefined;
  /** Prediction output distribution drift monitoring spec. */
  predictionOutputDriftSpec:
    | ModelMonitoringObjectiveSpec_DataDriftSpec
    | undefined;
  /** Feature attribution monitoring spec. */
  featureAttributionSpec: ModelMonitoringObjectiveSpec_FeatureAttributionSpec | undefined;
}

/**
 * Specification for the export destination of monitoring results, including
 * metrics, logs, etc.
 */
export interface ModelMonitoringOutputSpec {
  /** Google Cloud Storage base folder path for metrics, error logs, etc. */
  gcsBaseDirectory: GcsDestination | undefined;
}

/** Model monitoring data input spec. */
export interface ModelMonitoringInput {
  /** Columnized dataset. */
  columnizedDataset?:
    | ModelMonitoringInput_ModelMonitoringDataset
    | undefined;
  /** Vertex AI Batch prediction Job. */
  batchPredictionOutput?:
    | ModelMonitoringInput_BatchPredictionOutput
    | undefined;
  /** Vertex AI Endpoint request & response logging. */
  vertexEndpointLogs?:
    | ModelMonitoringInput_VertexEndpointLogs
    | undefined;
  /**
   * The time interval (pair of start_time and end_time) for which results
   * should be returned.
   */
  timeInterval?:
    | Interval
    | undefined;
  /** The time offset setting for which results should be returned. */
  timeOffset?: ModelMonitoringInput_TimeOffset | undefined;
}

/** Input dataset spec. */
export interface ModelMonitoringInput_ModelMonitoringDataset {
  /** Resource name of the Vertex AI managed dataset. */
  vertexDataset?:
    | string
    | undefined;
  /** Google Cloud Storage data source. */
  gcsSource?:
    | ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource
    | undefined;
  /** BigQuery data source. */
  bigquerySource?:
    | ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource
    | undefined;
  /** The timestamp field. Usually for serving data. */
  timestampField: string;
}

/** Dataset spec for data stored in Google Cloud Storage. */
export interface ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
  /**
   * Google Cloud Storage URI to the input file(s). May contain
   * wildcards. For more information on wildcards, see
   * https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
   */
  gcsUri: string;
  /** Data format of the dataset. */
  format: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat;
}

/** Supported data format. */
export enum ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat {
  /** DATA_FORMAT_UNSPECIFIED - Data format unspecified, used when this field is unset. */
  DATA_FORMAT_UNSPECIFIED = 0,
  /** CSV - CSV files. */
  CSV = 1,
  /** TF_RECORD - TfRecord files */
  TF_RECORD = 2,
  /** JSONL - JsonL files. */
  JSONL = 3,
  UNRECOGNIZED = -1,
}

export function modelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormatFromJSON(
  object: any,
): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "CSV":
      return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.CSV;
    case 2:
    case "TF_RECORD":
      return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.TF_RECORD;
    case 3:
    case "JSONL":
      return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.JSONL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.UNRECOGNIZED;
  }
}

export function modelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormatToJSON(
  object: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat,
): string {
  switch (object) {
    case ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.DATA_FORMAT_UNSPECIFIED:
      return "DATA_FORMAT_UNSPECIFIED";
    case ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.CSV:
      return "CSV";
    case ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.TF_RECORD:
      return "TF_RECORD";
    case ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.JSONL:
      return "JSONL";
    case ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Dataset spec for data sotred in BigQuery. */
export interface ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
  /**
   * BigQuery URI to a table, up to 2000 characters long. All the columns
   * in the table will be selected. Accepted forms:
   *
   * *  BigQuery path. For example:
   * `bq://projectId.bqDatasetId.bqTableId`.
   */
  tableUri?:
    | string
    | undefined;
  /** Standard SQL to be used instead of the `table_uri`. */
  query?: string | undefined;
}

/** Data from Vertex AI Batch prediction job output. */
export interface ModelMonitoringInput_BatchPredictionOutput {
  /**
   * Vertex AI Batch prediction job resource name. The job must match the
   * model version specified in [ModelMonitor].[model_monitoring_target].
   */
  batchPredictionJob: string;
}

/** Data from Vertex AI Endpoint request response logging. */
export interface ModelMonitoringInput_VertexEndpointLogs {
  /**
   * List of endpoint resource names. The endpoints must enable the logging
   * with the [Endpoint].[request_response_logging_config], and must contain
   * the deployed model corresponding to the model version specified in
   * [ModelMonitor].[model_monitoring_target].
   */
  endpoints: string[];
}

/** Time offset setting. */
export interface ModelMonitoringInput_TimeOffset {
  /**
   * [offset] is the time difference from the cut-off time.
   * For scheduled jobs, the cut-off time is the scheduled time.
   * For non-scheduled jobs, it's the time when the job was created.
   * Currently we support the following format:
   * 'w|W': Week, 'd|D': Day, 'h|H': Hour
   * E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
   */
  offset: string;
  /**
   * [window] refers to the scope of data selected for analysis.
   * It allows you to specify the quantity of data you wish to examine.
   * Currently we support the following format:
   * 'w|W': Week, 'd|D': Day, 'h|H': Hour
   * E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
   */
  window: string;
}

/**
 * Notification spec(email, notification channel) for model monitoring
 * statistics/alerts.
 */
export interface ModelMonitoringNotificationSpec {
  /** Email alert config. */
  emailConfig:
    | ModelMonitoringNotificationSpec_EmailConfig
    | undefined;
  /**
   * Dump the anomalies to Cloud Logging. The anomalies will be put to json
   * payload encoded from proto
   * [google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry][].
   * This can be further sinked to Pub/Sub or any other services supported
   * by Cloud Logging.
   */
  enableCloudLogging: boolean;
  /** Notification channel config. */
  notificationChannelConfigs: ModelMonitoringNotificationSpec_NotificationChannelConfig[];
}

/** The config for email alerts. */
export interface ModelMonitoringNotificationSpec_EmailConfig {
  /** The email addresses to send the alerts. */
  userEmails: string[];
}

/** Google Cloud Notification Channel config. */
export interface ModelMonitoringNotificationSpec_NotificationChannelConfig {
  /**
   * Resource names of the NotificationChannels.
   * Must be of the format
   * `projects/<project_id_or_number>/notificationChannels/<channel_id>`
   */
  notificationChannel: string;
}

function createBaseModelMonitoringSpec(): ModelMonitoringSpec {
  return { objectiveSpec: undefined, notificationSpec: undefined, outputSpec: undefined };
}

export const ModelMonitoringSpec: MessageFns<ModelMonitoringSpec> = {
  encode(message: ModelMonitoringSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.objectiveSpec !== undefined) {
      ModelMonitoringObjectiveSpec.encode(message.objectiveSpec, writer.uint32(10).fork()).join();
    }
    if (message.notificationSpec !== undefined) {
      ModelMonitoringNotificationSpec.encode(message.notificationSpec, writer.uint32(18).fork()).join();
    }
    if (message.outputSpec !== undefined) {
      ModelMonitoringOutputSpec.encode(message.outputSpec, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.objectiveSpec = ModelMonitoringObjectiveSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notificationSpec = ModelMonitoringNotificationSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputSpec = ModelMonitoringOutputSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringSpec {
    return {
      objectiveSpec: isSet(object.objectiveSpec)
        ? ModelMonitoringObjectiveSpec.fromJSON(object.objectiveSpec)
        : undefined,
      notificationSpec: isSet(object.notificationSpec)
        ? ModelMonitoringNotificationSpec.fromJSON(object.notificationSpec)
        : undefined,
      outputSpec: isSet(object.outputSpec) ? ModelMonitoringOutputSpec.fromJSON(object.outputSpec) : undefined,
    };
  },

  toJSON(message: ModelMonitoringSpec): unknown {
    const obj: any = {};
    if (message.objectiveSpec !== undefined) {
      obj.objectiveSpec = ModelMonitoringObjectiveSpec.toJSON(message.objectiveSpec);
    }
    if (message.notificationSpec !== undefined) {
      obj.notificationSpec = ModelMonitoringNotificationSpec.toJSON(message.notificationSpec);
    }
    if (message.outputSpec !== undefined) {
      obj.outputSpec = ModelMonitoringOutputSpec.toJSON(message.outputSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringSpec>): ModelMonitoringSpec {
    return ModelMonitoringSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringSpec>): ModelMonitoringSpec {
    const message = createBaseModelMonitoringSpec();
    message.objectiveSpec = (object.objectiveSpec !== undefined && object.objectiveSpec !== null)
      ? ModelMonitoringObjectiveSpec.fromPartial(object.objectiveSpec)
      : undefined;
    message.notificationSpec = (object.notificationSpec !== undefined && object.notificationSpec !== null)
      ? ModelMonitoringNotificationSpec.fromPartial(object.notificationSpec)
      : undefined;
    message.outputSpec = (object.outputSpec !== undefined && object.outputSpec !== null)
      ? ModelMonitoringOutputSpec.fromPartial(object.outputSpec)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec(): ModelMonitoringObjectiveSpec {
  return {
    tabularObjective: undefined,
    explanationSpec: undefined,
    baselineDataset: undefined,
    targetDataset: undefined,
  };
}

export const ModelMonitoringObjectiveSpec: MessageFns<ModelMonitoringObjectiveSpec> = {
  encode(message: ModelMonitoringObjectiveSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tabularObjective !== undefined) {
      ModelMonitoringObjectiveSpec_TabularObjective.encode(message.tabularObjective, writer.uint32(10).fork()).join();
    }
    if (message.explanationSpec !== undefined) {
      ExplanationSpec.encode(message.explanationSpec, writer.uint32(26).fork()).join();
    }
    if (message.baselineDataset !== undefined) {
      ModelMonitoringInput.encode(message.baselineDataset, writer.uint32(34).fork()).join();
    }
    if (message.targetDataset !== undefined) {
      ModelMonitoringInput.encode(message.targetDataset, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tabularObjective = ModelMonitoringObjectiveSpec_TabularObjective.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.explanationSpec = ExplanationSpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baselineDataset = ModelMonitoringInput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetDataset = ModelMonitoringInput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveSpec {
    return {
      tabularObjective: isSet(object.tabularObjective)
        ? ModelMonitoringObjectiveSpec_TabularObjective.fromJSON(object.tabularObjective)
        : undefined,
      explanationSpec: isSet(object.explanationSpec) ? ExplanationSpec.fromJSON(object.explanationSpec) : undefined,
      baselineDataset: isSet(object.baselineDataset)
        ? ModelMonitoringInput.fromJSON(object.baselineDataset)
        : undefined,
      targetDataset: isSet(object.targetDataset) ? ModelMonitoringInput.fromJSON(object.targetDataset) : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveSpec): unknown {
    const obj: any = {};
    if (message.tabularObjective !== undefined) {
      obj.tabularObjective = ModelMonitoringObjectiveSpec_TabularObjective.toJSON(message.tabularObjective);
    }
    if (message.explanationSpec !== undefined) {
      obj.explanationSpec = ExplanationSpec.toJSON(message.explanationSpec);
    }
    if (message.baselineDataset !== undefined) {
      obj.baselineDataset = ModelMonitoringInput.toJSON(message.baselineDataset);
    }
    if (message.targetDataset !== undefined) {
      obj.targetDataset = ModelMonitoringInput.toJSON(message.targetDataset);
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringObjectiveSpec>): ModelMonitoringObjectiveSpec {
    return ModelMonitoringObjectiveSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringObjectiveSpec>): ModelMonitoringObjectiveSpec {
    const message = createBaseModelMonitoringObjectiveSpec();
    message.tabularObjective = (object.tabularObjective !== undefined && object.tabularObjective !== null)
      ? ModelMonitoringObjectiveSpec_TabularObjective.fromPartial(object.tabularObjective)
      : undefined;
    message.explanationSpec = (object.explanationSpec !== undefined && object.explanationSpec !== null)
      ? ExplanationSpec.fromPartial(object.explanationSpec)
      : undefined;
    message.baselineDataset = (object.baselineDataset !== undefined && object.baselineDataset !== null)
      ? ModelMonitoringInput.fromPartial(object.baselineDataset)
      : undefined;
    message.targetDataset = (object.targetDataset !== undefined && object.targetDataset !== null)
      ? ModelMonitoringInput.fromPartial(object.targetDataset)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec_DataDriftSpec(): ModelMonitoringObjectiveSpec_DataDriftSpec {
  return {
    features: [],
    categoricalMetricType: "",
    numericMetricType: "",
    defaultCategoricalAlertCondition: undefined,
    defaultNumericAlertCondition: undefined,
    featureAlertConditions: {},
  };
}

export const ModelMonitoringObjectiveSpec_DataDriftSpec: MessageFns<ModelMonitoringObjectiveSpec_DataDriftSpec> = {
  encode(message: ModelMonitoringObjectiveSpec_DataDriftSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.features) {
      writer.uint32(10).string(v!);
    }
    if (message.categoricalMetricType !== "") {
      writer.uint32(18).string(message.categoricalMetricType);
    }
    if (message.numericMetricType !== "") {
      writer.uint32(26).string(message.numericMetricType);
    }
    if (message.defaultCategoricalAlertCondition !== undefined) {
      ModelMonitoringAlertCondition.encode(message.defaultCategoricalAlertCondition, writer.uint32(34).fork()).join();
    }
    if (message.defaultNumericAlertCondition !== undefined) {
      ModelMonitoringAlertCondition.encode(message.defaultNumericAlertCondition, writer.uint32(42).fork()).join();
    }
    Object.entries(message.featureAlertConditions).forEach(([key, value]) => {
      ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveSpec_DataDriftSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveSpec_DataDriftSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.features.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.categoricalMetricType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.numericMetricType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.defaultCategoricalAlertCondition = ModelMonitoringAlertCondition.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultNumericAlertCondition = ModelMonitoringAlertCondition.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry6.value !== undefined) {
            message.featureAlertConditions[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveSpec_DataDriftSpec {
    return {
      features: globalThis.Array.isArray(object?.features) ? object.features.map((e: any) => globalThis.String(e)) : [],
      categoricalMetricType: isSet(object.categoricalMetricType) ? globalThis.String(object.categoricalMetricType) : "",
      numericMetricType: isSet(object.numericMetricType) ? globalThis.String(object.numericMetricType) : "",
      defaultCategoricalAlertCondition: isSet(object.defaultCategoricalAlertCondition)
        ? ModelMonitoringAlertCondition.fromJSON(object.defaultCategoricalAlertCondition)
        : undefined,
      defaultNumericAlertCondition: isSet(object.defaultNumericAlertCondition)
        ? ModelMonitoringAlertCondition.fromJSON(object.defaultNumericAlertCondition)
        : undefined,
      featureAlertConditions: isObject(object.featureAlertConditions)
        ? Object.entries(object.featureAlertConditions).reduce<{ [key: string]: ModelMonitoringAlertCondition }>(
          (acc, [key, value]) => {
            acc[key] = ModelMonitoringAlertCondition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ModelMonitoringObjectiveSpec_DataDriftSpec): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features;
    }
    if (message.categoricalMetricType !== "") {
      obj.categoricalMetricType = message.categoricalMetricType;
    }
    if (message.numericMetricType !== "") {
      obj.numericMetricType = message.numericMetricType;
    }
    if (message.defaultCategoricalAlertCondition !== undefined) {
      obj.defaultCategoricalAlertCondition = ModelMonitoringAlertCondition.toJSON(
        message.defaultCategoricalAlertCondition,
      );
    }
    if (message.defaultNumericAlertCondition !== undefined) {
      obj.defaultNumericAlertCondition = ModelMonitoringAlertCondition.toJSON(message.defaultNumericAlertCondition);
    }
    if (message.featureAlertConditions) {
      const entries = Object.entries(message.featureAlertConditions);
      if (entries.length > 0) {
        obj.featureAlertConditions = {};
        entries.forEach(([k, v]) => {
          obj.featureAlertConditions[k] = ModelMonitoringAlertCondition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringObjectiveSpec_DataDriftSpec>): ModelMonitoringObjectiveSpec_DataDriftSpec {
    return ModelMonitoringObjectiveSpec_DataDriftSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveSpec_DataDriftSpec>,
  ): ModelMonitoringObjectiveSpec_DataDriftSpec {
    const message = createBaseModelMonitoringObjectiveSpec_DataDriftSpec();
    message.features = object.features?.map((e) => e) || [];
    message.categoricalMetricType = object.categoricalMetricType ?? "";
    message.numericMetricType = object.numericMetricType ?? "";
    message.defaultCategoricalAlertCondition =
      (object.defaultCategoricalAlertCondition !== undefined && object.defaultCategoricalAlertCondition !== null)
        ? ModelMonitoringAlertCondition.fromPartial(object.defaultCategoricalAlertCondition)
        : undefined;
    message.defaultNumericAlertCondition =
      (object.defaultNumericAlertCondition !== undefined && object.defaultNumericAlertCondition !== null)
        ? ModelMonitoringAlertCondition.fromPartial(object.defaultNumericAlertCondition)
        : undefined;
    message.featureAlertConditions = Object.entries(object.featureAlertConditions ?? {}).reduce<
      { [key: string]: ModelMonitoringAlertCondition }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ModelMonitoringAlertCondition.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry(): ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry: MessageFns<
  ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry
> = {
  encode(
    message: ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ModelMonitoringAlertCondition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ModelMonitoringAlertCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ModelMonitoringAlertCondition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ModelMonitoringAlertCondition.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry>,
  ): ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
    return ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry>,
  ): ModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry {
    const message = createBaseModelMonitoringObjectiveSpec_DataDriftSpec_FeatureAlertConditionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ModelMonitoringAlertCondition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec(): ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
  return {
    features: [],
    defaultAlertCondition: undefined,
    featureAlertConditions: {},
    batchExplanationDedicatedResources: undefined,
  };
}

export const ModelMonitoringObjectiveSpec_FeatureAttributionSpec: MessageFns<
  ModelMonitoringObjectiveSpec_FeatureAttributionSpec
> = {
  encode(
    message: ModelMonitoringObjectiveSpec_FeatureAttributionSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.features) {
      writer.uint32(10).string(v!);
    }
    if (message.defaultAlertCondition !== undefined) {
      ModelMonitoringAlertCondition.encode(message.defaultAlertCondition, writer.uint32(18).fork()).join();
    }
    Object.entries(message.featureAlertConditions).forEach(([key, value]) => {
      ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.batchExplanationDedicatedResources !== undefined) {
      BatchDedicatedResources.encode(message.batchExplanationDedicatedResources, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.features.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultAlertCondition = ModelMonitoringAlertCondition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.featureAlertConditions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.batchExplanationDedicatedResources = BatchDedicatedResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
    return {
      features: globalThis.Array.isArray(object?.features) ? object.features.map((e: any) => globalThis.String(e)) : [],
      defaultAlertCondition: isSet(object.defaultAlertCondition)
        ? ModelMonitoringAlertCondition.fromJSON(object.defaultAlertCondition)
        : undefined,
      featureAlertConditions: isObject(object.featureAlertConditions)
        ? Object.entries(object.featureAlertConditions).reduce<{ [key: string]: ModelMonitoringAlertCondition }>(
          (acc, [key, value]) => {
            acc[key] = ModelMonitoringAlertCondition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      batchExplanationDedicatedResources: isSet(object.batchExplanationDedicatedResources)
        ? BatchDedicatedResources.fromJSON(object.batchExplanationDedicatedResources)
        : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveSpec_FeatureAttributionSpec): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features;
    }
    if (message.defaultAlertCondition !== undefined) {
      obj.defaultAlertCondition = ModelMonitoringAlertCondition.toJSON(message.defaultAlertCondition);
    }
    if (message.featureAlertConditions) {
      const entries = Object.entries(message.featureAlertConditions);
      if (entries.length > 0) {
        obj.featureAlertConditions = {};
        entries.forEach(([k, v]) => {
          obj.featureAlertConditions[k] = ModelMonitoringAlertCondition.toJSON(v);
        });
      }
    }
    if (message.batchExplanationDedicatedResources !== undefined) {
      obj.batchExplanationDedicatedResources = BatchDedicatedResources.toJSON(
        message.batchExplanationDedicatedResources,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveSpec_FeatureAttributionSpec>,
  ): ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
    return ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveSpec_FeatureAttributionSpec>,
  ): ModelMonitoringObjectiveSpec_FeatureAttributionSpec {
    const message = createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec();
    message.features = object.features?.map((e) => e) || [];
    message.defaultAlertCondition =
      (object.defaultAlertCondition !== undefined && object.defaultAlertCondition !== null)
        ? ModelMonitoringAlertCondition.fromPartial(object.defaultAlertCondition)
        : undefined;
    message.featureAlertConditions = Object.entries(object.featureAlertConditions ?? {}).reduce<
      { [key: string]: ModelMonitoringAlertCondition }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ModelMonitoringAlertCondition.fromPartial(value);
      }
      return acc;
    }, {});
    message.batchExplanationDedicatedResources =
      (object.batchExplanationDedicatedResources !== undefined && object.batchExplanationDedicatedResources !== null)
        ? BatchDedicatedResources.fromPartial(object.batchExplanationDedicatedResources)
        : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry(): ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
  return { key: "", value: undefined };
}

export const ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry: MessageFns<
  ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry
> = {
  encode(
    message: ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ModelMonitoringAlertCondition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ModelMonitoringAlertCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ModelMonitoringAlertCondition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ModelMonitoringAlertCondition.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry>,
  ): ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
    return ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry>,
  ): ModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry {
    const message = createBaseModelMonitoringObjectiveSpec_FeatureAttributionSpec_FeatureAlertConditionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ModelMonitoringAlertCondition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringObjectiveSpec_TabularObjective(): ModelMonitoringObjectiveSpec_TabularObjective {
  return { featureDriftSpec: undefined, predictionOutputDriftSpec: undefined, featureAttributionSpec: undefined };
}

export const ModelMonitoringObjectiveSpec_TabularObjective: MessageFns<ModelMonitoringObjectiveSpec_TabularObjective> =
  {
    encode(
      message: ModelMonitoringObjectiveSpec_TabularObjective,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.featureDriftSpec !== undefined) {
        ModelMonitoringObjectiveSpec_DataDriftSpec.encode(message.featureDriftSpec, writer.uint32(82).fork()).join();
      }
      if (message.predictionOutputDriftSpec !== undefined) {
        ModelMonitoringObjectiveSpec_DataDriftSpec.encode(message.predictionOutputDriftSpec, writer.uint32(90).fork())
          .join();
      }
      if (message.featureAttributionSpec !== undefined) {
        ModelMonitoringObjectiveSpec_FeatureAttributionSpec.encode(
          message.featureAttributionSpec,
          writer.uint32(98).fork(),
        ).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringObjectiveSpec_TabularObjective {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseModelMonitoringObjectiveSpec_TabularObjective();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 10:
            if (tag !== 82) {
              break;
            }

            message.featureDriftSpec = ModelMonitoringObjectiveSpec_DataDriftSpec.decode(reader, reader.uint32());
            continue;
          case 11:
            if (tag !== 90) {
              break;
            }

            message.predictionOutputDriftSpec = ModelMonitoringObjectiveSpec_DataDriftSpec.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 12:
            if (tag !== 98) {
              break;
            }

            message.featureAttributionSpec = ModelMonitoringObjectiveSpec_FeatureAttributionSpec.decode(
              reader,
              reader.uint32(),
            );
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ModelMonitoringObjectiveSpec_TabularObjective {
      return {
        featureDriftSpec: isSet(object.featureDriftSpec)
          ? ModelMonitoringObjectiveSpec_DataDriftSpec.fromJSON(object.featureDriftSpec)
          : undefined,
        predictionOutputDriftSpec: isSet(object.predictionOutputDriftSpec)
          ? ModelMonitoringObjectiveSpec_DataDriftSpec.fromJSON(object.predictionOutputDriftSpec)
          : undefined,
        featureAttributionSpec: isSet(object.featureAttributionSpec)
          ? ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromJSON(object.featureAttributionSpec)
          : undefined,
      };
    },

    toJSON(message: ModelMonitoringObjectiveSpec_TabularObjective): unknown {
      const obj: any = {};
      if (message.featureDriftSpec !== undefined) {
        obj.featureDriftSpec = ModelMonitoringObjectiveSpec_DataDriftSpec.toJSON(message.featureDriftSpec);
      }
      if (message.predictionOutputDriftSpec !== undefined) {
        obj.predictionOutputDriftSpec = ModelMonitoringObjectiveSpec_DataDriftSpec.toJSON(
          message.predictionOutputDriftSpec,
        );
      }
      if (message.featureAttributionSpec !== undefined) {
        obj.featureAttributionSpec = ModelMonitoringObjectiveSpec_FeatureAttributionSpec.toJSON(
          message.featureAttributionSpec,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<ModelMonitoringObjectiveSpec_TabularObjective>,
    ): ModelMonitoringObjectiveSpec_TabularObjective {
      return ModelMonitoringObjectiveSpec_TabularObjective.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ModelMonitoringObjectiveSpec_TabularObjective>,
    ): ModelMonitoringObjectiveSpec_TabularObjective {
      const message = createBaseModelMonitoringObjectiveSpec_TabularObjective();
      message.featureDriftSpec = (object.featureDriftSpec !== undefined && object.featureDriftSpec !== null)
        ? ModelMonitoringObjectiveSpec_DataDriftSpec.fromPartial(object.featureDriftSpec)
        : undefined;
      message.predictionOutputDriftSpec =
        (object.predictionOutputDriftSpec !== undefined && object.predictionOutputDriftSpec !== null)
          ? ModelMonitoringObjectiveSpec_DataDriftSpec.fromPartial(object.predictionOutputDriftSpec)
          : undefined;
      message.featureAttributionSpec =
        (object.featureAttributionSpec !== undefined && object.featureAttributionSpec !== null)
          ? ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromPartial(object.featureAttributionSpec)
          : undefined;
      return message;
    },
  };

function createBaseModelMonitoringOutputSpec(): ModelMonitoringOutputSpec {
  return { gcsBaseDirectory: undefined };
}

export const ModelMonitoringOutputSpec: MessageFns<ModelMonitoringOutputSpec> = {
  encode(message: ModelMonitoringOutputSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsBaseDirectory !== undefined) {
      GcsDestination.encode(message.gcsBaseDirectory, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringOutputSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringOutputSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsBaseDirectory = GcsDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringOutputSpec {
    return {
      gcsBaseDirectory: isSet(object.gcsBaseDirectory) ? GcsDestination.fromJSON(object.gcsBaseDirectory) : undefined,
    };
  },

  toJSON(message: ModelMonitoringOutputSpec): unknown {
    const obj: any = {};
    if (message.gcsBaseDirectory !== undefined) {
      obj.gcsBaseDirectory = GcsDestination.toJSON(message.gcsBaseDirectory);
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringOutputSpec>): ModelMonitoringOutputSpec {
    return ModelMonitoringOutputSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringOutputSpec>): ModelMonitoringOutputSpec {
    const message = createBaseModelMonitoringOutputSpec();
    message.gcsBaseDirectory = (object.gcsBaseDirectory !== undefined && object.gcsBaseDirectory !== null)
      ? GcsDestination.fromPartial(object.gcsBaseDirectory)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringInput(): ModelMonitoringInput {
  return {
    columnizedDataset: undefined,
    batchPredictionOutput: undefined,
    vertexEndpointLogs: undefined,
    timeInterval: undefined,
    timeOffset: undefined,
  };
}

export const ModelMonitoringInput: MessageFns<ModelMonitoringInput> = {
  encode(message: ModelMonitoringInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columnizedDataset !== undefined) {
      ModelMonitoringInput_ModelMonitoringDataset.encode(message.columnizedDataset, writer.uint32(10).fork()).join();
    }
    if (message.batchPredictionOutput !== undefined) {
      ModelMonitoringInput_BatchPredictionOutput.encode(message.batchPredictionOutput, writer.uint32(18).fork()).join();
    }
    if (message.vertexEndpointLogs !== undefined) {
      ModelMonitoringInput_VertexEndpointLogs.encode(message.vertexEndpointLogs, writer.uint32(26).fork()).join();
    }
    if (message.timeInterval !== undefined) {
      Interval.encode(message.timeInterval, writer.uint32(50).fork()).join();
    }
    if (message.timeOffset !== undefined) {
      ModelMonitoringInput_TimeOffset.encode(message.timeOffset, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnizedDataset = ModelMonitoringInput_ModelMonitoringDataset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.batchPredictionOutput = ModelMonitoringInput_BatchPredictionOutput.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vertexEndpointLogs = ModelMonitoringInput_VertexEndpointLogs.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeInterval = Interval.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timeOffset = ModelMonitoringInput_TimeOffset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput {
    return {
      columnizedDataset: isSet(object.columnizedDataset)
        ? ModelMonitoringInput_ModelMonitoringDataset.fromJSON(object.columnizedDataset)
        : undefined,
      batchPredictionOutput: isSet(object.batchPredictionOutput)
        ? ModelMonitoringInput_BatchPredictionOutput.fromJSON(object.batchPredictionOutput)
        : undefined,
      vertexEndpointLogs: isSet(object.vertexEndpointLogs)
        ? ModelMonitoringInput_VertexEndpointLogs.fromJSON(object.vertexEndpointLogs)
        : undefined,
      timeInterval: isSet(object.timeInterval) ? Interval.fromJSON(object.timeInterval) : undefined,
      timeOffset: isSet(object.timeOffset) ? ModelMonitoringInput_TimeOffset.fromJSON(object.timeOffset) : undefined,
    };
  },

  toJSON(message: ModelMonitoringInput): unknown {
    const obj: any = {};
    if (message.columnizedDataset !== undefined) {
      obj.columnizedDataset = ModelMonitoringInput_ModelMonitoringDataset.toJSON(message.columnizedDataset);
    }
    if (message.batchPredictionOutput !== undefined) {
      obj.batchPredictionOutput = ModelMonitoringInput_BatchPredictionOutput.toJSON(message.batchPredictionOutput);
    }
    if (message.vertexEndpointLogs !== undefined) {
      obj.vertexEndpointLogs = ModelMonitoringInput_VertexEndpointLogs.toJSON(message.vertexEndpointLogs);
    }
    if (message.timeInterval !== undefined) {
      obj.timeInterval = Interval.toJSON(message.timeInterval);
    }
    if (message.timeOffset !== undefined) {
      obj.timeOffset = ModelMonitoringInput_TimeOffset.toJSON(message.timeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringInput>): ModelMonitoringInput {
    return ModelMonitoringInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringInput>): ModelMonitoringInput {
    const message = createBaseModelMonitoringInput();
    message.columnizedDataset = (object.columnizedDataset !== undefined && object.columnizedDataset !== null)
      ? ModelMonitoringInput_ModelMonitoringDataset.fromPartial(object.columnizedDataset)
      : undefined;
    message.batchPredictionOutput =
      (object.batchPredictionOutput !== undefined && object.batchPredictionOutput !== null)
        ? ModelMonitoringInput_BatchPredictionOutput.fromPartial(object.batchPredictionOutput)
        : undefined;
    message.vertexEndpointLogs = (object.vertexEndpointLogs !== undefined && object.vertexEndpointLogs !== null)
      ? ModelMonitoringInput_VertexEndpointLogs.fromPartial(object.vertexEndpointLogs)
      : undefined;
    message.timeInterval = (object.timeInterval !== undefined && object.timeInterval !== null)
      ? Interval.fromPartial(object.timeInterval)
      : undefined;
    message.timeOffset = (object.timeOffset !== undefined && object.timeOffset !== null)
      ? ModelMonitoringInput_TimeOffset.fromPartial(object.timeOffset)
      : undefined;
    return message;
  },
};

function createBaseModelMonitoringInput_ModelMonitoringDataset(): ModelMonitoringInput_ModelMonitoringDataset {
  return { vertexDataset: undefined, gcsSource: undefined, bigquerySource: undefined, timestampField: "" };
}

export const ModelMonitoringInput_ModelMonitoringDataset: MessageFns<ModelMonitoringInput_ModelMonitoringDataset> = {
  encode(
    message: ModelMonitoringInput_ModelMonitoringDataset,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.vertexDataset !== undefined) {
      writer.uint32(10).string(message.vertexDataset);
    }
    if (message.gcsSource !== undefined) {
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.encode(
        message.gcsSource,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.bigquerySource !== undefined) {
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.encode(
        message.bigquerySource,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.timestampField !== "") {
      writer.uint32(58).string(message.timestampField);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringInput_ModelMonitoringDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertexDataset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsSource = ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bigquerySource = ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timestampField = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_ModelMonitoringDataset {
    return {
      vertexDataset: isSet(object.vertexDataset) ? globalThis.String(object.vertexDataset) : undefined,
      gcsSource: isSet(object.gcsSource)
        ? ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromJSON(object.gcsSource)
        : undefined,
      bigquerySource: isSet(object.bigquerySource)
        ? ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromJSON(object.bigquerySource)
        : undefined,
      timestampField: isSet(object.timestampField) ? globalThis.String(object.timestampField) : "",
    };
  },

  toJSON(message: ModelMonitoringInput_ModelMonitoringDataset): unknown {
    const obj: any = {};
    if (message.vertexDataset !== undefined) {
      obj.vertexDataset = message.vertexDataset;
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.toJSON(message.gcsSource);
    }
    if (message.bigquerySource !== undefined) {
      obj.bigquerySource = ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.toJSON(
        message.bigquerySource,
      );
    }
    if (message.timestampField !== "") {
      obj.timestampField = message.timestampField;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset>): ModelMonitoringInput_ModelMonitoringDataset {
    return ModelMonitoringInput_ModelMonitoringDataset.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset>,
  ): ModelMonitoringInput_ModelMonitoringDataset {
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset();
    message.vertexDataset = object.vertexDataset ?? undefined;
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.bigquerySource = (object.bigquerySource !== undefined && object.bigquerySource !== null)
      ? ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromPartial(object.bigquerySource)
      : undefined;
    message.timestampField = object.timestampField ?? "";
    return message;
  },
};

function createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource(): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
  return { gcsUri: "", format: 0 };
}

export const ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource: MessageFns<
  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource
> = {
  encode(
    message: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.gcsUri !== "") {
      writer.uint32(10).string(message.gcsUri);
    }
    if (message.format !== 0) {
      writer.uint32(16).int32(message.format);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
    return {
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : "",
      format: isSet(object.format)
        ? modelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormatFromJSON(object.format)
        : 0,
    };
  },

  toJSON(message: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource): unknown {
    const obj: any = {};
    if (message.gcsUri !== "") {
      obj.gcsUri = message.gcsUri;
    }
    if (message.format !== 0) {
      obj.format = modelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormatToJSON(
        message.format,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource>,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource>,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource {
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource();
    message.gcsUri = object.gcsUri ?? "";
    message.format = object.format ?? 0;
    return message;
  },
};

function createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource(): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
  return { tableUri: undefined, query: undefined };
}

export const ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource: MessageFns<
  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource
> = {
  encode(
    message: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tableUri !== undefined) {
      writer.uint32(10).string(message.tableUri);
    }
    if (message.query !== undefined) {
      writer.uint32(18).string(message.query);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
    return {
      tableUri: isSet(object.tableUri) ? globalThis.String(object.tableUri) : undefined,
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
    };
  },

  toJSON(message: ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource): unknown {
    const obj: any = {};
    if (message.tableUri !== undefined) {
      obj.tableUri = message.tableUri;
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource>,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource>,
  ): ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource {
    const message = createBaseModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource();
    message.tableUri = object.tableUri ?? undefined;
    message.query = object.query ?? undefined;
    return message;
  },
};

function createBaseModelMonitoringInput_BatchPredictionOutput(): ModelMonitoringInput_BatchPredictionOutput {
  return { batchPredictionJob: "" };
}

export const ModelMonitoringInput_BatchPredictionOutput: MessageFns<ModelMonitoringInput_BatchPredictionOutput> = {
  encode(message: ModelMonitoringInput_BatchPredictionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batchPredictionJob !== "") {
      writer.uint32(10).string(message.batchPredictionJob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringInput_BatchPredictionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_BatchPredictionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.batchPredictionJob = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_BatchPredictionOutput {
    return { batchPredictionJob: isSet(object.batchPredictionJob) ? globalThis.String(object.batchPredictionJob) : "" };
  },

  toJSON(message: ModelMonitoringInput_BatchPredictionOutput): unknown {
    const obj: any = {};
    if (message.batchPredictionJob !== "") {
      obj.batchPredictionJob = message.batchPredictionJob;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringInput_BatchPredictionOutput>): ModelMonitoringInput_BatchPredictionOutput {
    return ModelMonitoringInput_BatchPredictionOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringInput_BatchPredictionOutput>,
  ): ModelMonitoringInput_BatchPredictionOutput {
    const message = createBaseModelMonitoringInput_BatchPredictionOutput();
    message.batchPredictionJob = object.batchPredictionJob ?? "";
    return message;
  },
};

function createBaseModelMonitoringInput_VertexEndpointLogs(): ModelMonitoringInput_VertexEndpointLogs {
  return { endpoints: [] };
}

export const ModelMonitoringInput_VertexEndpointLogs: MessageFns<ModelMonitoringInput_VertexEndpointLogs> = {
  encode(message: ModelMonitoringInput_VertexEndpointLogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.endpoints) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringInput_VertexEndpointLogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_VertexEndpointLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_VertexEndpointLogs {
    return {
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelMonitoringInput_VertexEndpointLogs): unknown {
    const obj: any = {};
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringInput_VertexEndpointLogs>): ModelMonitoringInput_VertexEndpointLogs {
    return ModelMonitoringInput_VertexEndpointLogs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringInput_VertexEndpointLogs>): ModelMonitoringInput_VertexEndpointLogs {
    const message = createBaseModelMonitoringInput_VertexEndpointLogs();
    message.endpoints = object.endpoints?.map((e) => e) || [];
    return message;
  },
};

function createBaseModelMonitoringInput_TimeOffset(): ModelMonitoringInput_TimeOffset {
  return { offset: "", window: "" };
}

export const ModelMonitoringInput_TimeOffset: MessageFns<ModelMonitoringInput_TimeOffset> = {
  encode(message: ModelMonitoringInput_TimeOffset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== "") {
      writer.uint32(10).string(message.offset);
    }
    if (message.window !== "") {
      writer.uint32(18).string(message.window);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringInput_TimeOffset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringInput_TimeOffset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.window = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringInput_TimeOffset {
    return {
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "",
      window: isSet(object.window) ? globalThis.String(object.window) : "",
    };
  },

  toJSON(message: ModelMonitoringInput_TimeOffset): unknown {
    const obj: any = {};
    if (message.offset !== "") {
      obj.offset = message.offset;
    }
    if (message.window !== "") {
      obj.window = message.window;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringInput_TimeOffset>): ModelMonitoringInput_TimeOffset {
    return ModelMonitoringInput_TimeOffset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringInput_TimeOffset>): ModelMonitoringInput_TimeOffset {
    const message = createBaseModelMonitoringInput_TimeOffset();
    message.offset = object.offset ?? "";
    message.window = object.window ?? "";
    return message;
  },
};

function createBaseModelMonitoringNotificationSpec(): ModelMonitoringNotificationSpec {
  return { emailConfig: undefined, enableCloudLogging: false, notificationChannelConfigs: [] };
}

export const ModelMonitoringNotificationSpec: MessageFns<ModelMonitoringNotificationSpec> = {
  encode(message: ModelMonitoringNotificationSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailConfig !== undefined) {
      ModelMonitoringNotificationSpec_EmailConfig.encode(message.emailConfig, writer.uint32(10).fork()).join();
    }
    if (message.enableCloudLogging !== false) {
      writer.uint32(16).bool(message.enableCloudLogging);
    }
    for (const v of message.notificationChannelConfigs) {
      ModelMonitoringNotificationSpec_NotificationChannelConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringNotificationSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringNotificationSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailConfig = ModelMonitoringNotificationSpec_EmailConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableCloudLogging = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notificationChannelConfigs.push(
            ModelMonitoringNotificationSpec_NotificationChannelConfig.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringNotificationSpec {
    return {
      emailConfig: isSet(object.emailConfig)
        ? ModelMonitoringNotificationSpec_EmailConfig.fromJSON(object.emailConfig)
        : undefined,
      enableCloudLogging: isSet(object.enableCloudLogging) ? globalThis.Boolean(object.enableCloudLogging) : false,
      notificationChannelConfigs: globalThis.Array.isArray(object?.notificationChannelConfigs)
        ? object.notificationChannelConfigs.map((e: any) =>
          ModelMonitoringNotificationSpec_NotificationChannelConfig.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: ModelMonitoringNotificationSpec): unknown {
    const obj: any = {};
    if (message.emailConfig !== undefined) {
      obj.emailConfig = ModelMonitoringNotificationSpec_EmailConfig.toJSON(message.emailConfig);
    }
    if (message.enableCloudLogging !== false) {
      obj.enableCloudLogging = message.enableCloudLogging;
    }
    if (message.notificationChannelConfigs?.length) {
      obj.notificationChannelConfigs = message.notificationChannelConfigs.map((e) =>
        ModelMonitoringNotificationSpec_NotificationChannelConfig.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringNotificationSpec>): ModelMonitoringNotificationSpec {
    return ModelMonitoringNotificationSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModelMonitoringNotificationSpec>): ModelMonitoringNotificationSpec {
    const message = createBaseModelMonitoringNotificationSpec();
    message.emailConfig = (object.emailConfig !== undefined && object.emailConfig !== null)
      ? ModelMonitoringNotificationSpec_EmailConfig.fromPartial(object.emailConfig)
      : undefined;
    message.enableCloudLogging = object.enableCloudLogging ?? false;
    message.notificationChannelConfigs =
      object.notificationChannelConfigs?.map((e) =>
        ModelMonitoringNotificationSpec_NotificationChannelConfig.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseModelMonitoringNotificationSpec_EmailConfig(): ModelMonitoringNotificationSpec_EmailConfig {
  return { userEmails: [] };
}

export const ModelMonitoringNotificationSpec_EmailConfig: MessageFns<ModelMonitoringNotificationSpec_EmailConfig> = {
  encode(
    message: ModelMonitoringNotificationSpec_EmailConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.userEmails) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringNotificationSpec_EmailConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringNotificationSpec_EmailConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userEmails.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringNotificationSpec_EmailConfig {
    return {
      userEmails: globalThis.Array.isArray(object?.userEmails)
        ? object.userEmails.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelMonitoringNotificationSpec_EmailConfig): unknown {
    const obj: any = {};
    if (message.userEmails?.length) {
      obj.userEmails = message.userEmails;
    }
    return obj;
  },

  create(base?: DeepPartial<ModelMonitoringNotificationSpec_EmailConfig>): ModelMonitoringNotificationSpec_EmailConfig {
    return ModelMonitoringNotificationSpec_EmailConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringNotificationSpec_EmailConfig>,
  ): ModelMonitoringNotificationSpec_EmailConfig {
    const message = createBaseModelMonitoringNotificationSpec_EmailConfig();
    message.userEmails = object.userEmails?.map((e) => e) || [];
    return message;
  },
};

function createBaseModelMonitoringNotificationSpec_NotificationChannelConfig(): ModelMonitoringNotificationSpec_NotificationChannelConfig {
  return { notificationChannel: "" };
}

export const ModelMonitoringNotificationSpec_NotificationChannelConfig: MessageFns<
  ModelMonitoringNotificationSpec_NotificationChannelConfig
> = {
  encode(
    message: ModelMonitoringNotificationSpec_NotificationChannelConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.notificationChannel !== "") {
      writer.uint32(10).string(message.notificationChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelMonitoringNotificationSpec_NotificationChannelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMonitoringNotificationSpec_NotificationChannelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notificationChannel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMonitoringNotificationSpec_NotificationChannelConfig {
    return {
      notificationChannel: isSet(object.notificationChannel) ? globalThis.String(object.notificationChannel) : "",
    };
  },

  toJSON(message: ModelMonitoringNotificationSpec_NotificationChannelConfig): unknown {
    const obj: any = {};
    if (message.notificationChannel !== "") {
      obj.notificationChannel = message.notificationChannel;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ModelMonitoringNotificationSpec_NotificationChannelConfig>,
  ): ModelMonitoringNotificationSpec_NotificationChannelConfig {
    return ModelMonitoringNotificationSpec_NotificationChannelConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ModelMonitoringNotificationSpec_NotificationChannelConfig>,
  ): ModelMonitoringNotificationSpec_NotificationChannelConfig {
    const message = createBaseModelMonitoringNotificationSpec_NotificationChannelConfig();
    message.notificationChannel = object.notificationChannel ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
