// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/index_endpoint.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { AutomaticResources, DedicatedResources } from "./machine_resources.js";
import { PrivateServiceConnectConfig, PscAutomatedEndpoints, PSCAutomationConfig } from "./service_networking.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Indexes are deployed into it. An IndexEndpoint can have multiple
 * DeployedIndexes.
 */
export interface IndexEndpoint {
  /** Output only. The resource name of the IndexEndpoint. */
  name: string;
  /**
   * Required. The display name of the IndexEndpoint.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** The description of the IndexEndpoint. */
  description: string;
  /** Output only. The indexes deployed in this endpoint. */
  deployedIndexes: DeployedIndex[];
  /**
   * Used to perform consistent read-modify-write updates. If not set, a blind
   * "overwrite" update happens.
   */
  etag: string;
  /**
   * The labels with user-defined metadata to organize your IndexEndpoints.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /** Output only. Timestamp when this IndexEndpoint was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp when this IndexEndpoint was last updated.
   * This timestamp is not updated when the endpoint's DeployedIndexes are
   * updated, e.g. due to updates of the original Indexes they are the
   * deployments of.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The full name of the Google Compute Engine
   * [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
   * to which the IndexEndpoint should be peered.
   *
   * Private services access must already be configured for the network. If left
   * unspecified, the Endpoint is not peered with any network.
   *
   * [network][google.cloud.aiplatform.v1beta1.IndexEndpoint.network] and
   * [private_service_connect_config][google.cloud.aiplatform.v1beta1.IndexEndpoint.private_service_connect_config]
   * are mutually exclusive.
   *
   * [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
   * `projects/{project}/global/networks/{network}`.
   * Where {project} is a project number, as in '12345', and {network} is
   * network name.
   */
  network: string;
  /**
   * Optional. Deprecated: If true, expose the IndexEndpoint via private service
   * connect.
   *
   * Only one of the fields,
   * [network][google.cloud.aiplatform.v1beta1.IndexEndpoint.network] or
   * [enable_private_service_connect][google.cloud.aiplatform.v1beta1.IndexEndpoint.enable_private_service_connect],
   * can be set.
   *
   * @deprecated
   */
  enablePrivateServiceConnect: boolean;
  /**
   * Optional. Configuration for private service connect.
   *
   * [network][google.cloud.aiplatform.v1beta1.IndexEndpoint.network] and
   * [private_service_connect_config][google.cloud.aiplatform.v1beta1.IndexEndpoint.private_service_connect_config]
   * are mutually exclusive.
   */
  privateServiceConnectConfig:
    | PrivateServiceConnectConfig
    | undefined;
  /**
   * Optional. If true, the deployed index will be accessible through public
   * endpoint.
   */
  publicEndpointEnabled: boolean;
  /**
   * Output only. If
   * [public_endpoint_enabled][google.cloud.aiplatform.v1beta1.IndexEndpoint.public_endpoint_enabled]
   * is true, this field will be populated with the domain name to use for this
   * index endpoint.
   */
  publicEndpointDomainName: string;
  /**
   * Immutable. Customer-managed encryption key spec for an IndexEndpoint. If
   * set, this IndexEndpoint and all sub-resources of this IndexEndpoint will be
   * secured by this key.
   */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

export interface IndexEndpoint_LabelsEntry {
  key: string;
  value: string;
}

/** A deployment of an Index. IndexEndpoints contain one or more DeployedIndexes. */
export interface DeployedIndex {
  /**
   * Required. The user specified ID of the DeployedIndex.
   * The ID can be up to 128 characters long and must start with a letter and
   * only contain letters, numbers, and underscores.
   * The ID must be unique within the project it is created in.
   */
  id: string;
  /**
   * Required. The name of the Index this is the deployment of.
   * We may refer to this Index as the DeployedIndex's "original" Index.
   */
  index: string;
  /**
   * The display name of the DeployedIndex. If not provided upon creation,
   * the Index's display_name is used.
   */
  displayName: string;
  /** Output only. Timestamp when the DeployedIndex was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Provides paths for users to send requests directly to the
   * deployed index services running on Cloud via private services access. This
   * field is populated if
   * [network][google.cloud.aiplatform.v1beta1.IndexEndpoint.network] is
   * configured.
   */
  privateEndpoints:
    | IndexPrivateEndpoints
    | undefined;
  /**
   * Output only. The DeployedIndex may depend on various data on its original
   * Index. Additionally when certain changes to the original Index are being
   * done (e.g. when what the Index contains is being changed) the DeployedIndex
   * may be asynchronously updated in the background to reflect these changes.
   * If this timestamp's value is at least the
   * [Index.update_time][google.cloud.aiplatform.v1beta1.Index.update_time] of
   * the original Index, it means that this DeployedIndex and the original Index
   * are in sync. If this timestamp is older, then to see which updates this
   * DeployedIndex already contains (and which it does not), one must
   * [list][google.longrunning.Operations.ListOperations] the operations that
   * are running on the original Index. Only the successfully completed
   * Operations with
   * [update_time][google.cloud.aiplatform.v1beta1.GenericOperationMetadata.update_time]
   * equal or before this sync time are contained in this DeployedIndex.
   */
  indexSyncTime:
    | Date
    | undefined;
  /**
   * Optional. A description of resources that the DeployedIndex uses, which to
   * large degree are decided by Vertex AI, and optionally allows only a modest
   * additional configuration.
   * If min_replica_count is not set, the default value is 2 (we don't provide
   * SLA when min_replica_count=1). If max_replica_count is not set, the
   * default value is min_replica_count. The max allowed replica count is
   * 1000.
   */
  automaticResources:
    | AutomaticResources
    | undefined;
  /**
   * Optional. A description of resources that are dedicated to the
   * DeployedIndex, and that need a higher degree of manual configuration. The
   * field min_replica_count must be set to a value strictly greater than 0, or
   * else validation will fail. We don't provide SLA when min_replica_count=1.
   * If max_replica_count is not set, the default value is min_replica_count.
   * The max allowed replica count is 1000.
   *
   * Available machine types for SMALL shard:
   * e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
   *
   * Available machine types for MEDIUM shard:
   * e2-standard-16 and all machine types available for LARGE shard.
   *
   * Available machine types for LARGE shard:
   * e2-highmem-16, n2d-standard-32.
   *
   * n1-standard-16 and n1-standard-32 are still available, but we recommend
   * e2-standard-16 and e2-highmem-16 for cost efficiency.
   */
  dedicatedResources:
    | DedicatedResources
    | undefined;
  /**
   * Optional. If true, private endpoint's access logs are sent to Cloud
   * Logging.
   *
   * These logs are like standard server access logs, containing
   * information like timestamp and latency for each MatchRequest.
   *
   * Note that logs may incur a cost, especially if the deployed
   * index receives a high queries per second rate (QPS).
   * Estimate your costs before enabling this option.
   */
  enableAccessLogging: boolean;
  /** Optional. If set, the authentication is enabled for the private endpoint. */
  deployedIndexAuthConfig:
    | DeployedIndexAuthConfig
    | undefined;
  /**
   * Optional. A list of reserved ip ranges under the VPC network that can be
   * used for this DeployedIndex.
   *
   * If set, we will deploy the index within the provided ip ranges. Otherwise,
   * the index might be deployed to any ip ranges under the provided VPC
   * network.
   *
   * The value should be the name of the address
   * (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
   * Example: ['vertex-ai-ip-range'].
   *
   * For more information about subnets and network IP ranges, please see
   * https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
   */
  reservedIpRanges: string[];
  /**
   * Optional. The deployment group can be no longer than 64 characters (eg:
   * 'test', 'prod'). If not set, we will use the 'default' deployment group.
   *
   * Creating `deployment_groups` with `reserved_ip_ranges` is a recommended
   * practice when the peered network has multiple peering ranges. This creates
   * your deployments from predictable IP spaces for easier traffic
   * administration. Also, one deployment_group (except 'default') can only be
   * used with the same reserved_ip_ranges which means if the deployment_group
   * has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or
   * [d, e] is disallowed.
   *
   * Note: we only support up to 5 deployment groups(not including 'default').
   */
  deploymentGroup: string;
  /**
   * Optional. If set for PSC deployed index, PSC connection will be
   * automatically created after deployment is done and the endpoint information
   * is populated in private_endpoints.psc_automated_endpoints.
   */
  pscAutomationConfigs: PSCAutomationConfig[];
}

/** Used to set up the auth on the DeployedIndex's private endpoint. */
export interface DeployedIndexAuthConfig {
  /** Defines the authentication provider that the DeployedIndex uses. */
  authProvider: DeployedIndexAuthConfig_AuthProvider | undefined;
}

/**
 * Configuration for an authentication provider, including support for
 * [JSON Web Token
 * (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
 */
export interface DeployedIndexAuthConfig_AuthProvider {
  /**
   * The list of JWT
   * [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
   * that are allowed to access. A JWT containing any of these audiences will
   * be accepted.
   */
  audiences: string[];
  /**
   * A list of allowed JWT issuers. Each entry must be a valid Google
   * service account, in the following format:
   *
   * `service-account-name@project-id.iam.gserviceaccount.com`
   */
  allowedIssuers: string[];
}

/**
 * IndexPrivateEndpoints proto is used to provide paths for users to send
 * requests via private endpoints (e.g. private service access, private service
 * connect).
 * To send request via private service access, use match_grpc_address.
 * To send request via private service connect, use service_attachment.
 */
export interface IndexPrivateEndpoints {
  /** Output only. The ip address used to send match gRPC requests. */
  matchGrpcAddress: string;
  /**
   * Output only. The name of the service attachment resource. Populated if
   * private service connect is enabled.
   */
  serviceAttachment: string;
  /**
   * Output only. PscAutomatedEndpoints is populated if private service connect
   * is enabled if PscAutomatedConfig is set.
   */
  pscAutomatedEndpoints: PscAutomatedEndpoints[];
}

function createBaseIndexEndpoint(): IndexEndpoint {
  return {
    name: "",
    displayName: "",
    description: "",
    deployedIndexes: [],
    etag: "",
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    network: "",
    enablePrivateServiceConnect: false,
    privateServiceConnectConfig: undefined,
    publicEndpointEnabled: false,
    publicEndpointDomainName: "",
    encryptionSpec: undefined,
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const IndexEndpoint: MessageFns<IndexEndpoint> = {
  encode(message: IndexEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.deployedIndexes) {
      DeployedIndex.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      IndexEndpoint_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(74).string(message.network);
    }
    if (message.enablePrivateServiceConnect !== false) {
      writer.uint32(80).bool(message.enablePrivateServiceConnect);
    }
    if (message.privateServiceConnectConfig !== undefined) {
      PrivateServiceConnectConfig.encode(message.privateServiceConnectConfig, writer.uint32(98).fork()).join();
    }
    if (message.publicEndpointEnabled !== false) {
      writer.uint32(104).bool(message.publicEndpointEnabled);
    }
    if (message.publicEndpointDomainName !== "") {
      writer.uint32(114).string(message.publicEndpointDomainName);
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(122).fork()).join();
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(136).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(144).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deployedIndexes.push(DeployedIndex.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = IndexEndpoint_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.network = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.enablePrivateServiceConnect = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.privateServiceConnectConfig = PrivateServiceConnectConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.publicEndpointEnabled = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.publicEndpointDomainName = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexEndpoint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      deployedIndexes: globalThis.Array.isArray(object?.deployedIndexes)
        ? object.deployedIndexes.map((e: any) => DeployedIndex.fromJSON(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      enablePrivateServiceConnect: isSet(object.enablePrivateServiceConnect)
        ? globalThis.Boolean(object.enablePrivateServiceConnect)
        : false,
      privateServiceConnectConfig: isSet(object.privateServiceConnectConfig)
        ? PrivateServiceConnectConfig.fromJSON(object.privateServiceConnectConfig)
        : undefined,
      publicEndpointEnabled: isSet(object.publicEndpointEnabled)
        ? globalThis.Boolean(object.publicEndpointEnabled)
        : false,
      publicEndpointDomainName: isSet(object.publicEndpointDomainName)
        ? globalThis.String(object.publicEndpointDomainName)
        : "",
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: IndexEndpoint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.deployedIndexes?.length) {
      obj.deployedIndexes = message.deployedIndexes.map((e) => DeployedIndex.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.enablePrivateServiceConnect !== false) {
      obj.enablePrivateServiceConnect = message.enablePrivateServiceConnect;
    }
    if (message.privateServiceConnectConfig !== undefined) {
      obj.privateServiceConnectConfig = PrivateServiceConnectConfig.toJSON(message.privateServiceConnectConfig);
    }
    if (message.publicEndpointEnabled !== false) {
      obj.publicEndpointEnabled = message.publicEndpointEnabled;
    }
    if (message.publicEndpointDomainName !== "") {
      obj.publicEndpointDomainName = message.publicEndpointDomainName;
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexEndpoint>): IndexEndpoint {
    return IndexEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexEndpoint>): IndexEndpoint {
    const message = createBaseIndexEndpoint();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.deployedIndexes = object.deployedIndexes?.map((e) => DeployedIndex.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.network = object.network ?? "";
    message.enablePrivateServiceConnect = object.enablePrivateServiceConnect ?? false;
    message.privateServiceConnectConfig =
      (object.privateServiceConnectConfig !== undefined && object.privateServiceConnectConfig !== null)
        ? PrivateServiceConnectConfig.fromPartial(object.privateServiceConnectConfig)
        : undefined;
    message.publicEndpointEnabled = object.publicEndpointEnabled ?? false;
    message.publicEndpointDomainName = object.publicEndpointDomainName ?? "";
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

function createBaseIndexEndpoint_LabelsEntry(): IndexEndpoint_LabelsEntry {
  return { key: "", value: "" };
}

export const IndexEndpoint_LabelsEntry: MessageFns<IndexEndpoint_LabelsEntry> = {
  encode(message: IndexEndpoint_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexEndpoint_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexEndpoint_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexEndpoint_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: IndexEndpoint_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexEndpoint_LabelsEntry>): IndexEndpoint_LabelsEntry {
    return IndexEndpoint_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexEndpoint_LabelsEntry>): IndexEndpoint_LabelsEntry {
    const message = createBaseIndexEndpoint_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeployedIndex(): DeployedIndex {
  return {
    id: "",
    index: "",
    displayName: "",
    createTime: undefined,
    privateEndpoints: undefined,
    indexSyncTime: undefined,
    automaticResources: undefined,
    dedicatedResources: undefined,
    enableAccessLogging: false,
    deployedIndexAuthConfig: undefined,
    reservedIpRanges: [],
    deploymentGroup: "",
    pscAutomationConfigs: [],
  };
}

export const DeployedIndex: MessageFns<DeployedIndex> = {
  encode(message: DeployedIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.privateEndpoints !== undefined) {
      IndexPrivateEndpoints.encode(message.privateEndpoints, writer.uint32(42).fork()).join();
    }
    if (message.indexSyncTime !== undefined) {
      Timestamp.encode(toTimestamp(message.indexSyncTime), writer.uint32(50).fork()).join();
    }
    if (message.automaticResources !== undefined) {
      AutomaticResources.encode(message.automaticResources, writer.uint32(58).fork()).join();
    }
    if (message.dedicatedResources !== undefined) {
      DedicatedResources.encode(message.dedicatedResources, writer.uint32(130).fork()).join();
    }
    if (message.enableAccessLogging !== false) {
      writer.uint32(64).bool(message.enableAccessLogging);
    }
    if (message.deployedIndexAuthConfig !== undefined) {
      DeployedIndexAuthConfig.encode(message.deployedIndexAuthConfig, writer.uint32(74).fork()).join();
    }
    for (const v of message.reservedIpRanges) {
      writer.uint32(82).string(v!);
    }
    if (message.deploymentGroup !== "") {
      writer.uint32(90).string(message.deploymentGroup);
    }
    for (const v of message.pscAutomationConfigs) {
      PSCAutomationConfig.encode(v!, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.privateEndpoints = IndexPrivateEndpoints.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.indexSyncTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.automaticResources = AutomaticResources.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.dedicatedResources = DedicatedResources.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.enableAccessLogging = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.deployedIndexAuthConfig = DeployedIndexAuthConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.reservedIpRanges.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.deploymentGroup = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.pscAutomationConfigs.push(PSCAutomationConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedIndex {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      privateEndpoints: isSet(object.privateEndpoints)
        ? IndexPrivateEndpoints.fromJSON(object.privateEndpoints)
        : undefined,
      indexSyncTime: isSet(object.indexSyncTime) ? fromJsonTimestamp(object.indexSyncTime) : undefined,
      automaticResources: isSet(object.automaticResources)
        ? AutomaticResources.fromJSON(object.automaticResources)
        : undefined,
      dedicatedResources: isSet(object.dedicatedResources)
        ? DedicatedResources.fromJSON(object.dedicatedResources)
        : undefined,
      enableAccessLogging: isSet(object.enableAccessLogging) ? globalThis.Boolean(object.enableAccessLogging) : false,
      deployedIndexAuthConfig: isSet(object.deployedIndexAuthConfig)
        ? DeployedIndexAuthConfig.fromJSON(object.deployedIndexAuthConfig)
        : undefined,
      reservedIpRanges: globalThis.Array.isArray(object?.reservedIpRanges)
        ? object.reservedIpRanges.map((e: any) => globalThis.String(e))
        : [],
      deploymentGroup: isSet(object.deploymentGroup) ? globalThis.String(object.deploymentGroup) : "",
      pscAutomationConfigs: globalThis.Array.isArray(object?.pscAutomationConfigs)
        ? object.pscAutomationConfigs.map((e: any) => PSCAutomationConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeployedIndex): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.privateEndpoints !== undefined) {
      obj.privateEndpoints = IndexPrivateEndpoints.toJSON(message.privateEndpoints);
    }
    if (message.indexSyncTime !== undefined) {
      obj.indexSyncTime = message.indexSyncTime.toISOString();
    }
    if (message.automaticResources !== undefined) {
      obj.automaticResources = AutomaticResources.toJSON(message.automaticResources);
    }
    if (message.dedicatedResources !== undefined) {
      obj.dedicatedResources = DedicatedResources.toJSON(message.dedicatedResources);
    }
    if (message.enableAccessLogging !== false) {
      obj.enableAccessLogging = message.enableAccessLogging;
    }
    if (message.deployedIndexAuthConfig !== undefined) {
      obj.deployedIndexAuthConfig = DeployedIndexAuthConfig.toJSON(message.deployedIndexAuthConfig);
    }
    if (message.reservedIpRanges?.length) {
      obj.reservedIpRanges = message.reservedIpRanges;
    }
    if (message.deploymentGroup !== "") {
      obj.deploymentGroup = message.deploymentGroup;
    }
    if (message.pscAutomationConfigs?.length) {
      obj.pscAutomationConfigs = message.pscAutomationConfigs.map((e) => PSCAutomationConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedIndex>): DeployedIndex {
    return DeployedIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedIndex>): DeployedIndex {
    const message = createBaseDeployedIndex();
    message.id = object.id ?? "";
    message.index = object.index ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.privateEndpoints = (object.privateEndpoints !== undefined && object.privateEndpoints !== null)
      ? IndexPrivateEndpoints.fromPartial(object.privateEndpoints)
      : undefined;
    message.indexSyncTime = object.indexSyncTime ?? undefined;
    message.automaticResources = (object.automaticResources !== undefined && object.automaticResources !== null)
      ? AutomaticResources.fromPartial(object.automaticResources)
      : undefined;
    message.dedicatedResources = (object.dedicatedResources !== undefined && object.dedicatedResources !== null)
      ? DedicatedResources.fromPartial(object.dedicatedResources)
      : undefined;
    message.enableAccessLogging = object.enableAccessLogging ?? false;
    message.deployedIndexAuthConfig =
      (object.deployedIndexAuthConfig !== undefined && object.deployedIndexAuthConfig !== null)
        ? DeployedIndexAuthConfig.fromPartial(object.deployedIndexAuthConfig)
        : undefined;
    message.reservedIpRanges = object.reservedIpRanges?.map((e) => e) || [];
    message.deploymentGroup = object.deploymentGroup ?? "";
    message.pscAutomationConfigs = object.pscAutomationConfigs?.map((e) => PSCAutomationConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployedIndexAuthConfig(): DeployedIndexAuthConfig {
  return { authProvider: undefined };
}

export const DeployedIndexAuthConfig: MessageFns<DeployedIndexAuthConfig> = {
  encode(message: DeployedIndexAuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authProvider !== undefined) {
      DeployedIndexAuthConfig_AuthProvider.encode(message.authProvider, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedIndexAuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedIndexAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authProvider = DeployedIndexAuthConfig_AuthProvider.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedIndexAuthConfig {
    return {
      authProvider: isSet(object.authProvider)
        ? DeployedIndexAuthConfig_AuthProvider.fromJSON(object.authProvider)
        : undefined,
    };
  },

  toJSON(message: DeployedIndexAuthConfig): unknown {
    const obj: any = {};
    if (message.authProvider !== undefined) {
      obj.authProvider = DeployedIndexAuthConfig_AuthProvider.toJSON(message.authProvider);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedIndexAuthConfig>): DeployedIndexAuthConfig {
    return DeployedIndexAuthConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedIndexAuthConfig>): DeployedIndexAuthConfig {
    const message = createBaseDeployedIndexAuthConfig();
    message.authProvider = (object.authProvider !== undefined && object.authProvider !== null)
      ? DeployedIndexAuthConfig_AuthProvider.fromPartial(object.authProvider)
      : undefined;
    return message;
  },
};

function createBaseDeployedIndexAuthConfig_AuthProvider(): DeployedIndexAuthConfig_AuthProvider {
  return { audiences: [], allowedIssuers: [] };
}

export const DeployedIndexAuthConfig_AuthProvider: MessageFns<DeployedIndexAuthConfig_AuthProvider> = {
  encode(message: DeployedIndexAuthConfig_AuthProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.audiences) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.allowedIssuers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedIndexAuthConfig_AuthProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedIndexAuthConfig_AuthProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audiences.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedIssuers.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedIndexAuthConfig_AuthProvider {
    return {
      audiences: globalThis.Array.isArray(object?.audiences)
        ? object.audiences.map((e: any) => globalThis.String(e))
        : [],
      allowedIssuers: globalThis.Array.isArray(object?.allowedIssuers)
        ? object.allowedIssuers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeployedIndexAuthConfig_AuthProvider): unknown {
    const obj: any = {};
    if (message.audiences?.length) {
      obj.audiences = message.audiences;
    }
    if (message.allowedIssuers?.length) {
      obj.allowedIssuers = message.allowedIssuers;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedIndexAuthConfig_AuthProvider>): DeployedIndexAuthConfig_AuthProvider {
    return DeployedIndexAuthConfig_AuthProvider.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedIndexAuthConfig_AuthProvider>): DeployedIndexAuthConfig_AuthProvider {
    const message = createBaseDeployedIndexAuthConfig_AuthProvider();
    message.audiences = object.audiences?.map((e) => e) || [];
    message.allowedIssuers = object.allowedIssuers?.map((e) => e) || [];
    return message;
  },
};

function createBaseIndexPrivateEndpoints(): IndexPrivateEndpoints {
  return { matchGrpcAddress: "", serviceAttachment: "", pscAutomatedEndpoints: [] };
}

export const IndexPrivateEndpoints: MessageFns<IndexPrivateEndpoints> = {
  encode(message: IndexPrivateEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchGrpcAddress !== "") {
      writer.uint32(10).string(message.matchGrpcAddress);
    }
    if (message.serviceAttachment !== "") {
      writer.uint32(18).string(message.serviceAttachment);
    }
    for (const v of message.pscAutomatedEndpoints) {
      PscAutomatedEndpoints.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexPrivateEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexPrivateEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchGrpcAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAttachment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pscAutomatedEndpoints.push(PscAutomatedEndpoints.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexPrivateEndpoints {
    return {
      matchGrpcAddress: isSet(object.matchGrpcAddress) ? globalThis.String(object.matchGrpcAddress) : "",
      serviceAttachment: isSet(object.serviceAttachment) ? globalThis.String(object.serviceAttachment) : "",
      pscAutomatedEndpoints: globalThis.Array.isArray(object?.pscAutomatedEndpoints)
        ? object.pscAutomatedEndpoints.map((e: any) => PscAutomatedEndpoints.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IndexPrivateEndpoints): unknown {
    const obj: any = {};
    if (message.matchGrpcAddress !== "") {
      obj.matchGrpcAddress = message.matchGrpcAddress;
    }
    if (message.serviceAttachment !== "") {
      obj.serviceAttachment = message.serviceAttachment;
    }
    if (message.pscAutomatedEndpoints?.length) {
      obj.pscAutomatedEndpoints = message.pscAutomatedEndpoints.map((e) => PscAutomatedEndpoints.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IndexPrivateEndpoints>): IndexPrivateEndpoints {
    return IndexPrivateEndpoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexPrivateEndpoints>): IndexPrivateEndpoints {
    const message = createBaseIndexPrivateEndpoints();
    message.matchGrpcAddress = object.matchGrpcAddress ?? "";
    message.serviceAttachment = object.serviceAttachment ?? "";
    message.pscAutomatedEndpoints = object.pscAutomatedEndpoints?.map((e) => PscAutomatedEndpoints.fromPartial(e)) ||
      [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
