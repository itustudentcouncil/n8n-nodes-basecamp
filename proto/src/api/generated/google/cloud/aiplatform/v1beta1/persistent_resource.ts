// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/persistent_resource.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { DiskSpec, MachineSpec } from "./machine_resources.js";
import { PscInterfaceConfig } from "./service_networking.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Represents long-lasting resources that are dedicated to users to runs custom
 * workloads.
 * A PersistentResource can have multiple node pools and each node
 * pool can have its own machine spec.
 */
export interface PersistentResource {
  /** Immutable. Resource name of a PersistentResource. */
  name: string;
  /**
   * Optional. The display name of the PersistentResource.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** Required. The spec of the pools of different resources. */
  resourcePools: ResourcePool[];
  /** Output only. The detailed state of a Study. */
  state: PersistentResource_State;
  /**
   * Output only. Only populated when persistent resource's state is `STOPPING`
   * or `ERROR`.
   */
  error:
    | Status
    | undefined;
  /** Output only. Time when the PersistentResource was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the PersistentResource for the first time entered
   * the `RUNNING` state.
   */
  startTime:
    | Date
    | undefined;
  /** Output only. Time when the PersistentResource was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The labels with user-defined metadata to organize
   * PersistentResource.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /**
   * Optional. The full name of the Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to peered with
   * Vertex AI to host the persistent resources.
   * For example, `projects/12345/global/networks/myVPC`.
   * [Format](/compute/docs/reference/rest/v1/networks/insert)
   * is of the form `projects/{project}/global/networks/{network}`.
   * Where {project} is a project number, as in `12345`, and {network} is a
   * network name.
   *
   * To specify this field, you must have already [configured VPC Network
   * Peering for Vertex
   * AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
   *
   * If this field is left unspecified, the resources aren't peered with any
   * network.
   */
  network: string;
  /** Optional. Configuration for PSC-I for PersistentResource. */
  pscInterfaceConfig:
    | PscInterfaceConfig
    | undefined;
  /**
   * Optional. Customer-managed encryption key spec for a PersistentResource.
   * If set, this PersistentResource and all sub-resources of this
   * PersistentResource will be secured by this key.
   */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /**
   * Optional. Persistent Resource runtime spec.
   * For example, used for Ray cluster configuration.
   */
  resourceRuntimeSpec:
    | ResourceRuntimeSpec
    | undefined;
  /** Output only. Runtime information of the Persistent Resource. */
  resourceRuntime:
    | ResourceRuntime
    | undefined;
  /**
   * Optional. A list of names for the reserved IP ranges under the VPC network
   * that can be used for this persistent resource.
   *
   * If set, we will deploy the persistent resource within the provided IP
   * ranges. Otherwise, the persistent resource is deployed to any IP
   * ranges under the provided VPC network.
   *
   * Example: ['vertex-ai-ip-range'].
   */
  reservedIpRanges: string[];
}

/** Describes the PersistentResource state. */
export enum PersistentResource_State {
  /** STATE_UNSPECIFIED - Not set. */
  STATE_UNSPECIFIED = 0,
  /**
   * PROVISIONING - The PROVISIONING state indicates the persistent resources is being
   * created.
   */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the persistent resource is healthy and fully
   * usable.
   */
  RUNNING = 3,
  /** STOPPING - The STOPPING state indicates the persistent resource is being deleted. */
  STOPPING = 4,
  /**
   * ERROR - The ERROR state indicates the persistent resource may be unusable.
   * Details can be found in the `error` field.
   */
  ERROR = 5,
  /**
   * REBOOTING - The REBOOTING state indicates the persistent resource is being rebooted
   * (PR is not available right now but is expected to be ready again later).
   */
  REBOOTING = 6,
  /** UPDATING - The UPDATING state indicates the persistent resource is being updated. */
  UPDATING = 7,
  UNRECOGNIZED = -1,
}

export function persistentResource_StateFromJSON(object: any): PersistentResource_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PersistentResource_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return PersistentResource_State.PROVISIONING;
    case 3:
    case "RUNNING":
      return PersistentResource_State.RUNNING;
    case 4:
    case "STOPPING":
      return PersistentResource_State.STOPPING;
    case 5:
    case "ERROR":
      return PersistentResource_State.ERROR;
    case 6:
    case "REBOOTING":
      return PersistentResource_State.REBOOTING;
    case 7:
    case "UPDATING":
      return PersistentResource_State.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersistentResource_State.UNRECOGNIZED;
  }
}

export function persistentResource_StateToJSON(object: PersistentResource_State): string {
  switch (object) {
    case PersistentResource_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PersistentResource_State.PROVISIONING:
      return "PROVISIONING";
    case PersistentResource_State.RUNNING:
      return "RUNNING";
    case PersistentResource_State.STOPPING:
      return "STOPPING";
    case PersistentResource_State.ERROR:
      return "ERROR";
    case PersistentResource_State.REBOOTING:
      return "REBOOTING";
    case PersistentResource_State.UPDATING:
      return "UPDATING";
    case PersistentResource_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PersistentResource_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Represents the spec of a group of resources of the same type,
 * for example machine type, disk, and accelerators, in a PersistentResource.
 */
export interface ResourcePool {
  /**
   * Immutable. The unique ID in a PersistentResource for referring to this
   * resource pool. User can specify it if necessary. Otherwise, it's generated
   * automatically.
   */
  id: string;
  /** Required. Immutable. The specification of a single machine. */
  machineSpec:
    | MachineSpec
    | undefined;
  /** Optional. The total number of machines to use for this resource pool. */
  replicaCount?:
    | Long
    | undefined;
  /** Optional. Disk spec for the machine in this node pool. */
  diskSpec:
    | DiskSpec
    | undefined;
  /**
   * Output only. The number of machines currently in use by training jobs for
   * this resource pool. Will replace idle_replica_count.
   */
  usedReplicaCount: Long;
  /** Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling */
  autoscalingSpec: ResourcePool_AutoscalingSpec | undefined;
}

/** The min/max number of replicas allowed if enabling autoscaling */
export interface ResourcePool_AutoscalingSpec {
  /**
   * Optional. min replicas in the node pool,
   * must be ≤ replica_count and < max_replica_count or will throw error.
   * For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
   * resource_pool to be 0 to match the OSS Ray
   * behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
   * As for Persistent Resource, the min_replica_count must be > 0, we added
   * a corresponding validation inside
   * CreatePersistentResourceRequestValidator.java.
   */
  minReplicaCount?:
    | Long
    | undefined;
  /**
   * Optional. max replicas in the node pool,
   * must be ≥ replica_count and > min_replica_count or will throw error
   */
  maxReplicaCount?: Long | undefined;
}

/**
 * Configuration for the runtime on a PersistentResource instance, including
 * but not limited to:
 *
 * * Service accounts used to run the workloads.
 * * Whether to make it a dedicated Ray Cluster.
 */
export interface ResourceRuntimeSpec {
  /** Optional. Configure the use of workload identity on the PersistentResource */
  serviceAccountSpec:
    | ServiceAccountSpec
    | undefined;
  /**
   * Optional. Ray cluster configuration.
   * Required when creating a dedicated RayCluster on the PersistentResource.
   */
  raySpec: RaySpec | undefined;
}

/**
 * Configuration information for the Ray cluster.
 * For experimental launch, Ray cluster creation and Persistent
 * cluster creation are 1:1 mapping: We will provision all the nodes within the
 * Persistent cluster as Ray nodes.
 */
export interface RaySpec {
  /**
   * Optional. Default image for user to choose a preferred ML framework
   * (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
   * images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
   * Either this or the resource_pool_images is required. Use this field if
   * you need all the resource pools to have the same Ray image. Otherwise, use
   * the {@code resource_pool_images} field.
   */
  imageUri: string;
  /**
   * Optional. Required if image_uri isn't set. A map of resource_pool_id to
   * prebuild Ray image if user need to use different images for different
   * head/worker pools. This map needs to cover all the resource pool ids.
   * Example:
   * {
   *   "ray_head_node_pool": "head image"
   *   "ray_worker_node_pool1": "worker image"
   *   "ray_worker_node_pool2": "another worker image"
   * }
   */
  resourcePoolImages: { [key: string]: string };
  /**
   * Optional. This will be used to indicate which resource pool will serve as
   * the Ray head node(the first node within that pool). Will use the machine
   * from the first workerpool as the head node by default if this field isn't
   * set.
   */
  headNodeResourcePoolId: string;
  /** Optional. Ray metrics configurations. */
  rayMetricSpec:
    | RayMetricSpec
    | undefined;
  /** Optional. OSS Ray logging configurations. */
  rayLogsSpec: RayLogsSpec | undefined;
}

export interface RaySpec_ResourcePoolImagesEntry {
  key: string;
  value: string;
}

/** Persistent Cluster runtime information as output */
export interface ResourceRuntime {
  /**
   * Output only. URIs for user to connect to the Cluster.
   * Example:
   * {
   *   "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
   *   "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
   * }
   */
  accessUris: { [key: string]: string };
  /**
   * Output only. The resource name of NotebookRuntimeTemplate for the RoV
   * Persistent Cluster The NotebokRuntimeTemplate is created in the same VPC
   * (if set), and with the same Ray and Python version as the Persistent
   * Cluster. Example:
   *   "projects/1000/locations/us-central1/notebookRuntimeTemplates/abc123"
   *
   * @deprecated
   */
  notebookRuntimeTemplate: string;
}

export interface ResourceRuntime_AccessUrisEntry {
  key: string;
  value: string;
}

/** Configuration for the use of custom service account to run the workloads. */
export interface ServiceAccountSpec {
  /**
   * Required. If true, custom user-managed service account is enforced to run
   * any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
   * the [Vertex AI Custom Code Service
   * Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
   */
  enableCustomServiceAccount: boolean;
  /**
   * Optional. Required when all below conditions are met
   *  * `enable_custom_service_account` is true;
   *  * any runtime is specified via `ResourceRuntimeSpec` on creation time,
   *    for example, Ray
   *
   * The users must have `iam.serviceAccounts.actAs` permission on this service
   * account and then the specified runtime containers will run as it.
   *
   * Do not set this field if you want to submit jobs using custom service
   * account to this PersistentResource after creation, but only specify the
   * `service_account` inside the job.
   */
  serviceAccount: string;
}

/** Configuration for the Ray metrics. */
export interface RayMetricSpec {
  /** Optional. Flag to disable the Ray metrics collection. */
  disabled: boolean;
}

/** Configuration for the Ray OSS Logs. */
export interface RayLogsSpec {
  /** Optional. Flag to disable the export of Ray OSS logs to Cloud Logging. */
  disabled: boolean;
}

function createBasePersistentResource(): PersistentResource {
  return {
    name: "",
    displayName: "",
    resourcePools: [],
    state: 0,
    error: undefined,
    createTime: undefined,
    startTime: undefined,
    updateTime: undefined,
    labels: {},
    network: "",
    pscInterfaceConfig: undefined,
    encryptionSpec: undefined,
    resourceRuntimeSpec: undefined,
    resourceRuntime: undefined,
    reservedIpRanges: [],
  };
}

export const PersistentResource: MessageFns<PersistentResource> = {
  encode(message: PersistentResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.resourcePools) {
      ResourcePool.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(50).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      PersistentResource_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.network !== "") {
      writer.uint32(90).string(message.network);
    }
    if (message.pscInterfaceConfig !== undefined) {
      PscInterfaceConfig.encode(message.pscInterfaceConfig, writer.uint32(138).fork()).join();
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(98).fork()).join();
    }
    if (message.resourceRuntimeSpec !== undefined) {
      ResourceRuntimeSpec.encode(message.resourceRuntimeSpec, writer.uint32(106).fork()).join();
    }
    if (message.resourceRuntime !== undefined) {
      ResourceRuntime.encode(message.resourceRuntime, writer.uint32(114).fork()).join();
    }
    for (const v of message.reservedIpRanges) {
      writer.uint32(122).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersistentResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersistentResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourcePools.push(ResourcePool.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = PersistentResource_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.network = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.pscInterfaceConfig = PscInterfaceConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.resourceRuntimeSpec = ResourceRuntimeSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.resourceRuntime = ResourceRuntime.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.reservedIpRanges.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersistentResource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      resourcePools: globalThis.Array.isArray(object?.resourcePools)
        ? object.resourcePools.map((e: any) => ResourcePool.fromJSON(e))
        : [],
      state: isSet(object.state) ? persistentResource_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      pscInterfaceConfig: isSet(object.pscInterfaceConfig)
        ? PscInterfaceConfig.fromJSON(object.pscInterfaceConfig)
        : undefined,
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      resourceRuntimeSpec: isSet(object.resourceRuntimeSpec)
        ? ResourceRuntimeSpec.fromJSON(object.resourceRuntimeSpec)
        : undefined,
      resourceRuntime: isSet(object.resourceRuntime) ? ResourceRuntime.fromJSON(object.resourceRuntime) : undefined,
      reservedIpRanges: globalThis.Array.isArray(object?.reservedIpRanges)
        ? object.reservedIpRanges.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PersistentResource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.resourcePools?.length) {
      obj.resourcePools = message.resourcePools.map((e) => ResourcePool.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = persistentResource_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.pscInterfaceConfig !== undefined) {
      obj.pscInterfaceConfig = PscInterfaceConfig.toJSON(message.pscInterfaceConfig);
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.resourceRuntimeSpec !== undefined) {
      obj.resourceRuntimeSpec = ResourceRuntimeSpec.toJSON(message.resourceRuntimeSpec);
    }
    if (message.resourceRuntime !== undefined) {
      obj.resourceRuntime = ResourceRuntime.toJSON(message.resourceRuntime);
    }
    if (message.reservedIpRanges?.length) {
      obj.reservedIpRanges = message.reservedIpRanges;
    }
    return obj;
  },

  create(base?: DeepPartial<PersistentResource>): PersistentResource {
    return PersistentResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PersistentResource>): PersistentResource {
    const message = createBasePersistentResource();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.resourcePools = object.resourcePools?.map((e) => ResourcePool.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.network = object.network ?? "";
    message.pscInterfaceConfig = (object.pscInterfaceConfig !== undefined && object.pscInterfaceConfig !== null)
      ? PscInterfaceConfig.fromPartial(object.pscInterfaceConfig)
      : undefined;
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.resourceRuntimeSpec = (object.resourceRuntimeSpec !== undefined && object.resourceRuntimeSpec !== null)
      ? ResourceRuntimeSpec.fromPartial(object.resourceRuntimeSpec)
      : undefined;
    message.resourceRuntime = (object.resourceRuntime !== undefined && object.resourceRuntime !== null)
      ? ResourceRuntime.fromPartial(object.resourceRuntime)
      : undefined;
    message.reservedIpRanges = object.reservedIpRanges?.map((e) => e) || [];
    return message;
  },
};

function createBasePersistentResource_LabelsEntry(): PersistentResource_LabelsEntry {
  return { key: "", value: "" };
}

export const PersistentResource_LabelsEntry: MessageFns<PersistentResource_LabelsEntry> = {
  encode(message: PersistentResource_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersistentResource_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersistentResource_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersistentResource_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PersistentResource_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PersistentResource_LabelsEntry>): PersistentResource_LabelsEntry {
    return PersistentResource_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PersistentResource_LabelsEntry>): PersistentResource_LabelsEntry {
    const message = createBasePersistentResource_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResourcePool(): ResourcePool {
  return {
    id: "",
    machineSpec: undefined,
    replicaCount: undefined,
    diskSpec: undefined,
    usedReplicaCount: Long.ZERO,
    autoscalingSpec: undefined,
  };
}

export const ResourcePool: MessageFns<ResourcePool> = {
  encode(message: ResourcePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.machineSpec !== undefined) {
      MachineSpec.encode(message.machineSpec, writer.uint32(18).fork()).join();
    }
    if (message.replicaCount !== undefined) {
      writer.uint32(24).int64(message.replicaCount.toString());
    }
    if (message.diskSpec !== undefined) {
      DiskSpec.encode(message.diskSpec, writer.uint32(34).fork()).join();
    }
    if (!message.usedReplicaCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.usedReplicaCount.toString());
    }
    if (message.autoscalingSpec !== undefined) {
      ResourcePool_AutoscalingSpec.encode(message.autoscalingSpec, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourcePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.machineSpec = MachineSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.replicaCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.diskSpec = DiskSpec.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.usedReplicaCount = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.autoscalingSpec = ResourcePool_AutoscalingSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcePool {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      machineSpec: isSet(object.machineSpec) ? MachineSpec.fromJSON(object.machineSpec) : undefined,
      replicaCount: isSet(object.replicaCount) ? Long.fromValue(object.replicaCount) : undefined,
      diskSpec: isSet(object.diskSpec) ? DiskSpec.fromJSON(object.diskSpec) : undefined,
      usedReplicaCount: isSet(object.usedReplicaCount) ? Long.fromValue(object.usedReplicaCount) : Long.ZERO,
      autoscalingSpec: isSet(object.autoscalingSpec)
        ? ResourcePool_AutoscalingSpec.fromJSON(object.autoscalingSpec)
        : undefined,
    };
  },

  toJSON(message: ResourcePool): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.machineSpec !== undefined) {
      obj.machineSpec = MachineSpec.toJSON(message.machineSpec);
    }
    if (message.replicaCount !== undefined) {
      obj.replicaCount = (message.replicaCount || Long.ZERO).toString();
    }
    if (message.diskSpec !== undefined) {
      obj.diskSpec = DiskSpec.toJSON(message.diskSpec);
    }
    if (!message.usedReplicaCount.equals(Long.ZERO)) {
      obj.usedReplicaCount = (message.usedReplicaCount || Long.ZERO).toString();
    }
    if (message.autoscalingSpec !== undefined) {
      obj.autoscalingSpec = ResourcePool_AutoscalingSpec.toJSON(message.autoscalingSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourcePool>): ResourcePool {
    return ResourcePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourcePool>): ResourcePool {
    const message = createBaseResourcePool();
    message.id = object.id ?? "";
    message.machineSpec = (object.machineSpec !== undefined && object.machineSpec !== null)
      ? MachineSpec.fromPartial(object.machineSpec)
      : undefined;
    message.replicaCount = (object.replicaCount !== undefined && object.replicaCount !== null)
      ? Long.fromValue(object.replicaCount)
      : undefined;
    message.diskSpec = (object.diskSpec !== undefined && object.diskSpec !== null)
      ? DiskSpec.fromPartial(object.diskSpec)
      : undefined;
    message.usedReplicaCount = (object.usedReplicaCount !== undefined && object.usedReplicaCount !== null)
      ? Long.fromValue(object.usedReplicaCount)
      : Long.ZERO;
    message.autoscalingSpec = (object.autoscalingSpec !== undefined && object.autoscalingSpec !== null)
      ? ResourcePool_AutoscalingSpec.fromPartial(object.autoscalingSpec)
      : undefined;
    return message;
  },
};

function createBaseResourcePool_AutoscalingSpec(): ResourcePool_AutoscalingSpec {
  return { minReplicaCount: undefined, maxReplicaCount: undefined };
}

export const ResourcePool_AutoscalingSpec: MessageFns<ResourcePool_AutoscalingSpec> = {
  encode(message: ResourcePool_AutoscalingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minReplicaCount !== undefined) {
      writer.uint32(8).int64(message.minReplicaCount.toString());
    }
    if (message.maxReplicaCount !== undefined) {
      writer.uint32(16).int64(message.maxReplicaCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourcePool_AutoscalingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePool_AutoscalingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minReplicaCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxReplicaCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcePool_AutoscalingSpec {
    return {
      minReplicaCount: isSet(object.minReplicaCount) ? Long.fromValue(object.minReplicaCount) : undefined,
      maxReplicaCount: isSet(object.maxReplicaCount) ? Long.fromValue(object.maxReplicaCount) : undefined,
    };
  },

  toJSON(message: ResourcePool_AutoscalingSpec): unknown {
    const obj: any = {};
    if (message.minReplicaCount !== undefined) {
      obj.minReplicaCount = (message.minReplicaCount || Long.ZERO).toString();
    }
    if (message.maxReplicaCount !== undefined) {
      obj.maxReplicaCount = (message.maxReplicaCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ResourcePool_AutoscalingSpec>): ResourcePool_AutoscalingSpec {
    return ResourcePool_AutoscalingSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourcePool_AutoscalingSpec>): ResourcePool_AutoscalingSpec {
    const message = createBaseResourcePool_AutoscalingSpec();
    message.minReplicaCount = (object.minReplicaCount !== undefined && object.minReplicaCount !== null)
      ? Long.fromValue(object.minReplicaCount)
      : undefined;
    message.maxReplicaCount = (object.maxReplicaCount !== undefined && object.maxReplicaCount !== null)
      ? Long.fromValue(object.maxReplicaCount)
      : undefined;
    return message;
  },
};

function createBaseResourceRuntimeSpec(): ResourceRuntimeSpec {
  return { serviceAccountSpec: undefined, raySpec: undefined };
}

export const ResourceRuntimeSpec: MessageFns<ResourceRuntimeSpec> = {
  encode(message: ResourceRuntimeSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountSpec !== undefined) {
      ServiceAccountSpec.encode(message.serviceAccountSpec, writer.uint32(18).fork()).join();
    }
    if (message.raySpec !== undefined) {
      RaySpec.encode(message.raySpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRuntimeSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRuntimeSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccountSpec = ServiceAccountSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.raySpec = RaySpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRuntimeSpec {
    return {
      serviceAccountSpec: isSet(object.serviceAccountSpec)
        ? ServiceAccountSpec.fromJSON(object.serviceAccountSpec)
        : undefined,
      raySpec: isSet(object.raySpec) ? RaySpec.fromJSON(object.raySpec) : undefined,
    };
  },

  toJSON(message: ResourceRuntimeSpec): unknown {
    const obj: any = {};
    if (message.serviceAccountSpec !== undefined) {
      obj.serviceAccountSpec = ServiceAccountSpec.toJSON(message.serviceAccountSpec);
    }
    if (message.raySpec !== undefined) {
      obj.raySpec = RaySpec.toJSON(message.raySpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRuntimeSpec>): ResourceRuntimeSpec {
    return ResourceRuntimeSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRuntimeSpec>): ResourceRuntimeSpec {
    const message = createBaseResourceRuntimeSpec();
    message.serviceAccountSpec = (object.serviceAccountSpec !== undefined && object.serviceAccountSpec !== null)
      ? ServiceAccountSpec.fromPartial(object.serviceAccountSpec)
      : undefined;
    message.raySpec = (object.raySpec !== undefined && object.raySpec !== null)
      ? RaySpec.fromPartial(object.raySpec)
      : undefined;
    return message;
  },
};

function createBaseRaySpec(): RaySpec {
  return {
    imageUri: "",
    resourcePoolImages: {},
    headNodeResourcePoolId: "",
    rayMetricSpec: undefined,
    rayLogsSpec: undefined,
  };
}

export const RaySpec: MessageFns<RaySpec> = {
  encode(message: RaySpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUri !== "") {
      writer.uint32(10).string(message.imageUri);
    }
    Object.entries(message.resourcePoolImages).forEach(([key, value]) => {
      RaySpec_ResourcePoolImagesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.headNodeResourcePoolId !== "") {
      writer.uint32(58).string(message.headNodeResourcePoolId);
    }
    if (message.rayMetricSpec !== undefined) {
      RayMetricSpec.encode(message.rayMetricSpec, writer.uint32(66).fork()).join();
    }
    if (message.rayLogsSpec !== undefined) {
      RayLogsSpec.encode(message.rayLogsSpec, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = RaySpec_ResourcePoolImagesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.resourcePoolImages[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.headNodeResourcePoolId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.rayMetricSpec = RayMetricSpec.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rayLogsSpec = RayLogsSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaySpec {
    return {
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      resourcePoolImages: isObject(object.resourcePoolImages)
        ? Object.entries(object.resourcePoolImages).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      headNodeResourcePoolId: isSet(object.headNodeResourcePoolId)
        ? globalThis.String(object.headNodeResourcePoolId)
        : "",
      rayMetricSpec: isSet(object.rayMetricSpec) ? RayMetricSpec.fromJSON(object.rayMetricSpec) : undefined,
      rayLogsSpec: isSet(object.rayLogsSpec) ? RayLogsSpec.fromJSON(object.rayLogsSpec) : undefined,
    };
  },

  toJSON(message: RaySpec): unknown {
    const obj: any = {};
    if (message.imageUri !== "") {
      obj.imageUri = message.imageUri;
    }
    if (message.resourcePoolImages) {
      const entries = Object.entries(message.resourcePoolImages);
      if (entries.length > 0) {
        obj.resourcePoolImages = {};
        entries.forEach(([k, v]) => {
          obj.resourcePoolImages[k] = v;
        });
      }
    }
    if (message.headNodeResourcePoolId !== "") {
      obj.headNodeResourcePoolId = message.headNodeResourcePoolId;
    }
    if (message.rayMetricSpec !== undefined) {
      obj.rayMetricSpec = RayMetricSpec.toJSON(message.rayMetricSpec);
    }
    if (message.rayLogsSpec !== undefined) {
      obj.rayLogsSpec = RayLogsSpec.toJSON(message.rayLogsSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<RaySpec>): RaySpec {
    return RaySpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RaySpec>): RaySpec {
    const message = createBaseRaySpec();
    message.imageUri = object.imageUri ?? "";
    message.resourcePoolImages = Object.entries(object.resourcePoolImages ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.headNodeResourcePoolId = object.headNodeResourcePoolId ?? "";
    message.rayMetricSpec = (object.rayMetricSpec !== undefined && object.rayMetricSpec !== null)
      ? RayMetricSpec.fromPartial(object.rayMetricSpec)
      : undefined;
    message.rayLogsSpec = (object.rayLogsSpec !== undefined && object.rayLogsSpec !== null)
      ? RayLogsSpec.fromPartial(object.rayLogsSpec)
      : undefined;
    return message;
  },
};

function createBaseRaySpec_ResourcePoolImagesEntry(): RaySpec_ResourcePoolImagesEntry {
  return { key: "", value: "" };
}

export const RaySpec_ResourcePoolImagesEntry: MessageFns<RaySpec_ResourcePoolImagesEntry> = {
  encode(message: RaySpec_ResourcePoolImagesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaySpec_ResourcePoolImagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaySpec_ResourcePoolImagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaySpec_ResourcePoolImagesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RaySpec_ResourcePoolImagesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RaySpec_ResourcePoolImagesEntry>): RaySpec_ResourcePoolImagesEntry {
    return RaySpec_ResourcePoolImagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RaySpec_ResourcePoolImagesEntry>): RaySpec_ResourcePoolImagesEntry {
    const message = createBaseRaySpec_ResourcePoolImagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResourceRuntime(): ResourceRuntime {
  return { accessUris: {}, notebookRuntimeTemplate: "" };
}

export const ResourceRuntime: MessageFns<ResourceRuntime> = {
  encode(message: ResourceRuntime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.accessUris).forEach(([key, value]) => {
      ResourceRuntime_AccessUrisEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.notebookRuntimeTemplate !== "") {
      writer.uint32(18).string(message.notebookRuntimeTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRuntime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ResourceRuntime_AccessUrisEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.accessUris[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notebookRuntimeTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRuntime {
    return {
      accessUris: isObject(object.accessUris)
        ? Object.entries(object.accessUris).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      notebookRuntimeTemplate: isSet(object.notebookRuntimeTemplate)
        ? globalThis.String(object.notebookRuntimeTemplate)
        : "",
    };
  },

  toJSON(message: ResourceRuntime): unknown {
    const obj: any = {};
    if (message.accessUris) {
      const entries = Object.entries(message.accessUris);
      if (entries.length > 0) {
        obj.accessUris = {};
        entries.forEach(([k, v]) => {
          obj.accessUris[k] = v;
        });
      }
    }
    if (message.notebookRuntimeTemplate !== "") {
      obj.notebookRuntimeTemplate = message.notebookRuntimeTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRuntime>): ResourceRuntime {
    return ResourceRuntime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRuntime>): ResourceRuntime {
    const message = createBaseResourceRuntime();
    message.accessUris = Object.entries(object.accessUris ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.notebookRuntimeTemplate = object.notebookRuntimeTemplate ?? "";
    return message;
  },
};

function createBaseResourceRuntime_AccessUrisEntry(): ResourceRuntime_AccessUrisEntry {
  return { key: "", value: "" };
}

export const ResourceRuntime_AccessUrisEntry: MessageFns<ResourceRuntime_AccessUrisEntry> = {
  encode(message: ResourceRuntime_AccessUrisEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRuntime_AccessUrisEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRuntime_AccessUrisEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRuntime_AccessUrisEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceRuntime_AccessUrisEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRuntime_AccessUrisEntry>): ResourceRuntime_AccessUrisEntry {
    return ResourceRuntime_AccessUrisEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRuntime_AccessUrisEntry>): ResourceRuntime_AccessUrisEntry {
    const message = createBaseResourceRuntime_AccessUrisEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceAccountSpec(): ServiceAccountSpec {
  return { enableCustomServiceAccount: false, serviceAccount: "" };
}

export const ServiceAccountSpec: MessageFns<ServiceAccountSpec> = {
  encode(message: ServiceAccountSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableCustomServiceAccount !== false) {
      writer.uint32(8).bool(message.enableCustomServiceAccount);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableCustomServiceAccount = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountSpec {
    return {
      enableCustomServiceAccount: isSet(object.enableCustomServiceAccount)
        ? globalThis.Boolean(object.enableCustomServiceAccount)
        : false,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: ServiceAccountSpec): unknown {
    const obj: any = {};
    if (message.enableCustomServiceAccount !== false) {
      obj.enableCustomServiceAccount = message.enableCustomServiceAccount;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccountSpec>): ServiceAccountSpec {
    return ServiceAccountSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccountSpec>): ServiceAccountSpec {
    const message = createBaseServiceAccountSpec();
    message.enableCustomServiceAccount = object.enableCustomServiceAccount ?? false;
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseRayMetricSpec(): RayMetricSpec {
  return { disabled: false };
}

export const RayMetricSpec: MessageFns<RayMetricSpec> = {
  encode(message: RayMetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RayMetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRayMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RayMetricSpec {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: RayMetricSpec): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<RayMetricSpec>): RayMetricSpec {
    return RayMetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RayMetricSpec>): RayMetricSpec {
    const message = createBaseRayMetricSpec();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseRayLogsSpec(): RayLogsSpec {
  return { disabled: false };
}

export const RayLogsSpec: MessageFns<RayLogsSpec> = {
  encode(message: RayLogsSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RayLogsSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRayLogsSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RayLogsSpec {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: RayLogsSpec): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<RayLogsSpec>): RayLogsSpec {
    return RayLogsSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RayLogsSpec>): RayLogsSpec {
    const message = createBaseRayLogsSpec();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
