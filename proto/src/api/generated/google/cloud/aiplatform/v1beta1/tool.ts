// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/tool.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";
import { Schema } from "./openapi.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Tool details that the model may use to generate response.
 *
 * A `Tool` is a piece of code that enables the system to interact with
 * external systems to perform an action, or set of actions, outside of
 * knowledge and scope of the model. A Tool object should contain exactly
 * one type of Tool (e.g FunctionDeclaration, Retrieval or
 * GoogleSearchRetrieval).
 */
export interface Tool {
  /**
   * Optional. Function tool type.
   * One or more function declarations to be passed to the model along with the
   * current user query. Model may decide to call a subset of these functions
   * by populating [FunctionCall][content.part.function_call] in the response.
   * User should provide a [FunctionResponse][content.part.function_response]
   * for each function call in the next turn. Based on the function responses,
   * Model will generate the final response back to the user.
   * Maximum 64 function declarations can be provided.
   */
  functionDeclarations: FunctionDeclaration[];
  /**
   * Optional. Retrieval tool type.
   * System will always execute the provided retrieval tool(s) to get external
   * knowledge to answer the prompt. Retrieval results are presented to the
   * model for generation.
   */
  retrieval:
    | Retrieval
    | undefined;
  /**
   * Optional. GoogleSearchRetrieval tool type.
   * Specialized retrieval tool that is powered by Google search.
   */
  googleSearchRetrieval: GoogleSearchRetrieval | undefined;
}

/** A single example of the tool usage. */
export interface ToolUseExample {
  /** Extension operation to call. */
  extensionOperation?:
    | ToolUseExample_ExtensionOperation
    | undefined;
  /** Function name to call. */
  functionName?:
    | string
    | undefined;
  /** Required. The display name for example. */
  displayName: string;
  /** Required. Query that should be routed to this tool. */
  query: string;
  /** Request parameters used for executing this tool. */
  requestParams:
    | { [key: string]: any }
    | undefined;
  /** Response parameters generated by this tool. */
  responseParams:
    | { [key: string]: any }
    | undefined;
  /** Summary of the tool response to the user query. */
  responseSummary: string;
}

/** Identifies one operation of the extension. */
export interface ToolUseExample_ExtensionOperation {
  /** Resource name of the extension. */
  extension: string;
  /** Required. Operation ID of the extension. */
  operationId: string;
}

/**
 * Structured representation of a function declaration as defined by the
 * [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
 * in this declaration are the function name and parameters. This
 * FunctionDeclaration is a representation of a block of code that can be used
 * as a `Tool` by the model and executed by the client.
 */
export interface FunctionDeclaration {
  /**
   * Required. The name of the function to call.
   * Must start with a letter or an underscore.
   * Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
   * maximum length of 64.
   */
  name: string;
  /**
   * Optional. Description and purpose of the function.
   * Model uses it to decide how and whether to call the function.
   */
  description: string;
  /**
   * Optional. Describes the parameters to this function in JSON Schema Object
   * format. Reflects the Open API 3.03 Parameter Object. string Key: the name
   * of the parameter. Parameter names are case sensitive. Schema Value: the
   * Schema defining the type used for the parameter. For function with no
   * parameters, this can be left unset. Parameter names must start with a
   * letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
   * underscores with a maximum length of 64. Example with 1 required and 1
   * optional parameter: type: OBJECT properties:
   *  param1:
   *    type: STRING
   *  param2:
   *    type: INTEGER
   * required:
   *  - param1
   */
  parameters:
    | Schema
    | undefined;
  /**
   * Optional. Describes the output from this function in JSON Schema format.
   * Reflects the Open API 3.03 Response Object. The Schema defines the type
   * used for the response value of the function.
   */
  response: Schema | undefined;
}

/**
 * A predicted [FunctionCall] returned from the model that contains a string
 * representing the [FunctionDeclaration.name] and a structured JSON object
 * containing the parameters and their values.
 */
export interface FunctionCall {
  /**
   * Required. The name of the function to call.
   * Matches [FunctionDeclaration.name].
   */
  name: string;
  /**
   * Optional. Required. The function parameters and values in JSON object
   * format. See [FunctionDeclaration.parameters] for parameter details.
   */
  args: { [key: string]: any } | undefined;
}

/**
 * The result output from a [FunctionCall] that contains a string representing
 * the [FunctionDeclaration.name] and a structured JSON object containing any
 * output from the function is used as context to the model. This should contain
 * the result of a [FunctionCall] made based on model prediction.
 */
export interface FunctionResponse {
  /**
   * Required. The name of the function to call.
   * Matches [FunctionDeclaration.name] and [FunctionCall.name].
   */
  name: string;
  /** Required. The function response in JSON object format. */
  response: { [key: string]: any } | undefined;
}

/** Defines a retrieval tool that model can call to access external knowledge. */
export interface Retrieval {
  /** Set to use data source powered by Vertex AI Search. */
  vertexAiSearch?:
    | VertexAISearch
    | undefined;
  /**
   * Set to use data source powered by Vertex RAG store.
   * User data is uploaded via the VertexRagDataService.
   */
  vertexRagStore?:
    | VertexRagStore
    | undefined;
  /**
   * Optional. Deprecated. This option is no longer supported.
   *
   * @deprecated
   */
  disableAttribution: boolean;
}

/** Retrieve from Vertex RAG Store for grounding. */
export interface VertexRagStore {
  /**
   * Optional. Deprecated. Please use rag_resources instead.
   *
   * @deprecated
   */
  ragCorpora: string[];
  /**
   * Optional. The representation of the rag source. It can be used to specify
   * corpus only or ragfiles. Currently only support one corpus or multiple
   * files from one corpus. In the future we may open up multiple corpora
   * support.
   */
  ragResources: VertexRagStore_RagResource[];
  /** Optional. Number of top k results to return from the selected corpora. */
  similarityTopK?:
    | number
    | undefined;
  /**
   * Optional. Only return results with vector distance smaller than the
   * threshold.
   */
  vectorDistanceThreshold?: number | undefined;
}

/** The definition of the Rag resource. */
export interface VertexRagStore_RagResource {
  /**
   * Optional. RagCorpora resource name.
   * Format:
   * `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
   */
  ragCorpus: string;
  /**
   * Optional. rag_file_id. The files should be in the same rag_corpus set in
   * rag_corpus field.
   */
  ragFileIds: string[];
}

/**
 * Retrieve from Vertex AI Search datastore for grounding.
 * See https://cloud.google.com/vertex-ai-search-and-conversation
 */
export interface VertexAISearch {
  /**
   * Required. Fully-qualified Vertex AI Search's datastore resource ID.
   * Format:
   * `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
   */
  datastore: string;
}

/** Tool to retrieve public web data for grounding, powered by Google. */
export interface GoogleSearchRetrieval {
}

/** Tool config. This config is shared for all tools provided in the request. */
export interface ToolConfig {
  /** Optional. Function calling config. */
  functionCallingConfig: FunctionCallingConfig | undefined;
}

/** Function calling config. */
export interface FunctionCallingConfig {
  /** Optional. Function calling mode. */
  mode: FunctionCallingConfig_Mode;
  /**
   * Optional. Function names to call. Only set when the Mode is ANY. Function
   * names should match [FunctionDeclaration.name]. With mode set to ANY, model
   * will predict a function call from the set of function names provided.
   */
  allowedFunctionNames: string[];
}

/** Function calling mode. */
export enum FunctionCallingConfig_Mode {
  /** MODE_UNSPECIFIED - Unspecified function calling mode. This value should not be used. */
  MODE_UNSPECIFIED = 0,
  /**
   * AUTO - Default model behavior, model decides to predict either a function call
   * or a natural language response.
   */
  AUTO = 1,
  /**
   * ANY - Model is constrained to always predicting a function call only.
   * If "allowed_function_names" are set, the predicted function call will be
   * limited to any one of "allowed_function_names", else the predicted
   * function call will be any one of the provided "function_declarations".
   */
  ANY = 2,
  /**
   * NONE - Model will not predict any function call. Model behavior is same as when
   * not passing any function declarations.
   */
  NONE = 3,
  UNRECOGNIZED = -1,
}

export function functionCallingConfig_ModeFromJSON(object: any): FunctionCallingConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return FunctionCallingConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "AUTO":
      return FunctionCallingConfig_Mode.AUTO;
    case 2:
    case "ANY":
      return FunctionCallingConfig_Mode.ANY;
    case 3:
    case "NONE":
      return FunctionCallingConfig_Mode.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FunctionCallingConfig_Mode.UNRECOGNIZED;
  }
}

export function functionCallingConfig_ModeToJSON(object: FunctionCallingConfig_Mode): string {
  switch (object) {
    case FunctionCallingConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case FunctionCallingConfig_Mode.AUTO:
      return "AUTO";
    case FunctionCallingConfig_Mode.ANY:
      return "ANY";
    case FunctionCallingConfig_Mode.NONE:
      return "NONE";
    case FunctionCallingConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseTool(): Tool {
  return { functionDeclarations: [], retrieval: undefined, googleSearchRetrieval: undefined };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.functionDeclarations) {
      FunctionDeclaration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.retrieval !== undefined) {
      Retrieval.encode(message.retrieval, writer.uint32(18).fork()).join();
    }
    if (message.googleSearchRetrieval !== undefined) {
      GoogleSearchRetrieval.encode(message.googleSearchRetrieval, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionDeclarations.push(FunctionDeclaration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retrieval = Retrieval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.googleSearchRetrieval = GoogleSearchRetrieval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      functionDeclarations: globalThis.Array.isArray(object?.functionDeclarations)
        ? object.functionDeclarations.map((e: any) => FunctionDeclaration.fromJSON(e))
        : [],
      retrieval: isSet(object.retrieval) ? Retrieval.fromJSON(object.retrieval) : undefined,
      googleSearchRetrieval: isSet(object.googleSearchRetrieval)
        ? GoogleSearchRetrieval.fromJSON(object.googleSearchRetrieval)
        : undefined,
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.functionDeclarations?.length) {
      obj.functionDeclarations = message.functionDeclarations.map((e) => FunctionDeclaration.toJSON(e));
    }
    if (message.retrieval !== undefined) {
      obj.retrieval = Retrieval.toJSON(message.retrieval);
    }
    if (message.googleSearchRetrieval !== undefined) {
      obj.googleSearchRetrieval = GoogleSearchRetrieval.toJSON(message.googleSearchRetrieval);
    }
    return obj;
  },

  create(base?: DeepPartial<Tool>): Tool {
    return Tool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tool>): Tool {
    const message = createBaseTool();
    message.functionDeclarations = object.functionDeclarations?.map((e) => FunctionDeclaration.fromPartial(e)) || [];
    message.retrieval = (object.retrieval !== undefined && object.retrieval !== null)
      ? Retrieval.fromPartial(object.retrieval)
      : undefined;
    message.googleSearchRetrieval =
      (object.googleSearchRetrieval !== undefined && object.googleSearchRetrieval !== null)
        ? GoogleSearchRetrieval.fromPartial(object.googleSearchRetrieval)
        : undefined;
    return message;
  },
};

function createBaseToolUseExample(): ToolUseExample {
  return {
    extensionOperation: undefined,
    functionName: undefined,
    displayName: "",
    query: "",
    requestParams: undefined,
    responseParams: undefined,
    responseSummary: "",
  };
}

export const ToolUseExample: MessageFns<ToolUseExample> = {
  encode(message: ToolUseExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.extensionOperation !== undefined) {
      ToolUseExample_ExtensionOperation.encode(message.extensionOperation, writer.uint32(82).fork()).join();
    }
    if (message.functionName !== undefined) {
      writer.uint32(90).string(message.functionName);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.requestParams !== undefined) {
      Struct.encode(Struct.wrap(message.requestParams), writer.uint32(26).fork()).join();
    }
    if (message.responseParams !== undefined) {
      Struct.encode(Struct.wrap(message.responseParams), writer.uint32(34).fork()).join();
    }
    if (message.responseSummary !== "") {
      writer.uint32(42).string(message.responseSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolUseExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolUseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.extensionOperation = ToolUseExample_ExtensionOperation.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.functionName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestParams = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.responseParams = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.responseSummary = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolUseExample {
    return {
      extensionOperation: isSet(object.extensionOperation)
        ? ToolUseExample_ExtensionOperation.fromJSON(object.extensionOperation)
        : undefined,
      functionName: isSet(object.functionName) ? globalThis.String(object.functionName) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      requestParams: isObject(object.requestParams) ? object.requestParams : undefined,
      responseParams: isObject(object.responseParams) ? object.responseParams : undefined,
      responseSummary: isSet(object.responseSummary) ? globalThis.String(object.responseSummary) : "",
    };
  },

  toJSON(message: ToolUseExample): unknown {
    const obj: any = {};
    if (message.extensionOperation !== undefined) {
      obj.extensionOperation = ToolUseExample_ExtensionOperation.toJSON(message.extensionOperation);
    }
    if (message.functionName !== undefined) {
      obj.functionName = message.functionName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.requestParams !== undefined) {
      obj.requestParams = message.requestParams;
    }
    if (message.responseParams !== undefined) {
      obj.responseParams = message.responseParams;
    }
    if (message.responseSummary !== "") {
      obj.responseSummary = message.responseSummary;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolUseExample>): ToolUseExample {
    return ToolUseExample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolUseExample>): ToolUseExample {
    const message = createBaseToolUseExample();
    message.extensionOperation = (object.extensionOperation !== undefined && object.extensionOperation !== null)
      ? ToolUseExample_ExtensionOperation.fromPartial(object.extensionOperation)
      : undefined;
    message.functionName = object.functionName ?? undefined;
    message.displayName = object.displayName ?? "";
    message.query = object.query ?? "";
    message.requestParams = object.requestParams ?? undefined;
    message.responseParams = object.responseParams ?? undefined;
    message.responseSummary = object.responseSummary ?? "";
    return message;
  },
};

function createBaseToolUseExample_ExtensionOperation(): ToolUseExample_ExtensionOperation {
  return { extension: "", operationId: "" };
}

export const ToolUseExample_ExtensionOperation: MessageFns<ToolUseExample_ExtensionOperation> = {
  encode(message: ToolUseExample_ExtensionOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.extension !== "") {
      writer.uint32(10).string(message.extension);
    }
    if (message.operationId !== "") {
      writer.uint32(18).string(message.operationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolUseExample_ExtensionOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolUseExample_ExtensionOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extension = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolUseExample_ExtensionOperation {
    return {
      extension: isSet(object.extension) ? globalThis.String(object.extension) : "",
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
    };
  },

  toJSON(message: ToolUseExample_ExtensionOperation): unknown {
    const obj: any = {};
    if (message.extension !== "") {
      obj.extension = message.extension;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    return obj;
  },

  create(base?: DeepPartial<ToolUseExample_ExtensionOperation>): ToolUseExample_ExtensionOperation {
    return ToolUseExample_ExtensionOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolUseExample_ExtensionOperation>): ToolUseExample_ExtensionOperation {
    const message = createBaseToolUseExample_ExtensionOperation();
    message.extension = object.extension ?? "";
    message.operationId = object.operationId ?? "";
    return message;
  },
};

function createBaseFunctionDeclaration(): FunctionDeclaration {
  return { name: "", description: "", parameters: undefined, response: undefined };
}

export const FunctionDeclaration: MessageFns<FunctionDeclaration> = {
  encode(message: FunctionDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parameters !== undefined) {
      Schema.encode(message.parameters, writer.uint32(26).fork()).join();
    }
    if (message.response !== undefined) {
      Schema.encode(message.response, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parameters = Schema.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.response = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDeclaration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isSet(object.parameters) ? Schema.fromJSON(object.parameters) : undefined,
      response: isSet(object.response) ? Schema.fromJSON(object.response) : undefined,
    };
  },

  toJSON(message: FunctionDeclaration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters !== undefined) {
      obj.parameters = Schema.toJSON(message.parameters);
    }
    if (message.response !== undefined) {
      obj.response = Schema.toJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    return FunctionDeclaration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    const message = createBaseFunctionDeclaration();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? Schema.fromPartial(object.parameters)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? Schema.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { name: "", args: undefined };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(message: FunctionCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== undefined) {
      Struct.encode(Struct.wrap(message.args), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isObject(object.args) ? object.args : undefined,
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== undefined) {
      obj.args = message.args;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall();
    message.name = object.name ?? "";
    message.args = object.args ?? undefined;
    return message;
  },
};

function createBaseFunctionResponse(): FunctionResponse {
  return { name: "", response: undefined };
}

export const FunctionResponse: MessageFns<FunctionResponse> = {
  encode(message: FunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.response !== undefined) {
      Struct.encode(Struct.wrap(message.response), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      response: isObject(object.response) ? object.response : undefined,
    };
  },

  toJSON(message: FunctionResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionResponse>): FunctionResponse {
    return FunctionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionResponse>): FunctionResponse {
    const message = createBaseFunctionResponse();
    message.name = object.name ?? "";
    message.response = object.response ?? undefined;
    return message;
  },
};

function createBaseRetrieval(): Retrieval {
  return { vertexAiSearch: undefined, vertexRagStore: undefined, disableAttribution: false };
}

export const Retrieval: MessageFns<Retrieval> = {
  encode(message: Retrieval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vertexAiSearch !== undefined) {
      VertexAISearch.encode(message.vertexAiSearch, writer.uint32(18).fork()).join();
    }
    if (message.vertexRagStore !== undefined) {
      VertexRagStore.encode(message.vertexRagStore, writer.uint32(34).fork()).join();
    }
    if (message.disableAttribution !== false) {
      writer.uint32(24).bool(message.disableAttribution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Retrieval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vertexAiSearch = VertexAISearch.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vertexRagStore = VertexRagStore.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.disableAttribution = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Retrieval {
    return {
      vertexAiSearch: isSet(object.vertexAiSearch) ? VertexAISearch.fromJSON(object.vertexAiSearch) : undefined,
      vertexRagStore: isSet(object.vertexRagStore) ? VertexRagStore.fromJSON(object.vertexRagStore) : undefined,
      disableAttribution: isSet(object.disableAttribution) ? globalThis.Boolean(object.disableAttribution) : false,
    };
  },

  toJSON(message: Retrieval): unknown {
    const obj: any = {};
    if (message.vertexAiSearch !== undefined) {
      obj.vertexAiSearch = VertexAISearch.toJSON(message.vertexAiSearch);
    }
    if (message.vertexRagStore !== undefined) {
      obj.vertexRagStore = VertexRagStore.toJSON(message.vertexRagStore);
    }
    if (message.disableAttribution !== false) {
      obj.disableAttribution = message.disableAttribution;
    }
    return obj;
  },

  create(base?: DeepPartial<Retrieval>): Retrieval {
    return Retrieval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Retrieval>): Retrieval {
    const message = createBaseRetrieval();
    message.vertexAiSearch = (object.vertexAiSearch !== undefined && object.vertexAiSearch !== null)
      ? VertexAISearch.fromPartial(object.vertexAiSearch)
      : undefined;
    message.vertexRagStore = (object.vertexRagStore !== undefined && object.vertexRagStore !== null)
      ? VertexRagStore.fromPartial(object.vertexRagStore)
      : undefined;
    message.disableAttribution = object.disableAttribution ?? false;
    return message;
  },
};

function createBaseVertexRagStore(): VertexRagStore {
  return { ragCorpora: [], ragResources: [], similarityTopK: undefined, vectorDistanceThreshold: undefined };
}

export const VertexRagStore: MessageFns<VertexRagStore> = {
  encode(message: VertexRagStore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ragCorpora) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.ragResources) {
      VertexRagStore_RagResource.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.similarityTopK !== undefined) {
      writer.uint32(16).int32(message.similarityTopK);
    }
    if (message.vectorDistanceThreshold !== undefined) {
      writer.uint32(25).double(message.vectorDistanceThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexRagStore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexRagStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ragCorpora.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ragResources.push(VertexRagStore_RagResource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.similarityTopK = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.vectorDistanceThreshold = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexRagStore {
    return {
      ragCorpora: globalThis.Array.isArray(object?.ragCorpora)
        ? object.ragCorpora.map((e: any) => globalThis.String(e))
        : [],
      ragResources: globalThis.Array.isArray(object?.ragResources)
        ? object.ragResources.map((e: any) => VertexRagStore_RagResource.fromJSON(e))
        : [],
      similarityTopK: isSet(object.similarityTopK) ? globalThis.Number(object.similarityTopK) : undefined,
      vectorDistanceThreshold: isSet(object.vectorDistanceThreshold)
        ? globalThis.Number(object.vectorDistanceThreshold)
        : undefined,
    };
  },

  toJSON(message: VertexRagStore): unknown {
    const obj: any = {};
    if (message.ragCorpora?.length) {
      obj.ragCorpora = message.ragCorpora;
    }
    if (message.ragResources?.length) {
      obj.ragResources = message.ragResources.map((e) => VertexRagStore_RagResource.toJSON(e));
    }
    if (message.similarityTopK !== undefined) {
      obj.similarityTopK = Math.round(message.similarityTopK);
    }
    if (message.vectorDistanceThreshold !== undefined) {
      obj.vectorDistanceThreshold = message.vectorDistanceThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexRagStore>): VertexRagStore {
    return VertexRagStore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexRagStore>): VertexRagStore {
    const message = createBaseVertexRagStore();
    message.ragCorpora = object.ragCorpora?.map((e) => e) || [];
    message.ragResources = object.ragResources?.map((e) => VertexRagStore_RagResource.fromPartial(e)) || [];
    message.similarityTopK = object.similarityTopK ?? undefined;
    message.vectorDistanceThreshold = object.vectorDistanceThreshold ?? undefined;
    return message;
  },
};

function createBaseVertexRagStore_RagResource(): VertexRagStore_RagResource {
  return { ragCorpus: "", ragFileIds: [] };
}

export const VertexRagStore_RagResource: MessageFns<VertexRagStore_RagResource> = {
  encode(message: VertexRagStore_RagResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ragCorpus !== "") {
      writer.uint32(10).string(message.ragCorpus);
    }
    for (const v of message.ragFileIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexRagStore_RagResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexRagStore_RagResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ragCorpus = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ragFileIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexRagStore_RagResource {
    return {
      ragCorpus: isSet(object.ragCorpus) ? globalThis.String(object.ragCorpus) : "",
      ragFileIds: globalThis.Array.isArray(object?.ragFileIds)
        ? object.ragFileIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VertexRagStore_RagResource): unknown {
    const obj: any = {};
    if (message.ragCorpus !== "") {
      obj.ragCorpus = message.ragCorpus;
    }
    if (message.ragFileIds?.length) {
      obj.ragFileIds = message.ragFileIds;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexRagStore_RagResource>): VertexRagStore_RagResource {
    return VertexRagStore_RagResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexRagStore_RagResource>): VertexRagStore_RagResource {
    const message = createBaseVertexRagStore_RagResource();
    message.ragCorpus = object.ragCorpus ?? "";
    message.ragFileIds = object.ragFileIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseVertexAISearch(): VertexAISearch {
  return { datastore: "" };
}

export const VertexAISearch: MessageFns<VertexAISearch> = {
  encode(message: VertexAISearch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datastore !== "") {
      writer.uint32(10).string(message.datastore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAISearch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAISearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datastore = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAISearch {
    return { datastore: isSet(object.datastore) ? globalThis.String(object.datastore) : "" };
  },

  toJSON(message: VertexAISearch): unknown {
    const obj: any = {};
    if (message.datastore !== "") {
      obj.datastore = message.datastore;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexAISearch>): VertexAISearch {
    return VertexAISearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexAISearch>): VertexAISearch {
    const message = createBaseVertexAISearch();
    message.datastore = object.datastore ?? "";
    return message;
  },
};

function createBaseGoogleSearchRetrieval(): GoogleSearchRetrieval {
  return {};
}

export const GoogleSearchRetrieval: MessageFns<GoogleSearchRetrieval> = {
  encode(_: GoogleSearchRetrieval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleSearchRetrieval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleSearchRetrieval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GoogleSearchRetrieval {
    return {};
  },

  toJSON(_: GoogleSearchRetrieval): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    return GoogleSearchRetrieval.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    const message = createBaseGoogleSearchRetrieval();
    return message;
  },
};

function createBaseToolConfig(): ToolConfig {
  return { functionCallingConfig: undefined };
}

export const ToolConfig: MessageFns<ToolConfig> = {
  encode(message: ToolConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionCallingConfig !== undefined) {
      FunctionCallingConfig.encode(message.functionCallingConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionCallingConfig = FunctionCallingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolConfig {
    return {
      functionCallingConfig: isSet(object.functionCallingConfig)
        ? FunctionCallingConfig.fromJSON(object.functionCallingConfig)
        : undefined,
    };
  },

  toJSON(message: ToolConfig): unknown {
    const obj: any = {};
    if (message.functionCallingConfig !== undefined) {
      obj.functionCallingConfig = FunctionCallingConfig.toJSON(message.functionCallingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ToolConfig>): ToolConfig {
    return ToolConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolConfig>): ToolConfig {
    const message = createBaseToolConfig();
    message.functionCallingConfig =
      (object.functionCallingConfig !== undefined && object.functionCallingConfig !== null)
        ? FunctionCallingConfig.fromPartial(object.functionCallingConfig)
        : undefined;
    return message;
  },
};

function createBaseFunctionCallingConfig(): FunctionCallingConfig {
  return { mode: 0, allowedFunctionNames: [] };
}

export const FunctionCallingConfig: MessageFns<FunctionCallingConfig> = {
  encode(message: FunctionCallingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    for (const v of message.allowedFunctionNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCallingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedFunctionNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCallingConfig {
    return {
      mode: isSet(object.mode) ? functionCallingConfig_ModeFromJSON(object.mode) : 0,
      allowedFunctionNames: globalThis.Array.isArray(object?.allowedFunctionNames)
        ? object.allowedFunctionNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FunctionCallingConfig): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = functionCallingConfig_ModeToJSON(message.mode);
    }
    if (message.allowedFunctionNames?.length) {
      obj.allowedFunctionNames = message.allowedFunctionNames;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    return FunctionCallingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    const message = createBaseFunctionCallingConfig();
    message.mode = object.mode ?? 0;
    message.allowedFunctionNames = object.allowedFunctionNames?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
