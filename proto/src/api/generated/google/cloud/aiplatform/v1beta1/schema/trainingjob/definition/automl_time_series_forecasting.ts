// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/schema/trainingjob/definition/automl_time_series_forecasting.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ExportEvaluatedDataItemsConfig } from "./export_evaluated_data_items_config.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1.schema.trainingjob.definition";

/** A TrainingJob that trains and uploads an AutoML Forecasting Model. */
export interface AutoMlForecasting {
  /** The input parameters of this TrainingJob. */
  inputs:
    | AutoMlForecastingInputs
    | undefined;
  /** The metadata information. */
  metadata: AutoMlForecastingMetadata | undefined;
}

export interface AutoMlForecastingInputs {
  /** The name of the column that the model is to predict. */
  targetColumn: string;
  /** The name of the column that identifies the time series. */
  timeSeriesIdentifierColumn: string;
  /** The name of the column that identifies time order in the time series. */
  timeColumn: string;
  /**
   * Each transformation will apply transform function to given input column.
   * And the result will be used for training.
   * When creating transformation for BigQuery Struct column, the column should
   * be flattened using "." as the delimiter.
   */
  transformations: AutoMlForecastingInputs_Transformation[];
  /**
   * Objective function the model is optimizing towards. The training process
   * creates a model that optimizes the value of the objective
   * function over the validation set.
   *
   * The supported optimization objectives:
   *
   *   * "minimize-rmse" (default) - Minimize root-mean-squared error (RMSE).
   *
   *   * "minimize-mae" - Minimize mean-absolute error (MAE).
   *
   *   * "minimize-rmsle" - Minimize root-mean-squared log error (RMSLE).
   *
   *   * "minimize-rmspe" - Minimize root-mean-squared percentage error (RMSPE).
   *
   *   * "minimize-wape-mae" - Minimize the combination of weighted absolute
   *     percentage error (WAPE) and mean-absolute-error (MAE).
   *
   *   * "minimize-quantile-loss" - Minimize the quantile loss at the quantiles
   *     defined in `quantiles`.
   */
  optimizationObjective: string;
  /**
   * Required. The train budget of creating this model, expressed in milli node
   * hours i.e. 1,000 value in this field means 1 node hour.
   *
   * The training cost of the model will not exceed this budget. The final cost
   * will be attempted to be close to the budget, though may end up being (even)
   * noticeably smaller - at the backend's discretion. This especially may
   * happen when further model training ceases to provide any improvements.
   *
   * If the budget is set to a value known to be insufficient to train a
   * model for the given dataset, the training won't be attempted and
   * will error.
   *
   * The train budget must be between 1,000 and 72,000 milli node hours,
   * inclusive.
   */
  trainBudgetMilliNodeHours: Long;
  /**
   * Column name that should be used as the weight column.
   * Higher values in this column give more importance to the row
   * during model training. The column must have numeric values between 0 and
   * 10000 inclusively; 0 means the row is ignored for training. If weight
   * column field is not set, then all rows are assumed to have equal weight
   * of 1.
   */
  weightColumn: string;
  /**
   * Column names that should be used as attribute columns.
   * The value of these columns does not vary as a function of time.
   * For example, store ID or item color.
   */
  timeSeriesAttributeColumns: string[];
  /**
   * Names of columns that are unavailable when a forecast is requested.
   * This column contains information for the given entity (identified
   * by the time_series_identifier_column) that is unknown before the forecast
   * For example, actual weather on a given day.
   */
  unavailableAtForecastColumns: string[];
  /**
   * Names of columns that are available and provided when a forecast
   * is requested. These columns
   * contain information for the given entity (identified by the
   * time_series_identifier_column column) that is known at forecast.
   * For example, predicted weather for a specific day.
   */
  availableAtForecastColumns: string[];
  /** Expected difference in time granularity between rows in the data. */
  dataGranularity:
    | AutoMlForecastingInputs_Granularity
    | undefined;
  /**
   * The amount of time into the future for which forecasted values for the
   * target are returned. Expressed in number of units defined by the
   * `data_granularity` field.
   */
  forecastHorizon: Long;
  /**
   * The amount of time into the past training and prediction data is used
   * for model training and prediction respectively. Expressed in number of
   * units defined by the `data_granularity` field.
   */
  contextWindow: Long;
  /**
   * Configuration for exporting test set predictions to a BigQuery table. If
   * this configuration is absent, then the export is not performed.
   */
  exportEvaluatedDataItemsConfig:
    | ExportEvaluatedDataItemsConfig
    | undefined;
  /**
   * Quantiles to use for minimize-quantile-loss `optimization_objective`. Up to
   * 5 quantiles are allowed of values between 0 and 1, exclusive. Required if
   * the value of optimization_objective is minimize-quantile-loss. Represents
   * the percent quantiles to use for that objective. Quantiles must be unique.
   */
  quantiles: number[];
  /**
   * Validation options for the data validation component. The available options
   * are:
   *
   *   * "fail-pipeline" - default, will validate against the validation and
   *      fail the pipeline if it fails.
   *
   *   * "ignore-validation" - ignore the results of the validation and continue
   */
  validationOptions: string;
  /** Additional experiment flags for the time series forcasting training. */
  additionalExperiments: string[];
}

export interface AutoMlForecastingInputs_Transformation {
  auto?: AutoMlForecastingInputs_Transformation_AutoTransformation | undefined;
  numeric?: AutoMlForecastingInputs_Transformation_NumericTransformation | undefined;
  categorical?: AutoMlForecastingInputs_Transformation_CategoricalTransformation | undefined;
  timestamp?: AutoMlForecastingInputs_Transformation_TimestampTransformation | undefined;
  text?: AutoMlForecastingInputs_Transformation_TextTransformation | undefined;
}

/**
 * Training pipeline will infer the proper transformation based on the
 * statistic of dataset.
 */
export interface AutoMlForecastingInputs_Transformation_AutoTransformation {
  columnName: string;
}

/**
 * Training pipeline will perform following transformation functions.
 *
 * *  The value converted to float32.
 *
 * *  The z_score of the value.
 *
 * *  log(value+1) when the value is greater than or equal to 0. Otherwise,
 *    this transformation is not applied and the value is considered a
 *    missing value.
 *
 * *  z_score of log(value+1) when the value is greater than or equal to 0.
 *    Otherwise, this transformation is not applied and the value is
 *    considered a missing value.
 *
 * *  A boolean value that indicates whether the value is valid.
 */
export interface AutoMlForecastingInputs_Transformation_NumericTransformation {
  columnName: string;
}

/**
 * Training pipeline will perform following transformation functions.
 *
 * *  The categorical string as is--no change to case, punctuation,
 *    spelling, tense, and so on.
 *
 * *  Convert the category name to a dictionary lookup index and generate an
 *    embedding for each index.
 *
 * *  Categories that appear less than 5 times in the training dataset are
 *    treated as the "unknown" category. The "unknown" category gets its own
 *    special lookup index and resulting embedding.
 */
export interface AutoMlForecastingInputs_Transformation_CategoricalTransformation {
  columnName: string;
}

/**
 * Training pipeline will perform following transformation functions.
 *
 * *  Apply the transformation functions for Numerical columns.
 *
 * *  Determine the year, month, day,and weekday. Treat each value from the
 *    timestamp as a Categorical column.
 *
 * *  Invalid numerical values (for example, values that fall outside of a
 *    typical timestamp range, or are extreme values) receive no special
 *    treatment and are not removed.
 */
export interface AutoMlForecastingInputs_Transformation_TimestampTransformation {
  columnName: string;
  /**
   * The format in which that time field is expressed. The time_format must
   * either be one of:
   *
   * * `unix-seconds`
   *
   * * `unix-milliseconds`
   *
   * * `unix-microseconds`
   *
   * * `unix-nanoseconds`
   *
   * (for respectively number of seconds, milliseconds, microseconds and
   * nanoseconds since start of the Unix epoch);
   *
   * or be written in `strftime` syntax.
   *
   * If time_format is not set, then the
   * default format is RFC 3339 `date-time` format, where
   * `time-offset` = `"Z"` (e.g. 1985-04-12T23:20:50.52Z)
   */
  timeFormat: string;
}

/**
 * Training pipeline will perform following transformation functions.
 *
 * *  The text as is--no change to case, punctuation, spelling, tense, and
 *    so on.
 *
 * *  Convert the category name to a dictionary lookup index and generate an
 *    embedding for each index.
 */
export interface AutoMlForecastingInputs_Transformation_TextTransformation {
  columnName: string;
}

/** A duration of time expressed in time granularity units. */
export interface AutoMlForecastingInputs_Granularity {
  /**
   * The time granularity unit of this time period.
   * The supported units are:
   *
   *  * "minute"
   *
   *  * "hour"
   *
   *  * "day"
   *
   *  * "week"
   *
   *  * "month"
   *
   *  * "year"
   */
  unit: string;
  /**
   * The number of granularity_units between data points in the training
   * data. If `granularity_unit` is `minute`,
   * can be 1, 5, 10, 15, or 30. For all other values of `granularity_unit`,
   * must be 1.
   */
  quantity: Long;
}

/** Model metadata specific to AutoML Forecasting. */
export interface AutoMlForecastingMetadata {
  /**
   * Output only. The actual training cost of the model, expressed in milli
   * node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed
   * to not exceed the train budget.
   */
  trainCostMilliNodeHours: Long;
}

function createBaseAutoMlForecasting(): AutoMlForecasting {
  return { inputs: undefined, metadata: undefined };
}

export const AutoMlForecasting: MessageFns<AutoMlForecasting> = {
  encode(message: AutoMlForecasting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== undefined) {
      AutoMlForecastingInputs.encode(message.inputs, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      AutoMlForecastingMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecasting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecasting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs = AutoMlForecastingInputs.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = AutoMlForecastingMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecasting {
    return {
      inputs: isSet(object.inputs) ? AutoMlForecastingInputs.fromJSON(object.inputs) : undefined,
      metadata: isSet(object.metadata) ? AutoMlForecastingMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AutoMlForecasting): unknown {
    const obj: any = {};
    if (message.inputs !== undefined) {
      obj.inputs = AutoMlForecastingInputs.toJSON(message.inputs);
    }
    if (message.metadata !== undefined) {
      obj.metadata = AutoMlForecastingMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlForecasting>): AutoMlForecasting {
    return AutoMlForecasting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlForecasting>): AutoMlForecasting {
    const message = createBaseAutoMlForecasting();
    message.inputs = (object.inputs !== undefined && object.inputs !== null)
      ? AutoMlForecastingInputs.fromPartial(object.inputs)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AutoMlForecastingMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAutoMlForecastingInputs(): AutoMlForecastingInputs {
  return {
    targetColumn: "",
    timeSeriesIdentifierColumn: "",
    timeColumn: "",
    transformations: [],
    optimizationObjective: "",
    trainBudgetMilliNodeHours: Long.ZERO,
    weightColumn: "",
    timeSeriesAttributeColumns: [],
    unavailableAtForecastColumns: [],
    availableAtForecastColumns: [],
    dataGranularity: undefined,
    forecastHorizon: Long.ZERO,
    contextWindow: Long.ZERO,
    exportEvaluatedDataItemsConfig: undefined,
    quantiles: [],
    validationOptions: "",
    additionalExperiments: [],
  };
}

export const AutoMlForecastingInputs: MessageFns<AutoMlForecastingInputs> = {
  encode(message: AutoMlForecastingInputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetColumn !== "") {
      writer.uint32(10).string(message.targetColumn);
    }
    if (message.timeSeriesIdentifierColumn !== "") {
      writer.uint32(18).string(message.timeSeriesIdentifierColumn);
    }
    if (message.timeColumn !== "") {
      writer.uint32(26).string(message.timeColumn);
    }
    for (const v of message.transformations) {
      AutoMlForecastingInputs_Transformation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.optimizationObjective !== "") {
      writer.uint32(42).string(message.optimizationObjective);
    }
    if (!message.trainBudgetMilliNodeHours.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.trainBudgetMilliNodeHours.toString());
    }
    if (message.weightColumn !== "") {
      writer.uint32(58).string(message.weightColumn);
    }
    for (const v of message.timeSeriesAttributeColumns) {
      writer.uint32(154).string(v!);
    }
    for (const v of message.unavailableAtForecastColumns) {
      writer.uint32(162).string(v!);
    }
    for (const v of message.availableAtForecastColumns) {
      writer.uint32(170).string(v!);
    }
    if (message.dataGranularity !== undefined) {
      AutoMlForecastingInputs_Granularity.encode(message.dataGranularity, writer.uint32(178).fork()).join();
    }
    if (!message.forecastHorizon.equals(Long.ZERO)) {
      writer.uint32(184).int64(message.forecastHorizon.toString());
    }
    if (!message.contextWindow.equals(Long.ZERO)) {
      writer.uint32(192).int64(message.contextWindow.toString());
    }
    if (message.exportEvaluatedDataItemsConfig !== undefined) {
      ExportEvaluatedDataItemsConfig.encode(message.exportEvaluatedDataItemsConfig, writer.uint32(122).fork()).join();
    }
    writer.uint32(130).fork();
    for (const v of message.quantiles) {
      writer.double(v);
    }
    writer.join();
    if (message.validationOptions !== "") {
      writer.uint32(138).string(message.validationOptions);
    }
    for (const v of message.additionalExperiments) {
      writer.uint32(202).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingInputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetColumn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeSeriesIdentifierColumn = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeColumn = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transformations.push(AutoMlForecastingInputs_Transformation.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.optimizationObjective = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.trainBudgetMilliNodeHours = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.weightColumn = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.timeSeriesAttributeColumns.push(reader.string());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.unavailableAtForecastColumns.push(reader.string());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.availableAtForecastColumns.push(reader.string());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.dataGranularity = AutoMlForecastingInputs_Granularity.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.forecastHorizon = Long.fromString(reader.int64().toString());
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.contextWindow = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.exportEvaluatedDataItemsConfig = ExportEvaluatedDataItemsConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag === 129) {
            message.quantiles.push(reader.double());

            continue;
          }

          if (tag === 130) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.quantiles.push(reader.double());
            }

            continue;
          }

          break;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.validationOptions = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.additionalExperiments.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs {
    return {
      targetColumn: isSet(object.targetColumn) ? globalThis.String(object.targetColumn) : "",
      timeSeriesIdentifierColumn: isSet(object.timeSeriesIdentifierColumn)
        ? globalThis.String(object.timeSeriesIdentifierColumn)
        : "",
      timeColumn: isSet(object.timeColumn) ? globalThis.String(object.timeColumn) : "",
      transformations: globalThis.Array.isArray(object?.transformations)
        ? object.transformations.map((e: any) => AutoMlForecastingInputs_Transformation.fromJSON(e))
        : [],
      optimizationObjective: isSet(object.optimizationObjective) ? globalThis.String(object.optimizationObjective) : "",
      trainBudgetMilliNodeHours: isSet(object.trainBudgetMilliNodeHours)
        ? Long.fromValue(object.trainBudgetMilliNodeHours)
        : Long.ZERO,
      weightColumn: isSet(object.weightColumn) ? globalThis.String(object.weightColumn) : "",
      timeSeriesAttributeColumns: globalThis.Array.isArray(object?.timeSeriesAttributeColumns)
        ? object.timeSeriesAttributeColumns.map((e: any) => globalThis.String(e))
        : [],
      unavailableAtForecastColumns: globalThis.Array.isArray(object?.unavailableAtForecastColumns)
        ? object.unavailableAtForecastColumns.map((e: any) => globalThis.String(e))
        : [],
      availableAtForecastColumns: globalThis.Array.isArray(object?.availableAtForecastColumns)
        ? object.availableAtForecastColumns.map((e: any) => globalThis.String(e))
        : [],
      dataGranularity: isSet(object.dataGranularity)
        ? AutoMlForecastingInputs_Granularity.fromJSON(object.dataGranularity)
        : undefined,
      forecastHorizon: isSet(object.forecastHorizon) ? Long.fromValue(object.forecastHorizon) : Long.ZERO,
      contextWindow: isSet(object.contextWindow) ? Long.fromValue(object.contextWindow) : Long.ZERO,
      exportEvaluatedDataItemsConfig: isSet(object.exportEvaluatedDataItemsConfig)
        ? ExportEvaluatedDataItemsConfig.fromJSON(object.exportEvaluatedDataItemsConfig)
        : undefined,
      quantiles: globalThis.Array.isArray(object?.quantiles)
        ? object.quantiles.map((e: any) => globalThis.Number(e))
        : [],
      validationOptions: isSet(object.validationOptions) ? globalThis.String(object.validationOptions) : "",
      additionalExperiments: globalThis.Array.isArray(object?.additionalExperiments)
        ? object.additionalExperiments.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AutoMlForecastingInputs): unknown {
    const obj: any = {};
    if (message.targetColumn !== "") {
      obj.targetColumn = message.targetColumn;
    }
    if (message.timeSeriesIdentifierColumn !== "") {
      obj.timeSeriesIdentifierColumn = message.timeSeriesIdentifierColumn;
    }
    if (message.timeColumn !== "") {
      obj.timeColumn = message.timeColumn;
    }
    if (message.transformations?.length) {
      obj.transformations = message.transformations.map((e) => AutoMlForecastingInputs_Transformation.toJSON(e));
    }
    if (message.optimizationObjective !== "") {
      obj.optimizationObjective = message.optimizationObjective;
    }
    if (!message.trainBudgetMilliNodeHours.equals(Long.ZERO)) {
      obj.trainBudgetMilliNodeHours = (message.trainBudgetMilliNodeHours || Long.ZERO).toString();
    }
    if (message.weightColumn !== "") {
      obj.weightColumn = message.weightColumn;
    }
    if (message.timeSeriesAttributeColumns?.length) {
      obj.timeSeriesAttributeColumns = message.timeSeriesAttributeColumns;
    }
    if (message.unavailableAtForecastColumns?.length) {
      obj.unavailableAtForecastColumns = message.unavailableAtForecastColumns;
    }
    if (message.availableAtForecastColumns?.length) {
      obj.availableAtForecastColumns = message.availableAtForecastColumns;
    }
    if (message.dataGranularity !== undefined) {
      obj.dataGranularity = AutoMlForecastingInputs_Granularity.toJSON(message.dataGranularity);
    }
    if (!message.forecastHorizon.equals(Long.ZERO)) {
      obj.forecastHorizon = (message.forecastHorizon || Long.ZERO).toString();
    }
    if (!message.contextWindow.equals(Long.ZERO)) {
      obj.contextWindow = (message.contextWindow || Long.ZERO).toString();
    }
    if (message.exportEvaluatedDataItemsConfig !== undefined) {
      obj.exportEvaluatedDataItemsConfig = ExportEvaluatedDataItemsConfig.toJSON(
        message.exportEvaluatedDataItemsConfig,
      );
    }
    if (message.quantiles?.length) {
      obj.quantiles = message.quantiles;
    }
    if (message.validationOptions !== "") {
      obj.validationOptions = message.validationOptions;
    }
    if (message.additionalExperiments?.length) {
      obj.additionalExperiments = message.additionalExperiments;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlForecastingInputs>): AutoMlForecastingInputs {
    return AutoMlForecastingInputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlForecastingInputs>): AutoMlForecastingInputs {
    const message = createBaseAutoMlForecastingInputs();
    message.targetColumn = object.targetColumn ?? "";
    message.timeSeriesIdentifierColumn = object.timeSeriesIdentifierColumn ?? "";
    message.timeColumn = object.timeColumn ?? "";
    message.transformations =
      object.transformations?.map((e) => AutoMlForecastingInputs_Transformation.fromPartial(e)) || [];
    message.optimizationObjective = object.optimizationObjective ?? "";
    message.trainBudgetMilliNodeHours =
      (object.trainBudgetMilliNodeHours !== undefined && object.trainBudgetMilliNodeHours !== null)
        ? Long.fromValue(object.trainBudgetMilliNodeHours)
        : Long.ZERO;
    message.weightColumn = object.weightColumn ?? "";
    message.timeSeriesAttributeColumns = object.timeSeriesAttributeColumns?.map((e) => e) || [];
    message.unavailableAtForecastColumns = object.unavailableAtForecastColumns?.map((e) => e) || [];
    message.availableAtForecastColumns = object.availableAtForecastColumns?.map((e) => e) || [];
    message.dataGranularity = (object.dataGranularity !== undefined && object.dataGranularity !== null)
      ? AutoMlForecastingInputs_Granularity.fromPartial(object.dataGranularity)
      : undefined;
    message.forecastHorizon = (object.forecastHorizon !== undefined && object.forecastHorizon !== null)
      ? Long.fromValue(object.forecastHorizon)
      : Long.ZERO;
    message.contextWindow = (object.contextWindow !== undefined && object.contextWindow !== null)
      ? Long.fromValue(object.contextWindow)
      : Long.ZERO;
    message.exportEvaluatedDataItemsConfig =
      (object.exportEvaluatedDataItemsConfig !== undefined && object.exportEvaluatedDataItemsConfig !== null)
        ? ExportEvaluatedDataItemsConfig.fromPartial(object.exportEvaluatedDataItemsConfig)
        : undefined;
    message.quantiles = object.quantiles?.map((e) => e) || [];
    message.validationOptions = object.validationOptions ?? "";
    message.additionalExperiments = object.additionalExperiments?.map((e) => e) || [];
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation(): AutoMlForecastingInputs_Transformation {
  return { auto: undefined, numeric: undefined, categorical: undefined, timestamp: undefined, text: undefined };
}

export const AutoMlForecastingInputs_Transformation: MessageFns<AutoMlForecastingInputs_Transformation> = {
  encode(message: AutoMlForecastingInputs_Transformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.auto !== undefined) {
      AutoMlForecastingInputs_Transformation_AutoTransformation.encode(message.auto, writer.uint32(10).fork()).join();
    }
    if (message.numeric !== undefined) {
      AutoMlForecastingInputs_Transformation_NumericTransformation.encode(message.numeric, writer.uint32(18).fork())
        .join();
    }
    if (message.categorical !== undefined) {
      AutoMlForecastingInputs_Transformation_CategoricalTransformation.encode(
        message.categorical,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.timestamp !== undefined) {
      AutoMlForecastingInputs_Transformation_TimestampTransformation.encode(message.timestamp, writer.uint32(34).fork())
        .join();
    }
    if (message.text !== undefined) {
      AutoMlForecastingInputs_Transformation_TextTransformation.encode(message.text, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingInputs_Transformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.auto = AutoMlForecastingInputs_Transformation_AutoTransformation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numeric = AutoMlForecastingInputs_Transformation_NumericTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.categorical = AutoMlForecastingInputs_Transformation_CategoricalTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = AutoMlForecastingInputs_Transformation_TimestampTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = AutoMlForecastingInputs_Transformation_TextTransformation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation {
    return {
      auto: isSet(object.auto)
        ? AutoMlForecastingInputs_Transformation_AutoTransformation.fromJSON(object.auto)
        : undefined,
      numeric: isSet(object.numeric)
        ? AutoMlForecastingInputs_Transformation_NumericTransformation.fromJSON(object.numeric)
        : undefined,
      categorical: isSet(object.categorical)
        ? AutoMlForecastingInputs_Transformation_CategoricalTransformation.fromJSON(object.categorical)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? AutoMlForecastingInputs_Transformation_TimestampTransformation.fromJSON(object.timestamp)
        : undefined,
      text: isSet(object.text)
        ? AutoMlForecastingInputs_Transformation_TextTransformation.fromJSON(object.text)
        : undefined,
    };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation): unknown {
    const obj: any = {};
    if (message.auto !== undefined) {
      obj.auto = AutoMlForecastingInputs_Transformation_AutoTransformation.toJSON(message.auto);
    }
    if (message.numeric !== undefined) {
      obj.numeric = AutoMlForecastingInputs_Transformation_NumericTransformation.toJSON(message.numeric);
    }
    if (message.categorical !== undefined) {
      obj.categorical = AutoMlForecastingInputs_Transformation_CategoricalTransformation.toJSON(message.categorical);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = AutoMlForecastingInputs_Transformation_TimestampTransformation.toJSON(message.timestamp);
    }
    if (message.text !== undefined) {
      obj.text = AutoMlForecastingInputs_Transformation_TextTransformation.toJSON(message.text);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlForecastingInputs_Transformation>): AutoMlForecastingInputs_Transformation {
    return AutoMlForecastingInputs_Transformation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlForecastingInputs_Transformation>): AutoMlForecastingInputs_Transformation {
    const message = createBaseAutoMlForecastingInputs_Transformation();
    message.auto = (object.auto !== undefined && object.auto !== null)
      ? AutoMlForecastingInputs_Transformation_AutoTransformation.fromPartial(object.auto)
      : undefined;
    message.numeric = (object.numeric !== undefined && object.numeric !== null)
      ? AutoMlForecastingInputs_Transformation_NumericTransformation.fromPartial(object.numeric)
      : undefined;
    message.categorical = (object.categorical !== undefined && object.categorical !== null)
      ? AutoMlForecastingInputs_Transformation_CategoricalTransformation.fromPartial(object.categorical)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? AutoMlForecastingInputs_Transformation_TimestampTransformation.fromPartial(object.timestamp)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AutoMlForecastingInputs_Transformation_TextTransformation.fromPartial(object.text)
      : undefined;
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation_AutoTransformation(): AutoMlForecastingInputs_Transformation_AutoTransformation {
  return { columnName: "" };
}

export const AutoMlForecastingInputs_Transformation_AutoTransformation: MessageFns<
  AutoMlForecastingInputs_Transformation_AutoTransformation
> = {
  encode(
    message: AutoMlForecastingInputs_Transformation_AutoTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingInputs_Transformation_AutoTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation_AutoTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation_AutoTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation_AutoTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlForecastingInputs_Transformation_AutoTransformation>,
  ): AutoMlForecastingInputs_Transformation_AutoTransformation {
    return AutoMlForecastingInputs_Transformation_AutoTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlForecastingInputs_Transformation_AutoTransformation>,
  ): AutoMlForecastingInputs_Transformation_AutoTransformation {
    const message = createBaseAutoMlForecastingInputs_Transformation_AutoTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation_NumericTransformation(): AutoMlForecastingInputs_Transformation_NumericTransformation {
  return { columnName: "" };
}

export const AutoMlForecastingInputs_Transformation_NumericTransformation: MessageFns<
  AutoMlForecastingInputs_Transformation_NumericTransformation
> = {
  encode(
    message: AutoMlForecastingInputs_Transformation_NumericTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlForecastingInputs_Transformation_NumericTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation_NumericTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation_NumericTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation_NumericTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlForecastingInputs_Transformation_NumericTransformation>,
  ): AutoMlForecastingInputs_Transformation_NumericTransformation {
    return AutoMlForecastingInputs_Transformation_NumericTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlForecastingInputs_Transformation_NumericTransformation>,
  ): AutoMlForecastingInputs_Transformation_NumericTransformation {
    const message = createBaseAutoMlForecastingInputs_Transformation_NumericTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation_CategoricalTransformation(): AutoMlForecastingInputs_Transformation_CategoricalTransformation {
  return { columnName: "" };
}

export const AutoMlForecastingInputs_Transformation_CategoricalTransformation: MessageFns<
  AutoMlForecastingInputs_Transformation_CategoricalTransformation
> = {
  encode(
    message: AutoMlForecastingInputs_Transformation_CategoricalTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlForecastingInputs_Transformation_CategoricalTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation_CategoricalTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation_CategoricalTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation_CategoricalTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlForecastingInputs_Transformation_CategoricalTransformation>,
  ): AutoMlForecastingInputs_Transformation_CategoricalTransformation {
    return AutoMlForecastingInputs_Transformation_CategoricalTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlForecastingInputs_Transformation_CategoricalTransformation>,
  ): AutoMlForecastingInputs_Transformation_CategoricalTransformation {
    const message = createBaseAutoMlForecastingInputs_Transformation_CategoricalTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation_TimestampTransformation(): AutoMlForecastingInputs_Transformation_TimestampTransformation {
  return { columnName: "", timeFormat: "" };
}

export const AutoMlForecastingInputs_Transformation_TimestampTransformation: MessageFns<
  AutoMlForecastingInputs_Transformation_TimestampTransformation
> = {
  encode(
    message: AutoMlForecastingInputs_Transformation_TimestampTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.timeFormat !== "") {
      writer.uint32(18).string(message.timeFormat);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlForecastingInputs_Transformation_TimestampTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation_TimestampTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeFormat = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation_TimestampTransformation {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      timeFormat: isSet(object.timeFormat) ? globalThis.String(object.timeFormat) : "",
    };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation_TimestampTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.timeFormat !== "") {
      obj.timeFormat = message.timeFormat;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlForecastingInputs_Transformation_TimestampTransformation>,
  ): AutoMlForecastingInputs_Transformation_TimestampTransformation {
    return AutoMlForecastingInputs_Transformation_TimestampTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlForecastingInputs_Transformation_TimestampTransformation>,
  ): AutoMlForecastingInputs_Transformation_TimestampTransformation {
    const message = createBaseAutoMlForecastingInputs_Transformation_TimestampTransformation();
    message.columnName = object.columnName ?? "";
    message.timeFormat = object.timeFormat ?? "";
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Transformation_TextTransformation(): AutoMlForecastingInputs_Transformation_TextTransformation {
  return { columnName: "" };
}

export const AutoMlForecastingInputs_Transformation_TextTransformation: MessageFns<
  AutoMlForecastingInputs_Transformation_TextTransformation
> = {
  encode(
    message: AutoMlForecastingInputs_Transformation_TextTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingInputs_Transformation_TextTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Transformation_TextTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Transformation_TextTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlForecastingInputs_Transformation_TextTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlForecastingInputs_Transformation_TextTransformation>,
  ): AutoMlForecastingInputs_Transformation_TextTransformation {
    return AutoMlForecastingInputs_Transformation_TextTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlForecastingInputs_Transformation_TextTransformation>,
  ): AutoMlForecastingInputs_Transformation_TextTransformation {
    const message = createBaseAutoMlForecastingInputs_Transformation_TextTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlForecastingInputs_Granularity(): AutoMlForecastingInputs_Granularity {
  return { unit: "", quantity: Long.ZERO };
}

export const AutoMlForecastingInputs_Granularity: MessageFns<AutoMlForecastingInputs_Granularity> = {
  encode(message: AutoMlForecastingInputs_Granularity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== "") {
      writer.uint32(10).string(message.unit);
    }
    if (!message.quantity.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.quantity.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingInputs_Granularity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingInputs_Granularity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unit = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingInputs_Granularity {
    return {
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      quantity: isSet(object.quantity) ? Long.fromValue(object.quantity) : Long.ZERO,
    };
  },

  toJSON(message: AutoMlForecastingInputs_Granularity): unknown {
    const obj: any = {};
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (!message.quantity.equals(Long.ZERO)) {
      obj.quantity = (message.quantity || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlForecastingInputs_Granularity>): AutoMlForecastingInputs_Granularity {
    return AutoMlForecastingInputs_Granularity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlForecastingInputs_Granularity>): AutoMlForecastingInputs_Granularity {
    const message = createBaseAutoMlForecastingInputs_Granularity();
    message.unit = object.unit ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Long.fromValue(object.quantity)
      : Long.ZERO;
    return message;
  },
};

function createBaseAutoMlForecastingMetadata(): AutoMlForecastingMetadata {
  return { trainCostMilliNodeHours: Long.ZERO };
}

export const AutoMlForecastingMetadata: MessageFns<AutoMlForecastingMetadata> = {
  encode(message: AutoMlForecastingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.trainCostMilliNodeHours.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.trainCostMilliNodeHours.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlForecastingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlForecastingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trainCostMilliNodeHours = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlForecastingMetadata {
    return {
      trainCostMilliNodeHours: isSet(object.trainCostMilliNodeHours)
        ? Long.fromValue(object.trainCostMilliNodeHours)
        : Long.ZERO,
    };
  },

  toJSON(message: AutoMlForecastingMetadata): unknown {
    const obj: any = {};
    if (!message.trainCostMilliNodeHours.equals(Long.ZERO)) {
      obj.trainCostMilliNodeHours = (message.trainCostMilliNodeHours || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlForecastingMetadata>): AutoMlForecastingMetadata {
    return AutoMlForecastingMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlForecastingMetadata>): AutoMlForecastingMetadata {
    const message = createBaseAutoMlForecastingMetadata();
    message.trainCostMilliNodeHours =
      (object.trainCostMilliNodeHours !== undefined && object.trainCostMilliNodeHours !== null)
        ? Long.fromValue(object.trainCostMilliNodeHours)
        : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
