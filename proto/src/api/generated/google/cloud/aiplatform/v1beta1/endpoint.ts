// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/endpoint.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { ExplanationSpec } from "./explanation.js";
import { BigQueryDestination } from "./io.js";
import { AutomaticResources, DedicatedResources } from "./machine_resources.js";
import { PrivateServiceConnectConfig } from "./service_networking.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Models are deployed into it, and afterwards Endpoint is called to obtain
 * predictions and explanations.
 */
export interface Endpoint {
  /** Output only. The resource name of the Endpoint. */
  name: string;
  /**
   * Required. The display name of the Endpoint.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** The description of the Endpoint. */
  description: string;
  /**
   * Output only. The models deployed in this Endpoint.
   * To add or remove DeployedModels use
   * [EndpointService.DeployModel][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel]
   * and
   * [EndpointService.UndeployModel][google.cloud.aiplatform.v1beta1.EndpointService.UndeployModel]
   * respectively.
   */
  deployedModels: DeployedModel[];
  /**
   * A map from a DeployedModel's ID to the percentage of this Endpoint's
   * traffic that should be forwarded to that DeployedModel.
   *
   * If a DeployedModel's ID is not listed in this map, then it receives no
   * traffic.
   *
   * The traffic percentage values must add up to 100, or map must be empty if
   * the Endpoint is to not accept any traffic at a moment.
   */
  trafficSplit: { [key: string]: number };
  /**
   * Used to perform consistent read-modify-write updates. If not set, a blind
   * "overwrite" update happens.
   */
  etag: string;
  /**
   * The labels with user-defined metadata to organize your Endpoints.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /** Output only. Timestamp when this Endpoint was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this Endpoint was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Customer-managed encryption key spec for an Endpoint. If set, this
   * Endpoint and all sub-resources of this Endpoint will be secured by
   * this key.
   */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /**
   * Optional. The full name of the Google Compute Engine
   * [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
   * to which the Endpoint should be peered.
   *
   * Private services access must already be configured for the network. If left
   * unspecified, the Endpoint is not peered with any network.
   *
   * Only one of the fields,
   * [network][google.cloud.aiplatform.v1beta1.Endpoint.network] or
   * [enable_private_service_connect][google.cloud.aiplatform.v1beta1.Endpoint.enable_private_service_connect],
   * can be set.
   *
   * [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
   * `projects/{project}/global/networks/{network}`.
   * Where `{project}` is a project number, as in `12345`, and `{network}` is
   * network name.
   */
  network: string;
  /**
   * Deprecated: If true, expose the Endpoint via private service connect.
   *
   * Only one of the fields,
   * [network][google.cloud.aiplatform.v1beta1.Endpoint.network] or
   * [enable_private_service_connect][google.cloud.aiplatform.v1beta1.Endpoint.enable_private_service_connect],
   * can be set.
   *
   * @deprecated
   */
  enablePrivateServiceConnect: boolean;
  /**
   * Optional. Configuration for private service connect.
   *
   * [network][google.cloud.aiplatform.v1beta1.Endpoint.network] and
   * [private_service_connect_config][google.cloud.aiplatform.v1beta1.Endpoint.private_service_connect_config]
   * are mutually exclusive.
   */
  privateServiceConnectConfig:
    | PrivateServiceConnectConfig
    | undefined;
  /**
   * Output only. Resource name of the Model Monitoring job associated with this
   * Endpoint if monitoring is enabled by
   * [JobService.CreateModelDeploymentMonitoringJob][google.cloud.aiplatform.v1beta1.JobService.CreateModelDeploymentMonitoringJob].
   * Format:
   * `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
   */
  modelDeploymentMonitoringJob: string;
  /** Configures the request-response logging for online prediction. */
  predictRequestResponseLoggingConfig:
    | PredictRequestResponseLoggingConfig
    | undefined;
  /**
   * If true, the endpoint will be exposed through a dedicated
   * DNS [Endpoint.dedicated_endpoint_dns]. Your request to the dedicated DNS
   * will be isolated from other users' traffic and will have better performance
   * and reliability.
   * Note: Once you enabled dedicated endpoint, you won't be able to send
   * request to the shared DNS {region}-aiplatform.googleapis.com. The
   * limitation will be removed soon.
   */
  dedicatedEndpointEnabled: boolean;
  /**
   * Output only. DNS of the dedicated endpoint. Will only be populated if
   * dedicated_endpoint_enabled is true.
   * Format:
   * `https://{endpoint_id}.{region}-{project_number}.prediction.vertexai.goog`.
   */
  dedicatedEndpointDns: string;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

export interface Endpoint_TrafficSplitEntry {
  key: string;
  value: number;
}

export interface Endpoint_LabelsEntry {
  key: string;
  value: string;
}

/** A deployment of a Model. Endpoints contain one or more DeployedModels. */
export interface DeployedModel {
  /**
   * A description of resources that are dedicated to the DeployedModel, and
   * that need a higher degree of manual configuration.
   */
  dedicatedResources?:
    | DedicatedResources
    | undefined;
  /**
   * A description of resources that to large degree are decided by Vertex
   * AI, and require only a modest additional configuration.
   */
  automaticResources?:
    | AutomaticResources
    | undefined;
  /**
   * The resource name of the shared DeploymentResourcePool to deploy on.
   * Format:
   * `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
   */
  sharedResources?:
    | string
    | undefined;
  /**
   * Immutable. The ID of the DeployedModel. If not provided upon deployment,
   * Vertex AI will generate a value for this ID.
   *
   * This value should be 1-10 characters, and valid characters are `/[0-9]/`.
   */
  id: string;
  /**
   * Required. The resource name of the Model that this is the deployment of.
   * Note that the Model may be in a different location than the DeployedModel's
   * Endpoint.
   *
   * The resource name may contain version id or version alias to specify the
   * version.
   *  Example: `projects/{project}/locations/{location}/models/{model}@2`
   *              or
   *            `projects/{project}/locations/{location}/models/{model}@golden`
   * if no version is specified, the default version will be deployed.
   */
  model: string;
  /** Output only. The version ID of the model that is deployed. */
  modelVersionId: string;
  /**
   * The display name of the DeployedModel. If not provided upon creation,
   * the Model's display_name is used.
   */
  displayName: string;
  /** Output only. Timestamp when the DeployedModel was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Explanation configuration for this DeployedModel.
   *
   * When deploying a Model using
   * [EndpointService.DeployModel][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel],
   * this value overrides the value of
   * [Model.explanation_spec][google.cloud.aiplatform.v1beta1.Model.explanation_spec].
   * All fields of
   * [explanation_spec][google.cloud.aiplatform.v1beta1.DeployedModel.explanation_spec]
   * are optional in the request. If a field of
   * [explanation_spec][google.cloud.aiplatform.v1beta1.DeployedModel.explanation_spec]
   * is not populated, the value of the same field of
   * [Model.explanation_spec][google.cloud.aiplatform.v1beta1.Model.explanation_spec]
   * is inherited. If the corresponding
   * [Model.explanation_spec][google.cloud.aiplatform.v1beta1.Model.explanation_spec]
   * is not populated, all fields of the
   * [explanation_spec][google.cloud.aiplatform.v1beta1.DeployedModel.explanation_spec]
   * will be used for the explanation configuration.
   */
  explanationSpec:
    | ExplanationSpec
    | undefined;
  /**
   * If true, deploy the model without explainable feature, regardless the
   * existence of
   * [Model.explanation_spec][google.cloud.aiplatform.v1beta1.Model.explanation_spec]
   * or
   * [explanation_spec][google.cloud.aiplatform.v1beta1.DeployedModel.explanation_spec].
   */
  disableExplanations: boolean;
  /**
   * The service account that the DeployedModel's container runs as. Specify the
   * email address of the service account. If this service account is not
   * specified, the container runs as a service account that doesn't have access
   * to the resource project.
   *
   * Users deploying the Model must have the `iam.serviceAccounts.actAs`
   * permission on this service account.
   */
  serviceAccount: string;
  /**
   * If true, the container of the DeployedModel instances will send `stderr`
   * and `stdout` streams to Cloud Logging.
   *
   * Only supported for custom-trained Models and AutoML Tabular Models.
   */
  enableContainerLogging: boolean;
  /**
   * If true, online prediction access logs are sent to Cloud
   * Logging.
   * These logs are like standard server access logs, containing
   * information like timestamp and latency for each prediction request.
   *
   * Note that logs may incur a cost, especially if your project
   * receives prediction requests at a high queries per second rate (QPS).
   * Estimate your costs before enabling this option.
   */
  enableAccessLogging: boolean;
  /**
   * Output only. Provide paths for users to send predict/explain/health
   * requests directly to the deployed model services running on Cloud via
   * private services access. This field is populated if
   * [network][google.cloud.aiplatform.v1beta1.Endpoint.network] is configured.
   */
  privateEndpoints: PrivateEndpoints | undefined;
}

/**
 * PrivateEndpoints proto is used to provide paths for users to send
 * requests privately.
 * To send request via private service access, use predict_http_uri,
 * explain_http_uri or health_http_uri. To send request via private service
 * connect, use service_attachment.
 */
export interface PrivateEndpoints {
  /** Output only. Http(s) path to send prediction requests. */
  predictHttpUri: string;
  /** Output only. Http(s) path to send explain requests. */
  explainHttpUri: string;
  /** Output only. Http(s) path to send health check requests. */
  healthHttpUri: string;
  /**
   * Output only. The name of the service attachment resource. Populated if
   * private service connect is enabled.
   */
  serviceAttachment: string;
}

/** Configuration for logging request-response to a BigQuery table. */
export interface PredictRequestResponseLoggingConfig {
  /** If logging is enabled or not. */
  enabled: boolean;
  /**
   * Percentage of requests to be logged, expressed as a fraction in
   * range(0,1].
   */
  samplingRate: number;
  /**
   * BigQuery table for logging.
   * If only given a project, a new dataset will be created with name
   * `logging_<endpoint-display-name>_<endpoint-id>` where
   * <endpoint-display-name> will be made BigQuery-dataset-name compatible (e.g.
   * most special characters will become underscores). If no table name is
   * given, a new table will be created with name `request_response_logging`
   */
  bigqueryDestination: BigQueryDestination | undefined;
}

function createBaseEndpoint(): Endpoint {
  return {
    name: "",
    displayName: "",
    description: "",
    deployedModels: [],
    trafficSplit: {},
    etag: "",
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    encryptionSpec: undefined,
    network: "",
    enablePrivateServiceConnect: false,
    privateServiceConnectConfig: undefined,
    modelDeploymentMonitoringJob: "",
    predictRequestResponseLoggingConfig: undefined,
    dedicatedEndpointEnabled: false,
    dedicatedEndpointDns: "",
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const Endpoint: MessageFns<Endpoint> = {
  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.deployedModels) {
      DeployedModel.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.trafficSplit).forEach(([key, value]) => {
      Endpoint_TrafficSplitEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(50).string(message.etag);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Endpoint_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(82).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(106).string(message.network);
    }
    if (message.enablePrivateServiceConnect !== false) {
      writer.uint32(136).bool(message.enablePrivateServiceConnect);
    }
    if (message.privateServiceConnectConfig !== undefined) {
      PrivateServiceConnectConfig.encode(message.privateServiceConnectConfig, writer.uint32(170).fork()).join();
    }
    if (message.modelDeploymentMonitoringJob !== "") {
      writer.uint32(114).string(message.modelDeploymentMonitoringJob);
    }
    if (message.predictRequestResponseLoggingConfig !== undefined) {
      PredictRequestResponseLoggingConfig.encode(message.predictRequestResponseLoggingConfig, writer.uint32(146).fork())
        .join();
    }
    if (message.dedicatedEndpointEnabled !== false) {
      writer.uint32(192).bool(message.dedicatedEndpointEnabled);
    }
    if (message.dedicatedEndpointDns !== "") {
      writer.uint32(202).string(message.dedicatedEndpointDns);
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(216).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(224).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deployedModels.push(DeployedModel.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Endpoint_TrafficSplitEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.trafficSplit[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Endpoint_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.network = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.enablePrivateServiceConnect = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.privateServiceConnectConfig = PrivateServiceConnectConfig.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.modelDeploymentMonitoringJob = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.predictRequestResponseLoggingConfig = PredictRequestResponseLoggingConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.dedicatedEndpointEnabled = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.dedicatedEndpointDns = reader.string();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      deployedModels: globalThis.Array.isArray(object?.deployedModels)
        ? object.deployedModels.map((e: any) => DeployedModel.fromJSON(e))
        : [],
      trafficSplit: isObject(object.trafficSplit)
        ? Object.entries(object.trafficSplit).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      enablePrivateServiceConnect: isSet(object.enablePrivateServiceConnect)
        ? globalThis.Boolean(object.enablePrivateServiceConnect)
        : false,
      privateServiceConnectConfig: isSet(object.privateServiceConnectConfig)
        ? PrivateServiceConnectConfig.fromJSON(object.privateServiceConnectConfig)
        : undefined,
      modelDeploymentMonitoringJob: isSet(object.modelDeploymentMonitoringJob)
        ? globalThis.String(object.modelDeploymentMonitoringJob)
        : "",
      predictRequestResponseLoggingConfig: isSet(object.predictRequestResponseLoggingConfig)
        ? PredictRequestResponseLoggingConfig.fromJSON(object.predictRequestResponseLoggingConfig)
        : undefined,
      dedicatedEndpointEnabled: isSet(object.dedicatedEndpointEnabled)
        ? globalThis.Boolean(object.dedicatedEndpointEnabled)
        : false,
      dedicatedEndpointDns: isSet(object.dedicatedEndpointDns) ? globalThis.String(object.dedicatedEndpointDns) : "",
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.deployedModels?.length) {
      obj.deployedModels = message.deployedModels.map((e) => DeployedModel.toJSON(e));
    }
    if (message.trafficSplit) {
      const entries = Object.entries(message.trafficSplit);
      if (entries.length > 0) {
        obj.trafficSplit = {};
        entries.forEach(([k, v]) => {
          obj.trafficSplit[k] = Math.round(v);
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.enablePrivateServiceConnect !== false) {
      obj.enablePrivateServiceConnect = message.enablePrivateServiceConnect;
    }
    if (message.privateServiceConnectConfig !== undefined) {
      obj.privateServiceConnectConfig = PrivateServiceConnectConfig.toJSON(message.privateServiceConnectConfig);
    }
    if (message.modelDeploymentMonitoringJob !== "") {
      obj.modelDeploymentMonitoringJob = message.modelDeploymentMonitoringJob;
    }
    if (message.predictRequestResponseLoggingConfig !== undefined) {
      obj.predictRequestResponseLoggingConfig = PredictRequestResponseLoggingConfig.toJSON(
        message.predictRequestResponseLoggingConfig,
      );
    }
    if (message.dedicatedEndpointEnabled !== false) {
      obj.dedicatedEndpointEnabled = message.dedicatedEndpointEnabled;
    }
    if (message.dedicatedEndpointDns !== "") {
      obj.dedicatedEndpointDns = message.dedicatedEndpointDns;
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint>): Endpoint {
    return Endpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint>): Endpoint {
    const message = createBaseEndpoint();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.deployedModels = object.deployedModels?.map((e) => DeployedModel.fromPartial(e)) || [];
    message.trafficSplit = Object.entries(object.trafficSplit ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.network = object.network ?? "";
    message.enablePrivateServiceConnect = object.enablePrivateServiceConnect ?? false;
    message.privateServiceConnectConfig =
      (object.privateServiceConnectConfig !== undefined && object.privateServiceConnectConfig !== null)
        ? PrivateServiceConnectConfig.fromPartial(object.privateServiceConnectConfig)
        : undefined;
    message.modelDeploymentMonitoringJob = object.modelDeploymentMonitoringJob ?? "";
    message.predictRequestResponseLoggingConfig =
      (object.predictRequestResponseLoggingConfig !== undefined && object.predictRequestResponseLoggingConfig !== null)
        ? PredictRequestResponseLoggingConfig.fromPartial(object.predictRequestResponseLoggingConfig)
        : undefined;
    message.dedicatedEndpointEnabled = object.dedicatedEndpointEnabled ?? false;
    message.dedicatedEndpointDns = object.dedicatedEndpointDns ?? "";
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

function createBaseEndpoint_TrafficSplitEntry(): Endpoint_TrafficSplitEntry {
  return { key: "", value: 0 };
}

export const Endpoint_TrafficSplitEntry: MessageFns<Endpoint_TrafficSplitEntry> = {
  encode(message: Endpoint_TrafficSplitEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_TrafficSplitEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_TrafficSplitEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_TrafficSplitEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Endpoint_TrafficSplitEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint_TrafficSplitEntry>): Endpoint_TrafficSplitEntry {
    return Endpoint_TrafficSplitEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint_TrafficSplitEntry>): Endpoint_TrafficSplitEntry {
    const message = createBaseEndpoint_TrafficSplitEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEndpoint_LabelsEntry(): Endpoint_LabelsEntry {
  return { key: "", value: "" };
}

export const Endpoint_LabelsEntry: MessageFns<Endpoint_LabelsEntry> = {
  encode(message: Endpoint_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Endpoint_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint_LabelsEntry>): Endpoint_LabelsEntry {
    return Endpoint_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint_LabelsEntry>): Endpoint_LabelsEntry {
    const message = createBaseEndpoint_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeployedModel(): DeployedModel {
  return {
    dedicatedResources: undefined,
    automaticResources: undefined,
    sharedResources: undefined,
    id: "",
    model: "",
    modelVersionId: "",
    displayName: "",
    createTime: undefined,
    explanationSpec: undefined,
    disableExplanations: false,
    serviceAccount: "",
    enableContainerLogging: false,
    enableAccessLogging: false,
    privateEndpoints: undefined,
  };
}

export const DeployedModel: MessageFns<DeployedModel> = {
  encode(message: DeployedModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dedicatedResources !== undefined) {
      DedicatedResources.encode(message.dedicatedResources, writer.uint32(58).fork()).join();
    }
    if (message.automaticResources !== undefined) {
      AutomaticResources.encode(message.automaticResources, writer.uint32(66).fork()).join();
    }
    if (message.sharedResources !== undefined) {
      writer.uint32(138).string(message.sharedResources);
    }
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.modelVersionId !== "") {
      writer.uint32(146).string(message.modelVersionId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.explanationSpec !== undefined) {
      ExplanationSpec.encode(message.explanationSpec, writer.uint32(74).fork()).join();
    }
    if (message.disableExplanations !== false) {
      writer.uint32(152).bool(message.disableExplanations);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(90).string(message.serviceAccount);
    }
    if (message.enableContainerLogging !== false) {
      writer.uint32(96).bool(message.enableContainerLogging);
    }
    if (message.enableAccessLogging !== false) {
      writer.uint32(104).bool(message.enableAccessLogging);
    }
    if (message.privateEndpoints !== undefined) {
      PrivateEndpoints.encode(message.privateEndpoints, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dedicatedResources = DedicatedResources.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.automaticResources = AutomaticResources.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.sharedResources = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.modelVersionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.explanationSpec = ExplanationSpec.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.disableExplanations = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableContainerLogging = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.enableAccessLogging = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.privateEndpoints = PrivateEndpoints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedModel {
    return {
      dedicatedResources: isSet(object.dedicatedResources)
        ? DedicatedResources.fromJSON(object.dedicatedResources)
        : undefined,
      automaticResources: isSet(object.automaticResources)
        ? AutomaticResources.fromJSON(object.automaticResources)
        : undefined,
      sharedResources: isSet(object.sharedResources) ? globalThis.String(object.sharedResources) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      modelVersionId: isSet(object.modelVersionId) ? globalThis.String(object.modelVersionId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      explanationSpec: isSet(object.explanationSpec) ? ExplanationSpec.fromJSON(object.explanationSpec) : undefined,
      disableExplanations: isSet(object.disableExplanations) ? globalThis.Boolean(object.disableExplanations) : false,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      enableContainerLogging: isSet(object.enableContainerLogging)
        ? globalThis.Boolean(object.enableContainerLogging)
        : false,
      enableAccessLogging: isSet(object.enableAccessLogging) ? globalThis.Boolean(object.enableAccessLogging) : false,
      privateEndpoints: isSet(object.privateEndpoints) ? PrivateEndpoints.fromJSON(object.privateEndpoints) : undefined,
    };
  },

  toJSON(message: DeployedModel): unknown {
    const obj: any = {};
    if (message.dedicatedResources !== undefined) {
      obj.dedicatedResources = DedicatedResources.toJSON(message.dedicatedResources);
    }
    if (message.automaticResources !== undefined) {
      obj.automaticResources = AutomaticResources.toJSON(message.automaticResources);
    }
    if (message.sharedResources !== undefined) {
      obj.sharedResources = message.sharedResources;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.modelVersionId !== "") {
      obj.modelVersionId = message.modelVersionId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.explanationSpec !== undefined) {
      obj.explanationSpec = ExplanationSpec.toJSON(message.explanationSpec);
    }
    if (message.disableExplanations !== false) {
      obj.disableExplanations = message.disableExplanations;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.enableContainerLogging !== false) {
      obj.enableContainerLogging = message.enableContainerLogging;
    }
    if (message.enableAccessLogging !== false) {
      obj.enableAccessLogging = message.enableAccessLogging;
    }
    if (message.privateEndpoints !== undefined) {
      obj.privateEndpoints = PrivateEndpoints.toJSON(message.privateEndpoints);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedModel>): DeployedModel {
    return DeployedModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedModel>): DeployedModel {
    const message = createBaseDeployedModel();
    message.dedicatedResources = (object.dedicatedResources !== undefined && object.dedicatedResources !== null)
      ? DedicatedResources.fromPartial(object.dedicatedResources)
      : undefined;
    message.automaticResources = (object.automaticResources !== undefined && object.automaticResources !== null)
      ? AutomaticResources.fromPartial(object.automaticResources)
      : undefined;
    message.sharedResources = object.sharedResources ?? undefined;
    message.id = object.id ?? "";
    message.model = object.model ?? "";
    message.modelVersionId = object.modelVersionId ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.explanationSpec = (object.explanationSpec !== undefined && object.explanationSpec !== null)
      ? ExplanationSpec.fromPartial(object.explanationSpec)
      : undefined;
    message.disableExplanations = object.disableExplanations ?? false;
    message.serviceAccount = object.serviceAccount ?? "";
    message.enableContainerLogging = object.enableContainerLogging ?? false;
    message.enableAccessLogging = object.enableAccessLogging ?? false;
    message.privateEndpoints = (object.privateEndpoints !== undefined && object.privateEndpoints !== null)
      ? PrivateEndpoints.fromPartial(object.privateEndpoints)
      : undefined;
    return message;
  },
};

function createBasePrivateEndpoints(): PrivateEndpoints {
  return { predictHttpUri: "", explainHttpUri: "", healthHttpUri: "", serviceAttachment: "" };
}

export const PrivateEndpoints: MessageFns<PrivateEndpoints> = {
  encode(message: PrivateEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.predictHttpUri !== "") {
      writer.uint32(10).string(message.predictHttpUri);
    }
    if (message.explainHttpUri !== "") {
      writer.uint32(18).string(message.explainHttpUri);
    }
    if (message.healthHttpUri !== "") {
      writer.uint32(26).string(message.healthHttpUri);
    }
    if (message.serviceAttachment !== "") {
      writer.uint32(34).string(message.serviceAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.predictHttpUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explainHttpUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.healthHttpUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateEndpoints {
    return {
      predictHttpUri: isSet(object.predictHttpUri) ? globalThis.String(object.predictHttpUri) : "",
      explainHttpUri: isSet(object.explainHttpUri) ? globalThis.String(object.explainHttpUri) : "",
      healthHttpUri: isSet(object.healthHttpUri) ? globalThis.String(object.healthHttpUri) : "",
      serviceAttachment: isSet(object.serviceAttachment) ? globalThis.String(object.serviceAttachment) : "",
    };
  },

  toJSON(message: PrivateEndpoints): unknown {
    const obj: any = {};
    if (message.predictHttpUri !== "") {
      obj.predictHttpUri = message.predictHttpUri;
    }
    if (message.explainHttpUri !== "") {
      obj.explainHttpUri = message.explainHttpUri;
    }
    if (message.healthHttpUri !== "") {
      obj.healthHttpUri = message.healthHttpUri;
    }
    if (message.serviceAttachment !== "") {
      obj.serviceAttachment = message.serviceAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateEndpoints>): PrivateEndpoints {
    return PrivateEndpoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateEndpoints>): PrivateEndpoints {
    const message = createBasePrivateEndpoints();
    message.predictHttpUri = object.predictHttpUri ?? "";
    message.explainHttpUri = object.explainHttpUri ?? "";
    message.healthHttpUri = object.healthHttpUri ?? "";
    message.serviceAttachment = object.serviceAttachment ?? "";
    return message;
  },
};

function createBasePredictRequestResponseLoggingConfig(): PredictRequestResponseLoggingConfig {
  return { enabled: false, samplingRate: 0, bigqueryDestination: undefined };
}

export const PredictRequestResponseLoggingConfig: MessageFns<PredictRequestResponseLoggingConfig> = {
  encode(message: PredictRequestResponseLoggingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.samplingRate !== 0) {
      writer.uint32(17).double(message.samplingRate);
    }
    if (message.bigqueryDestination !== undefined) {
      BigQueryDestination.encode(message.bigqueryDestination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredictRequestResponseLoggingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredictRequestResponseLoggingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.samplingRate = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bigqueryDestination = BigQueryDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredictRequestResponseLoggingConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      samplingRate: isSet(object.samplingRate) ? globalThis.Number(object.samplingRate) : 0,
      bigqueryDestination: isSet(object.bigqueryDestination)
        ? BigQueryDestination.fromJSON(object.bigqueryDestination)
        : undefined,
    };
  },

  toJSON(message: PredictRequestResponseLoggingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.samplingRate !== 0) {
      obj.samplingRate = message.samplingRate;
    }
    if (message.bigqueryDestination !== undefined) {
      obj.bigqueryDestination = BigQueryDestination.toJSON(message.bigqueryDestination);
    }
    return obj;
  },

  create(base?: DeepPartial<PredictRequestResponseLoggingConfig>): PredictRequestResponseLoggingConfig {
    return PredictRequestResponseLoggingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PredictRequestResponseLoggingConfig>): PredictRequestResponseLoggingConfig {
    const message = createBasePredictRequestResponseLoggingConfig();
    message.enabled = object.enabled ?? false;
    message.samplingRate = object.samplingRate ?? 0;
    message.bigqueryDestination = (object.bigqueryDestination !== undefined && object.bigqueryDestination !== null)
      ? BigQueryDestination.fromPartial(object.bigqueryDestination)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
