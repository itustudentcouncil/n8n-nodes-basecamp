// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/servicehealth/v1/event_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.servicehealth.v1";

/**
 * The event fields to include in ListEvents API response. This enum lists all
 * possible event views.
 */
export enum EventView {
  /** EVENT_VIEW_UNSPECIFIED - Unspecified event view. Default to `EVENT_VIEW_BASIC`. */
  EVENT_VIEW_UNSPECIFIED = 0,
  /**
   * EVENT_VIEW_BASIC - Includes all fields except `updates`. This view is the default for
   * ListEvents API.
   */
  EVENT_VIEW_BASIC = 1,
  /** EVENT_VIEW_FULL - Includes all event fields. */
  EVENT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function eventViewFromJSON(object: any): EventView {
  switch (object) {
    case 0:
    case "EVENT_VIEW_UNSPECIFIED":
      return EventView.EVENT_VIEW_UNSPECIFIED;
    case 1:
    case "EVENT_VIEW_BASIC":
      return EventView.EVENT_VIEW_BASIC;
    case 2:
    case "EVENT_VIEW_FULL":
      return EventView.EVENT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventView.UNRECOGNIZED;
  }
}

export function eventViewToJSON(object: EventView): string {
  switch (object) {
    case EventView.EVENT_VIEW_UNSPECIFIED:
      return "EVENT_VIEW_UNSPECIFIED";
    case EventView.EVENT_VIEW_BASIC:
      return "EVENT_VIEW_BASIC";
    case EventView.EVENT_VIEW_FULL:
      return "EVENT_VIEW_FULL";
    case EventView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The organization event fields to include in ListOrganizationEvents API
 * response. This enum lists all possible organization event views.
 */
export enum OrganizationEventView {
  /** ORGANIZATION_EVENT_VIEW_UNSPECIFIED - Unspecified event view. Default to `ORGANIZATION_EVENT_VIEW_BASIC`. */
  ORGANIZATION_EVENT_VIEW_UNSPECIFIED = 0,
  /**
   * ORGANIZATION_EVENT_VIEW_BASIC - Includes all organization event fields except `updates`. This view is the
   * default for ListOrganizationEvents API.
   */
  ORGANIZATION_EVENT_VIEW_BASIC = 1,
  /** ORGANIZATION_EVENT_VIEW_FULL - Includes all organization event fields. */
  ORGANIZATION_EVENT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function organizationEventViewFromJSON(object: any): OrganizationEventView {
  switch (object) {
    case 0:
    case "ORGANIZATION_EVENT_VIEW_UNSPECIFIED":
      return OrganizationEventView.ORGANIZATION_EVENT_VIEW_UNSPECIFIED;
    case 1:
    case "ORGANIZATION_EVENT_VIEW_BASIC":
      return OrganizationEventView.ORGANIZATION_EVENT_VIEW_BASIC;
    case 2:
    case "ORGANIZATION_EVENT_VIEW_FULL":
      return OrganizationEventView.ORGANIZATION_EVENT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationEventView.UNRECOGNIZED;
  }
}

export function organizationEventViewToJSON(object: OrganizationEventView): string {
  switch (object) {
    case OrganizationEventView.ORGANIZATION_EVENT_VIEW_UNSPECIFIED:
      return "ORGANIZATION_EVENT_VIEW_UNSPECIFIED";
    case OrganizationEventView.ORGANIZATION_EVENT_VIEW_BASIC:
      return "ORGANIZATION_EVENT_VIEW_BASIC";
    case OrganizationEventView.ORGANIZATION_EVENT_VIEW_FULL:
      return "ORGANIZATION_EVENT_VIEW_FULL";
    case OrganizationEventView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents service health events that may affect Google Cloud products.
 * Event resource is a read-only view and does not allow any modifications. All
 * fields are output only.
 */
export interface Event {
  /**
   * Output only. Identifier. Name of the event. Unique name of the event in
   * this scope including project and location using the form
   * `projects/{project_id}/locations/{location}/events/{event_id}`.
   */
  name: string;
  /** Output only. Brief description for the event. */
  title: string;
  /** Output only. Free-form, human-readable description. */
  description: string;
  /** Output only. The category of the event. */
  category: Event_EventCategory;
  /** Output only. The detailed category of the event. */
  detailedCategory: Event_DetailedCategory;
  /** Output only. The current state of the event. */
  state: Event_State;
  /** Output only. The current detailed state of the incident. */
  detailedState: Event_DetailedState;
  /** Google Cloud products and locations impacted by the event. */
  eventImpacts: EventImpact[];
  /**
   * Output only. Communicates why a given event is deemed relevant in the
   * context of a given project.
   */
  relevance: Event_Relevance;
  /** Output only. Event updates are correspondence from Google. */
  updates: EventUpdate[];
  /**
   * Output only. When `detailed_state`=`MERGED`, `parent_event` contains the
   * name of the parent event. All further updates will be published to the
   * parent event.
   */
  parentEvent: string;
  /** Output only. The time when the event was last modified. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The start time of the event, if applicable. */
  startTime:
    | Date
    | undefined;
  /** Output only. The end time of the event, if applicable. */
  endTime:
    | Date
    | undefined;
  /** Output only. The time when the next update can be expected. */
  nextUpdateTime: Date | undefined;
}

/**
 * The category of the event. This enum lists all possible categories of
 * event.
 */
export enum Event_EventCategory {
  /** EVENT_CATEGORY_UNSPECIFIED - Unspecified category. */
  EVENT_CATEGORY_UNSPECIFIED = 0,
  /** INCIDENT - Event category for service outage or degradation. */
  INCIDENT = 2,
  UNRECOGNIZED = -1,
}

export function event_EventCategoryFromJSON(object: any): Event_EventCategory {
  switch (object) {
    case 0:
    case "EVENT_CATEGORY_UNSPECIFIED":
      return Event_EventCategory.EVENT_CATEGORY_UNSPECIFIED;
    case 2:
    case "INCIDENT":
      return Event_EventCategory.INCIDENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_EventCategory.UNRECOGNIZED;
  }
}

export function event_EventCategoryToJSON(object: Event_EventCategory): string {
  switch (object) {
    case Event_EventCategory.EVENT_CATEGORY_UNSPECIFIED:
      return "EVENT_CATEGORY_UNSPECIFIED";
    case Event_EventCategory.INCIDENT:
      return "INCIDENT";
    case Event_EventCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The detailed category of an event. Contains all possible states for all
 * event categories.
 */
export enum Event_DetailedCategory {
  /** DETAILED_CATEGORY_UNSPECIFIED - Unspecified detailed category. */
  DETAILED_CATEGORY_UNSPECIFIED = 0,
  /**
   * CONFIRMED_INCIDENT - Indicates an event with category INCIDENT has a confirmed impact to at
   * least one Google Cloud product.
   */
  CONFIRMED_INCIDENT = 1,
  /**
   * EMERGING_INCIDENT - Indicates an event with category INCIDENT is under investigation to
   * determine if it has a confirmed impact on any Google Cloud products.
   */
  EMERGING_INCIDENT = 2,
  UNRECOGNIZED = -1,
}

export function event_DetailedCategoryFromJSON(object: any): Event_DetailedCategory {
  switch (object) {
    case 0:
    case "DETAILED_CATEGORY_UNSPECIFIED":
      return Event_DetailedCategory.DETAILED_CATEGORY_UNSPECIFIED;
    case 1:
    case "CONFIRMED_INCIDENT":
      return Event_DetailedCategory.CONFIRMED_INCIDENT;
    case 2:
    case "EMERGING_INCIDENT":
      return Event_DetailedCategory.EMERGING_INCIDENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_DetailedCategory.UNRECOGNIZED;
  }
}

export function event_DetailedCategoryToJSON(object: Event_DetailedCategory): string {
  switch (object) {
    case Event_DetailedCategory.DETAILED_CATEGORY_UNSPECIFIED:
      return "DETAILED_CATEGORY_UNSPECIFIED";
    case Event_DetailedCategory.CONFIRMED_INCIDENT:
      return "CONFIRMED_INCIDENT";
    case Event_DetailedCategory.EMERGING_INCIDENT:
      return "EMERGING_INCIDENT";
    case Event_DetailedCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state of the event. This enum lists all possible states of event. */
export enum Event_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Event is actively affecting a Google Cloud product and will continue to
   * receive updates.
   */
  ACTIVE = 1,
  /**
   * CLOSED - Event is no longer affecting the Google Cloud product or has been merged
   * with another event.
   */
  CLOSED = 2,
  UNRECOGNIZED = -1,
}

export function event_StateFromJSON(object: any): Event_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Event_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Event_State.ACTIVE;
    case 2:
    case "CLOSED":
      return Event_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_State.UNRECOGNIZED;
  }
}

export function event_StateToJSON(object: Event_State): string {
  switch (object) {
    case Event_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Event_State.ACTIVE:
      return "ACTIVE";
    case Event_State.CLOSED:
      return "CLOSED";
    case Event_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The detailed state of the incident. This enum lists all possible detailed
 * states of an incident.
 */
export enum Event_DetailedState {
  /** DETAILED_STATE_UNSPECIFIED - Unspecified detail state. */
  DETAILED_STATE_UNSPECIFIED = 0,
  /**
   * EMERGING - Google engineers are actively investigating the event to determine the
   * impact.
   */
  EMERGING = 1,
  /**
   * CONFIRMED - The incident is confirmed and impacting at least one Google Cloud
   * product. Ongoing status updates will be provided until it is resolved.
   */
  CONFIRMED = 2,
  /**
   * RESOLVED - The incident is no longer affecting any Google Cloud product, and there
   * will be no further updates.
   */
  RESOLVED = 3,
  /**
   * MERGED - The incident was merged into a parent incident. All further updates will
   * be published to the parent only. The `parent_event` field contains the
   * name of the parent.
   */
  MERGED = 4,
  /**
   * AUTO_CLOSED - The incident was automatically closed because of the following reasons:
   *
   *  * The impact of the incident could not be confirmed.
   *  * The incident was intermittent or resolved itself.
   *
   *  The incident does not have a resolution because no action or
   *  investigation happened. If it is intermittent, the incident may reopen.
   */
  AUTO_CLOSED = 9,
  /**
   * FALSE_POSITIVE - Upon investigation, Google engineers concluded that the incident is not
   * affecting a Google Cloud product. This state can change if the incident
   * is reviewed again.
   */
  FALSE_POSITIVE = 10,
  UNRECOGNIZED = -1,
}

export function event_DetailedStateFromJSON(object: any): Event_DetailedState {
  switch (object) {
    case 0:
    case "DETAILED_STATE_UNSPECIFIED":
      return Event_DetailedState.DETAILED_STATE_UNSPECIFIED;
    case 1:
    case "EMERGING":
      return Event_DetailedState.EMERGING;
    case 2:
    case "CONFIRMED":
      return Event_DetailedState.CONFIRMED;
    case 3:
    case "RESOLVED":
      return Event_DetailedState.RESOLVED;
    case 4:
    case "MERGED":
      return Event_DetailedState.MERGED;
    case 9:
    case "AUTO_CLOSED":
      return Event_DetailedState.AUTO_CLOSED;
    case 10:
    case "FALSE_POSITIVE":
      return Event_DetailedState.FALSE_POSITIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_DetailedState.UNRECOGNIZED;
  }
}

export function event_DetailedStateToJSON(object: Event_DetailedState): string {
  switch (object) {
    case Event_DetailedState.DETAILED_STATE_UNSPECIFIED:
      return "DETAILED_STATE_UNSPECIFIED";
    case Event_DetailedState.EMERGING:
      return "EMERGING";
    case Event_DetailedState.CONFIRMED:
      return "CONFIRMED";
    case Event_DetailedState.RESOLVED:
      return "RESOLVED";
    case Event_DetailedState.MERGED:
      return "MERGED";
    case Event_DetailedState.AUTO_CLOSED:
      return "AUTO_CLOSED";
    case Event_DetailedState.FALSE_POSITIVE:
      return "FALSE_POSITIVE";
    case Event_DetailedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Communicates why a given incident is deemed relevant in the context of a
 * given project. This enum lists all possible detailed states of relevance.
 */
export enum Event_Relevance {
  /** RELEVANCE_UNSPECIFIED - Unspecified relevance. */
  RELEVANCE_UNSPECIFIED = 0,
  /** UNKNOWN - The relevance of the incident to the project is unknown. */
  UNKNOWN = 2,
  /** NOT_IMPACTED - The incident does not impact the project. */
  NOT_IMPACTED = 6,
  /**
   * PARTIALLY_RELATED - The incident is associated with a Google Cloud product your project uses,
   * but the incident may not be impacting your project. For example, the
   * incident may be impacting a Google Cloud product that your project uses,
   * but in a location that your project does not use.
   */
  PARTIALLY_RELATED = 7,
  /**
   * RELATED - The incident has a direct connection with your project and impacts a
   * Google Cloud product in a location your project uses.
   */
  RELATED = 8,
  /** IMPACTED - The incident is verified to be impacting your project. */
  IMPACTED = 9,
  UNRECOGNIZED = -1,
}

export function event_RelevanceFromJSON(object: any): Event_Relevance {
  switch (object) {
    case 0:
    case "RELEVANCE_UNSPECIFIED":
      return Event_Relevance.RELEVANCE_UNSPECIFIED;
    case 2:
    case "UNKNOWN":
      return Event_Relevance.UNKNOWN;
    case 6:
    case "NOT_IMPACTED":
      return Event_Relevance.NOT_IMPACTED;
    case 7:
    case "PARTIALLY_RELATED":
      return Event_Relevance.PARTIALLY_RELATED;
    case 8:
    case "RELATED":
      return Event_Relevance.RELATED;
    case 9:
    case "IMPACTED":
      return Event_Relevance.IMPACTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_Relevance.UNRECOGNIZED;
  }
}

export function event_RelevanceToJSON(object: Event_Relevance): string {
  switch (object) {
    case Event_Relevance.RELEVANCE_UNSPECIFIED:
      return "RELEVANCE_UNSPECIFIED";
    case Event_Relevance.UNKNOWN:
      return "UNKNOWN";
    case Event_Relevance.NOT_IMPACTED:
      return "NOT_IMPACTED";
    case Event_Relevance.PARTIALLY_RELATED:
      return "PARTIALLY_RELATED";
    case Event_Relevance.RELATED:
      return "RELATED";
    case Event_Relevance.IMPACTED:
      return "IMPACTED";
    case Event_Relevance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents service health events that may affect Google Cloud products used
 * across the organization. It is a read-only view and does not allow any
 * modifications.
 */
export interface OrganizationEvent {
  /**
   * Output only. Identifier. Name of the event. Unique name of the event in
   * this scope including organization ID and location using the form
   * `organizations/{organization_id}/locations/{location}/organizationEvents/{event_id}`.
   *
   * `organization_id` - see [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).<br>
   * `location` - The location to get the service health events from.<br>
   * `event_id` - Organization event ID to retrieve.
   */
  name: string;
  /** Output only. Brief description for the event. */
  title: string;
  /** Output only. Free-form, human-readable description. */
  description: string;
  /** Output only. The category of the event. */
  category: OrganizationEvent_EventCategory;
  /** Output only. The detailed category of the event. */
  detailedCategory: OrganizationEvent_DetailedCategory;
  /** Output only. The current state of the event. */
  state: OrganizationEvent_State;
  /** Output only. The current detailed state of the incident. */
  detailedState: OrganizationEvent_DetailedState;
  /**
   * Output only. Represents the Google Cloud products and locations impacted by
   * the event.
   */
  eventImpacts: EventImpact[];
  /**
   * Output only. Incident-only field. Event updates are correspondence from
   * Google.
   */
  updates: EventUpdate[];
  /**
   * Output only. When `detailed_state`=`MERGED`, `parent_event` contains the
   * name of the parent event. All further updates will be published to the
   * parent event.
   */
  parentEvent: string;
  /** Output only. The time the update was posted. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The start time of the event, if applicable. */
  startTime:
    | Date
    | undefined;
  /** Output only. The end time of the event, if applicable. */
  endTime:
    | Date
    | undefined;
  /**
   * Output only. Incident-only field. The time when the next update can be
   * expected.
   */
  nextUpdateTime: Date | undefined;
}

/**
 * The category of the event. This enum lists all possible categories of
 * event.
 */
export enum OrganizationEvent_EventCategory {
  /** EVENT_CATEGORY_UNSPECIFIED - Unspecified category. */
  EVENT_CATEGORY_UNSPECIFIED = 0,
  /** INCIDENT - Event category for service outage or degradation. */
  INCIDENT = 2,
  UNRECOGNIZED = -1,
}

export function organizationEvent_EventCategoryFromJSON(object: any): OrganizationEvent_EventCategory {
  switch (object) {
    case 0:
    case "EVENT_CATEGORY_UNSPECIFIED":
      return OrganizationEvent_EventCategory.EVENT_CATEGORY_UNSPECIFIED;
    case 2:
    case "INCIDENT":
      return OrganizationEvent_EventCategory.INCIDENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationEvent_EventCategory.UNRECOGNIZED;
  }
}

export function organizationEvent_EventCategoryToJSON(object: OrganizationEvent_EventCategory): string {
  switch (object) {
    case OrganizationEvent_EventCategory.EVENT_CATEGORY_UNSPECIFIED:
      return "EVENT_CATEGORY_UNSPECIFIED";
    case OrganizationEvent_EventCategory.INCIDENT:
      return "INCIDENT";
    case OrganizationEvent_EventCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The detailed category of an event. Contains all possible states for all
 * event categories.
 */
export enum OrganizationEvent_DetailedCategory {
  /** DETAILED_CATEGORY_UNSPECIFIED - Unspecified detailed category. */
  DETAILED_CATEGORY_UNSPECIFIED = 0,
  /**
   * CONFIRMED_INCIDENT - Indicates an event with category INCIDENT has a confirmed impact to at
   * least one Google Cloud product.
   */
  CONFIRMED_INCIDENT = 1,
  /**
   * EMERGING_INCIDENT - Indicates an event with category INCIDENT is under investigation to
   * determine if it has a confirmed impact on any Google Cloud products.
   */
  EMERGING_INCIDENT = 2,
  UNRECOGNIZED = -1,
}

export function organizationEvent_DetailedCategoryFromJSON(object: any): OrganizationEvent_DetailedCategory {
  switch (object) {
    case 0:
    case "DETAILED_CATEGORY_UNSPECIFIED":
      return OrganizationEvent_DetailedCategory.DETAILED_CATEGORY_UNSPECIFIED;
    case 1:
    case "CONFIRMED_INCIDENT":
      return OrganizationEvent_DetailedCategory.CONFIRMED_INCIDENT;
    case 2:
    case "EMERGING_INCIDENT":
      return OrganizationEvent_DetailedCategory.EMERGING_INCIDENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationEvent_DetailedCategory.UNRECOGNIZED;
  }
}

export function organizationEvent_DetailedCategoryToJSON(object: OrganizationEvent_DetailedCategory): string {
  switch (object) {
    case OrganizationEvent_DetailedCategory.DETAILED_CATEGORY_UNSPECIFIED:
      return "DETAILED_CATEGORY_UNSPECIFIED";
    case OrganizationEvent_DetailedCategory.CONFIRMED_INCIDENT:
      return "CONFIRMED_INCIDENT";
    case OrganizationEvent_DetailedCategory.EMERGING_INCIDENT:
      return "EMERGING_INCIDENT";
    case OrganizationEvent_DetailedCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The state of the organization event. This enum lists all possible states of
 * event.
 */
export enum OrganizationEvent_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Event is actively affecting a Google Cloud product and will continue to
   * receive updates.
   */
  ACTIVE = 1,
  /**
   * CLOSED - Event is no longer affecting the Google Cloud product or has been merged
   * with another event.
   */
  CLOSED = 2,
  UNRECOGNIZED = -1,
}

export function organizationEvent_StateFromJSON(object: any): OrganizationEvent_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return OrganizationEvent_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return OrganizationEvent_State.ACTIVE;
    case 2:
    case "CLOSED":
      return OrganizationEvent_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationEvent_State.UNRECOGNIZED;
  }
}

export function organizationEvent_StateToJSON(object: OrganizationEvent_State): string {
  switch (object) {
    case OrganizationEvent_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case OrganizationEvent_State.ACTIVE:
      return "ACTIVE";
    case OrganizationEvent_State.CLOSED:
      return "CLOSED";
    case OrganizationEvent_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The detailed state of the incident. This enum lists all possible detailed
 * states of an incident.
 */
export enum OrganizationEvent_DetailedState {
  /** DETAILED_STATE_UNSPECIFIED - Unspecified detail state. */
  DETAILED_STATE_UNSPECIFIED = 0,
  /**
   * EMERGING - Google engineers are actively investigating the incident to determine the
   * impact.
   */
  EMERGING = 1,
  /**
   * CONFIRMED - The incident is confirmed and impacting at least one Google Cloud
   * product. Ongoing status updates will be provided until it is resolved.
   */
  CONFIRMED = 2,
  /**
   * RESOLVED - The incident is no longer affecting any Google Cloud product, and there
   * will be no further updates.
   */
  RESOLVED = 3,
  /**
   * MERGED - The incident was merged into a parent event. All further updates will be
   * published to the parent only. The `parent_event` contains the name of the
   * parent.
   */
  MERGED = 4,
  /**
   * AUTO_CLOSED - The incident was automatically closed because of the following reasons:
   *
   *  * The impact of the incident could not be confirmed.
   *  * The incident was intermittent or resolved itself.
   *
   *  The incident does not have a resolution because no action or
   *  investigation happened. If it is intermittent, the incident may reopen.
   */
  AUTO_CLOSED = 9,
  /**
   * FALSE_POSITIVE - Upon investigation, Google engineers concluded that the incident is not
   * affecting a Google Cloud product. This state can change if the incident
   * is reviewed again.
   */
  FALSE_POSITIVE = 10,
  UNRECOGNIZED = -1,
}

export function organizationEvent_DetailedStateFromJSON(object: any): OrganizationEvent_DetailedState {
  switch (object) {
    case 0:
    case "DETAILED_STATE_UNSPECIFIED":
      return OrganizationEvent_DetailedState.DETAILED_STATE_UNSPECIFIED;
    case 1:
    case "EMERGING":
      return OrganizationEvent_DetailedState.EMERGING;
    case 2:
    case "CONFIRMED":
      return OrganizationEvent_DetailedState.CONFIRMED;
    case 3:
    case "RESOLVED":
      return OrganizationEvent_DetailedState.RESOLVED;
    case 4:
    case "MERGED":
      return OrganizationEvent_DetailedState.MERGED;
    case 9:
    case "AUTO_CLOSED":
      return OrganizationEvent_DetailedState.AUTO_CLOSED;
    case 10:
    case "FALSE_POSITIVE":
      return OrganizationEvent_DetailedState.FALSE_POSITIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrganizationEvent_DetailedState.UNRECOGNIZED;
  }
}

export function organizationEvent_DetailedStateToJSON(object: OrganizationEvent_DetailedState): string {
  switch (object) {
    case OrganizationEvent_DetailedState.DETAILED_STATE_UNSPECIFIED:
      return "DETAILED_STATE_UNSPECIFIED";
    case OrganizationEvent_DetailedState.EMERGING:
      return "EMERGING";
    case OrganizationEvent_DetailedState.CONFIRMED:
      return "CONFIRMED";
    case OrganizationEvent_DetailedState.RESOLVED:
      return "RESOLVED";
    case OrganizationEvent_DetailedState.MERGED:
      return "MERGED";
    case OrganizationEvent_DetailedState.AUTO_CLOSED:
      return "AUTO_CLOSED";
    case OrganizationEvent_DetailedState.FALSE_POSITIVE:
      return "FALSE_POSITIVE";
    case OrganizationEvent_DetailedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Records an update made to the event. */
export interface EventUpdate {
  /** Output only. The time the update was posted. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Brief title for the event. */
  title: string;
  /** Output only. Free-form, human-readable description. */
  description: string;
  /** Output only. Symptoms of the event, if available. */
  symptom: string;
  /** Output only. Workaround steps to remediate the event impact, if available. */
  workaround: string;
}

/** Represents the locations impacted by the event. */
export interface Location {
  /** Location impacted by the event. Example: `"us-central1"` */
  locationName: string;
}

/** Represents the Google Cloud product impacted by the event. */
export interface Product {
  /** Google Cloud product impacted by the event. Example: `"Google Cloud SQL"` */
  productName: string;
}

/** Represents the Google Cloud products and locations impacted by the event. */
export interface EventImpact {
  /** Google Cloud product impacted by the event. */
  product:
    | Product
    | undefined;
  /** Location impacted by the event. */
  location: Location | undefined;
}

/**
 * Represents impact to assets at organizational level. It is a read-only view
 * and does not allow any modifications.
 */
export interface OrganizationImpact {
  /**
   * Output only. Identifier. Unique name of the organization impact in this
   * scope including organization and location using the form
   * `organizations/{organization_id}/locations/{location}/organizationImpacts/{organization_impact_id}`.
   *
   * `organization_id` - ID (number) of the organization that contains the
   * event. To get your `organization_id`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).<br>
   * `organization_impact_id` - ID of the [OrganizationImpact
   * resource](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact).
   */
  name: string;
  /** Output only. A list of event names impacting the asset. */
  events: string[];
  /** Output only. Google Cloud asset possibly impacted by the specified events. */
  asset:
    | Asset
    | undefined;
  /** Output only. The time when the affected project was last modified. */
  updateTime: Date | undefined;
}

/** Represents the asset impacted by the events. */
export interface Asset {
  /**
   * Output only. Full name of the resource as defined in
   * [Resource
   * Names](https://cloud.google.com/apis/design/resource_names#full_resource_name).
   */
  assetName: string;
  /**
   * Output only. Type of the asset. Example:
   * `"cloudresourcemanager.googleapis.com/Project"`
   */
  assetType: string;
}

export interface ListEventsRequest {
  /**
   * Required. Parent value using the form
   * `projects/{project_id}/locations/{location}/events`.
   *
   * `project_id` - ID of the project for which to list service health
   * events.
   * `location` - The location to get the service health events from.
   * To retrieve service health events of category = INCIDENT, use `location` =
   * `global`.
   */
  parent: string;
  /**
   * Optional. The maximum number of events that should be returned.  Acceptable
   * values are 1 to 100, inclusive. (The default value is 10.) If more results
   * are available, the service returns a next_page_token that you can use to
   * get the next page of results in subsequent list requests. The service may
   * return fewer events than the requested page_size.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   * Provide Page token returned by a previous `ListEvents` call to retrieve the
   * next page of results. When paginating, all other parameters provided to
   * `ListEvents` must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. A filter expression that filters resources listed in the
   * response. The expression takes the following forms: <br>
   * *   field=value for `category` and `state`<br>
   * *   field &lt;, >, &lt;=, or >= value for `update_time` <br>
   * Examples: `category=INCIDENT`, `update_time>=2000-01-01T11:30:00-04:00`
   * <br>
   *
   * Multiple filter queries are separated by spaces. Example:
   * `category=INCIDENT state=ACTIVE`.
   *
   * By default, each expression is an AND expression. However, you can include
   * AND and OR expressions explicitly.
   *
   * Filter is supported for the following fields: `category`, `state`,
   * `update_time`
   */
  filter: string;
  /** Optional. Event fields to include in response. */
  view: EventView;
}

export interface ListEventsResponse {
  /** Output only. List of events. */
  events: Event[];
  /**
   * Output only. The continuation token, used to page through large result
   * sets. Provide this value in a subsequent request as page_token to retrieve
   * the next page.
   *
   * If this field is not present, there are no subsequent results.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting an event */
export interface GetEventRequest {
  /**
   * Required. Unique name of the event in this scope including project
   * and location using the form
   * `projects/{project_id}/locations/{location}/events/{event_id}`.
   *
   * `project_id` - Project ID of the project that contains the event. <br>
   * `location` - The location to get the service health events from. <br>
   * `event_id` - Event ID to retrieve.
   */
  name: string;
}

export interface ListOrganizationEventsRequest {
  /**
   * Required. Parent value using the form
   * `organizations/{organization_id}/locations/{location}/organizationEvents`.
   *
   * `organization_id` - ID (number) of the project that contains the event. To
   * get your `organization_id`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).<br>
   * `location` - The location to get the service health events from. To
   * retrieve service health events of category = INCIDENT, use `location` =
   * `global`.
   */
  parent: string;
  /**
   * Optional. The maximum number of events that should be returned.  Acceptable
   * values are `1` to `100`, inclusive. (The default value is `10`.) If more
   * results are available, the service returns a `next_page_token` that you can
   * use to get the next page of results in subsequent list requests. The
   * service may return fewer events than the requested `page_size`.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   *
   * Provide Page token returned by a previous `ListOrganizationEvents` call to
   * retrieve the next page of results.
   *
   * When paginating, all other parameters provided to
   * `ListOrganizationEvents` must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. A filter expression that filters resources listed in the
   * response. The expression takes the following forms:
   *
   * *   field=value for `category` and `state`
   * *   field &lt;, >, &lt;=, or >= value for `update_time`
   *
   * Examples: `category=INCIDENT`, `update_time>=2000-01-01T11:30:00-04:00`
   *
   * Multiple filter queries are space-separated. Example:
   * `category=INCIDENT state=ACTIVE`.
   *
   * By default, each expression is an AND expression. However, you can include
   * AND and OR expressions explicitly.
   *
   * Filter is supported for the following fields: `category`, `state`,
   * `update_time`
   */
  filter: string;
  /** Optional. OrganizationEvent fields to include in response. */
  view: OrganizationEventView;
}

export interface ListOrganizationEventsResponse {
  /** Output only. List of organization events affecting an organization. */
  organizationEvents: OrganizationEvent[];
  /**
   * Output only. The continuation token, used to page through large result
   * sets. Provide this value in a subsequent request as `page_token` to
   * retrieve the next page.
   *
   * If this field is not present, there are no subsequent results.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

export interface GetOrganizationEventRequest {
  /**
   * Required. Unique name of the event in this scope including organization and
   * event ID using the form
   * `organizations/{organization_id}/locations/locations/global/organizationEvents/{event_id}`.
   *
   * `organization_id` - ID (number) of the project that contains the event. To
   * get your `organization_id`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).<br>
   * `event_id` - Organization event ID to retrieve.
   */
  name: string;
}

/** Message for requesting list of OrganizationImpacts */
export interface ListOrganizationImpactsRequest {
  /**
   * Required. Parent value using the form
   * `organizations/{organization_id}/locations/{location}/organizationImpacts`.
   *
   * `organization_id` - ID (number) of the project that contains the event. To
   * get your `organization_id`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
   */
  parent: string;
  /**
   * Optional. The maximum number of events that should be returned. Acceptable
   * values are `1` to `100`, inclusive. The default value is `10`.
   *
   *  If more results are available, the service returns a
   * `next_page_token` that can be used to get the next page of results in
   * subsequent list requests. The service may return fewer
   * [impacts](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact)
   * than the requested `page_size`.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   *
   * Provide `page_token` returned by a previous `ListOrganizationImpacts` call
   * to retrieve the next page of results.
   *
   * When paginating, all other parameters provided to `ListOrganizationImpacts`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. A filter expression that filters resources listed in the
   * response. The expression is in the form of `field:value` for checking if a
   * repeated field contains a value.
   *
   * Example:
   * `events:organizations%2F{organization_id}%2Flocations%2Fglobal%2ForganizationEvents%2Fevent-id`
   *
   * To get your `{organization_id}`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
   *
   * Multiple filter queries are separated by spaces.
   *
   * By default, each expression is an AND expression. However, you can include
   * AND and OR expressions explicitly.
   * Filter is supported for the following fields: `events`.
   */
  filter: string;
}

export interface ListOrganizationImpactsResponse {
  /**
   * Output only. List of
   * [impacts](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact)
   * for an organization affected by service health events.
   */
  organizationImpacts: OrganizationImpact[];
  /**
   * Output only. The continuation token, used to page through large result
   * sets. Provide this value in a subsequent request as `page_token` to
   * retrieve the next page.
   *
   * If this field is not present, there are no subsequent results.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

export interface GetOrganizationImpactRequest {
  /**
   * Required. Name of the resource using the form
   * `organizations/{organization_id}/locations/global/organizationImpacts/{organization_impact_id}`.
   *
   * `organization_id` - ID (number) of the organization that contains the
   * event. To get your `organization_id`, see
   * [Getting your organization resource
   * ID](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).<br>
   * `organization_impact_id` - ID of the [OrganizationImpact
   * resource](/service-health/docs/reference/rest/v1beta/organizations.locations.organizationImpacts#OrganizationImpact).
   */
  name: string;
}

function createBaseEvent(): Event {
  return {
    name: "",
    title: "",
    description: "",
    category: 0,
    detailedCategory: 0,
    state: 0,
    detailedState: 0,
    eventImpacts: [],
    relevance: 0,
    updates: [],
    parentEvent: "",
    updateTime: undefined,
    startTime: undefined,
    endTime: undefined,
    nextUpdateTime: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.detailedCategory !== 0) {
      writer.uint32(168).int32(message.detailedCategory);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.detailedState !== 0) {
      writer.uint32(152).int32(message.detailedState);
    }
    for (const v of message.eventImpacts) {
      EventImpact.encode(v!, writer.uint32(162).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(64).int32(message.relevance);
    }
    for (const v of message.updates) {
      EventUpdate.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.parentEvent !== "") {
      writer.uint32(82).string(message.parentEvent);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(106).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(114).fork()).join();
    }
    if (message.nextUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextUpdateTime), writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.detailedCategory = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.detailedState = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.eventImpacts.push(EventImpact.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updates.push(EventUpdate.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.parentEvent = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.nextUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? event_EventCategoryFromJSON(object.category) : 0,
      detailedCategory: isSet(object.detailedCategory) ? event_DetailedCategoryFromJSON(object.detailedCategory) : 0,
      state: isSet(object.state) ? event_StateFromJSON(object.state) : 0,
      detailedState: isSet(object.detailedState) ? event_DetailedStateFromJSON(object.detailedState) : 0,
      eventImpacts: globalThis.Array.isArray(object?.eventImpacts)
        ? object.eventImpacts.map((e: any) => EventImpact.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? event_RelevanceFromJSON(object.relevance) : 0,
      updates: globalThis.Array.isArray(object?.updates) ? object.updates.map((e: any) => EventUpdate.fromJSON(e)) : [],
      parentEvent: isSet(object.parentEvent) ? globalThis.String(object.parentEvent) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      nextUpdateTime: isSet(object.nextUpdateTime) ? fromJsonTimestamp(object.nextUpdateTime) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = event_EventCategoryToJSON(message.category);
    }
    if (message.detailedCategory !== 0) {
      obj.detailedCategory = event_DetailedCategoryToJSON(message.detailedCategory);
    }
    if (message.state !== 0) {
      obj.state = event_StateToJSON(message.state);
    }
    if (message.detailedState !== 0) {
      obj.detailedState = event_DetailedStateToJSON(message.detailedState);
    }
    if (message.eventImpacts?.length) {
      obj.eventImpacts = message.eventImpacts.map((e) => EventImpact.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = event_RelevanceToJSON(message.relevance);
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => EventUpdate.toJSON(e));
    }
    if (message.parentEvent !== "") {
      obj.parentEvent = message.parentEvent;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.nextUpdateTime !== undefined) {
      obj.nextUpdateTime = message.nextUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    message.detailedCategory = object.detailedCategory ?? 0;
    message.state = object.state ?? 0;
    message.detailedState = object.detailedState ?? 0;
    message.eventImpacts = object.eventImpacts?.map((e) => EventImpact.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    message.updates = object.updates?.map((e) => EventUpdate.fromPartial(e)) || [];
    message.parentEvent = object.parentEvent ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.nextUpdateTime = object.nextUpdateTime ?? undefined;
    return message;
  },
};

function createBaseOrganizationEvent(): OrganizationEvent {
  return {
    name: "",
    title: "",
    description: "",
    category: 0,
    detailedCategory: 0,
    state: 0,
    detailedState: 0,
    eventImpacts: [],
    updates: [],
    parentEvent: "",
    updateTime: undefined,
    startTime: undefined,
    endTime: undefined,
    nextUpdateTime: undefined,
  };
}

export const OrganizationEvent: MessageFns<OrganizationEvent> = {
  encode(message: OrganizationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.detailedCategory !== 0) {
      writer.uint32(136).int32(message.detailedCategory);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.detailedState !== 0) {
      writer.uint32(128).int32(message.detailedState);
    }
    for (const v of message.eventImpacts) {
      EventImpact.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.updates) {
      EventUpdate.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.parentEvent !== "") {
      writer.uint32(74).string(message.parentEvent);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(98).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(106).fork()).join();
    }
    if (message.nextUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextUpdateTime), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.detailedCategory = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.detailedState = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.eventImpacts.push(EventImpact.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updates.push(EventUpdate.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parentEvent = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.nextUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationEvent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? organizationEvent_EventCategoryFromJSON(object.category) : 0,
      detailedCategory: isSet(object.detailedCategory)
        ? organizationEvent_DetailedCategoryFromJSON(object.detailedCategory)
        : 0,
      state: isSet(object.state) ? organizationEvent_StateFromJSON(object.state) : 0,
      detailedState: isSet(object.detailedState) ? organizationEvent_DetailedStateFromJSON(object.detailedState) : 0,
      eventImpacts: globalThis.Array.isArray(object?.eventImpacts)
        ? object.eventImpacts.map((e: any) => EventImpact.fromJSON(e))
        : [],
      updates: globalThis.Array.isArray(object?.updates) ? object.updates.map((e: any) => EventUpdate.fromJSON(e)) : [],
      parentEvent: isSet(object.parentEvent) ? globalThis.String(object.parentEvent) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      nextUpdateTime: isSet(object.nextUpdateTime) ? fromJsonTimestamp(object.nextUpdateTime) : undefined,
    };
  },

  toJSON(message: OrganizationEvent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = organizationEvent_EventCategoryToJSON(message.category);
    }
    if (message.detailedCategory !== 0) {
      obj.detailedCategory = organizationEvent_DetailedCategoryToJSON(message.detailedCategory);
    }
    if (message.state !== 0) {
      obj.state = organizationEvent_StateToJSON(message.state);
    }
    if (message.detailedState !== 0) {
      obj.detailedState = organizationEvent_DetailedStateToJSON(message.detailedState);
    }
    if (message.eventImpacts?.length) {
      obj.eventImpacts = message.eventImpacts.map((e) => EventImpact.toJSON(e));
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => EventUpdate.toJSON(e));
    }
    if (message.parentEvent !== "") {
      obj.parentEvent = message.parentEvent;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.nextUpdateTime !== undefined) {
      obj.nextUpdateTime = message.nextUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OrganizationEvent>): OrganizationEvent {
    return OrganizationEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrganizationEvent>): OrganizationEvent {
    const message = createBaseOrganizationEvent();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    message.detailedCategory = object.detailedCategory ?? 0;
    message.state = object.state ?? 0;
    message.detailedState = object.detailedState ?? 0;
    message.eventImpacts = object.eventImpacts?.map((e) => EventImpact.fromPartial(e)) || [];
    message.updates = object.updates?.map((e) => EventUpdate.fromPartial(e)) || [];
    message.parentEvent = object.parentEvent ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.nextUpdateTime = object.nextUpdateTime ?? undefined;
    return message;
  },
};

function createBaseEventUpdate(): EventUpdate {
  return { updateTime: undefined, title: "", description: "", symptom: "", workaround: "" };
}

export const EventUpdate: MessageFns<EventUpdate> = {
  encode(message: EventUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.symptom !== "") {
      writer.uint32(34).string(message.symptom);
    }
    if (message.workaround !== "") {
      writer.uint32(42).string(message.workaround);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symptom = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workaround = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdate {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      symptom: isSet(object.symptom) ? globalThis.String(object.symptom) : "",
      workaround: isSet(object.workaround) ? globalThis.String(object.workaround) : "",
    };
  },

  toJSON(message: EventUpdate): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.symptom !== "") {
      obj.symptom = message.symptom;
    }
    if (message.workaround !== "") {
      obj.workaround = message.workaround;
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdate>): EventUpdate {
    return EventUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdate>): EventUpdate {
    const message = createBaseEventUpdate();
    message.updateTime = object.updateTime ?? undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.symptom = object.symptom ?? "";
    message.workaround = object.workaround ?? "";
    return message;
  },
};

function createBaseLocation(): Location {
  return { locationName: "" };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locationName !== "") {
      writer.uint32(10).string(message.locationName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return { locationName: isSet(object.locationName) ? globalThis.String(object.locationName) : "" };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.locationName !== "") {
      obj.locationName = message.locationName;
    }
    return obj;
  },

  create(base?: DeepPartial<Location>): Location {
    return Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Location>): Location {
    const message = createBaseLocation();
    message.locationName = object.locationName ?? "";
    return message;
  },
};

function createBaseProduct(): Product {
  return { productName: "" };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productName !== "") {
      writer.uint32(10).string(message.productName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return { productName: isSet(object.productName) ? globalThis.String(object.productName) : "" };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    return obj;
  },

  create(base?: DeepPartial<Product>): Product {
    return Product.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Product>): Product {
    const message = createBaseProduct();
    message.productName = object.productName ?? "";
    return message;
  },
};

function createBaseEventImpact(): EventImpact {
  return { product: undefined, location: undefined };
}

export const EventImpact: MessageFns<EventImpact> = {
  encode(message: EventImpact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventImpact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventImpact {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: EventImpact): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create(base?: DeepPartial<EventImpact>): EventImpact {
    return EventImpact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventImpact>): EventImpact {
    const message = createBaseEventImpact();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseOrganizationImpact(): OrganizationImpact {
  return { name: "", events: [], asset: undefined, updateTime: undefined };
}

export const OrganizationImpact: MessageFns<OrganizationImpact> = {
  encode(message: OrganizationImpact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.events) {
      writer.uint32(18).string(v!);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationImpact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationImpact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => globalThis.String(e)) : [],
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: OrganizationImpact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.events?.length) {
      obj.events = message.events;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OrganizationImpact>): OrganizationImpact {
    return OrganizationImpact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrganizationImpact>): OrganizationImpact {
    const message = createBaseOrganizationImpact();
    message.name = object.name ?? "";
    message.events = object.events?.map((e) => e) || [];
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseAsset(): Asset {
  return { assetName: "", assetType: "" };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetName !== "") {
      writer.uint32(10).string(message.assetName);
    }
    if (message.assetType !== "") {
      writer.uint32(18).string(message.assetType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      assetName: isSet(object.assetName) ? globalThis.String(object.assetName) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.assetName !== "") {
      obj.assetName = message.assetName;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.assetName = object.assetName ?? "";
    message.assetType = object.assetType ?? "";
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", view: 0 };
}

export const ListEventsRequest: MessageFns<ListEventsRequest> = {
  encode(message: ListEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      view: isSet(object.view) ? eventViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListEventsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.view !== 0) {
      obj.view = eventViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsRequest>): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsRequest>): ListEventsRequest {
    const message = createBaseListEventsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListEventsResponse(): ListEventsResponse {
  return { events: [], nextPageToken: "", unreachable: [] };
}

export const ListEventsResponse: MessageFns<ListEventsResponse> = {
  encode(message: ListEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsResponse>): ListEventsResponse {
    return ListEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsResponse>): ListEventsResponse {
    const message = createBaseListEventsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEventRequest(): GetEventRequest {
  return { name: "" };
}

export const GetEventRequest: MessageFns<GetEventRequest> = {
  encode(message: GetEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEventRequest>): GetEventRequest {
    return GetEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEventRequest>): GetEventRequest {
    const message = createBaseGetEventRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOrganizationEventsRequest(): ListOrganizationEventsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", view: 0 };
}

export const ListOrganizationEventsRequest: MessageFns<ListOrganizationEventsRequest> = {
  encode(message: ListOrganizationEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrganizationEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrganizationEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrganizationEventsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      view: isSet(object.view) ? organizationEventViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListOrganizationEventsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.view !== 0) {
      obj.view = organizationEventViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrganizationEventsRequest>): ListOrganizationEventsRequest {
    return ListOrganizationEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrganizationEventsRequest>): ListOrganizationEventsRequest {
    const message = createBaseListOrganizationEventsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListOrganizationEventsResponse(): ListOrganizationEventsResponse {
  return { organizationEvents: [], nextPageToken: "", unreachable: [] };
}

export const ListOrganizationEventsResponse: MessageFns<ListOrganizationEventsResponse> = {
  encode(message: ListOrganizationEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organizationEvents) {
      OrganizationEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrganizationEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrganizationEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organizationEvents.push(OrganizationEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrganizationEventsResponse {
    return {
      organizationEvents: globalThis.Array.isArray(object?.organizationEvents)
        ? object.organizationEvents.map((e: any) => OrganizationEvent.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOrganizationEventsResponse): unknown {
    const obj: any = {};
    if (message.organizationEvents?.length) {
      obj.organizationEvents = message.organizationEvents.map((e) => OrganizationEvent.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrganizationEventsResponse>): ListOrganizationEventsResponse {
    return ListOrganizationEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrganizationEventsResponse>): ListOrganizationEventsResponse {
    const message = createBaseListOrganizationEventsResponse();
    message.organizationEvents = object.organizationEvents?.map((e) => OrganizationEvent.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOrganizationEventRequest(): GetOrganizationEventRequest {
  return { name: "" };
}

export const GetOrganizationEventRequest: MessageFns<GetOrganizationEventRequest> = {
  encode(message: GetOrganizationEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrganizationEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationEventRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOrganizationEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOrganizationEventRequest>): GetOrganizationEventRequest {
    return GetOrganizationEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrganizationEventRequest>): GetOrganizationEventRequest {
    const message = createBaseGetOrganizationEventRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOrganizationImpactsRequest(): ListOrganizationImpactsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListOrganizationImpactsRequest: MessageFns<ListOrganizationImpactsRequest> = {
  encode(message: ListOrganizationImpactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrganizationImpactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrganizationImpactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrganizationImpactsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListOrganizationImpactsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrganizationImpactsRequest>): ListOrganizationImpactsRequest {
    return ListOrganizationImpactsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrganizationImpactsRequest>): ListOrganizationImpactsRequest {
    const message = createBaseListOrganizationImpactsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListOrganizationImpactsResponse(): ListOrganizationImpactsResponse {
  return { organizationImpacts: [], nextPageToken: "", unreachable: [] };
}

export const ListOrganizationImpactsResponse: MessageFns<ListOrganizationImpactsResponse> = {
  encode(message: ListOrganizationImpactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organizationImpacts) {
      OrganizationImpact.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrganizationImpactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrganizationImpactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organizationImpacts.push(OrganizationImpact.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrganizationImpactsResponse {
    return {
      organizationImpacts: globalThis.Array.isArray(object?.organizationImpacts)
        ? object.organizationImpacts.map((e: any) => OrganizationImpact.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOrganizationImpactsResponse): unknown {
    const obj: any = {};
    if (message.organizationImpacts?.length) {
      obj.organizationImpacts = message.organizationImpacts.map((e) => OrganizationImpact.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrganizationImpactsResponse>): ListOrganizationImpactsResponse {
    return ListOrganizationImpactsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrganizationImpactsResponse>): ListOrganizationImpactsResponse {
    const message = createBaseListOrganizationImpactsResponse();
    message.organizationImpacts = object.organizationImpacts?.map((e) => OrganizationImpact.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOrganizationImpactRequest(): GetOrganizationImpactRequest {
  return { name: "" };
}

export const GetOrganizationImpactRequest: MessageFns<GetOrganizationImpactRequest> = {
  encode(message: GetOrganizationImpactRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrganizationImpactRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationImpactRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationImpactRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOrganizationImpactRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOrganizationImpactRequest>): GetOrganizationImpactRequest {
    return GetOrganizationImpactRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrganizationImpactRequest>): GetOrganizationImpactRequest {
    const message = createBaseGetOrganizationImpactRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
