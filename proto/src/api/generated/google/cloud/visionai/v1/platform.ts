// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1/platform.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  StreamAnnotation,
  StreamAnnotationType,
  streamAnnotationTypeFromJSON,
  streamAnnotationTypeToJSON,
} from "./annotations.js";
import { GcsSource } from "./common.js";

export const protobufPackage = "google.cloud.visionai.v1";

/** All the supported model types in Vision AI App Platform. */
export enum ModelType {
  /** MODEL_TYPE_UNSPECIFIED - Processor Type UNSPECIFIED. */
  MODEL_TYPE_UNSPECIFIED = 0,
  /** IMAGE_CLASSIFICATION - Model Type Image Classification. */
  IMAGE_CLASSIFICATION = 1,
  /** OBJECT_DETECTION - Model Type Object Detection. */
  OBJECT_DETECTION = 2,
  /** VIDEO_CLASSIFICATION - Model Type Video Classification. */
  VIDEO_CLASSIFICATION = 3,
  /** VIDEO_OBJECT_TRACKING - Model Type Object Tracking. */
  VIDEO_OBJECT_TRACKING = 4,
  /** VIDEO_ACTION_RECOGNITION - Model Type Action Recognition. */
  VIDEO_ACTION_RECOGNITION = 5,
  /** OCCUPANCY_COUNTING - Model Type Occupancy Counting. */
  OCCUPANCY_COUNTING = 6,
  /** PERSON_BLUR - Model Type Person Blur. */
  PERSON_BLUR = 7,
  /** VERTEX_CUSTOM - Model Type Vertex Custom. */
  VERTEX_CUSTOM = 8,
  /** PRODUCT_RECOGNIZER - Model Type Product Recognizer. */
  PRODUCT_RECOGNIZER = 9,
  /** TAG_RECOGNIZER - Model Type Tag Recognizer. */
  TAG_RECOGNIZER = 10,
  /** SYNTH_ID - Model Type SynthID. */
  SYNTH_ID = 15,
  UNRECOGNIZED = -1,
}

export function modelTypeFromJSON(object: any): ModelType {
  switch (object) {
    case 0:
    case "MODEL_TYPE_UNSPECIFIED":
      return ModelType.MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "IMAGE_CLASSIFICATION":
      return ModelType.IMAGE_CLASSIFICATION;
    case 2:
    case "OBJECT_DETECTION":
      return ModelType.OBJECT_DETECTION;
    case 3:
    case "VIDEO_CLASSIFICATION":
      return ModelType.VIDEO_CLASSIFICATION;
    case 4:
    case "VIDEO_OBJECT_TRACKING":
      return ModelType.VIDEO_OBJECT_TRACKING;
    case 5:
    case "VIDEO_ACTION_RECOGNITION":
      return ModelType.VIDEO_ACTION_RECOGNITION;
    case 6:
    case "OCCUPANCY_COUNTING":
      return ModelType.OCCUPANCY_COUNTING;
    case 7:
    case "PERSON_BLUR":
      return ModelType.PERSON_BLUR;
    case 8:
    case "VERTEX_CUSTOM":
      return ModelType.VERTEX_CUSTOM;
    case 9:
    case "PRODUCT_RECOGNIZER":
      return ModelType.PRODUCT_RECOGNIZER;
    case 10:
    case "TAG_RECOGNIZER":
      return ModelType.TAG_RECOGNIZER;
    case 15:
    case "SYNTH_ID":
      return ModelType.SYNTH_ID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelType.UNRECOGNIZED;
  }
}

export function modelTypeToJSON(object: ModelType): string {
  switch (object) {
    case ModelType.MODEL_TYPE_UNSPECIFIED:
      return "MODEL_TYPE_UNSPECIFIED";
    case ModelType.IMAGE_CLASSIFICATION:
      return "IMAGE_CLASSIFICATION";
    case ModelType.OBJECT_DETECTION:
      return "OBJECT_DETECTION";
    case ModelType.VIDEO_CLASSIFICATION:
      return "VIDEO_CLASSIFICATION";
    case ModelType.VIDEO_OBJECT_TRACKING:
      return "VIDEO_OBJECT_TRACKING";
    case ModelType.VIDEO_ACTION_RECOGNITION:
      return "VIDEO_ACTION_RECOGNITION";
    case ModelType.OCCUPANCY_COUNTING:
      return "OCCUPANCY_COUNTING";
    case ModelType.PERSON_BLUR:
      return "PERSON_BLUR";
    case ModelType.VERTEX_CUSTOM:
      return "VERTEX_CUSTOM";
    case ModelType.PRODUCT_RECOGNIZER:
      return "PRODUCT_RECOGNIZER";
    case ModelType.TAG_RECOGNIZER:
      return "TAG_RECOGNIZER";
    case ModelType.SYNTH_ID:
      return "SYNTH_ID";
    case ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a hardware accelerator type. */
export enum AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Unspecified accelerator type, which means no accelerator. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Nvidia Tesla K80 GPU. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Nvidia Tesla P100 GPU. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Nvidia Tesla V100 GPU. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Nvidia Tesla P4 GPU. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Nvidia Tesla T4 GPU. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Nvidia Tesla A100 GPU. */
  NVIDIA_TESLA_A100 = 8,
  /** TPU_V2 - TPU v2. */
  TPU_V2 = 6,
  /** TPU_V3 - TPU v3. */
  TPU_V3 = 7,
  UNRECOGNIZED = -1,
}

export function acceleratorTypeFromJSON(object: any): AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return AcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return AcceleratorType.NVIDIA_TESLA_T4;
    case 8:
    case "NVIDIA_TESLA_A100":
      return AcceleratorType.NVIDIA_TESLA_A100;
    case 6:
    case "TPU_V2":
      return AcceleratorType.TPU_V2;
    case 7:
    case "TPU_V3":
      return AcceleratorType.TPU_V3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceleratorType.UNRECOGNIZED;
  }
}

export function acceleratorTypeToJSON(object: AcceleratorType): string {
  switch (object) {
    case AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case AcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case AcceleratorType.TPU_V2:
      return "TPU_V2";
    case AcceleratorType.TPU_V3:
      return "TPU_V3";
    case AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All supported data types. */
export enum DataType {
  /** DATA_TYPE_UNSPECIFIED - The default value of DataType. */
  DATA_TYPE_UNSPECIFIED = 0,
  /** VIDEO - Video data type like H264. */
  VIDEO = 1,
  /** IMAGE - Image data type. */
  IMAGE = 3,
  /** PROTO - Protobuf data type, usually used for general data blob. */
  PROTO = 2,
  /**
   * PLACEHOLDER - A placeholder data type, applicable for the universal input processor which
   * supports any data type. This will be instantiated and replaced by a
   * concrete underlying `DataType` during instance deployment.
   */
  PLACEHOLDER = 4,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "VIDEO":
      return DataType.VIDEO;
    case 3:
    case "IMAGE":
      return DataType.IMAGE;
    case 2:
    case "PROTO":
      return DataType.PROTO;
    case 4:
    case "PLACEHOLDER":
      return DataType.PLACEHOLDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataType.VIDEO:
      return "VIDEO";
    case DataType.IMAGE:
      return "IMAGE";
    case DataType.PROTO:
      return "PROTO";
    case DataType.PLACEHOLDER:
      return "PLACEHOLDER";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for DeleteApplicationInstance Response. */
export interface DeleteApplicationInstancesResponse {
}

/** Message for CreateApplicationInstance Response. */
export interface CreateApplicationInstancesResponse {
}

/** Message for UpdateApplicationInstances Response. */
export interface UpdateApplicationInstancesResponse {
}

/** Message for adding stream input to an Application. */
export interface CreateApplicationInstancesRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /** Required. The resources being created. */
  applicationInstances: ApplicationInstance[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for removing stream input from an Application. */
export interface DeleteApplicationInstancesRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /** Required. Id of the requesting object. */
  instanceIds: string[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * RPC Request Messages.
 * Message for DeployApplication Response.
 */
export interface DeployApplicationResponse {
}

/** Message for UndeployApplication Response. */
export interface UndeployApplicationResponse {
}

/** Message for RemoveApplicationStreamInput Response. */
export interface RemoveApplicationStreamInputResponse {
}

/** Message for AddApplicationStreamInput Response. */
export interface AddApplicationStreamInputResponse {
}

/** Message for AddApplicationStreamInput Response. */
export interface UpdateApplicationStreamInputResponse {
}

/** Message for requesting list of Applications. */
export interface ListApplicationsRequest {
  /** Required. Parent value for ListApplicationsRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing Applications. */
export interface ListApplicationsResponse {
  /** The list of Application. */
  applications: Application[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Application. */
export interface GetApplicationRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for creating a Application. */
export interface CreateApplicationRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. Id of the requesting object. */
  applicationId: string;
  /** Required. The resource being created. */
  application:
    | Application
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating an Application. */
export interface UpdateApplicationRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * Application resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  application:
    | Application
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting an Application. */
export interface DeleteApplicationRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, any instances and drafts from this application
   * will also be deleted. (Otherwise, the request will only work if the
   * application has no instances and drafts.)
   */
  force: boolean;
}

/** Message for deploying an Application. */
export interface DeployApplicationRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /**
   * If set, validate the request and preview the application graph, but do not
   * actually deploy it.
   */
  validateOnly: boolean;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. Whether or not to enable monitoring for the application on
   * deployment.
   */
  enableMonitoring: boolean;
}

/** Message for undeploying an Application. */
export interface UndeployApplicationRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message about a single stream input config. */
export interface ApplicationStreamInput {
  streamWithAnnotation: StreamWithAnnotation | undefined;
}

/** Message for adding stream input to an Application. */
export interface AddApplicationStreamInputRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /**
   * The stream inputs to add, the stream resource name is the key of each
   * StreamInput, and it must be unique within each application.
   */
  applicationStreamInputs: ApplicationStreamInput[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating stream input to an Application. */
export interface UpdateApplicationStreamInputRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /**
   * The stream inputs to update, the stream resource name is the key of each
   * StreamInput, and it must be unique within each application.
   */
  applicationStreamInputs: ApplicationStreamInput[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * If true, UpdateApplicationStreamInput will insert stream input to
   * application even if the target stream is not included in the application.
   */
  allowMissing: boolean;
}

/** Message for removing stream input from an Application. */
export interface RemoveApplicationStreamInputRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  /** The target stream to remove. */
  targetStreamInputs: RemoveApplicationStreamInputRequest_TargetStreamInput[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message about target streamInput to remove. */
export interface RemoveApplicationStreamInputRequest_TargetStreamInput {
  stream: string;
}

/** Message for requesting list of Instances. */
export interface ListInstancesRequest {
  /** Required. Parent value for ListInstancesRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing Instances. */
export interface ListInstancesResponse {
  /** The list of Instance. */
  instances: Instance[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Instance. */
export interface GetInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for requesting list of Drafts. */
export interface ListDraftsRequest {
  /** Required. Parent value for ListDraftsRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing Drafts. */
export interface ListDraftsResponse {
  /** The list of Draft. */
  drafts: Draft[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Draft. */
export interface GetDraftRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for creating a Draft. */
export interface CreateDraftRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. Id of the requesting object. */
  draftId: string;
  /** Required. The resource being created. */
  draft:
    | Draft
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating a Draft. */
export interface UpdateDraftRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * Draft resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  draft:
    | Draft
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * If true, UpdateDraftRequest will create one resource if the target resource
   * doesn't exist, this time, the field_mask will be ignored.
   */
  allowMissing: boolean;
}

/** Message for updating an ApplicationInstance. */
export interface UpdateApplicationInstancesRequest {
  /**
   * Required. the name of the application to retrieve.
   * Format:
   * "projects/{project}/locations/{location}/applications/{application}"
   */
  name: string;
  applicationInstances: UpdateApplicationInstancesRequest_UpdateApplicationInstance[];
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * If true, Update Request will create one resource if the target resource
   * doesn't exist, this time, the field_mask will be ignored.
   */
  allowMissing: boolean;
}

export interface UpdateApplicationInstancesRequest_UpdateApplicationInstance {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in
   * the Draft resource by the update. The fields specified in the update_mask
   * are relative to the resource, not the full request. A field will be
   * overwritten if it is in the mask. If the user does not provide a mask
   * then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  instance:
    | Instance
    | undefined;
  /** Required. The id of the instance. */
  instanceId: string;
}

/** Message for deleting a Draft. */
export interface DeleteDraftRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for requesting list of Processors. */
export interface ListProcessorsRequest {
  /** Required. Parent value for ListProcessorsRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing Processors. */
export interface ListProcessorsResponse {
  /** The list of Processor. */
  processors: Processor[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request Message for listing Prebuilt Processors. */
export interface ListPrebuiltProcessorsRequest {
  /** Required. Parent path. */
  parent: string;
}

/** Response Message for listing Prebuilt Processors. */
export interface ListPrebuiltProcessorsResponse {
  /** The list of Processor. */
  processors: Processor[];
}

/** Message for getting a Processor. */
export interface GetProcessorRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for creating a Processor. */
export interface CreateProcessorRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. Id of the requesting object. */
  processorId: string;
  /** Required. The resource being created. */
  processor:
    | Processor
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating a Processor. */
export interface UpdateProcessorRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * Processor resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  processor:
    | Processor
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a Processor. */
export interface DeleteProcessorRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message describing Application object */
export interface Application {
  /** name of resource */
  name: string;
  /** Output only. [Output only] Create timestamp */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Update timestamp */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the solution. */
  displayName: string;
  /** A description for this application. */
  description: string;
  /** Application graph configuration. */
  applicationConfigs:
    | ApplicationConfigs
    | undefined;
  /**
   * Output only. Application graph runtime info. Only exists when application
   * state equals to DEPLOYED.
   */
  runtimeInfo:
    | Application_ApplicationRuntimeInfo
    | undefined;
  /** Output only. State of the application. */
  state: Application_State;
  /** Billing mode of the application. */
  billingMode: Application_BillingMode;
}

/** State of the Application */
export enum Application_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** CREATED - State CREATED. */
  CREATED = 1,
  /** DEPLOYING - State DEPLOYING. */
  DEPLOYING = 2,
  /** DEPLOYED - State DEPLOYED. */
  DEPLOYED = 3,
  /** UNDEPLOYING - State UNDEPLOYING. */
  UNDEPLOYING = 4,
  /** DELETED - State DELETED. */
  DELETED = 5,
  /** ERROR - State ERROR. */
  ERROR = 6,
  /** CREATING - State CREATING. */
  CREATING = 7,
  /** UPDATING - State Updating. */
  UPDATING = 8,
  /** DELETING - State Deleting. */
  DELETING = 9,
  /** FIXING - State Fixing. */
  FIXING = 10,
  UNRECOGNIZED = -1,
}

export function application_StateFromJSON(object: any): Application_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Application_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return Application_State.CREATED;
    case 2:
    case "DEPLOYING":
      return Application_State.DEPLOYING;
    case 3:
    case "DEPLOYED":
      return Application_State.DEPLOYED;
    case 4:
    case "UNDEPLOYING":
      return Application_State.UNDEPLOYING;
    case 5:
    case "DELETED":
      return Application_State.DELETED;
    case 6:
    case "ERROR":
      return Application_State.ERROR;
    case 7:
    case "CREATING":
      return Application_State.CREATING;
    case 8:
    case "UPDATING":
      return Application_State.UPDATING;
    case 9:
    case "DELETING":
      return Application_State.DELETING;
    case 10:
    case "FIXING":
      return Application_State.FIXING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Application_State.UNRECOGNIZED;
  }
}

export function application_StateToJSON(object: Application_State): string {
  switch (object) {
    case Application_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Application_State.CREATED:
      return "CREATED";
    case Application_State.DEPLOYING:
      return "DEPLOYING";
    case Application_State.DEPLOYED:
      return "DEPLOYED";
    case Application_State.UNDEPLOYING:
      return "UNDEPLOYING";
    case Application_State.DELETED:
      return "DELETED";
    case Application_State.ERROR:
      return "ERROR";
    case Application_State.CREATING:
      return "CREATING";
    case Application_State.UPDATING:
      return "UPDATING";
    case Application_State.DELETING:
      return "DELETING";
    case Application_State.FIXING:
      return "FIXING";
    case Application_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Billing mode of the Application */
export enum Application_BillingMode {
  /** BILLING_MODE_UNSPECIFIED - The default value. */
  BILLING_MODE_UNSPECIFIED = 0,
  /** PAYG - Pay as you go billing mode. */
  PAYG = 1,
  /** MONTHLY - Monthly billing mode. */
  MONTHLY = 2,
  UNRECOGNIZED = -1,
}

export function application_BillingModeFromJSON(object: any): Application_BillingMode {
  switch (object) {
    case 0:
    case "BILLING_MODE_UNSPECIFIED":
      return Application_BillingMode.BILLING_MODE_UNSPECIFIED;
    case 1:
    case "PAYG":
      return Application_BillingMode.PAYG;
    case 2:
    case "MONTHLY":
      return Application_BillingMode.MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Application_BillingMode.UNRECOGNIZED;
  }
}

export function application_BillingModeToJSON(object: Application_BillingMode): string {
  switch (object) {
    case Application_BillingMode.BILLING_MODE_UNSPECIFIED:
      return "BILLING_MODE_UNSPECIFIED";
    case Application_BillingMode.PAYG:
      return "PAYG";
    case Application_BillingMode.MONTHLY:
      return "MONTHLY";
    case Application_BillingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message storing the runtime information of the application. */
export interface Application_ApplicationRuntimeInfo {
  /** Timestamp when the engine be deployed */
  deployTime:
    | Date
    | undefined;
  /** Globally created resources like warehouse dataschemas. */
  globalOutputResources: Application_ApplicationRuntimeInfo_GlobalOutputResource[];
  /** Monitoring-related configuration for this application. */
  monitoringConfig: Application_ApplicationRuntimeInfo_MonitoringConfig | undefined;
}

/** Message about output resources from application. */
export interface Application_ApplicationRuntimeInfo_GlobalOutputResource {
  /** The full resource name of the outputted resources. */
  outputResource: string;
  /**
   * The name of graph node who produces the output resource name.
   * For example:
   * output_resource:
   * /projects/123/locations/us-central1/corpora/my-corpus/dataSchemas/my-schema
   * producer_node: occupancy-count
   */
  producerNode: string;
  /**
   * The key of the output resource, it has to be unique within the same
   * producer node. One producer node can output several output resources,
   * the key can be used to match corresponding output resources.
   */
  key: string;
}

/** Monitoring-related configuration for an application. */
export interface Application_ApplicationRuntimeInfo_MonitoringConfig {
  /** Whether this application has monitoring enabled. */
  enabled: boolean;
}

export interface Application_LabelsEntry {
  key: string;
  value: string;
}

/** Message storing the graph of the application. */
export interface ApplicationConfigs {
  /** A list of nodes  in the application graph. */
  nodes: Node[];
  /** Event-related configuration for this application. */
  eventDeliveryConfig: ApplicationConfigs_EventDeliveryConfig | undefined;
}

/** message storing the config for event delivery */
export interface ApplicationConfigs_EventDeliveryConfig {
  /**
   * The delivery channel for the event notification, only pub/sub topic is
   * supported now.
   * Example channel:
   * [//pubsub.googleapis.com/projects/visionai-testing-stable/topics/test-topic]
   */
  channel: string;
  /**
   * The expected delivery interval for the same event. The same event won't
   * be notified multiple times during this internal event that it is
   * happening multiple times during the period of time.The same event is
   * identified by <event_id, app_platform_metadata>.
   */
  minimalDeliveryInterval: Duration | undefined;
}

/** Message describing node object. */
export interface Node {
  /**
   * By default, the output of the node will only be available to downstream
   * nodes. To consume the direct output from the application node, the output
   * must be sent to Vision AI Streams at first.
   *
   * By setting output_all_output_channels_to_stream to true, App Platform
   * will automatically send all the outputs of the current node to Vision AI
   * Stream resources (one stream per output channel). The output stream
   * resource will be created by App Platform automatically during deployment
   * and deleted after application un-deployment.
   * Note that this config applies to all the Application Instances.
   *
   * The output stream can be override at instance level by
   * configuring the `output_resources` section of Instance resource.
   * `producer_node` should be current node, `output_resource_binding` should
   * be the output channel name (or leave it blank if there is only 1 output
   * channel of the processor) and `output_resource` should be the target
   * output stream.
   */
  outputAllOutputChannelsToStream?:
    | boolean
    | undefined;
  /** Required. A unique name for the node. */
  name: string;
  /** A user friendly display name for the node. */
  displayName: string;
  /** Node config. */
  nodeConfig:
    | ProcessorConfig
    | undefined;
  /** Processor name refer to the chosen processor resource. */
  processor: string;
  /**
   * Parent node. Input node should not have parent node. For V1 Alpha1/Beta
   * only media warehouse node can have multiple parents, other types of nodes
   * will only have one parent.
   */
  parents: Node_InputEdge[];
}

/** Message describing one edge pointing into a node. */
export interface Node_InputEdge {
  /** The name of the parent node. */
  parentNode: string;
  /**
   * The connected output artifact of the parent node.
   * It can be omitted if target processor only has 1 output artifact.
   */
  parentOutputChannel: string;
  /**
   * The connected input channel of the current node's processor.
   * It can be omitted if target processor only has 1 input channel.
   */
  connectedInputChannel: string;
}

/** Message describing Draft object */
export interface Draft {
  /** name of resource */
  name: string;
  /** Output only. [Output only] Create timestamp */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Create timestamp */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the solution. */
  displayName: string;
  /** A description for this application. */
  description: string;
  /** The draft application configs which haven't been updated to an application. */
  draftApplicationConfigs: ApplicationConfigs | undefined;
}

export interface Draft_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Message describing Instance object
 * Next ID: 12
 */
export interface Instance {
  /** Output only. name of resource */
  name: string;
  /** Output only. [Output only] Create timestamp */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Update timestamp */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the solution. */
  displayName: string;
  /** A description for this instance. */
  description: string;
  /** The instance type for the current instance. */
  instanceType: Instance_InstanceType;
  /**
   * The input resources for the current application instance.
   * For example:
   * input_resources:
   * visionai.googleapis.com/v1/projects/123/locations/us-central1/clusters/456/streams/stream-a
   */
  inputResources: Instance_InputResource[];
  /** All the output resources associated to one application instance. */
  outputResources: Instance_OutputResource[];
  /** State of the instance. */
  state: Instance_State;
}

/** All the supported instance types. */
export enum Instance_InstanceType {
  /**
   * INSTANCE_TYPE_UNSPECIFIED - Unspecified instance type.
   * If the instance type is not specified, the default one is
   * STREAMING_PREDICTION.
   */
  INSTANCE_TYPE_UNSPECIFIED = 0,
  /** STREAMING_PREDICTION - Instance type for streaming prediction. */
  STREAMING_PREDICTION = 1,
  /** BATCH_PREDICTION - Instance type for batch prediction. */
  BATCH_PREDICTION = 2,
  /** ONLINE_PREDICTION - Instance type for online prediction. */
  ONLINE_PREDICTION = 3,
  UNRECOGNIZED = -1,
}

export function instance_InstanceTypeFromJSON(object: any): Instance_InstanceType {
  switch (object) {
    case 0:
    case "INSTANCE_TYPE_UNSPECIFIED":
      return Instance_InstanceType.INSTANCE_TYPE_UNSPECIFIED;
    case 1:
    case "STREAMING_PREDICTION":
      return Instance_InstanceType.STREAMING_PREDICTION;
    case 2:
    case "BATCH_PREDICTION":
      return Instance_InstanceType.BATCH_PREDICTION;
    case 3:
    case "ONLINE_PREDICTION":
      return Instance_InstanceType.ONLINE_PREDICTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_InstanceType.UNRECOGNIZED;
  }
}

export function instance_InstanceTypeToJSON(object: Instance_InstanceType): string {
  switch (object) {
    case Instance_InstanceType.INSTANCE_TYPE_UNSPECIFIED:
      return "INSTANCE_TYPE_UNSPECIFIED";
    case Instance_InstanceType.STREAMING_PREDICTION:
      return "STREAMING_PREDICTION";
    case Instance_InstanceType.BATCH_PREDICTION:
      return "BATCH_PREDICTION";
    case Instance_InstanceType.ONLINE_PREDICTION:
      return "ONLINE_PREDICTION";
    case Instance_InstanceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** State of the Instance */
export enum Instance_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - State CREATING. */
  CREATING = 1,
  /** CREATED - State CREATED. */
  CREATED = 2,
  /** DEPLOYING - State DEPLOYING. */
  DEPLOYING = 3,
  /** DEPLOYED - State DEPLOYED. */
  DEPLOYED = 4,
  /** UNDEPLOYING - State UNDEPLOYING. */
  UNDEPLOYING = 5,
  /** DELETED - State DELETED. */
  DELETED = 6,
  /** ERROR - State ERROR. */
  ERROR = 7,
  /** UPDATING - State Updating */
  UPDATING = 8,
  /** DELETING - State Deleting. */
  DELETING = 9,
  /** FIXING - State Fixing. */
  FIXING = 10,
  /** FINISHED - State Finished. */
  FINISHED = 11,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Instance_State.CREATING;
    case 2:
    case "CREATED":
      return Instance_State.CREATED;
    case 3:
    case "DEPLOYING":
      return Instance_State.DEPLOYING;
    case 4:
    case "DEPLOYED":
      return Instance_State.DEPLOYED;
    case 5:
    case "UNDEPLOYING":
      return Instance_State.UNDEPLOYING;
    case 6:
    case "DELETED":
      return Instance_State.DELETED;
    case 7:
    case "ERROR":
      return Instance_State.ERROR;
    case 8:
    case "UPDATING":
      return Instance_State.UPDATING;
    case 9:
    case "DELETING":
      return Instance_State.DELETING;
    case 10:
    case "FIXING":
      return Instance_State.FIXING;
    case 11:
    case "FINISHED":
      return Instance_State.FINISHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.CREATED:
      return "CREATED";
    case Instance_State.DEPLOYING:
      return "DEPLOYING";
    case Instance_State.DEPLOYED:
      return "DEPLOYED";
    case Instance_State.UNDEPLOYING:
      return "UNDEPLOYING";
    case Instance_State.DELETED:
      return "DELETED";
    case Instance_State.ERROR:
      return "ERROR";
    case Instance_State.UPDATING:
      return "UPDATING";
    case Instance_State.DELETING:
      return "DELETING";
    case Instance_State.FIXING:
      return "FIXING";
    case Instance_State.FINISHED:
      return "FINISHED";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message of input resource used in one application instance. */
export interface Instance_InputResource {
  /**
   * The direct input resource name.
   * If the instance type is STREAMING_PREDICTION, the input resource is in
   * format of
   * "projects/123/locations/us-central1/clusters/456/streams/stream-a".
   * If the instance type is BATCH_PREDICTION from Cloud Storage input
   * container, the input resource is in format of "gs://bucket-a".
   */
  inputResource?:
    | string
    | undefined;
  /**
   * If the input resource is VisionAI Stream, the associated annotations
   * can be specified using annotated_stream instead.
   *
   * @deprecated
   */
  annotatedStream?:
    | StreamWithAnnotation
    | undefined;
  /** Data type for the current input resource. */
  dataType: DataType;
  /**
   * The name of graph node who receives the input resource.
   * For example:
   * input_resource:
   * visionai.googleapis.com/v1/projects/123/locations/us-central1/clusters/456/streams/input-stream-a
   * consumer_node: stream-input
   */
  consumerNode: string;
  /**
   * The specific input resource binding which will consume the current Input
   * Resource, can be ignored is there is only 1 input binding.
   */
  inputResourceBinding: string;
  /** Contains resource annotations. */
  annotations: ResourceAnnotations | undefined;
}

/** Message of output resource used in one application instance. */
export interface Instance_OutputResource {
  /** The output resource name for the current application instance. */
  outputResource: string;
  /**
   * The name of graph node who produces the output resource name.
   * For example:
   * output_resource:
   * /projects/123/locations/us-central1/clusters/456/streams/output-application-789-stream-a-occupancy-counting
   * producer_node: occupancy-counting
   */
  producerNode: string;
  /**
   * The specific output resource binding which produces the current
   * OutputResource.
   */
  outputResourceBinding: string;
  /**
   * Output only. Whether the output resource is temporary which means the
   * resource is generated during the deployment of the application. Temporary
   * resource will be deleted during the undeployment of the application.
   */
  isTemporary: boolean;
  /**
   * Output only. Whether the output resource is created automatically by the
   * Vision AI App Platform.
   */
  autogen: boolean;
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

/** Message for creating a Instance. */
export interface ApplicationInstance {
  /** Required. Id of the requesting object. */
  instanceId: string;
  /** Required. The resource being created. */
  instance: Instance | undefined;
}

/**
 * Message describing Processor object.
 * Next ID: 19
 */
export interface Processor {
  /** name of resource. */
  name: string;
  /** Output only. [Output only] Create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Required. A user friendly display name for the processor. */
  displayName: string;
  /** Illustrative sentences for describing the functionality of the processor. */
  description: string;
  /** Output only. Processor Type. */
  processorType: Processor_ProcessorType;
  /** Model Type. */
  modelType: ModelType;
  /** Source info for customer created processor. */
  customProcessorSourceInfo:
    | CustomProcessorSourceInfo
    | undefined;
  /** Output only. State of the Processor. */
  state: Processor_ProcessorState;
  /**
   * Output only. [Output only] The input / output specifications of a
   * processor, each type of processor has fixed input / output specs which
   * cannot be altered by customer.
   */
  processorIoSpec:
    | ProcessorIOSpec
    | undefined;
  /**
   * Output only. The corresponding configuration can be used in the Application
   * to customize the behavior of the processor.
   */
  configurationTypeurl: string;
  supportedAnnotationTypes: StreamAnnotationType[];
  /** Indicates if the processor supports post processing. */
  supportsPostProcessing: boolean;
  /**
   * Which instance types this processor supports; if empty, this default to
   * STREAMING_PREDICTION.
   */
  supportedInstanceTypes: Instance_InstanceType[];
}

/** Type */
export enum Processor_ProcessorType {
  /** PROCESSOR_TYPE_UNSPECIFIED - Processor Type UNSPECIFIED. */
  PROCESSOR_TYPE_UNSPECIFIED = 0,
  /**
   * PRETRAINED - Processor Type PRETRAINED.
   * Pretrained processor is developed by Vision AI App Platform with
   * state-of-the-art vision data processing functionality, like occupancy
   * counting or person blur. Pretrained processor is usually publicly
   * available.
   */
  PRETRAINED = 1,
  /**
   * CUSTOM - Processor Type CUSTOM.
   * Custom processors are specialized processors which are either uploaded by
   * customers or imported from other GCP platform (for example Vertex AI).
   * Custom processor is only visible to the creator.
   */
  CUSTOM = 2,
  /**
   * CONNECTOR - Processor Type CONNECTOR.
   * Connector processors are special processors which perform I/O for the
   * application, they do not processing the data but either deliver the data
   * to other processors or receive data from other processors.
   */
  CONNECTOR = 3,
  UNRECOGNIZED = -1,
}

export function processor_ProcessorTypeFromJSON(object: any): Processor_ProcessorType {
  switch (object) {
    case 0:
    case "PROCESSOR_TYPE_UNSPECIFIED":
      return Processor_ProcessorType.PROCESSOR_TYPE_UNSPECIFIED;
    case 1:
    case "PRETRAINED":
      return Processor_ProcessorType.PRETRAINED;
    case 2:
    case "CUSTOM":
      return Processor_ProcessorType.CUSTOM;
    case 3:
    case "CONNECTOR":
      return Processor_ProcessorType.CONNECTOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Processor_ProcessorType.UNRECOGNIZED;
  }
}

export function processor_ProcessorTypeToJSON(object: Processor_ProcessorType): string {
  switch (object) {
    case Processor_ProcessorType.PROCESSOR_TYPE_UNSPECIFIED:
      return "PROCESSOR_TYPE_UNSPECIFIED";
    case Processor_ProcessorType.PRETRAINED:
      return "PRETRAINED";
    case Processor_ProcessorType.CUSTOM:
      return "CUSTOM";
    case Processor_ProcessorType.CONNECTOR:
      return "CONNECTOR";
    case Processor_ProcessorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Processor_ProcessorState {
  /** PROCESSOR_STATE_UNSPECIFIED - Unspecified Processor state. */
  PROCESSOR_STATE_UNSPECIFIED = 0,
  /** CREATING - Processor is being created (not ready for use). */
  CREATING = 1,
  /** ACTIVE - Processor is and ready for use. */
  ACTIVE = 2,
  /** DELETING - Processor is being deleted (not ready for use). */
  DELETING = 3,
  /** FAILED - Processor deleted or creation failed . */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function processor_ProcessorStateFromJSON(object: any): Processor_ProcessorState {
  switch (object) {
    case 0:
    case "PROCESSOR_STATE_UNSPECIFIED":
      return Processor_ProcessorState.PROCESSOR_STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Processor_ProcessorState.CREATING;
    case 2:
    case "ACTIVE":
      return Processor_ProcessorState.ACTIVE;
    case 3:
    case "DELETING":
      return Processor_ProcessorState.DELETING;
    case 4:
    case "FAILED":
      return Processor_ProcessorState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Processor_ProcessorState.UNRECOGNIZED;
  }
}

export function processor_ProcessorStateToJSON(object: Processor_ProcessorState): string {
  switch (object) {
    case Processor_ProcessorState.PROCESSOR_STATE_UNSPECIFIED:
      return "PROCESSOR_STATE_UNSPECIFIED";
    case Processor_ProcessorState.CREATING:
      return "CREATING";
    case Processor_ProcessorState.ACTIVE:
      return "ACTIVE";
    case Processor_ProcessorState.DELETING:
      return "DELETING";
    case Processor_ProcessorState.FAILED:
      return "FAILED";
    case Processor_ProcessorState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Processor_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing the input / output specifications of a processor. */
export interface ProcessorIOSpec {
  /**
   * For processors with input_channel_specs, the processor must be explicitly
   * connected to another processor.
   */
  graphInputChannelSpecs: ProcessorIOSpec_GraphInputChannelSpec[];
  /** The output artifact specifications for the current processor. */
  graphOutputChannelSpecs: ProcessorIOSpec_GraphOutputChannelSpec[];
  /** The input resource that needs to be fed from the application instance. */
  instanceResourceInputBindingSpecs: ProcessorIOSpec_InstanceResourceInputBindingSpec[];
  /**
   * The output resource that the processor will generate per instance.
   * Other than the explicitly listed output bindings here, all the processors'
   * GraphOutputChannels can be binded to stream resource. The bind name then is
   * the same as the GraphOutputChannel's name.
   */
  instanceResourceOutputBindingSpecs: ProcessorIOSpec_InstanceResourceOutputBindingSpec[];
}

/** Message for input channel specification. */
export interface ProcessorIOSpec_GraphInputChannelSpec {
  /** The name of the current input channel. */
  name: string;
  /**
   * The data types of the current input channel.
   * When this field has more than 1 value, it means this input channel can be
   * connected to either of these different data types.
   */
  dataType: DataType;
  /**
   * If specified, only those detailed data types can be connected to the
   * processor. For example, jpeg stream for MEDIA, or PredictionResult proto
   * for PROTO type. If unspecified, then any proto is accepted.
   */
  acceptedDataTypeUris: string[];
  /**
   * Whether the current input channel is required by the processor.
   * For example, for a processor with required video input and optional audio
   * input, if video input is missing, the application will be rejected while
   * the audio input can be missing as long as the video input exists.
   */
  required: boolean;
  /**
   * How many input edges can be connected to this input channel. 0 means
   * unlimited.
   */
  maxConnectionAllowed: Long;
}

/** Message for output channel specification. */
export interface ProcessorIOSpec_GraphOutputChannelSpec {
  /** The name of the current output channel. */
  name: string;
  /** The data type of the current output channel. */
  dataType: DataType;
  dataTypeUri: string;
}

/**
 * Message for instance resource channel specification.
 * External resources are virtual nodes which are not expressed in the
 * application graph. Each processor expresses its out-graph spec, so customer
 * is able to override the external source or destinations to the
 */
export interface ProcessorIOSpec_InstanceResourceInputBindingSpec {
  /**
   * The configuration proto that includes the Googleapis resources. I.e.
   * type.googleapis.com/google.cloud.vision.v1.StreamWithAnnotation
   */
  configTypeUri?:
    | string
    | undefined;
  /**
   * The direct type url of Googleapis resource. i.e.
   * type.googleapis.com/google.cloud.vision.v1.Asset
   */
  resourceTypeUri?:
    | string
    | undefined;
  /** Name of the input binding, unique within the processor. */
  name: string;
}

export interface ProcessorIOSpec_InstanceResourceOutputBindingSpec {
  /** Name of the output binding, unique within the processor. */
  name: string;
  /** The resource type uri of the acceptable output resource. */
  resourceTypeUri: string;
  /**
   * Whether the output resource needs to be explicitly set in the instance.
   * If it is false, the processor will automatically generate it if required.
   */
  explicit: boolean;
}

/** Describes the source info for a custom processor. */
export interface CustomProcessorSourceInfo {
  /** The resource name original model hosted in the vertex AI platform. */
  vertexModel?:
    | string
    | undefined;
  /** Artifact for product recognizer. */
  productRecognizerArtifact?:
    | CustomProcessorSourceInfo_ProductRecognizerArtifact
    | undefined;
  /** The original product which holds the custom processor's functionality. */
  sourceType: CustomProcessorSourceInfo_SourceType;
  /**
   * Output only. Additional info related to the imported custom processor.
   * Data is filled in by app platform during the processor creation.
   */
  additionalInfo: { [key: string]: string };
  /**
   * Model schema files which specifies the signature of the model.
   * For VERTEX_CUSTOM models, instances schema is required.
   * If instances schema is not specified during the processor creation,
   * VisionAI Platform will try to get it from Vertex, if it doesn't exist, the
   * creation will fail.
   */
  modelSchema: CustomProcessorSourceInfo_ModelSchema | undefined;
}

/** Source type of the imported custom processor. */
export enum CustomProcessorSourceInfo_SourceType {
  /** SOURCE_TYPE_UNSPECIFIED - Source type unspecified. */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /** VERTEX_AUTOML - Custom processors coming from Vertex AutoML product. */
  VERTEX_AUTOML = 1,
  /** VERTEX_CUSTOM - Custom processors coming from general custom models from Vertex. */
  VERTEX_CUSTOM = 2,
  /** PRODUCT_RECOGNIZER - Source for Product Recognizer. */
  PRODUCT_RECOGNIZER = 3,
  UNRECOGNIZED = -1,
}

export function customProcessorSourceInfo_SourceTypeFromJSON(object: any): CustomProcessorSourceInfo_SourceType {
  switch (object) {
    case 0:
    case "SOURCE_TYPE_UNSPECIFIED":
      return CustomProcessorSourceInfo_SourceType.SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "VERTEX_AUTOML":
      return CustomProcessorSourceInfo_SourceType.VERTEX_AUTOML;
    case 2:
    case "VERTEX_CUSTOM":
      return CustomProcessorSourceInfo_SourceType.VERTEX_CUSTOM;
    case 3:
    case "PRODUCT_RECOGNIZER":
      return CustomProcessorSourceInfo_SourceType.PRODUCT_RECOGNIZER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomProcessorSourceInfo_SourceType.UNRECOGNIZED;
  }
}

export function customProcessorSourceInfo_SourceTypeToJSON(object: CustomProcessorSourceInfo_SourceType): string {
  switch (object) {
    case CustomProcessorSourceInfo_SourceType.SOURCE_TYPE_UNSPECIFIED:
      return "SOURCE_TYPE_UNSPECIFIED";
    case CustomProcessorSourceInfo_SourceType.VERTEX_AUTOML:
      return "VERTEX_AUTOML";
    case CustomProcessorSourceInfo_SourceType.VERTEX_CUSTOM:
      return "VERTEX_CUSTOM";
    case CustomProcessorSourceInfo_SourceType.PRODUCT_RECOGNIZER:
      return "PRODUCT_RECOGNIZER";
    case CustomProcessorSourceInfo_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describes product recognizer artifact. */
export interface CustomProcessorSourceInfo_ProductRecognizerArtifact {
  /**
   * Required. Resource name of RetailProductRecognitionIndex.
   * Format is
   * 'projects/* /locations/* /retailCatalogs/* /retailProductRecognitionIndexes/*'
   */
  retailProductRecognitionIndex: string;
  /**
   * Optional. The resource name of embedding model hosted in Vertex AI
   * Platform.
   */
  vertexModel: string;
}

/**
 * The schema is defined as an OpenAPI 3.0.2 [Schema
 * Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
 */
export interface CustomProcessorSourceInfo_ModelSchema {
  /**
   * Cloud Storage location to a YAML file that defines the format of a single
   * instance used in prediction and explanation requests.
   */
  instancesSchema:
    | GcsSource
    | undefined;
  /**
   * Cloud Storage location to a YAML file that defines the prediction and
   * explanation parameters.
   */
  parametersSchema:
    | GcsSource
    | undefined;
  /**
   * Cloud Storage location to a YAML file that defines the format of a single
   * prediction or explanation.
   */
  predictionsSchema: GcsSource | undefined;
}

export interface CustomProcessorSourceInfo_AdditionalInfoEntry {
  key: string;
  value: string;
}

/** Next ID: 35 */
export interface ProcessorConfig {
  /** Configs of stream input processor. */
  videoStreamInputConfig?:
    | VideoStreamInputConfig
    | undefined;
  /** Config of AI-enabled input devices. */
  aiEnabledDevicesInputConfig?:
    | AIEnabledDevicesInputConfig
    | undefined;
  /** Configs of media warehouse processor. */
  mediaWarehouseConfig?:
    | MediaWarehouseConfig
    | undefined;
  /** Configs of person blur processor. */
  personBlurConfig?:
    | PersonBlurConfig
    | undefined;
  /** Configs of occupancy count processor. */
  occupancyCountConfig?:
    | OccupancyCountConfig
    | undefined;
  /** Configs of Person Vehicle Detection processor. */
  personVehicleDetectionConfig?:
    | PersonVehicleDetectionConfig
    | undefined;
  /** Configs of Vertex AutoML vision processor. */
  vertexAutomlVisionConfig?:
    | VertexAutoMLVisionConfig
    | undefined;
  /** Configs of Vertex AutoML video processor. */
  vertexAutomlVideoConfig?:
    | VertexAutoMLVideoConfig
    | undefined;
  /** Configs of Vertex Custom processor. */
  vertexCustomConfig?:
    | VertexCustomConfig
    | undefined;
  /** Configs of General Object Detection processor. */
  generalObjectDetectionConfig?:
    | GeneralObjectDetectionConfig
    | undefined;
  /** Configs of BigQuery processor. */
  bigQueryConfig?:
    | BigQueryConfig
    | undefined;
  /** Configs of Cloud Storage output processor. */
  gcsOutputConfig?:
    | GcsOutputConfig
    | undefined;
  /** Runtime configs of Product Recognizer processor. */
  productRecognizerConfig?:
    | ProductRecognizerConfig
    | undefined;
  /** Configs of personal_protective_equipment_detection_config */
  personalProtectiveEquipmentDetectionConfig?:
    | PersonalProtectiveEquipmentDetectionConfig
    | undefined;
  /** Runtime configs of Tag Recognizer processor. */
  tagRecognizerConfig?:
    | TagRecognizerConfig
    | undefined;
  /** Runtime configs of UniversalInput processor. */
  universalInputConfig?:
    | UniversalInputConfig
    | undefined;
  /**
   * Experimental configurations. Structured object containing not-yet-stable
   * processor parameters.
   */
  experimentalConfig: { [key: string]: any } | undefined;
}

/**
 * Message describing Vision AI stream with application specific annotations.
 * All the StreamAnnotation object inside this message MUST have unique id.
 */
export interface StreamWithAnnotation {
  /** Vision AI Stream resource name. */
  stream: string;
  /** Annotations that will be applied to the whole application. */
  applicationAnnotations: StreamAnnotation[];
  /**
   * Annotations that will be applied to the specific node of the application.
   * If the same type of the annotations is applied to both application and
   * node, the node annotation will be added in addition to the global
   * application one.
   * For example, if there is one active zone annotation for the whole
   * application and one active zone annotation for the Occupancy Analytic
   * processor, then the Occupancy Analytic processor will have two active zones
   * defined.
   */
  nodeAnnotations: StreamWithAnnotation_NodeAnnotation[];
}

/** Message describing annotations specific to application node. */
export interface StreamWithAnnotation_NodeAnnotation {
  /** The node name of the application graph. */
  node: string;
  /** The node specific stream annotations. */
  annotations: StreamAnnotation[];
}

/**
 * Message describing annotations specific to application node.
 * This message is a duplication of StreamWithAnnotation.NodeAnnotation.
 */
export interface ApplicationNodeAnnotation {
  /** The node name of the application graph. */
  node: string;
  /** The node specific stream annotations. */
  annotations: StreamAnnotation[];
}

/** Message describing general annotation for resources. */
export interface ResourceAnnotations {
  /** Annotations that will be applied to the whole application. */
  applicationAnnotations: StreamAnnotation[];
  /**
   * Annotations that will be applied to the specific node of the application.
   * If the same type of the annotations is applied to both application and
   * node, the node annotation will be added in addition to the global
   * application one.
   * For example, if there is one active zone annotation for the whole
   * application and one active zone annotation for the Occupancy Analytic
   * processor, then the Occupancy Analytic processor will have two active zones
   * defined.
   */
  nodeAnnotations: ApplicationNodeAnnotation[];
}

/**
 * Message describing Video Stream Input Config.
 * This message should only be used as a placeholder for builtin:stream-input
 * processor, actual stream binding should be specified using corresponding
 * API.
 */
export interface VideoStreamInputConfig {
  /** @deprecated */
  streams: string[];
  /** @deprecated */
  streamsWithAnnotation: StreamWithAnnotation[];
}

/** Message describing AI-enabled Devices Input Config. */
export interface AIEnabledDevicesInputConfig {
}

/** Message describing MediaWarehouseConfig. */
export interface MediaWarehouseConfig {
  /**
   * Resource name of the Media Warehouse corpus.
   * Format:
   * projects/${project_id}/locations/${location_id}/corpora/${corpus_id}
   */
  corpus: string;
  /**
   * Deprecated.
   *
   * @deprecated
   */
  region: string;
  /**
   * The duration for which all media assets, associated metadata, and search
   * documents can exist.
   */
  ttl: Duration | undefined;
}

/** Message describing FaceBlurConfig. */
export interface PersonBlurConfig {
  /** Person blur type. */
  personBlurType: PersonBlurConfig_PersonBlurType;
  /** Whether only blur faces other than the whole object in the processor. */
  facesOnly: boolean;
}

/** Type of Person Blur */
export enum PersonBlurConfig_PersonBlurType {
  /** PERSON_BLUR_TYPE_UNSPECIFIED - PersonBlur Type UNSPECIFIED. */
  PERSON_BLUR_TYPE_UNSPECIFIED = 0,
  /** FULL_OCCULUSION - FaceBlur Type full occlusion. */
  FULL_OCCULUSION = 1,
  /** BLUR_FILTER - FaceBlur Type blur filter. */
  BLUR_FILTER = 2,
  UNRECOGNIZED = -1,
}

export function personBlurConfig_PersonBlurTypeFromJSON(object: any): PersonBlurConfig_PersonBlurType {
  switch (object) {
    case 0:
    case "PERSON_BLUR_TYPE_UNSPECIFIED":
      return PersonBlurConfig_PersonBlurType.PERSON_BLUR_TYPE_UNSPECIFIED;
    case 1:
    case "FULL_OCCULUSION":
      return PersonBlurConfig_PersonBlurType.FULL_OCCULUSION;
    case 2:
    case "BLUR_FILTER":
      return PersonBlurConfig_PersonBlurType.BLUR_FILTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersonBlurConfig_PersonBlurType.UNRECOGNIZED;
  }
}

export function personBlurConfig_PersonBlurTypeToJSON(object: PersonBlurConfig_PersonBlurType): string {
  switch (object) {
    case PersonBlurConfig_PersonBlurType.PERSON_BLUR_TYPE_UNSPECIFIED:
      return "PERSON_BLUR_TYPE_UNSPECIFIED";
    case PersonBlurConfig_PersonBlurType.FULL_OCCULUSION:
      return "FULL_OCCULUSION";
    case PersonBlurConfig_PersonBlurType.BLUR_FILTER:
      return "BLUR_FILTER";
    case PersonBlurConfig_PersonBlurType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describing OccupancyCountConfig. */
export interface OccupancyCountConfig {
  /**
   * Whether to count the appearances of people, output counts have 'people' as
   * the key.
   */
  enablePeopleCounting: boolean;
  /**
   * Whether to count the appearances of vehicles, output counts will have
   * 'vehicle' as the key.
   */
  enableVehicleCounting: boolean;
  /**
   * Whether to track each invidual object's loitering time inside the scene or
   * specific zone.
   */
  enableDwellingTimeTracking: boolean;
}

/** Message describing PersonVehicleDetectionConfig. */
export interface PersonVehicleDetectionConfig {
  /**
   * At least one of enable_people_counting and enable_vehicle_counting fields
   * must be set to true.
   * Whether to count the appearances of people, output counts have 'people' as
   * the key.
   */
  enablePeopleCounting: boolean;
  /**
   * Whether to count the appearances of vehicles, output counts will have
   * 'vehicle' as the key.
   */
  enableVehicleCounting: boolean;
}

/** Message describing PersonalProtectiveEquipmentDetectionConfig. */
export interface PersonalProtectiveEquipmentDetectionConfig {
  /** Whether to enable face coverage detection. */
  enableFaceCoverageDetection: boolean;
  /** Whether to enable head coverage detection. */
  enableHeadCoverageDetection: boolean;
  /** Whether to enable hands coverage detection. */
  enableHandsCoverageDetection: boolean;
}

/** Message of configurations for General Object Detection processor. */
export interface GeneralObjectDetectionConfig {
}

/** Message of configurations for BigQuery processor. */
export interface BigQueryConfig {
  /** BigQuery table resource for Vision AI Platform to ingest annotations to. */
  table: string;
  /**
   * Data Schema
   * By default, Vision AI Application will try to write annotations to the
   * target BigQuery table using the following schema:
   *
   * ingestion_time: TIMESTAMP, the ingestion time of the original data.
   *
   * application: STRING, name of the application which produces the annotation.
   *
   * instance: STRING, Id of the instance which produces the annotation.
   *
   * node: STRING, name of the application graph node which produces the
   * annotation.
   *
   * annotation: STRING or JSON, the actual annotation protobuf will be
   * converted to json string with bytes field as 64 encoded string. It can be
   * written to both String or Json type column.
   *
   * To forward annotation data to an existing BigQuery table, customer needs to
   * make sure the compatibility of the schema.
   * The map maps application node name to its corresponding cloud function
   * endpoint to transform the annotations directly to the
   * google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
   * proto_rows should be set). If configured, annotations produced by
   * corresponding application node will sent to the Cloud Function at first
   * before be forwarded to BigQuery.
   *
   * If the default table schema doesn't fit, customer is able to transform the
   * annotation output from Vision AI Application to arbitrary BigQuery table
   * schema with CloudFunction.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of Vision AI annotation.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * AppendRowsRequest stored in the annotations field.
   * * To drop the annotation, simply clear the annotations field in the
   * returned AppPlatformCloudFunctionResponse.
   */
  cloudFunctionMapping: { [key: string]: string };
  /**
   * If true, App Platform will create the BigQuery DataSet and the
   * BigQuery Table with default schema if the specified table doesn't exist.
   * This doesn't work if any cloud function customized schema is specified
   * since the system doesn't know your desired schema.
   * JSON column will be used in the default table created by App Platform.
   */
  createDefaultTableIfNotExists: boolean;
}

export interface BigQueryConfig_CloudFunctionMappingEntry {
  key: string;
  value: string;
}

/** Message of configurations of Vertex AutoML Vision Processors. */
export interface VertexAutoMLVisionConfig {
  /**
   * Only entities with higher score than the threshold will be returned.
   * Value 0.0 means to return all the detected entities.
   */
  confidenceThreshold: number;
  /**
   * At most this many predictions will be returned per output frame.
   * Value 0 means to return all the detected entities.
   */
  maxPredictions: number;
}

/** Message describing VertexAutoMLVideoConfig. */
export interface VertexAutoMLVideoConfig {
  /**
   * Only entities with higher score than the threshold will be returned.
   * Value 0.0 means returns all the detected entities.
   */
  confidenceThreshold: number;
  /** Labels specified in this field won't be returned. */
  blockedLabels: string[];
  /**
   * At most this many predictions will be returned per output frame.
   * Value 0 means to return all the detected entities.
   */
  maxPredictions: number;
  /**
   * Only Bounding Box whose size is larger than this limit will be returned.
   * Object Tracking only.
   * Value 0.0 means to return all the detected entities.
   */
  boundingBoxSizeLimit: number;
}

/** Message describing VertexCustomConfig. */
export interface VertexCustomConfig {
  /**
   * The max prediction frame per second. This attribute sets how fast the
   * operator sends prediction requests to Vertex AI endpoint. Default value is
   * 0, which means there is no max prediction fps limit. The operator sends
   * prediction requests at input fps.
   */
  maxPredictionFps: number;
  /**
   * A description of resources that are dedicated to the DeployedModel, and
   * that need a higher degree of manual configuration.
   */
  dedicatedResources:
    | DedicatedResources
    | undefined;
  /**
   * If not empty, the prediction result will be sent to the specified cloud
   * function for post processing.
   * * The cloud function will receive AppPlatformCloudFunctionRequest where
   * the annotations field will be the json format of proto PredictResponse.
   * * The cloud function should return AppPlatformCloudFunctionResponse with
   * PredictResponse stored in the annotations field.
   * * To drop the prediction output, simply clear the payload field in the
   * returned AppPlatformCloudFunctionResponse.
   */
  postProcessingCloudFunction: string;
  /**
   * If true, the prediction request received by custom model will also contain
   * metadata with the following schema:
   * 'appPlatformMetadata': {
   *       'ingestionTime': DOUBLE; (UNIX timestamp)
   *       'application': STRING;
   *       'instanceId': STRING;
   *       'node': STRING;
   *       'processor': STRING;
   *  }
   */
  attachApplicationMetadata: boolean;
  /**
   * Optional. By setting the configuration_input_topic, processor will
   * subscribe to given topic, only pub/sub topic is supported now. Example
   * channel:
   * //pubsub.googleapis.com/projects/visionai-testing-stable/topics/test-topic
   * message schema should be:
   * message Message {
   * // The ID of the stream that associates with the application instance.
   * string stream_id = 1;
   * // The target fps. By default, the custom processor will *not* send any
   * data to the Vertex Prediction container. Note that once the
   * dynamic_config_input_topic is set, max_prediction_fps will not work and be
   * preceded by the fps set inside the topic.
   * int32 fps = 2;
   * }
   */
  dynamicConfigInputTopic?: string | undefined;
}

/** Message describing GcsOutputConfig. */
export interface GcsOutputConfig {
  /** The Cloud Storage path for Vision AI Platform to ingest annotations to. */
  gcsPath: string;
}

/** Message describing UniversalInputConfig. */
export interface UniversalInputConfig {
}

/** Specification of a single machine. */
export interface MachineSpec {
  /**
   * Immutable. The type of the machine.
   *
   * See the [list of machine types supported for
   * prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
   *
   * See the [list of machine types supported for custom
   * training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
   *
   * For [DeployedModel][] this field is optional, and the default
   * value is `n1-standard-2`. For [BatchPredictionJob][] or as part of
   * [WorkerPoolSpec][] this field is required.
   */
  machineType: string;
  /**
   * Immutable. The type of accelerator(s) that may be attached to the machine
   * as per
   * [accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count].
   */
  acceleratorType: AcceleratorType;
  /** The number of accelerators to attach to the machine. */
  acceleratorCount: number;
}

/**
 * The metric specification that defines the target resource utilization
 * (CPU utilization, accelerator's duty cycle, and so on) for calculating the
 * desired replica count.
 */
export interface AutoscalingMetricSpec {
  /**
   * Required. The resource metric name.
   * Supported metrics:
   *
   * * For Online Prediction:
   * * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
   * * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
   */
  metricName: string;
  /**
   * The target resource utilization in percentage (1% - 100%) for the given
   * metric; once the real usage deviates from the target by a certain
   * percentage, the machine replicas change. The default value is 60
   * (representing 60%) if not provided.
   */
  target: number;
}

/**
 * A description of resources that are dedicated to a DeployedModel, and
 * that need a higher degree of manual configuration.
 */
export interface DedicatedResources {
  /**
   * Required. Immutable. The specification of a single machine used by the
   * prediction.
   */
  machineSpec:
    | MachineSpec
    | undefined;
  /**
   * Required. Immutable. The minimum number of machine replicas this
   * DeployedModel will be always deployed on. This value must be greater than
   * or equal to 1.
   *
   * If traffic against the DeployedModel increases, it may dynamically be
   * deployed onto more replicas, and as traffic decreases, some of these extra
   * replicas may be freed.
   */
  minReplicaCount: number;
  /**
   * Immutable. The maximum number of replicas this DeployedModel may be
   * deployed on when the traffic against it increases. If the requested value
   * is too large, the deployment will error, but if deployment succeeds then
   * the ability to scale the model to that many replicas is guaranteed (barring
   * service outages). If traffic against the DeployedModel increases beyond
   * what its replicas at maximum may handle, a portion of the traffic will be
   * dropped. If this value is not provided, will use
   * [min_replica_count][google.cloud.visionai.v1.DedicatedResources.min_replica_count]
   * as the default value.
   *
   * The value of this field impacts the charge against Vertex CPU and GPU
   * quotas. Specifically, you will be charged for max_replica_count *
   * number of cores in the selected machine type) and (max_replica_count *
   * number of GPUs per replica in the selected machine type).
   */
  maxReplicaCount: number;
  /**
   * Immutable. The metric specifications that overrides a resource
   * utilization metric (CPU utilization, accelerator's duty cycle, and so on)
   * target value (default to 60 if not set). At most one entry is allowed per
   * metric.
   *
   * If
   * [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
   * is above 0, the autoscaling will be based on both CPU utilization and
   * accelerator's duty cycle metrics and scale up when either metrics exceeds
   * its target value while scale down if both metrics are under their target
   * value. The default target value is 60 for both metrics.
   *
   * If
   * [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
   * is 0, the autoscaling will be based on CPU utilization metric only with
   * default target value 60 if not explicitly set.
   *
   * For example, in the case of Online Prediction, if you want to override
   * target CPU utilization to 80, you should set
   * [autoscaling_metric_specs.metric_name][google.cloud.visionai.v1.AutoscalingMetricSpec.metric_name]
   * to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
   * [autoscaling_metric_specs.target][google.cloud.visionai.v1.AutoscalingMetricSpec.target]
   * to `80`.
   */
  autoscalingMetricSpecs: AutoscalingMetricSpec[];
}

/** Message describing ProductRecognizerConfig. */
export interface ProductRecognizerConfig {
  /** The resource name of retail endpoint to use. */
  retailEndpoint: string;
  /**
   * Confidence threshold to filter detection results. If not set, a system
   * default value will be used.
   */
  recognitionConfidenceThreshold: number;
}

/** Message describing TagRecognizerConfig. */
export interface TagRecognizerConfig {
  /**
   * Confidence threshold to filter detection results. If not set, a system
   * default value will be used.
   */
  entityDetectionConfidenceThreshold: number;
  /** Configuration to customize how tags are parsed. */
  tagParsingConfig: TagParsingConfig | undefined;
}

/** Configuration for tag parsing. */
export interface TagParsingConfig {
  /**
   * Each tag entity class may have an optional EntityParsingConfig which is
   * used to help parse the entities of the class.
   */
  entityParsingConfigs: TagParsingConfig_EntityParsingConfig[];
}

/** Configuration for parsing a tag entity class. */
export interface TagParsingConfig_EntityParsingConfig {
  /**
   * Required. The tag entity class name. This should match the class name
   * produced by the tag entity detection model.
   */
  entityClass: string;
  /** Optional. An regular expression hint. */
  regex: string;
  /** Optional. Entity matching strategy. */
  entityMatchingStrategy: TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy;
}

/** Type of entity matching strategy. */
export enum TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy {
  /** ENTITY_MATCHING_STRATEGY_UNSPECIFIED - If unspecified, multi-line matching will be used by default. */
  ENTITY_MATCHING_STRATEGY_UNSPECIFIED = 0,
  /** MULTI_LINE_MATCHING - Matches multiple lines of text. */
  MULTI_LINE_MATCHING = 1,
  /**
   * MAX_OVERLAP_AREA - Matches the line with the maximum overlap area with entity bounding
   * box.
   */
  MAX_OVERLAP_AREA = 2,
  UNRECOGNIZED = -1,
}

export function tagParsingConfig_EntityParsingConfig_EntityMatchingStrategyFromJSON(
  object: any,
): TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy {
  switch (object) {
    case 0:
    case "ENTITY_MATCHING_STRATEGY_UNSPECIFIED":
      return TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.ENTITY_MATCHING_STRATEGY_UNSPECIFIED;
    case 1:
    case "MULTI_LINE_MATCHING":
      return TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.MULTI_LINE_MATCHING;
    case 2:
    case "MAX_OVERLAP_AREA":
      return TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.MAX_OVERLAP_AREA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.UNRECOGNIZED;
  }
}

export function tagParsingConfig_EntityParsingConfig_EntityMatchingStrategyToJSON(
  object: TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy,
): string {
  switch (object) {
    case TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.ENTITY_MATCHING_STRATEGY_UNSPECIFIED:
      return "ENTITY_MATCHING_STRATEGY_UNSPECIFIED";
    case TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.MULTI_LINE_MATCHING:
      return "MULTI_LINE_MATCHING";
    case TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.MAX_OVERLAP_AREA:
      return "MAX_OVERLAP_AREA";
    case TagParsingConfig_EntityParsingConfig_EntityMatchingStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDeleteApplicationInstancesResponse(): DeleteApplicationInstancesResponse {
  return {};
}

export const DeleteApplicationInstancesResponse: MessageFns<DeleteApplicationInstancesResponse> = {
  encode(_: DeleteApplicationInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteApplicationInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteApplicationInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteApplicationInstancesResponse {
    return {};
  },

  toJSON(_: DeleteApplicationInstancesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteApplicationInstancesResponse>): DeleteApplicationInstancesResponse {
    return DeleteApplicationInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteApplicationInstancesResponse>): DeleteApplicationInstancesResponse {
    const message = createBaseDeleteApplicationInstancesResponse();
    return message;
  },
};

function createBaseCreateApplicationInstancesResponse(): CreateApplicationInstancesResponse {
  return {};
}

export const CreateApplicationInstancesResponse: MessageFns<CreateApplicationInstancesResponse> = {
  encode(_: CreateApplicationInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateApplicationInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateApplicationInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateApplicationInstancesResponse {
    return {};
  },

  toJSON(_: CreateApplicationInstancesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateApplicationInstancesResponse>): CreateApplicationInstancesResponse {
    return CreateApplicationInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateApplicationInstancesResponse>): CreateApplicationInstancesResponse {
    const message = createBaseCreateApplicationInstancesResponse();
    return message;
  },
};

function createBaseUpdateApplicationInstancesResponse(): UpdateApplicationInstancesResponse {
  return {};
}

export const UpdateApplicationInstancesResponse: MessageFns<UpdateApplicationInstancesResponse> = {
  encode(_: UpdateApplicationInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateApplicationInstancesResponse {
    return {};
  },

  toJSON(_: UpdateApplicationInstancesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationInstancesResponse>): UpdateApplicationInstancesResponse {
    return UpdateApplicationInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateApplicationInstancesResponse>): UpdateApplicationInstancesResponse {
    const message = createBaseUpdateApplicationInstancesResponse();
    return message;
  },
};

function createBaseCreateApplicationInstancesRequest(): CreateApplicationInstancesRequest {
  return { name: "", applicationInstances: [], requestId: "" };
}

export const CreateApplicationInstancesRequest: MessageFns<CreateApplicationInstancesRequest> = {
  encode(message: CreateApplicationInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.applicationInstances) {
      ApplicationInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateApplicationInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateApplicationInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationInstances.push(ApplicationInstance.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateApplicationInstancesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      applicationInstances: globalThis.Array.isArray(object?.applicationInstances)
        ? object.applicationInstances.map((e: any) => ApplicationInstance.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateApplicationInstancesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.applicationInstances?.length) {
      obj.applicationInstances = message.applicationInstances.map((e) => ApplicationInstance.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateApplicationInstancesRequest>): CreateApplicationInstancesRequest {
    return CreateApplicationInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateApplicationInstancesRequest>): CreateApplicationInstancesRequest {
    const message = createBaseCreateApplicationInstancesRequest();
    message.name = object.name ?? "";
    message.applicationInstances = object.applicationInstances?.map((e) => ApplicationInstance.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteApplicationInstancesRequest(): DeleteApplicationInstancesRequest {
  return { name: "", instanceIds: [], requestId: "" };
}

export const DeleteApplicationInstancesRequest: MessageFns<DeleteApplicationInstancesRequest> = {
  encode(message: DeleteApplicationInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.instanceIds) {
      writer.uint32(18).string(v!);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteApplicationInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteApplicationInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteApplicationInstancesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instanceIds: globalThis.Array.isArray(object?.instanceIds)
        ? object.instanceIds.map((e: any) => globalThis.String(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteApplicationInstancesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instanceIds?.length) {
      obj.instanceIds = message.instanceIds;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteApplicationInstancesRequest>): DeleteApplicationInstancesRequest {
    return DeleteApplicationInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteApplicationInstancesRequest>): DeleteApplicationInstancesRequest {
    const message = createBaseDeleteApplicationInstancesRequest();
    message.name = object.name ?? "";
    message.instanceIds = object.instanceIds?.map((e) => e) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeployApplicationResponse(): DeployApplicationResponse {
  return {};
}

export const DeployApplicationResponse: MessageFns<DeployApplicationResponse> = {
  encode(_: DeployApplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployApplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployApplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeployApplicationResponse {
    return {};
  },

  toJSON(_: DeployApplicationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeployApplicationResponse>): DeployApplicationResponse {
    return DeployApplicationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeployApplicationResponse>): DeployApplicationResponse {
    const message = createBaseDeployApplicationResponse();
    return message;
  },
};

function createBaseUndeployApplicationResponse(): UndeployApplicationResponse {
  return {};
}

export const UndeployApplicationResponse: MessageFns<UndeployApplicationResponse> = {
  encode(_: UndeployApplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeployApplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeployApplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UndeployApplicationResponse {
    return {};
  },

  toJSON(_: UndeployApplicationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UndeployApplicationResponse>): UndeployApplicationResponse {
    return UndeployApplicationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UndeployApplicationResponse>): UndeployApplicationResponse {
    const message = createBaseUndeployApplicationResponse();
    return message;
  },
};

function createBaseRemoveApplicationStreamInputResponse(): RemoveApplicationStreamInputResponse {
  return {};
}

export const RemoveApplicationStreamInputResponse: MessageFns<RemoveApplicationStreamInputResponse> = {
  encode(_: RemoveApplicationStreamInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveApplicationStreamInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveApplicationStreamInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveApplicationStreamInputResponse {
    return {};
  },

  toJSON(_: RemoveApplicationStreamInputResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveApplicationStreamInputResponse>): RemoveApplicationStreamInputResponse {
    return RemoveApplicationStreamInputResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveApplicationStreamInputResponse>): RemoveApplicationStreamInputResponse {
    const message = createBaseRemoveApplicationStreamInputResponse();
    return message;
  },
};

function createBaseAddApplicationStreamInputResponse(): AddApplicationStreamInputResponse {
  return {};
}

export const AddApplicationStreamInputResponse: MessageFns<AddApplicationStreamInputResponse> = {
  encode(_: AddApplicationStreamInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddApplicationStreamInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddApplicationStreamInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddApplicationStreamInputResponse {
    return {};
  },

  toJSON(_: AddApplicationStreamInputResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddApplicationStreamInputResponse>): AddApplicationStreamInputResponse {
    return AddApplicationStreamInputResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddApplicationStreamInputResponse>): AddApplicationStreamInputResponse {
    const message = createBaseAddApplicationStreamInputResponse();
    return message;
  },
};

function createBaseUpdateApplicationStreamInputResponse(): UpdateApplicationStreamInputResponse {
  return {};
}

export const UpdateApplicationStreamInputResponse: MessageFns<UpdateApplicationStreamInputResponse> = {
  encode(_: UpdateApplicationStreamInputResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationStreamInputResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationStreamInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateApplicationStreamInputResponse {
    return {};
  },

  toJSON(_: UpdateApplicationStreamInputResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationStreamInputResponse>): UpdateApplicationStreamInputResponse {
    return UpdateApplicationStreamInputResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateApplicationStreamInputResponse>): UpdateApplicationStreamInputResponse {
    const message = createBaseUpdateApplicationStreamInputResponse();
    return message;
  },
};

function createBaseListApplicationsRequest(): ListApplicationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListApplicationsRequest: MessageFns<ListApplicationsRequest> = {
  encode(message: ListApplicationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListApplicationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListApplicationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListApplicationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListApplicationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListApplicationsRequest>): ListApplicationsRequest {
    return ListApplicationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListApplicationsRequest>): ListApplicationsRequest {
    const message = createBaseListApplicationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListApplicationsResponse(): ListApplicationsResponse {
  return { applications: [], nextPageToken: "", unreachable: [] };
}

export const ListApplicationsResponse: MessageFns<ListApplicationsResponse> = {
  encode(message: ListApplicationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.applications) {
      Application.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListApplicationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListApplicationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.applications.push(Application.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListApplicationsResponse {
    return {
      applications: globalThis.Array.isArray(object?.applications)
        ? object.applications.map((e: any) => Application.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListApplicationsResponse): unknown {
    const obj: any = {};
    if (message.applications?.length) {
      obj.applications = message.applications.map((e) => Application.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListApplicationsResponse>): ListApplicationsResponse {
    return ListApplicationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListApplicationsResponse>): ListApplicationsResponse {
    const message = createBaseListApplicationsResponse();
    message.applications = object.applications?.map((e) => Application.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetApplicationRequest(): GetApplicationRequest {
  return { name: "" };
}

export const GetApplicationRequest: MessageFns<GetApplicationRequest> = {
  encode(message: GetApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetApplicationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetApplicationRequest>): GetApplicationRequest {
    return GetApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetApplicationRequest>): GetApplicationRequest {
    const message = createBaseGetApplicationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateApplicationRequest(): CreateApplicationRequest {
  return { parent: "", applicationId: "", application: undefined, requestId: "" };
}

export const CreateApplicationRequest: MessageFns<CreateApplicationRequest> = {
  encode(message: CreateApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.applicationId !== "") {
      writer.uint32(18).string(message.applicationId);
    }
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateApplicationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      applicationId: isSet(object.applicationId) ? globalThis.String(object.applicationId) : "",
      application: isSet(object.application) ? Application.fromJSON(object.application) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateApplicationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.applicationId !== "") {
      obj.applicationId = message.applicationId;
    }
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateApplicationRequest>): CreateApplicationRequest {
    return CreateApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateApplicationRequest>): CreateApplicationRequest {
    const message = createBaseCreateApplicationRequest();
    message.parent = object.parent ?? "";
    message.applicationId = object.applicationId ?? "";
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateApplicationRequest(): UpdateApplicationRequest {
  return { updateMask: undefined, application: undefined, requestId: "" };
}

export const UpdateApplicationRequest: MessageFns<UpdateApplicationRequest> = {
  encode(message: UpdateApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      application: isSet(object.application) ? Application.fromJSON(object.application) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateApplicationRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationRequest>): UpdateApplicationRequest {
    return UpdateApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateApplicationRequest>): UpdateApplicationRequest {
    const message = createBaseUpdateApplicationRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteApplicationRequest(): DeleteApplicationRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteApplicationRequest: MessageFns<DeleteApplicationRequest> = {
  encode(message: DeleteApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteApplicationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteApplicationRequest>): DeleteApplicationRequest {
    return DeleteApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteApplicationRequest>): DeleteApplicationRequest {
    const message = createBaseDeleteApplicationRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseDeployApplicationRequest(): DeployApplicationRequest {
  return { name: "", validateOnly: false, requestId: "", enableMonitoring: false };
}

export const DeployApplicationRequest: MessageFns<DeployApplicationRequest> = {
  encode(message: DeployApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.enableMonitoring !== false) {
      writer.uint32(32).bool(message.enableMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableMonitoring = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployApplicationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      enableMonitoring: isSet(object.enableMonitoring) ? globalThis.Boolean(object.enableMonitoring) : false,
    };
  },

  toJSON(message: DeployApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.enableMonitoring !== false) {
      obj.enableMonitoring = message.enableMonitoring;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployApplicationRequest>): DeployApplicationRequest {
    return DeployApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployApplicationRequest>): DeployApplicationRequest {
    const message = createBaseDeployApplicationRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.requestId = object.requestId ?? "";
    message.enableMonitoring = object.enableMonitoring ?? false;
    return message;
  },
};

function createBaseUndeployApplicationRequest(): UndeployApplicationRequest {
  return { name: "", requestId: "" };
}

export const UndeployApplicationRequest: MessageFns<UndeployApplicationRequest> = {
  encode(message: UndeployApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeployApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeployApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeployApplicationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UndeployApplicationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeployApplicationRequest>): UndeployApplicationRequest {
    return UndeployApplicationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeployApplicationRequest>): UndeployApplicationRequest {
    const message = createBaseUndeployApplicationRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseApplicationStreamInput(): ApplicationStreamInput {
  return { streamWithAnnotation: undefined };
}

export const ApplicationStreamInput: MessageFns<ApplicationStreamInput> = {
  encode(message: ApplicationStreamInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamWithAnnotation !== undefined) {
      StreamWithAnnotation.encode(message.streamWithAnnotation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationStreamInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationStreamInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamWithAnnotation = StreamWithAnnotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationStreamInput {
    return {
      streamWithAnnotation: isSet(object.streamWithAnnotation)
        ? StreamWithAnnotation.fromJSON(object.streamWithAnnotation)
        : undefined,
    };
  },

  toJSON(message: ApplicationStreamInput): unknown {
    const obj: any = {};
    if (message.streamWithAnnotation !== undefined) {
      obj.streamWithAnnotation = StreamWithAnnotation.toJSON(message.streamWithAnnotation);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationStreamInput>): ApplicationStreamInput {
    return ApplicationStreamInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationStreamInput>): ApplicationStreamInput {
    const message = createBaseApplicationStreamInput();
    message.streamWithAnnotation = (object.streamWithAnnotation !== undefined && object.streamWithAnnotation !== null)
      ? StreamWithAnnotation.fromPartial(object.streamWithAnnotation)
      : undefined;
    return message;
  },
};

function createBaseAddApplicationStreamInputRequest(): AddApplicationStreamInputRequest {
  return { name: "", applicationStreamInputs: [], requestId: "" };
}

export const AddApplicationStreamInputRequest: MessageFns<AddApplicationStreamInputRequest> = {
  encode(message: AddApplicationStreamInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.applicationStreamInputs) {
      ApplicationStreamInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddApplicationStreamInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddApplicationStreamInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationStreamInputs.push(ApplicationStreamInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddApplicationStreamInputRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      applicationStreamInputs: globalThis.Array.isArray(object?.applicationStreamInputs)
        ? object.applicationStreamInputs.map((e: any) => ApplicationStreamInput.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: AddApplicationStreamInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.applicationStreamInputs?.length) {
      obj.applicationStreamInputs = message.applicationStreamInputs.map((e) => ApplicationStreamInput.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<AddApplicationStreamInputRequest>): AddApplicationStreamInputRequest {
    return AddApplicationStreamInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddApplicationStreamInputRequest>): AddApplicationStreamInputRequest {
    const message = createBaseAddApplicationStreamInputRequest();
    message.name = object.name ?? "";
    message.applicationStreamInputs =
      object.applicationStreamInputs?.map((e) => ApplicationStreamInput.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateApplicationStreamInputRequest(): UpdateApplicationStreamInputRequest {
  return { name: "", applicationStreamInputs: [], requestId: "", allowMissing: false };
}

export const UpdateApplicationStreamInputRequest: MessageFns<UpdateApplicationStreamInputRequest> = {
  encode(message: UpdateApplicationStreamInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.applicationStreamInputs) {
      ApplicationStreamInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationStreamInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationStreamInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationStreamInputs.push(ApplicationStreamInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationStreamInputRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      applicationStreamInputs: globalThis.Array.isArray(object?.applicationStreamInputs)
        ? object.applicationStreamInputs.map((e: any) => ApplicationStreamInput.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateApplicationStreamInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.applicationStreamInputs?.length) {
      obj.applicationStreamInputs = message.applicationStreamInputs.map((e) => ApplicationStreamInput.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationStreamInputRequest>): UpdateApplicationStreamInputRequest {
    return UpdateApplicationStreamInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateApplicationStreamInputRequest>): UpdateApplicationStreamInputRequest {
    const message = createBaseUpdateApplicationStreamInputRequest();
    message.name = object.name ?? "";
    message.applicationStreamInputs =
      object.applicationStreamInputs?.map((e) => ApplicationStreamInput.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseRemoveApplicationStreamInputRequest(): RemoveApplicationStreamInputRequest {
  return { name: "", targetStreamInputs: [], requestId: "" };
}

export const RemoveApplicationStreamInputRequest: MessageFns<RemoveApplicationStreamInputRequest> = {
  encode(message: RemoveApplicationStreamInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.targetStreamInputs) {
      RemoveApplicationStreamInputRequest_TargetStreamInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveApplicationStreamInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveApplicationStreamInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetStreamInputs.push(
            RemoveApplicationStreamInputRequest_TargetStreamInput.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveApplicationStreamInputRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetStreamInputs: globalThis.Array.isArray(object?.targetStreamInputs)
        ? object.targetStreamInputs.map((e: any) => RemoveApplicationStreamInputRequest_TargetStreamInput.fromJSON(e))
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RemoveApplicationStreamInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.targetStreamInputs?.length) {
      obj.targetStreamInputs = message.targetStreamInputs.map((e) =>
        RemoveApplicationStreamInputRequest_TargetStreamInput.toJSON(e)
      );
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveApplicationStreamInputRequest>): RemoveApplicationStreamInputRequest {
    return RemoveApplicationStreamInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveApplicationStreamInputRequest>): RemoveApplicationStreamInputRequest {
    const message = createBaseRemoveApplicationStreamInputRequest();
    message.name = object.name ?? "";
    message.targetStreamInputs =
      object.targetStreamInputs?.map((e) => RemoveApplicationStreamInputRequest_TargetStreamInput.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRemoveApplicationStreamInputRequest_TargetStreamInput(): RemoveApplicationStreamInputRequest_TargetStreamInput {
  return { stream: "" };
}

export const RemoveApplicationStreamInputRequest_TargetStreamInput: MessageFns<
  RemoveApplicationStreamInputRequest_TargetStreamInput
> = {
  encode(
    message: RemoveApplicationStreamInputRequest_TargetStreamInput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stream !== "") {
      writer.uint32(10).string(message.stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveApplicationStreamInputRequest_TargetStreamInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveApplicationStreamInputRequest_TargetStreamInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveApplicationStreamInputRequest_TargetStreamInput {
    return { stream: isSet(object.stream) ? globalThis.String(object.stream) : "" };
  },

  toJSON(message: RemoveApplicationStreamInputRequest_TargetStreamInput): unknown {
    const obj: any = {};
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RemoveApplicationStreamInputRequest_TargetStreamInput>,
  ): RemoveApplicationStreamInputRequest_TargetStreamInput {
    return RemoveApplicationStreamInputRequest_TargetStreamInput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RemoveApplicationStreamInputRequest_TargetStreamInput>,
  ): RemoveApplicationStreamInputRequest_TargetStreamInput {
    const message = createBaseRemoveApplicationStreamInputRequest_TargetStreamInput();
    message.stream = object.stream ?? "";
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDraftsRequest(): ListDraftsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDraftsRequest: MessageFns<ListDraftsRequest> = {
  encode(message: ListDraftsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDraftsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDraftsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDraftsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDraftsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDraftsRequest>): ListDraftsRequest {
    return ListDraftsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDraftsRequest>): ListDraftsRequest {
    const message = createBaseListDraftsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListDraftsResponse(): ListDraftsResponse {
  return { drafts: [], nextPageToken: "", unreachable: [] };
}

export const ListDraftsResponse: MessageFns<ListDraftsResponse> = {
  encode(message: ListDraftsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.drafts) {
      Draft.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDraftsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDraftsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.drafts.push(Draft.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDraftsResponse {
    return {
      drafts: globalThis.Array.isArray(object?.drafts) ? object.drafts.map((e: any) => Draft.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDraftsResponse): unknown {
    const obj: any = {};
    if (message.drafts?.length) {
      obj.drafts = message.drafts.map((e) => Draft.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDraftsResponse>): ListDraftsResponse {
    return ListDraftsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDraftsResponse>): ListDraftsResponse {
    const message = createBaseListDraftsResponse();
    message.drafts = object.drafts?.map((e) => Draft.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDraftRequest(): GetDraftRequest {
  return { name: "" };
}

export const GetDraftRequest: MessageFns<GetDraftRequest> = {
  encode(message: GetDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDraftRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDraftRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDraftRequest>): GetDraftRequest {
    return GetDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDraftRequest>): GetDraftRequest {
    const message = createBaseGetDraftRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDraftRequest(): CreateDraftRequest {
  return { parent: "", draftId: "", draft: undefined, requestId: "" };
}

export const CreateDraftRequest: MessageFns<CreateDraftRequest> = {
  encode(message: CreateDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.draftId !== "") {
      writer.uint32(18).string(message.draftId);
    }
    if (message.draft !== undefined) {
      Draft.encode(message.draft, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.draftId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.draft = Draft.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDraftRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      draftId: isSet(object.draftId) ? globalThis.String(object.draftId) : "",
      draft: isSet(object.draft) ? Draft.fromJSON(object.draft) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateDraftRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.draftId !== "") {
      obj.draftId = message.draftId;
    }
    if (message.draft !== undefined) {
      obj.draft = Draft.toJSON(message.draft);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDraftRequest>): CreateDraftRequest {
    return CreateDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDraftRequest>): CreateDraftRequest {
    const message = createBaseCreateDraftRequest();
    message.parent = object.parent ?? "";
    message.draftId = object.draftId ?? "";
    message.draft = (object.draft !== undefined && object.draft !== null) ? Draft.fromPartial(object.draft) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateDraftRequest(): UpdateDraftRequest {
  return { updateMask: undefined, draft: undefined, requestId: "", allowMissing: false };
}

export const UpdateDraftRequest: MessageFns<UpdateDraftRequest> = {
  encode(message: UpdateDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.draft !== undefined) {
      Draft.encode(message.draft, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.draft = Draft.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDraftRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      draft: isSet(object.draft) ? Draft.fromJSON(object.draft) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateDraftRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.draft !== undefined) {
      obj.draft = Draft.toJSON(message.draft);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDraftRequest>): UpdateDraftRequest {
    return UpdateDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDraftRequest>): UpdateDraftRequest {
    const message = createBaseUpdateDraftRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.draft = (object.draft !== undefined && object.draft !== null) ? Draft.fromPartial(object.draft) : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseUpdateApplicationInstancesRequest(): UpdateApplicationInstancesRequest {
  return { name: "", applicationInstances: [], requestId: "", allowMissing: false };
}

export const UpdateApplicationInstancesRequest: MessageFns<UpdateApplicationInstancesRequest> = {
  encode(message: UpdateApplicationInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.applicationInstances) {
      UpdateApplicationInstancesRequest_UpdateApplicationInstance.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationInstances.push(
            UpdateApplicationInstancesRequest_UpdateApplicationInstance.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationInstancesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      applicationInstances: globalThis.Array.isArray(object?.applicationInstances)
        ? object.applicationInstances.map((e: any) =>
          UpdateApplicationInstancesRequest_UpdateApplicationInstance.fromJSON(e)
        )
        : [],
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateApplicationInstancesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.applicationInstances?.length) {
      obj.applicationInstances = message.applicationInstances.map((e) =>
        UpdateApplicationInstancesRequest_UpdateApplicationInstance.toJSON(e)
      );
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateApplicationInstancesRequest>): UpdateApplicationInstancesRequest {
    return UpdateApplicationInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateApplicationInstancesRequest>): UpdateApplicationInstancesRequest {
    const message = createBaseUpdateApplicationInstancesRequest();
    message.name = object.name ?? "";
    message.applicationInstances =
      object.applicationInstances?.map((e) =>
        UpdateApplicationInstancesRequest_UpdateApplicationInstance.fromPartial(e)
      ) || [];
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseUpdateApplicationInstancesRequest_UpdateApplicationInstance(): UpdateApplicationInstancesRequest_UpdateApplicationInstance {
  return { updateMask: undefined, instance: undefined, instanceId: "" };
}

export const UpdateApplicationInstancesRequest_UpdateApplicationInstance: MessageFns<
  UpdateApplicationInstancesRequest_UpdateApplicationInstance
> = {
  encode(
    message: UpdateApplicationInstancesRequest_UpdateApplicationInstance,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    if (message.instanceId !== "") {
      writer.uint32(26).string(message.instanceId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateApplicationInstancesRequest_UpdateApplicationInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationInstancesRequest_UpdateApplicationInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationInstancesRequest_UpdateApplicationInstance {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
    };
  },

  toJSON(message: UpdateApplicationInstancesRequest_UpdateApplicationInstance): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<UpdateApplicationInstancesRequest_UpdateApplicationInstance>,
  ): UpdateApplicationInstancesRequest_UpdateApplicationInstance {
    return UpdateApplicationInstancesRequest_UpdateApplicationInstance.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UpdateApplicationInstancesRequest_UpdateApplicationInstance>,
  ): UpdateApplicationInstancesRequest_UpdateApplicationInstance {
    const message = createBaseUpdateApplicationInstancesRequest_UpdateApplicationInstance();
    message.updateMask = object.updateMask ?? undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.instanceId = object.instanceId ?? "";
    return message;
  },
};

function createBaseDeleteDraftRequest(): DeleteDraftRequest {
  return { name: "", requestId: "" };
}

export const DeleteDraftRequest: MessageFns<DeleteDraftRequest> = {
  encode(message: DeleteDraftRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDraftRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDraftRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDraftRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteDraftRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDraftRequest>): DeleteDraftRequest {
    return DeleteDraftRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDraftRequest>): DeleteDraftRequest {
    const message = createBaseDeleteDraftRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListProcessorsRequest(): ListProcessorsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListProcessorsRequest: MessageFns<ListProcessorsRequest> = {
  encode(message: ListProcessorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProcessorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProcessorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProcessorsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListProcessorsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProcessorsRequest>): ListProcessorsRequest {
    return ListProcessorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProcessorsRequest>): ListProcessorsRequest {
    const message = createBaseListProcessorsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListProcessorsResponse(): ListProcessorsResponse {
  return { processors: [], nextPageToken: "", unreachable: [] };
}

export const ListProcessorsResponse: MessageFns<ListProcessorsResponse> = {
  encode(message: ListProcessorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processors) {
      Processor.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProcessorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProcessorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.processors.push(Processor.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProcessorsResponse {
    return {
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => Processor.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListProcessorsResponse): unknown {
    const obj: any = {};
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => Processor.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProcessorsResponse>): ListProcessorsResponse {
    return ListProcessorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProcessorsResponse>): ListProcessorsResponse {
    const message = createBaseListProcessorsResponse();
    message.processors = object.processors?.map((e) => Processor.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListPrebuiltProcessorsRequest(): ListPrebuiltProcessorsRequest {
  return { parent: "" };
}

export const ListPrebuiltProcessorsRequest: MessageFns<ListPrebuiltProcessorsRequest> = {
  encode(message: ListPrebuiltProcessorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrebuiltProcessorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrebuiltProcessorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrebuiltProcessorsRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: ListPrebuiltProcessorsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrebuiltProcessorsRequest>): ListPrebuiltProcessorsRequest {
    return ListPrebuiltProcessorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrebuiltProcessorsRequest>): ListPrebuiltProcessorsRequest {
    const message = createBaseListPrebuiltProcessorsRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseListPrebuiltProcessorsResponse(): ListPrebuiltProcessorsResponse {
  return { processors: [] };
}

export const ListPrebuiltProcessorsResponse: MessageFns<ListPrebuiltProcessorsResponse> = {
  encode(message: ListPrebuiltProcessorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processors) {
      Processor.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrebuiltProcessorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrebuiltProcessorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.processors.push(Processor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrebuiltProcessorsResponse {
    return {
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => Processor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPrebuiltProcessorsResponse): unknown {
    const obj: any = {};
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => Processor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrebuiltProcessorsResponse>): ListPrebuiltProcessorsResponse {
    return ListPrebuiltProcessorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrebuiltProcessorsResponse>): ListPrebuiltProcessorsResponse {
    const message = createBaseListPrebuiltProcessorsResponse();
    message.processors = object.processors?.map((e) => Processor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProcessorRequest(): GetProcessorRequest {
  return { name: "" };
}

export const GetProcessorRequest: MessageFns<GetProcessorRequest> = {
  encode(message: GetProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProcessorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProcessorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetProcessorRequest>): GetProcessorRequest {
    return GetProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProcessorRequest>): GetProcessorRequest {
    const message = createBaseGetProcessorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateProcessorRequest(): CreateProcessorRequest {
  return { parent: "", processorId: "", processor: undefined, requestId: "" };
}

export const CreateProcessorRequest: MessageFns<CreateProcessorRequest> = {
  encode(message: CreateProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.processorId !== "") {
      writer.uint32(18).string(message.processorId);
    }
    if (message.processor !== undefined) {
      Processor.encode(message.processor, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.processor = Processor.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProcessorRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      processorId: isSet(object.processorId) ? globalThis.String(object.processorId) : "",
      processor: isSet(object.processor) ? Processor.fromJSON(object.processor) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateProcessorRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.processorId !== "") {
      obj.processorId = message.processorId;
    }
    if (message.processor !== undefined) {
      obj.processor = Processor.toJSON(message.processor);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProcessorRequest>): CreateProcessorRequest {
    return CreateProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProcessorRequest>): CreateProcessorRequest {
    const message = createBaseCreateProcessorRequest();
    message.parent = object.parent ?? "";
    message.processorId = object.processorId ?? "";
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? Processor.fromPartial(object.processor)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateProcessorRequest(): UpdateProcessorRequest {
  return { updateMask: undefined, processor: undefined, requestId: "" };
}

export const UpdateProcessorRequest: MessageFns<UpdateProcessorRequest> = {
  encode(message: UpdateProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.processor !== undefined) {
      Processor.encode(message.processor, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processor = Processor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProcessorRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      processor: isSet(object.processor) ? Processor.fromJSON(object.processor) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateProcessorRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.processor !== undefined) {
      obj.processor = Processor.toJSON(message.processor);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateProcessorRequest>): UpdateProcessorRequest {
    return UpdateProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateProcessorRequest>): UpdateProcessorRequest {
    const message = createBaseUpdateProcessorRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? Processor.fromPartial(object.processor)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteProcessorRequest(): DeleteProcessorRequest {
  return { name: "", requestId: "" };
}

export const DeleteProcessorRequest: MessageFns<DeleteProcessorRequest> = {
  encode(message: DeleteProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProcessorRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteProcessorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteProcessorRequest>): DeleteProcessorRequest {
    return DeleteProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteProcessorRequest>): DeleteProcessorRequest {
    const message = createBaseDeleteProcessorRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseApplication(): Application {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    applicationConfigs: undefined,
    runtimeInfo: undefined,
    state: 0,
    billingMode: 0,
  };
}

export const Application: MessageFns<Application> = {
  encode(message: Application, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Application_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.applicationConfigs !== undefined) {
      ApplicationConfigs.encode(message.applicationConfigs, writer.uint32(58).fork()).join();
    }
    if (message.runtimeInfo !== undefined) {
      Application_ApplicationRuntimeInfo.encode(message.runtimeInfo, writer.uint32(66).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.billingMode !== 0) {
      writer.uint32(96).int32(message.billingMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Application_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.applicationConfigs = ApplicationConfigs.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.runtimeInfo = Application_ApplicationRuntimeInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.billingMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      applicationConfigs: isSet(object.applicationConfigs)
        ? ApplicationConfigs.fromJSON(object.applicationConfigs)
        : undefined,
      runtimeInfo: isSet(object.runtimeInfo)
        ? Application_ApplicationRuntimeInfo.fromJSON(object.runtimeInfo)
        : undefined,
      state: isSet(object.state) ? application_StateFromJSON(object.state) : 0,
      billingMode: isSet(object.billingMode) ? application_BillingModeFromJSON(object.billingMode) : 0,
    };
  },

  toJSON(message: Application): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.applicationConfigs !== undefined) {
      obj.applicationConfigs = ApplicationConfigs.toJSON(message.applicationConfigs);
    }
    if (message.runtimeInfo !== undefined) {
      obj.runtimeInfo = Application_ApplicationRuntimeInfo.toJSON(message.runtimeInfo);
    }
    if (message.state !== 0) {
      obj.state = application_StateToJSON(message.state);
    }
    if (message.billingMode !== 0) {
      obj.billingMode = application_BillingModeToJSON(message.billingMode);
    }
    return obj;
  },

  create(base?: DeepPartial<Application>): Application {
    return Application.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Application>): Application {
    const message = createBaseApplication();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.applicationConfigs = (object.applicationConfigs !== undefined && object.applicationConfigs !== null)
      ? ApplicationConfigs.fromPartial(object.applicationConfigs)
      : undefined;
    message.runtimeInfo = (object.runtimeInfo !== undefined && object.runtimeInfo !== null)
      ? Application_ApplicationRuntimeInfo.fromPartial(object.runtimeInfo)
      : undefined;
    message.state = object.state ?? 0;
    message.billingMode = object.billingMode ?? 0;
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo(): Application_ApplicationRuntimeInfo {
  return { deployTime: undefined, globalOutputResources: [], monitoringConfig: undefined };
}

export const Application_ApplicationRuntimeInfo: MessageFns<Application_ApplicationRuntimeInfo> = {
  encode(message: Application_ApplicationRuntimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deployTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.globalOutputResources) {
      Application_ApplicationRuntimeInfo_GlobalOutputResource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.monitoringConfig !== undefined) {
      Application_ApplicationRuntimeInfo_MonitoringConfig.encode(message.monitoringConfig, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.globalOutputResources.push(
            Application_ApplicationRuntimeInfo_GlobalOutputResource.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monitoringConfig = Application_ApplicationRuntimeInfo_MonitoringConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo {
    return {
      deployTime: isSet(object.deployTime) ? fromJsonTimestamp(object.deployTime) : undefined,
      globalOutputResources: globalThis.Array.isArray(object?.globalOutputResources)
        ? object.globalOutputResources.map((e: any) =>
          Application_ApplicationRuntimeInfo_GlobalOutputResource.fromJSON(e)
        )
        : [],
      monitoringConfig: isSet(object.monitoringConfig)
        ? Application_ApplicationRuntimeInfo_MonitoringConfig.fromJSON(object.monitoringConfig)
        : undefined,
    };
  },

  toJSON(message: Application_ApplicationRuntimeInfo): unknown {
    const obj: any = {};
    if (message.deployTime !== undefined) {
      obj.deployTime = message.deployTime.toISOString();
    }
    if (message.globalOutputResources?.length) {
      obj.globalOutputResources = message.globalOutputResources.map((e) =>
        Application_ApplicationRuntimeInfo_GlobalOutputResource.toJSON(e)
      );
    }
    if (message.monitoringConfig !== undefined) {
      obj.monitoringConfig = Application_ApplicationRuntimeInfo_MonitoringConfig.toJSON(message.monitoringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Application_ApplicationRuntimeInfo>): Application_ApplicationRuntimeInfo {
    return Application_ApplicationRuntimeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Application_ApplicationRuntimeInfo>): Application_ApplicationRuntimeInfo {
    const message = createBaseApplication_ApplicationRuntimeInfo();
    message.deployTime = object.deployTime ?? undefined;
    message.globalOutputResources =
      object.globalOutputResources?.map((e) =>
        Application_ApplicationRuntimeInfo_GlobalOutputResource.fromPartial(e)
      ) || [];
    message.monitoringConfig = (object.monitoringConfig !== undefined && object.monitoringConfig !== null)
      ? Application_ApplicationRuntimeInfo_MonitoringConfig.fromPartial(object.monitoringConfig)
      : undefined;
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource(): Application_ApplicationRuntimeInfo_GlobalOutputResource {
  return { outputResource: "", producerNode: "", key: "" };
}

export const Application_ApplicationRuntimeInfo_GlobalOutputResource: MessageFns<
  Application_ApplicationRuntimeInfo_GlobalOutputResource
> = {
  encode(
    message: Application_ApplicationRuntimeInfo_GlobalOutputResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.outputResource !== "") {
      writer.uint32(10).string(message.outputResource);
    }
    if (message.producerNode !== "") {
      writer.uint32(18).string(message.producerNode);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputResource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producerNode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    return {
      outputResource: isSet(object.outputResource) ? globalThis.String(object.outputResource) : "",
      producerNode: isSet(object.producerNode) ? globalThis.String(object.producerNode) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: Application_ApplicationRuntimeInfo_GlobalOutputResource): unknown {
    const obj: any = {};
    if (message.outputResource !== "") {
      obj.outputResource = message.outputResource;
    }
    if (message.producerNode !== "") {
      obj.producerNode = message.producerNode;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Application_ApplicationRuntimeInfo_GlobalOutputResource>,
  ): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    return Application_ApplicationRuntimeInfo_GlobalOutputResource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Application_ApplicationRuntimeInfo_GlobalOutputResource>,
  ): Application_ApplicationRuntimeInfo_GlobalOutputResource {
    const message = createBaseApplication_ApplicationRuntimeInfo_GlobalOutputResource();
    message.outputResource = object.outputResource ?? "";
    message.producerNode = object.producerNode ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig(): Application_ApplicationRuntimeInfo_MonitoringConfig {
  return { enabled: false };
}

export const Application_ApplicationRuntimeInfo_MonitoringConfig: MessageFns<
  Application_ApplicationRuntimeInfo_MonitoringConfig
> = {
  encode(
    message: Application_ApplicationRuntimeInfo_MonitoringConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_ApplicationRuntimeInfo_MonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_ApplicationRuntimeInfo_MonitoringConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: Application_ApplicationRuntimeInfo_MonitoringConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Application_ApplicationRuntimeInfo_MonitoringConfig>,
  ): Application_ApplicationRuntimeInfo_MonitoringConfig {
    return Application_ApplicationRuntimeInfo_MonitoringConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Application_ApplicationRuntimeInfo_MonitoringConfig>,
  ): Application_ApplicationRuntimeInfo_MonitoringConfig {
    const message = createBaseApplication_ApplicationRuntimeInfo_MonitoringConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseApplication_LabelsEntry(): Application_LabelsEntry {
  return { key: "", value: "" };
}

export const Application_LabelsEntry: MessageFns<Application_LabelsEntry> = {
  encode(message: Application_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Application_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplication_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Application_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Application_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Application_LabelsEntry>): Application_LabelsEntry {
    return Application_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Application_LabelsEntry>): Application_LabelsEntry {
    const message = createBaseApplication_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApplicationConfigs(): ApplicationConfigs {
  return { nodes: [], eventDeliveryConfig: undefined };
}

export const ApplicationConfigs: MessageFns<ApplicationConfigs> = {
  encode(message: ApplicationConfigs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.eventDeliveryConfig !== undefined) {
      ApplicationConfigs_EventDeliveryConfig.encode(message.eventDeliveryConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationConfigs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationConfigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventDeliveryConfig = ApplicationConfigs_EventDeliveryConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationConfigs {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      eventDeliveryConfig: isSet(object.eventDeliveryConfig)
        ? ApplicationConfigs_EventDeliveryConfig.fromJSON(object.eventDeliveryConfig)
        : undefined,
    };
  },

  toJSON(message: ApplicationConfigs): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.eventDeliveryConfig !== undefined) {
      obj.eventDeliveryConfig = ApplicationConfigs_EventDeliveryConfig.toJSON(message.eventDeliveryConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationConfigs>): ApplicationConfigs {
    return ApplicationConfigs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationConfigs>): ApplicationConfigs {
    const message = createBaseApplicationConfigs();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.eventDeliveryConfig = (object.eventDeliveryConfig !== undefined && object.eventDeliveryConfig !== null)
      ? ApplicationConfigs_EventDeliveryConfig.fromPartial(object.eventDeliveryConfig)
      : undefined;
    return message;
  },
};

function createBaseApplicationConfigs_EventDeliveryConfig(): ApplicationConfigs_EventDeliveryConfig {
  return { channel: "", minimalDeliveryInterval: undefined };
}

export const ApplicationConfigs_EventDeliveryConfig: MessageFns<ApplicationConfigs_EventDeliveryConfig> = {
  encode(message: ApplicationConfigs_EventDeliveryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    if (message.minimalDeliveryInterval !== undefined) {
      Duration.encode(message.minimalDeliveryInterval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationConfigs_EventDeliveryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationConfigs_EventDeliveryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minimalDeliveryInterval = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationConfigs_EventDeliveryConfig {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      minimalDeliveryInterval: isSet(object.minimalDeliveryInterval)
        ? Duration.fromJSON(object.minimalDeliveryInterval)
        : undefined,
    };
  },

  toJSON(message: ApplicationConfigs_EventDeliveryConfig): unknown {
    const obj: any = {};
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.minimalDeliveryInterval !== undefined) {
      obj.minimalDeliveryInterval = Duration.toJSON(message.minimalDeliveryInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationConfigs_EventDeliveryConfig>): ApplicationConfigs_EventDeliveryConfig {
    return ApplicationConfigs_EventDeliveryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationConfigs_EventDeliveryConfig>): ApplicationConfigs_EventDeliveryConfig {
    const message = createBaseApplicationConfigs_EventDeliveryConfig();
    message.channel = object.channel ?? "";
    message.minimalDeliveryInterval =
      (object.minimalDeliveryInterval !== undefined && object.minimalDeliveryInterval !== null)
        ? Duration.fromPartial(object.minimalDeliveryInterval)
        : undefined;
    return message;
  },
};

function createBaseNode(): Node {
  return {
    outputAllOutputChannelsToStream: undefined,
    name: "",
    displayName: "",
    nodeConfig: undefined,
    processor: "",
    parents: [],
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputAllOutputChannelsToStream !== undefined) {
      writer.uint32(48).bool(message.outputAllOutputChannelsToStream);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.nodeConfig !== undefined) {
      ProcessorConfig.encode(message.nodeConfig, writer.uint32(26).fork()).join();
    }
    if (message.processor !== "") {
      writer.uint32(34).string(message.processor);
    }
    for (const v of message.parents) {
      Node_InputEdge.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.outputAllOutputChannelsToStream = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeConfig = ProcessorConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.processor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parents.push(Node_InputEdge.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      outputAllOutputChannelsToStream: isSet(object.outputAllOutputChannelsToStream)
        ? globalThis.Boolean(object.outputAllOutputChannelsToStream)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      nodeConfig: isSet(object.nodeConfig) ? ProcessorConfig.fromJSON(object.nodeConfig) : undefined,
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parents: globalThis.Array.isArray(object?.parents)
        ? object.parents.map((e: any) => Node_InputEdge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.outputAllOutputChannelsToStream !== undefined) {
      obj.outputAllOutputChannelsToStream = message.outputAllOutputChannelsToStream;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = ProcessorConfig.toJSON(message.nodeConfig);
    }
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parents?.length) {
      obj.parents = message.parents.map((e) => Node_InputEdge.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.outputAllOutputChannelsToStream = object.outputAllOutputChannelsToStream ?? undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? ProcessorConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.processor = object.processor ?? "";
    message.parents = object.parents?.map((e) => Node_InputEdge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNode_InputEdge(): Node_InputEdge {
  return { parentNode: "", parentOutputChannel: "", connectedInputChannel: "" };
}

export const Node_InputEdge: MessageFns<Node_InputEdge> = {
  encode(message: Node_InputEdge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentNode !== "") {
      writer.uint32(10).string(message.parentNode);
    }
    if (message.parentOutputChannel !== "") {
      writer.uint32(18).string(message.parentOutputChannel);
    }
    if (message.connectedInputChannel !== "") {
      writer.uint32(26).string(message.connectedInputChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_InputEdge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_InputEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentNode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentOutputChannel = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connectedInputChannel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_InputEdge {
    return {
      parentNode: isSet(object.parentNode) ? globalThis.String(object.parentNode) : "",
      parentOutputChannel: isSet(object.parentOutputChannel) ? globalThis.String(object.parentOutputChannel) : "",
      connectedInputChannel: isSet(object.connectedInputChannel) ? globalThis.String(object.connectedInputChannel) : "",
    };
  },

  toJSON(message: Node_InputEdge): unknown {
    const obj: any = {};
    if (message.parentNode !== "") {
      obj.parentNode = message.parentNode;
    }
    if (message.parentOutputChannel !== "") {
      obj.parentOutputChannel = message.parentOutputChannel;
    }
    if (message.connectedInputChannel !== "") {
      obj.connectedInputChannel = message.connectedInputChannel;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_InputEdge>): Node_InputEdge {
    return Node_InputEdge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_InputEdge>): Node_InputEdge {
    const message = createBaseNode_InputEdge();
    message.parentNode = object.parentNode ?? "";
    message.parentOutputChannel = object.parentOutputChannel ?? "";
    message.connectedInputChannel = object.connectedInputChannel ?? "";
    return message;
  },
};

function createBaseDraft(): Draft {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    draftApplicationConfigs: undefined,
  };
}

export const Draft: MessageFns<Draft> = {
  encode(message: Draft, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Draft_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.draftApplicationConfigs !== undefined) {
      ApplicationConfigs.encode(message.draftApplicationConfigs, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Draft {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Draft_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.draftApplicationConfigs = ApplicationConfigs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Draft {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      draftApplicationConfigs: isSet(object.draftApplicationConfigs)
        ? ApplicationConfigs.fromJSON(object.draftApplicationConfigs)
        : undefined,
    };
  },

  toJSON(message: Draft): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.draftApplicationConfigs !== undefined) {
      obj.draftApplicationConfigs = ApplicationConfigs.toJSON(message.draftApplicationConfigs);
    }
    return obj;
  },

  create(base?: DeepPartial<Draft>): Draft {
    return Draft.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Draft>): Draft {
    const message = createBaseDraft();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.draftApplicationConfigs =
      (object.draftApplicationConfigs !== undefined && object.draftApplicationConfigs !== null)
        ? ApplicationConfigs.fromPartial(object.draftApplicationConfigs)
        : undefined;
    return message;
  },
};

function createBaseDraft_LabelsEntry(): Draft_LabelsEntry {
  return { key: "", value: "" };
}

export const Draft_LabelsEntry: MessageFns<Draft_LabelsEntry> = {
  encode(message: Draft_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Draft_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraft_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Draft_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Draft_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Draft_LabelsEntry>): Draft_LabelsEntry {
    return Draft_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Draft_LabelsEntry>): Draft_LabelsEntry {
    const message = createBaseDraft_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    instanceType: 0,
    inputResources: [],
    outputResources: [],
    state: 0,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.instanceType !== 0) {
      writer.uint32(80).int32(message.instanceType);
    }
    for (const v of message.inputResources) {
      Instance_InputResource.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.outputResources) {
      Instance_OutputResource.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.instanceType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputResources.push(Instance_InputResource.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.outputResources.push(Instance_OutputResource.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      instanceType: isSet(object.instanceType) ? instance_InstanceTypeFromJSON(object.instanceType) : 0,
      inputResources: globalThis.Array.isArray(object?.inputResources)
        ? object.inputResources.map((e: any) => Instance_InputResource.fromJSON(e))
        : [],
      outputResources: globalThis.Array.isArray(object?.outputResources)
        ? object.outputResources.map((e: any) => Instance_OutputResource.fromJSON(e))
        : [],
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.instanceType !== 0) {
      obj.instanceType = instance_InstanceTypeToJSON(message.instanceType);
    }
    if (message.inputResources?.length) {
      obj.inputResources = message.inputResources.map((e) => Instance_InputResource.toJSON(e));
    }
    if (message.outputResources?.length) {
      obj.outputResources = message.outputResources.map((e) => Instance_OutputResource.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.instanceType = object.instanceType ?? 0;
    message.inputResources = object.inputResources?.map((e) => Instance_InputResource.fromPartial(e)) || [];
    message.outputResources = object.outputResources?.map((e) => Instance_OutputResource.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseInstance_InputResource(): Instance_InputResource {
  return {
    inputResource: undefined,
    annotatedStream: undefined,
    dataType: 0,
    consumerNode: "",
    inputResourceBinding: "",
    annotations: undefined,
  };
}

export const Instance_InputResource: MessageFns<Instance_InputResource> = {
  encode(message: Instance_InputResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputResource !== undefined) {
      writer.uint32(10).string(message.inputResource);
    }
    if (message.annotatedStream !== undefined) {
      StreamWithAnnotation.encode(message.annotatedStream, writer.uint32(34).fork()).join();
    }
    if (message.dataType !== 0) {
      writer.uint32(48).int32(message.dataType);
    }
    if (message.consumerNode !== "") {
      writer.uint32(18).string(message.consumerNode);
    }
    if (message.inputResourceBinding !== "") {
      writer.uint32(26).string(message.inputResourceBinding);
    }
    if (message.annotations !== undefined) {
      ResourceAnnotations.encode(message.annotations, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_InputResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_InputResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputResource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.annotatedStream = StreamWithAnnotation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.consumerNode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputResourceBinding = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.annotations = ResourceAnnotations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_InputResource {
    return {
      inputResource: isSet(object.inputResource) ? globalThis.String(object.inputResource) : undefined,
      annotatedStream: isSet(object.annotatedStream)
        ? StreamWithAnnotation.fromJSON(object.annotatedStream)
        : undefined,
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      consumerNode: isSet(object.consumerNode) ? globalThis.String(object.consumerNode) : "",
      inputResourceBinding: isSet(object.inputResourceBinding) ? globalThis.String(object.inputResourceBinding) : "",
      annotations: isSet(object.annotations) ? ResourceAnnotations.fromJSON(object.annotations) : undefined,
    };
  },

  toJSON(message: Instance_InputResource): unknown {
    const obj: any = {};
    if (message.inputResource !== undefined) {
      obj.inputResource = message.inputResource;
    }
    if (message.annotatedStream !== undefined) {
      obj.annotatedStream = StreamWithAnnotation.toJSON(message.annotatedStream);
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.consumerNode !== "") {
      obj.consumerNode = message.consumerNode;
    }
    if (message.inputResourceBinding !== "") {
      obj.inputResourceBinding = message.inputResourceBinding;
    }
    if (message.annotations !== undefined) {
      obj.annotations = ResourceAnnotations.toJSON(message.annotations);
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_InputResource>): Instance_InputResource {
    return Instance_InputResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_InputResource>): Instance_InputResource {
    const message = createBaseInstance_InputResource();
    message.inputResource = object.inputResource ?? undefined;
    message.annotatedStream = (object.annotatedStream !== undefined && object.annotatedStream !== null)
      ? StreamWithAnnotation.fromPartial(object.annotatedStream)
      : undefined;
    message.dataType = object.dataType ?? 0;
    message.consumerNode = object.consumerNode ?? "";
    message.inputResourceBinding = object.inputResourceBinding ?? "";
    message.annotations = (object.annotations !== undefined && object.annotations !== null)
      ? ResourceAnnotations.fromPartial(object.annotations)
      : undefined;
    return message;
  },
};

function createBaseInstance_OutputResource(): Instance_OutputResource {
  return { outputResource: "", producerNode: "", outputResourceBinding: "", isTemporary: false, autogen: false };
}

export const Instance_OutputResource: MessageFns<Instance_OutputResource> = {
  encode(message: Instance_OutputResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputResource !== "") {
      writer.uint32(10).string(message.outputResource);
    }
    if (message.producerNode !== "") {
      writer.uint32(18).string(message.producerNode);
    }
    if (message.outputResourceBinding !== "") {
      writer.uint32(34).string(message.outputResourceBinding);
    }
    if (message.isTemporary !== false) {
      writer.uint32(24).bool(message.isTemporary);
    }
    if (message.autogen !== false) {
      writer.uint32(40).bool(message.autogen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_OutputResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_OutputResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputResource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producerNode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.outputResourceBinding = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isTemporary = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.autogen = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_OutputResource {
    return {
      outputResource: isSet(object.outputResource) ? globalThis.String(object.outputResource) : "",
      producerNode: isSet(object.producerNode) ? globalThis.String(object.producerNode) : "",
      outputResourceBinding: isSet(object.outputResourceBinding) ? globalThis.String(object.outputResourceBinding) : "",
      isTemporary: isSet(object.isTemporary) ? globalThis.Boolean(object.isTemporary) : false,
      autogen: isSet(object.autogen) ? globalThis.Boolean(object.autogen) : false,
    };
  },

  toJSON(message: Instance_OutputResource): unknown {
    const obj: any = {};
    if (message.outputResource !== "") {
      obj.outputResource = message.outputResource;
    }
    if (message.producerNode !== "") {
      obj.producerNode = message.producerNode;
    }
    if (message.outputResourceBinding !== "") {
      obj.outputResourceBinding = message.outputResourceBinding;
    }
    if (message.isTemporary !== false) {
      obj.isTemporary = message.isTemporary;
    }
    if (message.autogen !== false) {
      obj.autogen = message.autogen;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_OutputResource>): Instance_OutputResource {
    return Instance_OutputResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_OutputResource>): Instance_OutputResource {
    const message = createBaseInstance_OutputResource();
    message.outputResource = object.outputResource ?? "";
    message.producerNode = object.producerNode ?? "";
    message.outputResourceBinding = object.outputResourceBinding ?? "";
    message.isTemporary = object.isTemporary ?? false;
    message.autogen = object.autogen ?? false;
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApplicationInstance(): ApplicationInstance {
  return { instanceId: "", instance: undefined };
}

export const ApplicationInstance: MessageFns<ApplicationInstance> = {
  encode(message: ApplicationInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationInstance {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: ApplicationInstance): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationInstance>): ApplicationInstance {
    return ApplicationInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationInstance>): ApplicationInstance {
    const message = createBaseApplicationInstance();
    message.instanceId = object.instanceId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseProcessor(): Processor {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    description: "",
    processorType: 0,
    modelType: 0,
    customProcessorSourceInfo: undefined,
    state: 0,
    processorIoSpec: undefined,
    configurationTypeurl: "",
    supportedAnnotationTypes: [],
    supportsPostProcessing: false,
    supportedInstanceTypes: [],
  };
}

export const Processor: MessageFns<Processor> = {
  encode(message: Processor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Processor_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.processorType !== 0) {
      writer.uint32(48).int32(message.processorType);
    }
    if (message.modelType !== 0) {
      writer.uint32(104).int32(message.modelType);
    }
    if (message.customProcessorSourceInfo !== undefined) {
      CustomProcessorSourceInfo.encode(message.customProcessorSourceInfo, writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.processorIoSpec !== undefined) {
      ProcessorIOSpec.encode(message.processorIoSpec, writer.uint32(90).fork()).join();
    }
    if (message.configurationTypeurl !== "") {
      writer.uint32(114).string(message.configurationTypeurl);
    }
    writer.uint32(122).fork();
    for (const v of message.supportedAnnotationTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.supportsPostProcessing !== false) {
      writer.uint32(136).bool(message.supportsPostProcessing);
    }
    writer.uint32(146).fork();
    for (const v of message.supportedInstanceTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Processor_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.processorType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.modelType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customProcessorSourceInfo = CustomProcessorSourceInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.processorIoSpec = ProcessorIOSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.configurationTypeurl = reader.string();
          continue;
        case 15:
          if (tag === 120) {
            message.supportedAnnotationTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedAnnotationTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.supportsPostProcessing = reader.bool();
          continue;
        case 18:
          if (tag === 144) {
            message.supportedInstanceTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInstanceTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      processorType: isSet(object.processorType) ? processor_ProcessorTypeFromJSON(object.processorType) : 0,
      modelType: isSet(object.modelType) ? modelTypeFromJSON(object.modelType) : 0,
      customProcessorSourceInfo: isSet(object.customProcessorSourceInfo)
        ? CustomProcessorSourceInfo.fromJSON(object.customProcessorSourceInfo)
        : undefined,
      state: isSet(object.state) ? processor_ProcessorStateFromJSON(object.state) : 0,
      processorIoSpec: isSet(object.processorIoSpec) ? ProcessorIOSpec.fromJSON(object.processorIoSpec) : undefined,
      configurationTypeurl: isSet(object.configurationTypeurl) ? globalThis.String(object.configurationTypeurl) : "",
      supportedAnnotationTypes: globalThis.Array.isArray(object?.supportedAnnotationTypes)
        ? object.supportedAnnotationTypes.map((e: any) => streamAnnotationTypeFromJSON(e))
        : [],
      supportsPostProcessing: isSet(object.supportsPostProcessing)
        ? globalThis.Boolean(object.supportsPostProcessing)
        : false,
      supportedInstanceTypes: globalThis.Array.isArray(object?.supportedInstanceTypes)
        ? object.supportedInstanceTypes.map((e: any) => instance_InstanceTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: Processor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.processorType !== 0) {
      obj.processorType = processor_ProcessorTypeToJSON(message.processorType);
    }
    if (message.modelType !== 0) {
      obj.modelType = modelTypeToJSON(message.modelType);
    }
    if (message.customProcessorSourceInfo !== undefined) {
      obj.customProcessorSourceInfo = CustomProcessorSourceInfo.toJSON(message.customProcessorSourceInfo);
    }
    if (message.state !== 0) {
      obj.state = processor_ProcessorStateToJSON(message.state);
    }
    if (message.processorIoSpec !== undefined) {
      obj.processorIoSpec = ProcessorIOSpec.toJSON(message.processorIoSpec);
    }
    if (message.configurationTypeurl !== "") {
      obj.configurationTypeurl = message.configurationTypeurl;
    }
    if (message.supportedAnnotationTypes?.length) {
      obj.supportedAnnotationTypes = message.supportedAnnotationTypes.map((e) => streamAnnotationTypeToJSON(e));
    }
    if (message.supportsPostProcessing !== false) {
      obj.supportsPostProcessing = message.supportsPostProcessing;
    }
    if (message.supportedInstanceTypes?.length) {
      obj.supportedInstanceTypes = message.supportedInstanceTypes.map((e) => instance_InstanceTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Processor>): Processor {
    return Processor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Processor>): Processor {
    const message = createBaseProcessor();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.processorType = object.processorType ?? 0;
    message.modelType = object.modelType ?? 0;
    message.customProcessorSourceInfo =
      (object.customProcessorSourceInfo !== undefined && object.customProcessorSourceInfo !== null)
        ? CustomProcessorSourceInfo.fromPartial(object.customProcessorSourceInfo)
        : undefined;
    message.state = object.state ?? 0;
    message.processorIoSpec = (object.processorIoSpec !== undefined && object.processorIoSpec !== null)
      ? ProcessorIOSpec.fromPartial(object.processorIoSpec)
      : undefined;
    message.configurationTypeurl = object.configurationTypeurl ?? "";
    message.supportedAnnotationTypes = object.supportedAnnotationTypes?.map((e) => e) || [];
    message.supportsPostProcessing = object.supportsPostProcessing ?? false;
    message.supportedInstanceTypes = object.supportedInstanceTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseProcessor_LabelsEntry(): Processor_LabelsEntry {
  return { key: "", value: "" };
}

export const Processor_LabelsEntry: MessageFns<Processor_LabelsEntry> = {
  encode(message: Processor_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Processor_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Processor_LabelsEntry>): Processor_LabelsEntry {
    return Processor_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Processor_LabelsEntry>): Processor_LabelsEntry {
    const message = createBaseProcessor_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec(): ProcessorIOSpec {
  return {
    graphInputChannelSpecs: [],
    graphOutputChannelSpecs: [],
    instanceResourceInputBindingSpecs: [],
    instanceResourceOutputBindingSpecs: [],
  };
}

export const ProcessorIOSpec: MessageFns<ProcessorIOSpec> = {
  encode(message: ProcessorIOSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.graphInputChannelSpecs) {
      ProcessorIOSpec_GraphInputChannelSpec.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.graphOutputChannelSpecs) {
      ProcessorIOSpec_GraphOutputChannelSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.instanceResourceInputBindingSpecs) {
      ProcessorIOSpec_InstanceResourceInputBindingSpec.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.instanceResourceOutputBindingSpecs) {
      ProcessorIOSpec_InstanceResourceOutputBindingSpec.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.graphInputChannelSpecs.push(ProcessorIOSpec_GraphInputChannelSpec.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.graphOutputChannelSpecs.push(ProcessorIOSpec_GraphOutputChannelSpec.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instanceResourceInputBindingSpecs.push(
            ProcessorIOSpec_InstanceResourceInputBindingSpec.decode(reader, reader.uint32()),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.instanceResourceOutputBindingSpecs.push(
            ProcessorIOSpec_InstanceResourceOutputBindingSpec.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec {
    return {
      graphInputChannelSpecs: globalThis.Array.isArray(object?.graphInputChannelSpecs)
        ? object.graphInputChannelSpecs.map((e: any) => ProcessorIOSpec_GraphInputChannelSpec.fromJSON(e))
        : [],
      graphOutputChannelSpecs: globalThis.Array.isArray(object?.graphOutputChannelSpecs)
        ? object.graphOutputChannelSpecs.map((e: any) => ProcessorIOSpec_GraphOutputChannelSpec.fromJSON(e))
        : [],
      instanceResourceInputBindingSpecs: globalThis.Array.isArray(object?.instanceResourceInputBindingSpecs)
        ? object.instanceResourceInputBindingSpecs.map((e: any) =>
          ProcessorIOSpec_InstanceResourceInputBindingSpec.fromJSON(e)
        )
        : [],
      instanceResourceOutputBindingSpecs: globalThis.Array.isArray(object?.instanceResourceOutputBindingSpecs)
        ? object.instanceResourceOutputBindingSpecs.map((e: any) =>
          ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: ProcessorIOSpec): unknown {
    const obj: any = {};
    if (message.graphInputChannelSpecs?.length) {
      obj.graphInputChannelSpecs = message.graphInputChannelSpecs.map((e) =>
        ProcessorIOSpec_GraphInputChannelSpec.toJSON(e)
      );
    }
    if (message.graphOutputChannelSpecs?.length) {
      obj.graphOutputChannelSpecs = message.graphOutputChannelSpecs.map((e) =>
        ProcessorIOSpec_GraphOutputChannelSpec.toJSON(e)
      );
    }
    if (message.instanceResourceInputBindingSpecs?.length) {
      obj.instanceResourceInputBindingSpecs = message.instanceResourceInputBindingSpecs.map((e) =>
        ProcessorIOSpec_InstanceResourceInputBindingSpec.toJSON(e)
      );
    }
    if (message.instanceResourceOutputBindingSpecs?.length) {
      obj.instanceResourceOutputBindingSpecs = message.instanceResourceOutputBindingSpecs.map((e) =>
        ProcessorIOSpec_InstanceResourceOutputBindingSpec.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorIOSpec>): ProcessorIOSpec {
    return ProcessorIOSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorIOSpec>): ProcessorIOSpec {
    const message = createBaseProcessorIOSpec();
    message.graphInputChannelSpecs =
      object.graphInputChannelSpecs?.map((e) => ProcessorIOSpec_GraphInputChannelSpec.fromPartial(e)) || [];
    message.graphOutputChannelSpecs =
      object.graphOutputChannelSpecs?.map((e) => ProcessorIOSpec_GraphOutputChannelSpec.fromPartial(e)) || [];
    message.instanceResourceInputBindingSpecs =
      object.instanceResourceInputBindingSpecs?.map((e) =>
        ProcessorIOSpec_InstanceResourceInputBindingSpec.fromPartial(e)
      ) || [];
    message.instanceResourceOutputBindingSpecs =
      object.instanceResourceOutputBindingSpecs?.map((e) =>
        ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseProcessorIOSpec_GraphInputChannelSpec(): ProcessorIOSpec_GraphInputChannelSpec {
  return { name: "", dataType: 0, acceptedDataTypeUris: [], required: false, maxConnectionAllowed: Long.ZERO };
}

export const ProcessorIOSpec_GraphInputChannelSpec: MessageFns<ProcessorIOSpec_GraphInputChannelSpec> = {
  encode(message: ProcessorIOSpec_GraphInputChannelSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    for (const v of message.acceptedDataTypeUris) {
      writer.uint32(42).string(v!);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (!message.maxConnectionAllowed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.maxConnectionAllowed.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_GraphInputChannelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_GraphInputChannelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.acceptedDataTypeUris.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxConnectionAllowed = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_GraphInputChannelSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      acceptedDataTypeUris: globalThis.Array.isArray(object?.acceptedDataTypeUris)
        ? object.acceptedDataTypeUris.map((e: any) => globalThis.String(e))
        : [],
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      maxConnectionAllowed: isSet(object.maxConnectionAllowed)
        ? Long.fromValue(object.maxConnectionAllowed)
        : Long.ZERO,
    };
  },

  toJSON(message: ProcessorIOSpec_GraphInputChannelSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.acceptedDataTypeUris?.length) {
      obj.acceptedDataTypeUris = message.acceptedDataTypeUris;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (!message.maxConnectionAllowed.equals(Long.ZERO)) {
      obj.maxConnectionAllowed = (message.maxConnectionAllowed || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorIOSpec_GraphInputChannelSpec>): ProcessorIOSpec_GraphInputChannelSpec {
    return ProcessorIOSpec_GraphInputChannelSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorIOSpec_GraphInputChannelSpec>): ProcessorIOSpec_GraphInputChannelSpec {
    const message = createBaseProcessorIOSpec_GraphInputChannelSpec();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.acceptedDataTypeUris = object.acceptedDataTypeUris?.map((e) => e) || [];
    message.required = object.required ?? false;
    message.maxConnectionAllowed = (object.maxConnectionAllowed !== undefined && object.maxConnectionAllowed !== null)
      ? Long.fromValue(object.maxConnectionAllowed)
      : Long.ZERO;
    return message;
  },
};

function createBaseProcessorIOSpec_GraphOutputChannelSpec(): ProcessorIOSpec_GraphOutputChannelSpec {
  return { name: "", dataType: 0, dataTypeUri: "" };
}

export const ProcessorIOSpec_GraphOutputChannelSpec: MessageFns<ProcessorIOSpec_GraphOutputChannelSpec> = {
  encode(message: ProcessorIOSpec_GraphOutputChannelSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (message.dataTypeUri !== "") {
      writer.uint32(26).string(message.dataTypeUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_GraphOutputChannelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_GraphOutputChannelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataTypeUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_GraphOutputChannelSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      dataTypeUri: isSet(object.dataTypeUri) ? globalThis.String(object.dataTypeUri) : "",
    };
  },

  toJSON(message: ProcessorIOSpec_GraphOutputChannelSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.dataTypeUri !== "") {
      obj.dataTypeUri = message.dataTypeUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorIOSpec_GraphOutputChannelSpec>): ProcessorIOSpec_GraphOutputChannelSpec {
    return ProcessorIOSpec_GraphOutputChannelSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorIOSpec_GraphOutputChannelSpec>): ProcessorIOSpec_GraphOutputChannelSpec {
    const message = createBaseProcessorIOSpec_GraphOutputChannelSpec();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.dataTypeUri = object.dataTypeUri ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec_InstanceResourceInputBindingSpec(): ProcessorIOSpec_InstanceResourceInputBindingSpec {
  return { configTypeUri: undefined, resourceTypeUri: undefined, name: "" };
}

export const ProcessorIOSpec_InstanceResourceInputBindingSpec: MessageFns<
  ProcessorIOSpec_InstanceResourceInputBindingSpec
> = {
  encode(
    message: ProcessorIOSpec_InstanceResourceInputBindingSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.configTypeUri !== undefined) {
      writer.uint32(18).string(message.configTypeUri);
    }
    if (message.resourceTypeUri !== undefined) {
      writer.uint32(26).string(message.resourceTypeUri);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_InstanceResourceInputBindingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configTypeUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceTypeUri = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    return {
      configTypeUri: isSet(object.configTypeUri) ? globalThis.String(object.configTypeUri) : undefined,
      resourceTypeUri: isSet(object.resourceTypeUri) ? globalThis.String(object.resourceTypeUri) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ProcessorIOSpec_InstanceResourceInputBindingSpec): unknown {
    const obj: any = {};
    if (message.configTypeUri !== undefined) {
      obj.configTypeUri = message.configTypeUri;
    }
    if (message.resourceTypeUri !== undefined) {
      obj.resourceTypeUri = message.resourceTypeUri;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ProcessorIOSpec_InstanceResourceInputBindingSpec>,
  ): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    return ProcessorIOSpec_InstanceResourceInputBindingSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProcessorIOSpec_InstanceResourceInputBindingSpec>,
  ): ProcessorIOSpec_InstanceResourceInputBindingSpec {
    const message = createBaseProcessorIOSpec_InstanceResourceInputBindingSpec();
    message.configTypeUri = object.configTypeUri ?? undefined;
    message.resourceTypeUri = object.resourceTypeUri ?? undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec(): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
  return { name: "", resourceTypeUri: "", explicit: false };
}

export const ProcessorIOSpec_InstanceResourceOutputBindingSpec: MessageFns<
  ProcessorIOSpec_InstanceResourceOutputBindingSpec
> = {
  encode(
    message: ProcessorIOSpec_InstanceResourceOutputBindingSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceTypeUri !== "") {
      writer.uint32(18).string(message.resourceTypeUri);
    }
    if (message.explicit !== false) {
      writer.uint32(24).bool(message.explicit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceTypeUri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.explicit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resourceTypeUri: isSet(object.resourceTypeUri) ? globalThis.String(object.resourceTypeUri) : "",
      explicit: isSet(object.explicit) ? globalThis.Boolean(object.explicit) : false,
    };
  },

  toJSON(message: ProcessorIOSpec_InstanceResourceOutputBindingSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resourceTypeUri !== "") {
      obj.resourceTypeUri = message.resourceTypeUri;
    }
    if (message.explicit !== false) {
      obj.explicit = message.explicit;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ProcessorIOSpec_InstanceResourceOutputBindingSpec>,
  ): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    return ProcessorIOSpec_InstanceResourceOutputBindingSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProcessorIOSpec_InstanceResourceOutputBindingSpec>,
  ): ProcessorIOSpec_InstanceResourceOutputBindingSpec {
    const message = createBaseProcessorIOSpec_InstanceResourceOutputBindingSpec();
    message.name = object.name ?? "";
    message.resourceTypeUri = object.resourceTypeUri ?? "";
    message.explicit = object.explicit ?? false;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo(): CustomProcessorSourceInfo {
  return {
    vertexModel: undefined,
    productRecognizerArtifact: undefined,
    sourceType: 0,
    additionalInfo: {},
    modelSchema: undefined,
  };
}

export const CustomProcessorSourceInfo: MessageFns<CustomProcessorSourceInfo> = {
  encode(message: CustomProcessorSourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vertexModel !== undefined) {
      writer.uint32(18).string(message.vertexModel);
    }
    if (message.productRecognizerArtifact !== undefined) {
      CustomProcessorSourceInfo_ProductRecognizerArtifact.encode(
        message.productRecognizerArtifact,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.sourceType !== 0) {
      writer.uint32(8).int32(message.sourceType);
    }
    Object.entries(message.additionalInfo).forEach(([key, value]) => {
      CustomProcessorSourceInfo_AdditionalInfoEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.modelSchema !== undefined) {
      CustomProcessorSourceInfo_ModelSchema.encode(message.modelSchema, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomProcessorSourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vertexModel = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productRecognizerArtifact = CustomProcessorSourceInfo_ProductRecognizerArtifact.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = CustomProcessorSourceInfo_AdditionalInfoEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.additionalInfo[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.modelSchema = CustomProcessorSourceInfo_ModelSchema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomProcessorSourceInfo {
    return {
      vertexModel: isSet(object.vertexModel) ? globalThis.String(object.vertexModel) : undefined,
      productRecognizerArtifact: isSet(object.productRecognizerArtifact)
        ? CustomProcessorSourceInfo_ProductRecognizerArtifact.fromJSON(object.productRecognizerArtifact)
        : undefined,
      sourceType: isSet(object.sourceType) ? customProcessorSourceInfo_SourceTypeFromJSON(object.sourceType) : 0,
      additionalInfo: isObject(object.additionalInfo)
        ? Object.entries(object.additionalInfo).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      modelSchema: isSet(object.modelSchema)
        ? CustomProcessorSourceInfo_ModelSchema.fromJSON(object.modelSchema)
        : undefined,
    };
  },

  toJSON(message: CustomProcessorSourceInfo): unknown {
    const obj: any = {};
    if (message.vertexModel !== undefined) {
      obj.vertexModel = message.vertexModel;
    }
    if (message.productRecognizerArtifact !== undefined) {
      obj.productRecognizerArtifact = CustomProcessorSourceInfo_ProductRecognizerArtifact.toJSON(
        message.productRecognizerArtifact,
      );
    }
    if (message.sourceType !== 0) {
      obj.sourceType = customProcessorSourceInfo_SourceTypeToJSON(message.sourceType);
    }
    if (message.additionalInfo) {
      const entries = Object.entries(message.additionalInfo);
      if (entries.length > 0) {
        obj.additionalInfo = {};
        entries.forEach(([k, v]) => {
          obj.additionalInfo[k] = v;
        });
      }
    }
    if (message.modelSchema !== undefined) {
      obj.modelSchema = CustomProcessorSourceInfo_ModelSchema.toJSON(message.modelSchema);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomProcessorSourceInfo>): CustomProcessorSourceInfo {
    return CustomProcessorSourceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomProcessorSourceInfo>): CustomProcessorSourceInfo {
    const message = createBaseCustomProcessorSourceInfo();
    message.vertexModel = object.vertexModel ?? undefined;
    message.productRecognizerArtifact =
      (object.productRecognizerArtifact !== undefined && object.productRecognizerArtifact !== null)
        ? CustomProcessorSourceInfo_ProductRecognizerArtifact.fromPartial(object.productRecognizerArtifact)
        : undefined;
    message.sourceType = object.sourceType ?? 0;
    message.additionalInfo = Object.entries(object.additionalInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.modelSchema = (object.modelSchema !== undefined && object.modelSchema !== null)
      ? CustomProcessorSourceInfo_ModelSchema.fromPartial(object.modelSchema)
      : undefined;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo_ProductRecognizerArtifact(): CustomProcessorSourceInfo_ProductRecognizerArtifact {
  return { retailProductRecognitionIndex: "", vertexModel: "" };
}

export const CustomProcessorSourceInfo_ProductRecognizerArtifact: MessageFns<
  CustomProcessorSourceInfo_ProductRecognizerArtifact
> = {
  encode(
    message: CustomProcessorSourceInfo_ProductRecognizerArtifact,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.retailProductRecognitionIndex !== "") {
      writer.uint32(10).string(message.retailProductRecognitionIndex);
    }
    if (message.vertexModel !== "") {
      writer.uint32(18).string(message.vertexModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo_ProductRecognizerArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomProcessorSourceInfo_ProductRecognizerArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retailProductRecognitionIndex = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vertexModel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomProcessorSourceInfo_ProductRecognizerArtifact {
    return {
      retailProductRecognitionIndex: isSet(object.retailProductRecognitionIndex)
        ? globalThis.String(object.retailProductRecognitionIndex)
        : "",
      vertexModel: isSet(object.vertexModel) ? globalThis.String(object.vertexModel) : "",
    };
  },

  toJSON(message: CustomProcessorSourceInfo_ProductRecognizerArtifact): unknown {
    const obj: any = {};
    if (message.retailProductRecognitionIndex !== "") {
      obj.retailProductRecognitionIndex = message.retailProductRecognitionIndex;
    }
    if (message.vertexModel !== "") {
      obj.vertexModel = message.vertexModel;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CustomProcessorSourceInfo_ProductRecognizerArtifact>,
  ): CustomProcessorSourceInfo_ProductRecognizerArtifact {
    return CustomProcessorSourceInfo_ProductRecognizerArtifact.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CustomProcessorSourceInfo_ProductRecognizerArtifact>,
  ): CustomProcessorSourceInfo_ProductRecognizerArtifact {
    const message = createBaseCustomProcessorSourceInfo_ProductRecognizerArtifact();
    message.retailProductRecognitionIndex = object.retailProductRecognitionIndex ?? "";
    message.vertexModel = object.vertexModel ?? "";
    return message;
  },
};

function createBaseCustomProcessorSourceInfo_ModelSchema(): CustomProcessorSourceInfo_ModelSchema {
  return { instancesSchema: undefined, parametersSchema: undefined, predictionsSchema: undefined };
}

export const CustomProcessorSourceInfo_ModelSchema: MessageFns<CustomProcessorSourceInfo_ModelSchema> = {
  encode(message: CustomProcessorSourceInfo_ModelSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instancesSchema !== undefined) {
      GcsSource.encode(message.instancesSchema, writer.uint32(10).fork()).join();
    }
    if (message.parametersSchema !== undefined) {
      GcsSource.encode(message.parametersSchema, writer.uint32(18).fork()).join();
    }
    if (message.predictionsSchema !== undefined) {
      GcsSource.encode(message.predictionsSchema, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo_ModelSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomProcessorSourceInfo_ModelSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instancesSchema = GcsSource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parametersSchema = GcsSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.predictionsSchema = GcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomProcessorSourceInfo_ModelSchema {
    return {
      instancesSchema: isSet(object.instancesSchema) ? GcsSource.fromJSON(object.instancesSchema) : undefined,
      parametersSchema: isSet(object.parametersSchema) ? GcsSource.fromJSON(object.parametersSchema) : undefined,
      predictionsSchema: isSet(object.predictionsSchema) ? GcsSource.fromJSON(object.predictionsSchema) : undefined,
    };
  },

  toJSON(message: CustomProcessorSourceInfo_ModelSchema): unknown {
    const obj: any = {};
    if (message.instancesSchema !== undefined) {
      obj.instancesSchema = GcsSource.toJSON(message.instancesSchema);
    }
    if (message.parametersSchema !== undefined) {
      obj.parametersSchema = GcsSource.toJSON(message.parametersSchema);
    }
    if (message.predictionsSchema !== undefined) {
      obj.predictionsSchema = GcsSource.toJSON(message.predictionsSchema);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomProcessorSourceInfo_ModelSchema>): CustomProcessorSourceInfo_ModelSchema {
    return CustomProcessorSourceInfo_ModelSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomProcessorSourceInfo_ModelSchema>): CustomProcessorSourceInfo_ModelSchema {
    const message = createBaseCustomProcessorSourceInfo_ModelSchema();
    message.instancesSchema = (object.instancesSchema !== undefined && object.instancesSchema !== null)
      ? GcsSource.fromPartial(object.instancesSchema)
      : undefined;
    message.parametersSchema = (object.parametersSchema !== undefined && object.parametersSchema !== null)
      ? GcsSource.fromPartial(object.parametersSchema)
      : undefined;
    message.predictionsSchema = (object.predictionsSchema !== undefined && object.predictionsSchema !== null)
      ? GcsSource.fromPartial(object.predictionsSchema)
      : undefined;
    return message;
  },
};

function createBaseCustomProcessorSourceInfo_AdditionalInfoEntry(): CustomProcessorSourceInfo_AdditionalInfoEntry {
  return { key: "", value: "" };
}

export const CustomProcessorSourceInfo_AdditionalInfoEntry: MessageFns<CustomProcessorSourceInfo_AdditionalInfoEntry> =
  {
    encode(
      message: CustomProcessorSourceInfo_AdditionalInfoEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CustomProcessorSourceInfo_AdditionalInfoEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCustomProcessorSourceInfo_AdditionalInfoEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CustomProcessorSourceInfo_AdditionalInfoEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: CustomProcessorSourceInfo_AdditionalInfoEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<CustomProcessorSourceInfo_AdditionalInfoEntry>,
    ): CustomProcessorSourceInfo_AdditionalInfoEntry {
      return CustomProcessorSourceInfo_AdditionalInfoEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CustomProcessorSourceInfo_AdditionalInfoEntry>,
    ): CustomProcessorSourceInfo_AdditionalInfoEntry {
      const message = createBaseCustomProcessorSourceInfo_AdditionalInfoEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseProcessorConfig(): ProcessorConfig {
  return {
    videoStreamInputConfig: undefined,
    aiEnabledDevicesInputConfig: undefined,
    mediaWarehouseConfig: undefined,
    personBlurConfig: undefined,
    occupancyCountConfig: undefined,
    personVehicleDetectionConfig: undefined,
    vertexAutomlVisionConfig: undefined,
    vertexAutomlVideoConfig: undefined,
    vertexCustomConfig: undefined,
    generalObjectDetectionConfig: undefined,
    bigQueryConfig: undefined,
    gcsOutputConfig: undefined,
    productRecognizerConfig: undefined,
    personalProtectiveEquipmentDetectionConfig: undefined,
    tagRecognizerConfig: undefined,
    universalInputConfig: undefined,
    experimentalConfig: undefined,
  };
}

export const ProcessorConfig: MessageFns<ProcessorConfig> = {
  encode(message: ProcessorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoStreamInputConfig !== undefined) {
      VideoStreamInputConfig.encode(message.videoStreamInputConfig, writer.uint32(74).fork()).join();
    }
    if (message.aiEnabledDevicesInputConfig !== undefined) {
      AIEnabledDevicesInputConfig.encode(message.aiEnabledDevicesInputConfig, writer.uint32(162).fork()).join();
    }
    if (message.mediaWarehouseConfig !== undefined) {
      MediaWarehouseConfig.encode(message.mediaWarehouseConfig, writer.uint32(82).fork()).join();
    }
    if (message.personBlurConfig !== undefined) {
      PersonBlurConfig.encode(message.personBlurConfig, writer.uint32(90).fork()).join();
    }
    if (message.occupancyCountConfig !== undefined) {
      OccupancyCountConfig.encode(message.occupancyCountConfig, writer.uint32(98).fork()).join();
    }
    if (message.personVehicleDetectionConfig !== undefined) {
      PersonVehicleDetectionConfig.encode(message.personVehicleDetectionConfig, writer.uint32(122).fork()).join();
    }
    if (message.vertexAutomlVisionConfig !== undefined) {
      VertexAutoMLVisionConfig.encode(message.vertexAutomlVisionConfig, writer.uint32(106).fork()).join();
    }
    if (message.vertexAutomlVideoConfig !== undefined) {
      VertexAutoMLVideoConfig.encode(message.vertexAutomlVideoConfig, writer.uint32(114).fork()).join();
    }
    if (message.vertexCustomConfig !== undefined) {
      VertexCustomConfig.encode(message.vertexCustomConfig, writer.uint32(138).fork()).join();
    }
    if (message.generalObjectDetectionConfig !== undefined) {
      GeneralObjectDetectionConfig.encode(message.generalObjectDetectionConfig, writer.uint32(146).fork()).join();
    }
    if (message.bigQueryConfig !== undefined) {
      BigQueryConfig.encode(message.bigQueryConfig, writer.uint32(154).fork()).join();
    }
    if (message.gcsOutputConfig !== undefined) {
      GcsOutputConfig.encode(message.gcsOutputConfig, writer.uint32(218).fork()).join();
    }
    if (message.productRecognizerConfig !== undefined) {
      ProductRecognizerConfig.encode(message.productRecognizerConfig, writer.uint32(170).fork()).join();
    }
    if (message.personalProtectiveEquipmentDetectionConfig !== undefined) {
      PersonalProtectiveEquipmentDetectionConfig.encode(
        message.personalProtectiveEquipmentDetectionConfig,
        writer.uint32(178).fork(),
      ).join();
    }
    if (message.tagRecognizerConfig !== undefined) {
      TagRecognizerConfig.encode(message.tagRecognizerConfig, writer.uint32(202).fork()).join();
    }
    if (message.universalInputConfig !== undefined) {
      UniversalInputConfig.encode(message.universalInputConfig, writer.uint32(226).fork()).join();
    }
    if (message.experimentalConfig !== undefined) {
      Struct.encode(Struct.wrap(message.experimentalConfig), writer.uint32(210).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 74) {
            break;
          }

          message.videoStreamInputConfig = VideoStreamInputConfig.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.aiEnabledDevicesInputConfig = AIEnabledDevicesInputConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mediaWarehouseConfig = MediaWarehouseConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.personBlurConfig = PersonBlurConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.occupancyCountConfig = OccupancyCountConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.personVehicleDetectionConfig = PersonVehicleDetectionConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.vertexAutomlVisionConfig = VertexAutoMLVisionConfig.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vertexAutomlVideoConfig = VertexAutoMLVideoConfig.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.vertexCustomConfig = VertexCustomConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.generalObjectDetectionConfig = GeneralObjectDetectionConfig.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.bigQueryConfig = BigQueryConfig.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.gcsOutputConfig = GcsOutputConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.productRecognizerConfig = ProductRecognizerConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.personalProtectiveEquipmentDetectionConfig = PersonalProtectiveEquipmentDetectionConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.tagRecognizerConfig = TagRecognizerConfig.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.universalInputConfig = UniversalInputConfig.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.experimentalConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorConfig {
    return {
      videoStreamInputConfig: isSet(object.videoStreamInputConfig)
        ? VideoStreamInputConfig.fromJSON(object.videoStreamInputConfig)
        : undefined,
      aiEnabledDevicesInputConfig: isSet(object.aiEnabledDevicesInputConfig)
        ? AIEnabledDevicesInputConfig.fromJSON(object.aiEnabledDevicesInputConfig)
        : undefined,
      mediaWarehouseConfig: isSet(object.mediaWarehouseConfig)
        ? MediaWarehouseConfig.fromJSON(object.mediaWarehouseConfig)
        : undefined,
      personBlurConfig: isSet(object.personBlurConfig) ? PersonBlurConfig.fromJSON(object.personBlurConfig) : undefined,
      occupancyCountConfig: isSet(object.occupancyCountConfig)
        ? OccupancyCountConfig.fromJSON(object.occupancyCountConfig)
        : undefined,
      personVehicleDetectionConfig: isSet(object.personVehicleDetectionConfig)
        ? PersonVehicleDetectionConfig.fromJSON(object.personVehicleDetectionConfig)
        : undefined,
      vertexAutomlVisionConfig: isSet(object.vertexAutomlVisionConfig)
        ? VertexAutoMLVisionConfig.fromJSON(object.vertexAutomlVisionConfig)
        : undefined,
      vertexAutomlVideoConfig: isSet(object.vertexAutomlVideoConfig)
        ? VertexAutoMLVideoConfig.fromJSON(object.vertexAutomlVideoConfig)
        : undefined,
      vertexCustomConfig: isSet(object.vertexCustomConfig)
        ? VertexCustomConfig.fromJSON(object.vertexCustomConfig)
        : undefined,
      generalObjectDetectionConfig: isSet(object.generalObjectDetectionConfig)
        ? GeneralObjectDetectionConfig.fromJSON(object.generalObjectDetectionConfig)
        : undefined,
      bigQueryConfig: isSet(object.bigQueryConfig) ? BigQueryConfig.fromJSON(object.bigQueryConfig) : undefined,
      gcsOutputConfig: isSet(object.gcsOutputConfig) ? GcsOutputConfig.fromJSON(object.gcsOutputConfig) : undefined,
      productRecognizerConfig: isSet(object.productRecognizerConfig)
        ? ProductRecognizerConfig.fromJSON(object.productRecognizerConfig)
        : undefined,
      personalProtectiveEquipmentDetectionConfig: isSet(object.personalProtectiveEquipmentDetectionConfig)
        ? PersonalProtectiveEquipmentDetectionConfig.fromJSON(object.personalProtectiveEquipmentDetectionConfig)
        : undefined,
      tagRecognizerConfig: isSet(object.tagRecognizerConfig)
        ? TagRecognizerConfig.fromJSON(object.tagRecognizerConfig)
        : undefined,
      universalInputConfig: isSet(object.universalInputConfig)
        ? UniversalInputConfig.fromJSON(object.universalInputConfig)
        : undefined,
      experimentalConfig: isObject(object.experimentalConfig) ? object.experimentalConfig : undefined,
    };
  },

  toJSON(message: ProcessorConfig): unknown {
    const obj: any = {};
    if (message.videoStreamInputConfig !== undefined) {
      obj.videoStreamInputConfig = VideoStreamInputConfig.toJSON(message.videoStreamInputConfig);
    }
    if (message.aiEnabledDevicesInputConfig !== undefined) {
      obj.aiEnabledDevicesInputConfig = AIEnabledDevicesInputConfig.toJSON(message.aiEnabledDevicesInputConfig);
    }
    if (message.mediaWarehouseConfig !== undefined) {
      obj.mediaWarehouseConfig = MediaWarehouseConfig.toJSON(message.mediaWarehouseConfig);
    }
    if (message.personBlurConfig !== undefined) {
      obj.personBlurConfig = PersonBlurConfig.toJSON(message.personBlurConfig);
    }
    if (message.occupancyCountConfig !== undefined) {
      obj.occupancyCountConfig = OccupancyCountConfig.toJSON(message.occupancyCountConfig);
    }
    if (message.personVehicleDetectionConfig !== undefined) {
      obj.personVehicleDetectionConfig = PersonVehicleDetectionConfig.toJSON(message.personVehicleDetectionConfig);
    }
    if (message.vertexAutomlVisionConfig !== undefined) {
      obj.vertexAutomlVisionConfig = VertexAutoMLVisionConfig.toJSON(message.vertexAutomlVisionConfig);
    }
    if (message.vertexAutomlVideoConfig !== undefined) {
      obj.vertexAutomlVideoConfig = VertexAutoMLVideoConfig.toJSON(message.vertexAutomlVideoConfig);
    }
    if (message.vertexCustomConfig !== undefined) {
      obj.vertexCustomConfig = VertexCustomConfig.toJSON(message.vertexCustomConfig);
    }
    if (message.generalObjectDetectionConfig !== undefined) {
      obj.generalObjectDetectionConfig = GeneralObjectDetectionConfig.toJSON(message.generalObjectDetectionConfig);
    }
    if (message.bigQueryConfig !== undefined) {
      obj.bigQueryConfig = BigQueryConfig.toJSON(message.bigQueryConfig);
    }
    if (message.gcsOutputConfig !== undefined) {
      obj.gcsOutputConfig = GcsOutputConfig.toJSON(message.gcsOutputConfig);
    }
    if (message.productRecognizerConfig !== undefined) {
      obj.productRecognizerConfig = ProductRecognizerConfig.toJSON(message.productRecognizerConfig);
    }
    if (message.personalProtectiveEquipmentDetectionConfig !== undefined) {
      obj.personalProtectiveEquipmentDetectionConfig = PersonalProtectiveEquipmentDetectionConfig.toJSON(
        message.personalProtectiveEquipmentDetectionConfig,
      );
    }
    if (message.tagRecognizerConfig !== undefined) {
      obj.tagRecognizerConfig = TagRecognizerConfig.toJSON(message.tagRecognizerConfig);
    }
    if (message.universalInputConfig !== undefined) {
      obj.universalInputConfig = UniversalInputConfig.toJSON(message.universalInputConfig);
    }
    if (message.experimentalConfig !== undefined) {
      obj.experimentalConfig = message.experimentalConfig;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorConfig>): ProcessorConfig {
    return ProcessorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorConfig>): ProcessorConfig {
    const message = createBaseProcessorConfig();
    message.videoStreamInputConfig =
      (object.videoStreamInputConfig !== undefined && object.videoStreamInputConfig !== null)
        ? VideoStreamInputConfig.fromPartial(object.videoStreamInputConfig)
        : undefined;
    message.aiEnabledDevicesInputConfig =
      (object.aiEnabledDevicesInputConfig !== undefined && object.aiEnabledDevicesInputConfig !== null)
        ? AIEnabledDevicesInputConfig.fromPartial(object.aiEnabledDevicesInputConfig)
        : undefined;
    message.mediaWarehouseConfig = (object.mediaWarehouseConfig !== undefined && object.mediaWarehouseConfig !== null)
      ? MediaWarehouseConfig.fromPartial(object.mediaWarehouseConfig)
      : undefined;
    message.personBlurConfig = (object.personBlurConfig !== undefined && object.personBlurConfig !== null)
      ? PersonBlurConfig.fromPartial(object.personBlurConfig)
      : undefined;
    message.occupancyCountConfig = (object.occupancyCountConfig !== undefined && object.occupancyCountConfig !== null)
      ? OccupancyCountConfig.fromPartial(object.occupancyCountConfig)
      : undefined;
    message.personVehicleDetectionConfig =
      (object.personVehicleDetectionConfig !== undefined && object.personVehicleDetectionConfig !== null)
        ? PersonVehicleDetectionConfig.fromPartial(object.personVehicleDetectionConfig)
        : undefined;
    message.vertexAutomlVisionConfig =
      (object.vertexAutomlVisionConfig !== undefined && object.vertexAutomlVisionConfig !== null)
        ? VertexAutoMLVisionConfig.fromPartial(object.vertexAutomlVisionConfig)
        : undefined;
    message.vertexAutomlVideoConfig =
      (object.vertexAutomlVideoConfig !== undefined && object.vertexAutomlVideoConfig !== null)
        ? VertexAutoMLVideoConfig.fromPartial(object.vertexAutomlVideoConfig)
        : undefined;
    message.vertexCustomConfig = (object.vertexCustomConfig !== undefined && object.vertexCustomConfig !== null)
      ? VertexCustomConfig.fromPartial(object.vertexCustomConfig)
      : undefined;
    message.generalObjectDetectionConfig =
      (object.generalObjectDetectionConfig !== undefined && object.generalObjectDetectionConfig !== null)
        ? GeneralObjectDetectionConfig.fromPartial(object.generalObjectDetectionConfig)
        : undefined;
    message.bigQueryConfig = (object.bigQueryConfig !== undefined && object.bigQueryConfig !== null)
      ? BigQueryConfig.fromPartial(object.bigQueryConfig)
      : undefined;
    message.gcsOutputConfig = (object.gcsOutputConfig !== undefined && object.gcsOutputConfig !== null)
      ? GcsOutputConfig.fromPartial(object.gcsOutputConfig)
      : undefined;
    message.productRecognizerConfig =
      (object.productRecognizerConfig !== undefined && object.productRecognizerConfig !== null)
        ? ProductRecognizerConfig.fromPartial(object.productRecognizerConfig)
        : undefined;
    message.personalProtectiveEquipmentDetectionConfig =
      (object.personalProtectiveEquipmentDetectionConfig !== undefined &&
          object.personalProtectiveEquipmentDetectionConfig !== null)
        ? PersonalProtectiveEquipmentDetectionConfig.fromPartial(object.personalProtectiveEquipmentDetectionConfig)
        : undefined;
    message.tagRecognizerConfig = (object.tagRecognizerConfig !== undefined && object.tagRecognizerConfig !== null)
      ? TagRecognizerConfig.fromPartial(object.tagRecognizerConfig)
      : undefined;
    message.universalInputConfig = (object.universalInputConfig !== undefined && object.universalInputConfig !== null)
      ? UniversalInputConfig.fromPartial(object.universalInputConfig)
      : undefined;
    message.experimentalConfig = object.experimentalConfig ?? undefined;
    return message;
  },
};

function createBaseStreamWithAnnotation(): StreamWithAnnotation {
  return { stream: "", applicationAnnotations: [], nodeAnnotations: [] };
}

export const StreamWithAnnotation: MessageFns<StreamWithAnnotation> = {
  encode(message: StreamWithAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stream !== "") {
      writer.uint32(10).string(message.stream);
    }
    for (const v of message.applicationAnnotations) {
      StreamAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodeAnnotations) {
      StreamWithAnnotation_NodeAnnotation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamWithAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamWithAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicationAnnotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeAnnotations.push(StreamWithAnnotation_NodeAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamWithAnnotation {
    return {
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      applicationAnnotations: globalThis.Array.isArray(object?.applicationAnnotations)
        ? object.applicationAnnotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
      nodeAnnotations: globalThis.Array.isArray(object?.nodeAnnotations)
        ? object.nodeAnnotations.map((e: any) => StreamWithAnnotation_NodeAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamWithAnnotation): unknown {
    const obj: any = {};
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.applicationAnnotations?.length) {
      obj.applicationAnnotations = message.applicationAnnotations.map((e) => StreamAnnotation.toJSON(e));
    }
    if (message.nodeAnnotations?.length) {
      obj.nodeAnnotations = message.nodeAnnotations.map((e) => StreamWithAnnotation_NodeAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamWithAnnotation>): StreamWithAnnotation {
    return StreamWithAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamWithAnnotation>): StreamWithAnnotation {
    const message = createBaseStreamWithAnnotation();
    message.stream = object.stream ?? "";
    message.applicationAnnotations = object.applicationAnnotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    message.nodeAnnotations = object.nodeAnnotations?.map((e) => StreamWithAnnotation_NodeAnnotation.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseStreamWithAnnotation_NodeAnnotation(): StreamWithAnnotation_NodeAnnotation {
  return { node: "", annotations: [] };
}

export const StreamWithAnnotation_NodeAnnotation: MessageFns<StreamWithAnnotation_NodeAnnotation> = {
  encode(message: StreamWithAnnotation_NodeAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    for (const v of message.annotations) {
      StreamAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamWithAnnotation_NodeAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamWithAnnotation_NodeAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamWithAnnotation_NodeAnnotation {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamWithAnnotation_NodeAnnotation): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => StreamAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamWithAnnotation_NodeAnnotation>): StreamWithAnnotation_NodeAnnotation {
    return StreamWithAnnotation_NodeAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamWithAnnotation_NodeAnnotation>): StreamWithAnnotation_NodeAnnotation {
    const message = createBaseStreamWithAnnotation_NodeAnnotation();
    message.node = object.node ?? "";
    message.annotations = object.annotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseApplicationNodeAnnotation(): ApplicationNodeAnnotation {
  return { node: "", annotations: [] };
}

export const ApplicationNodeAnnotation: MessageFns<ApplicationNodeAnnotation> = {
  encode(message: ApplicationNodeAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    for (const v of message.annotations) {
      StreamAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationNodeAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationNodeAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationNodeAnnotation {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ApplicationNodeAnnotation): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => StreamAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationNodeAnnotation>): ApplicationNodeAnnotation {
    return ApplicationNodeAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationNodeAnnotation>): ApplicationNodeAnnotation {
    const message = createBaseApplicationNodeAnnotation();
    message.node = object.node ?? "";
    message.annotations = object.annotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResourceAnnotations(): ResourceAnnotations {
  return { applicationAnnotations: [], nodeAnnotations: [] };
}

export const ResourceAnnotations: MessageFns<ResourceAnnotations> = {
  encode(message: ResourceAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.applicationAnnotations) {
      StreamAnnotation.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.nodeAnnotations) {
      ApplicationNodeAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.applicationAnnotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeAnnotations.push(ApplicationNodeAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceAnnotations {
    return {
      applicationAnnotations: globalThis.Array.isArray(object?.applicationAnnotations)
        ? object.applicationAnnotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
      nodeAnnotations: globalThis.Array.isArray(object?.nodeAnnotations)
        ? object.nodeAnnotations.map((e: any) => ApplicationNodeAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResourceAnnotations): unknown {
    const obj: any = {};
    if (message.applicationAnnotations?.length) {
      obj.applicationAnnotations = message.applicationAnnotations.map((e) => StreamAnnotation.toJSON(e));
    }
    if (message.nodeAnnotations?.length) {
      obj.nodeAnnotations = message.nodeAnnotations.map((e) => ApplicationNodeAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceAnnotations>): ResourceAnnotations {
    return ResourceAnnotations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceAnnotations>): ResourceAnnotations {
    const message = createBaseResourceAnnotations();
    message.applicationAnnotations = object.applicationAnnotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    message.nodeAnnotations = object.nodeAnnotations?.map((e) => ApplicationNodeAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoStreamInputConfig(): VideoStreamInputConfig {
  return { streams: [], streamsWithAnnotation: [] };
}

export const VideoStreamInputConfig: MessageFns<VideoStreamInputConfig> = {
  encode(message: VideoStreamInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.streams) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.streamsWithAnnotation) {
      StreamWithAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStreamInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStreamInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streams.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streamsWithAnnotation.push(StreamWithAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStreamInputConfig {
    return {
      streams: globalThis.Array.isArray(object?.streams) ? object.streams.map((e: any) => globalThis.String(e)) : [],
      streamsWithAnnotation: globalThis.Array.isArray(object?.streamsWithAnnotation)
        ? object.streamsWithAnnotation.map((e: any) => StreamWithAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoStreamInputConfig): unknown {
    const obj: any = {};
    if (message.streams?.length) {
      obj.streams = message.streams;
    }
    if (message.streamsWithAnnotation?.length) {
      obj.streamsWithAnnotation = message.streamsWithAnnotation.map((e) => StreamWithAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStreamInputConfig>): VideoStreamInputConfig {
    return VideoStreamInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStreamInputConfig>): VideoStreamInputConfig {
    const message = createBaseVideoStreamInputConfig();
    message.streams = object.streams?.map((e) => e) || [];
    message.streamsWithAnnotation = object.streamsWithAnnotation?.map((e) => StreamWithAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAIEnabledDevicesInputConfig(): AIEnabledDevicesInputConfig {
  return {};
}

export const AIEnabledDevicesInputConfig: MessageFns<AIEnabledDevicesInputConfig> = {
  encode(_: AIEnabledDevicesInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIEnabledDevicesInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIEnabledDevicesInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AIEnabledDevicesInputConfig {
    return {};
  },

  toJSON(_: AIEnabledDevicesInputConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AIEnabledDevicesInputConfig>): AIEnabledDevicesInputConfig {
    return AIEnabledDevicesInputConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AIEnabledDevicesInputConfig>): AIEnabledDevicesInputConfig {
    const message = createBaseAIEnabledDevicesInputConfig();
    return message;
  },
};

function createBaseMediaWarehouseConfig(): MediaWarehouseConfig {
  return { corpus: "", region: "", ttl: undefined };
}

export const MediaWarehouseConfig: MessageFns<MediaWarehouseConfig> = {
  encode(message: MediaWarehouseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== "") {
      writer.uint32(10).string(message.corpus);
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaWarehouseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaWarehouseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaWarehouseConfig {
    return {
      corpus: isSet(object.corpus) ? globalThis.String(object.corpus) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: MediaWarehouseConfig): unknown {
    const obj: any = {};
    if (message.corpus !== "") {
      obj.corpus = message.corpus;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create(base?: DeepPartial<MediaWarehouseConfig>): MediaWarehouseConfig {
    return MediaWarehouseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediaWarehouseConfig>): MediaWarehouseConfig {
    const message = createBaseMediaWarehouseConfig();
    message.corpus = object.corpus ?? "";
    message.region = object.region ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBasePersonBlurConfig(): PersonBlurConfig {
  return { personBlurType: 0, facesOnly: false };
}

export const PersonBlurConfig: MessageFns<PersonBlurConfig> = {
  encode(message: PersonBlurConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.personBlurType !== 0) {
      writer.uint32(8).int32(message.personBlurType);
    }
    if (message.facesOnly !== false) {
      writer.uint32(16).bool(message.facesOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonBlurConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonBlurConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.personBlurType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.facesOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonBlurConfig {
    return {
      personBlurType: isSet(object.personBlurType) ? personBlurConfig_PersonBlurTypeFromJSON(object.personBlurType) : 0,
      facesOnly: isSet(object.facesOnly) ? globalThis.Boolean(object.facesOnly) : false,
    };
  },

  toJSON(message: PersonBlurConfig): unknown {
    const obj: any = {};
    if (message.personBlurType !== 0) {
      obj.personBlurType = personBlurConfig_PersonBlurTypeToJSON(message.personBlurType);
    }
    if (message.facesOnly !== false) {
      obj.facesOnly = message.facesOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<PersonBlurConfig>): PersonBlurConfig {
    return PersonBlurConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PersonBlurConfig>): PersonBlurConfig {
    const message = createBasePersonBlurConfig();
    message.personBlurType = object.personBlurType ?? 0;
    message.facesOnly = object.facesOnly ?? false;
    return message;
  },
};

function createBaseOccupancyCountConfig(): OccupancyCountConfig {
  return { enablePeopleCounting: false, enableVehicleCounting: false, enableDwellingTimeTracking: false };
}

export const OccupancyCountConfig: MessageFns<OccupancyCountConfig> = {
  encode(message: OccupancyCountConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePeopleCounting !== false) {
      writer.uint32(8).bool(message.enablePeopleCounting);
    }
    if (message.enableVehicleCounting !== false) {
      writer.uint32(16).bool(message.enableVehicleCounting);
    }
    if (message.enableDwellingTimeTracking !== false) {
      writer.uint32(24).bool(message.enableDwellingTimeTracking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePeopleCounting = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableVehicleCounting = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableDwellingTimeTracking = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountConfig {
    return {
      enablePeopleCounting: isSet(object.enablePeopleCounting)
        ? globalThis.Boolean(object.enablePeopleCounting)
        : false,
      enableVehicleCounting: isSet(object.enableVehicleCounting)
        ? globalThis.Boolean(object.enableVehicleCounting)
        : false,
      enableDwellingTimeTracking: isSet(object.enableDwellingTimeTracking)
        ? globalThis.Boolean(object.enableDwellingTimeTracking)
        : false,
    };
  },

  toJSON(message: OccupancyCountConfig): unknown {
    const obj: any = {};
    if (message.enablePeopleCounting !== false) {
      obj.enablePeopleCounting = message.enablePeopleCounting;
    }
    if (message.enableVehicleCounting !== false) {
      obj.enableVehicleCounting = message.enableVehicleCounting;
    }
    if (message.enableDwellingTimeTracking !== false) {
      obj.enableDwellingTimeTracking = message.enableDwellingTimeTracking;
    }
    return obj;
  },

  create(base?: DeepPartial<OccupancyCountConfig>): OccupancyCountConfig {
    return OccupancyCountConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OccupancyCountConfig>): OccupancyCountConfig {
    const message = createBaseOccupancyCountConfig();
    message.enablePeopleCounting = object.enablePeopleCounting ?? false;
    message.enableVehicleCounting = object.enableVehicleCounting ?? false;
    message.enableDwellingTimeTracking = object.enableDwellingTimeTracking ?? false;
    return message;
  },
};

function createBasePersonVehicleDetectionConfig(): PersonVehicleDetectionConfig {
  return { enablePeopleCounting: false, enableVehicleCounting: false };
}

export const PersonVehicleDetectionConfig: MessageFns<PersonVehicleDetectionConfig> = {
  encode(message: PersonVehicleDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePeopleCounting !== false) {
      writer.uint32(8).bool(message.enablePeopleCounting);
    }
    if (message.enableVehicleCounting !== false) {
      writer.uint32(16).bool(message.enableVehicleCounting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonVehicleDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonVehicleDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePeopleCounting = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableVehicleCounting = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonVehicleDetectionConfig {
    return {
      enablePeopleCounting: isSet(object.enablePeopleCounting)
        ? globalThis.Boolean(object.enablePeopleCounting)
        : false,
      enableVehicleCounting: isSet(object.enableVehicleCounting)
        ? globalThis.Boolean(object.enableVehicleCounting)
        : false,
    };
  },

  toJSON(message: PersonVehicleDetectionConfig): unknown {
    const obj: any = {};
    if (message.enablePeopleCounting !== false) {
      obj.enablePeopleCounting = message.enablePeopleCounting;
    }
    if (message.enableVehicleCounting !== false) {
      obj.enableVehicleCounting = message.enableVehicleCounting;
    }
    return obj;
  },

  create(base?: DeepPartial<PersonVehicleDetectionConfig>): PersonVehicleDetectionConfig {
    return PersonVehicleDetectionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PersonVehicleDetectionConfig>): PersonVehicleDetectionConfig {
    const message = createBasePersonVehicleDetectionConfig();
    message.enablePeopleCounting = object.enablePeopleCounting ?? false;
    message.enableVehicleCounting = object.enableVehicleCounting ?? false;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionConfig(): PersonalProtectiveEquipmentDetectionConfig {
  return {
    enableFaceCoverageDetection: false,
    enableHeadCoverageDetection: false,
    enableHandsCoverageDetection: false,
  };
}

export const PersonalProtectiveEquipmentDetectionConfig: MessageFns<PersonalProtectiveEquipmentDetectionConfig> = {
  encode(message: PersonalProtectiveEquipmentDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableFaceCoverageDetection !== false) {
      writer.uint32(8).bool(message.enableFaceCoverageDetection);
    }
    if (message.enableHeadCoverageDetection !== false) {
      writer.uint32(16).bool(message.enableHeadCoverageDetection);
    }
    if (message.enableHandsCoverageDetection !== false) {
      writer.uint32(24).bool(message.enableHandsCoverageDetection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableFaceCoverageDetection = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableHeadCoverageDetection = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableHandsCoverageDetection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionConfig {
    return {
      enableFaceCoverageDetection: isSet(object.enableFaceCoverageDetection)
        ? globalThis.Boolean(object.enableFaceCoverageDetection)
        : false,
      enableHeadCoverageDetection: isSet(object.enableHeadCoverageDetection)
        ? globalThis.Boolean(object.enableHeadCoverageDetection)
        : false,
      enableHandsCoverageDetection: isSet(object.enableHandsCoverageDetection)
        ? globalThis.Boolean(object.enableHandsCoverageDetection)
        : false,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionConfig): unknown {
    const obj: any = {};
    if (message.enableFaceCoverageDetection !== false) {
      obj.enableFaceCoverageDetection = message.enableFaceCoverageDetection;
    }
    if (message.enableHeadCoverageDetection !== false) {
      obj.enableHeadCoverageDetection = message.enableHeadCoverageDetection;
    }
    if (message.enableHandsCoverageDetection !== false) {
      obj.enableHandsCoverageDetection = message.enableHandsCoverageDetection;
    }
    return obj;
  },

  create(base?: DeepPartial<PersonalProtectiveEquipmentDetectionConfig>): PersonalProtectiveEquipmentDetectionConfig {
    return PersonalProtectiveEquipmentDetectionConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionConfig>,
  ): PersonalProtectiveEquipmentDetectionConfig {
    const message = createBasePersonalProtectiveEquipmentDetectionConfig();
    message.enableFaceCoverageDetection = object.enableFaceCoverageDetection ?? false;
    message.enableHeadCoverageDetection = object.enableHeadCoverageDetection ?? false;
    message.enableHandsCoverageDetection = object.enableHandsCoverageDetection ?? false;
    return message;
  },
};

function createBaseGeneralObjectDetectionConfig(): GeneralObjectDetectionConfig {
  return {};
}

export const GeneralObjectDetectionConfig: MessageFns<GeneralObjectDetectionConfig> = {
  encode(_: GeneralObjectDetectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneralObjectDetectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneralObjectDetectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GeneralObjectDetectionConfig {
    return {};
  },

  toJSON(_: GeneralObjectDetectionConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GeneralObjectDetectionConfig>): GeneralObjectDetectionConfig {
    return GeneralObjectDetectionConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GeneralObjectDetectionConfig>): GeneralObjectDetectionConfig {
    const message = createBaseGeneralObjectDetectionConfig();
    return message;
  },
};

function createBaseBigQueryConfig(): BigQueryConfig {
  return { table: "", cloudFunctionMapping: {}, createDefaultTableIfNotExists: false };
}

export const BigQueryConfig: MessageFns<BigQueryConfig> = {
  encode(message: BigQueryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    Object.entries(message.cloudFunctionMapping).forEach(([key, value]) => {
      BigQueryConfig_CloudFunctionMappingEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.createDefaultTableIfNotExists !== false) {
      writer.uint32(24).bool(message.createDefaultTableIfNotExists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = BigQueryConfig_CloudFunctionMappingEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.cloudFunctionMapping[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createDefaultTableIfNotExists = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQueryConfig {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      cloudFunctionMapping: isObject(object.cloudFunctionMapping)
        ? Object.entries(object.cloudFunctionMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createDefaultTableIfNotExists: isSet(object.createDefaultTableIfNotExists)
        ? globalThis.Boolean(object.createDefaultTableIfNotExists)
        : false,
    };
  },

  toJSON(message: BigQueryConfig): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.cloudFunctionMapping) {
      const entries = Object.entries(message.cloudFunctionMapping);
      if (entries.length > 0) {
        obj.cloudFunctionMapping = {};
        entries.forEach(([k, v]) => {
          obj.cloudFunctionMapping[k] = v;
        });
      }
    }
    if (message.createDefaultTableIfNotExists !== false) {
      obj.createDefaultTableIfNotExists = message.createDefaultTableIfNotExists;
    }
    return obj;
  },

  create(base?: DeepPartial<BigQueryConfig>): BigQueryConfig {
    return BigQueryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigQueryConfig>): BigQueryConfig {
    const message = createBaseBigQueryConfig();
    message.table = object.table ?? "";
    message.cloudFunctionMapping = Object.entries(object.cloudFunctionMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createDefaultTableIfNotExists = object.createDefaultTableIfNotExists ?? false;
    return message;
  },
};

function createBaseBigQueryConfig_CloudFunctionMappingEntry(): BigQueryConfig_CloudFunctionMappingEntry {
  return { key: "", value: "" };
}

export const BigQueryConfig_CloudFunctionMappingEntry: MessageFns<BigQueryConfig_CloudFunctionMappingEntry> = {
  encode(message: BigQueryConfig_CloudFunctionMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryConfig_CloudFunctionMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryConfig_CloudFunctionMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQueryConfig_CloudFunctionMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BigQueryConfig_CloudFunctionMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BigQueryConfig_CloudFunctionMappingEntry>): BigQueryConfig_CloudFunctionMappingEntry {
    return BigQueryConfig_CloudFunctionMappingEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigQueryConfig_CloudFunctionMappingEntry>): BigQueryConfig_CloudFunctionMappingEntry {
    const message = createBaseBigQueryConfig_CloudFunctionMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVertexAutoMLVisionConfig(): VertexAutoMLVisionConfig {
  return { confidenceThreshold: 0, maxPredictions: 0 };
}

export const VertexAutoMLVisionConfig: MessageFns<VertexAutoMLVisionConfig> = {
  encode(message: VertexAutoMLVisionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceThreshold !== 0) {
      writer.uint32(13).float(message.confidenceThreshold);
    }
    if (message.maxPredictions !== 0) {
      writer.uint32(16).int32(message.maxPredictions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAutoMLVisionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAutoMLVisionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidenceThreshold = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxPredictions = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAutoMLVisionConfig {
    return {
      confidenceThreshold: isSet(object.confidenceThreshold) ? globalThis.Number(object.confidenceThreshold) : 0,
      maxPredictions: isSet(object.maxPredictions) ? globalThis.Number(object.maxPredictions) : 0,
    };
  },

  toJSON(message: VertexAutoMLVisionConfig): unknown {
    const obj: any = {};
    if (message.confidenceThreshold !== 0) {
      obj.confidenceThreshold = message.confidenceThreshold;
    }
    if (message.maxPredictions !== 0) {
      obj.maxPredictions = Math.round(message.maxPredictions);
    }
    return obj;
  },

  create(base?: DeepPartial<VertexAutoMLVisionConfig>): VertexAutoMLVisionConfig {
    return VertexAutoMLVisionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexAutoMLVisionConfig>): VertexAutoMLVisionConfig {
    const message = createBaseVertexAutoMLVisionConfig();
    message.confidenceThreshold = object.confidenceThreshold ?? 0;
    message.maxPredictions = object.maxPredictions ?? 0;
    return message;
  },
};

function createBaseVertexAutoMLVideoConfig(): VertexAutoMLVideoConfig {
  return { confidenceThreshold: 0, blockedLabels: [], maxPredictions: 0, boundingBoxSizeLimit: 0 };
}

export const VertexAutoMLVideoConfig: MessageFns<VertexAutoMLVideoConfig> = {
  encode(message: VertexAutoMLVideoConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceThreshold !== 0) {
      writer.uint32(13).float(message.confidenceThreshold);
    }
    for (const v of message.blockedLabels) {
      writer.uint32(18).string(v!);
    }
    if (message.maxPredictions !== 0) {
      writer.uint32(24).int32(message.maxPredictions);
    }
    if (message.boundingBoxSizeLimit !== 0) {
      writer.uint32(37).float(message.boundingBoxSizeLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexAutoMLVideoConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexAutoMLVideoConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidenceThreshold = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockedLabels.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxPredictions = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.boundingBoxSizeLimit = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexAutoMLVideoConfig {
    return {
      confidenceThreshold: isSet(object.confidenceThreshold) ? globalThis.Number(object.confidenceThreshold) : 0,
      blockedLabels: globalThis.Array.isArray(object?.blockedLabels)
        ? object.blockedLabels.map((e: any) => globalThis.String(e))
        : [],
      maxPredictions: isSet(object.maxPredictions) ? globalThis.Number(object.maxPredictions) : 0,
      boundingBoxSizeLimit: isSet(object.boundingBoxSizeLimit) ? globalThis.Number(object.boundingBoxSizeLimit) : 0,
    };
  },

  toJSON(message: VertexAutoMLVideoConfig): unknown {
    const obj: any = {};
    if (message.confidenceThreshold !== 0) {
      obj.confidenceThreshold = message.confidenceThreshold;
    }
    if (message.blockedLabels?.length) {
      obj.blockedLabels = message.blockedLabels;
    }
    if (message.maxPredictions !== 0) {
      obj.maxPredictions = Math.round(message.maxPredictions);
    }
    if (message.boundingBoxSizeLimit !== 0) {
      obj.boundingBoxSizeLimit = message.boundingBoxSizeLimit;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexAutoMLVideoConfig>): VertexAutoMLVideoConfig {
    return VertexAutoMLVideoConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexAutoMLVideoConfig>): VertexAutoMLVideoConfig {
    const message = createBaseVertexAutoMLVideoConfig();
    message.confidenceThreshold = object.confidenceThreshold ?? 0;
    message.blockedLabels = object.blockedLabels?.map((e) => e) || [];
    message.maxPredictions = object.maxPredictions ?? 0;
    message.boundingBoxSizeLimit = object.boundingBoxSizeLimit ?? 0;
    return message;
  },
};

function createBaseVertexCustomConfig(): VertexCustomConfig {
  return {
    maxPredictionFps: 0,
    dedicatedResources: undefined,
    postProcessingCloudFunction: "",
    attachApplicationMetadata: false,
    dynamicConfigInputTopic: undefined,
  };
}

export const VertexCustomConfig: MessageFns<VertexCustomConfig> = {
  encode(message: VertexCustomConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPredictionFps !== 0) {
      writer.uint32(8).int32(message.maxPredictionFps);
    }
    if (message.dedicatedResources !== undefined) {
      DedicatedResources.encode(message.dedicatedResources, writer.uint32(18).fork()).join();
    }
    if (message.postProcessingCloudFunction !== "") {
      writer.uint32(26).string(message.postProcessingCloudFunction);
    }
    if (message.attachApplicationMetadata !== false) {
      writer.uint32(32).bool(message.attachApplicationMetadata);
    }
    if (message.dynamicConfigInputTopic !== undefined) {
      writer.uint32(50).string(message.dynamicConfigInputTopic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VertexCustomConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexCustomConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxPredictionFps = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dedicatedResources = DedicatedResources.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postProcessingCloudFunction = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attachApplicationMetadata = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dynamicConfigInputTopic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexCustomConfig {
    return {
      maxPredictionFps: isSet(object.maxPredictionFps) ? globalThis.Number(object.maxPredictionFps) : 0,
      dedicatedResources: isSet(object.dedicatedResources)
        ? DedicatedResources.fromJSON(object.dedicatedResources)
        : undefined,
      postProcessingCloudFunction: isSet(object.postProcessingCloudFunction)
        ? globalThis.String(object.postProcessingCloudFunction)
        : "",
      attachApplicationMetadata: isSet(object.attachApplicationMetadata)
        ? globalThis.Boolean(object.attachApplicationMetadata)
        : false,
      dynamicConfigInputTopic: isSet(object.dynamicConfigInputTopic)
        ? globalThis.String(object.dynamicConfigInputTopic)
        : undefined,
    };
  },

  toJSON(message: VertexCustomConfig): unknown {
    const obj: any = {};
    if (message.maxPredictionFps !== 0) {
      obj.maxPredictionFps = Math.round(message.maxPredictionFps);
    }
    if (message.dedicatedResources !== undefined) {
      obj.dedicatedResources = DedicatedResources.toJSON(message.dedicatedResources);
    }
    if (message.postProcessingCloudFunction !== "") {
      obj.postProcessingCloudFunction = message.postProcessingCloudFunction;
    }
    if (message.attachApplicationMetadata !== false) {
      obj.attachApplicationMetadata = message.attachApplicationMetadata;
    }
    if (message.dynamicConfigInputTopic !== undefined) {
      obj.dynamicConfigInputTopic = message.dynamicConfigInputTopic;
    }
    return obj;
  },

  create(base?: DeepPartial<VertexCustomConfig>): VertexCustomConfig {
    return VertexCustomConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VertexCustomConfig>): VertexCustomConfig {
    const message = createBaseVertexCustomConfig();
    message.maxPredictionFps = object.maxPredictionFps ?? 0;
    message.dedicatedResources = (object.dedicatedResources !== undefined && object.dedicatedResources !== null)
      ? DedicatedResources.fromPartial(object.dedicatedResources)
      : undefined;
    message.postProcessingCloudFunction = object.postProcessingCloudFunction ?? "";
    message.attachApplicationMetadata = object.attachApplicationMetadata ?? false;
    message.dynamicConfigInputTopic = object.dynamicConfigInputTopic ?? undefined;
    return message;
  },
};

function createBaseGcsOutputConfig(): GcsOutputConfig {
  return { gcsPath: "" };
}

export const GcsOutputConfig: MessageFns<GcsOutputConfig> = {
  encode(message: GcsOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsPath !== "") {
      writer.uint32(10).string(message.gcsPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsOutputConfig {
    return { gcsPath: isSet(object.gcsPath) ? globalThis.String(object.gcsPath) : "" };
  },

  toJSON(message: GcsOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsPath !== "") {
      obj.gcsPath = message.gcsPath;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsOutputConfig>): GcsOutputConfig {
    return GcsOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsOutputConfig>): GcsOutputConfig {
    const message = createBaseGcsOutputConfig();
    message.gcsPath = object.gcsPath ?? "";
    return message;
  },
};

function createBaseUniversalInputConfig(): UniversalInputConfig {
  return {};
}

export const UniversalInputConfig: MessageFns<UniversalInputConfig> = {
  encode(_: UniversalInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UniversalInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUniversalInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UniversalInputConfig {
    return {};
  },

  toJSON(_: UniversalInputConfig): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UniversalInputConfig>): UniversalInputConfig {
    return UniversalInputConfig.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UniversalInputConfig>): UniversalInputConfig {
    const message = createBaseUniversalInputConfig();
    return message;
  },
};

function createBaseMachineSpec(): MachineSpec {
  return { machineType: "", acceleratorType: 0, acceleratorCount: 0 };
}

export const MachineSpec: MessageFns<MachineSpec> = {
  encode(message: MachineSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.acceleratorType !== 0) {
      writer.uint32(16).int32(message.acceleratorType);
    }
    if (message.acceleratorCount !== 0) {
      writer.uint32(24).int32(message.acceleratorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.acceleratorType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.acceleratorCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineSpec {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      acceleratorType: isSet(object.acceleratorType) ? acceleratorTypeFromJSON(object.acceleratorType) : 0,
      acceleratorCount: isSet(object.acceleratorCount) ? globalThis.Number(object.acceleratorCount) : 0,
    };
  },

  toJSON(message: MachineSpec): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.acceleratorType !== 0) {
      obj.acceleratorType = acceleratorTypeToJSON(message.acceleratorType);
    }
    if (message.acceleratorCount !== 0) {
      obj.acceleratorCount = Math.round(message.acceleratorCount);
    }
    return obj;
  },

  create(base?: DeepPartial<MachineSpec>): MachineSpec {
    return MachineSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineSpec>): MachineSpec {
    const message = createBaseMachineSpec();
    message.machineType = object.machineType ?? "";
    message.acceleratorType = object.acceleratorType ?? 0;
    message.acceleratorCount = object.acceleratorCount ?? 0;
    return message;
  },
};

function createBaseAutoscalingMetricSpec(): AutoscalingMetricSpec {
  return { metricName: "", target: 0 };
}

export const AutoscalingMetricSpec: MessageFns<AutoscalingMetricSpec> = {
  encode(message: AutoscalingMetricSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.target !== 0) {
      writer.uint32(16).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingMetricSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingMetricSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.target = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingMetricSpec {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      target: isSet(object.target) ? globalThis.Number(object.target) : 0,
    };
  },

  toJSON(message: AutoscalingMetricSpec): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.target !== 0) {
      obj.target = Math.round(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingMetricSpec>): AutoscalingMetricSpec {
    return AutoscalingMetricSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingMetricSpec>): AutoscalingMetricSpec {
    const message = createBaseAutoscalingMetricSpec();
    message.metricName = object.metricName ?? "";
    message.target = object.target ?? 0;
    return message;
  },
};

function createBaseDedicatedResources(): DedicatedResources {
  return { machineSpec: undefined, minReplicaCount: 0, maxReplicaCount: 0, autoscalingMetricSpecs: [] };
}

export const DedicatedResources: MessageFns<DedicatedResources> = {
  encode(message: DedicatedResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineSpec !== undefined) {
      MachineSpec.encode(message.machineSpec, writer.uint32(10).fork()).join();
    }
    if (message.minReplicaCount !== 0) {
      writer.uint32(16).int32(message.minReplicaCount);
    }
    if (message.maxReplicaCount !== 0) {
      writer.uint32(24).int32(message.maxReplicaCount);
    }
    for (const v of message.autoscalingMetricSpecs) {
      AutoscalingMetricSpec.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DedicatedResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDedicatedResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineSpec = MachineSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minReplicaCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxReplicaCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.autoscalingMetricSpecs.push(AutoscalingMetricSpec.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DedicatedResources {
    return {
      machineSpec: isSet(object.machineSpec) ? MachineSpec.fromJSON(object.machineSpec) : undefined,
      minReplicaCount: isSet(object.minReplicaCount) ? globalThis.Number(object.minReplicaCount) : 0,
      maxReplicaCount: isSet(object.maxReplicaCount) ? globalThis.Number(object.maxReplicaCount) : 0,
      autoscalingMetricSpecs: globalThis.Array.isArray(object?.autoscalingMetricSpecs)
        ? object.autoscalingMetricSpecs.map((e: any) => AutoscalingMetricSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DedicatedResources): unknown {
    const obj: any = {};
    if (message.machineSpec !== undefined) {
      obj.machineSpec = MachineSpec.toJSON(message.machineSpec);
    }
    if (message.minReplicaCount !== 0) {
      obj.minReplicaCount = Math.round(message.minReplicaCount);
    }
    if (message.maxReplicaCount !== 0) {
      obj.maxReplicaCount = Math.round(message.maxReplicaCount);
    }
    if (message.autoscalingMetricSpecs?.length) {
      obj.autoscalingMetricSpecs = message.autoscalingMetricSpecs.map((e) => AutoscalingMetricSpec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DedicatedResources>): DedicatedResources {
    return DedicatedResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DedicatedResources>): DedicatedResources {
    const message = createBaseDedicatedResources();
    message.machineSpec = (object.machineSpec !== undefined && object.machineSpec !== null)
      ? MachineSpec.fromPartial(object.machineSpec)
      : undefined;
    message.minReplicaCount = object.minReplicaCount ?? 0;
    message.maxReplicaCount = object.maxReplicaCount ?? 0;
    message.autoscalingMetricSpecs = object.autoscalingMetricSpecs?.map((e) => AutoscalingMetricSpec.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseProductRecognizerConfig(): ProductRecognizerConfig {
  return { retailEndpoint: "", recognitionConfidenceThreshold: 0 };
}

export const ProductRecognizerConfig: MessageFns<ProductRecognizerConfig> = {
  encode(message: ProductRecognizerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retailEndpoint !== "") {
      writer.uint32(10).string(message.retailEndpoint);
    }
    if (message.recognitionConfidenceThreshold !== 0) {
      writer.uint32(21).float(message.recognitionConfidenceThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductRecognizerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductRecognizerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retailEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.recognitionConfidenceThreshold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductRecognizerConfig {
    return {
      retailEndpoint: isSet(object.retailEndpoint) ? globalThis.String(object.retailEndpoint) : "",
      recognitionConfidenceThreshold: isSet(object.recognitionConfidenceThreshold)
        ? globalThis.Number(object.recognitionConfidenceThreshold)
        : 0,
    };
  },

  toJSON(message: ProductRecognizerConfig): unknown {
    const obj: any = {};
    if (message.retailEndpoint !== "") {
      obj.retailEndpoint = message.retailEndpoint;
    }
    if (message.recognitionConfidenceThreshold !== 0) {
      obj.recognitionConfidenceThreshold = message.recognitionConfidenceThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductRecognizerConfig>): ProductRecognizerConfig {
    return ProductRecognizerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductRecognizerConfig>): ProductRecognizerConfig {
    const message = createBaseProductRecognizerConfig();
    message.retailEndpoint = object.retailEndpoint ?? "";
    message.recognitionConfidenceThreshold = object.recognitionConfidenceThreshold ?? 0;
    return message;
  },
};

function createBaseTagRecognizerConfig(): TagRecognizerConfig {
  return { entityDetectionConfidenceThreshold: 0, tagParsingConfig: undefined };
}

export const TagRecognizerConfig: MessageFns<TagRecognizerConfig> = {
  encode(message: TagRecognizerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityDetectionConfidenceThreshold !== 0) {
      writer.uint32(13).float(message.entityDetectionConfidenceThreshold);
    }
    if (message.tagParsingConfig !== undefined) {
      TagParsingConfig.encode(message.tagParsingConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagRecognizerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagRecognizerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.entityDetectionConfidenceThreshold = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tagParsingConfig = TagParsingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagRecognizerConfig {
    return {
      entityDetectionConfidenceThreshold: isSet(object.entityDetectionConfidenceThreshold)
        ? globalThis.Number(object.entityDetectionConfidenceThreshold)
        : 0,
      tagParsingConfig: isSet(object.tagParsingConfig) ? TagParsingConfig.fromJSON(object.tagParsingConfig) : undefined,
    };
  },

  toJSON(message: TagRecognizerConfig): unknown {
    const obj: any = {};
    if (message.entityDetectionConfidenceThreshold !== 0) {
      obj.entityDetectionConfidenceThreshold = message.entityDetectionConfidenceThreshold;
    }
    if (message.tagParsingConfig !== undefined) {
      obj.tagParsingConfig = TagParsingConfig.toJSON(message.tagParsingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<TagRecognizerConfig>): TagRecognizerConfig {
    return TagRecognizerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagRecognizerConfig>): TagRecognizerConfig {
    const message = createBaseTagRecognizerConfig();
    message.entityDetectionConfidenceThreshold = object.entityDetectionConfidenceThreshold ?? 0;
    message.tagParsingConfig = (object.tagParsingConfig !== undefined && object.tagParsingConfig !== null)
      ? TagParsingConfig.fromPartial(object.tagParsingConfig)
      : undefined;
    return message;
  },
};

function createBaseTagParsingConfig(): TagParsingConfig {
  return { entityParsingConfigs: [] };
}

export const TagParsingConfig: MessageFns<TagParsingConfig> = {
  encode(message: TagParsingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entityParsingConfigs) {
      TagParsingConfig_EntityParsingConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagParsingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagParsingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityParsingConfigs.push(TagParsingConfig_EntityParsingConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagParsingConfig {
    return {
      entityParsingConfigs: globalThis.Array.isArray(object?.entityParsingConfigs)
        ? object.entityParsingConfigs.map((e: any) => TagParsingConfig_EntityParsingConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TagParsingConfig): unknown {
    const obj: any = {};
    if (message.entityParsingConfigs?.length) {
      obj.entityParsingConfigs = message.entityParsingConfigs.map((e) =>
        TagParsingConfig_EntityParsingConfig.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TagParsingConfig>): TagParsingConfig {
    return TagParsingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagParsingConfig>): TagParsingConfig {
    const message = createBaseTagParsingConfig();
    message.entityParsingConfigs =
      object.entityParsingConfigs?.map((e) => TagParsingConfig_EntityParsingConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTagParsingConfig_EntityParsingConfig(): TagParsingConfig_EntityParsingConfig {
  return { entityClass: "", regex: "", entityMatchingStrategy: 0 };
}

export const TagParsingConfig_EntityParsingConfig: MessageFns<TagParsingConfig_EntityParsingConfig> = {
  encode(message: TagParsingConfig_EntityParsingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityClass !== "") {
      writer.uint32(10).string(message.entityClass);
    }
    if (message.regex !== "") {
      writer.uint32(18).string(message.regex);
    }
    if (message.entityMatchingStrategy !== 0) {
      writer.uint32(24).int32(message.entityMatchingStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagParsingConfig_EntityParsingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagParsingConfig_EntityParsingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityClass = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regex = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityMatchingStrategy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagParsingConfig_EntityParsingConfig {
    return {
      entityClass: isSet(object.entityClass) ? globalThis.String(object.entityClass) : "",
      regex: isSet(object.regex) ? globalThis.String(object.regex) : "",
      entityMatchingStrategy: isSet(object.entityMatchingStrategy)
        ? tagParsingConfig_EntityParsingConfig_EntityMatchingStrategyFromJSON(object.entityMatchingStrategy)
        : 0,
    };
  },

  toJSON(message: TagParsingConfig_EntityParsingConfig): unknown {
    const obj: any = {};
    if (message.entityClass !== "") {
      obj.entityClass = message.entityClass;
    }
    if (message.regex !== "") {
      obj.regex = message.regex;
    }
    if (message.entityMatchingStrategy !== 0) {
      obj.entityMatchingStrategy = tagParsingConfig_EntityParsingConfig_EntityMatchingStrategyToJSON(
        message.entityMatchingStrategy,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TagParsingConfig_EntityParsingConfig>): TagParsingConfig_EntityParsingConfig {
    return TagParsingConfig_EntityParsingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagParsingConfig_EntityParsingConfig>): TagParsingConfig_EntityParsingConfig {
    const message = createBaseTagParsingConfig_EntityParsingConfig();
    message.entityClass = object.entityClass ?? "";
    message.regex = object.regex ?? "";
    message.entityMatchingStrategy = object.entityMatchingStrategy ?? 0;
    return message;
  },
};

/** Service describing handlers for resources */
export type AppPlatformDefinition = typeof AppPlatformDefinition;
export const AppPlatformDefinition = {
  name: "AppPlatform",
  fullName: "google.cloud.visionai.v1.AppPlatform",
  methods: {
    /** Lists Applications in a given project and location. */
    listApplications: {
      name: "ListApplications",
      requestType: ListApplicationsRequest,
      requestStream: false,
      responseType: ListApplicationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Application. */
    getApplication: {
      name: "GetApplication",
      requestType: GetApplicationRequest,
      requestStream: false,
      responseType: Application,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Application in a given project and location. */
    createApplication: {
      name: "CreateApplication",
      requestType: CreateApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              11,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Application. */
    updateApplication: {
      name: "UpdateApplication",
      requestType: UpdateApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              11,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              50,
              60,
              47,
              118,
              49,
              47,
              123,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Application. */
    deleteApplication: {
      name: "DeleteApplication",
      requestType: DeleteApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deploys a single Application. */
    deployApplication: {
      name: "DeployApplication",
      requestType: DeployApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              25,
              68,
              101,
              112,
              108,
              111,
              121,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              112,
              108,
              111,
              121,
            ]),
          ],
        },
      },
    },
    /** Undeploys a single Application. */
    undeployApplication: {
      name: "UndeployApplication",
      requestType: UndeployApplicationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              27,
              85,
              110,
              100,
              101,
              112,
              108,
              111,
              121,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              112,
              108,
              111,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Adds target stream input to the Application.
     * If the Application is deployed, the corresponding new Application instance
     * will be created. If the stream has already been in the Application, the RPC
     * will fail.
     */
    addApplicationStreamInput: {
      name: "AddApplicationStreamInput",
      requestType: AddApplicationStreamInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              54,
              10,
              33,
              65,
              100,
              100,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Remove target stream input to the Application, if the Application is
     * deployed, the corresponding instance based will be deleted. If the stream
     * is not in the Application, the RPC will fail.
     */
    removeApplicationStreamInput: {
      name: "RemoveApplicationStreamInput",
      requestType: RemoveApplicationStreamInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              57,
              10,
              36,
              82,
              101,
              109,
              111,
              118,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Update target stream input to the Application, if the Application is
     * deployed, the corresponding instance based will be deployed. For
     * CreateOrUpdate behavior, set allow_missing to true.
     */
    updateApplicationStreamInput: {
      name: "UpdateApplicationStreamInput",
      requestType: UpdateApplicationStreamInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              57,
              10,
              36,
              85,
              112,
              100,
              97,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              83,
              116,
              114,
              101,
              97,
              109,
              73,
              110,
              112,
              117,
              116,
            ]),
          ],
        },
      },
    },
    /** Lists Instances in a given project and location. */
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Instance. */
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Adds target stream input to the Application.
     * If the Application is deployed, the corresponding new Application instance
     * will be created. If the stream has already been in the Application, the RPC
     * will fail.
     */
    createApplicationInstances: {
      name: "CreateApplicationInstances",
      requestType: CreateApplicationInstancesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              55,
              10,
              34,
              67,
              114,
              101,
              97,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              114,
              101,
              97,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Remove target stream input to the Application, if the Application is
     * deployed, the corresponding instance based will be deleted. If the stream
     * is not in the Application, the RPC will fail.
     */
    deleteApplicationInstances: {
      name: "DeleteApplicationInstances",
      requestType: DeleteApplicationInstancesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              29,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              108,
              101,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Adds target stream input to the Application.
     * If the Application is deployed, the corresponding new Application instance
     * will be created. If the stream has already been in the Application, the RPC
     * will fail.
     */
    updateApplicationInstances: {
      name: "UpdateApplicationInstances",
      requestType: UpdateApplicationInstancesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              55,
              10,
              34,
              85,
              112,
              100,
              97,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              110,
              97,
              109,
              101,
              44,
              32,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              65,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists Drafts in a given project and location. */
    listDrafts: {
      name: "ListDrafts",
      requestType: ListDraftsRequest,
      requestStream: false,
      responseType: ListDraftsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              114,
              97,
              102,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Draft. */
    getDraft: {
      name: "GetDraft",
      requestType: GetDraftRequest,
      requestStream: false,
      responseType: Draft,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              114,
              97,
              102,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Draft in a given project and location. */
    createDraft: {
      name: "CreateDraft",
      requestType: CreateDraftRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              68,
              114,
              97,
              102,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              114,
              97,
              102,
              116,
              44,
              100,
              114,
              97,
              102,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              5,
              100,
              114,
              97,
              102,
              116,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              114,
              97,
              102,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Draft. */
    updateDraft: {
      name: "UpdateDraft",
      requestType: UpdateDraftRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              68,
              114,
              97,
              102,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 100, 114, 97, 102, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              72,
              58,
              5,
              100,
              114,
              97,
              102,
              116,
              50,
              63,
              47,
              118,
              49,
              47,
              123,
              100,
              114,
              97,
              102,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              114,
              97,
              102,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Draft. */
    deleteDraft: {
      name: "DeleteDraft",
      requestType: DeleteDraftRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              114,
              97,
              102,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Processors in a given project and location. */
    listProcessors: {
      name: "ListProcessors",
      requestType: ListProcessorsRequest,
      requestStream: false,
      responseType: ListProcessorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * ListPrebuiltProcessors is a custom pass-through verb that Lists Prebuilt
     * Processors.
     */
    listPrebuiltProcessors: {
      name: "ListPrebuiltProcessors",
      requestType: ListPrebuiltProcessorsRequest,
      requestStream: false,
      responseType: ListPrebuiltProcessorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
              58,
              112,
              114,
              101,
              98,
              117,
              105,
              108,
              116,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Processor. */
    getProcessor: {
      name: "GetProcessor",
      requestType: GetProcessorRequest,
      requestStream: false,
      responseType: Processor,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Processor in a given project and location. */
    createProcessor: {
      name: "CreateProcessor",
      requestType: CreateProcessorRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              44,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              59,
              58,
              9,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Processor. */
    updateProcessor: {
      name: "UpdateProcessor",
      requestType: UpdateProcessorRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              9,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              50,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Processor. */
    deleteProcessor: {
      name: "DeleteProcessor",
      requestType: DeleteProcessorRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AppPlatformServiceImplementation<CallContextExt = {}> {
  /** Lists Applications in a given project and location. */
  listApplications(
    request: ListApplicationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListApplicationsResponse>>;
  /** Gets details of a single Application. */
  getApplication(
    request: GetApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Application>>;
  /** Creates a new Application in a given project and location. */
  createApplication(
    request: CreateApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Application. */
  updateApplication(
    request: UpdateApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single Application. */
  deleteApplication(
    request: DeleteApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deploys a single Application. */
  deployApplication(
    request: DeployApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Undeploys a single Application. */
  undeployApplication(
    request: UndeployApplicationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  addApplicationStreamInput(
    request: AddApplicationStreamInputRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Remove target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deleted. If the stream
   * is not in the Application, the RPC will fail.
   */
  removeApplicationStreamInput(
    request: RemoveApplicationStreamInputRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Update target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deployed. For
   * CreateOrUpdate behavior, set allow_missing to true.
   */
  updateApplicationStreamInput(
    request: UpdateApplicationStreamInputRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Instances in a given project and location. */
  listInstances(
    request: ListInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancesResponse>>;
  /** Gets details of a single Instance. */
  getInstance(request: GetInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Instance>>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  createApplicationInstances(
    request: CreateApplicationInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Remove target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deleted. If the stream
   * is not in the Application, the RPC will fail.
   */
  deleteApplicationInstances(
    request: DeleteApplicationInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  updateApplicationInstances(
    request: UpdateApplicationInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Drafts in a given project and location. */
  listDrafts(
    request: ListDraftsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDraftsResponse>>;
  /** Gets details of a single Draft. */
  getDraft(request: GetDraftRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Draft>>;
  /** Creates a new Draft in a given project and location. */
  createDraft(request: CreateDraftRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Draft. */
  updateDraft(request: UpdateDraftRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Draft. */
  deleteDraft(request: DeleteDraftRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists Processors in a given project and location. */
  listProcessors(
    request: ListProcessorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProcessorsResponse>>;
  /**
   * ListPrebuiltProcessors is a custom pass-through verb that Lists Prebuilt
   * Processors.
   */
  listPrebuiltProcessors(
    request: ListPrebuiltProcessorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPrebuiltProcessorsResponse>>;
  /** Gets details of a single Processor. */
  getProcessor(request: GetProcessorRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Processor>>;
  /** Creates a new Processor in a given project and location. */
  createProcessor(
    request: CreateProcessorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Processor. */
  updateProcessor(
    request: UpdateProcessorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single Processor. */
  deleteProcessor(
    request: DeleteProcessorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface AppPlatformClient<CallOptionsExt = {}> {
  /** Lists Applications in a given project and location. */
  listApplications(
    request: DeepPartial<ListApplicationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListApplicationsResponse>;
  /** Gets details of a single Application. */
  getApplication(
    request: DeepPartial<GetApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Application>;
  /** Creates a new Application in a given project and location. */
  createApplication(
    request: DeepPartial<CreateApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single Application. */
  updateApplication(
    request: DeepPartial<UpdateApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single Application. */
  deleteApplication(
    request: DeepPartial<DeleteApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deploys a single Application. */
  deployApplication(
    request: DeepPartial<DeployApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Undeploys a single Application. */
  undeployApplication(
    request: DeepPartial<UndeployApplicationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  addApplicationStreamInput(
    request: DeepPartial<AddApplicationStreamInputRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Remove target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deleted. If the stream
   * is not in the Application, the RPC will fail.
   */
  removeApplicationStreamInput(
    request: DeepPartial<RemoveApplicationStreamInputRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Update target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deployed. For
   * CreateOrUpdate behavior, set allow_missing to true.
   */
  updateApplicationStreamInput(
    request: DeepPartial<UpdateApplicationStreamInputRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Instances in a given project and location. */
  listInstances(
    request: DeepPartial<ListInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancesResponse>;
  /** Gets details of a single Instance. */
  getInstance(request: DeepPartial<GetInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Instance>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  createApplicationInstances(
    request: DeepPartial<CreateApplicationInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Remove target stream input to the Application, if the Application is
   * deployed, the corresponding instance based will be deleted. If the stream
   * is not in the Application, the RPC will fail.
   */
  deleteApplicationInstances(
    request: DeepPartial<DeleteApplicationInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Adds target stream input to the Application.
   * If the Application is deployed, the corresponding new Application instance
   * will be created. If the stream has already been in the Application, the RPC
   * will fail.
   */
  updateApplicationInstances(
    request: DeepPartial<UpdateApplicationInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Drafts in a given project and location. */
  listDrafts(
    request: DeepPartial<ListDraftsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDraftsResponse>;
  /** Gets details of a single Draft. */
  getDraft(request: DeepPartial<GetDraftRequest>, options?: CallOptions & CallOptionsExt): Promise<Draft>;
  /** Creates a new Draft in a given project and location. */
  createDraft(request: DeepPartial<CreateDraftRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Draft. */
  updateDraft(request: DeepPartial<UpdateDraftRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Draft. */
  deleteDraft(request: DeepPartial<DeleteDraftRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists Processors in a given project and location. */
  listProcessors(
    request: DeepPartial<ListProcessorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProcessorsResponse>;
  /**
   * ListPrebuiltProcessors is a custom pass-through verb that Lists Prebuilt
   * Processors.
   */
  listPrebuiltProcessors(
    request: DeepPartial<ListPrebuiltProcessorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPrebuiltProcessorsResponse>;
  /** Gets details of a single Processor. */
  getProcessor(request: DeepPartial<GetProcessorRequest>, options?: CallOptions & CallOptionsExt): Promise<Processor>;
  /** Creates a new Processor in a given project and location. */
  createProcessor(
    request: DeepPartial<CreateProcessorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single Processor. */
  updateProcessor(
    request: DeepPartial<UpdateProcessorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single Processor. */
  deleteProcessor(
    request: DeepPartial<DeleteProcessorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
