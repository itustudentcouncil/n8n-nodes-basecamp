// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1alpha1/lva.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.visionai.v1alpha1";

/** Represents an actual value of an operator attribute. */
export interface AttributeValue {
  /** int. */
  i?:
    | Long
    | undefined;
  /** float. */
  f?:
    | number
    | undefined;
  /** bool. */
  b?:
    | boolean
    | undefined;
  /** string. */
  s?: Buffer | undefined;
}

/**
 * Defines an Analyzer.
 *
 * An analyzer processes data from its input streams using the logic defined in
 * the Operator that it represents. Of course, it produces data for the output
 * streams declared in the Operator.
 */
export interface AnalyzerDefinition {
  /**
   * The name of this analyzer.
   *
   * Tentatively [a-z][a-z0-9]*(_[a-z0-9]+)*.
   */
  analyzer: string;
  /**
   * The name of the operator that this analyzer runs.
   *
   * Must match the name of a supported operator.
   */
  operator: string;
  /** Input streams. */
  inputs: AnalyzerDefinition_StreamInput[];
  /**
   * The attribute values that this analyzer applies to the operator.
   *
   * Supply a mapping between the attribute names and the actual value you wish
   * to apply. If an attribute name is omitted, then it will take a
   * preconfigured default value.
   */
  attrs: { [key: string]: AttributeValue };
  /** Debug options. */
  debugOptions: AnalyzerDefinition_DebugOptions | undefined;
}

/**
 * The inputs to this analyzer.
 *
 * We accept input name references of the following form:
 * <analyzer-name>:<output-argument-name>
 *
 * Example:
 *
 * Suppose you had an operator named "SomeOp" that has 2 output
 * arguments, the first of which is named "foo" and the second of which is
 * named "bar", and an operator named "MyOp" that accepts 2 inputs.
 *
 * Also suppose that there is an analyzer named "some-analyzer" that is
 * running "SomeOp" and another analyzer named "my-analyzer" running "MyOp".
 *
 * To indicate that "my-analyzer" is to consume "some-analyzer"'s "foo"
 * output as its first input and "some-analyzer"'s "bar" output as its
 * second input, you can set this field to the following:
 * input = ["some-analyzer:foo", "some-analyzer:bar"]
 */
export interface AnalyzerDefinition_StreamInput {
  /** The name of the stream input (as discussed above). */
  input: string;
}

/** Options available for debugging purposes only. */
export interface AnalyzerDefinition_DebugOptions {
  /** Environment variables. */
  environmentVariables: { [key: string]: string };
}

export interface AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  key: string;
  value: string;
}

export interface AnalyzerDefinition_AttrsEntry {
  key: string;
  value: AttributeValue | undefined;
}

/**
 * Defines a full analysis.
 *
 * This is a description of the overall live analytics pipeline.
 * You may think of this as an edge list representation of a multigraph.
 *
 * This may be directly authored by a human in protobuf textformat, or it may be
 * generated by a programming API (perhaps Python or JavaScript depending on
 * context).
 */
export interface AnalysisDefinition {
  /** Analyzer definitions. */
  analyzers: AnalyzerDefinition[];
}

function createBaseAttributeValue(): AttributeValue {
  return { i: undefined, f: undefined, b: undefined, s: undefined };
}

export const AttributeValue: MessageFns<AttributeValue> = {
  encode(message: AttributeValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== undefined) {
      writer.uint32(8).int64(message.i.toString());
    }
    if (message.f !== undefined) {
      writer.uint32(21).float(message.f);
    }
    if (message.b !== undefined) {
      writer.uint32(24).bool(message.b);
    }
    if (message.s !== undefined) {
      writer.uint32(34).bytes(message.s);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.i = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.f = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.b = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.s = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      i: isSet(object.i) ? Long.fromValue(object.i) : undefined,
      f: isSet(object.f) ? globalThis.Number(object.f) : undefined,
      b: isSet(object.b) ? globalThis.Boolean(object.b) : undefined,
      s: isSet(object.s) ? Buffer.from(bytesFromBase64(object.s)) : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.i !== undefined) {
      obj.i = (message.i || Long.ZERO).toString();
    }
    if (message.f !== undefined) {
      obj.f = message.f;
    }
    if (message.b !== undefined) {
      obj.b = message.b;
    }
    if (message.s !== undefined) {
      obj.s = base64FromBytes(message.s);
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValue>): AttributeValue {
    return AttributeValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValue>): AttributeValue {
    const message = createBaseAttributeValue();
    message.i = (object.i !== undefined && object.i !== null) ? Long.fromValue(object.i) : undefined;
    message.f = object.f ?? undefined;
    message.b = object.b ?? undefined;
    message.s = object.s ?? undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition(): AnalyzerDefinition {
  return { analyzer: "", operator: "", inputs: [], attrs: {}, debugOptions: undefined };
}

export const AnalyzerDefinition: MessageFns<AnalyzerDefinition> = {
  encode(message: AnalyzerDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.analyzer !== "") {
      writer.uint32(10).string(message.analyzer);
    }
    if (message.operator !== "") {
      writer.uint32(18).string(message.operator);
    }
    for (const v of message.inputs) {
      AnalyzerDefinition_StreamInput.encode(v!, writer.uint32(26).fork()).join();
    }
    Object.entries(message.attrs).forEach(([key, value]) => {
      AnalyzerDefinition_AttrsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.debugOptions !== undefined) {
      AnalyzerDefinition_DebugOptions.encode(message.debugOptions, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analyzer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operator = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputs.push(AnalyzerDefinition_StreamInput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AnalyzerDefinition_AttrsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attrs[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.debugOptions = AnalyzerDefinition_DebugOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition {
    return {
      analyzer: isSet(object.analyzer) ? globalThis.String(object.analyzer) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => AnalyzerDefinition_StreamInput.fromJSON(e))
        : [],
      attrs: isObject(object.attrs)
        ? Object.entries(object.attrs).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      debugOptions: isSet(object.debugOptions)
        ? AnalyzerDefinition_DebugOptions.fromJSON(object.debugOptions)
        : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition): unknown {
    const obj: any = {};
    if (message.analyzer !== "") {
      obj.analyzer = message.analyzer;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => AnalyzerDefinition_StreamInput.toJSON(e));
    }
    if (message.attrs) {
      const entries = Object.entries(message.attrs);
      if (entries.length > 0) {
        obj.attrs = {};
        entries.forEach(([k, v]) => {
          obj.attrs[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.debugOptions !== undefined) {
      obj.debugOptions = AnalyzerDefinition_DebugOptions.toJSON(message.debugOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition>): AnalyzerDefinition {
    return AnalyzerDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition>): AnalyzerDefinition {
    const message = createBaseAnalyzerDefinition();
    message.analyzer = object.analyzer ?? "";
    message.operator = object.operator ?? "";
    message.inputs = object.inputs?.map((e) => AnalyzerDefinition_StreamInput.fromPartial(e)) || [];
    message.attrs = Object.entries(object.attrs ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.debugOptions = (object.debugOptions !== undefined && object.debugOptions !== null)
      ? AnalyzerDefinition_DebugOptions.fromPartial(object.debugOptions)
      : undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition_StreamInput(): AnalyzerDefinition_StreamInput {
  return { input: "" };
}

export const AnalyzerDefinition_StreamInput: MessageFns<AnalyzerDefinition_StreamInput> = {
  encode(message: AnalyzerDefinition_StreamInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_StreamInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_StreamInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_StreamInput {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: AnalyzerDefinition_StreamInput): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_StreamInput>): AnalyzerDefinition_StreamInput {
    return AnalyzerDefinition_StreamInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_StreamInput>): AnalyzerDefinition_StreamInput {
    const message = createBaseAnalyzerDefinition_StreamInput();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions(): AnalyzerDefinition_DebugOptions {
  return { environmentVariables: {} };
}

export const AnalyzerDefinition_DebugOptions: MessageFns<AnalyzerDefinition_DebugOptions> = {
  encode(message: AnalyzerDefinition_DebugOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.environmentVariables).forEach(([key, value]) => {
      AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.environmentVariables[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions {
    return {
      environmentVariables: isObject(object.environmentVariables)
        ? Object.entries(object.environmentVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions): unknown {
    const obj: any = {};
    if (message.environmentVariables) {
      const entries = Object.entries(message.environmentVariables);
      if (entries.length > 0) {
        obj.environmentVariables = {};
        entries.forEach(([k, v]) => {
          obj.environmentVariables[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_DebugOptions>): AnalyzerDefinition_DebugOptions {
    return AnalyzerDefinition_DebugOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_DebugOptions>): AnalyzerDefinition_DebugOptions {
    const message = createBaseAnalyzerDefinition_DebugOptions();
    message.environmentVariables = Object.entries(object.environmentVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry(): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  return { key: "", value: "" };
}

export const AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry: MessageFns<
  AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry
> = {
  encode(
    message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_AttrsEntry(): AnalyzerDefinition_AttrsEntry {
  return { key: "", value: undefined };
}

export const AnalyzerDefinition_AttrsEntry: MessageFns<AnalyzerDefinition_AttrsEntry> = {
  encode(message: AnalyzerDefinition_AttrsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_AttrsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_AttrsEntry>): AnalyzerDefinition_AttrsEntry {
    return AnalyzerDefinition_AttrsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_AttrsEntry>): AnalyzerDefinition_AttrsEntry {
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysisDefinition(): AnalysisDefinition {
  return { analyzers: [] };
}

export const AnalysisDefinition: MessageFns<AnalysisDefinition> = {
  encode(message: AnalysisDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.analyzers) {
      AnalyzerDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analyzers.push(AnalyzerDefinition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisDefinition {
    return {
      analyzers: globalThis.Array.isArray(object?.analyzers)
        ? object.analyzers.map((e: any) => AnalyzerDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalysisDefinition): unknown {
    const obj: any = {};
    if (message.analyzers?.length) {
      obj.analyzers = message.analyzers.map((e) => AnalyzerDefinition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisDefinition>): AnalysisDefinition {
    return AnalysisDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisDefinition>): AnalysisDefinition {
    const message = createBaseAnalysisDefinition();
    message.analyzers = object.analyzers?.map((e) => AnalyzerDefinition.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
