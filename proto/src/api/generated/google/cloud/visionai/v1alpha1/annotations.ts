// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1alpha1/annotations.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue, Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.visionai.v1alpha1";

/** Enum describing all possible types of a stream annotation. */
export enum StreamAnnotationType {
  /** STREAM_ANNOTATION_TYPE_UNSPECIFIED - Type UNSPECIFIED. */
  STREAM_ANNOTATION_TYPE_UNSPECIFIED = 0,
  /**
   * STREAM_ANNOTATION_TYPE_ACTIVE_ZONE - active_zone annotation defines a polygon on top of the content from an
   * image/video based stream, following processing will only focus on the
   * content inside the active zone.
   */
  STREAM_ANNOTATION_TYPE_ACTIVE_ZONE = 1,
  /**
   * STREAM_ANNOTATION_TYPE_CROSSING_LINE - crossing_line annotation defines a polyline on top of the content from an
   * image/video based Vision AI stream, events happening across the line will
   * be captured. For example, the counts of people who goes acroos the line
   * in Occupancy Analytic Processor.
   */
  STREAM_ANNOTATION_TYPE_CROSSING_LINE = 2,
  UNRECOGNIZED = -1,
}

export function streamAnnotationTypeFromJSON(object: any): StreamAnnotationType {
  switch (object) {
    case 0:
    case "STREAM_ANNOTATION_TYPE_UNSPECIFIED":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_ACTIVE_ZONE;
    case 2:
    case "STREAM_ANNOTATION_TYPE_CROSSING_LINE":
      return StreamAnnotationType.STREAM_ANNOTATION_TYPE_CROSSING_LINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamAnnotationType.UNRECOGNIZED;
  }
}

export function streamAnnotationTypeToJSON(object: StreamAnnotationType): string {
  switch (object) {
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_UNSPECIFIED:
      return "STREAM_ANNOTATION_TYPE_UNSPECIFIED";
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_ACTIVE_ZONE:
      return "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE";
    case StreamAnnotationType.STREAM_ANNOTATION_TYPE_CROSSING_LINE:
      return "STREAM_ANNOTATION_TYPE_CROSSING_LINE";
    case StreamAnnotationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Output format for Personal Protective Equipment Detection Operator. */
export interface PersonalProtectiveEquipmentDetectionOutput {
  /** Current timestamp. */
  currentTime:
    | Date
    | undefined;
  /** A list of DetectedPersons. */
  detectedPersons: PersonalProtectiveEquipmentDetectionOutput_DetectedPerson[];
}

/** The entity info for annotations from person detection prediction result. */
export interface PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
  /** Entity id. */
  personEntityId: Long;
}

/** The entity info for annotations from PPE detection prediction result. */
export interface PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
  /** Label id. */
  ppeLabelId: Long;
  /** Human readable string of the label (Examples: helmet, glove, mask). */
  ppeLabelString: string;
  /**
   * Human readable string of the super category label (Examples: head_cover,
   * hands_cover, face_cover).
   */
  ppeSupercategoryLabelString: string;
  /** Entity id. */
  ppeEntityId: Long;
}

/** Bounding Box in the normalized coordinates. */
export interface PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
  /** Min in x coordinate. */
  xmin: number;
  /** Min in y coordinate. */
  ymin: number;
  /** Width of the bounding box. */
  width: number;
  /** Height of the bounding box. */
  height: number;
}

/**
 * PersonIdentified box contains the location and the entity info of the
 * person.
 */
export interface PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
  /** An unique id for this box. */
  boxId: Long;
  /** Bounding Box in the normalized coordinates. */
  normalizedBoundingBox:
    | PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox
    | undefined;
  /** Confidence score associated with this box. */
  confidenceScore: number;
  /** Person entity info. */
  personEntity: PersonalProtectiveEquipmentDetectionOutput_PersonEntity | undefined;
}

/** PPEIdentified box contains the location and the entity info of the PPE. */
export interface PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
  /** An unique id for this box. */
  boxId: Long;
  /** Bounding Box in the normalized coordinates. */
  normalizedBoundingBox:
    | PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox
    | undefined;
  /** Confidence score associated with this box. */
  confidenceScore: number;
  /** PPE entity info. */
  ppeEntity: PersonalProtectiveEquipmentDetectionOutput_PPEEntity | undefined;
}

/**
 * Detected Person contains the detected person and their associated
 * ppes and their protecting information.
 */
export interface PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
  /** The id of detected person. */
  personId: Long;
  /** The info of detected person identified box. */
  detectedPersonIdentifiedBox:
    | PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox
    | undefined;
  /** The info of detected person associated ppe identified boxes. */
  detectedPpeIdentifiedBoxes: PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox[];
  /**
   * Coverage score for each body part.
   * Coverage score for face.
   */
  faceCoverageScore?:
    | number
    | undefined;
  /** Coverage score for eyes. */
  eyesCoverageScore?:
    | number
    | undefined;
  /** Coverage score for head. */
  headCoverageScore?:
    | number
    | undefined;
  /** Coverage score for hands. */
  handsCoverageScore?:
    | number
    | undefined;
  /** Coverage score for body. */
  bodyCoverageScore?:
    | number
    | undefined;
  /** Coverage score for feet. */
  feetCoverageScore?: number | undefined;
}

/** Prediction output format for Generic Object Detection. */
export interface ObjectDetectionPredictionResult {
  /** Current timestamp. */
  currentTime:
    | Date
    | undefined;
  /** A list of identified boxes. */
  identifiedBoxes: ObjectDetectionPredictionResult_IdentifiedBox[];
}

/** The entity info for annotations from object detection prediction result. */
export interface ObjectDetectionPredictionResult_Entity {
  /** Label id. */
  labelId: Long;
  /** Human readable string of the label. */
  labelString: string;
}

/** Identified box contains location and the entity of the object. */
export interface ObjectDetectionPredictionResult_IdentifiedBox {
  /** An unique id for this box. */
  boxId: Long;
  /** Bounding Box in the normalized coordinates. */
  normalizedBoundingBox:
    | ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox
    | undefined;
  /** Confidence score associated with this box. */
  confidenceScore: number;
  /** Entity of this box. */
  entity: ObjectDetectionPredictionResult_Entity | undefined;
}

/** Bounding Box in the normalized coordinates. */
export interface ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
  /** Min in x coordinate. */
  xmin: number;
  /** Min in y coordinate. */
  ymin: number;
  /** Width of the bounding box. */
  width: number;
  /** Height of the bounding box. */
  height: number;
}

/** Prediction output format for Image Object Detection. */
export interface ImageObjectDetectionPredictionResult {
  /**
   * The resource IDs of the AnnotationSpecs that had been identified, ordered
   * by the confidence score descendingly. It is the id segment instead of full
   * resource name.
   */
  ids: Long[];
  /**
   * The display names of the AnnotationSpecs that had been identified, order
   * matches the IDs.
   */
  displayNames: string[];
  /**
   * The Model's confidences in correctness of the predicted IDs, higher value
   * means higher confidence. Order matches the Ids.
   */
  confidences: number[];
  /**
   * Bounding boxes, i.e. the rectangles over the image, that pinpoint
   * the found AnnotationSpecs. Given in order that matches the IDs. Each
   * bounding box is an array of 4 numbers `xMin`, `xMax`, `yMin`, and
   * `yMax`, which represent the extremal coordinates of the box. They are
   * relative to the image size, and the point 0,0 is in the top left
   * of the image.
   */
  bboxes: Array<any>[];
}

/** Prediction output format for Image and Text Classification. */
export interface ClassificationPredictionResult {
  /** The resource IDs of the AnnotationSpecs that had been identified. */
  ids: Long[];
  /**
   * The display names of the AnnotationSpecs that had been identified, order
   * matches the IDs.
   */
  displayNames: string[];
  /**
   * The Model's confidences in correctness of the predicted IDs, higher value
   * means higher confidence. Order matches the Ids.
   */
  confidences: number[];
}

/** Prediction output format for Image Segmentation. */
export interface ImageSegmentationPredictionResult {
  /**
   * A PNG image where each pixel in the mask represents the category in which
   * the pixel in the original image was predicted to belong to. The size of
   * this image will be the same as the original image. The mapping between the
   * AnntoationSpec and the color can be found in model's metadata. The model
   * will choose the most likely category and if none of the categories reach
   * the confidence threshold, the pixel will be marked as background.
   */
  categoryMask: string;
  /**
   * A one channel image which is encoded as an 8bit lossless PNG. The size of
   * the image will be the same as the original image. For a specific pixel,
   * darker color means less confidence in correctness of the cateogry in the
   * categoryMask for the corresponding pixel. Black means no confidence and
   * white means complete confidence.
   */
  confidenceMask: string;
}

/** Prediction output format for Video Action Recognition. */
export interface VideoActionRecognitionPredictionResult {
  /**
   * The beginning, inclusive, of the video's time segment in which the
   * actions have been identified.
   */
  segmentStartTime:
    | Date
    | undefined;
  /**
   * The end, inclusive, of the video's time segment in which the actions have
   * been identified. Particularly, if the end is the same as the start, it
   * means the identification happens on a specific video frame.
   */
  segmentEndTime:
    | Date
    | undefined;
  /** All of the actions identified in the time range. */
  actions: VideoActionRecognitionPredictionResult_IdentifiedAction[];
}

/**
 * Each IdentifiedAction is one particular identification of an action
 * specified with the AnnotationSpec id, display_name and the associated
 * confidence score.
 */
export interface VideoActionRecognitionPredictionResult_IdentifiedAction {
  /** The resource ID of the AnnotationSpec that had been identified. */
  id: string;
  /** The display name of the AnnotationSpec that had been identified. */
  displayName: string;
  /**
   * The Model's confidence in correction of this identification, higher
   * value means higher confidence.
   */
  confidence: number;
}

/** Prediction output format for Video Object Tracking. */
export interface VideoObjectTrackingPredictionResult {
  /**
   * The beginning, inclusive, of the video's time segment in which the
   * current identifications happens.
   */
  segmentStartTime:
    | Date
    | undefined;
  /**
   * The end, inclusive, of the video's time segment in which the current
   * identifications happen. Particularly, if the end is the same as the start,
   * it means the identifications happen on a specific video frame.
   */
  segmentEndTime:
    | Date
    | undefined;
  /** All of the objects detected in the specified time range. */
  objects: VideoObjectTrackingPredictionResult_DetectedObject[];
}

/**
 * Boundingbox for detected object. I.e. the rectangle over the video frame
 * pinpointing the found AnnotationSpec. The coordinates are relative to the
 * frame size, and the point 0,0 is in the top left of the frame.
 */
export interface VideoObjectTrackingPredictionResult_BoundingBox {
  /** The leftmost coordinate of the bounding box. */
  xMin: number;
  /** The rightmost coordinate of the bounding box. */
  xMax: number;
  /** The topmost coordinate of the bounding box. */
  yMin: number;
  /** The bottommost coordinate of the bounding box. */
  yMax: number;
}

/**
 * Each DetectedObject is one particular identification of an object
 * specified with the AnnotationSpec id and display_name, the bounding box,
 * the associated confidence score and the corresponding track_id.
 */
export interface VideoObjectTrackingPredictionResult_DetectedObject {
  /** The resource ID of the AnnotationSpec that had been identified. */
  id: string;
  /** The display name of the AnnotationSpec that had been identified. */
  displayName: string;
  /** Boundingbox. */
  boundingBox:
    | VideoObjectTrackingPredictionResult_BoundingBox
    | undefined;
  /**
   * The Model's confidence in correction of this identification, higher
   * value means higher confidence.
   */
  confidence: number;
  /**
   * The same object may be identified on muitiple frames which are typical
   * adjacent. The set of frames where a particular object has been detected
   * form a track. This track_id can be used to trace down all frames for an
   * detected object.
   */
  trackId: Long;
}

/** Prediction output format for Video Classification. */
export interface VideoClassificationPredictionResult {
  /**
   * The beginning, inclusive, of the video's time segment in which the
   * classifications have been identified.
   */
  segmentStartTime:
    | Date
    | undefined;
  /**
   * The end, inclusive, of the video's time segment in which the
   * classifications have been identified. Particularly, if the end is the same
   * as the start, it means the identification happens on a specific video
   * frame.
   */
  segmentEndTime:
    | Date
    | undefined;
  /** All of the classifications identified in the time range. */
  classifications: VideoClassificationPredictionResult_IdentifiedClassification[];
}

/**
 * Each IdentifiedClassification is one particular identification of an
 * classification specified with the AnnotationSpec id and display_name,
 * and the associated confidence score.
 */
export interface VideoClassificationPredictionResult_IdentifiedClassification {
  /** The resource ID of the AnnotationSpec that had been identified. */
  id: string;
  /** The display name of the AnnotationSpec that had been identified. */
  displayName: string;
  /**
   * The Model's confidence in correction of this identification, higher
   * value means higher confidence.
   */
  confidence: number;
}

/** The prediction result proto for occupancy counting. */
export interface OccupancyCountingPredictionResult {
  /** Current timestamp. */
  currentTime:
    | Date
    | undefined;
  /** A list of identified boxes. */
  identifiedBoxes: OccupancyCountingPredictionResult_IdentifiedBox[];
  /** Detection statistics. */
  stats:
    | OccupancyCountingPredictionResult_Stats
    | undefined;
  /**
   * Track related information. All the tracks that are live at this timestamp.
   * It only exists if tracking is enabled.
   */
  trackInfo: OccupancyCountingPredictionResult_TrackInfo[];
  /**
   * Dwell time related information. All the tracks that are live in a given
   * zone with a start and end dwell time timestamp
   */
  dwellTimeInfo: OccupancyCountingPredictionResult_DwellTimeInfo[];
}

/** The entity info for annotations from occupancy counting operator. */
export interface OccupancyCountingPredictionResult_Entity {
  /** Label id. */
  labelId: Long;
  /** Human readable string of the label. */
  labelString: string;
}

/** Identified box contains location and the entity of the object. */
export interface OccupancyCountingPredictionResult_IdentifiedBox {
  /** An unique id for this box. */
  boxId: Long;
  /** Bounding Box in the normalized coordinates. */
  normalizedBoundingBox:
    | OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox
    | undefined;
  /** Confidence score associated with this box. */
  score: number;
  /** Entity of this box. */
  entity:
    | OccupancyCountingPredictionResult_Entity
    | undefined;
  /**
   * An unique id to identify a track. It should be consistent across frames.
   * It only exists if tracking is enabled.
   */
  trackId: Long;
}

/** Bounding Box in the normalized coordinates. */
export interface OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
  /** Min in x coordinate. */
  xmin: number;
  /** Min in y coordinate. */
  ymin: number;
  /** Width of the bounding box. */
  width: number;
  /** Height of the bounding box. */
  height: number;
}

/** The statistics info for annotations from occupancy counting operator. */
export interface OccupancyCountingPredictionResult_Stats {
  /** Counts of the full frame. */
  fullFrameCount: OccupancyCountingPredictionResult_Stats_ObjectCount[];
  /** Crossing line counts. */
  crossingLineCounts: OccupancyCountingPredictionResult_Stats_CrossingLineCount[];
  /** Active zone counts. */
  activeZoneCounts: OccupancyCountingPredictionResult_Stats_ActiveZoneCount[];
}

/**
 * The object info and instant count for annotations from occupancy counting
 * operator.
 */
export interface OccupancyCountingPredictionResult_Stats_ObjectCount {
  /** Entity of this object. */
  entity:
    | OccupancyCountingPredictionResult_Entity
    | undefined;
  /** Count of the object. */
  count: number;
}

/**
 * The object info and accumulated count for annotations from occupancy
 * counting operator.
 */
export interface OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
  /** The start time of the accumulated count. */
  startTime:
    | Date
    | undefined;
  /** The object count for the accumulated count. */
  objectCount: OccupancyCountingPredictionResult_Stats_ObjectCount | undefined;
}

/** Message for Crossing line count. */
export interface OccupancyCountingPredictionResult_Stats_CrossingLineCount {
  /** Line annotation from the user. */
  annotation:
    | StreamAnnotation
    | undefined;
  /** The direction that follows the right hand rule. */
  positiveDirectionCounts: OccupancyCountingPredictionResult_Stats_ObjectCount[];
  /** The direction that is opposite to the right hand rule. */
  negativeDirectionCounts: OccupancyCountingPredictionResult_Stats_ObjectCount[];
  /** The accumulated positive count. */
  accumulatedPositiveDirectionCounts: OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount[];
  /** The accumulated negative count. */
  accumulatedNegativeDirectionCounts: OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount[];
}

/** Message for the active zone count. */
export interface OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
  /** Active zone annotation from the user. */
  annotation:
    | StreamAnnotation
    | undefined;
  /** Counts in the zone. */
  counts: OccupancyCountingPredictionResult_Stats_ObjectCount[];
}

/** The track info for annotations from occupancy counting operator. */
export interface OccupancyCountingPredictionResult_TrackInfo {
  /** An unique id to identify a track. It should be consistent across frames. */
  trackId: string;
  /** Start timestamp of this track. */
  startTime: Date | undefined;
}

/** The dwell time info for annotations from occupancy counting operator. */
export interface OccupancyCountingPredictionResult_DwellTimeInfo {
  /** An unique id to identify a track. It should be consistent across frames. */
  trackId: string;
  /** The unique id for the zone in which the object is dwelling/waiting. */
  zoneId: string;
  /** The beginning time when a dwelling object has been identified in a zone. */
  dwellStartTime:
    | Date
    | undefined;
  /** The end time when a dwelling object has exited in a zone. */
  dwellEndTime: Date | undefined;
}

/** message about annotations about Vision AI stream resource. */
export interface StreamAnnotation {
  /** Annotation for type ACTIVE_ZONE */
  activeZone?:
    | NormalizedPolygon
    | undefined;
  /** Annotation for type CROSSING_LINE */
  crossingLine?:
    | NormalizedPolyline
    | undefined;
  /**
   * ID of the annotation. It must be unique when used in the certain context.
   * For example, all the annotations to one input streams of a Vision AI
   * application.
   */
  id: string;
  /** User-friendly name for the annotation. */
  displayName: string;
  /** The Vision AI stream resource name. */
  sourceStream: string;
  /** The actual type of Annotation. */
  type: StreamAnnotationType;
}

/** A wrapper of repeated StreamAnnotation. */
export interface StreamAnnotations {
  /** Multiple annotations. */
  streamAnnotations: StreamAnnotation[];
}

/** Normalized Polygon. */
export interface NormalizedPolygon {
  /**
   * The bounding polygon normalized vertices. Top left corner of the image
   * will be [0, 0].
   */
  normalizedVertices: NormalizedVertex[];
}

/**
 * Normalized Pplyline, which represents a curve consisting of connected
 * straight-line segments.
 */
export interface NormalizedPolyline {
  /** A sequence of vertices connected by straight lines. */
  normalizedVertices: NormalizedVertex[];
}

/**
 * A vertex represents a 2D point in the image.
 * NOTE: the normalized vertex coordinates are relative to the original image
 * and range from 0 to 1.
 */
export interface NormalizedVertex {
  /** X coordinate. */
  x: number;
  /** Y coordinate. */
  y: number;
}

/**
 * Message of essential metadata of App Platform.
 * This message is usually attached to a certain processor output annotation for
 * customer to identify the source of the data.
 */
export interface AppPlatformMetadata {
  /** The application resource name. */
  application: string;
  /**
   * The instance resource id. Instance is the nested resource of application
   * under collection 'instances'.
   */
  instanceId: string;
  /** The node name of the application graph. */
  node: string;
  /** The referred processor resource name of the application node. */
  processor: string;
}

/**
 * For any cloud function based customer processing logic, customer's cloud
 * function is expected to receive AppPlatformCloudFunctionRequest as request
 * and send back AppPlatformCloudFunctionResponse as response.
 * Message of request from AppPlatform to Cloud Function.
 */
export interface AppPlatformCloudFunctionRequest {
  /**
   * The metadata of the AppPlatform for customer to identify the source of the
   * payload.
   */
  appPlatformMetadata:
    | AppPlatformMetadata
    | undefined;
  /** The actual annotations to be processed by the customized Cloud Function. */
  annotations: AppPlatformCloudFunctionRequest_StructedInputAnnotation[];
}

/**
 * A general annotation message that uses struct format to represent different
 * concrete annotation protobufs.
 */
export interface AppPlatformCloudFunctionRequest_StructedInputAnnotation {
  /** The ingestion time of the current annotation. */
  ingestionTimeMicros: Long;
  /** The struct format of the actual annotation. */
  annotation: { [key: string]: any } | undefined;
}

/** Message of the response from customer's Cloud Function to AppPlatform. */
export interface AppPlatformCloudFunctionResponse {
  /**
   * The modified annotations that is returned back to AppPlatform.
   * If the annotations fields are empty, then those annotations will be dropped
   * by AppPlatform.
   */
  annotations: AppPlatformCloudFunctionResponse_StructedOutputAnnotation[];
  /**
   * If set to true, AppPlatform will use original annotations instead of
   * dropping them, even if it is empty in the annotations filed.
   */
  annotationPassthrough: boolean;
  /**
   * The event notifications that is returned back to AppPlatform. Typically it
   * will then be configured to be consumed/forwared to a operator that handles
   * events, such as Pub/Sub operator.
   */
  events: AppPlatformEventBody[];
}

/**
 * A general annotation message that uses struct format to represent different
 * concrete annotation protobufs.
 */
export interface AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
  /** The struct format of the actual annotation. */
  annotation: { [key: string]: any } | undefined;
}

/** Message of content of appPlatform event */
export interface AppPlatformEventBody {
  /**
   * Human readable string of the event like "There are more than 6 people in
   * the scene". or "Shelf is empty!".
   */
  eventMessage: string;
  /**
   * For the case of Pub/Sub, it will be stored in the message attributes.
   * ​​pubsub.proto
   */
  payload:
    | { [key: string]: any }
    | undefined;
  /**
   * User defined Event Id, used to classify event, within a delivery interval,
   * events from the same application instance with the same id will be
   * de-duplicated & only first one will be sent out. Empty event_id will be
   * treated as "".
   */
  eventId: string;
}

function createBasePersonalProtectiveEquipmentDetectionOutput(): PersonalProtectiveEquipmentDetectionOutput {
  return { currentTime: undefined, detectedPersons: [] };
}

export const PersonalProtectiveEquipmentDetectionOutput: MessageFns<PersonalProtectiveEquipmentDetectionOutput> = {
  encode(message: PersonalProtectiveEquipmentDetectionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentTime !== undefined) {
      Timestamp.encode(toTimestamp(message.currentTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedPersons) {
      PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedPersons.push(
            PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput {
    return {
      currentTime: isSet(object.currentTime) ? fromJsonTimestamp(object.currentTime) : undefined,
      detectedPersons: globalThis.Array.isArray(object?.detectedPersons)
        ? object.detectedPersons.map((e: any) => PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput): unknown {
    const obj: any = {};
    if (message.currentTime !== undefined) {
      obj.currentTime = message.currentTime.toISOString();
    }
    if (message.detectedPersons?.length) {
      obj.detectedPersons = message.detectedPersons.map((e) =>
        PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput>): PersonalProtectiveEquipmentDetectionOutput {
    return PersonalProtectiveEquipmentDetectionOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput>,
  ): PersonalProtectiveEquipmentDetectionOutput {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput();
    message.currentTime = object.currentTime ?? undefined;
    message.detectedPersons =
      object.detectedPersons?.map((e) => PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_PersonEntity(): PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
  return { personEntityId: Long.ZERO };
}

export const PersonalProtectiveEquipmentDetectionOutput_PersonEntity: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_PersonEntity
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_PersonEntity,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.personEntityId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.personEntityId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PersonEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.personEntityId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
    return { personEntityId: isSet(object.personEntityId) ? Long.fromValue(object.personEntityId) : Long.ZERO };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_PersonEntity): unknown {
    const obj: any = {};
    if (!message.personEntityId.equals(Long.ZERO)) {
      obj.personEntityId = (message.personEntityId || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PersonEntity>,
  ): PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
    return PersonalProtectiveEquipmentDetectionOutput_PersonEntity.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PersonEntity>,
  ): PersonalProtectiveEquipmentDetectionOutput_PersonEntity {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PersonEntity();
    message.personEntityId = (object.personEntityId !== undefined && object.personEntityId !== null)
      ? Long.fromValue(object.personEntityId)
      : Long.ZERO;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_PPEEntity(): PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
  return { ppeLabelId: Long.ZERO, ppeLabelString: "", ppeSupercategoryLabelString: "", ppeEntityId: Long.ZERO };
}

export const PersonalProtectiveEquipmentDetectionOutput_PPEEntity: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_PPEEntity
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_PPEEntity,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.ppeLabelId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.ppeLabelId.toString());
    }
    if (message.ppeLabelString !== "") {
      writer.uint32(18).string(message.ppeLabelString);
    }
    if (message.ppeSupercategoryLabelString !== "") {
      writer.uint32(26).string(message.ppeSupercategoryLabelString);
    }
    if (!message.ppeEntityId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.ppeEntityId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PPEEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ppeLabelId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ppeLabelString = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ppeSupercategoryLabelString = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ppeEntityId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
    return {
      ppeLabelId: isSet(object.ppeLabelId) ? Long.fromValue(object.ppeLabelId) : Long.ZERO,
      ppeLabelString: isSet(object.ppeLabelString) ? globalThis.String(object.ppeLabelString) : "",
      ppeSupercategoryLabelString: isSet(object.ppeSupercategoryLabelString)
        ? globalThis.String(object.ppeSupercategoryLabelString)
        : "",
      ppeEntityId: isSet(object.ppeEntityId) ? Long.fromValue(object.ppeEntityId) : Long.ZERO,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_PPEEntity): unknown {
    const obj: any = {};
    if (!message.ppeLabelId.equals(Long.ZERO)) {
      obj.ppeLabelId = (message.ppeLabelId || Long.ZERO).toString();
    }
    if (message.ppeLabelString !== "") {
      obj.ppeLabelString = message.ppeLabelString;
    }
    if (message.ppeSupercategoryLabelString !== "") {
      obj.ppeSupercategoryLabelString = message.ppeSupercategoryLabelString;
    }
    if (!message.ppeEntityId.equals(Long.ZERO)) {
      obj.ppeEntityId = (message.ppeEntityId || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PPEEntity>,
  ): PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
    return PersonalProtectiveEquipmentDetectionOutput_PPEEntity.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PPEEntity>,
  ): PersonalProtectiveEquipmentDetectionOutput_PPEEntity {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PPEEntity();
    message.ppeLabelId = (object.ppeLabelId !== undefined && object.ppeLabelId !== null)
      ? Long.fromValue(object.ppeLabelId)
      : Long.ZERO;
    message.ppeLabelString = object.ppeLabelString ?? "";
    message.ppeSupercategoryLabelString = object.ppeSupercategoryLabelString ?? "";
    message.ppeEntityId = (object.ppeEntityId !== undefined && object.ppeEntityId !== null)
      ? Long.fromValue(object.ppeEntityId)
      : Long.ZERO;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox(): PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
  return { xmin: 0, ymin: 0, width: 0, height: 0 };
}

export const PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.xmin !== 0) {
      writer.uint32(13).float(message.xmin);
    }
    if (message.ymin !== 0) {
      writer.uint32(21).float(message.ymin);
    }
    if (message.width !== 0) {
      writer.uint32(29).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(37).float(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.xmin = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.ymin = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.width = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
    return {
      xmin: isSet(object.xmin) ? globalThis.Number(object.xmin) : 0,
      ymin: isSet(object.ymin) ? globalThis.Number(object.ymin) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox): unknown {
    const obj: any = {};
    if (message.xmin !== 0) {
      obj.xmin = message.xmin;
    }
    if (message.ymin !== 0) {
      obj.ymin = message.ymin;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
    return PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox();
    message.xmin = object.xmin ?? 0;
    message.ymin = object.ymin ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox(): PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
  return { boxId: Long.ZERO, normalizedBoundingBox: undefined, confidenceScore: 0, personEntity: undefined };
}

export const PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.boxId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.boxId.toString());
    }
    if (message.normalizedBoundingBox !== undefined) {
      PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.encode(
        message.normalizedBoundingBox,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(29).float(message.confidenceScore);
    }
    if (message.personEntity !== undefined) {
      PersonalProtectiveEquipmentDetectionOutput_PersonEntity.encode(message.personEntity, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boxId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normalizedBoundingBox = PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidenceScore = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.personEntity = PersonalProtectiveEquipmentDetectionOutput_PersonEntity.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
    return {
      boxId: isSet(object.boxId) ? Long.fromValue(object.boxId) : Long.ZERO,
      normalizedBoundingBox: isSet(object.normalizedBoundingBox)
        ? PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.fromJSON(object.normalizedBoundingBox)
        : undefined,
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      personEntity: isSet(object.personEntity)
        ? PersonalProtectiveEquipmentDetectionOutput_PersonEntity.fromJSON(object.personEntity)
        : undefined,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox): unknown {
    const obj: any = {};
    if (!message.boxId.equals(Long.ZERO)) {
      obj.boxId = (message.boxId || Long.ZERO).toString();
    }
    if (message.normalizedBoundingBox !== undefined) {
      obj.normalizedBoundingBox = PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.toJSON(
        message.normalizedBoundingBox,
      );
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.personEntity !== undefined) {
      obj.personEntity = PersonalProtectiveEquipmentDetectionOutput_PersonEntity.toJSON(message.personEntity);
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
    return PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox();
    message.boxId = (object.boxId !== undefined && object.boxId !== null) ? Long.fromValue(object.boxId) : Long.ZERO;
    message.normalizedBoundingBox =
      (object.normalizedBoundingBox !== undefined && object.normalizedBoundingBox !== null)
        ? PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.fromPartial(object.normalizedBoundingBox)
        : undefined;
    message.confidenceScore = object.confidenceScore ?? 0;
    message.personEntity = (object.personEntity !== undefined && object.personEntity !== null)
      ? PersonalProtectiveEquipmentDetectionOutput_PersonEntity.fromPartial(object.personEntity)
      : undefined;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox(): PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
  return { boxId: Long.ZERO, normalizedBoundingBox: undefined, confidenceScore: 0, ppeEntity: undefined };
}

export const PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.boxId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.boxId.toString());
    }
    if (message.normalizedBoundingBox !== undefined) {
      PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.encode(
        message.normalizedBoundingBox,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(29).float(message.confidenceScore);
    }
    if (message.ppeEntity !== undefined) {
      PersonalProtectiveEquipmentDetectionOutput_PPEEntity.encode(message.ppeEntity, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boxId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normalizedBoundingBox = PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidenceScore = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ppeEntity = PersonalProtectiveEquipmentDetectionOutput_PPEEntity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
    return {
      boxId: isSet(object.boxId) ? Long.fromValue(object.boxId) : Long.ZERO,
      normalizedBoundingBox: isSet(object.normalizedBoundingBox)
        ? PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.fromJSON(object.normalizedBoundingBox)
        : undefined,
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      ppeEntity: isSet(object.ppeEntity)
        ? PersonalProtectiveEquipmentDetectionOutput_PPEEntity.fromJSON(object.ppeEntity)
        : undefined,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox): unknown {
    const obj: any = {};
    if (!message.boxId.equals(Long.ZERO)) {
      obj.boxId = (message.boxId || Long.ZERO).toString();
    }
    if (message.normalizedBoundingBox !== undefined) {
      obj.normalizedBoundingBox = PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.toJSON(
        message.normalizedBoundingBox,
      );
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.ppeEntity !== undefined) {
      obj.ppeEntity = PersonalProtectiveEquipmentDetectionOutput_PPEEntity.toJSON(message.ppeEntity);
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
    return PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox>,
  ): PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox();
    message.boxId = (object.boxId !== undefined && object.boxId !== null) ? Long.fromValue(object.boxId) : Long.ZERO;
    message.normalizedBoundingBox =
      (object.normalizedBoundingBox !== undefined && object.normalizedBoundingBox !== null)
        ? PersonalProtectiveEquipmentDetectionOutput_NormalizedBoundingBox.fromPartial(object.normalizedBoundingBox)
        : undefined;
    message.confidenceScore = object.confidenceScore ?? 0;
    message.ppeEntity = (object.ppeEntity !== undefined && object.ppeEntity !== null)
      ? PersonalProtectiveEquipmentDetectionOutput_PPEEntity.fromPartial(object.ppeEntity)
      : undefined;
    return message;
  },
};

function createBasePersonalProtectiveEquipmentDetectionOutput_DetectedPerson(): PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
  return {
    personId: Long.ZERO,
    detectedPersonIdentifiedBox: undefined,
    detectedPpeIdentifiedBoxes: [],
    faceCoverageScore: undefined,
    eyesCoverageScore: undefined,
    headCoverageScore: undefined,
    handsCoverageScore: undefined,
    bodyCoverageScore: undefined,
    feetCoverageScore: undefined,
  };
}

export const PersonalProtectiveEquipmentDetectionOutput_DetectedPerson: MessageFns<
  PersonalProtectiveEquipmentDetectionOutput_DetectedPerson
> = {
  encode(
    message: PersonalProtectiveEquipmentDetectionOutput_DetectedPerson,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.personId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.personId.toString());
    }
    if (message.detectedPersonIdentifiedBox !== undefined) {
      PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.encode(
        message.detectedPersonIdentifiedBox,
        writer.uint32(18).fork(),
      ).join();
    }
    for (const v of message.detectedPpeIdentifiedBoxes) {
      PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.faceCoverageScore !== undefined) {
      writer.uint32(37).float(message.faceCoverageScore);
    }
    if (message.eyesCoverageScore !== undefined) {
      writer.uint32(45).float(message.eyesCoverageScore);
    }
    if (message.headCoverageScore !== undefined) {
      writer.uint32(53).float(message.headCoverageScore);
    }
    if (message.handsCoverageScore !== undefined) {
      writer.uint32(61).float(message.handsCoverageScore);
    }
    if (message.bodyCoverageScore !== undefined) {
      writer.uint32(69).float(message.bodyCoverageScore);
    }
    if (message.feetCoverageScore !== undefined) {
      writer.uint32(77).float(message.feetCoverageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_DetectedPerson();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.personId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedPersonIdentifiedBox = PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedPpeIdentifiedBoxes.push(
            PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.faceCoverageScore = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.eyesCoverageScore = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.headCoverageScore = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.handsCoverageScore = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.bodyCoverageScore = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.feetCoverageScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
    return {
      personId: isSet(object.personId) ? Long.fromValue(object.personId) : Long.ZERO,
      detectedPersonIdentifiedBox: isSet(object.detectedPersonIdentifiedBox)
        ? PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.fromJSON(object.detectedPersonIdentifiedBox)
        : undefined,
      detectedPpeIdentifiedBoxes: globalThis.Array.isArray(object?.detectedPpeIdentifiedBoxes)
        ? object.detectedPpeIdentifiedBoxes.map((e: any) =>
          PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.fromJSON(e)
        )
        : [],
      faceCoverageScore: isSet(object.faceCoverageScore) ? globalThis.Number(object.faceCoverageScore) : undefined,
      eyesCoverageScore: isSet(object.eyesCoverageScore) ? globalThis.Number(object.eyesCoverageScore) : undefined,
      headCoverageScore: isSet(object.headCoverageScore) ? globalThis.Number(object.headCoverageScore) : undefined,
      handsCoverageScore: isSet(object.handsCoverageScore) ? globalThis.Number(object.handsCoverageScore) : undefined,
      bodyCoverageScore: isSet(object.bodyCoverageScore) ? globalThis.Number(object.bodyCoverageScore) : undefined,
      feetCoverageScore: isSet(object.feetCoverageScore) ? globalThis.Number(object.feetCoverageScore) : undefined,
    };
  },

  toJSON(message: PersonalProtectiveEquipmentDetectionOutput_DetectedPerson): unknown {
    const obj: any = {};
    if (!message.personId.equals(Long.ZERO)) {
      obj.personId = (message.personId || Long.ZERO).toString();
    }
    if (message.detectedPersonIdentifiedBox !== undefined) {
      obj.detectedPersonIdentifiedBox = PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.toJSON(
        message.detectedPersonIdentifiedBox,
      );
    }
    if (message.detectedPpeIdentifiedBoxes?.length) {
      obj.detectedPpeIdentifiedBoxes = message.detectedPpeIdentifiedBoxes.map((e) =>
        PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.toJSON(e)
      );
    }
    if (message.faceCoverageScore !== undefined) {
      obj.faceCoverageScore = message.faceCoverageScore;
    }
    if (message.eyesCoverageScore !== undefined) {
      obj.eyesCoverageScore = message.eyesCoverageScore;
    }
    if (message.headCoverageScore !== undefined) {
      obj.headCoverageScore = message.headCoverageScore;
    }
    if (message.handsCoverageScore !== undefined) {
      obj.handsCoverageScore = message.handsCoverageScore;
    }
    if (message.bodyCoverageScore !== undefined) {
      obj.bodyCoverageScore = message.bodyCoverageScore;
    }
    if (message.feetCoverageScore !== undefined) {
      obj.feetCoverageScore = message.feetCoverageScore;
    }
    return obj;
  },

  create(
    base?: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_DetectedPerson>,
  ): PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
    return PersonalProtectiveEquipmentDetectionOutput_DetectedPerson.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PersonalProtectiveEquipmentDetectionOutput_DetectedPerson>,
  ): PersonalProtectiveEquipmentDetectionOutput_DetectedPerson {
    const message = createBasePersonalProtectiveEquipmentDetectionOutput_DetectedPerson();
    message.personId = (object.personId !== undefined && object.personId !== null)
      ? Long.fromValue(object.personId)
      : Long.ZERO;
    message.detectedPersonIdentifiedBox =
      (object.detectedPersonIdentifiedBox !== undefined && object.detectedPersonIdentifiedBox !== null)
        ? PersonalProtectiveEquipmentDetectionOutput_PersonIdentifiedBox.fromPartial(object.detectedPersonIdentifiedBox)
        : undefined;
    message.detectedPpeIdentifiedBoxes =
      object.detectedPpeIdentifiedBoxes?.map((e) =>
        PersonalProtectiveEquipmentDetectionOutput_PPEIdentifiedBox.fromPartial(e)
      ) || [];
    message.faceCoverageScore = object.faceCoverageScore ?? undefined;
    message.eyesCoverageScore = object.eyesCoverageScore ?? undefined;
    message.headCoverageScore = object.headCoverageScore ?? undefined;
    message.handsCoverageScore = object.handsCoverageScore ?? undefined;
    message.bodyCoverageScore = object.bodyCoverageScore ?? undefined;
    message.feetCoverageScore = object.feetCoverageScore ?? undefined;
    return message;
  },
};

function createBaseObjectDetectionPredictionResult(): ObjectDetectionPredictionResult {
  return { currentTime: undefined, identifiedBoxes: [] };
}

export const ObjectDetectionPredictionResult: MessageFns<ObjectDetectionPredictionResult> = {
  encode(message: ObjectDetectionPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentTime !== undefined) {
      Timestamp.encode(toTimestamp(message.currentTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.identifiedBoxes) {
      ObjectDetectionPredictionResult_IdentifiedBox.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectDetectionPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectDetectionPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identifiedBoxes.push(ObjectDetectionPredictionResult_IdentifiedBox.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectDetectionPredictionResult {
    return {
      currentTime: isSet(object.currentTime) ? fromJsonTimestamp(object.currentTime) : undefined,
      identifiedBoxes: globalThis.Array.isArray(object?.identifiedBoxes)
        ? object.identifiedBoxes.map((e: any) => ObjectDetectionPredictionResult_IdentifiedBox.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ObjectDetectionPredictionResult): unknown {
    const obj: any = {};
    if (message.currentTime !== undefined) {
      obj.currentTime = message.currentTime.toISOString();
    }
    if (message.identifiedBoxes?.length) {
      obj.identifiedBoxes = message.identifiedBoxes.map((e) => ObjectDetectionPredictionResult_IdentifiedBox.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectDetectionPredictionResult>): ObjectDetectionPredictionResult {
    return ObjectDetectionPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectDetectionPredictionResult>): ObjectDetectionPredictionResult {
    const message = createBaseObjectDetectionPredictionResult();
    message.currentTime = object.currentTime ?? undefined;
    message.identifiedBoxes =
      object.identifiedBoxes?.map((e) => ObjectDetectionPredictionResult_IdentifiedBox.fromPartial(e)) || [];
    return message;
  },
};

function createBaseObjectDetectionPredictionResult_Entity(): ObjectDetectionPredictionResult_Entity {
  return { labelId: Long.ZERO, labelString: "" };
}

export const ObjectDetectionPredictionResult_Entity: MessageFns<ObjectDetectionPredictionResult_Entity> = {
  encode(message: ObjectDetectionPredictionResult_Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.labelId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.labelId.toString());
    }
    if (message.labelString !== "") {
      writer.uint32(18).string(message.labelString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectDetectionPredictionResult_Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectDetectionPredictionResult_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.labelId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.labelString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectDetectionPredictionResult_Entity {
    return {
      labelId: isSet(object.labelId) ? Long.fromValue(object.labelId) : Long.ZERO,
      labelString: isSet(object.labelString) ? globalThis.String(object.labelString) : "",
    };
  },

  toJSON(message: ObjectDetectionPredictionResult_Entity): unknown {
    const obj: any = {};
    if (!message.labelId.equals(Long.ZERO)) {
      obj.labelId = (message.labelId || Long.ZERO).toString();
    }
    if (message.labelString !== "") {
      obj.labelString = message.labelString;
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectDetectionPredictionResult_Entity>): ObjectDetectionPredictionResult_Entity {
    return ObjectDetectionPredictionResult_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectDetectionPredictionResult_Entity>): ObjectDetectionPredictionResult_Entity {
    const message = createBaseObjectDetectionPredictionResult_Entity();
    message.labelId = (object.labelId !== undefined && object.labelId !== null)
      ? Long.fromValue(object.labelId)
      : Long.ZERO;
    message.labelString = object.labelString ?? "";
    return message;
  },
};

function createBaseObjectDetectionPredictionResult_IdentifiedBox(): ObjectDetectionPredictionResult_IdentifiedBox {
  return { boxId: Long.ZERO, normalizedBoundingBox: undefined, confidenceScore: 0, entity: undefined };
}

export const ObjectDetectionPredictionResult_IdentifiedBox: MessageFns<ObjectDetectionPredictionResult_IdentifiedBox> =
  {
    encode(
      message: ObjectDetectionPredictionResult_IdentifiedBox,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (!message.boxId.equals(Long.ZERO)) {
        writer.uint32(8).int64(message.boxId.toString());
      }
      if (message.normalizedBoundingBox !== undefined) {
        ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.encode(
          message.normalizedBoundingBox,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.confidenceScore !== 0) {
        writer.uint32(29).float(message.confidenceScore);
      }
      if (message.entity !== undefined) {
        ObjectDetectionPredictionResult_Entity.encode(message.entity, writer.uint32(34).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ObjectDetectionPredictionResult_IdentifiedBox {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseObjectDetectionPredictionResult_IdentifiedBox();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.boxId = Long.fromString(reader.int64().toString());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.normalizedBoundingBox = ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.decode(
              reader,
              reader.uint32(),
            );
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }

            message.confidenceScore = reader.float();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.entity = ObjectDetectionPredictionResult_Entity.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ObjectDetectionPredictionResult_IdentifiedBox {
      return {
        boxId: isSet(object.boxId) ? Long.fromValue(object.boxId) : Long.ZERO,
        normalizedBoundingBox: isSet(object.normalizedBoundingBox)
          ? ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromJSON(object.normalizedBoundingBox)
          : undefined,
        confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
        entity: isSet(object.entity) ? ObjectDetectionPredictionResult_Entity.fromJSON(object.entity) : undefined,
      };
    },

    toJSON(message: ObjectDetectionPredictionResult_IdentifiedBox): unknown {
      const obj: any = {};
      if (!message.boxId.equals(Long.ZERO)) {
        obj.boxId = (message.boxId || Long.ZERO).toString();
      }
      if (message.normalizedBoundingBox !== undefined) {
        obj.normalizedBoundingBox = ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.toJSON(
          message.normalizedBoundingBox,
        );
      }
      if (message.confidenceScore !== 0) {
        obj.confidenceScore = message.confidenceScore;
      }
      if (message.entity !== undefined) {
        obj.entity = ObjectDetectionPredictionResult_Entity.toJSON(message.entity);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ObjectDetectionPredictionResult_IdentifiedBox>,
    ): ObjectDetectionPredictionResult_IdentifiedBox {
      return ObjectDetectionPredictionResult_IdentifiedBox.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ObjectDetectionPredictionResult_IdentifiedBox>,
    ): ObjectDetectionPredictionResult_IdentifiedBox {
      const message = createBaseObjectDetectionPredictionResult_IdentifiedBox();
      message.boxId = (object.boxId !== undefined && object.boxId !== null) ? Long.fromValue(object.boxId) : Long.ZERO;
      message.normalizedBoundingBox =
        (object.normalizedBoundingBox !== undefined && object.normalizedBoundingBox !== null)
          ? ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromPartial(
            object.normalizedBoundingBox,
          )
          : undefined;
      message.confidenceScore = object.confidenceScore ?? 0;
      message.entity = (object.entity !== undefined && object.entity !== null)
        ? ObjectDetectionPredictionResult_Entity.fromPartial(object.entity)
        : undefined;
      return message;
    },
  };

function createBaseObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox(): ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
  return { xmin: 0, ymin: 0, width: 0, height: 0 };
}

export const ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox: MessageFns<
  ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox
> = {
  encode(
    message: ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.xmin !== 0) {
      writer.uint32(13).float(message.xmin);
    }
    if (message.ymin !== 0) {
      writer.uint32(21).float(message.ymin);
    }
    if (message.width !== 0) {
      writer.uint32(29).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(37).float(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.xmin = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.ymin = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.width = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    return {
      xmin: isSet(object.xmin) ? globalThis.Number(object.xmin) : 0,
      ymin: isSet(object.ymin) ? globalThis.Number(object.ymin) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox): unknown {
    const obj: any = {};
    if (message.xmin !== 0) {
      obj.xmin = message.xmin;
    }
    if (message.ymin !== 0) {
      obj.ymin = message.ymin;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox>,
  ): ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    return ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox>,
  ): ObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    const message = createBaseObjectDetectionPredictionResult_IdentifiedBox_NormalizedBoundingBox();
    message.xmin = object.xmin ?? 0;
    message.ymin = object.ymin ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseImageObjectDetectionPredictionResult(): ImageObjectDetectionPredictionResult {
  return { ids: [], displayNames: [], confidences: [], bboxes: [] };
}

export const ImageObjectDetectionPredictionResult: MessageFns<ImageObjectDetectionPredictionResult> = {
  encode(message: ImageObjectDetectionPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int64(v.toString());
    }
    writer.join();
    for (const v of message.displayNames) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.confidences) {
      writer.float(v);
    }
    writer.join();
    for (const v of message.bboxes) {
      ListValue.encode(ListValue.wrap(v!), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageObjectDetectionPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageObjectDetectionPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ids.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayNames.push(reader.string());
          continue;
        case 3:
          if (tag === 29) {
            message.confidences.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.confidences.push(reader.float());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bboxes.push(ListValue.unwrap(ListValue.decode(reader, reader.uint32())));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageObjectDetectionPredictionResult {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Long.fromValue(e)) : [],
      displayNames: globalThis.Array.isArray(object?.displayNames)
        ? object.displayNames.map((e: any) => globalThis.String(e))
        : [],
      confidences: globalThis.Array.isArray(object?.confidences)
        ? object.confidences.map((e: any) => globalThis.Number(e))
        : [],
      bboxes: globalThis.Array.isArray(object?.bboxes) ? object.bboxes.map((e: any) => [...e]) : [],
    };
  },

  toJSON(message: ImageObjectDetectionPredictionResult): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => (e || Long.ZERO).toString());
    }
    if (message.displayNames?.length) {
      obj.displayNames = message.displayNames;
    }
    if (message.confidences?.length) {
      obj.confidences = message.confidences;
    }
    if (message.bboxes?.length) {
      obj.bboxes = message.bboxes;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageObjectDetectionPredictionResult>): ImageObjectDetectionPredictionResult {
    return ImageObjectDetectionPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageObjectDetectionPredictionResult>): ImageObjectDetectionPredictionResult {
    const message = createBaseImageObjectDetectionPredictionResult();
    message.ids = object.ids?.map((e) => Long.fromValue(e)) || [];
    message.displayNames = object.displayNames?.map((e) => e) || [];
    message.confidences = object.confidences?.map((e) => e) || [];
    message.bboxes = object.bboxes?.map((e) => e) || [];
    return message;
  },
};

function createBaseClassificationPredictionResult(): ClassificationPredictionResult {
  return { ids: [], displayNames: [], confidences: [] };
}

export const ClassificationPredictionResult: MessageFns<ClassificationPredictionResult> = {
  encode(message: ClassificationPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int64(v.toString());
    }
    writer.join();
    for (const v of message.displayNames) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.confidences) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClassificationPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassificationPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ids.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayNames.push(reader.string());
          continue;
        case 3:
          if (tag === 29) {
            message.confidences.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.confidences.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassificationPredictionResult {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Long.fromValue(e)) : [],
      displayNames: globalThis.Array.isArray(object?.displayNames)
        ? object.displayNames.map((e: any) => globalThis.String(e))
        : [],
      confidences: globalThis.Array.isArray(object?.confidences)
        ? object.confidences.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ClassificationPredictionResult): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => (e || Long.ZERO).toString());
    }
    if (message.displayNames?.length) {
      obj.displayNames = message.displayNames;
    }
    if (message.confidences?.length) {
      obj.confidences = message.confidences;
    }
    return obj;
  },

  create(base?: DeepPartial<ClassificationPredictionResult>): ClassificationPredictionResult {
    return ClassificationPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClassificationPredictionResult>): ClassificationPredictionResult {
    const message = createBaseClassificationPredictionResult();
    message.ids = object.ids?.map((e) => Long.fromValue(e)) || [];
    message.displayNames = object.displayNames?.map((e) => e) || [];
    message.confidences = object.confidences?.map((e) => e) || [];
    return message;
  },
};

function createBaseImageSegmentationPredictionResult(): ImageSegmentationPredictionResult {
  return { categoryMask: "", confidenceMask: "" };
}

export const ImageSegmentationPredictionResult: MessageFns<ImageSegmentationPredictionResult> = {
  encode(message: ImageSegmentationPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryMask !== "") {
      writer.uint32(10).string(message.categoryMask);
    }
    if (message.confidenceMask !== "") {
      writer.uint32(18).string(message.confidenceMask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageSegmentationPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageSegmentationPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categoryMask = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.confidenceMask = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageSegmentationPredictionResult {
    return {
      categoryMask: isSet(object.categoryMask) ? globalThis.String(object.categoryMask) : "",
      confidenceMask: isSet(object.confidenceMask) ? globalThis.String(object.confidenceMask) : "",
    };
  },

  toJSON(message: ImageSegmentationPredictionResult): unknown {
    const obj: any = {};
    if (message.categoryMask !== "") {
      obj.categoryMask = message.categoryMask;
    }
    if (message.confidenceMask !== "") {
      obj.confidenceMask = message.confidenceMask;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageSegmentationPredictionResult>): ImageSegmentationPredictionResult {
    return ImageSegmentationPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageSegmentationPredictionResult>): ImageSegmentationPredictionResult {
    const message = createBaseImageSegmentationPredictionResult();
    message.categoryMask = object.categoryMask ?? "";
    message.confidenceMask = object.confidenceMask ?? "";
    return message;
  },
};

function createBaseVideoActionRecognitionPredictionResult(): VideoActionRecognitionPredictionResult {
  return { segmentStartTime: undefined, segmentEndTime: undefined, actions: [] };
}

export const VideoActionRecognitionPredictionResult: MessageFns<VideoActionRecognitionPredictionResult> = {
  encode(message: VideoActionRecognitionPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segmentStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentStartTime), writer.uint32(10).fork()).join();
    }
    if (message.segmentEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentEndTime), writer.uint32(18).fork()).join();
    }
    for (const v of message.actions) {
      VideoActionRecognitionPredictionResult_IdentifiedAction.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoActionRecognitionPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoActionRecognitionPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segmentStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actions.push(VideoActionRecognitionPredictionResult_IdentifiedAction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoActionRecognitionPredictionResult {
    return {
      segmentStartTime: isSet(object.segmentStartTime) ? fromJsonTimestamp(object.segmentStartTime) : undefined,
      segmentEndTime: isSet(object.segmentEndTime) ? fromJsonTimestamp(object.segmentEndTime) : undefined,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => VideoActionRecognitionPredictionResult_IdentifiedAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoActionRecognitionPredictionResult): unknown {
    const obj: any = {};
    if (message.segmentStartTime !== undefined) {
      obj.segmentStartTime = message.segmentStartTime.toISOString();
    }
    if (message.segmentEndTime !== undefined) {
      obj.segmentEndTime = message.segmentEndTime.toISOString();
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => VideoActionRecognitionPredictionResult_IdentifiedAction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VideoActionRecognitionPredictionResult>): VideoActionRecognitionPredictionResult {
    return VideoActionRecognitionPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoActionRecognitionPredictionResult>): VideoActionRecognitionPredictionResult {
    const message = createBaseVideoActionRecognitionPredictionResult();
    message.segmentStartTime = object.segmentStartTime ?? undefined;
    message.segmentEndTime = object.segmentEndTime ?? undefined;
    message.actions =
      object.actions?.map((e) => VideoActionRecognitionPredictionResult_IdentifiedAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoActionRecognitionPredictionResult_IdentifiedAction(): VideoActionRecognitionPredictionResult_IdentifiedAction {
  return { id: "", displayName: "", confidence: 0 };
}

export const VideoActionRecognitionPredictionResult_IdentifiedAction: MessageFns<
  VideoActionRecognitionPredictionResult_IdentifiedAction
> = {
  encode(
    message: VideoActionRecognitionPredictionResult_IdentifiedAction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.confidence !== 0) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoActionRecognitionPredictionResult_IdentifiedAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoActionRecognitionPredictionResult_IdentifiedAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoActionRecognitionPredictionResult_IdentifiedAction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: VideoActionRecognitionPredictionResult_IdentifiedAction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(
    base?: DeepPartial<VideoActionRecognitionPredictionResult_IdentifiedAction>,
  ): VideoActionRecognitionPredictionResult_IdentifiedAction {
    return VideoActionRecognitionPredictionResult_IdentifiedAction.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VideoActionRecognitionPredictionResult_IdentifiedAction>,
  ): VideoActionRecognitionPredictionResult_IdentifiedAction {
    const message = createBaseVideoActionRecognitionPredictionResult_IdentifiedAction();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseVideoObjectTrackingPredictionResult(): VideoObjectTrackingPredictionResult {
  return { segmentStartTime: undefined, segmentEndTime: undefined, objects: [] };
}

export const VideoObjectTrackingPredictionResult: MessageFns<VideoObjectTrackingPredictionResult> = {
  encode(message: VideoObjectTrackingPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segmentStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentStartTime), writer.uint32(10).fork()).join();
    }
    if (message.segmentEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentEndTime), writer.uint32(18).fork()).join();
    }
    for (const v of message.objects) {
      VideoObjectTrackingPredictionResult_DetectedObject.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoObjectTrackingPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoObjectTrackingPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segmentStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.objects.push(VideoObjectTrackingPredictionResult_DetectedObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoObjectTrackingPredictionResult {
    return {
      segmentStartTime: isSet(object.segmentStartTime) ? fromJsonTimestamp(object.segmentStartTime) : undefined,
      segmentEndTime: isSet(object.segmentEndTime) ? fromJsonTimestamp(object.segmentEndTime) : undefined,
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => VideoObjectTrackingPredictionResult_DetectedObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoObjectTrackingPredictionResult): unknown {
    const obj: any = {};
    if (message.segmentStartTime !== undefined) {
      obj.segmentStartTime = message.segmentStartTime.toISOString();
    }
    if (message.segmentEndTime !== undefined) {
      obj.segmentEndTime = message.segmentEndTime.toISOString();
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => VideoObjectTrackingPredictionResult_DetectedObject.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VideoObjectTrackingPredictionResult>): VideoObjectTrackingPredictionResult {
    return VideoObjectTrackingPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoObjectTrackingPredictionResult>): VideoObjectTrackingPredictionResult {
    const message = createBaseVideoObjectTrackingPredictionResult();
    message.segmentStartTime = object.segmentStartTime ?? undefined;
    message.segmentEndTime = object.segmentEndTime ?? undefined;
    message.objects = object.objects?.map((e) => VideoObjectTrackingPredictionResult_DetectedObject.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseVideoObjectTrackingPredictionResult_BoundingBox(): VideoObjectTrackingPredictionResult_BoundingBox {
  return { xMin: 0, xMax: 0, yMin: 0, yMax: 0 };
}

export const VideoObjectTrackingPredictionResult_BoundingBox: MessageFns<
  VideoObjectTrackingPredictionResult_BoundingBox
> = {
  encode(
    message: VideoObjectTrackingPredictionResult_BoundingBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.xMin !== 0) {
      writer.uint32(13).float(message.xMin);
    }
    if (message.xMax !== 0) {
      writer.uint32(21).float(message.xMax);
    }
    if (message.yMin !== 0) {
      writer.uint32(29).float(message.yMin);
    }
    if (message.yMax !== 0) {
      writer.uint32(37).float(message.yMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoObjectTrackingPredictionResult_BoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoObjectTrackingPredictionResult_BoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.xMin = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.xMax = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.yMin = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.yMax = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoObjectTrackingPredictionResult_BoundingBox {
    return {
      xMin: isSet(object.xMin) ? globalThis.Number(object.xMin) : 0,
      xMax: isSet(object.xMax) ? globalThis.Number(object.xMax) : 0,
      yMin: isSet(object.yMin) ? globalThis.Number(object.yMin) : 0,
      yMax: isSet(object.yMax) ? globalThis.Number(object.yMax) : 0,
    };
  },

  toJSON(message: VideoObjectTrackingPredictionResult_BoundingBox): unknown {
    const obj: any = {};
    if (message.xMin !== 0) {
      obj.xMin = message.xMin;
    }
    if (message.xMax !== 0) {
      obj.xMax = message.xMax;
    }
    if (message.yMin !== 0) {
      obj.yMin = message.yMin;
    }
    if (message.yMax !== 0) {
      obj.yMax = message.yMax;
    }
    return obj;
  },

  create(
    base?: DeepPartial<VideoObjectTrackingPredictionResult_BoundingBox>,
  ): VideoObjectTrackingPredictionResult_BoundingBox {
    return VideoObjectTrackingPredictionResult_BoundingBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VideoObjectTrackingPredictionResult_BoundingBox>,
  ): VideoObjectTrackingPredictionResult_BoundingBox {
    const message = createBaseVideoObjectTrackingPredictionResult_BoundingBox();
    message.xMin = object.xMin ?? 0;
    message.xMax = object.xMax ?? 0;
    message.yMin = object.yMin ?? 0;
    message.yMax = object.yMax ?? 0;
    return message;
  },
};

function createBaseVideoObjectTrackingPredictionResult_DetectedObject(): VideoObjectTrackingPredictionResult_DetectedObject {
  return { id: "", displayName: "", boundingBox: undefined, confidence: 0, trackId: Long.ZERO };
}

export const VideoObjectTrackingPredictionResult_DetectedObject: MessageFns<
  VideoObjectTrackingPredictionResult_DetectedObject
> = {
  encode(
    message: VideoObjectTrackingPredictionResult_DetectedObject,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.boundingBox !== undefined) {
      VideoObjectTrackingPredictionResult_BoundingBox.encode(message.boundingBox, writer.uint32(26).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    if (!message.trackId.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.trackId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoObjectTrackingPredictionResult_DetectedObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoObjectTrackingPredictionResult_DetectedObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingBox = VideoObjectTrackingPredictionResult_BoundingBox.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.trackId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoObjectTrackingPredictionResult_DetectedObject {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      boundingBox: isSet(object.boundingBox)
        ? VideoObjectTrackingPredictionResult_BoundingBox.fromJSON(object.boundingBox)
        : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      trackId: isSet(object.trackId) ? Long.fromValue(object.trackId) : Long.ZERO,
    };
  },

  toJSON(message: VideoObjectTrackingPredictionResult_DetectedObject): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = VideoObjectTrackingPredictionResult_BoundingBox.toJSON(message.boundingBox);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (!message.trackId.equals(Long.ZERO)) {
      obj.trackId = (message.trackId || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<VideoObjectTrackingPredictionResult_DetectedObject>,
  ): VideoObjectTrackingPredictionResult_DetectedObject {
    return VideoObjectTrackingPredictionResult_DetectedObject.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VideoObjectTrackingPredictionResult_DetectedObject>,
  ): VideoObjectTrackingPredictionResult_DetectedObject {
    const message = createBaseVideoObjectTrackingPredictionResult_DetectedObject();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? VideoObjectTrackingPredictionResult_BoundingBox.fromPartial(object.boundingBox)
      : undefined;
    message.confidence = object.confidence ?? 0;
    message.trackId = (object.trackId !== undefined && object.trackId !== null)
      ? Long.fromValue(object.trackId)
      : Long.ZERO;
    return message;
  },
};

function createBaseVideoClassificationPredictionResult(): VideoClassificationPredictionResult {
  return { segmentStartTime: undefined, segmentEndTime: undefined, classifications: [] };
}

export const VideoClassificationPredictionResult: MessageFns<VideoClassificationPredictionResult> = {
  encode(message: VideoClassificationPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segmentStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentStartTime), writer.uint32(10).fork()).join();
    }
    if (message.segmentEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.segmentEndTime), writer.uint32(18).fork()).join();
    }
    for (const v of message.classifications) {
      VideoClassificationPredictionResult_IdentifiedClassification.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoClassificationPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoClassificationPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segmentStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segmentEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.classifications.push(
            VideoClassificationPredictionResult_IdentifiedClassification.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoClassificationPredictionResult {
    return {
      segmentStartTime: isSet(object.segmentStartTime) ? fromJsonTimestamp(object.segmentStartTime) : undefined,
      segmentEndTime: isSet(object.segmentEndTime) ? fromJsonTimestamp(object.segmentEndTime) : undefined,
      classifications: globalThis.Array.isArray(object?.classifications)
        ? object.classifications.map((e: any) =>
          VideoClassificationPredictionResult_IdentifiedClassification.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: VideoClassificationPredictionResult): unknown {
    const obj: any = {};
    if (message.segmentStartTime !== undefined) {
      obj.segmentStartTime = message.segmentStartTime.toISOString();
    }
    if (message.segmentEndTime !== undefined) {
      obj.segmentEndTime = message.segmentEndTime.toISOString();
    }
    if (message.classifications?.length) {
      obj.classifications = message.classifications.map((e) =>
        VideoClassificationPredictionResult_IdentifiedClassification.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<VideoClassificationPredictionResult>): VideoClassificationPredictionResult {
    return VideoClassificationPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoClassificationPredictionResult>): VideoClassificationPredictionResult {
    const message = createBaseVideoClassificationPredictionResult();
    message.segmentStartTime = object.segmentStartTime ?? undefined;
    message.segmentEndTime = object.segmentEndTime ?? undefined;
    message.classifications =
      object.classifications?.map((e) => VideoClassificationPredictionResult_IdentifiedClassification.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseVideoClassificationPredictionResult_IdentifiedClassification(): VideoClassificationPredictionResult_IdentifiedClassification {
  return { id: "", displayName: "", confidence: 0 };
}

export const VideoClassificationPredictionResult_IdentifiedClassification: MessageFns<
  VideoClassificationPredictionResult_IdentifiedClassification
> = {
  encode(
    message: VideoClassificationPredictionResult_IdentifiedClassification,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.confidence !== 0) {
      writer.uint32(29).float(message.confidence);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): VideoClassificationPredictionResult_IdentifiedClassification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoClassificationPredictionResult_IdentifiedClassification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoClassificationPredictionResult_IdentifiedClassification {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: VideoClassificationPredictionResult_IdentifiedClassification): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(
    base?: DeepPartial<VideoClassificationPredictionResult_IdentifiedClassification>,
  ): VideoClassificationPredictionResult_IdentifiedClassification {
    return VideoClassificationPredictionResult_IdentifiedClassification.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VideoClassificationPredictionResult_IdentifiedClassification>,
  ): VideoClassificationPredictionResult_IdentifiedClassification {
    const message = createBaseVideoClassificationPredictionResult_IdentifiedClassification();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult(): OccupancyCountingPredictionResult {
  return { currentTime: undefined, identifiedBoxes: [], stats: undefined, trackInfo: [], dwellTimeInfo: [] };
}

export const OccupancyCountingPredictionResult: MessageFns<OccupancyCountingPredictionResult> = {
  encode(message: OccupancyCountingPredictionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentTime !== undefined) {
      Timestamp.encode(toTimestamp(message.currentTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.identifiedBoxes) {
      OccupancyCountingPredictionResult_IdentifiedBox.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.stats !== undefined) {
      OccupancyCountingPredictionResult_Stats.encode(message.stats, writer.uint32(26).fork()).join();
    }
    for (const v of message.trackInfo) {
      OccupancyCountingPredictionResult_TrackInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.dwellTimeInfo) {
      OccupancyCountingPredictionResult_DwellTimeInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identifiedBoxes.push(OccupancyCountingPredictionResult_IdentifiedBox.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stats = OccupancyCountingPredictionResult_Stats.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trackInfo.push(OccupancyCountingPredictionResult_TrackInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dwellTimeInfo.push(OccupancyCountingPredictionResult_DwellTimeInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult {
    return {
      currentTime: isSet(object.currentTime) ? fromJsonTimestamp(object.currentTime) : undefined,
      identifiedBoxes: globalThis.Array.isArray(object?.identifiedBoxes)
        ? object.identifiedBoxes.map((e: any) => OccupancyCountingPredictionResult_IdentifiedBox.fromJSON(e))
        : [],
      stats: isSet(object.stats) ? OccupancyCountingPredictionResult_Stats.fromJSON(object.stats) : undefined,
      trackInfo: globalThis.Array.isArray(object?.trackInfo)
        ? object.trackInfo.map((e: any) => OccupancyCountingPredictionResult_TrackInfo.fromJSON(e))
        : [],
      dwellTimeInfo: globalThis.Array.isArray(object?.dwellTimeInfo)
        ? object.dwellTimeInfo.map((e: any) => OccupancyCountingPredictionResult_DwellTimeInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OccupancyCountingPredictionResult): unknown {
    const obj: any = {};
    if (message.currentTime !== undefined) {
      obj.currentTime = message.currentTime.toISOString();
    }
    if (message.identifiedBoxes?.length) {
      obj.identifiedBoxes = message.identifiedBoxes.map((e) =>
        OccupancyCountingPredictionResult_IdentifiedBox.toJSON(e)
      );
    }
    if (message.stats !== undefined) {
      obj.stats = OccupancyCountingPredictionResult_Stats.toJSON(message.stats);
    }
    if (message.trackInfo?.length) {
      obj.trackInfo = message.trackInfo.map((e) => OccupancyCountingPredictionResult_TrackInfo.toJSON(e));
    }
    if (message.dwellTimeInfo?.length) {
      obj.dwellTimeInfo = message.dwellTimeInfo.map((e) => OccupancyCountingPredictionResult_DwellTimeInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OccupancyCountingPredictionResult>): OccupancyCountingPredictionResult {
    return OccupancyCountingPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OccupancyCountingPredictionResult>): OccupancyCountingPredictionResult {
    const message = createBaseOccupancyCountingPredictionResult();
    message.currentTime = object.currentTime ?? undefined;
    message.identifiedBoxes =
      object.identifiedBoxes?.map((e) => OccupancyCountingPredictionResult_IdentifiedBox.fromPartial(e)) || [];
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? OccupancyCountingPredictionResult_Stats.fromPartial(object.stats)
      : undefined;
    message.trackInfo = object.trackInfo?.map((e) => OccupancyCountingPredictionResult_TrackInfo.fromPartial(e)) || [];
    message.dwellTimeInfo =
      object.dwellTimeInfo?.map((e) => OccupancyCountingPredictionResult_DwellTimeInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Entity(): OccupancyCountingPredictionResult_Entity {
  return { labelId: Long.ZERO, labelString: "" };
}

export const OccupancyCountingPredictionResult_Entity: MessageFns<OccupancyCountingPredictionResult_Entity> = {
  encode(message: OccupancyCountingPredictionResult_Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.labelId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.labelId.toString());
    }
    if (message.labelString !== "") {
      writer.uint32(18).string(message.labelString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.labelId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.labelString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Entity {
    return {
      labelId: isSet(object.labelId) ? Long.fromValue(object.labelId) : Long.ZERO,
      labelString: isSet(object.labelString) ? globalThis.String(object.labelString) : "",
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Entity): unknown {
    const obj: any = {};
    if (!message.labelId.equals(Long.ZERO)) {
      obj.labelId = (message.labelId || Long.ZERO).toString();
    }
    if (message.labelString !== "") {
      obj.labelString = message.labelString;
    }
    return obj;
  },

  create(base?: DeepPartial<OccupancyCountingPredictionResult_Entity>): OccupancyCountingPredictionResult_Entity {
    return OccupancyCountingPredictionResult_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OccupancyCountingPredictionResult_Entity>): OccupancyCountingPredictionResult_Entity {
    const message = createBaseOccupancyCountingPredictionResult_Entity();
    message.labelId = (object.labelId !== undefined && object.labelId !== null)
      ? Long.fromValue(object.labelId)
      : Long.ZERO;
    message.labelString = object.labelString ?? "";
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_IdentifiedBox(): OccupancyCountingPredictionResult_IdentifiedBox {
  return { boxId: Long.ZERO, normalizedBoundingBox: undefined, score: 0, entity: undefined, trackId: Long.ZERO };
}

export const OccupancyCountingPredictionResult_IdentifiedBox: MessageFns<
  OccupancyCountingPredictionResult_IdentifiedBox
> = {
  encode(
    message: OccupancyCountingPredictionResult_IdentifiedBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.boxId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.boxId.toString());
    }
    if (message.normalizedBoundingBox !== undefined) {
      OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.encode(
        message.normalizedBoundingBox,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    if (message.entity !== undefined) {
      OccupancyCountingPredictionResult_Entity.encode(message.entity, writer.uint32(34).fork()).join();
    }
    if (!message.trackId.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.trackId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_IdentifiedBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_IdentifiedBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boxId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normalizedBoundingBox = OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entity = OccupancyCountingPredictionResult_Entity.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.trackId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_IdentifiedBox {
    return {
      boxId: isSet(object.boxId) ? Long.fromValue(object.boxId) : Long.ZERO,
      normalizedBoundingBox: isSet(object.normalizedBoundingBox)
        ? OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromJSON(object.normalizedBoundingBox)
        : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      entity: isSet(object.entity) ? OccupancyCountingPredictionResult_Entity.fromJSON(object.entity) : undefined,
      trackId: isSet(object.trackId) ? Long.fromValue(object.trackId) : Long.ZERO,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_IdentifiedBox): unknown {
    const obj: any = {};
    if (!message.boxId.equals(Long.ZERO)) {
      obj.boxId = (message.boxId || Long.ZERO).toString();
    }
    if (message.normalizedBoundingBox !== undefined) {
      obj.normalizedBoundingBox = OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.toJSON(
        message.normalizedBoundingBox,
      );
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.entity !== undefined) {
      obj.entity = OccupancyCountingPredictionResult_Entity.toJSON(message.entity);
    }
    if (!message.trackId.equals(Long.ZERO)) {
      obj.trackId = (message.trackId || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_IdentifiedBox>,
  ): OccupancyCountingPredictionResult_IdentifiedBox {
    return OccupancyCountingPredictionResult_IdentifiedBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_IdentifiedBox>,
  ): OccupancyCountingPredictionResult_IdentifiedBox {
    const message = createBaseOccupancyCountingPredictionResult_IdentifiedBox();
    message.boxId = (object.boxId !== undefined && object.boxId !== null) ? Long.fromValue(object.boxId) : Long.ZERO;
    message.normalizedBoundingBox =
      (object.normalizedBoundingBox !== undefined && object.normalizedBoundingBox !== null)
        ? OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromPartial(
          object.normalizedBoundingBox,
        )
        : undefined;
    message.score = object.score ?? 0;
    message.entity = (object.entity !== undefined && object.entity !== null)
      ? OccupancyCountingPredictionResult_Entity.fromPartial(object.entity)
      : undefined;
    message.trackId = (object.trackId !== undefined && object.trackId !== null)
      ? Long.fromValue(object.trackId)
      : Long.ZERO;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox(): OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
  return { xmin: 0, ymin: 0, width: 0, height: 0 };
}

export const OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox: MessageFns<
  OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox
> = {
  encode(
    message: OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.xmin !== 0) {
      writer.uint32(13).float(message.xmin);
    }
    if (message.ymin !== 0) {
      writer.uint32(21).float(message.ymin);
    }
    if (message.width !== 0) {
      writer.uint32(29).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(37).float(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.xmin = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.ymin = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.width = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    return {
      xmin: isSet(object.xmin) ? globalThis.Number(object.xmin) : 0,
      ymin: isSet(object.ymin) ? globalThis.Number(object.ymin) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox): unknown {
    const obj: any = {};
    if (message.xmin !== 0) {
      obj.xmin = message.xmin;
    }
    if (message.ymin !== 0) {
      obj.ymin = message.ymin;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox>,
  ): OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    return OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox>,
  ): OccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox {
    const message = createBaseOccupancyCountingPredictionResult_IdentifiedBox_NormalizedBoundingBox();
    message.xmin = object.xmin ?? 0;
    message.ymin = object.ymin ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Stats(): OccupancyCountingPredictionResult_Stats {
  return { fullFrameCount: [], crossingLineCounts: [], activeZoneCounts: [] };
}

export const OccupancyCountingPredictionResult_Stats: MessageFns<OccupancyCountingPredictionResult_Stats> = {
  encode(message: OccupancyCountingPredictionResult_Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fullFrameCount) {
      OccupancyCountingPredictionResult_Stats_ObjectCount.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.crossingLineCounts) {
      OccupancyCountingPredictionResult_Stats_CrossingLineCount.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.activeZoneCounts) {
      OccupancyCountingPredictionResult_Stats_ActiveZoneCount.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Stats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullFrameCount.push(
            OccupancyCountingPredictionResult_Stats_ObjectCount.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crossingLineCounts.push(
            OccupancyCountingPredictionResult_Stats_CrossingLineCount.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.activeZoneCounts.push(
            OccupancyCountingPredictionResult_Stats_ActiveZoneCount.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Stats {
    return {
      fullFrameCount: globalThis.Array.isArray(object?.fullFrameCount)
        ? object.fullFrameCount.map((e: any) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromJSON(e))
        : [],
      crossingLineCounts: globalThis.Array.isArray(object?.crossingLineCounts)
        ? object.crossingLineCounts.map((e: any) =>
          OccupancyCountingPredictionResult_Stats_CrossingLineCount.fromJSON(e)
        )
        : [],
      activeZoneCounts: globalThis.Array.isArray(object?.activeZoneCounts)
        ? object.activeZoneCounts.map((e: any) => OccupancyCountingPredictionResult_Stats_ActiveZoneCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Stats): unknown {
    const obj: any = {};
    if (message.fullFrameCount?.length) {
      obj.fullFrameCount = message.fullFrameCount.map((e) =>
        OccupancyCountingPredictionResult_Stats_ObjectCount.toJSON(e)
      );
    }
    if (message.crossingLineCounts?.length) {
      obj.crossingLineCounts = message.crossingLineCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_CrossingLineCount.toJSON(e)
      );
    }
    if (message.activeZoneCounts?.length) {
      obj.activeZoneCounts = message.activeZoneCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_ActiveZoneCount.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<OccupancyCountingPredictionResult_Stats>): OccupancyCountingPredictionResult_Stats {
    return OccupancyCountingPredictionResult_Stats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OccupancyCountingPredictionResult_Stats>): OccupancyCountingPredictionResult_Stats {
    const message = createBaseOccupancyCountingPredictionResult_Stats();
    message.fullFrameCount =
      object.fullFrameCount?.map((e) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(e)) || [];
    message.crossingLineCounts =
      object.crossingLineCounts?.map((e) => OccupancyCountingPredictionResult_Stats_CrossingLineCount.fromPartial(e)) ||
      [];
    message.activeZoneCounts =
      object.activeZoneCounts?.map((e) => OccupancyCountingPredictionResult_Stats_ActiveZoneCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Stats_ObjectCount(): OccupancyCountingPredictionResult_Stats_ObjectCount {
  return { entity: undefined, count: 0 };
}

export const OccupancyCountingPredictionResult_Stats_ObjectCount: MessageFns<
  OccupancyCountingPredictionResult_Stats_ObjectCount
> = {
  encode(
    message: OccupancyCountingPredictionResult_Stats_ObjectCount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.entity !== undefined) {
      OccupancyCountingPredictionResult_Entity.encode(message.entity, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_Stats_ObjectCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Stats_ObjectCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entity = OccupancyCountingPredictionResult_Entity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Stats_ObjectCount {
    return {
      entity: isSet(object.entity) ? OccupancyCountingPredictionResult_Entity.fromJSON(object.entity) : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Stats_ObjectCount): unknown {
    const obj: any = {};
    if (message.entity !== undefined) {
      obj.entity = OccupancyCountingPredictionResult_Entity.toJSON(message.entity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_Stats_ObjectCount>,
  ): OccupancyCountingPredictionResult_Stats_ObjectCount {
    return OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_Stats_ObjectCount>,
  ): OccupancyCountingPredictionResult_Stats_ObjectCount {
    const message = createBaseOccupancyCountingPredictionResult_Stats_ObjectCount();
    message.entity = (object.entity !== undefined && object.entity !== null)
      ? OccupancyCountingPredictionResult_Entity.fromPartial(object.entity)
      : undefined;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Stats_AccumulatedObjectCount(): OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
  return { startTime: undefined, objectCount: undefined };
}

export const OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount: MessageFns<
  OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount
> = {
  encode(
    message: OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.objectCount !== undefined) {
      OccupancyCountingPredictionResult_Stats_ObjectCount.encode(message.objectCount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Stats_AccumulatedObjectCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.objectCount = OccupancyCountingPredictionResult_Stats_ObjectCount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      objectCount: isSet(object.objectCount)
        ? OccupancyCountingPredictionResult_Stats_ObjectCount.fromJSON(object.objectCount)
        : undefined,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.objectCount !== undefined) {
      obj.objectCount = OccupancyCountingPredictionResult_Stats_ObjectCount.toJSON(message.objectCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount>,
  ): OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
    return OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount>,
  ): OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount {
    const message = createBaseOccupancyCountingPredictionResult_Stats_AccumulatedObjectCount();
    message.startTime = object.startTime ?? undefined;
    message.objectCount = (object.objectCount !== undefined && object.objectCount !== null)
      ? OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(object.objectCount)
      : undefined;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Stats_CrossingLineCount(): OccupancyCountingPredictionResult_Stats_CrossingLineCount {
  return {
    annotation: undefined,
    positiveDirectionCounts: [],
    negativeDirectionCounts: [],
    accumulatedPositiveDirectionCounts: [],
    accumulatedNegativeDirectionCounts: [],
  };
}

export const OccupancyCountingPredictionResult_Stats_CrossingLineCount: MessageFns<
  OccupancyCountingPredictionResult_Stats_CrossingLineCount
> = {
  encode(
    message: OccupancyCountingPredictionResult_Stats_CrossingLineCount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.annotation !== undefined) {
      StreamAnnotation.encode(message.annotation, writer.uint32(10).fork()).join();
    }
    for (const v of message.positiveDirectionCounts) {
      OccupancyCountingPredictionResult_Stats_ObjectCount.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.negativeDirectionCounts) {
      OccupancyCountingPredictionResult_Stats_ObjectCount.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.accumulatedPositiveDirectionCounts) {
      OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.accumulatedNegativeDirectionCounts) {
      OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_Stats_CrossingLineCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Stats_CrossingLineCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = StreamAnnotation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.positiveDirectionCounts.push(
            OccupancyCountingPredictionResult_Stats_ObjectCount.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.negativeDirectionCounts.push(
            OccupancyCountingPredictionResult_Stats_ObjectCount.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accumulatedPositiveDirectionCounts.push(
            OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accumulatedNegativeDirectionCounts.push(
            OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Stats_CrossingLineCount {
    return {
      annotation: isSet(object.annotation) ? StreamAnnotation.fromJSON(object.annotation) : undefined,
      positiveDirectionCounts: globalThis.Array.isArray(object?.positiveDirectionCounts)
        ? object.positiveDirectionCounts.map((e: any) =>
          OccupancyCountingPredictionResult_Stats_ObjectCount.fromJSON(e)
        )
        : [],
      negativeDirectionCounts: globalThis.Array.isArray(object?.negativeDirectionCounts)
        ? object.negativeDirectionCounts.map((e: any) =>
          OccupancyCountingPredictionResult_Stats_ObjectCount.fromJSON(e)
        )
        : [],
      accumulatedPositiveDirectionCounts: globalThis.Array.isArray(object?.accumulatedPositiveDirectionCounts)
        ? object.accumulatedPositiveDirectionCounts.map((e: any) =>
          OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.fromJSON(e)
        )
        : [],
      accumulatedNegativeDirectionCounts: globalThis.Array.isArray(object?.accumulatedNegativeDirectionCounts)
        ? object.accumulatedNegativeDirectionCounts.map((e: any) =>
          OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Stats_CrossingLineCount): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = StreamAnnotation.toJSON(message.annotation);
    }
    if (message.positiveDirectionCounts?.length) {
      obj.positiveDirectionCounts = message.positiveDirectionCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_ObjectCount.toJSON(e)
      );
    }
    if (message.negativeDirectionCounts?.length) {
      obj.negativeDirectionCounts = message.negativeDirectionCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_ObjectCount.toJSON(e)
      );
    }
    if (message.accumulatedPositiveDirectionCounts?.length) {
      obj.accumulatedPositiveDirectionCounts = message.accumulatedPositiveDirectionCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.toJSON(e)
      );
    }
    if (message.accumulatedNegativeDirectionCounts?.length) {
      obj.accumulatedNegativeDirectionCounts = message.accumulatedNegativeDirectionCounts.map((e) =>
        OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_Stats_CrossingLineCount>,
  ): OccupancyCountingPredictionResult_Stats_CrossingLineCount {
    return OccupancyCountingPredictionResult_Stats_CrossingLineCount.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_Stats_CrossingLineCount>,
  ): OccupancyCountingPredictionResult_Stats_CrossingLineCount {
    const message = createBaseOccupancyCountingPredictionResult_Stats_CrossingLineCount();
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? StreamAnnotation.fromPartial(object.annotation)
      : undefined;
    message.positiveDirectionCounts =
      object.positiveDirectionCounts?.map((e) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(e)) ||
      [];
    message.negativeDirectionCounts =
      object.negativeDirectionCounts?.map((e) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(e)) ||
      [];
    message.accumulatedPositiveDirectionCounts =
      object.accumulatedPositiveDirectionCounts?.map((e) =>
        OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.fromPartial(e)
      ) || [];
    message.accumulatedNegativeDirectionCounts =
      object.accumulatedNegativeDirectionCounts?.map((e) =>
        OccupancyCountingPredictionResult_Stats_AccumulatedObjectCount.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_Stats_ActiveZoneCount(): OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
  return { annotation: undefined, counts: [] };
}

export const OccupancyCountingPredictionResult_Stats_ActiveZoneCount: MessageFns<
  OccupancyCountingPredictionResult_Stats_ActiveZoneCount
> = {
  encode(
    message: OccupancyCountingPredictionResult_Stats_ActiveZoneCount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.annotation !== undefined) {
      StreamAnnotation.encode(message.annotation, writer.uint32(10).fork()).join();
    }
    for (const v of message.counts) {
      OccupancyCountingPredictionResult_Stats_ObjectCount.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_Stats_ActiveZoneCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = StreamAnnotation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counts.push(OccupancyCountingPredictionResult_Stats_ObjectCount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
    return {
      annotation: isSet(object.annotation) ? StreamAnnotation.fromJSON(object.annotation) : undefined,
      counts: globalThis.Array.isArray(object?.counts)
        ? object.counts.map((e: any) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_Stats_ActiveZoneCount): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = StreamAnnotation.toJSON(message.annotation);
    }
    if (message.counts?.length) {
      obj.counts = message.counts.map((e) => OccupancyCountingPredictionResult_Stats_ObjectCount.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_Stats_ActiveZoneCount>,
  ): OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
    return OccupancyCountingPredictionResult_Stats_ActiveZoneCount.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_Stats_ActiveZoneCount>,
  ): OccupancyCountingPredictionResult_Stats_ActiveZoneCount {
    const message = createBaseOccupancyCountingPredictionResult_Stats_ActiveZoneCount();
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? StreamAnnotation.fromPartial(object.annotation)
      : undefined;
    message.counts = object.counts?.map((e) => OccupancyCountingPredictionResult_Stats_ObjectCount.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_TrackInfo(): OccupancyCountingPredictionResult_TrackInfo {
  return { trackId: "", startTime: undefined };
}

export const OccupancyCountingPredictionResult_TrackInfo: MessageFns<OccupancyCountingPredictionResult_TrackInfo> = {
  encode(
    message: OccupancyCountingPredictionResult_TrackInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trackId !== "") {
      writer.uint32(10).string(message.trackId);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_TrackInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_TrackInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trackId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_TrackInfo {
    return {
      trackId: isSet(object.trackId) ? globalThis.String(object.trackId) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_TrackInfo): unknown {
    const obj: any = {};
    if (message.trackId !== "") {
      obj.trackId = message.trackId;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OccupancyCountingPredictionResult_TrackInfo>): OccupancyCountingPredictionResult_TrackInfo {
    return OccupancyCountingPredictionResult_TrackInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_TrackInfo>,
  ): OccupancyCountingPredictionResult_TrackInfo {
    const message = createBaseOccupancyCountingPredictionResult_TrackInfo();
    message.trackId = object.trackId ?? "";
    message.startTime = object.startTime ?? undefined;
    return message;
  },
};

function createBaseOccupancyCountingPredictionResult_DwellTimeInfo(): OccupancyCountingPredictionResult_DwellTimeInfo {
  return { trackId: "", zoneId: "", dwellStartTime: undefined, dwellEndTime: undefined };
}

export const OccupancyCountingPredictionResult_DwellTimeInfo: MessageFns<
  OccupancyCountingPredictionResult_DwellTimeInfo
> = {
  encode(
    message: OccupancyCountingPredictionResult_DwellTimeInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trackId !== "") {
      writer.uint32(10).string(message.trackId);
    }
    if (message.zoneId !== "") {
      writer.uint32(18).string(message.zoneId);
    }
    if (message.dwellStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dwellStartTime), writer.uint32(26).fork()).join();
    }
    if (message.dwellEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dwellEndTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OccupancyCountingPredictionResult_DwellTimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOccupancyCountingPredictionResult_DwellTimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trackId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zoneId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dwellStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dwellEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OccupancyCountingPredictionResult_DwellTimeInfo {
    return {
      trackId: isSet(object.trackId) ? globalThis.String(object.trackId) : "",
      zoneId: isSet(object.zoneId) ? globalThis.String(object.zoneId) : "",
      dwellStartTime: isSet(object.dwellStartTime) ? fromJsonTimestamp(object.dwellStartTime) : undefined,
      dwellEndTime: isSet(object.dwellEndTime) ? fromJsonTimestamp(object.dwellEndTime) : undefined,
    };
  },

  toJSON(message: OccupancyCountingPredictionResult_DwellTimeInfo): unknown {
    const obj: any = {};
    if (message.trackId !== "") {
      obj.trackId = message.trackId;
    }
    if (message.zoneId !== "") {
      obj.zoneId = message.zoneId;
    }
    if (message.dwellStartTime !== undefined) {
      obj.dwellStartTime = message.dwellStartTime.toISOString();
    }
    if (message.dwellEndTime !== undefined) {
      obj.dwellEndTime = message.dwellEndTime.toISOString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<OccupancyCountingPredictionResult_DwellTimeInfo>,
  ): OccupancyCountingPredictionResult_DwellTimeInfo {
    return OccupancyCountingPredictionResult_DwellTimeInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OccupancyCountingPredictionResult_DwellTimeInfo>,
  ): OccupancyCountingPredictionResult_DwellTimeInfo {
    const message = createBaseOccupancyCountingPredictionResult_DwellTimeInfo();
    message.trackId = object.trackId ?? "";
    message.zoneId = object.zoneId ?? "";
    message.dwellStartTime = object.dwellStartTime ?? undefined;
    message.dwellEndTime = object.dwellEndTime ?? undefined;
    return message;
  },
};

function createBaseStreamAnnotation(): StreamAnnotation {
  return { activeZone: undefined, crossingLine: undefined, id: "", displayName: "", sourceStream: "", type: 0 };
}

export const StreamAnnotation: MessageFns<StreamAnnotation> = {
  encode(message: StreamAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeZone !== undefined) {
      NormalizedPolygon.encode(message.activeZone, writer.uint32(42).fork()).join();
    }
    if (message.crossingLine !== undefined) {
      NormalizedPolyline.encode(message.crossingLine, writer.uint32(50).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.sourceStream !== "") {
      writer.uint32(26).string(message.sourceStream);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.activeZone = NormalizedPolygon.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.crossingLine = NormalizedPolyline.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceStream = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAnnotation {
    return {
      activeZone: isSet(object.activeZone) ? NormalizedPolygon.fromJSON(object.activeZone) : undefined,
      crossingLine: isSet(object.crossingLine) ? NormalizedPolyline.fromJSON(object.crossingLine) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceStream: isSet(object.sourceStream) ? globalThis.String(object.sourceStream) : "",
      type: isSet(object.type) ? streamAnnotationTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: StreamAnnotation): unknown {
    const obj: any = {};
    if (message.activeZone !== undefined) {
      obj.activeZone = NormalizedPolygon.toJSON(message.activeZone);
    }
    if (message.crossingLine !== undefined) {
      obj.crossingLine = NormalizedPolyline.toJSON(message.crossingLine);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceStream !== "") {
      obj.sourceStream = message.sourceStream;
    }
    if (message.type !== 0) {
      obj.type = streamAnnotationTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamAnnotation>): StreamAnnotation {
    return StreamAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamAnnotation>): StreamAnnotation {
    const message = createBaseStreamAnnotation();
    message.activeZone = (object.activeZone !== undefined && object.activeZone !== null)
      ? NormalizedPolygon.fromPartial(object.activeZone)
      : undefined;
    message.crossingLine = (object.crossingLine !== undefined && object.crossingLine !== null)
      ? NormalizedPolyline.fromPartial(object.crossingLine)
      : undefined;
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.sourceStream = object.sourceStream ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseStreamAnnotations(): StreamAnnotations {
  return { streamAnnotations: [] };
}

export const StreamAnnotations: MessageFns<StreamAnnotations> = {
  encode(message: StreamAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.streamAnnotations) {
      StreamAnnotation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamAnnotations.push(StreamAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAnnotations {
    return {
      streamAnnotations: globalThis.Array.isArray(object?.streamAnnotations)
        ? object.streamAnnotations.map((e: any) => StreamAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamAnnotations): unknown {
    const obj: any = {};
    if (message.streamAnnotations?.length) {
      obj.streamAnnotations = message.streamAnnotations.map((e) => StreamAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamAnnotations>): StreamAnnotations {
    return StreamAnnotations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamAnnotations>): StreamAnnotations {
    const message = createBaseStreamAnnotations();
    message.streamAnnotations = object.streamAnnotations?.map((e) => StreamAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedPolygon(): NormalizedPolygon {
  return { normalizedVertices: [] };
}

export const NormalizedPolygon: MessageFns<NormalizedPolygon> = {
  encode(message: NormalizedPolygon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedPolygon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedPolygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedPolygon {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedPolygon): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedPolygon>): NormalizedPolygon {
    return NormalizedPolygon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedPolygon>): NormalizedPolygon {
    const message = createBaseNormalizedPolygon();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedPolyline(): NormalizedPolyline {
  return { normalizedVertices: [] };
}

export const NormalizedPolyline: MessageFns<NormalizedPolyline> = {
  encode(message: NormalizedPolyline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedPolyline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedPolyline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedPolyline {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedPolyline): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedPolyline>): NormalizedPolyline {
    return NormalizedPolyline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedPolyline>): NormalizedPolyline {
    const message = createBaseNormalizedPolyline();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedVertex(): NormalizedVertex {
  return { x: 0, y: 0 };
}

export const NormalizedVertex: MessageFns<NormalizedVertex> = {
  encode(message: NormalizedVertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedVertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedVertex {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NormalizedVertex): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedVertex>): NormalizedVertex {
    return NormalizedVertex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedVertex>): NormalizedVertex {
    const message = createBaseNormalizedVertex();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseAppPlatformMetadata(): AppPlatformMetadata {
  return { application: "", instanceId: "", node: "", processor: "" };
}

export const AppPlatformMetadata: MessageFns<AppPlatformMetadata> = {
  encode(message: AppPlatformMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== "") {
      writer.uint32(10).string(message.application);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.node !== "") {
      writer.uint32(26).string(message.node);
    }
    if (message.processor !== "") {
      writer.uint32(34).string(message.processor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.application = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.node = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.processor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformMetadata {
    return {
      application: isSet(object.application) ? globalThis.String(object.application) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
    };
  },

  toJSON(message: AppPlatformMetadata): unknown {
    const obj: any = {};
    if (message.application !== "") {
      obj.application = message.application;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    return obj;
  },

  create(base?: DeepPartial<AppPlatformMetadata>): AppPlatformMetadata {
    return AppPlatformMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppPlatformMetadata>): AppPlatformMetadata {
    const message = createBaseAppPlatformMetadata();
    message.application = object.application ?? "";
    message.instanceId = object.instanceId ?? "";
    message.node = object.node ?? "";
    message.processor = object.processor ?? "";
    return message;
  },
};

function createBaseAppPlatformCloudFunctionRequest(): AppPlatformCloudFunctionRequest {
  return { appPlatformMetadata: undefined, annotations: [] };
}

export const AppPlatformCloudFunctionRequest: MessageFns<AppPlatformCloudFunctionRequest> = {
  encode(message: AppPlatformCloudFunctionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appPlatformMetadata !== undefined) {
      AppPlatformMetadata.encode(message.appPlatformMetadata, writer.uint32(10).fork()).join();
    }
    for (const v of message.annotations) {
      AppPlatformCloudFunctionRequest_StructedInputAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformCloudFunctionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformCloudFunctionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appPlatformMetadata = AppPlatformMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotations.push(
            AppPlatformCloudFunctionRequest_StructedInputAnnotation.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformCloudFunctionRequest {
    return {
      appPlatformMetadata: isSet(object.appPlatformMetadata)
        ? AppPlatformMetadata.fromJSON(object.appPlatformMetadata)
        : undefined,
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => AppPlatformCloudFunctionRequest_StructedInputAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AppPlatformCloudFunctionRequest): unknown {
    const obj: any = {};
    if (message.appPlatformMetadata !== undefined) {
      obj.appPlatformMetadata = AppPlatformMetadata.toJSON(message.appPlatformMetadata);
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) =>
        AppPlatformCloudFunctionRequest_StructedInputAnnotation.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AppPlatformCloudFunctionRequest>): AppPlatformCloudFunctionRequest {
    return AppPlatformCloudFunctionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppPlatformCloudFunctionRequest>): AppPlatformCloudFunctionRequest {
    const message = createBaseAppPlatformCloudFunctionRequest();
    message.appPlatformMetadata = (object.appPlatformMetadata !== undefined && object.appPlatformMetadata !== null)
      ? AppPlatformMetadata.fromPartial(object.appPlatformMetadata)
      : undefined;
    message.annotations =
      object.annotations?.map((e) => AppPlatformCloudFunctionRequest_StructedInputAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAppPlatformCloudFunctionRequest_StructedInputAnnotation(): AppPlatformCloudFunctionRequest_StructedInputAnnotation {
  return { ingestionTimeMicros: Long.ZERO, annotation: undefined };
}

export const AppPlatformCloudFunctionRequest_StructedInputAnnotation: MessageFns<
  AppPlatformCloudFunctionRequest_StructedInputAnnotation
> = {
  encode(
    message: AppPlatformCloudFunctionRequest_StructedInputAnnotation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.ingestionTimeMicros.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.ingestionTimeMicros.toString());
    }
    if (message.annotation !== undefined) {
      Struct.encode(Struct.wrap(message.annotation), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformCloudFunctionRequest_StructedInputAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformCloudFunctionRequest_StructedInputAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ingestionTimeMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformCloudFunctionRequest_StructedInputAnnotation {
    return {
      ingestionTimeMicros: isSet(object.ingestionTimeMicros) ? Long.fromValue(object.ingestionTimeMicros) : Long.ZERO,
      annotation: isObject(object.annotation) ? object.annotation : undefined,
    };
  },

  toJSON(message: AppPlatformCloudFunctionRequest_StructedInputAnnotation): unknown {
    const obj: any = {};
    if (!message.ingestionTimeMicros.equals(Long.ZERO)) {
      obj.ingestionTimeMicros = (message.ingestionTimeMicros || Long.ZERO).toString();
    }
    if (message.annotation !== undefined) {
      obj.annotation = message.annotation;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AppPlatformCloudFunctionRequest_StructedInputAnnotation>,
  ): AppPlatformCloudFunctionRequest_StructedInputAnnotation {
    return AppPlatformCloudFunctionRequest_StructedInputAnnotation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AppPlatformCloudFunctionRequest_StructedInputAnnotation>,
  ): AppPlatformCloudFunctionRequest_StructedInputAnnotation {
    const message = createBaseAppPlatformCloudFunctionRequest_StructedInputAnnotation();
    message.ingestionTimeMicros = (object.ingestionTimeMicros !== undefined && object.ingestionTimeMicros !== null)
      ? Long.fromValue(object.ingestionTimeMicros)
      : Long.ZERO;
    message.annotation = object.annotation ?? undefined;
    return message;
  },
};

function createBaseAppPlatformCloudFunctionResponse(): AppPlatformCloudFunctionResponse {
  return { annotations: [], annotationPassthrough: false, events: [] };
}

export const AppPlatformCloudFunctionResponse: MessageFns<AppPlatformCloudFunctionResponse> = {
  encode(message: AppPlatformCloudFunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      AppPlatformCloudFunctionResponse_StructedOutputAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.annotationPassthrough !== false) {
      writer.uint32(24).bool(message.annotationPassthrough);
    }
    for (const v of message.events) {
      AppPlatformEventBody.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformCloudFunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformCloudFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotations.push(
            AppPlatformCloudFunctionResponse_StructedOutputAnnotation.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.annotationPassthrough = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.events.push(AppPlatformEventBody.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformCloudFunctionResponse {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => AppPlatformCloudFunctionResponse_StructedOutputAnnotation.fromJSON(e))
        : [],
      annotationPassthrough: isSet(object.annotationPassthrough)
        ? globalThis.Boolean(object.annotationPassthrough)
        : false,
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => AppPlatformEventBody.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AppPlatformCloudFunctionResponse): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) =>
        AppPlatformCloudFunctionResponse_StructedOutputAnnotation.toJSON(e)
      );
    }
    if (message.annotationPassthrough !== false) {
      obj.annotationPassthrough = message.annotationPassthrough;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => AppPlatformEventBody.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AppPlatformCloudFunctionResponse>): AppPlatformCloudFunctionResponse {
    return AppPlatformCloudFunctionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppPlatformCloudFunctionResponse>): AppPlatformCloudFunctionResponse {
    const message = createBaseAppPlatformCloudFunctionResponse();
    message.annotations =
      object.annotations?.map((e) => AppPlatformCloudFunctionResponse_StructedOutputAnnotation.fromPartial(e)) || [];
    message.annotationPassthrough = object.annotationPassthrough ?? false;
    message.events = object.events?.map((e) => AppPlatformEventBody.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAppPlatformCloudFunctionResponse_StructedOutputAnnotation(): AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
  return { annotation: undefined };
}

export const AppPlatformCloudFunctionResponse_StructedOutputAnnotation: MessageFns<
  AppPlatformCloudFunctionResponse_StructedOutputAnnotation
> = {
  encode(
    message: AppPlatformCloudFunctionResponse_StructedOutputAnnotation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.annotation !== undefined) {
      Struct.encode(Struct.wrap(message.annotation), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformCloudFunctionResponse_StructedOutputAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
    return { annotation: isObject(object.annotation) ? object.annotation : undefined };
  },

  toJSON(message: AppPlatformCloudFunctionResponse_StructedOutputAnnotation): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = message.annotation;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AppPlatformCloudFunctionResponse_StructedOutputAnnotation>,
  ): AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
    return AppPlatformCloudFunctionResponse_StructedOutputAnnotation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AppPlatformCloudFunctionResponse_StructedOutputAnnotation>,
  ): AppPlatformCloudFunctionResponse_StructedOutputAnnotation {
    const message = createBaseAppPlatformCloudFunctionResponse_StructedOutputAnnotation();
    message.annotation = object.annotation ?? undefined;
    return message;
  },
};

function createBaseAppPlatformEventBody(): AppPlatformEventBody {
  return { eventMessage: "", payload: undefined, eventId: "" };
}

export const AppPlatformEventBody: MessageFns<AppPlatformEventBody> = {
  encode(message: AppPlatformEventBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventMessage !== "") {
      writer.uint32(10).string(message.eventMessage);
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(18).fork()).join();
    }
    if (message.eventId !== "") {
      writer.uint32(26).string(message.eventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppPlatformEventBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppPlatformEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventMessage = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppPlatformEventBody {
    return {
      eventMessage: isSet(object.eventMessage) ? globalThis.String(object.eventMessage) : "",
      payload: isObject(object.payload) ? object.payload : undefined,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
    };
  },

  toJSON(message: AppPlatformEventBody): unknown {
    const obj: any = {};
    if (message.eventMessage !== "") {
      obj.eventMessage = message.eventMessage;
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    return obj;
  },

  create(base?: DeepPartial<AppPlatformEventBody>): AppPlatformEventBody {
    return AppPlatformEventBody.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppPlatformEventBody>): AppPlatformEventBody {
    const message = createBaseAppPlatformEventBody();
    message.eventMessage = object.eventMessage ?? "";
    message.payload = object.payload ?? undefined;
    message.eventId = object.eventId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
