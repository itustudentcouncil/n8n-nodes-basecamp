// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1beta3/document_io.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";

export const protobufPackage = "google.cloud.documentai.v1beta3";

/** Payload message of raw document content (bytes). */
export interface RawDocument {
  /** Inline document content. */
  content: Buffer;
  /**
   * An IANA MIME type (RFC6838) indicating the nature and format of the
   * [content][google.cloud.documentai.v1beta3.RawDocument.content].
   */
  mimeType: string;
  /**
   * The display name of the document, it supports all Unicode characters except
   * the following:
   * `*`, `?`, `[`, `]`, `%`, `{`, `}`,`'`, `\"`, `,`
   * `~`, `=` and `:` are reserved.
   * If not specified, a default ID is generated.
   */
  displayName: string;
}

/** Specifies a document stored on Cloud Storage. */
export interface GcsDocument {
  /** The Cloud Storage object uri. */
  gcsUri: string;
  /** An IANA MIME type (RFC6838) of the content. */
  mimeType: string;
}

/** Specifies a set of documents on Cloud Storage. */
export interface GcsDocuments {
  /** The list of documents. */
  documents: GcsDocument[];
}

/** Specifies all documents on Cloud Storage with a common prefix. */
export interface GcsPrefix {
  /** The URI prefix. */
  gcsUriPrefix: string;
}

/** The common config to specify a set of documents used as input. */
export interface BatchDocumentsInputConfig {
  /** The set of documents that match the specified Cloud Storage `gcs_prefix`. */
  gcsPrefix?:
    | GcsPrefix
    | undefined;
  /** The set of documents individually specified on Cloud Storage. */
  gcsDocuments?: GcsDocuments | undefined;
}

/**
 * Config that controls the output of documents. All documents will be written
 * as a JSON file.
 */
export interface DocumentOutputConfig {
  /** Output config to write the results to Cloud Storage. */
  gcsOutputConfig?: DocumentOutputConfig_GcsOutputConfig | undefined;
}

/** The configuration used when outputting documents. */
export interface DocumentOutputConfig_GcsOutputConfig {
  /** The Cloud Storage uri (a directory) of the output. */
  gcsUri: string;
  /**
   * Specifies which fields to include in the output documents.
   * Only supports top level document and pages field so it must be in the
   * form of `{document_field_name}` or `pages.{page_field_name}`.
   */
  fieldMask:
    | string[]
    | undefined;
  /** Specifies the sharding config for the output document. */
  shardingConfig: DocumentOutputConfig_GcsOutputConfig_ShardingConfig | undefined;
}

/** The sharding config for the output document. */
export interface DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
  /** The number of pages per shard. */
  pagesPerShard: number;
  /** The number of overlapping pages between consecutive shards. */
  pagesOverlap: number;
}

/** Config for Document OCR. */
export interface OcrConfig {
  /** Hints for the OCR model. */
  hints:
    | OcrConfig_Hints
    | undefined;
  /**
   * Enables special handling for PDFs with existing text information. Results
   * in better text extraction quality in such PDF inputs.
   */
  enableNativePdfParsing: boolean;
  /**
   * Enables intelligent document quality scores after OCR. Can help with
   * diagnosing why OCR responses are of poor quality for a given input.
   * Adds additional latency comparable to regular OCR to the process call.
   */
  enableImageQualityScores: boolean;
  /**
   * A list of advanced OCR options to further fine-tune OCR behavior. Current
   * valid values are:
   *
   * - `legacy_layout`: a heuristics layout detection algorithm, which serves as
   * an alternative to the current ML-based layout detection algorithm.
   * Customers can choose the best suitable layout algorithm based on their
   * situation.
   */
  advancedOcrOptions: string[];
  /** Includes symbol level OCR information if set to true. */
  enableSymbol: boolean;
  /**
   * Turn on font identification model and return font style information.
   * Deprecated, use
   * [PremiumFeatures.compute_style_info][google.cloud.documentai.v1beta3.OcrConfig.PremiumFeatures.compute_style_info]
   * instead.
   *
   * @deprecated
   */
  computeStyleInfo: boolean;
  /**
   * Turn off character box detector in OCR engine. Character box detection is
   * enabled by default in OCR 2.0 (and later) processors.
   */
  disableCharacterBoxesDetection: boolean;
  /** Configurations for premium OCR features. */
  premiumFeatures: OcrConfig_PremiumFeatures | undefined;
}

/** Hints for OCR Engine */
export interface OcrConfig_Hints {
  /**
   * List of BCP-47 language codes to use for OCR. In most cases, not
   * specifying it yields the best results since it enables automatic language
   * detection. For languages based on the Latin alphabet, setting hints is
   * not needed. In rare cases, when the language of the text in the
   * image is known, setting a hint will help get better results (although it
   * will be a significant hindrance if the hint is wrong).
   */
  languageHints: string[];
}

/** Configurations for premium OCR features. */
export interface OcrConfig_PremiumFeatures {
  /**
   * Turn on selection mark detector in OCR engine. Only available in OCR 2.0
   * (and later) processors.
   */
  enableSelectionMarkDetection: boolean;
  /** Turn on font identification model and return font style information. */
  computeStyleInfo: boolean;
  /** Turn on the model that can extract LaTeX math formulas. */
  enableMathOcr: boolean;
}

function createBaseRawDocument(): RawDocument {
  return { content: Buffer.alloc(0), mimeType: "", displayName: "" };
}

export const RawDocument: MessageFns<RawDocument> = {
  encode(message: RawDocument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawDocument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawDocument {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: RawDocument): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<RawDocument>): RawDocument {
    return RawDocument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawDocument>): RawDocument {
    const message = createBaseRawDocument();
    message.content = object.content ?? Buffer.alloc(0);
    message.mimeType = object.mimeType ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseGcsDocument(): GcsDocument {
  return { gcsUri: "", mimeType: "" };
}

export const GcsDocument: MessageFns<GcsDocument> = {
  encode(message: GcsDocument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUri !== "") {
      writer.uint32(10).string(message.gcsUri);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDocument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDocument {
    return {
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: GcsDocument): unknown {
    const obj: any = {};
    if (message.gcsUri !== "") {
      obj.gcsUri = message.gcsUri;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDocument>): GcsDocument {
    return GcsDocument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDocument>): GcsDocument {
    const message = createBaseGcsDocument();
    message.gcsUri = object.gcsUri ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseGcsDocuments(): GcsDocuments {
  return { documents: [] };
}

export const GcsDocuments: MessageFns<GcsDocuments> = {
  encode(message: GcsDocuments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      GcsDocument.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDocuments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDocuments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documents.push(GcsDocument.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDocuments {
    return {
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => GcsDocument.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GcsDocuments): unknown {
    const obj: any = {};
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => GcsDocument.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDocuments>): GcsDocuments {
    return GcsDocuments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDocuments>): GcsDocuments {
    const message = createBaseGcsDocuments();
    message.documents = object.documents?.map((e) => GcsDocument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGcsPrefix(): GcsPrefix {
  return { gcsUriPrefix: "" };
}

export const GcsPrefix: MessageFns<GcsPrefix> = {
  encode(message: GcsPrefix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUriPrefix !== "") {
      writer.uint32(10).string(message.gcsUriPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsPrefix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsPrefix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUriPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsPrefix {
    return { gcsUriPrefix: isSet(object.gcsUriPrefix) ? globalThis.String(object.gcsUriPrefix) : "" };
  },

  toJSON(message: GcsPrefix): unknown {
    const obj: any = {};
    if (message.gcsUriPrefix !== "") {
      obj.gcsUriPrefix = message.gcsUriPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsPrefix>): GcsPrefix {
    return GcsPrefix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsPrefix>): GcsPrefix {
    const message = createBaseGcsPrefix();
    message.gcsUriPrefix = object.gcsUriPrefix ?? "";
    return message;
  },
};

function createBaseBatchDocumentsInputConfig(): BatchDocumentsInputConfig {
  return { gcsPrefix: undefined, gcsDocuments: undefined };
}

export const BatchDocumentsInputConfig: MessageFns<BatchDocumentsInputConfig> = {
  encode(message: BatchDocumentsInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsPrefix !== undefined) {
      GcsPrefix.encode(message.gcsPrefix, writer.uint32(10).fork()).join();
    }
    if (message.gcsDocuments !== undefined) {
      GcsDocuments.encode(message.gcsDocuments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDocumentsInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDocumentsInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsPrefix = GcsPrefix.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsDocuments = GcsDocuments.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDocumentsInputConfig {
    return {
      gcsPrefix: isSet(object.gcsPrefix) ? GcsPrefix.fromJSON(object.gcsPrefix) : undefined,
      gcsDocuments: isSet(object.gcsDocuments) ? GcsDocuments.fromJSON(object.gcsDocuments) : undefined,
    };
  },

  toJSON(message: BatchDocumentsInputConfig): unknown {
    const obj: any = {};
    if (message.gcsPrefix !== undefined) {
      obj.gcsPrefix = GcsPrefix.toJSON(message.gcsPrefix);
    }
    if (message.gcsDocuments !== undefined) {
      obj.gcsDocuments = GcsDocuments.toJSON(message.gcsDocuments);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDocumentsInputConfig>): BatchDocumentsInputConfig {
    return BatchDocumentsInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDocumentsInputConfig>): BatchDocumentsInputConfig {
    const message = createBaseBatchDocumentsInputConfig();
    message.gcsPrefix = (object.gcsPrefix !== undefined && object.gcsPrefix !== null)
      ? GcsPrefix.fromPartial(object.gcsPrefix)
      : undefined;
    message.gcsDocuments = (object.gcsDocuments !== undefined && object.gcsDocuments !== null)
      ? GcsDocuments.fromPartial(object.gcsDocuments)
      : undefined;
    return message;
  },
};

function createBaseDocumentOutputConfig(): DocumentOutputConfig {
  return { gcsOutputConfig: undefined };
}

export const DocumentOutputConfig: MessageFns<DocumentOutputConfig> = {
  encode(message: DocumentOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsOutputConfig !== undefined) {
      DocumentOutputConfig_GcsOutputConfig.encode(message.gcsOutputConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsOutputConfig = DocumentOutputConfig_GcsOutputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentOutputConfig {
    return {
      gcsOutputConfig: isSet(object.gcsOutputConfig)
        ? DocumentOutputConfig_GcsOutputConfig.fromJSON(object.gcsOutputConfig)
        : undefined,
    };
  },

  toJSON(message: DocumentOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsOutputConfig !== undefined) {
      obj.gcsOutputConfig = DocumentOutputConfig_GcsOutputConfig.toJSON(message.gcsOutputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentOutputConfig>): DocumentOutputConfig {
    return DocumentOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentOutputConfig>): DocumentOutputConfig {
    const message = createBaseDocumentOutputConfig();
    message.gcsOutputConfig = (object.gcsOutputConfig !== undefined && object.gcsOutputConfig !== null)
      ? DocumentOutputConfig_GcsOutputConfig.fromPartial(object.gcsOutputConfig)
      : undefined;
    return message;
  },
};

function createBaseDocumentOutputConfig_GcsOutputConfig(): DocumentOutputConfig_GcsOutputConfig {
  return { gcsUri: "", fieldMask: undefined, shardingConfig: undefined };
}

export const DocumentOutputConfig_GcsOutputConfig: MessageFns<DocumentOutputConfig_GcsOutputConfig> = {
  encode(message: DocumentOutputConfig_GcsOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUri !== "") {
      writer.uint32(10).string(message.gcsUri);
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(18).fork()).join();
    }
    if (message.shardingConfig !== undefined) {
      DocumentOutputConfig_GcsOutputConfig_ShardingConfig.encode(message.shardingConfig, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentOutputConfig_GcsOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentOutputConfig_GcsOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shardingConfig = DocumentOutputConfig_GcsOutputConfig_ShardingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentOutputConfig_GcsOutputConfig {
    return {
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : "",
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
      shardingConfig: isSet(object.shardingConfig)
        ? DocumentOutputConfig_GcsOutputConfig_ShardingConfig.fromJSON(object.shardingConfig)
        : undefined,
    };
  },

  toJSON(message: DocumentOutputConfig_GcsOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsUri !== "") {
      obj.gcsUri = message.gcsUri;
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    if (message.shardingConfig !== undefined) {
      obj.shardingConfig = DocumentOutputConfig_GcsOutputConfig_ShardingConfig.toJSON(message.shardingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentOutputConfig_GcsOutputConfig>): DocumentOutputConfig_GcsOutputConfig {
    return DocumentOutputConfig_GcsOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentOutputConfig_GcsOutputConfig>): DocumentOutputConfig_GcsOutputConfig {
    const message = createBaseDocumentOutputConfig_GcsOutputConfig();
    message.gcsUri = object.gcsUri ?? "";
    message.fieldMask = object.fieldMask ?? undefined;
    message.shardingConfig = (object.shardingConfig !== undefined && object.shardingConfig !== null)
      ? DocumentOutputConfig_GcsOutputConfig_ShardingConfig.fromPartial(object.shardingConfig)
      : undefined;
    return message;
  },
};

function createBaseDocumentOutputConfig_GcsOutputConfig_ShardingConfig(): DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
  return { pagesPerShard: 0, pagesOverlap: 0 };
}

export const DocumentOutputConfig_GcsOutputConfig_ShardingConfig: MessageFns<
  DocumentOutputConfig_GcsOutputConfig_ShardingConfig
> = {
  encode(
    message: DocumentOutputConfig_GcsOutputConfig_ShardingConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pagesPerShard !== 0) {
      writer.uint32(8).int32(message.pagesPerShard);
    }
    if (message.pagesOverlap !== 0) {
      writer.uint32(16).int32(message.pagesOverlap);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentOutputConfig_GcsOutputConfig_ShardingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pagesPerShard = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pagesOverlap = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
    return {
      pagesPerShard: isSet(object.pagesPerShard) ? globalThis.Number(object.pagesPerShard) : 0,
      pagesOverlap: isSet(object.pagesOverlap) ? globalThis.Number(object.pagesOverlap) : 0,
    };
  },

  toJSON(message: DocumentOutputConfig_GcsOutputConfig_ShardingConfig): unknown {
    const obj: any = {};
    if (message.pagesPerShard !== 0) {
      obj.pagesPerShard = Math.round(message.pagesPerShard);
    }
    if (message.pagesOverlap !== 0) {
      obj.pagesOverlap = Math.round(message.pagesOverlap);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DocumentOutputConfig_GcsOutputConfig_ShardingConfig>,
  ): DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
    return DocumentOutputConfig_GcsOutputConfig_ShardingConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DocumentOutputConfig_GcsOutputConfig_ShardingConfig>,
  ): DocumentOutputConfig_GcsOutputConfig_ShardingConfig {
    const message = createBaseDocumentOutputConfig_GcsOutputConfig_ShardingConfig();
    message.pagesPerShard = object.pagesPerShard ?? 0;
    message.pagesOverlap = object.pagesOverlap ?? 0;
    return message;
  },
};

function createBaseOcrConfig(): OcrConfig {
  return {
    hints: undefined,
    enableNativePdfParsing: false,
    enableImageQualityScores: false,
    advancedOcrOptions: [],
    enableSymbol: false,
    computeStyleInfo: false,
    disableCharacterBoxesDetection: false,
    premiumFeatures: undefined,
  };
}

export const OcrConfig: MessageFns<OcrConfig> = {
  encode(message: OcrConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hints !== undefined) {
      OcrConfig_Hints.encode(message.hints, writer.uint32(18).fork()).join();
    }
    if (message.enableNativePdfParsing !== false) {
      writer.uint32(24).bool(message.enableNativePdfParsing);
    }
    if (message.enableImageQualityScores !== false) {
      writer.uint32(32).bool(message.enableImageQualityScores);
    }
    for (const v of message.advancedOcrOptions) {
      writer.uint32(42).string(v!);
    }
    if (message.enableSymbol !== false) {
      writer.uint32(48).bool(message.enableSymbol);
    }
    if (message.computeStyleInfo !== false) {
      writer.uint32(64).bool(message.computeStyleInfo);
    }
    if (message.disableCharacterBoxesDetection !== false) {
      writer.uint32(80).bool(message.disableCharacterBoxesDetection);
    }
    if (message.premiumFeatures !== undefined) {
      OcrConfig_PremiumFeatures.encode(message.premiumFeatures, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OcrConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOcrConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hints = OcrConfig_Hints.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableNativePdfParsing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableImageQualityScores = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.advancedOcrOptions.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.enableSymbol = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.computeStyleInfo = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.disableCharacterBoxesDetection = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.premiumFeatures = OcrConfig_PremiumFeatures.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OcrConfig {
    return {
      hints: isSet(object.hints) ? OcrConfig_Hints.fromJSON(object.hints) : undefined,
      enableNativePdfParsing: isSet(object.enableNativePdfParsing)
        ? globalThis.Boolean(object.enableNativePdfParsing)
        : false,
      enableImageQualityScores: isSet(object.enableImageQualityScores)
        ? globalThis.Boolean(object.enableImageQualityScores)
        : false,
      advancedOcrOptions: globalThis.Array.isArray(object?.advancedOcrOptions)
        ? object.advancedOcrOptions.map((e: any) => globalThis.String(e))
        : [],
      enableSymbol: isSet(object.enableSymbol) ? globalThis.Boolean(object.enableSymbol) : false,
      computeStyleInfo: isSet(object.computeStyleInfo) ? globalThis.Boolean(object.computeStyleInfo) : false,
      disableCharacterBoxesDetection: isSet(object.disableCharacterBoxesDetection)
        ? globalThis.Boolean(object.disableCharacterBoxesDetection)
        : false,
      premiumFeatures: isSet(object.premiumFeatures)
        ? OcrConfig_PremiumFeatures.fromJSON(object.premiumFeatures)
        : undefined,
    };
  },

  toJSON(message: OcrConfig): unknown {
    const obj: any = {};
    if (message.hints !== undefined) {
      obj.hints = OcrConfig_Hints.toJSON(message.hints);
    }
    if (message.enableNativePdfParsing !== false) {
      obj.enableNativePdfParsing = message.enableNativePdfParsing;
    }
    if (message.enableImageQualityScores !== false) {
      obj.enableImageQualityScores = message.enableImageQualityScores;
    }
    if (message.advancedOcrOptions?.length) {
      obj.advancedOcrOptions = message.advancedOcrOptions;
    }
    if (message.enableSymbol !== false) {
      obj.enableSymbol = message.enableSymbol;
    }
    if (message.computeStyleInfo !== false) {
      obj.computeStyleInfo = message.computeStyleInfo;
    }
    if (message.disableCharacterBoxesDetection !== false) {
      obj.disableCharacterBoxesDetection = message.disableCharacterBoxesDetection;
    }
    if (message.premiumFeatures !== undefined) {
      obj.premiumFeatures = OcrConfig_PremiumFeatures.toJSON(message.premiumFeatures);
    }
    return obj;
  },

  create(base?: DeepPartial<OcrConfig>): OcrConfig {
    return OcrConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OcrConfig>): OcrConfig {
    const message = createBaseOcrConfig();
    message.hints = (object.hints !== undefined && object.hints !== null)
      ? OcrConfig_Hints.fromPartial(object.hints)
      : undefined;
    message.enableNativePdfParsing = object.enableNativePdfParsing ?? false;
    message.enableImageQualityScores = object.enableImageQualityScores ?? false;
    message.advancedOcrOptions = object.advancedOcrOptions?.map((e) => e) || [];
    message.enableSymbol = object.enableSymbol ?? false;
    message.computeStyleInfo = object.computeStyleInfo ?? false;
    message.disableCharacterBoxesDetection = object.disableCharacterBoxesDetection ?? false;
    message.premiumFeatures = (object.premiumFeatures !== undefined && object.premiumFeatures !== null)
      ? OcrConfig_PremiumFeatures.fromPartial(object.premiumFeatures)
      : undefined;
    return message;
  },
};

function createBaseOcrConfig_Hints(): OcrConfig_Hints {
  return { languageHints: [] };
}

export const OcrConfig_Hints: MessageFns<OcrConfig_Hints> = {
  encode(message: OcrConfig_Hints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languageHints) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OcrConfig_Hints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOcrConfig_Hints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageHints.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OcrConfig_Hints {
    return {
      languageHints: globalThis.Array.isArray(object?.languageHints)
        ? object.languageHints.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OcrConfig_Hints): unknown {
    const obj: any = {};
    if (message.languageHints?.length) {
      obj.languageHints = message.languageHints;
    }
    return obj;
  },

  create(base?: DeepPartial<OcrConfig_Hints>): OcrConfig_Hints {
    return OcrConfig_Hints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OcrConfig_Hints>): OcrConfig_Hints {
    const message = createBaseOcrConfig_Hints();
    message.languageHints = object.languageHints?.map((e) => e) || [];
    return message;
  },
};

function createBaseOcrConfig_PremiumFeatures(): OcrConfig_PremiumFeatures {
  return { enableSelectionMarkDetection: false, computeStyleInfo: false, enableMathOcr: false };
}

export const OcrConfig_PremiumFeatures: MessageFns<OcrConfig_PremiumFeatures> = {
  encode(message: OcrConfig_PremiumFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSelectionMarkDetection !== false) {
      writer.uint32(24).bool(message.enableSelectionMarkDetection);
    }
    if (message.computeStyleInfo !== false) {
      writer.uint32(32).bool(message.computeStyleInfo);
    }
    if (message.enableMathOcr !== false) {
      writer.uint32(40).bool(message.enableMathOcr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OcrConfig_PremiumFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOcrConfig_PremiumFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableSelectionMarkDetection = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.computeStyleInfo = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableMathOcr = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OcrConfig_PremiumFeatures {
    return {
      enableSelectionMarkDetection: isSet(object.enableSelectionMarkDetection)
        ? globalThis.Boolean(object.enableSelectionMarkDetection)
        : false,
      computeStyleInfo: isSet(object.computeStyleInfo) ? globalThis.Boolean(object.computeStyleInfo) : false,
      enableMathOcr: isSet(object.enableMathOcr) ? globalThis.Boolean(object.enableMathOcr) : false,
    };
  },

  toJSON(message: OcrConfig_PremiumFeatures): unknown {
    const obj: any = {};
    if (message.enableSelectionMarkDetection !== false) {
      obj.enableSelectionMarkDetection = message.enableSelectionMarkDetection;
    }
    if (message.computeStyleInfo !== false) {
      obj.computeStyleInfo = message.computeStyleInfo;
    }
    if (message.enableMathOcr !== false) {
      obj.enableMathOcr = message.enableMathOcr;
    }
    return obj;
  },

  create(base?: DeepPartial<OcrConfig_PremiumFeatures>): OcrConfig_PremiumFeatures {
    return OcrConfig_PremiumFeatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OcrConfig_PremiumFeatures>): OcrConfig_PremiumFeatures {
    const message = createBaseOcrConfig_PremiumFeatures();
    message.enableSelectionMarkDetection = object.enableSelectionMarkDetection ?? false;
    message.computeStyleInfo = object.computeStyleInfo ?? false;
    message.enableMathOcr = object.enableMathOcr ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
