// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1/processor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DocumentSchema } from "./document_schema.js";
import { EvaluationReference } from "./evaluation.js";

export const protobufPackage = "google.cloud.documentai.v1";

/**
 * A processor version is an implementation of a processor. Each processor
 * can have multiple versions, pretrained by Google internally or uptrained
 * by the customer. A processor can only have one default version at a time.
 * Its document-processing behavior is defined by that version.
 */
export interface ProcessorVersion {
  /**
   * Identifier. The resource name of the processor version.
   * Format:
   * `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processor_version}`
   */
  name: string;
  /** The display name of the processor version. */
  displayName: string;
  /** The schema of the processor version. Describes the output. */
  documentSchema:
    | DocumentSchema
    | undefined;
  /** Output only. The state of the processor version. */
  state: ProcessorVersion_State;
  /** The time the processor version was created. */
  createTime:
    | Date
    | undefined;
  /** The most recently invoked evaluation for the processor version. */
  latestEvaluation:
    | EvaluationReference
    | undefined;
  /** The KMS key name used for encryption. */
  kmsKeyName: string;
  /** The KMS key version with which data is encrypted. */
  kmsKeyVersionName: string;
  /** Output only. Denotes that this `ProcessorVersion` is managed by Google. */
  googleManaged: boolean;
  /** If set, information about the eventual deprecation of this version. */
  deprecationInfo:
    | ProcessorVersion_DeprecationInfo
    | undefined;
  /** Output only. The model type of this processor version. */
  modelType: ProcessorVersion_ModelType;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
  /**
   * Output only. Information about Generative AI model-based processor
   * versions.
   */
  genAiModelInfo: ProcessorVersion_GenAiModelInfo | undefined;
}

/** The possible states of the processor version. */
export enum ProcessorVersion_State {
  /** STATE_UNSPECIFIED - The processor version is in an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** DEPLOYED - The processor version is deployed and can be used for processing. */
  DEPLOYED = 1,
  /** DEPLOYING - The processor version is being deployed. */
  DEPLOYING = 2,
  /** UNDEPLOYED - The processor version is not deployed and cannot be used for processing. */
  UNDEPLOYED = 3,
  /** UNDEPLOYING - The processor version is being undeployed. */
  UNDEPLOYING = 4,
  /** CREATING - The processor version is being created. */
  CREATING = 5,
  /** DELETING - The processor version is being deleted. */
  DELETING = 6,
  /** FAILED - The processor version failed and is in an indeterminate state. */
  FAILED = 7,
  /** IMPORTING - The processor version is being imported. */
  IMPORTING = 8,
  UNRECOGNIZED = -1,
}

export function processorVersion_StateFromJSON(object: any): ProcessorVersion_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ProcessorVersion_State.STATE_UNSPECIFIED;
    case 1:
    case "DEPLOYED":
      return ProcessorVersion_State.DEPLOYED;
    case 2:
    case "DEPLOYING":
      return ProcessorVersion_State.DEPLOYING;
    case 3:
    case "UNDEPLOYED":
      return ProcessorVersion_State.UNDEPLOYED;
    case 4:
    case "UNDEPLOYING":
      return ProcessorVersion_State.UNDEPLOYING;
    case 5:
    case "CREATING":
      return ProcessorVersion_State.CREATING;
    case 6:
    case "DELETING":
      return ProcessorVersion_State.DELETING;
    case 7:
    case "FAILED":
      return ProcessorVersion_State.FAILED;
    case 8:
    case "IMPORTING":
      return ProcessorVersion_State.IMPORTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessorVersion_State.UNRECOGNIZED;
  }
}

export function processorVersion_StateToJSON(object: ProcessorVersion_State): string {
  switch (object) {
    case ProcessorVersion_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ProcessorVersion_State.DEPLOYED:
      return "DEPLOYED";
    case ProcessorVersion_State.DEPLOYING:
      return "DEPLOYING";
    case ProcessorVersion_State.UNDEPLOYED:
      return "UNDEPLOYED";
    case ProcessorVersion_State.UNDEPLOYING:
      return "UNDEPLOYING";
    case ProcessorVersion_State.CREATING:
      return "CREATING";
    case ProcessorVersion_State.DELETING:
      return "DELETING";
    case ProcessorVersion_State.FAILED:
      return "FAILED";
    case ProcessorVersion_State.IMPORTING:
      return "IMPORTING";
    case ProcessorVersion_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The possible model types of the processor version. */
export enum ProcessorVersion_ModelType {
  /** MODEL_TYPE_UNSPECIFIED - The processor version has unspecified model type. */
  MODEL_TYPE_UNSPECIFIED = 0,
  /** MODEL_TYPE_GENERATIVE - The processor version has generative model type. */
  MODEL_TYPE_GENERATIVE = 1,
  /** MODEL_TYPE_CUSTOM - The processor version has custom model type. */
  MODEL_TYPE_CUSTOM = 2,
  UNRECOGNIZED = -1,
}

export function processorVersion_ModelTypeFromJSON(object: any): ProcessorVersion_ModelType {
  switch (object) {
    case 0:
    case "MODEL_TYPE_UNSPECIFIED":
      return ProcessorVersion_ModelType.MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "MODEL_TYPE_GENERATIVE":
      return ProcessorVersion_ModelType.MODEL_TYPE_GENERATIVE;
    case 2:
    case "MODEL_TYPE_CUSTOM":
      return ProcessorVersion_ModelType.MODEL_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessorVersion_ModelType.UNRECOGNIZED;
  }
}

export function processorVersion_ModelTypeToJSON(object: ProcessorVersion_ModelType): string {
  switch (object) {
    case ProcessorVersion_ModelType.MODEL_TYPE_UNSPECIFIED:
      return "MODEL_TYPE_UNSPECIFIED";
    case ProcessorVersion_ModelType.MODEL_TYPE_GENERATIVE:
      return "MODEL_TYPE_GENERATIVE";
    case ProcessorVersion_ModelType.MODEL_TYPE_CUSTOM:
      return "MODEL_TYPE_CUSTOM";
    case ProcessorVersion_ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the upcoming deprecation of this processor version. */
export interface ProcessorVersion_DeprecationInfo {
  /** The time at which this processor version will be deprecated. */
  deprecationTime:
    | Date
    | undefined;
  /** If set, the processor version that will be used as a replacement. */
  replacementProcessorVersion: string;
}

/** Information about Generative AI model-based processor versions. */
export interface ProcessorVersion_GenAiModelInfo {
  /** Information for a pretrained Google-managed foundation model. */
  foundationGenAiModelInfo?:
    | ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo
    | undefined;
  /** Information for a custom Generative AI model created by the user. */
  customGenAiModelInfo?: ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo | undefined;
}

/** Information for a pretrained Google-managed foundation model. */
export interface ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
  /** Whether finetuning is allowed for this base processor version. */
  finetuningAllowed: boolean;
  /**
   * The minimum number of labeled documents in the training dataset
   * required for finetuning.
   */
  minTrainLabeledDocuments: number;
}

/**
 * Information for a custom Generative AI model created by the user. These
 * are created with `Create New Version` in either the `Call foundation
 * model` or `Fine tuning` tabs.
 */
export interface ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
  /** The type of custom model created by the user. */
  customModelType: ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType;
  /** The base processor version ID for the custom model. */
  baseProcessorVersionId: string;
}

/** The type of custom model created by the user. */
export enum ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType {
  /** CUSTOM_MODEL_TYPE_UNSPECIFIED - The model type is unspecified. */
  CUSTOM_MODEL_TYPE_UNSPECIFIED = 0,
  /** VERSIONED_FOUNDATION - The model is a versioned foundation model. */
  VERSIONED_FOUNDATION = 1,
  /** FINE_TUNED - The model is a finetuned foundation model. */
  FINE_TUNED = 2,
  UNRECOGNIZED = -1,
}

export function processorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelTypeFromJSON(
  object: any,
): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType {
  switch (object) {
    case 0:
    case "CUSTOM_MODEL_TYPE_UNSPECIFIED":
      return ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.CUSTOM_MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "VERSIONED_FOUNDATION":
      return ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.VERSIONED_FOUNDATION;
    case 2:
    case "FINE_TUNED":
      return ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.FINE_TUNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.UNRECOGNIZED;
  }
}

export function processorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelTypeToJSON(
  object: ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType,
): string {
  switch (object) {
    case ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.CUSTOM_MODEL_TYPE_UNSPECIFIED:
      return "CUSTOM_MODEL_TYPE_UNSPECIFIED";
    case ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.VERSIONED_FOUNDATION:
      return "VERSIONED_FOUNDATION";
    case ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.FINE_TUNED:
      return "FINE_TUNED";
    case ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains the alias and the aliased resource name of processor version. */
export interface ProcessorVersionAlias {
  /** The alias in the form of `processor_version` resource name. */
  alias: string;
  /** The resource name of aliased processor version. */
  processorVersion: string;
}

/**
 * The first-class citizen for Document AI. Each processor defines how to
 * extract structural information from a document.
 */
export interface Processor {
  /**
   * Output only. Immutable. The resource name of the processor.
   * Format: `projects/{project}/locations/{location}/processors/{processor}`
   */
  name: string;
  /**
   * The processor type, such as: `OCR_PROCESSOR`, `INVOICE_PROCESSOR`.
   * To get a list of processor types, see
   * [FetchProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes].
   */
  type: string;
  /** The display name of the processor. */
  displayName: string;
  /** Output only. The state of the processor. */
  state: Processor_State;
  /** The default processor version. */
  defaultProcessorVersion: string;
  /** Output only. The processor version aliases. */
  processorVersionAliases: ProcessorVersionAlias[];
  /**
   * Output only. Immutable. The http endpoint that can be called to invoke
   * processing.
   */
  processEndpoint: string;
  /** The time the processor was created. */
  createTime:
    | Date
    | undefined;
  /**
   * The [KMS key](https://cloud.google.com/security-key-management) used for
   * encryption and decryption in CMEK scenarios.
   */
  kmsKeyName: string;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

/** The possible states of the processor. */
export enum Processor_State {
  /** STATE_UNSPECIFIED - The processor is in an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * ENABLED - The processor is enabled, i.e., has an enabled version which can
   * currently serve processing requests and all the feature dependencies have
   * been successfully initialized.
   */
  ENABLED = 1,
  /** DISABLED - The processor is disabled. */
  DISABLED = 2,
  /** ENABLING - The processor is being enabled, will become `ENABLED` if successful. */
  ENABLING = 3,
  /** DISABLING - The processor is being disabled, will become `DISABLED` if successful. */
  DISABLING = 4,
  /**
   * CREATING - The processor is being created, will become either `ENABLED` (for
   * successful creation) or `FAILED` (for failed ones).
   * Once a processor is in this state, it can then be used for document
   * processing, but the feature dependencies of the processor might not be
   * fully created yet.
   */
  CREATING = 5,
  /**
   * FAILED - The processor failed during creation or initialization of feature
   * dependencies. The user should delete the processor and recreate one as
   * all the functionalities of the processor are disabled.
   */
  FAILED = 6,
  /** DELETING - The processor is being deleted, will be removed if successful. */
  DELETING = 7,
  UNRECOGNIZED = -1,
}

export function processor_StateFromJSON(object: any): Processor_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Processor_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Processor_State.ENABLED;
    case 2:
    case "DISABLED":
      return Processor_State.DISABLED;
    case 3:
    case "ENABLING":
      return Processor_State.ENABLING;
    case 4:
    case "DISABLING":
      return Processor_State.DISABLING;
    case 5:
    case "CREATING":
      return Processor_State.CREATING;
    case 6:
    case "FAILED":
      return Processor_State.FAILED;
    case 7:
    case "DELETING":
      return Processor_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Processor_State.UNRECOGNIZED;
  }
}

export function processor_StateToJSON(object: Processor_State): string {
  switch (object) {
    case Processor_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Processor_State.ENABLED:
      return "ENABLED";
    case Processor_State.DISABLED:
      return "DISABLED";
    case Processor_State.ENABLING:
      return "ENABLING";
    case Processor_State.DISABLING:
      return "DISABLING";
    case Processor_State.CREATING:
      return "CREATING";
    case Processor_State.FAILED:
      return "FAILED";
    case Processor_State.DELETING:
      return "DELETING";
    case Processor_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseProcessorVersion(): ProcessorVersion {
  return {
    name: "",
    displayName: "",
    documentSchema: undefined,
    state: 0,
    createTime: undefined,
    latestEvaluation: undefined,
    kmsKeyName: "",
    kmsKeyVersionName: "",
    googleManaged: false,
    deprecationInfo: undefined,
    modelType: 0,
    satisfiesPzs: false,
    satisfiesPzi: false,
    genAiModelInfo: undefined,
  };
}

export const ProcessorVersion: MessageFns<ProcessorVersion> = {
  encode(message: ProcessorVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.documentSchema !== undefined) {
      DocumentSchema.encode(message.documentSchema, writer.uint32(98).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.latestEvaluation !== undefined) {
      EvaluationReference.encode(message.latestEvaluation, writer.uint32(66).fork()).join();
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(74).string(message.kmsKeyName);
    }
    if (message.kmsKeyVersionName !== "") {
      writer.uint32(82).string(message.kmsKeyVersionName);
    }
    if (message.googleManaged !== false) {
      writer.uint32(88).bool(message.googleManaged);
    }
    if (message.deprecationInfo !== undefined) {
      ProcessorVersion_DeprecationInfo.encode(message.deprecationInfo, writer.uint32(106).fork()).join();
    }
    if (message.modelType !== 0) {
      writer.uint32(120).int32(message.modelType);
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(128).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(136).bool(message.satisfiesPzi);
    }
    if (message.genAiModelInfo !== undefined) {
      ProcessorVersion_GenAiModelInfo.encode(message.genAiModelInfo, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.documentSchema = DocumentSchema.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latestEvaluation = EvaluationReference.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.kmsKeyVersionName = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.googleManaged = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.deprecationInfo = ProcessorVersion_DeprecationInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.modelType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.genAiModelInfo = ProcessorVersion_GenAiModelInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      documentSchema: isSet(object.documentSchema) ? DocumentSchema.fromJSON(object.documentSchema) : undefined,
      state: isSet(object.state) ? processorVersion_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      latestEvaluation: isSet(object.latestEvaluation)
        ? EvaluationReference.fromJSON(object.latestEvaluation)
        : undefined,
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      kmsKeyVersionName: isSet(object.kmsKeyVersionName) ? globalThis.String(object.kmsKeyVersionName) : "",
      googleManaged: isSet(object.googleManaged) ? globalThis.Boolean(object.googleManaged) : false,
      deprecationInfo: isSet(object.deprecationInfo)
        ? ProcessorVersion_DeprecationInfo.fromJSON(object.deprecationInfo)
        : undefined,
      modelType: isSet(object.modelType) ? processorVersion_ModelTypeFromJSON(object.modelType) : 0,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
      genAiModelInfo: isSet(object.genAiModelInfo)
        ? ProcessorVersion_GenAiModelInfo.fromJSON(object.genAiModelInfo)
        : undefined,
    };
  },

  toJSON(message: ProcessorVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.documentSchema !== undefined) {
      obj.documentSchema = DocumentSchema.toJSON(message.documentSchema);
    }
    if (message.state !== 0) {
      obj.state = processorVersion_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.latestEvaluation !== undefined) {
      obj.latestEvaluation = EvaluationReference.toJSON(message.latestEvaluation);
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.kmsKeyVersionName !== "") {
      obj.kmsKeyVersionName = message.kmsKeyVersionName;
    }
    if (message.googleManaged !== false) {
      obj.googleManaged = message.googleManaged;
    }
    if (message.deprecationInfo !== undefined) {
      obj.deprecationInfo = ProcessorVersion_DeprecationInfo.toJSON(message.deprecationInfo);
    }
    if (message.modelType !== 0) {
      obj.modelType = processorVersion_ModelTypeToJSON(message.modelType);
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    if (message.genAiModelInfo !== undefined) {
      obj.genAiModelInfo = ProcessorVersion_GenAiModelInfo.toJSON(message.genAiModelInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorVersion>): ProcessorVersion {
    return ProcessorVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorVersion>): ProcessorVersion {
    const message = createBaseProcessorVersion();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.documentSchema = (object.documentSchema !== undefined && object.documentSchema !== null)
      ? DocumentSchema.fromPartial(object.documentSchema)
      : undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.latestEvaluation = (object.latestEvaluation !== undefined && object.latestEvaluation !== null)
      ? EvaluationReference.fromPartial(object.latestEvaluation)
      : undefined;
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.kmsKeyVersionName = object.kmsKeyVersionName ?? "";
    message.googleManaged = object.googleManaged ?? false;
    message.deprecationInfo = (object.deprecationInfo !== undefined && object.deprecationInfo !== null)
      ? ProcessorVersion_DeprecationInfo.fromPartial(object.deprecationInfo)
      : undefined;
    message.modelType = object.modelType ?? 0;
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    message.genAiModelInfo = (object.genAiModelInfo !== undefined && object.genAiModelInfo !== null)
      ? ProcessorVersion_GenAiModelInfo.fromPartial(object.genAiModelInfo)
      : undefined;
    return message;
  },
};

function createBaseProcessorVersion_DeprecationInfo(): ProcessorVersion_DeprecationInfo {
  return { deprecationTime: undefined, replacementProcessorVersion: "" };
}

export const ProcessorVersion_DeprecationInfo: MessageFns<ProcessorVersion_DeprecationInfo> = {
  encode(message: ProcessorVersion_DeprecationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deprecationTime), writer.uint32(10).fork()).join();
    }
    if (message.replacementProcessorVersion !== "") {
      writer.uint32(18).string(message.replacementProcessorVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersion_DeprecationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersion_DeprecationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deprecationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replacementProcessorVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersion_DeprecationInfo {
    return {
      deprecationTime: isSet(object.deprecationTime) ? fromJsonTimestamp(object.deprecationTime) : undefined,
      replacementProcessorVersion: isSet(object.replacementProcessorVersion)
        ? globalThis.String(object.replacementProcessorVersion)
        : "",
    };
  },

  toJSON(message: ProcessorVersion_DeprecationInfo): unknown {
    const obj: any = {};
    if (message.deprecationTime !== undefined) {
      obj.deprecationTime = message.deprecationTime.toISOString();
    }
    if (message.replacementProcessorVersion !== "") {
      obj.replacementProcessorVersion = message.replacementProcessorVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorVersion_DeprecationInfo>): ProcessorVersion_DeprecationInfo {
    return ProcessorVersion_DeprecationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorVersion_DeprecationInfo>): ProcessorVersion_DeprecationInfo {
    const message = createBaseProcessorVersion_DeprecationInfo();
    message.deprecationTime = object.deprecationTime ?? undefined;
    message.replacementProcessorVersion = object.replacementProcessorVersion ?? "";
    return message;
  },
};

function createBaseProcessorVersion_GenAiModelInfo(): ProcessorVersion_GenAiModelInfo {
  return { foundationGenAiModelInfo: undefined, customGenAiModelInfo: undefined };
}

export const ProcessorVersion_GenAiModelInfo: MessageFns<ProcessorVersion_GenAiModelInfo> = {
  encode(message: ProcessorVersion_GenAiModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.foundationGenAiModelInfo !== undefined) {
      ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.encode(
        message.foundationGenAiModelInfo,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.customGenAiModelInfo !== undefined) {
      ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.encode(
        message.customGenAiModelInfo,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersion_GenAiModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersion_GenAiModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.foundationGenAiModelInfo = ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customGenAiModelInfo = ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersion_GenAiModelInfo {
    return {
      foundationGenAiModelInfo: isSet(object.foundationGenAiModelInfo)
        ? ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.fromJSON(object.foundationGenAiModelInfo)
        : undefined,
      customGenAiModelInfo: isSet(object.customGenAiModelInfo)
        ? ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.fromJSON(object.customGenAiModelInfo)
        : undefined,
    };
  },

  toJSON(message: ProcessorVersion_GenAiModelInfo): unknown {
    const obj: any = {};
    if (message.foundationGenAiModelInfo !== undefined) {
      obj.foundationGenAiModelInfo = ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.toJSON(
        message.foundationGenAiModelInfo,
      );
    }
    if (message.customGenAiModelInfo !== undefined) {
      obj.customGenAiModelInfo = ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.toJSON(
        message.customGenAiModelInfo,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorVersion_GenAiModelInfo>): ProcessorVersion_GenAiModelInfo {
    return ProcessorVersion_GenAiModelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorVersion_GenAiModelInfo>): ProcessorVersion_GenAiModelInfo {
    const message = createBaseProcessorVersion_GenAiModelInfo();
    message.foundationGenAiModelInfo =
      (object.foundationGenAiModelInfo !== undefined && object.foundationGenAiModelInfo !== null)
        ? ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.fromPartial(object.foundationGenAiModelInfo)
        : undefined;
    message.customGenAiModelInfo = (object.customGenAiModelInfo !== undefined && object.customGenAiModelInfo !== null)
      ? ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.fromPartial(object.customGenAiModelInfo)
      : undefined;
    return message;
  },
};

function createBaseProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo(): ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
  return { finetuningAllowed: false, minTrainLabeledDocuments: 0 };
}

export const ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo: MessageFns<
  ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo
> = {
  encode(
    message: ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.finetuningAllowed !== false) {
      writer.uint32(8).bool(message.finetuningAllowed);
    }
    if (message.minTrainLabeledDocuments !== 0) {
      writer.uint32(16).int32(message.minTrainLabeledDocuments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.finetuningAllowed = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minTrainLabeledDocuments = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
    return {
      finetuningAllowed: isSet(object.finetuningAllowed) ? globalThis.Boolean(object.finetuningAllowed) : false,
      minTrainLabeledDocuments: isSet(object.minTrainLabeledDocuments)
        ? globalThis.Number(object.minTrainLabeledDocuments)
        : 0,
    };
  },

  toJSON(message: ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo): unknown {
    const obj: any = {};
    if (message.finetuningAllowed !== false) {
      obj.finetuningAllowed = message.finetuningAllowed;
    }
    if (message.minTrainLabeledDocuments !== 0) {
      obj.minTrainLabeledDocuments = Math.round(message.minTrainLabeledDocuments);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo>,
  ): ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
    return ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo>,
  ): ProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo {
    const message = createBaseProcessorVersion_GenAiModelInfo_FoundationGenAiModelInfo();
    message.finetuningAllowed = object.finetuningAllowed ?? false;
    message.minTrainLabeledDocuments = object.minTrainLabeledDocuments ?? 0;
    return message;
  },
};

function createBaseProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo(): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
  return { customModelType: 0, baseProcessorVersionId: "" };
}

export const ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo: MessageFns<
  ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo
> = {
  encode(
    message: ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.customModelType !== 0) {
      writer.uint32(8).int32(message.customModelType);
    }
    if (message.baseProcessorVersionId !== "") {
      writer.uint32(18).string(message.baseProcessorVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customModelType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseProcessorVersionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
    return {
      customModelType: isSet(object.customModelType)
        ? processorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelTypeFromJSON(object.customModelType)
        : 0,
      baseProcessorVersionId: isSet(object.baseProcessorVersionId)
        ? globalThis.String(object.baseProcessorVersionId)
        : "",
    };
  },

  toJSON(message: ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo): unknown {
    const obj: any = {};
    if (message.customModelType !== 0) {
      obj.customModelType = processorVersion_GenAiModelInfo_CustomGenAiModelInfo_CustomModelTypeToJSON(
        message.customModelType,
      );
    }
    if (message.baseProcessorVersionId !== "") {
      obj.baseProcessorVersionId = message.baseProcessorVersionId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo>,
  ): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
    return ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo>,
  ): ProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo {
    const message = createBaseProcessorVersion_GenAiModelInfo_CustomGenAiModelInfo();
    message.customModelType = object.customModelType ?? 0;
    message.baseProcessorVersionId = object.baseProcessorVersionId ?? "";
    return message;
  },
};

function createBaseProcessorVersionAlias(): ProcessorVersionAlias {
  return { alias: "", processorVersion: "" };
}

export const ProcessorVersionAlias: MessageFns<ProcessorVersionAlias> = {
  encode(message: ProcessorVersionAlias, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alias !== "") {
      writer.uint32(10).string(message.alias);
    }
    if (message.processorVersion !== "") {
      writer.uint32(18).string(message.processorVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorVersionAlias {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorVersionAlias();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alias = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processorVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorVersionAlias {
    return {
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
      processorVersion: isSet(object.processorVersion) ? globalThis.String(object.processorVersion) : "",
    };
  },

  toJSON(message: ProcessorVersionAlias): unknown {
    const obj: any = {};
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    if (message.processorVersion !== "") {
      obj.processorVersion = message.processorVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorVersionAlias>): ProcessorVersionAlias {
    return ProcessorVersionAlias.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorVersionAlias>): ProcessorVersionAlias {
    const message = createBaseProcessorVersionAlias();
    message.alias = object.alias ?? "";
    message.processorVersion = object.processorVersion ?? "";
    return message;
  },
};

function createBaseProcessor(): Processor {
  return {
    name: "",
    type: "",
    displayName: "",
    state: 0,
    defaultProcessorVersion: "",
    processorVersionAliases: [],
    processEndpoint: "",
    createTime: undefined,
    kmsKeyName: "",
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const Processor: MessageFns<Processor> = {
  encode(message: Processor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.defaultProcessorVersion !== "") {
      writer.uint32(74).string(message.defaultProcessorVersion);
    }
    for (const v of message.processorVersionAliases) {
      ProcessorVersionAlias.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.processEndpoint !== "") {
      writer.uint32(50).string(message.processEndpoint);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(66).string(message.kmsKeyName);
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(96).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(104).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.defaultProcessorVersion = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.processorVersionAliases.push(ProcessorVersionAlias.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.processEndpoint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? processor_StateFromJSON(object.state) : 0,
      defaultProcessorVersion: isSet(object.defaultProcessorVersion)
        ? globalThis.String(object.defaultProcessorVersion)
        : "",
      processorVersionAliases: globalThis.Array.isArray(object?.processorVersionAliases)
        ? object.processorVersionAliases.map((e: any) => ProcessorVersionAlias.fromJSON(e))
        : [],
      processEndpoint: isSet(object.processEndpoint) ? globalThis.String(object.processEndpoint) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: Processor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = processor_StateToJSON(message.state);
    }
    if (message.defaultProcessorVersion !== "") {
      obj.defaultProcessorVersion = message.defaultProcessorVersion;
    }
    if (message.processorVersionAliases?.length) {
      obj.processorVersionAliases = message.processorVersionAliases.map((e) => ProcessorVersionAlias.toJSON(e));
    }
    if (message.processEndpoint !== "") {
      obj.processEndpoint = message.processEndpoint;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<Processor>): Processor {
    return Processor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Processor>): Processor {
    const message = createBaseProcessor();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.defaultProcessorVersion = object.defaultProcessorVersion ?? "";
    message.processorVersionAliases =
      object.processorVersionAliases?.map((e) => ProcessorVersionAlias.fromPartial(e)) || [];
    message.processEndpoint = object.processEndpoint ?? "";
    message.createTime = object.createTime ?? undefined;
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
