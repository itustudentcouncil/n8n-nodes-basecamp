// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tpu/v1/cloud_tpu.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.tpu.v1";

/** Sets the scheduling options for this node. */
export interface SchedulingConfig {
  /** Defines whether the node is preemptible. */
  preemptible: boolean;
  /** Whether the node is created under a reservation. */
  reserved: boolean;
}

/** A network endpoint over which a TPU worker can be reached. */
export interface NetworkEndpoint {
  /** The IP address of this network endpoint. */
  ipAddress: string;
  /** The port of this network endpoint. */
  port: number;
}

/** A TPU instance. */
export interface Node {
  /** Output only. Immutable. The name of the TPU */
  name: string;
  /** The user-supplied description of the TPU. Maximum of 512 characters. */
  description: string;
  /** Required. The type of hardware accelerators associated with this node. */
  acceleratorType: string;
  /**
   * Output only. DEPRECATED! Use network_endpoints instead.
   * The network address for the TPU Node as visible to Compute Engine
   * instances.
   *
   * @deprecated
   */
  ipAddress: string;
  /**
   * Output only. DEPRECATED! Use network_endpoints instead.
   * The network port for the TPU Node as visible to Compute Engine instances.
   *
   * @deprecated
   */
  port: string;
  /** Output only. The current state for the TPU Node. */
  state: Node_State;
  /**
   * Output only. If this field is populated, it contains a description of why
   * the TPU Node is unhealthy.
   */
  healthDescription: string;
  /** Required. The version of Tensorflow running in the Node. */
  tensorflowVersion: string;
  /**
   * The name of a network they wish to peer the TPU node to. It must be a
   * preexisting Compute Engine network inside of the project on which this API
   * has been activated. If none is provided, "default" will be used.
   */
  network: string;
  /**
   * The CIDR block that the TPU node will use when selecting an IP address.
   * This CIDR block must be a /29 block; the Compute Engine networks API
   * forbids a smaller block, and using a larger block would be wasteful (a
   * node can only consume one IP address). Errors will occur if the CIDR block
   * has already been used for a currently existing TPU node, the CIDR block
   * conflicts with any subnetworks in the user's provided network, or the
   * provided network is peered with another network that is using that CIDR
   * block.
   */
  cidrBlock: string;
  /**
   * Output only. The service account used to run the tensor flow services
   * within the node. To share resources, including Google Cloud Storage data,
   * with the Tensorflow job running in the Node, this account must have
   * permissions to that data.
   */
  serviceAccount: string;
  /** Output only. The time when the node was created. */
  createTime:
    | Date
    | undefined;
  /** The scheduling options for this node. */
  schedulingConfig:
    | SchedulingConfig
    | undefined;
  /**
   * Output only. The network endpoints where TPU workers can be accessed and
   * sent work. It is recommended that Tensorflow clients of the node reach out
   * to the 0th entry in this map first.
   */
  networkEndpoints: NetworkEndpoint[];
  /** The health status of the TPU node. */
  health: Node_Health;
  /** Resource labels to represent user-provided metadata. */
  labels: { [key: string]: string };
  /**
   * Whether the VPC peering for the node is set up through Service Networking
   * API. The VPC Peering should be set up before provisioning the node.
   * If this field is set, cidr_block field should not be specified. If the
   * network, that you want to peer the TPU Node to, is Shared VPC networks,
   * the node must be created with this this field enabled.
   */
  useServiceNetworking: boolean;
  /** Output only. The API version that created this Node. */
  apiVersion: Node_ApiVersion;
  /** Output only. The Symptoms that have occurred to the TPU Node. */
  symptoms: Symptom[];
}

/** Represents the different states of a TPU node during its lifecycle. */
export enum Node_State {
  /** STATE_UNSPECIFIED - TPU node state is not known/set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - TPU node is being created. */
  CREATING = 1,
  /** READY - TPU node has been created. */
  READY = 2,
  /** RESTARTING - TPU node is restarting. */
  RESTARTING = 3,
  /** REIMAGING - TPU node is undergoing reimaging. */
  REIMAGING = 4,
  /** DELETING - TPU node is being deleted. */
  DELETING = 5,
  /**
   * REPAIRING - TPU node is being repaired and may be unusable. Details can be
   * found in the `help_description` field.
   */
  REPAIRING = 6,
  /** STOPPED - TPU node is stopped. */
  STOPPED = 8,
  /** STOPPING - TPU node is currently stopping. */
  STOPPING = 9,
  /** STARTING - TPU node is currently starting. */
  STARTING = 10,
  /** PREEMPTED - TPU node has been preempted. Only applies to Preemptible TPU Nodes. */
  PREEMPTED = 11,
  /**
   * TERMINATED - TPU node has been terminated due to maintenance or has reached the end of
   * its life cycle (for preemptible nodes).
   */
  TERMINATED = 12,
  /** HIDING - TPU node is currently hiding. */
  HIDING = 13,
  /** HIDDEN - TPU node has been hidden. */
  HIDDEN = 14,
  /** UNHIDING - TPU node is currently unhiding. */
  UNHIDING = 15,
  UNRECOGNIZED = -1,
}

export function node_StateFromJSON(object: any): Node_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Node_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Node_State.CREATING;
    case 2:
    case "READY":
      return Node_State.READY;
    case 3:
    case "RESTARTING":
      return Node_State.RESTARTING;
    case 4:
    case "REIMAGING":
      return Node_State.REIMAGING;
    case 5:
    case "DELETING":
      return Node_State.DELETING;
    case 6:
    case "REPAIRING":
      return Node_State.REPAIRING;
    case 8:
    case "STOPPED":
      return Node_State.STOPPED;
    case 9:
    case "STOPPING":
      return Node_State.STOPPING;
    case 10:
    case "STARTING":
      return Node_State.STARTING;
    case 11:
    case "PREEMPTED":
      return Node_State.PREEMPTED;
    case 12:
    case "TERMINATED":
      return Node_State.TERMINATED;
    case 13:
    case "HIDING":
      return Node_State.HIDING;
    case 14:
    case "HIDDEN":
      return Node_State.HIDDEN;
    case 15:
    case "UNHIDING":
      return Node_State.UNHIDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_State.UNRECOGNIZED;
  }
}

export function node_StateToJSON(object: Node_State): string {
  switch (object) {
    case Node_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Node_State.CREATING:
      return "CREATING";
    case Node_State.READY:
      return "READY";
    case Node_State.RESTARTING:
      return "RESTARTING";
    case Node_State.REIMAGING:
      return "REIMAGING";
    case Node_State.DELETING:
      return "DELETING";
    case Node_State.REPAIRING:
      return "REPAIRING";
    case Node_State.STOPPED:
      return "STOPPED";
    case Node_State.STOPPING:
      return "STOPPING";
    case Node_State.STARTING:
      return "STARTING";
    case Node_State.PREEMPTED:
      return "PREEMPTED";
    case Node_State.TERMINATED:
      return "TERMINATED";
    case Node_State.HIDING:
      return "HIDING";
    case Node_State.HIDDEN:
      return "HIDDEN";
    case Node_State.UNHIDING:
      return "UNHIDING";
    case Node_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Health defines the status of a TPU node as reported by
 * Health Monitor.
 */
export enum Node_Health {
  /** HEALTH_UNSPECIFIED - Health status is unknown: not initialized or failed to retrieve. */
  HEALTH_UNSPECIFIED = 0,
  /** HEALTHY - The resource is healthy. */
  HEALTHY = 1,
  /** DEPRECATED_UNHEALTHY - The resource is unhealthy. */
  DEPRECATED_UNHEALTHY = 2,
  /** TIMEOUT - The resource is unresponsive. */
  TIMEOUT = 3,
  /** UNHEALTHY_TENSORFLOW - The in-guest ML stack is unhealthy. */
  UNHEALTHY_TENSORFLOW = 4,
  /**
   * UNHEALTHY_MAINTENANCE - The node is under maintenance/priority boost caused rescheduling and
   * will resume running once rescheduled.
   */
  UNHEALTHY_MAINTENANCE = 5,
  UNRECOGNIZED = -1,
}

export function node_HealthFromJSON(object: any): Node_Health {
  switch (object) {
    case 0:
    case "HEALTH_UNSPECIFIED":
      return Node_Health.HEALTH_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return Node_Health.HEALTHY;
    case 2:
    case "DEPRECATED_UNHEALTHY":
      return Node_Health.DEPRECATED_UNHEALTHY;
    case 3:
    case "TIMEOUT":
      return Node_Health.TIMEOUT;
    case 4:
    case "UNHEALTHY_TENSORFLOW":
      return Node_Health.UNHEALTHY_TENSORFLOW;
    case 5:
    case "UNHEALTHY_MAINTENANCE":
      return Node_Health.UNHEALTHY_MAINTENANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_Health.UNRECOGNIZED;
  }
}

export function node_HealthToJSON(object: Node_Health): string {
  switch (object) {
    case Node_Health.HEALTH_UNSPECIFIED:
      return "HEALTH_UNSPECIFIED";
    case Node_Health.HEALTHY:
      return "HEALTHY";
    case Node_Health.DEPRECATED_UNHEALTHY:
      return "DEPRECATED_UNHEALTHY";
    case Node_Health.TIMEOUT:
      return "TIMEOUT";
    case Node_Health.UNHEALTHY_TENSORFLOW:
      return "UNHEALTHY_TENSORFLOW";
    case Node_Health.UNHEALTHY_MAINTENANCE:
      return "UNHEALTHY_MAINTENANCE";
    case Node_Health.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TPU API Version. */
export enum Node_ApiVersion {
  /** API_VERSION_UNSPECIFIED - API version is unknown. */
  API_VERSION_UNSPECIFIED = 0,
  /** V1_ALPHA1 - TPU API V1Alpha1 version. */
  V1_ALPHA1 = 1,
  /** V1 - TPU API V1 version. */
  V1 = 2,
  /** V2_ALPHA1 - TPU API V2Alpha1 version. */
  V2_ALPHA1 = 3,
  UNRECOGNIZED = -1,
}

export function node_ApiVersionFromJSON(object: any): Node_ApiVersion {
  switch (object) {
    case 0:
    case "API_VERSION_UNSPECIFIED":
      return Node_ApiVersion.API_VERSION_UNSPECIFIED;
    case 1:
    case "V1_ALPHA1":
      return Node_ApiVersion.V1_ALPHA1;
    case 2:
    case "V1":
      return Node_ApiVersion.V1;
    case 3:
    case "V2_ALPHA1":
      return Node_ApiVersion.V2_ALPHA1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_ApiVersion.UNRECOGNIZED;
  }
}

export function node_ApiVersionToJSON(object: Node_ApiVersion): string {
  switch (object) {
    case Node_ApiVersion.API_VERSION_UNSPECIFIED:
      return "API_VERSION_UNSPECIFIED";
    case Node_ApiVersion.V1_ALPHA1:
      return "V1_ALPHA1";
    case Node_ApiVersion.V1:
      return "V1";
    case Node_ApiVersion.V2_ALPHA1:
      return "V2_ALPHA1";
    case Node_ApiVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Node_LabelsEntry {
  key: string;
  value: string;
}

/** Request for [ListNodes][google.cloud.tpu.v1.Tpu.ListNodes]. */
export interface ListNodesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/** Response for [ListNodes][google.cloud.tpu.v1.Tpu.ListNodes]. */
export interface ListNodesResponse {
  /** The listed nodes. */
  nodes: Node[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for [GetNode][google.cloud.tpu.v1.Tpu.GetNode]. */
export interface GetNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [CreateNode][google.cloud.tpu.v1.Tpu.CreateNode]. */
export interface CreateNodeRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The unqualified resource name. */
  nodeId: string;
  /** Required. The node. */
  node: Node | undefined;
}

/** Request for [DeleteNode][google.cloud.tpu.v1.Tpu.DeleteNode]. */
export interface DeleteNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [ReimageNode][google.cloud.tpu.v1.Tpu.ReimageNode]. */
export interface ReimageNodeRequest {
  /** The resource name. */
  name: string;
  /** The version for reimage to create. */
  tensorflowVersion: string;
}

/** Request for [StopNode][google.cloud.tpu.v1.Tpu.StopNode]. */
export interface StopNodeRequest {
  /** The resource name. */
  name: string;
}

/** Request for [StartNode][google.cloud.tpu.v1.Tpu.StartNode]. */
export interface StartNodeRequest {
  /** The resource name. */
  name: string;
}

/** A tensorflow version that a Node can be configured with. */
export interface TensorFlowVersion {
  /** The resource name. */
  name: string;
  /** the tensorflow version. */
  version: string;
}

/**
 * Request for
 * [GetTensorFlowVersion][google.cloud.tpu.v1.Tpu.GetTensorFlowVersion].
 */
export interface GetTensorFlowVersionRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListTensorFlowVersions][google.cloud.tpu.v1.Tpu.ListTensorFlowVersions].
 */
export interface ListTensorFlowVersionsRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListTensorFlowVersions][google.cloud.tpu.v1.Tpu.ListTensorFlowVersions].
 */
export interface ListTensorFlowVersionsResponse {
  /** The listed nodes. */
  tensorflowVersions: TensorFlowVersion[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A accelerator type that a Node can be configured with. */
export interface AcceleratorType {
  /** The resource name. */
  name: string;
  /** the accelerator type. */
  type: string;
}

/** Request for [GetAcceleratorType][google.cloud.tpu.v1.Tpu.GetAcceleratorType]. */
export interface GetAcceleratorTypeRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListAcceleratorTypes][google.cloud.tpu.v1.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListAcceleratorTypes][google.cloud.tpu.v1.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesResponse {
  /** The listed nodes. */
  acceleratorTypes: AcceleratorType[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Metadata describing an [Operation][google.longrunning.Operation] */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /**
   * Target of the operation - for example
   * projects/project-1/connectivityTests/test-1
   */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
  /** Human-readable status of the operation, if any. */
  statusDetail: string;
  /** Specifies if cancellation was requested for the operation. */
  cancelRequested: boolean;
  /** API version. */
  apiVersion: string;
}

/** A Symptom instance. */
export interface Symptom {
  /** Timestamp when the Symptom is created. */
  createTime:
    | Date
    | undefined;
  /** Type of the Symptom. */
  symptomType: Symptom_SymptomType;
  /** Detailed information of the current Symptom. */
  details: string;
  /** A string used to uniquely distinguish a worker within a TPU node. */
  workerId: string;
}

/**
 * SymptomType represents the different types of Symptoms that a TPU can be
 * at.
 */
export enum Symptom_SymptomType {
  /** SYMPTOM_TYPE_UNSPECIFIED - Unspecified symptom. */
  SYMPTOM_TYPE_UNSPECIFIED = 0,
  /** LOW_MEMORY - TPU VM memory is low. */
  LOW_MEMORY = 1,
  /** OUT_OF_MEMORY - TPU runtime is out of memory. */
  OUT_OF_MEMORY = 2,
  /** EXECUTE_TIMED_OUT - TPU runtime execution has timed out. */
  EXECUTE_TIMED_OUT = 3,
  /**
   * MESH_BUILD_FAIL - TPU runtime fails to construct a mesh that recognizes each TPU device's
   * neighbors.
   */
  MESH_BUILD_FAIL = 4,
  /** HBM_OUT_OF_MEMORY - TPU HBM is out of memory. */
  HBM_OUT_OF_MEMORY = 5,
  /** PROJECT_ABUSE - Abusive behaviors have been identified on the current project. */
  PROJECT_ABUSE = 6,
  UNRECOGNIZED = -1,
}

export function symptom_SymptomTypeFromJSON(object: any): Symptom_SymptomType {
  switch (object) {
    case 0:
    case "SYMPTOM_TYPE_UNSPECIFIED":
      return Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED;
    case 1:
    case "LOW_MEMORY":
      return Symptom_SymptomType.LOW_MEMORY;
    case 2:
    case "OUT_OF_MEMORY":
      return Symptom_SymptomType.OUT_OF_MEMORY;
    case 3:
    case "EXECUTE_TIMED_OUT":
      return Symptom_SymptomType.EXECUTE_TIMED_OUT;
    case 4:
    case "MESH_BUILD_FAIL":
      return Symptom_SymptomType.MESH_BUILD_FAIL;
    case 5:
    case "HBM_OUT_OF_MEMORY":
      return Symptom_SymptomType.HBM_OUT_OF_MEMORY;
    case 6:
    case "PROJECT_ABUSE":
      return Symptom_SymptomType.PROJECT_ABUSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Symptom_SymptomType.UNRECOGNIZED;
  }
}

export function symptom_SymptomTypeToJSON(object: Symptom_SymptomType): string {
  switch (object) {
    case Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED:
      return "SYMPTOM_TYPE_UNSPECIFIED";
    case Symptom_SymptomType.LOW_MEMORY:
      return "LOW_MEMORY";
    case Symptom_SymptomType.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case Symptom_SymptomType.EXECUTE_TIMED_OUT:
      return "EXECUTE_TIMED_OUT";
    case Symptom_SymptomType.MESH_BUILD_FAIL:
      return "MESH_BUILD_FAIL";
    case Symptom_SymptomType.HBM_OUT_OF_MEMORY:
      return "HBM_OUT_OF_MEMORY";
    case Symptom_SymptomType.PROJECT_ABUSE:
      return "PROJECT_ABUSE";
    case Symptom_SymptomType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSchedulingConfig(): SchedulingConfig {
  return { preemptible: false, reserved: false };
}

export const SchedulingConfig: MessageFns<SchedulingConfig> = {
  encode(message: SchedulingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preemptible !== false) {
      writer.uint32(8).bool(message.preemptible);
    }
    if (message.reserved !== false) {
      writer.uint32(16).bool(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingConfig {
    return {
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : false,
      reserved: isSet(object.reserved) ? globalThis.Boolean(object.reserved) : false,
    };
  },

  toJSON(message: SchedulingConfig): unknown {
    const obj: any = {};
    if (message.preemptible !== false) {
      obj.preemptible = message.preemptible;
    }
    if (message.reserved !== false) {
      obj.reserved = message.reserved;
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulingConfig>): SchedulingConfig {
    return SchedulingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulingConfig>): SchedulingConfig {
    const message = createBaseSchedulingConfig();
    message.preemptible = object.preemptible ?? false;
    message.reserved = object.reserved ?? false;
    return message;
  },
};

function createBaseNetworkEndpoint(): NetworkEndpoint {
  return { ipAddress: "", port: 0 };
}

export const NetworkEndpoint: MessageFns<NetworkEndpoint> = {
  encode(message: NetworkEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkEndpoint {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: NetworkEndpoint): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    return NetworkEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    const message = createBaseNetworkEndpoint();
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseNode(): Node {
  return {
    name: "",
    description: "",
    acceleratorType: "",
    ipAddress: "",
    port: "",
    state: 0,
    healthDescription: "",
    tensorflowVersion: "",
    network: "",
    cidrBlock: "",
    serviceAccount: "",
    createTime: undefined,
    schedulingConfig: undefined,
    networkEndpoints: [],
    health: 0,
    labels: {},
    useServiceNetworking: false,
    apiVersion: 0,
    symptoms: [],
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.acceleratorType !== "") {
      writer.uint32(42).string(message.acceleratorType);
    }
    if (message.ipAddress !== "") {
      writer.uint32(66).string(message.ipAddress);
    }
    if (message.port !== "") {
      writer.uint32(114).string(message.port);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.healthDescription !== "") {
      writer.uint32(82).string(message.healthDescription);
    }
    if (message.tensorflowVersion !== "") {
      writer.uint32(90).string(message.tensorflowVersion);
    }
    if (message.network !== "") {
      writer.uint32(98).string(message.network);
    }
    if (message.cidrBlock !== "") {
      writer.uint32(106).string(message.cidrBlock);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(122).string(message.serviceAccount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(130).fork()).join();
    }
    if (message.schedulingConfig !== undefined) {
      SchedulingConfig.encode(message.schedulingConfig, writer.uint32(138).fork()).join();
    }
    for (const v of message.networkEndpoints) {
      NetworkEndpoint.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.health !== 0) {
      writer.uint32(176).int32(message.health);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Node_LabelsEntry.encode({ key: key as any, value }, writer.uint32(194).fork()).join();
    });
    if (message.useServiceNetworking !== false) {
      writer.uint32(216).bool(message.useServiceNetworking);
    }
    if (message.apiVersion !== 0) {
      writer.uint32(304).int32(message.apiVersion);
    }
    for (const v of message.symptoms) {
      Symptom.encode(v!, writer.uint32(314).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.port = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.healthDescription = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tensorflowVersion = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.network = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.schedulingConfig = SchedulingConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.networkEndpoints.push(NetworkEndpoint.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.health = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          const entry24 = Node_LabelsEntry.decode(reader, reader.uint32());
          if (entry24.value !== undefined) {
            message.labels[entry24.key] = entry24.value;
          }
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.useServiceNetworking = reader.bool();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.apiVersion = reader.int32() as any;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.symptoms.push(Symptom.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      state: isSet(object.state) ? node_StateFromJSON(object.state) : 0,
      healthDescription: isSet(object.healthDescription) ? globalThis.String(object.healthDescription) : "",
      tensorflowVersion: isSet(object.tensorflowVersion) ? globalThis.String(object.tensorflowVersion) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      schedulingConfig: isSet(object.schedulingConfig) ? SchedulingConfig.fromJSON(object.schedulingConfig) : undefined,
      networkEndpoints: globalThis.Array.isArray(object?.networkEndpoints)
        ? object.networkEndpoints.map((e: any) => NetworkEndpoint.fromJSON(e))
        : [],
      health: isSet(object.health) ? node_HealthFromJSON(object.health) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      useServiceNetworking: isSet(object.useServiceNetworking)
        ? globalThis.Boolean(object.useServiceNetworking)
        : false,
      apiVersion: isSet(object.apiVersion) ? node_ApiVersionFromJSON(object.apiVersion) : 0,
      symptoms: globalThis.Array.isArray(object?.symptoms) ? object.symptoms.map((e: any) => Symptom.fromJSON(e)) : [],
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceleratorType !== "") {
      obj.acceleratorType = message.acceleratorType;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.state !== 0) {
      obj.state = node_StateToJSON(message.state);
    }
    if (message.healthDescription !== "") {
      obj.healthDescription = message.healthDescription;
    }
    if (message.tensorflowVersion !== "") {
      obj.tensorflowVersion = message.tensorflowVersion;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.schedulingConfig !== undefined) {
      obj.schedulingConfig = SchedulingConfig.toJSON(message.schedulingConfig);
    }
    if (message.networkEndpoints?.length) {
      obj.networkEndpoints = message.networkEndpoints.map((e) => NetworkEndpoint.toJSON(e));
    }
    if (message.health !== 0) {
      obj.health = node_HealthToJSON(message.health);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.useServiceNetworking !== false) {
      obj.useServiceNetworking = message.useServiceNetworking;
    }
    if (message.apiVersion !== 0) {
      obj.apiVersion = node_ApiVersionToJSON(message.apiVersion);
    }
    if (message.symptoms?.length) {
      obj.symptoms = message.symptoms.map((e) => Symptom.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.acceleratorType = object.acceleratorType ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? "";
    message.state = object.state ?? 0;
    message.healthDescription = object.healthDescription ?? "";
    message.tensorflowVersion = object.tensorflowVersion ?? "";
    message.network = object.network ?? "";
    message.cidrBlock = object.cidrBlock ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.createTime = object.createTime ?? undefined;
    message.schedulingConfig = (object.schedulingConfig !== undefined && object.schedulingConfig !== null)
      ? SchedulingConfig.fromPartial(object.schedulingConfig)
      : undefined;
    message.networkEndpoints = object.networkEndpoints?.map((e) => NetworkEndpoint.fromPartial(e)) || [];
    message.health = object.health ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.useServiceNetworking = object.useServiceNetworking ?? false;
    message.apiVersion = object.apiVersion ?? 0;
    message.symptoms = object.symptoms?.map((e) => Symptom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNode_LabelsEntry(): Node_LabelsEntry {
  return { key: "", value: "" };
}

export const Node_LabelsEntry: MessageFns<Node_LabelsEntry> = {
  encode(message: Node_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Node_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    return Node_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    const message = createBaseNode_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListNodesRequest(): ListNodesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListNodesRequest: MessageFns<ListNodesRequest> = {
  encode(message: ListNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNodesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesRequest>): ListNodesRequest {
    return ListNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesRequest>): ListNodesRequest {
    const message = createBaseListNodesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNodesResponse(): ListNodesResponse {
  return { nodes: [], nextPageToken: "", unreachable: [] };
}

export const ListNodesResponse: MessageFns<ListNodesResponse> = {
  encode(message: ListNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesResponse>): ListNodesResponse {
    return ListNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesResponse>): ListNodesResponse {
    const message = createBaseListNodesResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { name: "" };
}

export const GetNodeRequest: MessageFns<GetNodeRequest> = {
  encode(message: GetNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodeRequest>): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodeRequest>): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNodeRequest(): CreateNodeRequest {
  return { parent: "", nodeId: "", node: undefined };
}

export const CreateNodeRequest: MessageFns<CreateNodeRequest> = {
  encode(message: CreateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: CreateNodeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    return CreateNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    const message = createBaseCreateNodeRequest();
    message.parent = object.parent ?? "";
    message.nodeId = object.nodeId ?? "";
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseDeleteNodeRequest(): DeleteNodeRequest {
  return { name: "" };
}

export const DeleteNodeRequest: MessageFns<DeleteNodeRequest> = {
  encode(message: DeleteNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    return DeleteNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    const message = createBaseDeleteNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseReimageNodeRequest(): ReimageNodeRequest {
  return { name: "", tensorflowVersion: "" };
}

export const ReimageNodeRequest: MessageFns<ReimageNodeRequest> = {
  encode(message: ReimageNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tensorflowVersion !== "") {
      writer.uint32(18).string(message.tensorflowVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReimageNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReimageNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tensorflowVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReimageNodeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tensorflowVersion: isSet(object.tensorflowVersion) ? globalThis.String(object.tensorflowVersion) : "",
    };
  },

  toJSON(message: ReimageNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tensorflowVersion !== "") {
      obj.tensorflowVersion = message.tensorflowVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ReimageNodeRequest>): ReimageNodeRequest {
    return ReimageNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReimageNodeRequest>): ReimageNodeRequest {
    const message = createBaseReimageNodeRequest();
    message.name = object.name ?? "";
    message.tensorflowVersion = object.tensorflowVersion ?? "";
    return message;
  },
};

function createBaseStopNodeRequest(): StopNodeRequest {
  return { name: "" };
}

export const StopNodeRequest: MessageFns<StopNodeRequest> = {
  encode(message: StopNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StopNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StopNodeRequest>): StopNodeRequest {
    return StopNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopNodeRequest>): StopNodeRequest {
    const message = createBaseStopNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartNodeRequest(): StartNodeRequest {
  return { name: "" };
}

export const StartNodeRequest: MessageFns<StartNodeRequest> = {
  encode(message: StartNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StartNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StartNodeRequest>): StartNodeRequest {
    return StartNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartNodeRequest>): StartNodeRequest {
    const message = createBaseStartNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTensorFlowVersion(): TensorFlowVersion {
  return { name: "", version: "" };
}

export const TensorFlowVersion: MessageFns<TensorFlowVersion> = {
  encode(message: TensorFlowVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TensorFlowVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTensorFlowVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TensorFlowVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: TensorFlowVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<TensorFlowVersion>): TensorFlowVersion {
    return TensorFlowVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TensorFlowVersion>): TensorFlowVersion {
    const message = createBaseTensorFlowVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetTensorFlowVersionRequest(): GetTensorFlowVersionRequest {
  return { name: "" };
}

export const GetTensorFlowVersionRequest: MessageFns<GetTensorFlowVersionRequest> = {
  encode(message: GetTensorFlowVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTensorFlowVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTensorFlowVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTensorFlowVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTensorFlowVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTensorFlowVersionRequest>): GetTensorFlowVersionRequest {
    return GetTensorFlowVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTensorFlowVersionRequest>): GetTensorFlowVersionRequest {
    const message = createBaseGetTensorFlowVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTensorFlowVersionsRequest(): ListTensorFlowVersionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListTensorFlowVersionsRequest: MessageFns<ListTensorFlowVersionsRequest> = {
  encode(message: ListTensorFlowVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTensorFlowVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTensorFlowVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTensorFlowVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListTensorFlowVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTensorFlowVersionsRequest>): ListTensorFlowVersionsRequest {
    return ListTensorFlowVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTensorFlowVersionsRequest>): ListTensorFlowVersionsRequest {
    const message = createBaseListTensorFlowVersionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListTensorFlowVersionsResponse(): ListTensorFlowVersionsResponse {
  return { tensorflowVersions: [], nextPageToken: "", unreachable: [] };
}

export const ListTensorFlowVersionsResponse: MessageFns<ListTensorFlowVersionsResponse> = {
  encode(message: ListTensorFlowVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tensorflowVersions) {
      TensorFlowVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTensorFlowVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTensorFlowVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tensorflowVersions.push(TensorFlowVersion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTensorFlowVersionsResponse {
    return {
      tensorflowVersions: globalThis.Array.isArray(object?.tensorflowVersions)
        ? object.tensorflowVersions.map((e: any) => TensorFlowVersion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListTensorFlowVersionsResponse): unknown {
    const obj: any = {};
    if (message.tensorflowVersions?.length) {
      obj.tensorflowVersions = message.tensorflowVersions.map((e) => TensorFlowVersion.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTensorFlowVersionsResponse>): ListTensorFlowVersionsResponse {
    return ListTensorFlowVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTensorFlowVersionsResponse>): ListTensorFlowVersionsResponse {
    const message = createBaseListTensorFlowVersionsResponse();
    message.tensorflowVersions = object.tensorflowVersions?.map((e) => TensorFlowVersion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseAcceleratorType(): AcceleratorType {
  return { name: "", type: "" };
}

export const AcceleratorType: MessageFns<AcceleratorType> = {
  encode(message: AcceleratorType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: AcceleratorType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorType>): AcceleratorType {
    return AcceleratorType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorType>): AcceleratorType {
    const message = createBaseAcceleratorType();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseGetAcceleratorTypeRequest(): GetAcceleratorTypeRequest {
  return { name: "" };
}

export const GetAcceleratorTypeRequest: MessageFns<GetAcceleratorTypeRequest> = {
  encode(message: GetAcceleratorTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAcceleratorTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAcceleratorTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAcceleratorTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAcceleratorTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    return GetAcceleratorTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    const message = createBaseGetAcceleratorTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesRequest(): ListAcceleratorTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAcceleratorTypesRequest: MessageFns<ListAcceleratorTypesRequest> = {
  encode(message: ListAcceleratorTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAcceleratorTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    return ListAcceleratorTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    const message = createBaseListAcceleratorTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesResponse(): ListAcceleratorTypesResponse {
  return { acceleratorTypes: [], nextPageToken: "", unreachable: [] };
}

export const ListAcceleratorTypesResponse: MessageFns<ListAcceleratorTypesResponse> = {
  encode(message: ListAcceleratorTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acceleratorTypes) {
      AcceleratorType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceleratorTypes.push(AcceleratorType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesResponse {
    return {
      acceleratorTypes: globalThis.Array.isArray(object?.acceleratorTypes)
        ? object.acceleratorTypes.map((e: any) => AcceleratorType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAcceleratorTypesResponse): unknown {
    const obj: any = {};
    if (message.acceleratorTypes?.length) {
      obj.acceleratorTypes = message.acceleratorTypes.map((e) => AcceleratorType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    return ListAcceleratorTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    const message = createBaseListAcceleratorTypesResponse();
    message.acceleratorTypes = object.acceleratorTypes?.map((e) => AcceleratorType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusDetail: "",
    cancelRequested: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusDetail !== "") {
      writer.uint32(42).string(message.statusDetail);
    }
    if (message.cancelRequested !== false) {
      writer.uint32(48).bool(message.cancelRequested);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusDetail = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cancelRequested = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusDetail: isSet(object.statusDetail) ? globalThis.String(object.statusDetail) : "",
      cancelRequested: isSet(object.cancelRequested) ? globalThis.Boolean(object.cancelRequested) : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusDetail !== "") {
      obj.statusDetail = message.statusDetail;
    }
    if (message.cancelRequested !== false) {
      obj.cancelRequested = message.cancelRequested;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusDetail = object.statusDetail ?? "";
    message.cancelRequested = object.cancelRequested ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseSymptom(): Symptom {
  return { createTime: undefined, symptomType: 0, details: "", workerId: "" };
}

export const Symptom: MessageFns<Symptom> = {
  encode(message: Symptom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.symptomType !== 0) {
      writer.uint32(16).int32(message.symptomType);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.workerId !== "") {
      writer.uint32(34).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Symptom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSymptom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.symptomType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Symptom {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      symptomType: isSet(object.symptomType) ? symptom_SymptomTypeFromJSON(object.symptomType) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
    };
  },

  toJSON(message: Symptom): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.symptomType !== 0) {
      obj.symptomType = symptom_SymptomTypeToJSON(message.symptomType);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<Symptom>): Symptom {
    return Symptom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Symptom>): Symptom {
    const message = createBaseSymptom();
    message.createTime = object.createTime ?? undefined;
    message.symptomType = object.symptomType ?? 0;
    message.details = object.details ?? "";
    message.workerId = object.workerId ?? "";
    return message;
  },
};

/**
 * Manages TPU nodes and other resources
 *
 * TPU API v1
 */
export type TpuDefinition = typeof TpuDefinition;
export const TpuDefinition = {
  name: "Tpu",
  fullName: "google.cloud.tpu.v1.Tpu",
  methods: {
    /** Lists nodes. */
    listNodes: {
      name: "ListNodes",
      requestType: ListNodesRequest,
      requestStream: false,
      responseType: ListNodesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a node. */
    getNode: {
      name: "GetNode",
      requestType: GetNodeRequest,
      requestStream: false,
      responseType: Node,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a node. */
    createNode: {
      name: "CreateNode",
      requestType: CreateNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              111,
              100,
              101,
              44,
              110,
              111,
              100,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              49,
              58,
              4,
              110,
              111,
              100,
              101,
              34,
              41,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a node. */
    deleteNode: {
      name: "DeleteNode",
      requestType: DeleteNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              42,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Reimages a node's OS. */
    reimageNode: {
      name: "ReimageNode",
      requestType: ReimageNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              105,
              109,
              97,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /** Stops a node, this operation is only available with single TPU nodes. */
    stopNode: {
      name: "StopNode",
      requestType: StopNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
            ]),
          ],
        },
      },
    },
    /** Starts a node. */
    startNode: {
      name: "StartNode",
      requestType: StartNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** List TensorFlow versions supported by this API. */
    listTensorFlowVersions: {
      name: "ListTensorFlowVersions",
      requestType: ListTensorFlowVersionsRequest,
      requestStream: false,
      responseType: ListTensorFlowVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              110,
              115,
              111,
              114,
              102,
              108,
              111,
              119,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets TensorFlow Version. */
    getTensorFlowVersion: {
      name: "GetTensorFlowVersion",
      requestType: GetTensorFlowVersionRequest,
      requestStream: false,
      responseType: TensorFlowVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              115,
              111,
              114,
              102,
              108,
              111,
              119,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists accelerator types supported by this API. */
    listAcceleratorTypes: {
      name: "ListAcceleratorTypes",
      requestType: ListAcceleratorTypesRequest,
      requestStream: false,
      responseType: ListAcceleratorTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets AcceleratorType. */
    getAcceleratorType: {
      name: "GetAcceleratorType",
      requestType: GetAcceleratorTypeRequest,
      requestStream: false,
      responseType: AcceleratorType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TpuServiceImplementation<CallContextExt = {}> {
  /** Lists nodes. */
  listNodes(request: ListNodesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListNodesResponse>>;
  /** Gets the details of a node. */
  getNode(request: GetNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Node>>;
  /** Creates a node. */
  createNode(request: CreateNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a node. */
  deleteNode(request: DeleteNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Reimages a node's OS. */
  reimageNode(request: ReimageNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Stops a node, this operation is only available with single TPU nodes. */
  stopNode(request: StopNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Starts a node. */
  startNode(request: StartNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** List TensorFlow versions supported by this API. */
  listTensorFlowVersions(
    request: ListTensorFlowVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTensorFlowVersionsResponse>>;
  /** Gets TensorFlow Version. */
  getTensorFlowVersion(
    request: GetTensorFlowVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TensorFlowVersion>>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: ListAcceleratorTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAcceleratorTypesResponse>>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: GetAcceleratorTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AcceleratorType>>;
}

export interface TpuClient<CallOptionsExt = {}> {
  /** Lists nodes. */
  listNodes(request: DeepPartial<ListNodesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListNodesResponse>;
  /** Gets the details of a node. */
  getNode(request: DeepPartial<GetNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Node>;
  /** Creates a node. */
  createNode(request: DeepPartial<CreateNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a node. */
  deleteNode(request: DeepPartial<DeleteNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Reimages a node's OS. */
  reimageNode(request: DeepPartial<ReimageNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Stops a node, this operation is only available with single TPU nodes. */
  stopNode(request: DeepPartial<StopNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Starts a node. */
  startNode(request: DeepPartial<StartNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** List TensorFlow versions supported by this API. */
  listTensorFlowVersions(
    request: DeepPartial<ListTensorFlowVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTensorFlowVersionsResponse>;
  /** Gets TensorFlow Version. */
  getTensorFlowVersion(
    request: DeepPartial<GetTensorFlowVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TensorFlowVersion>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: DeepPartial<ListAcceleratorTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAcceleratorTypesResponse>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: DeepPartial<GetAcceleratorTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AcceleratorType>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
