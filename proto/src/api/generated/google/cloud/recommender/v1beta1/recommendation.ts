// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recommender/v1beta1/recommendation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Struct, Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.cloud.recommender.v1beta1";

/**
 * A recommendation along with a suggested action. E.g., a rightsizing
 * recommendation for an underutilized VM, IAM role recommendations, etc
 */
export interface Recommendation {
  /** Name of recommendation. */
  name: string;
  /**
   * Free-form human readable summary in English. The maximum length is 500
   * characters.
   */
  description: string;
  /**
   * Contains an identifier for a subtype of recommendations produced for the
   * same recommender. Subtype is a function of content and impact, meaning a
   * new subtype might be added when significant changes to `content` or
   * `primary_impact.category` are introduced. See the Recommenders section
   * to see a list of subtypes for a given Recommender.
   *
   * Examples:
   *   For recommender = "google.iam.policy.Recommender",
   *   recommender_subtype can be one of "REMOVE_ROLE"/"REPLACE_ROLE"
   */
  recommenderSubtype: string;
  /**
   * Last time this recommendation was refreshed by the system that created it
   * in the first place.
   */
  lastRefreshTime:
    | Date
    | undefined;
  /**
   * The primary impact that this recommendation can have while trying to
   * optimize for one category.
   */
  primaryImpact:
    | Impact
    | undefined;
  /**
   * Optional set of additional impact that this recommendation may have when
   * trying to optimize for the primary category. These may be positive
   * or negative.
   */
  additionalImpact: Impact[];
  /** Recommendation's priority. */
  priority: Recommendation_Priority;
  /** Content of the recommendation describing recommended changes to resources. */
  content:
    | RecommendationContent
    | undefined;
  /** Information for state. Contains state and metadata. */
  stateInfo:
    | RecommendationStateInfo
    | undefined;
  /**
   * Fingerprint of the Recommendation. Provides optimistic locking when
   * updating states.
   */
  etag: string;
  /** Insights that led to this recommendation. */
  associatedInsights: Recommendation_InsightReference[];
  /**
   * Corresponds to a mutually exclusive group ID within a recommender.
   * A non-empty ID indicates that the recommendation belongs to a mutually
   * exclusive group. This means that only one recommendation within the group
   * is suggested to be applied.
   */
  xorGroupId: string;
}

/** Recommendation priority levels. */
export enum Recommendation_Priority {
  /** PRIORITY_UNSPECIFIED - Recommendation has unspecified priority. */
  PRIORITY_UNSPECIFIED = 0,
  /** P4 - Recommendation has P4 priority (lowest priority). */
  P4 = 1,
  /** P3 - Recommendation has P3 priority (second lowest priority). */
  P3 = 2,
  /** P2 - Recommendation has P2 priority (second highest priority). */
  P2 = 3,
  /** P1 - Recommendation has P1 priority (highest priority). */
  P1 = 4,
  UNRECOGNIZED = -1,
}

export function recommendation_PriorityFromJSON(object: any): Recommendation_Priority {
  switch (object) {
    case 0:
    case "PRIORITY_UNSPECIFIED":
      return Recommendation_Priority.PRIORITY_UNSPECIFIED;
    case 1:
    case "P4":
      return Recommendation_Priority.P4;
    case 2:
    case "P3":
      return Recommendation_Priority.P3;
    case 3:
    case "P2":
      return Recommendation_Priority.P2;
    case 4:
    case "P1":
      return Recommendation_Priority.P1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Recommendation_Priority.UNRECOGNIZED;
  }
}

export function recommendation_PriorityToJSON(object: Recommendation_Priority): string {
  switch (object) {
    case Recommendation_Priority.PRIORITY_UNSPECIFIED:
      return "PRIORITY_UNSPECIFIED";
    case Recommendation_Priority.P4:
      return "P4";
    case Recommendation_Priority.P3:
      return "P3";
    case Recommendation_Priority.P2:
      return "P2";
    case Recommendation_Priority.P1:
      return "P1";
    case Recommendation_Priority.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reference to an associated insight. */
export interface Recommendation_InsightReference {
  /**
   * Insight resource name, e.g.
   * projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/insights/[INSIGHT_ID]
   */
  insight: string;
}

/** Contains what resources are changing and how they are changing. */
export interface RecommendationContent {
  /**
   * Operations to one or more Google Cloud resources grouped in such a way
   * that, all operations within one group are expected to be performed
   * atomically and in an order.
   */
  operationGroups: OperationGroup[];
  /** Condensed overview information about the recommendation. */
  overview: { [key: string]: any } | undefined;
}

/** Group of operations that need to be performed atomically. */
export interface OperationGroup {
  /**
   * List of operations across one or more resources that belong to this group.
   * Loosely based on RFC6902 and should be performed in the order they appear.
   */
  operations: Operation[];
}

/**
 * Contains an operation for a resource loosely based on the JSON-PATCH format
 * with support for:
 *
 * * Custom filters for describing partial array patch.
 * * Extended path values for describing nested arrays.
 * * Custom fields for describing the resource for which the operation is being
 *   described.
 * * Allows extension to custom operations not natively supported by RFC6902.
 * See https://tools.ietf.org/html/rfc6902 for details on the original RFC.
 */
export interface Operation {
  /**
   * Type of this operation. Contains one of 'add', 'remove', 'replace', 'move',
   * 'copy', 'test' and 'custom' operations. This field is case-insensitive and
   * always populated.
   */
  action: string;
  /**
   * Type of GCP resource being modified/tested. This field is always populated.
   * Example: cloudresourcemanager.googleapis.com/Project,
   * compute.googleapis.com/Instance
   */
  resourceType: string;
  /**
   * Contains the fully qualified resource name. This field is always populated.
   * ex: //cloudresourcemanager.googleapis.com/projects/foo.
   */
  resource: string;
  /**
   * Path to the target field being operated on. If the operation is at the
   * resource level, then path should be "/". This field is always populated.
   */
  path: string;
  /**
   * Can be set with action 'copy' to copy resource configuration across
   * different resources of the same type. Example: A resource clone can be
   * done via action = 'copy', path = "/", from = "/",
   * source_resource = <source> and resource_name = <target>.
   * This field is empty for all other values of `action`.
   */
  sourceResource: string;
  /**
   * Can be set with action 'copy' or 'move' to indicate the source field within
   * resource or source_resource, ignored if provided for other operation types.
   */
  sourcePath: string;
  /**
   * Value for the `path` field. Will be set for actions:'add'/'replace'.
   * Maybe set for action: 'test'. Either this or `value_matcher` will be set
   * for 'test' operation. An exact match must be performed.
   */
  value?:
    | any
    | undefined;
  /**
   * Can be set for action 'test' for advanced matching for the value of
   * 'path' field. Either this or `value` will be set for 'test' operation.
   */
  valueMatcher?:
    | ValueMatcher
    | undefined;
  /**
   * Set of filters to apply if `path` refers to array elements or nested array
   * elements in order to narrow down to a single unique element that is being
   * tested/modified.
   * This is intended to be an exact match per filter. To perform advanced
   * matching, use path_value_matchers.
   *
   * * Example:
   * ```
   * {
   *   "/versions/* /name" : "it-123"
   *   "/versions/* /targetSize/percent": 20
   * }
   * ```
   * * Example:
   * ```
   * {
   *   "/bindings/* /role": "roles/owner"
   *   "/bindings/* /condition" : null
   * }
   * ```
   * * Example:
   * ```
   * {
   *   "/bindings/* /role": "roles/owner"
   *   "/bindings/* /members/*" : ["x@example.com", "y@example.com"]
   * }
   * ```
   * When both path_filters and path_value_matchers are set, an implicit AND
   * must be performed.
   */
  pathFilters: { [key: string]: any | undefined };
  /**
   * Similar to path_filters, this contains set of filters to apply if `path`
   * field refers to array elements. This is meant to support value matching
   * beyond exact match. To perform exact match, use path_filters.
   * When both path_filters and path_value_matchers are set, an implicit AND
   * must be performed.
   */
  pathValueMatchers: { [key: string]: ValueMatcher };
}

export interface Operation_PathFiltersEntry {
  key: string;
  value: any | undefined;
}

export interface Operation_PathValueMatchersEntry {
  key: string;
  value: ValueMatcher | undefined;
}

/** Contains various matching options for values for a GCP resource field. */
export interface ValueMatcher {
  /**
   * To be used for full regex matching. The regular expression is using the
   * Google RE2 syntax (https://github.com/google/re2/wiki/Syntax), so to be
   * used with RE2::FullMatch
   */
  matchesPattern?: string | undefined;
}

/** Contains metadata about how much money a recommendation can save or incur. */
export interface CostProjection {
  /**
   * An approximate projection on amount saved or amount incurred. Negative cost
   * units indicate cost savings and positive cost units indicate increase.
   * See google.type.Money documentation for positive/negative units.
   *
   * A user's permissions may affect whether the cost is computed using list
   * prices or custom contract prices.
   */
  cost:
    | Money
    | undefined;
  /** Duration for which this cost applies. */
  duration: Duration | undefined;
}

/** Contains various ways of describing the impact on Security. */
export interface SecurityProjection {
  /**
   * This field can be used by the recommender to define details specific to
   * security impact.
   */
  details: { [key: string]: any } | undefined;
}

/**
 * Contains metadata about how much sustainability a recommendation can save or
 * incur.
 */
export interface SustainabilityProjection {
  /**
   * Carbon Footprint generated in kg of CO2 equivalent.
   * Chose kg_c_o2e so that the name renders correctly in camelCase (kgCO2e).
   */
  kgCO2e: number;
  /** Duration for which this sustanability applies. */
  duration: Duration | undefined;
}

/** Contains the impact a recommendation can have for a given category. */
export interface Impact {
  /** Category that is being targeted. */
  category: Impact_Category;
  /** Use with CategoryType.COST */
  costProjection?:
    | CostProjection
    | undefined;
  /** Use with CategoryType.SECURITY */
  securityProjection?:
    | SecurityProjection
    | undefined;
  /** Use with CategoryType.SUSTAINABILITY */
  sustainabilityProjection?: SustainabilityProjection | undefined;
}

/** The category of the impact. */
export enum Impact_Category {
  /** CATEGORY_UNSPECIFIED - Default unspecified category. Don't use directly. */
  CATEGORY_UNSPECIFIED = 0,
  /** COST - Indicates a potential increase or decrease in cost. */
  COST = 1,
  /** SECURITY - Indicates a potential increase or decrease in security. */
  SECURITY = 2,
  /** PERFORMANCE - Indicates a potential increase or decrease in performance. */
  PERFORMANCE = 3,
  /** MANAGEABILITY - Indicates a potential increase or decrease in manageability. */
  MANAGEABILITY = 4,
  /** SUSTAINABILITY - Indicates a potential increase or decrease in sustainability. */
  SUSTAINABILITY = 5,
  UNRECOGNIZED = -1,
}

export function impact_CategoryFromJSON(object: any): Impact_Category {
  switch (object) {
    case 0:
    case "CATEGORY_UNSPECIFIED":
      return Impact_Category.CATEGORY_UNSPECIFIED;
    case 1:
    case "COST":
      return Impact_Category.COST;
    case 2:
    case "SECURITY":
      return Impact_Category.SECURITY;
    case 3:
    case "PERFORMANCE":
      return Impact_Category.PERFORMANCE;
    case 4:
    case "MANAGEABILITY":
      return Impact_Category.MANAGEABILITY;
    case 5:
    case "SUSTAINABILITY":
      return Impact_Category.SUSTAINABILITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Impact_Category.UNRECOGNIZED;
  }
}

export function impact_CategoryToJSON(object: Impact_Category): string {
  switch (object) {
    case Impact_Category.CATEGORY_UNSPECIFIED:
      return "CATEGORY_UNSPECIFIED";
    case Impact_Category.COST:
      return "COST";
    case Impact_Category.SECURITY:
      return "SECURITY";
    case Impact_Category.PERFORMANCE:
      return "PERFORMANCE";
    case Impact_Category.MANAGEABILITY:
      return "MANAGEABILITY";
    case Impact_Category.SUSTAINABILITY:
      return "SUSTAINABILITY";
    case Impact_Category.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information for state. Contains state and metadata. */
export interface RecommendationStateInfo {
  /** The state of the recommendation, Eg ACTIVE, SUCCEEDED, FAILED. */
  state: RecommendationStateInfo_State;
  /** A map of metadata for the state, provided by user or automations systems. */
  stateMetadata: { [key: string]: string };
}

/** Represents Recommendation State. */
export enum RecommendationStateInfo_State {
  /** STATE_UNSPECIFIED - Default state. Don't use directly. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Recommendation is active and can be applied. Recommendations content can
   * be updated by Google.
   *
   * ACTIVE recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
   */
  ACTIVE = 1,
  /**
   * CLAIMED - Recommendation is in claimed state. Recommendations content is
   * immutable and cannot be updated by Google.
   *
   * CLAIMED recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
   */
  CLAIMED = 6,
  /**
   * SUCCEEDED - Recommendation is in succeeded state. Recommendations content is
   * immutable and cannot be updated by Google.
   *
   * SUCCEEDED recommendations can be marked as SUCCEEDED, or FAILED.
   */
  SUCCEEDED = 3,
  /**
   * FAILED - Recommendation is in failed state. Recommendations content is immutable
   * and cannot be updated by Google.
   *
   * FAILED recommendations can be marked as SUCCEEDED, or FAILED.
   */
  FAILED = 4,
  /**
   * DISMISSED - Recommendation is in dismissed state. Recommendation content can be
   * updated by Google.
   *
   * DISMISSED recommendations can be marked as ACTIVE.
   */
  DISMISSED = 5,
  UNRECOGNIZED = -1,
}

export function recommendationStateInfo_StateFromJSON(object: any): RecommendationStateInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return RecommendationStateInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return RecommendationStateInfo_State.ACTIVE;
    case 6:
    case "CLAIMED":
      return RecommendationStateInfo_State.CLAIMED;
    case 3:
    case "SUCCEEDED":
      return RecommendationStateInfo_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return RecommendationStateInfo_State.FAILED;
    case 5:
    case "DISMISSED":
      return RecommendationStateInfo_State.DISMISSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecommendationStateInfo_State.UNRECOGNIZED;
  }
}

export function recommendationStateInfo_StateToJSON(object: RecommendationStateInfo_State): string {
  switch (object) {
    case RecommendationStateInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case RecommendationStateInfo_State.ACTIVE:
      return "ACTIVE";
    case RecommendationStateInfo_State.CLAIMED:
      return "CLAIMED";
    case RecommendationStateInfo_State.SUCCEEDED:
      return "SUCCEEDED";
    case RecommendationStateInfo_State.FAILED:
      return "FAILED";
    case RecommendationStateInfo_State.DISMISSED:
      return "DISMISSED";
    case RecommendationStateInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RecommendationStateInfo_StateMetadataEntry {
  key: string;
  value: string;
}

/** The type of a recommender. */
export interface RecommenderType {
  /**
   * The recommender's name in format RecommenderTypes/{recommender_type}
   * eg:  recommenderTypes/google.iam.policy.Recommender
   */
  name: string;
}

function createBaseRecommendation(): Recommendation {
  return {
    name: "",
    description: "",
    recommenderSubtype: "",
    lastRefreshTime: undefined,
    primaryImpact: undefined,
    additionalImpact: [],
    priority: 0,
    content: undefined,
    stateInfo: undefined,
    etag: "",
    associatedInsights: [],
    xorGroupId: "",
  };
}

export const Recommendation: MessageFns<Recommendation> = {
  encode(message: Recommendation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.recommenderSubtype !== "") {
      writer.uint32(98).string(message.recommenderSubtype);
    }
    if (message.lastRefreshTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRefreshTime), writer.uint32(34).fork()).join();
    }
    if (message.primaryImpact !== undefined) {
      Impact.encode(message.primaryImpact, writer.uint32(42).fork()).join();
    }
    for (const v of message.additionalImpact) {
      Impact.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.priority !== 0) {
      writer.uint32(136).int32(message.priority);
    }
    if (message.content !== undefined) {
      RecommendationContent.encode(message.content, writer.uint32(58).fork()).join();
    }
    if (message.stateInfo !== undefined) {
      RecommendationStateInfo.encode(message.stateInfo, writer.uint32(82).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(90).string(message.etag);
    }
    for (const v of message.associatedInsights) {
      Recommendation_InsightReference.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.xorGroupId !== "") {
      writer.uint32(146).string(message.xorGroupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recommendation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recommenderSubtype = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastRefreshTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.primaryImpact = Impact.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.additionalImpact.push(Impact.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.content = RecommendationContent.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.stateInfo = RecommendationStateInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.associatedInsights.push(Recommendation_InsightReference.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.xorGroupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recommendation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      recommenderSubtype: isSet(object.recommenderSubtype) ? globalThis.String(object.recommenderSubtype) : "",
      lastRefreshTime: isSet(object.lastRefreshTime) ? fromJsonTimestamp(object.lastRefreshTime) : undefined,
      primaryImpact: isSet(object.primaryImpact) ? Impact.fromJSON(object.primaryImpact) : undefined,
      additionalImpact: globalThis.Array.isArray(object?.additionalImpact)
        ? object.additionalImpact.map((e: any) => Impact.fromJSON(e))
        : [],
      priority: isSet(object.priority) ? recommendation_PriorityFromJSON(object.priority) : 0,
      content: isSet(object.content) ? RecommendationContent.fromJSON(object.content) : undefined,
      stateInfo: isSet(object.stateInfo) ? RecommendationStateInfo.fromJSON(object.stateInfo) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      associatedInsights: globalThis.Array.isArray(object?.associatedInsights)
        ? object.associatedInsights.map((e: any) => Recommendation_InsightReference.fromJSON(e))
        : [],
      xorGroupId: isSet(object.xorGroupId) ? globalThis.String(object.xorGroupId) : "",
    };
  },

  toJSON(message: Recommendation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.recommenderSubtype !== "") {
      obj.recommenderSubtype = message.recommenderSubtype;
    }
    if (message.lastRefreshTime !== undefined) {
      obj.lastRefreshTime = message.lastRefreshTime.toISOString();
    }
    if (message.primaryImpact !== undefined) {
      obj.primaryImpact = Impact.toJSON(message.primaryImpact);
    }
    if (message.additionalImpact?.length) {
      obj.additionalImpact = message.additionalImpact.map((e) => Impact.toJSON(e));
    }
    if (message.priority !== 0) {
      obj.priority = recommendation_PriorityToJSON(message.priority);
    }
    if (message.content !== undefined) {
      obj.content = RecommendationContent.toJSON(message.content);
    }
    if (message.stateInfo !== undefined) {
      obj.stateInfo = RecommendationStateInfo.toJSON(message.stateInfo);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.associatedInsights?.length) {
      obj.associatedInsights = message.associatedInsights.map((e) => Recommendation_InsightReference.toJSON(e));
    }
    if (message.xorGroupId !== "") {
      obj.xorGroupId = message.xorGroupId;
    }
    return obj;
  },

  create(base?: DeepPartial<Recommendation>): Recommendation {
    return Recommendation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Recommendation>): Recommendation {
    const message = createBaseRecommendation();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.recommenderSubtype = object.recommenderSubtype ?? "";
    message.lastRefreshTime = object.lastRefreshTime ?? undefined;
    message.primaryImpact = (object.primaryImpact !== undefined && object.primaryImpact !== null)
      ? Impact.fromPartial(object.primaryImpact)
      : undefined;
    message.additionalImpact = object.additionalImpact?.map((e) => Impact.fromPartial(e)) || [];
    message.priority = object.priority ?? 0;
    message.content = (object.content !== undefined && object.content !== null)
      ? RecommendationContent.fromPartial(object.content)
      : undefined;
    message.stateInfo = (object.stateInfo !== undefined && object.stateInfo !== null)
      ? RecommendationStateInfo.fromPartial(object.stateInfo)
      : undefined;
    message.etag = object.etag ?? "";
    message.associatedInsights =
      object.associatedInsights?.map((e) => Recommendation_InsightReference.fromPartial(e)) || [];
    message.xorGroupId = object.xorGroupId ?? "";
    return message;
  },
};

function createBaseRecommendation_InsightReference(): Recommendation_InsightReference {
  return { insight: "" };
}

export const Recommendation_InsightReference: MessageFns<Recommendation_InsightReference> = {
  encode(message: Recommendation_InsightReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.insight !== "") {
      writer.uint32(10).string(message.insight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recommendation_InsightReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendation_InsightReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.insight = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recommendation_InsightReference {
    return { insight: isSet(object.insight) ? globalThis.String(object.insight) : "" };
  },

  toJSON(message: Recommendation_InsightReference): unknown {
    const obj: any = {};
    if (message.insight !== "") {
      obj.insight = message.insight;
    }
    return obj;
  },

  create(base?: DeepPartial<Recommendation_InsightReference>): Recommendation_InsightReference {
    return Recommendation_InsightReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Recommendation_InsightReference>): Recommendation_InsightReference {
    const message = createBaseRecommendation_InsightReference();
    message.insight = object.insight ?? "";
    return message;
  },
};

function createBaseRecommendationContent(): RecommendationContent {
  return { operationGroups: [], overview: undefined };
}

export const RecommendationContent: MessageFns<RecommendationContent> = {
  encode(message: RecommendationContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operationGroups) {
      OperationGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.overview !== undefined) {
      Struct.encode(Struct.wrap(message.overview), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecommendationContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendationContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationGroups.push(OperationGroup.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.overview = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommendationContent {
    return {
      operationGroups: globalThis.Array.isArray(object?.operationGroups)
        ? object.operationGroups.map((e: any) => OperationGroup.fromJSON(e))
        : [],
      overview: isObject(object.overview) ? object.overview : undefined,
    };
  },

  toJSON(message: RecommendationContent): unknown {
    const obj: any = {};
    if (message.operationGroups?.length) {
      obj.operationGroups = message.operationGroups.map((e) => OperationGroup.toJSON(e));
    }
    if (message.overview !== undefined) {
      obj.overview = message.overview;
    }
    return obj;
  },

  create(base?: DeepPartial<RecommendationContent>): RecommendationContent {
    return RecommendationContent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecommendationContent>): RecommendationContent {
    const message = createBaseRecommendationContent();
    message.operationGroups = object.operationGroups?.map((e) => OperationGroup.fromPartial(e)) || [];
    message.overview = object.overview ?? undefined;
    return message;
  },
};

function createBaseOperationGroup(): OperationGroup {
  return { operations: [] };
}

export const OperationGroup: MessageFns<OperationGroup> = {
  encode(message: OperationGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationGroup {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationGroup): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OperationGroup>): OperationGroup {
    return OperationGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationGroup>): OperationGroup {
    const message = createBaseOperationGroup();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    action: "",
    resourceType: "",
    resource: "",
    path: "",
    sourceResource: "",
    sourcePath: "",
    value: undefined,
    valueMatcher: undefined,
    pathFilters: {},
    pathValueMatchers: {},
  };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.resourceType !== "") {
      writer.uint32(18).string(message.resourceType);
    }
    if (message.resource !== "") {
      writer.uint32(26).string(message.resource);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.sourceResource !== "") {
      writer.uint32(42).string(message.sourceResource);
    }
    if (message.sourcePath !== "") {
      writer.uint32(50).string(message.sourcePath);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(58).fork()).join();
    }
    if (message.valueMatcher !== undefined) {
      ValueMatcher.encode(message.valueMatcher, writer.uint32(82).fork()).join();
    }
    Object.entries(message.pathFilters).forEach(([key, value]) => {
      if (value !== undefined) {
        Operation_PathFiltersEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
      }
    });
    Object.entries(message.pathValueMatchers).forEach(([key, value]) => {
      Operation_PathValueMatchersEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceResource = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.valueMatcher = ValueMatcher.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Operation_PathFiltersEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.pathFilters[entry8.key] = entry8.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = Operation_PathValueMatchersEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.pathValueMatchers[entry11.key] = entry11.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      sourceResource: isSet(object.sourceResource) ? globalThis.String(object.sourceResource) : "",
      sourcePath: isSet(object.sourcePath) ? globalThis.String(object.sourcePath) : "",
      value: isSet(object?.value) ? object.value : undefined,
      valueMatcher: isSet(object.valueMatcher) ? ValueMatcher.fromJSON(object.valueMatcher) : undefined,
      pathFilters: isObject(object.pathFilters)
        ? Object.entries(object.pathFilters).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      pathValueMatchers: isObject(object.pathValueMatchers)
        ? Object.entries(object.pathValueMatchers).reduce<{ [key: string]: ValueMatcher }>((acc, [key, value]) => {
          acc[key] = ValueMatcher.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.sourceResource !== "") {
      obj.sourceResource = message.sourceResource;
    }
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.valueMatcher !== undefined) {
      obj.valueMatcher = ValueMatcher.toJSON(message.valueMatcher);
    }
    if (message.pathFilters) {
      const entries = Object.entries(message.pathFilters);
      if (entries.length > 0) {
        obj.pathFilters = {};
        entries.forEach(([k, v]) => {
          obj.pathFilters[k] = v;
        });
      }
    }
    if (message.pathValueMatchers) {
      const entries = Object.entries(message.pathValueMatchers);
      if (entries.length > 0) {
        obj.pathValueMatchers = {};
        entries.forEach(([k, v]) => {
          obj.pathValueMatchers[k] = ValueMatcher.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Operation>): Operation {
    return Operation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation>): Operation {
    const message = createBaseOperation();
    message.action = object.action ?? "";
    message.resourceType = object.resourceType ?? "";
    message.resource = object.resource ?? "";
    message.path = object.path ?? "";
    message.sourceResource = object.sourceResource ?? "";
    message.sourcePath = object.sourcePath ?? "";
    message.value = object.value ?? undefined;
    message.valueMatcher = (object.valueMatcher !== undefined && object.valueMatcher !== null)
      ? ValueMatcher.fromPartial(object.valueMatcher)
      : undefined;
    message.pathFilters = Object.entries(object.pathFilters ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.pathValueMatchers = Object.entries(object.pathValueMatchers ?? {}).reduce<{ [key: string]: ValueMatcher }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ValueMatcher.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseOperation_PathFiltersEntry(): Operation_PathFiltersEntry {
  return { key: "", value: undefined };
}

export const Operation_PathFiltersEntry: MessageFns<Operation_PathFiltersEntry> = {
  encode(message: Operation_PathFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation_PathFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_PathFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation_PathFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Operation_PathFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Operation_PathFiltersEntry>): Operation_PathFiltersEntry {
    return Operation_PathFiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation_PathFiltersEntry>): Operation_PathFiltersEntry {
    const message = createBaseOperation_PathFiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseOperation_PathValueMatchersEntry(): Operation_PathValueMatchersEntry {
  return { key: "", value: undefined };
}

export const Operation_PathValueMatchersEntry: MessageFns<Operation_PathValueMatchersEntry> = {
  encode(message: Operation_PathValueMatchersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ValueMatcher.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation_PathValueMatchersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation_PathValueMatchersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ValueMatcher.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation_PathValueMatchersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ValueMatcher.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Operation_PathValueMatchersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ValueMatcher.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Operation_PathValueMatchersEntry>): Operation_PathValueMatchersEntry {
    return Operation_PathValueMatchersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation_PathValueMatchersEntry>): Operation_PathValueMatchersEntry {
    const message = createBaseOperation_PathValueMatchersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ValueMatcher.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseValueMatcher(): ValueMatcher {
  return { matchesPattern: undefined };
}

export const ValueMatcher: MessageFns<ValueMatcher> = {
  encode(message: ValueMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchesPattern !== undefined) {
      writer.uint32(10).string(message.matchesPattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchesPattern = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueMatcher {
    return { matchesPattern: isSet(object.matchesPattern) ? globalThis.String(object.matchesPattern) : undefined };
  },

  toJSON(message: ValueMatcher): unknown {
    const obj: any = {};
    if (message.matchesPattern !== undefined) {
      obj.matchesPattern = message.matchesPattern;
    }
    return obj;
  },

  create(base?: DeepPartial<ValueMatcher>): ValueMatcher {
    return ValueMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValueMatcher>): ValueMatcher {
    const message = createBaseValueMatcher();
    message.matchesPattern = object.matchesPattern ?? undefined;
    return message;
  },
};

function createBaseCostProjection(): CostProjection {
  return { cost: undefined, duration: undefined };
}

export const CostProjection: MessageFns<CostProjection> = {
  encode(message: CostProjection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cost !== undefined) {
      Money.encode(message.cost, writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CostProjection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCostProjection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cost = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CostProjection {
    return {
      cost: isSet(object.cost) ? Money.fromJSON(object.cost) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: CostProjection): unknown {
    const obj: any = {};
    if (message.cost !== undefined) {
      obj.cost = Money.toJSON(message.cost);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<CostProjection>): CostProjection {
    return CostProjection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CostProjection>): CostProjection {
    const message = createBaseCostProjection();
    message.cost = (object.cost !== undefined && object.cost !== null) ? Money.fromPartial(object.cost) : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseSecurityProjection(): SecurityProjection {
  return { details: undefined };
}

export const SecurityProjection: MessageFns<SecurityProjection> = {
  encode(message: SecurityProjection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.details !== undefined) {
      Struct.encode(Struct.wrap(message.details), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityProjection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityProjection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityProjection {
    return { details: isObject(object.details) ? object.details : undefined };
  },

  toJSON(message: SecurityProjection): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create(base?: DeepPartial<SecurityProjection>): SecurityProjection {
    return SecurityProjection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecurityProjection>): SecurityProjection {
    const message = createBaseSecurityProjection();
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseSustainabilityProjection(): SustainabilityProjection {
  return { kgCO2e: 0, duration: undefined };
}

export const SustainabilityProjection: MessageFns<SustainabilityProjection> = {
  encode(message: SustainabilityProjection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kgCO2e !== 0) {
      writer.uint32(9).double(message.kgCO2e);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SustainabilityProjection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSustainabilityProjection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.kgCO2e = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SustainabilityProjection {
    return {
      kgCO2e: isSet(object.kgCO2e) ? globalThis.Number(object.kgCO2e) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: SustainabilityProjection): unknown {
    const obj: any = {};
    if (message.kgCO2e !== 0) {
      obj.kgCO2e = message.kgCO2e;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<SustainabilityProjection>): SustainabilityProjection {
    return SustainabilityProjection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SustainabilityProjection>): SustainabilityProjection {
    const message = createBaseSustainabilityProjection();
    message.kgCO2e = object.kgCO2e ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseImpact(): Impact {
  return { category: 0, costProjection: undefined, securityProjection: undefined, sustainabilityProjection: undefined };
}

export const Impact: MessageFns<Impact> = {
  encode(message: Impact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== 0) {
      writer.uint32(8).int32(message.category);
    }
    if (message.costProjection !== undefined) {
      CostProjection.encode(message.costProjection, writer.uint32(802).fork()).join();
    }
    if (message.securityProjection !== undefined) {
      SecurityProjection.encode(message.securityProjection, writer.uint32(810).fork()).join();
    }
    if (message.sustainabilityProjection !== undefined) {
      SustainabilityProjection.encode(message.sustainabilityProjection, writer.uint32(818).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Impact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.costProjection = CostProjection.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.securityProjection = SecurityProjection.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.sustainabilityProjection = SustainabilityProjection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Impact {
    return {
      category: isSet(object.category) ? impact_CategoryFromJSON(object.category) : 0,
      costProjection: isSet(object.costProjection) ? CostProjection.fromJSON(object.costProjection) : undefined,
      securityProjection: isSet(object.securityProjection)
        ? SecurityProjection.fromJSON(object.securityProjection)
        : undefined,
      sustainabilityProjection: isSet(object.sustainabilityProjection)
        ? SustainabilityProjection.fromJSON(object.sustainabilityProjection)
        : undefined,
    };
  },

  toJSON(message: Impact): unknown {
    const obj: any = {};
    if (message.category !== 0) {
      obj.category = impact_CategoryToJSON(message.category);
    }
    if (message.costProjection !== undefined) {
      obj.costProjection = CostProjection.toJSON(message.costProjection);
    }
    if (message.securityProjection !== undefined) {
      obj.securityProjection = SecurityProjection.toJSON(message.securityProjection);
    }
    if (message.sustainabilityProjection !== undefined) {
      obj.sustainabilityProjection = SustainabilityProjection.toJSON(message.sustainabilityProjection);
    }
    return obj;
  },

  create(base?: DeepPartial<Impact>): Impact {
    return Impact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Impact>): Impact {
    const message = createBaseImpact();
    message.category = object.category ?? 0;
    message.costProjection = (object.costProjection !== undefined && object.costProjection !== null)
      ? CostProjection.fromPartial(object.costProjection)
      : undefined;
    message.securityProjection = (object.securityProjection !== undefined && object.securityProjection !== null)
      ? SecurityProjection.fromPartial(object.securityProjection)
      : undefined;
    message.sustainabilityProjection =
      (object.sustainabilityProjection !== undefined && object.sustainabilityProjection !== null)
        ? SustainabilityProjection.fromPartial(object.sustainabilityProjection)
        : undefined;
    return message;
  },
};

function createBaseRecommendationStateInfo(): RecommendationStateInfo {
  return { state: 0, stateMetadata: {} };
}

export const RecommendationStateInfo: MessageFns<RecommendationStateInfo> = {
  encode(message: RecommendationStateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    Object.entries(message.stateMetadata).forEach(([key, value]) => {
      RecommendationStateInfo_StateMetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecommendationStateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendationStateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = RecommendationStateInfo_StateMetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.stateMetadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommendationStateInfo {
    return {
      state: isSet(object.state) ? recommendationStateInfo_StateFromJSON(object.state) : 0,
      stateMetadata: isObject(object.stateMetadata)
        ? Object.entries(object.stateMetadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RecommendationStateInfo): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = recommendationStateInfo_StateToJSON(message.state);
    }
    if (message.stateMetadata) {
      const entries = Object.entries(message.stateMetadata);
      if (entries.length > 0) {
        obj.stateMetadata = {};
        entries.forEach(([k, v]) => {
          obj.stateMetadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RecommendationStateInfo>): RecommendationStateInfo {
    return RecommendationStateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecommendationStateInfo>): RecommendationStateInfo {
    const message = createBaseRecommendationStateInfo();
    message.state = object.state ?? 0;
    message.stateMetadata = Object.entries(object.stateMetadata ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRecommendationStateInfo_StateMetadataEntry(): RecommendationStateInfo_StateMetadataEntry {
  return { key: "", value: "" };
}

export const RecommendationStateInfo_StateMetadataEntry: MessageFns<RecommendationStateInfo_StateMetadataEntry> = {
  encode(message: RecommendationStateInfo_StateMetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecommendationStateInfo_StateMetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommendationStateInfo_StateMetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommendationStateInfo_StateMetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RecommendationStateInfo_StateMetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RecommendationStateInfo_StateMetadataEntry>): RecommendationStateInfo_StateMetadataEntry {
    return RecommendationStateInfo_StateMetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RecommendationStateInfo_StateMetadataEntry>,
  ): RecommendationStateInfo_StateMetadataEntry {
    const message = createBaseRecommendationStateInfo_StateMetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRecommenderType(): RecommenderType {
  return { name: "" };
}

export const RecommenderType: MessageFns<RecommenderType> = {
  encode(message: RecommenderType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecommenderType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecommenderType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecommenderType {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RecommenderType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RecommenderType>): RecommenderType {
    return RecommenderType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecommenderType>): RecommenderType {
    const message = createBaseRecommenderType();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
