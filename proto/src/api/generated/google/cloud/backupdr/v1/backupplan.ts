// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/backupdr/v1/backupplan.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../type/dayofweek.js";
import { Month, monthFromJSON, monthToJSON } from "../../../type/month.js";

export const protobufPackage = "google.cloud.backupdr.v1";

/**
 * A `BackupPlan` specifies some common fields, such as `description` as well
 * as one or more `BackupRule` messages. Each `BackupRule` has a retention
 * policy and defines a schedule by which the system is to perform backup
 * workloads.
 */
export interface BackupPlan {
  /**
   * Output only. Identifier. The resource name of the `BackupPlan`.
   *
   * Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
   */
  name: string;
  /**
   * Optional. The description of the `BackupPlan` resource.
   *
   * The description allows for additional details about `BackupPlan` and its
   * use cases to be provided. An example description is the following:  "This
   * is a backup plan that performs a daily backup at 6pm and retains data for 3
   * months". The description must be at most 2048 characters.
   */
  description: string;
  /**
   * Optional. This collection of key/value pairs allows for custom labels to be
   * supplied by the user.  Example, {"tag": "Weekly"}.
   */
  labels: { [key: string]: string };
  /** Output only. When the `BackupPlan` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. When the `BackupPlan` was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The backup rules for this `BackupPlan`. There must be at least
   * one `BackupRule` message.
   */
  backupRules: BackupRule[];
  /** Output only. The `State` for the `BackupPlan`. */
  state: BackupPlan_State;
  /**
   * Required. The resource type to which the `BackupPlan` will be applied.
   * Examples include, "compute.googleapis.com/Instance" and
   * "storage.googleapis.com/Bucket".
   */
  resourceType: string;
  /**
   * Optional. `etag` is returned from the service in the response. As a user of
   * the service, you may provide an etag value in this field to prevent stale
   * resources.
   */
  etag: string;
  /**
   * Required. Resource name of backup vault which will be used as storage
   * location for backups. Format:
   * projects/{project}/locations/{location}/backupVaults/{backupvault}
   */
  backupVault: string;
  /**
   * Output only. The Google Cloud Platform Service Account to be used by the
   * BackupVault for taking backups. Specify the email address of the Backup
   * Vault Service Account.
   */
  backupVaultServiceAccount: string;
}

/** `State` enumerates the possible states for a `BackupPlan`. */
export enum BackupPlan_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The resource is being created. */
  CREATING = 1,
  /** ACTIVE - The resource has been created and is fully usable. */
  ACTIVE = 2,
  /** DELETING - The resource is being deleted. */
  DELETING = 3,
  /** INACTIVE - The resource has been created but is not usable. */
  INACTIVE = 4,
  UNRECOGNIZED = -1,
}

export function backupPlan_StateFromJSON(object: any): BackupPlan_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BackupPlan_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return BackupPlan_State.CREATING;
    case 2:
    case "ACTIVE":
      return BackupPlan_State.ACTIVE;
    case 3:
    case "DELETING":
      return BackupPlan_State.DELETING;
    case 4:
    case "INACTIVE":
      return BackupPlan_State.INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupPlan_State.UNRECOGNIZED;
  }
}

export function backupPlan_StateToJSON(object: BackupPlan_State): string {
  switch (object) {
    case BackupPlan_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BackupPlan_State.CREATING:
      return "CREATING";
    case BackupPlan_State.ACTIVE:
      return "ACTIVE";
    case BackupPlan_State.DELETING:
      return "DELETING";
    case BackupPlan_State.INACTIVE:
      return "INACTIVE";
    case BackupPlan_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BackupPlan_LabelsEntry {
  key: string;
  value: string;
}

/** `BackupRule` binds the backup schedule to a retention policy. */
export interface BackupRule {
  /**
   * Required. Immutable. The unique id of this `BackupRule`. The `rule_id` is
   * unique per `BackupPlan`.The `rule_id` must start with a lowercase letter
   * followed by up to 62 lowercase letters, numbers, or hyphens. Pattern,
   * /[a-z][a-z0-9-]{,62}/.
   */
  ruleId: string;
  /**
   * Required. Configures the duration for which backup data will be kept. It is
   * defined in “days”. The value should be greater than or equal to minimum
   * enforced retention of the backup vault.
   */
  backupRetentionDays: number;
  /**
   * Required. Defines a schedule that runs within the confines of a defined
   * window of time.
   */
  standardSchedule?: StandardSchedule | undefined;
}

/**
 * `StandardSchedule` defines a schedule that run within the confines of a
 * defined window of days. We can define recurrence type for schedule as
 * HOURLY, DAILY, WEEKLY, MONTHLY or YEARLY.
 */
export interface StandardSchedule {
  /** Required. Specifies the `RecurrenceType` for the schedule. */
  recurrenceType: StandardSchedule_RecurrenceType;
  /**
   * Optional. Specifies frequency for hourly backups. A hourly frequency of 2
   * means jobs will run every 2 hours from start time till end time defined.
   *
   * This is required for `recurrence_type`, `HOURLY` and is not applicable
   * otherwise. A validation error will occur if a value is supplied and
   * `recurrence_type` is not `HOURLY`.
   *
   * Value of hourly frequency should be between 6 and 23.
   *
   * Reason for limit : We found that there is bandwidth limitation of 3GB/S for
   * GMI while taking a backup and 5GB/S while doing a restore. Given the amount
   * of parallel backups and restore we are targeting, this will potentially
   * take the backup time to mins and hours (in worst case scenario).
   */
  hourlyFrequency: number;
  /**
   * Optional. Specifies days of week like, MONDAY or TUESDAY, on which jobs
   * will run.
   *
   * This is required for `recurrence_type`, `WEEKLY` and is not applicable
   * otherwise. A validation error will occur if a value is supplied and
   * `recurrence_type` is not `WEEKLY`.
   */
  daysOfWeek: DayOfWeek[];
  /**
   * Optional. Specifies days of months like 1, 5, or 14 on which jobs will run.
   *
   * Values for `days_of_month` are only applicable for `recurrence_type`,
   * `MONTHLY` and `YEARLY`. A validation error will occur if other values are
   * supplied.
   */
  daysOfMonth: number[];
  /**
   * Optional. Specifies a week day of the month like, FIRST SUNDAY or LAST
   * MONDAY, on which jobs will run. This will be specified by two fields in
   * `WeekDayOfMonth`, one for the day, e.g. `MONDAY`, and one for the week,
   * e.g. `LAST`.
   *
   * This field is only applicable for `recurrence_type`, `MONTHLY` and
   * `YEARLY`. A validation error will occur if other values are supplied.
   */
  weekDayOfMonth:
    | WeekDayOfMonth
    | undefined;
  /**
   * Optional. Specifies the months of year, like `FEBRUARY` and/or `MAY`, on
   * which jobs will run.
   *
   * This field is only applicable when `recurrence_type` is `YEARLY`. A
   * validation error will occur if other values are supplied.
   */
  months: Month[];
  /**
   * Required. A BackupWindow defines the window of day during which backup jobs
   * will run. Jobs are queued at the beginning of the window and will be marked
   * as `NOT_RUN` if they do not start by the end of the window.
   *
   * Note: running jobs will not be cancelled at the end of the window.
   */
  backupWindow:
    | BackupWindow
    | undefined;
  /**
   * Required. The time zone to be used when interpreting the schedule.
   * The value of this field must be a time zone name from the IANA tz database.
   * See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for the
   * list of valid timezone names. For e.g., Europe/Paris.
   */
  timeZone: string;
}

/** `RecurrenceTypes` enumerates the applicable periodicity for the schedule. */
export enum StandardSchedule_RecurrenceType {
  /** RECURRENCE_TYPE_UNSPECIFIED - recurrence type not set */
  RECURRENCE_TYPE_UNSPECIFIED = 0,
  /** HOURLY - The `BackupRule` is to be applied hourly. */
  HOURLY = 1,
  /** DAILY - The `BackupRule` is to be applied daily. */
  DAILY = 2,
  /** WEEKLY - The `BackupRule` is to be applied weekly. */
  WEEKLY = 3,
  /** MONTHLY - The `BackupRule` is to be applied monthly. */
  MONTHLY = 4,
  /** YEARLY - The `BackupRule` is to be applied yearly. */
  YEARLY = 5,
  UNRECOGNIZED = -1,
}

export function standardSchedule_RecurrenceTypeFromJSON(object: any): StandardSchedule_RecurrenceType {
  switch (object) {
    case 0:
    case "RECURRENCE_TYPE_UNSPECIFIED":
      return StandardSchedule_RecurrenceType.RECURRENCE_TYPE_UNSPECIFIED;
    case 1:
    case "HOURLY":
      return StandardSchedule_RecurrenceType.HOURLY;
    case 2:
    case "DAILY":
      return StandardSchedule_RecurrenceType.DAILY;
    case 3:
    case "WEEKLY":
      return StandardSchedule_RecurrenceType.WEEKLY;
    case 4:
    case "MONTHLY":
      return StandardSchedule_RecurrenceType.MONTHLY;
    case 5:
    case "YEARLY":
      return StandardSchedule_RecurrenceType.YEARLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StandardSchedule_RecurrenceType.UNRECOGNIZED;
  }
}

export function standardSchedule_RecurrenceTypeToJSON(object: StandardSchedule_RecurrenceType): string {
  switch (object) {
    case StandardSchedule_RecurrenceType.RECURRENCE_TYPE_UNSPECIFIED:
      return "RECURRENCE_TYPE_UNSPECIFIED";
    case StandardSchedule_RecurrenceType.HOURLY:
      return "HOURLY";
    case StandardSchedule_RecurrenceType.DAILY:
      return "DAILY";
    case StandardSchedule_RecurrenceType.WEEKLY:
      return "WEEKLY";
    case StandardSchedule_RecurrenceType.MONTHLY:
      return "MONTHLY";
    case StandardSchedule_RecurrenceType.YEARLY:
      return "YEARLY";
    case StandardSchedule_RecurrenceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** `BackupWindow` defines a window of the day during which backup jobs will run. */
export interface BackupWindow {
  /**
   * Required. The hour of day (0-23) when the window starts for e.g. if value
   * of start hour of day is 6 that mean backup window start at 6:00.
   */
  startHourOfDay: number;
  /**
   * Required. The hour of day (1-24) when the window end for e.g. if value of
   * end hour of day is 10 that mean backup window end time is 10:00.
   *
   * End hour of day should be greater than start hour of day.
   * 0 <= start_hour_of_day < end_hour_of_day <= 24
   *
   * End hour of day is not include in backup window that mean if
   * end_hour_of_day= 10 jobs should start before 10:00.
   */
  endHourOfDay: number;
}

/**
 * `WeekDayOfMonth` defines the week day of the month on which the backups will
 * run. The message combines a `WeekOfMonth` and `DayOfWeek` to produce values
 * like `FIRST`/`MONDAY` or `LAST`/`FRIDAY`.
 */
export interface WeekDayOfMonth {
  /** Required. Specifies the week of the month. */
  weekOfMonth: WeekDayOfMonth_WeekOfMonth;
  /** Required. Specifies the day of the week. */
  dayOfWeek: DayOfWeek;
}

/**
 * `WeekOfMonth` enumerates possible weeks in the month, e.g. the first,
 * third, or last week of the month.
 */
export enum WeekDayOfMonth_WeekOfMonth {
  /** WEEK_OF_MONTH_UNSPECIFIED - The zero value. Do not use. */
  WEEK_OF_MONTH_UNSPECIFIED = 0,
  /** FIRST - The first week of the month. */
  FIRST = 1,
  /** SECOND - The second week of the month. */
  SECOND = 2,
  /** THIRD - The third week of the month. */
  THIRD = 3,
  /** FOURTH - The fourth  week of the month. */
  FOURTH = 4,
  /** LAST - The last  week of the month. */
  LAST = 5,
  UNRECOGNIZED = -1,
}

export function weekDayOfMonth_WeekOfMonthFromJSON(object: any): WeekDayOfMonth_WeekOfMonth {
  switch (object) {
    case 0:
    case "WEEK_OF_MONTH_UNSPECIFIED":
      return WeekDayOfMonth_WeekOfMonth.WEEK_OF_MONTH_UNSPECIFIED;
    case 1:
    case "FIRST":
      return WeekDayOfMonth_WeekOfMonth.FIRST;
    case 2:
    case "SECOND":
      return WeekDayOfMonth_WeekOfMonth.SECOND;
    case 3:
    case "THIRD":
      return WeekDayOfMonth_WeekOfMonth.THIRD;
    case 4:
    case "FOURTH":
      return WeekDayOfMonth_WeekOfMonth.FOURTH;
    case 5:
    case "LAST":
      return WeekDayOfMonth_WeekOfMonth.LAST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WeekDayOfMonth_WeekOfMonth.UNRECOGNIZED;
  }
}

export function weekDayOfMonth_WeekOfMonthToJSON(object: WeekDayOfMonth_WeekOfMonth): string {
  switch (object) {
    case WeekDayOfMonth_WeekOfMonth.WEEK_OF_MONTH_UNSPECIFIED:
      return "WEEK_OF_MONTH_UNSPECIFIED";
    case WeekDayOfMonth_WeekOfMonth.FIRST:
      return "FIRST";
    case WeekDayOfMonth_WeekOfMonth.SECOND:
      return "SECOND";
    case WeekDayOfMonth_WeekOfMonth.THIRD:
      return "THIRD";
    case WeekDayOfMonth_WeekOfMonth.FOURTH:
      return "FOURTH";
    case WeekDayOfMonth_WeekOfMonth.LAST:
      return "LAST";
    case WeekDayOfMonth_WeekOfMonth.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The request message for creating a `BackupPlan`. */
export interface CreateBackupPlanRequest {
  /**
   * Required. The `BackupPlan` project and location in the format
   * `projects/{project}/locations/{location}`. In Cloud BackupDR locations
   * map to GCP regions, for example **us-central1**.
   */
  parent: string;
  /**
   * Required. The name of the `BackupPlan` to create. The name must be unique
   * for the specified project and location.The name must start with a lowercase
   * letter followed by up to 62 lowercase letters, numbers, or hyphens.
   * Pattern, /[a-z][a-z0-9-]{,62}/.
   */
  backupPlanId: string;
  /** Required. The `BackupPlan` resource object to create. */
  backupPlan:
    | BackupPlan
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** The request message for getting a list `BackupPlan`. */
export interface ListBackupPlansRequest {
  /**
   * Required. The project and location for which to retrieve `BackupPlans`
   * information. Format: `projects/{project}/locations/{location}`. In Cloud
   * BackupDR, locations map to GCP regions, for e.g. **us-central1**. To
   * retrieve backup plans for all locations, use "-" for the
   * `{location}` value.
   */
  parent: string;
  /**
   * Optional. The maximum number of `BackupPlans` to return in a single
   * response. If not specified, a default value will be chosen by the service.
   * Note that the response may include a partial list and a caller should
   * only rely on the response's
   * [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
   * to determine if there are more instances left to be queried.
   */
  pageSize: number;
  /**
   * Optional. The value of
   * [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
   * received from a previous `ListBackupPlans` call.
   * Provide this to retrieve the subsequent page in a multi-page list of
   * results. When paginating, all other parameters provided to
   * `ListBackupPlans` must match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. Field match expression used to filter the results. */
  filter: string;
  /** Optional. Field by which to sort the results. */
  orderBy: string;
}

/** The response message for getting a list of `BackupPlan`. */
export interface ListBackupPlansResponse {
  /**
   * The list of `BackupPlans` in the project for the specified
   * location.
   *
   * If the `{location}` value in the request is "-", the response contains a
   * list of resources from all locations. In case any location is unreachable,
   * the response will only return backup plans in reachable locations and
   * the 'unreachable' field will be populated with a list of unreachable
   * locations.
   * BackupPlan
   */
  backupPlans: BackupPlan[];
  /**
   * A token which may be sent as
   * [page_token][google.cloud.backupdr.v1.ListBackupPlansRequest.page_token] in
   * a subsequent `ListBackupPlans` call to retrieve the next page of results.
   * If this field is omitted or empty, then there are no more results to
   * return.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request message for getting a `BackupPlan`. */
export interface GetBackupPlanRequest {
  /**
   * Required. The resource name of the `BackupPlan` to retrieve.
   *
   * Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
   */
  name: string;
}

/** The request message for deleting a `BackupPlan`. */
export interface DeleteBackupPlanRequest {
  /**
   * Required. The resource name of the `BackupPlan` to delete.
   *
   * Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
   */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

function createBaseBackupPlan(): BackupPlan {
  return {
    name: "",
    description: "",
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    backupRules: [],
    state: 0,
    resourceType: "",
    etag: "",
    backupVault: "",
    backupVaultServiceAccount: "",
  };
}

export const BackupPlan: MessageFns<BackupPlan> = {
  encode(message: BackupPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      BackupPlan_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    for (const v of message.backupRules) {
      BackupRule.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.resourceType !== "") {
      writer.uint32(66).string(message.resourceType);
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.backupVault !== "") {
      writer.uint32(82).string(message.backupVault);
    }
    if (message.backupVaultServiceAccount !== "") {
      writer.uint32(90).string(message.backupVaultServiceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BackupPlan_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.backupRules.push(BackupRule.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.backupVault = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.backupVaultServiceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      backupRules: globalThis.Array.isArray(object?.backupRules)
        ? object.backupRules.map((e: any) => BackupRule.fromJSON(e))
        : [],
      state: isSet(object.state) ? backupPlan_StateFromJSON(object.state) : 0,
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      backupVault: isSet(object.backupVault) ? globalThis.String(object.backupVault) : "",
      backupVaultServiceAccount: isSet(object.backupVaultServiceAccount)
        ? globalThis.String(object.backupVaultServiceAccount)
        : "",
    };
  },

  toJSON(message: BackupPlan): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.backupRules?.length) {
      obj.backupRules = message.backupRules.map((e) => BackupRule.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = backupPlan_StateToJSON(message.state);
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.backupVault !== "") {
      obj.backupVault = message.backupVault;
    }
    if (message.backupVaultServiceAccount !== "") {
      obj.backupVaultServiceAccount = message.backupVaultServiceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan>): BackupPlan {
    return BackupPlan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan>): BackupPlan {
    const message = createBaseBackupPlan();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.backupRules = object.backupRules?.map((e) => BackupRule.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.resourceType = object.resourceType ?? "";
    message.etag = object.etag ?? "";
    message.backupVault = object.backupVault ?? "";
    message.backupVaultServiceAccount = object.backupVaultServiceAccount ?? "";
    return message;
  },
};

function createBaseBackupPlan_LabelsEntry(): BackupPlan_LabelsEntry {
  return { key: "", value: "" };
}

export const BackupPlan_LabelsEntry: MessageFns<BackupPlan_LabelsEntry> = {
  encode(message: BackupPlan_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BackupPlan_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan_LabelsEntry>): BackupPlan_LabelsEntry {
    return BackupPlan_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan_LabelsEntry>): BackupPlan_LabelsEntry {
    const message = createBaseBackupPlan_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackupRule(): BackupRule {
  return { ruleId: "", backupRetentionDays: 0, standardSchedule: undefined };
}

export const BackupRule: MessageFns<BackupRule> = {
  encode(message: BackupRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.backupRetentionDays !== 0) {
      writer.uint32(32).int32(message.backupRetentionDays);
    }
    if (message.standardSchedule !== undefined) {
      StandardSchedule.encode(message.standardSchedule, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.backupRetentionDays = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.standardSchedule = StandardSchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupRule {
    return {
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      backupRetentionDays: isSet(object.backupRetentionDays) ? globalThis.Number(object.backupRetentionDays) : 0,
      standardSchedule: isSet(object.standardSchedule) ? StandardSchedule.fromJSON(object.standardSchedule) : undefined,
    };
  },

  toJSON(message: BackupRule): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.backupRetentionDays !== 0) {
      obj.backupRetentionDays = Math.round(message.backupRetentionDays);
    }
    if (message.standardSchedule !== undefined) {
      obj.standardSchedule = StandardSchedule.toJSON(message.standardSchedule);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupRule>): BackupRule {
    return BackupRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupRule>): BackupRule {
    const message = createBaseBackupRule();
    message.ruleId = object.ruleId ?? "";
    message.backupRetentionDays = object.backupRetentionDays ?? 0;
    message.standardSchedule = (object.standardSchedule !== undefined && object.standardSchedule !== null)
      ? StandardSchedule.fromPartial(object.standardSchedule)
      : undefined;
    return message;
  },
};

function createBaseStandardSchedule(): StandardSchedule {
  return {
    recurrenceType: 0,
    hourlyFrequency: 0,
    daysOfWeek: [],
    daysOfMonth: [],
    weekDayOfMonth: undefined,
    months: [],
    backupWindow: undefined,
    timeZone: "",
  };
}

export const StandardSchedule: MessageFns<StandardSchedule> = {
  encode(message: StandardSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recurrenceType !== 0) {
      writer.uint32(8).int32(message.recurrenceType);
    }
    if (message.hourlyFrequency !== 0) {
      writer.uint32(16).int32(message.hourlyFrequency);
    }
    writer.uint32(26).fork();
    for (const v of message.daysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.daysOfMonth) {
      writer.int32(v);
    }
    writer.join();
    if (message.weekDayOfMonth !== undefined) {
      WeekDayOfMonth.encode(message.weekDayOfMonth, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.months) {
      writer.int32(v);
    }
    writer.join();
    if (message.backupWindow !== undefined) {
      BackupWindow.encode(message.backupWindow, writer.uint32(58).fork()).join();
    }
    if (message.timeZone !== "") {
      writer.uint32(66).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recurrenceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hourlyFrequency = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.daysOfWeek.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.daysOfWeek.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.daysOfMonth.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.daysOfMonth.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.weekDayOfMonth = WeekDayOfMonth.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag === 48) {
            message.months.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.months.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.backupWindow = BackupWindow.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSchedule {
    return {
      recurrenceType: isSet(object.recurrenceType) ? standardSchedule_RecurrenceTypeFromJSON(object.recurrenceType) : 0,
      hourlyFrequency: isSet(object.hourlyFrequency) ? globalThis.Number(object.hourlyFrequency) : 0,
      daysOfWeek: globalThis.Array.isArray(object?.daysOfWeek)
        ? object.daysOfWeek.map((e: any) => dayOfWeekFromJSON(e))
        : [],
      daysOfMonth: globalThis.Array.isArray(object?.daysOfMonth)
        ? object.daysOfMonth.map((e: any) => globalThis.Number(e))
        : [],
      weekDayOfMonth: isSet(object.weekDayOfMonth) ? WeekDayOfMonth.fromJSON(object.weekDayOfMonth) : undefined,
      months: globalThis.Array.isArray(object?.months) ? object.months.map((e: any) => monthFromJSON(e)) : [],
      backupWindow: isSet(object.backupWindow) ? BackupWindow.fromJSON(object.backupWindow) : undefined,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
    };
  },

  toJSON(message: StandardSchedule): unknown {
    const obj: any = {};
    if (message.recurrenceType !== 0) {
      obj.recurrenceType = standardSchedule_RecurrenceTypeToJSON(message.recurrenceType);
    }
    if (message.hourlyFrequency !== 0) {
      obj.hourlyFrequency = Math.round(message.hourlyFrequency);
    }
    if (message.daysOfWeek?.length) {
      obj.daysOfWeek = message.daysOfWeek.map((e) => dayOfWeekToJSON(e));
    }
    if (message.daysOfMonth?.length) {
      obj.daysOfMonth = message.daysOfMonth.map((e) => Math.round(e));
    }
    if (message.weekDayOfMonth !== undefined) {
      obj.weekDayOfMonth = WeekDayOfMonth.toJSON(message.weekDayOfMonth);
    }
    if (message.months?.length) {
      obj.months = message.months.map((e) => monthToJSON(e));
    }
    if (message.backupWindow !== undefined) {
      obj.backupWindow = BackupWindow.toJSON(message.backupWindow);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSchedule>): StandardSchedule {
    return StandardSchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSchedule>): StandardSchedule {
    const message = createBaseStandardSchedule();
    message.recurrenceType = object.recurrenceType ?? 0;
    message.hourlyFrequency = object.hourlyFrequency ?? 0;
    message.daysOfWeek = object.daysOfWeek?.map((e) => e) || [];
    message.daysOfMonth = object.daysOfMonth?.map((e) => e) || [];
    message.weekDayOfMonth = (object.weekDayOfMonth !== undefined && object.weekDayOfMonth !== null)
      ? WeekDayOfMonth.fromPartial(object.weekDayOfMonth)
      : undefined;
    message.months = object.months?.map((e) => e) || [];
    message.backupWindow = (object.backupWindow !== undefined && object.backupWindow !== null)
      ? BackupWindow.fromPartial(object.backupWindow)
      : undefined;
    message.timeZone = object.timeZone ?? "";
    return message;
  },
};

function createBaseBackupWindow(): BackupWindow {
  return { startHourOfDay: 0, endHourOfDay: 0 };
}

export const BackupWindow: MessageFns<BackupWindow> = {
  encode(message: BackupWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startHourOfDay !== 0) {
      writer.uint32(8).int32(message.startHourOfDay);
    }
    if (message.endHourOfDay !== 0) {
      writer.uint32(16).int32(message.endHourOfDay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startHourOfDay = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endHourOfDay = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupWindow {
    return {
      startHourOfDay: isSet(object.startHourOfDay) ? globalThis.Number(object.startHourOfDay) : 0,
      endHourOfDay: isSet(object.endHourOfDay) ? globalThis.Number(object.endHourOfDay) : 0,
    };
  },

  toJSON(message: BackupWindow): unknown {
    const obj: any = {};
    if (message.startHourOfDay !== 0) {
      obj.startHourOfDay = Math.round(message.startHourOfDay);
    }
    if (message.endHourOfDay !== 0) {
      obj.endHourOfDay = Math.round(message.endHourOfDay);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupWindow>): BackupWindow {
    return BackupWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupWindow>): BackupWindow {
    const message = createBaseBackupWindow();
    message.startHourOfDay = object.startHourOfDay ?? 0;
    message.endHourOfDay = object.endHourOfDay ?? 0;
    return message;
  },
};

function createBaseWeekDayOfMonth(): WeekDayOfMonth {
  return { weekOfMonth: 0, dayOfWeek: 0 };
}

export const WeekDayOfMonth: MessageFns<WeekDayOfMonth> = {
  encode(message: WeekDayOfMonth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weekOfMonth !== 0) {
      writer.uint32(8).int32(message.weekOfMonth);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(16).int32(message.dayOfWeek);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeekDayOfMonth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeekDayOfMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weekOfMonth = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeekDayOfMonth {
    return {
      weekOfMonth: isSet(object.weekOfMonth) ? weekDayOfMonth_WeekOfMonthFromJSON(object.weekOfMonth) : 0,
      dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekFromJSON(object.dayOfWeek) : 0,
    };
  },

  toJSON(message: WeekDayOfMonth): unknown {
    const obj: any = {};
    if (message.weekOfMonth !== 0) {
      obj.weekOfMonth = weekDayOfMonth_WeekOfMonthToJSON(message.weekOfMonth);
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekToJSON(message.dayOfWeek);
    }
    return obj;
  },

  create(base?: DeepPartial<WeekDayOfMonth>): WeekDayOfMonth {
    return WeekDayOfMonth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeekDayOfMonth>): WeekDayOfMonth {
    const message = createBaseWeekDayOfMonth();
    message.weekOfMonth = object.weekOfMonth ?? 0;
    message.dayOfWeek = object.dayOfWeek ?? 0;
    return message;
  },
};

function createBaseCreateBackupPlanRequest(): CreateBackupPlanRequest {
  return { parent: "", backupPlanId: "", backupPlan: undefined, requestId: "" };
}

export const CreateBackupPlanRequest: MessageFns<CreateBackupPlanRequest> = {
  encode(message: CreateBackupPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.backupPlanId !== "") {
      writer.uint32(18).string(message.backupPlanId);
    }
    if (message.backupPlan !== undefined) {
      BackupPlan.encode(message.backupPlan, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBackupPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBackupPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupPlanId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupPlan = BackupPlan.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBackupPlanRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      backupPlanId: isSet(object.backupPlanId) ? globalThis.String(object.backupPlanId) : "",
      backupPlan: isSet(object.backupPlan) ? BackupPlan.fromJSON(object.backupPlan) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateBackupPlanRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.backupPlanId !== "") {
      obj.backupPlanId = message.backupPlanId;
    }
    if (message.backupPlan !== undefined) {
      obj.backupPlan = BackupPlan.toJSON(message.backupPlan);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBackupPlanRequest>): CreateBackupPlanRequest {
    return CreateBackupPlanRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBackupPlanRequest>): CreateBackupPlanRequest {
    const message = createBaseCreateBackupPlanRequest();
    message.parent = object.parent ?? "";
    message.backupPlanId = object.backupPlanId ?? "";
    message.backupPlan = (object.backupPlan !== undefined && object.backupPlan !== null)
      ? BackupPlan.fromPartial(object.backupPlan)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListBackupPlansRequest(): ListBackupPlansRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListBackupPlansRequest: MessageFns<ListBackupPlansRequest> = {
  encode(message: ListBackupPlansRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupPlansRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupPlansRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupPlansRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListBackupPlansRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupPlansRequest>): ListBackupPlansRequest {
    return ListBackupPlansRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupPlansRequest>): ListBackupPlansRequest {
    const message = createBaseListBackupPlansRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListBackupPlansResponse(): ListBackupPlansResponse {
  return { backupPlans: [], nextPageToken: "", unreachable: [] };
}

export const ListBackupPlansResponse: MessageFns<ListBackupPlansResponse> = {
  encode(message: ListBackupPlansResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backupPlans) {
      BackupPlan.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupPlansResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupPlansResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPlans.push(BackupPlan.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupPlansResponse {
    return {
      backupPlans: globalThis.Array.isArray(object?.backupPlans)
        ? object.backupPlans.map((e: any) => BackupPlan.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBackupPlansResponse): unknown {
    const obj: any = {};
    if (message.backupPlans?.length) {
      obj.backupPlans = message.backupPlans.map((e) => BackupPlan.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupPlansResponse>): ListBackupPlansResponse {
    return ListBackupPlansResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupPlansResponse>): ListBackupPlansResponse {
    const message = createBaseListBackupPlansResponse();
    message.backupPlans = object.backupPlans?.map((e) => BackupPlan.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBackupPlanRequest(): GetBackupPlanRequest {
  return { name: "" };
}

export const GetBackupPlanRequest: MessageFns<GetBackupPlanRequest> = {
  encode(message: GetBackupPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBackupPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBackupPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBackupPlanRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBackupPlanRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBackupPlanRequest>): GetBackupPlanRequest {
    return GetBackupPlanRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBackupPlanRequest>): GetBackupPlanRequest {
    const message = createBaseGetBackupPlanRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteBackupPlanRequest(): DeleteBackupPlanRequest {
  return { name: "", requestId: "" };
}

export const DeleteBackupPlanRequest: MessageFns<DeleteBackupPlanRequest> = {
  encode(message: DeleteBackupPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBackupPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBackupPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBackupPlanRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteBackupPlanRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBackupPlanRequest>): DeleteBackupPlanRequest {
    return DeleteBackupPlanRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBackupPlanRequest>): DeleteBackupPlanRequest {
    const message = createBaseDeleteBackupPlanRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
