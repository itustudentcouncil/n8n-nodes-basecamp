// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/connection/v1/connection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../../iam/v1/iam_policy.js";
import { Policy } from "../../../../iam/v1/policy.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";

export const protobufPackage = "google.cloud.bigquery.connection.v1";

/**
 * The request for
 * [ConnectionService.CreateConnection][google.cloud.bigquery.connection.v1.ConnectionService.CreateConnection].
 */
export interface CreateConnectionRequest {
  /**
   * Required. Parent resource name.
   * Must be in the format `projects/{project_id}/locations/{location_id}`
   */
  parent: string;
  /** Optional. Connection id that should be assigned to the created connection. */
  connectionId: string;
  /** Required. Connection to create. */
  connection: Connection | undefined;
}

/**
 * The request for
 * [ConnectionService.GetConnection][google.cloud.bigquery.connection.v1.ConnectionService.GetConnection].
 */
export interface GetConnectionRequest {
  /**
   * Required. Name of the requested connection, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
}

/**
 * The request for
 * [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
 */
export interface ListConnectionsRequest {
  /**
   * Required. Parent resource name.
   * Must be in the form: `projects/{project_id}/locations/{location_id}`
   */
  parent: string;
  /** Required. Page size. */
  pageSize: number;
  /** Page token. */
  pageToken: string;
}

/**
 * The response for
 * [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1.ConnectionService.ListConnections].
 */
export interface ListConnectionsResponse {
  /** Next page token. */
  nextPageToken: string;
  /** List of connections. */
  connections: Connection[];
}

/**
 * The request for
 * [ConnectionService.UpdateConnection][google.cloud.bigquery.connection.v1.ConnectionService.UpdateConnection].
 */
export interface UpdateConnectionRequest {
  /**
   * Required. Name of the connection to update, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
  /** Required. Connection containing the updated fields. */
  connection:
    | Connection
    | undefined;
  /** Required. Update mask for the connection fields to be updated. */
  updateMask: string[] | undefined;
}

/** The request for [ConnectionService.DeleteConnectionRequest][]. */
export interface DeleteConnectionRequest {
  /**
   * Required. Name of the deleted connection, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
}

/**
 * Configuration parameters to establish connection with an external data
 * source, except the credential attributes.
 */
export interface Connection {
  /**
   * The resource name of the connection in the form of:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
  /** User provided display name for the connection. */
  friendlyName: string;
  /** User provided description. */
  description: string;
  /** Cloud SQL properties. */
  cloudSql?:
    | CloudSqlProperties
    | undefined;
  /** Amazon Web Services (AWS) properties. */
  aws?:
    | AwsProperties
    | undefined;
  /** Azure properties. */
  azure?:
    | AzureProperties
    | undefined;
  /** Cloud Spanner properties. */
  cloudSpanner?:
    | CloudSpannerProperties
    | undefined;
  /** Cloud Resource properties. */
  cloudResource?:
    | CloudResourceProperties
    | undefined;
  /** Spark properties. */
  spark?:
    | SparkProperties
    | undefined;
  /**
   * Optional. Salesforce DataCloud properties. This field is intended for
   * use only by Salesforce partner projects. This field contains properties
   * for your Salesforce DataCloud connection.
   */
  salesforceDataCloud?:
    | SalesforceDataCloudProperties
    | undefined;
  /** Output only. The creation timestamp of the connection. */
  creationTime: Long;
  /** Output only. The last update timestamp of the connection. */
  lastModifiedTime: Long;
  /** Output only. True, if credential is configured for this connection. */
  hasCredential: boolean;
}

/** Connection properties specific to the Cloud SQL. */
export interface CloudSqlProperties {
  /** Cloud SQL instance ID in the form `project:location:instance`. */
  instanceId: string;
  /** Database name. */
  database: string;
  /** Type of the Cloud SQL database. */
  type: CloudSqlProperties_DatabaseType;
  /** Input only. Cloud SQL credential. */
  credential:
    | CloudSqlCredential
    | undefined;
  /**
   * Output only. The account ID of the service used for the purpose of this
   * connection.
   *
   * When the connection is used in the context of an operation in
   * BigQuery, this service account will serve as the identity being used for
   * connecting to the CloudSQL instance specified in this connection.
   */
  serviceAccountId: string;
}

/** Supported Cloud SQL database types. */
export enum CloudSqlProperties_DatabaseType {
  /** DATABASE_TYPE_UNSPECIFIED - Unspecified database type. */
  DATABASE_TYPE_UNSPECIFIED = 0,
  /** POSTGRES - Cloud SQL for PostgreSQL. */
  POSTGRES = 1,
  /** MYSQL - Cloud SQL for MySQL. */
  MYSQL = 2,
  UNRECOGNIZED = -1,
}

export function cloudSqlProperties_DatabaseTypeFromJSON(object: any): CloudSqlProperties_DatabaseType {
  switch (object) {
    case 0:
    case "DATABASE_TYPE_UNSPECIFIED":
      return CloudSqlProperties_DatabaseType.DATABASE_TYPE_UNSPECIFIED;
    case 1:
    case "POSTGRES":
      return CloudSqlProperties_DatabaseType.POSTGRES;
    case 2:
    case "MYSQL":
      return CloudSqlProperties_DatabaseType.MYSQL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlProperties_DatabaseType.UNRECOGNIZED;
  }
}

export function cloudSqlProperties_DatabaseTypeToJSON(object: CloudSqlProperties_DatabaseType): string {
  switch (object) {
    case CloudSqlProperties_DatabaseType.DATABASE_TYPE_UNSPECIFIED:
      return "DATABASE_TYPE_UNSPECIFIED";
    case CloudSqlProperties_DatabaseType.POSTGRES:
      return "POSTGRES";
    case CloudSqlProperties_DatabaseType.MYSQL:
      return "MYSQL";
    case CloudSqlProperties_DatabaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Credential info for the Cloud SQL. */
export interface CloudSqlCredential {
  /** The username for the credential. */
  username: string;
  /** The password for the credential. */
  password: string;
}

/** Connection properties specific to Cloud Spanner. */
export interface CloudSpannerProperties {
  /** Cloud Spanner database in the form `project/instance/database' */
  database: string;
  /** If parallelism should be used when reading from Cloud Spanner */
  useParallelism: boolean;
  /**
   * Allows setting max parallelism per query when executing on Spanner
   * independent compute resources. If unspecified, default values of
   * parallelism are chosen that are dependent on the Cloud Spanner instance
   * configuration.
   *
   * REQUIRES: `use_parallelism` must be set.
   * REQUIRES: Either `use_data_boost` or `use_serverless_analytics` must be
   * set.
   */
  maxParallelism: number;
  /**
   * If the serverless analytics service should be used to read data from Cloud
   * Spanner.
   * Note: `use_parallelism` must be set when using serverless analytics.
   */
  useServerlessAnalytics: boolean;
  /**
   * If set, the request will be executed via Spanner independent compute
   * resources.
   * REQUIRES: `use_parallelism` must be set.
   *
   * NOTE: `use_serverless_analytics` will be deprecated. Prefer
   * `use_data_boost` over `use_serverless_analytics`.
   */
  useDataBoost: boolean;
  /**
   * Optional. Cloud Spanner database role for fine-grained access control.
   * The Cloud Spanner admin should have provisioned the database role with
   * appropriate permissions, such as `SELECT` and `INSERT`. Other users should
   * only use roles provided by their Cloud Spanner admins.
   *
   * For more details, see [About fine-grained access control]
   * (https://cloud.google.com/spanner/docs/fgac-about).
   *
   * REQUIRES: The database role name must start with a letter, and can only
   * contain letters, numbers, and underscores.
   */
  databaseRole: string;
}

/** Connection properties specific to Amazon Web Services (AWS). */
export interface AwsProperties {
  /**
   * Authentication using Google owned AWS IAM user's access key to assume
   * into customer's AWS IAM Role.
   * Deprecated, do not use.
   *
   * @deprecated
   */
  crossAccountRole?:
    | AwsCrossAccountRole
    | undefined;
  /**
   * Authentication using Google owned service account to assume into
   * customer's AWS IAM Role.
   */
  accessRole?: AwsAccessRole | undefined;
}

/**
 * Authentication method for Amazon Web Services (AWS) that uses Google owned
 * AWS IAM user's access key to assume into customer's AWS IAM Role.
 */
export interface AwsCrossAccountRole {
  /**
   * The user’s AWS IAM Role that trusts the Google-owned AWS IAM user
   * Connection.
   */
  iamRoleId: string;
  /** Output only. Google-owned AWS IAM User for a Connection. */
  iamUserId: string;
  /**
   * Output only. A Google-generated id for representing Connection’s identity
   * in AWS. External Id is also used for preventing the Confused Deputy
   * Problem. See
   * https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html
   */
  externalId: string;
}

/**
 * Authentication method for Amazon Web Services (AWS) that uses Google owned
 * Google service account to assume into customer's AWS IAM Role.
 */
export interface AwsAccessRole {
  /**
   * The user’s AWS IAM Role that trusts the Google-owned AWS IAM user
   * Connection.
   */
  iamRoleId: string;
  /**
   * A unique Google-owned and Google-generated identity for the Connection.
   * This identity will be used to access the user's AWS IAM Role.
   */
  identity: string;
}

/** Container for connection properties specific to Azure. */
export interface AzureProperties {
  /** Output only. The name of the Azure Active Directory Application. */
  application: string;
  /** Output only. The client id of the Azure Active Directory Application. */
  clientId: string;
  /** Output only. The object id of the Azure Active Directory Application. */
  objectId: string;
  /** The id of customer's directory that host the data. */
  customerTenantId: string;
  /**
   * The URL user will be redirected to after granting consent during connection
   * setup.
   */
  redirectUri: string;
  /**
   * The client ID of the user's Azure Active Directory Application used for a
   * federated connection.
   */
  federatedApplicationClientId: string;
  /**
   * Output only. A unique Google-owned and Google-generated identity for the
   * Connection. This identity will be used to access the user's Azure Active
   * Directory Application.
   */
  identity: string;
}

/**
 * Container for connection properties for delegation of access to GCP
 * resources.
 */
export interface CloudResourceProperties {
  /**
   * Output only. The account ID of the service created for the purpose of this
   * connection.
   *
   * The service account does not have any permissions associated with it
   * when it is created. After creation, customers delegate permissions
   * to the service account. When the connection is used in the context of an
   * operation in BigQuery, the service account will be used to connect to the
   * desired resources in GCP.
   *
   * The account ID is in the form of:
   *   <service-1234>@gcp-sa-bigquery-cloudresource.iam.gserviceaccount.com
   */
  serviceAccountId: string;
}

/** Configuration of the Dataproc Metastore Service. */
export interface MetastoreServiceConfig {
  /**
   * Optional. Resource name of an existing Dataproc Metastore service.
   *
   * Example:
   *
   * * `projects/[project_id]/locations/[region]/services/[service_id]`
   */
  metastoreService: string;
}

/** Configuration of the Spark History Server. */
export interface SparkHistoryServerConfig {
  /**
   * Optional. Resource name of an existing Dataproc Cluster to act as a Spark
   * History Server for the connection.
   *
   * Example:
   *
   * * `projects/[project_id]/regions/[region]/clusters/[cluster_name]`
   */
  dataprocCluster: string;
}

/**
 * Container for connection properties to execute stored procedures for Apache
 * Spark.
 */
export interface SparkProperties {
  /**
   * Output only. The account ID of the service created for the purpose of this
   * connection.
   *
   * The service account does not have any permissions associated with it when
   * it is created. After creation, customers delegate permissions to the
   * service account. When the connection is used in the context of a stored
   * procedure for Apache Spark in BigQuery, the service account is used to
   * connect to the desired resources in Google Cloud.
   *
   * The account ID is in the form of:
   * bqcx-<projectnumber>-<uniqueid>@gcp-sa-bigquery-consp.iam.gserviceaccount.com
   */
  serviceAccountId: string;
  /** Optional. Dataproc Metastore Service configuration for the connection. */
  metastoreServiceConfig:
    | MetastoreServiceConfig
    | undefined;
  /** Optional. Spark History Server configuration for the connection. */
  sparkHistoryServerConfig: SparkHistoryServerConfig | undefined;
}

/**
 * Connection properties specific to Salesforce DataCloud. This is intended for
 * use only by Salesforce partner projects.
 */
export interface SalesforceDataCloudProperties {
  /** The URL to the user's Salesforce DataCloud instance. */
  instanceUri: string;
  /**
   * Output only. A unique Google-owned and Google-generated service account
   * identity for the connection.
   */
  identity: string;
  /** The ID of the user's Salesforce tenant. */
  tenantId: string;
}

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { parent: "", connectionId: "", connection: undefined };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.parent = object.parent ?? "";
    message.connectionId = object.connectionId ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseGetConnectionRequest(): GetConnectionRequest {
  return { name: "" };
}

export const GetConnectionRequest: MessageFns<GetConnectionRequest> = {
  encode(message: GetConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    return GetConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    const message = createBaseGetConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { nextPageToken: "", connections: [] };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextPageToken !== "") {
      writer.uint32(10).string(message.nextPageToken);
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.nextPageToken = object.nextPageToken ?? "";
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateConnectionRequest(): UpdateConnectionRequest {
  return { name: "", connection: undefined, updateMask: undefined };
}

export const UpdateConnectionRequest: MessageFns<UpdateConnectionRequest> = {
  encode(message: UpdateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    return UpdateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    const message = createBaseUpdateConnectionRequest();
    message.name = object.name ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { name: "" };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseConnection(): Connection {
  return {
    name: "",
    friendlyName: "",
    description: "",
    cloudSql: undefined,
    aws: undefined,
    azure: undefined,
    cloudSpanner: undefined,
    cloudResource: undefined,
    spark: undefined,
    salesforceDataCloud: undefined,
    creationTime: Long.ZERO,
    lastModifiedTime: Long.ZERO,
    hasCredential: false,
  };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.friendlyName !== "") {
      writer.uint32(18).string(message.friendlyName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.cloudSql !== undefined) {
      CloudSqlProperties.encode(message.cloudSql, writer.uint32(34).fork()).join();
    }
    if (message.aws !== undefined) {
      AwsProperties.encode(message.aws, writer.uint32(66).fork()).join();
    }
    if (message.azure !== undefined) {
      AzureProperties.encode(message.azure, writer.uint32(90).fork()).join();
    }
    if (message.cloudSpanner !== undefined) {
      CloudSpannerProperties.encode(message.cloudSpanner, writer.uint32(170).fork()).join();
    }
    if (message.cloudResource !== undefined) {
      CloudResourceProperties.encode(message.cloudResource, writer.uint32(178).fork()).join();
    }
    if (message.spark !== undefined) {
      SparkProperties.encode(message.spark, writer.uint32(186).fork()).join();
    }
    if (message.salesforceDataCloud !== undefined) {
      SalesforceDataCloudProperties.encode(message.salesforceDataCloud, writer.uint32(194).fork()).join();
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.creationTime.toString());
    }
    if (!message.lastModifiedTime.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastModifiedTime.toString());
    }
    if (message.hasCredential !== false) {
      writer.uint32(56).bool(message.hasCredential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.friendlyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudSql = CloudSqlProperties.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.aws = AwsProperties.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.azure = AzureProperties.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.cloudSpanner = CloudSpannerProperties.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.cloudResource = CloudResourceProperties.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.spark = SparkProperties.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.salesforceDataCloud = SalesforceDataCloudProperties.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.creationTime = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lastModifiedTime = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hasCredential = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      friendlyName: isSet(object.friendlyName) ? globalThis.String(object.friendlyName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      cloudSql: isSet(object.cloudSql) ? CloudSqlProperties.fromJSON(object.cloudSql) : undefined,
      aws: isSet(object.aws) ? AwsProperties.fromJSON(object.aws) : undefined,
      azure: isSet(object.azure) ? AzureProperties.fromJSON(object.azure) : undefined,
      cloudSpanner: isSet(object.cloudSpanner) ? CloudSpannerProperties.fromJSON(object.cloudSpanner) : undefined,
      cloudResource: isSet(object.cloudResource) ? CloudResourceProperties.fromJSON(object.cloudResource) : undefined,
      spark: isSet(object.spark) ? SparkProperties.fromJSON(object.spark) : undefined,
      salesforceDataCloud: isSet(object.salesforceDataCloud)
        ? SalesforceDataCloudProperties.fromJSON(object.salesforceDataCloud)
        : undefined,
      creationTime: isSet(object.creationTime) ? Long.fromValue(object.creationTime) : Long.ZERO,
      lastModifiedTime: isSet(object.lastModifiedTime) ? Long.fromValue(object.lastModifiedTime) : Long.ZERO,
      hasCredential: isSet(object.hasCredential) ? globalThis.Boolean(object.hasCredential) : false,
    };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.friendlyName !== "") {
      obj.friendlyName = message.friendlyName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.cloudSql !== undefined) {
      obj.cloudSql = CloudSqlProperties.toJSON(message.cloudSql);
    }
    if (message.aws !== undefined) {
      obj.aws = AwsProperties.toJSON(message.aws);
    }
    if (message.azure !== undefined) {
      obj.azure = AzureProperties.toJSON(message.azure);
    }
    if (message.cloudSpanner !== undefined) {
      obj.cloudSpanner = CloudSpannerProperties.toJSON(message.cloudSpanner);
    }
    if (message.cloudResource !== undefined) {
      obj.cloudResource = CloudResourceProperties.toJSON(message.cloudResource);
    }
    if (message.spark !== undefined) {
      obj.spark = SparkProperties.toJSON(message.spark);
    }
    if (message.salesforceDataCloud !== undefined) {
      obj.salesforceDataCloud = SalesforceDataCloudProperties.toJSON(message.salesforceDataCloud);
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      obj.creationTime = (message.creationTime || Long.ZERO).toString();
    }
    if (!message.lastModifiedTime.equals(Long.ZERO)) {
      obj.lastModifiedTime = (message.lastModifiedTime || Long.ZERO).toString();
    }
    if (message.hasCredential !== false) {
      obj.hasCredential = message.hasCredential;
    }
    return obj;
  },

  create(base?: DeepPartial<Connection>): Connection {
    return Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection>): Connection {
    const message = createBaseConnection();
    message.name = object.name ?? "";
    message.friendlyName = object.friendlyName ?? "";
    message.description = object.description ?? "";
    message.cloudSql = (object.cloudSql !== undefined && object.cloudSql !== null)
      ? CloudSqlProperties.fromPartial(object.cloudSql)
      : undefined;
    message.aws = (object.aws !== undefined && object.aws !== null) ? AwsProperties.fromPartial(object.aws) : undefined;
    message.azure = (object.azure !== undefined && object.azure !== null)
      ? AzureProperties.fromPartial(object.azure)
      : undefined;
    message.cloudSpanner = (object.cloudSpanner !== undefined && object.cloudSpanner !== null)
      ? CloudSpannerProperties.fromPartial(object.cloudSpanner)
      : undefined;
    message.cloudResource = (object.cloudResource !== undefined && object.cloudResource !== null)
      ? CloudResourceProperties.fromPartial(object.cloudResource)
      : undefined;
    message.spark = (object.spark !== undefined && object.spark !== null)
      ? SparkProperties.fromPartial(object.spark)
      : undefined;
    message.salesforceDataCloud = (object.salesforceDataCloud !== undefined && object.salesforceDataCloud !== null)
      ? SalesforceDataCloudProperties.fromPartial(object.salesforceDataCloud)
      : undefined;
    message.creationTime = (object.creationTime !== undefined && object.creationTime !== null)
      ? Long.fromValue(object.creationTime)
      : Long.ZERO;
    message.lastModifiedTime = (object.lastModifiedTime !== undefined && object.lastModifiedTime !== null)
      ? Long.fromValue(object.lastModifiedTime)
      : Long.ZERO;
    message.hasCredential = object.hasCredential ?? false;
    return message;
  },
};

function createBaseCloudSqlProperties(): CloudSqlProperties {
  return { instanceId: "", database: "", type: 0, credential: undefined, serviceAccountId: "" };
}

export const CloudSqlProperties: MessageFns<CloudSqlProperties> = {
  encode(message: CloudSqlProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.credential !== undefined) {
      CloudSqlCredential.encode(message.credential, writer.uint32(34).fork()).join();
    }
    if (message.serviceAccountId !== "") {
      writer.uint32(42).string(message.serviceAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.credential = CloudSqlCredential.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlProperties {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      type: isSet(object.type) ? cloudSqlProperties_DatabaseTypeFromJSON(object.type) : 0,
      credential: isSet(object.credential) ? CloudSqlCredential.fromJSON(object.credential) : undefined,
      serviceAccountId: isSet(object.serviceAccountId) ? globalThis.String(object.serviceAccountId) : "",
    };
  },

  toJSON(message: CloudSqlProperties): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.type !== 0) {
      obj.type = cloudSqlProperties_DatabaseTypeToJSON(message.type);
    }
    if (message.credential !== undefined) {
      obj.credential = CloudSqlCredential.toJSON(message.credential);
    }
    if (message.serviceAccountId !== "") {
      obj.serviceAccountId = message.serviceAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlProperties>): CloudSqlProperties {
    return CloudSqlProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlProperties>): CloudSqlProperties {
    const message = createBaseCloudSqlProperties();
    message.instanceId = object.instanceId ?? "";
    message.database = object.database ?? "";
    message.type = object.type ?? 0;
    message.credential = (object.credential !== undefined && object.credential !== null)
      ? CloudSqlCredential.fromPartial(object.credential)
      : undefined;
    message.serviceAccountId = object.serviceAccountId ?? "";
    return message;
  },
};

function createBaseCloudSqlCredential(): CloudSqlCredential {
  return { username: "", password: "" };
}

export const CloudSqlCredential: MessageFns<CloudSqlCredential> = {
  encode(message: CloudSqlCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlCredential {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: CloudSqlCredential): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlCredential>): CloudSqlCredential {
    return CloudSqlCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlCredential>): CloudSqlCredential {
    const message = createBaseCloudSqlCredential();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseCloudSpannerProperties(): CloudSpannerProperties {
  return {
    database: "",
    useParallelism: false,
    maxParallelism: 0,
    useServerlessAnalytics: false,
    useDataBoost: false,
    databaseRole: "",
  };
}

export const CloudSpannerProperties: MessageFns<CloudSpannerProperties> = {
  encode(message: CloudSpannerProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== "") {
      writer.uint32(10).string(message.database);
    }
    if (message.useParallelism !== false) {
      writer.uint32(16).bool(message.useParallelism);
    }
    if (message.maxParallelism !== 0) {
      writer.uint32(40).int32(message.maxParallelism);
    }
    if (message.useServerlessAnalytics !== false) {
      writer.uint32(24).bool(message.useServerlessAnalytics);
    }
    if (message.useDataBoost !== false) {
      writer.uint32(48).bool(message.useDataBoost);
    }
    if (message.databaseRole !== "") {
      writer.uint32(34).string(message.databaseRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSpannerProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSpannerProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.database = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.useParallelism = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxParallelism = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.useServerlessAnalytics = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.useDataBoost = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.databaseRole = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSpannerProperties {
    return {
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      useParallelism: isSet(object.useParallelism) ? globalThis.Boolean(object.useParallelism) : false,
      maxParallelism: isSet(object.maxParallelism) ? globalThis.Number(object.maxParallelism) : 0,
      useServerlessAnalytics: isSet(object.useServerlessAnalytics)
        ? globalThis.Boolean(object.useServerlessAnalytics)
        : false,
      useDataBoost: isSet(object.useDataBoost) ? globalThis.Boolean(object.useDataBoost) : false,
      databaseRole: isSet(object.databaseRole) ? globalThis.String(object.databaseRole) : "",
    };
  },

  toJSON(message: CloudSpannerProperties): unknown {
    const obj: any = {};
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.useParallelism !== false) {
      obj.useParallelism = message.useParallelism;
    }
    if (message.maxParallelism !== 0) {
      obj.maxParallelism = Math.round(message.maxParallelism);
    }
    if (message.useServerlessAnalytics !== false) {
      obj.useServerlessAnalytics = message.useServerlessAnalytics;
    }
    if (message.useDataBoost !== false) {
      obj.useDataBoost = message.useDataBoost;
    }
    if (message.databaseRole !== "") {
      obj.databaseRole = message.databaseRole;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSpannerProperties>): CloudSpannerProperties {
    return CloudSpannerProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSpannerProperties>): CloudSpannerProperties {
    const message = createBaseCloudSpannerProperties();
    message.database = object.database ?? "";
    message.useParallelism = object.useParallelism ?? false;
    message.maxParallelism = object.maxParallelism ?? 0;
    message.useServerlessAnalytics = object.useServerlessAnalytics ?? false;
    message.useDataBoost = object.useDataBoost ?? false;
    message.databaseRole = object.databaseRole ?? "";
    return message;
  },
};

function createBaseAwsProperties(): AwsProperties {
  return { crossAccountRole: undefined, accessRole: undefined };
}

export const AwsProperties: MessageFns<AwsProperties> = {
  encode(message: AwsProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crossAccountRole !== undefined) {
      AwsCrossAccountRole.encode(message.crossAccountRole, writer.uint32(18).fork()).join();
    }
    if (message.accessRole !== undefined) {
      AwsAccessRole.encode(message.accessRole, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crossAccountRole = AwsCrossAccountRole.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessRole = AwsAccessRole.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsProperties {
    return {
      crossAccountRole: isSet(object.crossAccountRole)
        ? AwsCrossAccountRole.fromJSON(object.crossAccountRole)
        : undefined,
      accessRole: isSet(object.accessRole) ? AwsAccessRole.fromJSON(object.accessRole) : undefined,
    };
  },

  toJSON(message: AwsProperties): unknown {
    const obj: any = {};
    if (message.crossAccountRole !== undefined) {
      obj.crossAccountRole = AwsCrossAccountRole.toJSON(message.crossAccountRole);
    }
    if (message.accessRole !== undefined) {
      obj.accessRole = AwsAccessRole.toJSON(message.accessRole);
    }
    return obj;
  },

  create(base?: DeepPartial<AwsProperties>): AwsProperties {
    return AwsProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsProperties>): AwsProperties {
    const message = createBaseAwsProperties();
    message.crossAccountRole = (object.crossAccountRole !== undefined && object.crossAccountRole !== null)
      ? AwsCrossAccountRole.fromPartial(object.crossAccountRole)
      : undefined;
    message.accessRole = (object.accessRole !== undefined && object.accessRole !== null)
      ? AwsAccessRole.fromPartial(object.accessRole)
      : undefined;
    return message;
  },
};

function createBaseAwsCrossAccountRole(): AwsCrossAccountRole {
  return { iamRoleId: "", iamUserId: "", externalId: "" };
}

export const AwsCrossAccountRole: MessageFns<AwsCrossAccountRole> = {
  encode(message: AwsCrossAccountRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iamRoleId !== "") {
      writer.uint32(10).string(message.iamRoleId);
    }
    if (message.iamUserId !== "") {
      writer.uint32(18).string(message.iamUserId);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsCrossAccountRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsCrossAccountRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iamRoleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iamUserId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsCrossAccountRole {
    return {
      iamRoleId: isSet(object.iamRoleId) ? globalThis.String(object.iamRoleId) : "",
      iamUserId: isSet(object.iamUserId) ? globalThis.String(object.iamUserId) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: AwsCrossAccountRole): unknown {
    const obj: any = {};
    if (message.iamRoleId !== "") {
      obj.iamRoleId = message.iamRoleId;
    }
    if (message.iamUserId !== "") {
      obj.iamUserId = message.iamUserId;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsCrossAccountRole>): AwsCrossAccountRole {
    return AwsCrossAccountRole.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsCrossAccountRole>): AwsCrossAccountRole {
    const message = createBaseAwsCrossAccountRole();
    message.iamRoleId = object.iamRoleId ?? "";
    message.iamUserId = object.iamUserId ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseAwsAccessRole(): AwsAccessRole {
  return { iamRoleId: "", identity: "" };
}

export const AwsAccessRole: MessageFns<AwsAccessRole> = {
  encode(message: AwsAccessRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iamRoleId !== "") {
      writer.uint32(10).string(message.iamRoleId);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsAccessRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsAccessRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iamRoleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsAccessRole {
    return {
      iamRoleId: isSet(object.iamRoleId) ? globalThis.String(object.iamRoleId) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
    };
  },

  toJSON(message: AwsAccessRole): unknown {
    const obj: any = {};
    if (message.iamRoleId !== "") {
      obj.iamRoleId = message.iamRoleId;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsAccessRole>): AwsAccessRole {
    return AwsAccessRole.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsAccessRole>): AwsAccessRole {
    const message = createBaseAwsAccessRole();
    message.iamRoleId = object.iamRoleId ?? "";
    message.identity = object.identity ?? "";
    return message;
  },
};

function createBaseAzureProperties(): AzureProperties {
  return {
    application: "",
    clientId: "",
    objectId: "",
    customerTenantId: "",
    redirectUri: "",
    federatedApplicationClientId: "",
    identity: "",
  };
}

export const AzureProperties: MessageFns<AzureProperties> = {
  encode(message: AzureProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== "") {
      writer.uint32(10).string(message.application);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.objectId !== "") {
      writer.uint32(26).string(message.objectId);
    }
    if (message.customerTenantId !== "") {
      writer.uint32(34).string(message.customerTenantId);
    }
    if (message.redirectUri !== "") {
      writer.uint32(42).string(message.redirectUri);
    }
    if (message.federatedApplicationClientId !== "") {
      writer.uint32(50).string(message.federatedApplicationClientId);
    }
    if (message.identity !== "") {
      writer.uint32(58).string(message.identity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AzureProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAzureProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.application = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.objectId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerTenantId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.federatedApplicationClientId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.identity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AzureProperties {
    return {
      application: isSet(object.application) ? globalThis.String(object.application) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      customerTenantId: isSet(object.customerTenantId) ? globalThis.String(object.customerTenantId) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
      federatedApplicationClientId: isSet(object.federatedApplicationClientId)
        ? globalThis.String(object.federatedApplicationClientId)
        : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
    };
  },

  toJSON(message: AzureProperties): unknown {
    const obj: any = {};
    if (message.application !== "") {
      obj.application = message.application;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.customerTenantId !== "") {
      obj.customerTenantId = message.customerTenantId;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.federatedApplicationClientId !== "") {
      obj.federatedApplicationClientId = message.federatedApplicationClientId;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    return obj;
  },

  create(base?: DeepPartial<AzureProperties>): AzureProperties {
    return AzureProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AzureProperties>): AzureProperties {
    const message = createBaseAzureProperties();
    message.application = object.application ?? "";
    message.clientId = object.clientId ?? "";
    message.objectId = object.objectId ?? "";
    message.customerTenantId = object.customerTenantId ?? "";
    message.redirectUri = object.redirectUri ?? "";
    message.federatedApplicationClientId = object.federatedApplicationClientId ?? "";
    message.identity = object.identity ?? "";
    return message;
  },
};

function createBaseCloudResourceProperties(): CloudResourceProperties {
  return { serviceAccountId: "" };
}

export const CloudResourceProperties: MessageFns<CloudResourceProperties> = {
  encode(message: CloudResourceProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountId !== "") {
      writer.uint32(10).string(message.serviceAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudResourceProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudResourceProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudResourceProperties {
    return { serviceAccountId: isSet(object.serviceAccountId) ? globalThis.String(object.serviceAccountId) : "" };
  },

  toJSON(message: CloudResourceProperties): unknown {
    const obj: any = {};
    if (message.serviceAccountId !== "") {
      obj.serviceAccountId = message.serviceAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudResourceProperties>): CloudResourceProperties {
    return CloudResourceProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudResourceProperties>): CloudResourceProperties {
    const message = createBaseCloudResourceProperties();
    message.serviceAccountId = object.serviceAccountId ?? "";
    return message;
  },
};

function createBaseMetastoreServiceConfig(): MetastoreServiceConfig {
  return { metastoreService: "" };
}

export const MetastoreServiceConfig: MessageFns<MetastoreServiceConfig> = {
  encode(message: MetastoreServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metastoreService !== "") {
      writer.uint32(10).string(message.metastoreService);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetastoreServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetastoreServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metastoreService = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetastoreServiceConfig {
    return { metastoreService: isSet(object.metastoreService) ? globalThis.String(object.metastoreService) : "" };
  },

  toJSON(message: MetastoreServiceConfig): unknown {
    const obj: any = {};
    if (message.metastoreService !== "") {
      obj.metastoreService = message.metastoreService;
    }
    return obj;
  },

  create(base?: DeepPartial<MetastoreServiceConfig>): MetastoreServiceConfig {
    return MetastoreServiceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetastoreServiceConfig>): MetastoreServiceConfig {
    const message = createBaseMetastoreServiceConfig();
    message.metastoreService = object.metastoreService ?? "";
    return message;
  },
};

function createBaseSparkHistoryServerConfig(): SparkHistoryServerConfig {
  return { dataprocCluster: "" };
}

export const SparkHistoryServerConfig: MessageFns<SparkHistoryServerConfig> = {
  encode(message: SparkHistoryServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataprocCluster !== "") {
      writer.uint32(10).string(message.dataprocCluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkHistoryServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkHistoryServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataprocCluster = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparkHistoryServerConfig {
    return { dataprocCluster: isSet(object.dataprocCluster) ? globalThis.String(object.dataprocCluster) : "" };
  },

  toJSON(message: SparkHistoryServerConfig): unknown {
    const obj: any = {};
    if (message.dataprocCluster !== "") {
      obj.dataprocCluster = message.dataprocCluster;
    }
    return obj;
  },

  create(base?: DeepPartial<SparkHistoryServerConfig>): SparkHistoryServerConfig {
    return SparkHistoryServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparkHistoryServerConfig>): SparkHistoryServerConfig {
    const message = createBaseSparkHistoryServerConfig();
    message.dataprocCluster = object.dataprocCluster ?? "";
    return message;
  },
};

function createBaseSparkProperties(): SparkProperties {
  return { serviceAccountId: "", metastoreServiceConfig: undefined, sparkHistoryServerConfig: undefined };
}

export const SparkProperties: MessageFns<SparkProperties> = {
  encode(message: SparkProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountId !== "") {
      writer.uint32(10).string(message.serviceAccountId);
    }
    if (message.metastoreServiceConfig !== undefined) {
      MetastoreServiceConfig.encode(message.metastoreServiceConfig, writer.uint32(26).fork()).join();
    }
    if (message.sparkHistoryServerConfig !== undefined) {
      SparkHistoryServerConfig.encode(message.sparkHistoryServerConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metastoreServiceConfig = MetastoreServiceConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sparkHistoryServerConfig = SparkHistoryServerConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparkProperties {
    return {
      serviceAccountId: isSet(object.serviceAccountId) ? globalThis.String(object.serviceAccountId) : "",
      metastoreServiceConfig: isSet(object.metastoreServiceConfig)
        ? MetastoreServiceConfig.fromJSON(object.metastoreServiceConfig)
        : undefined,
      sparkHistoryServerConfig: isSet(object.sparkHistoryServerConfig)
        ? SparkHistoryServerConfig.fromJSON(object.sparkHistoryServerConfig)
        : undefined,
    };
  },

  toJSON(message: SparkProperties): unknown {
    const obj: any = {};
    if (message.serviceAccountId !== "") {
      obj.serviceAccountId = message.serviceAccountId;
    }
    if (message.metastoreServiceConfig !== undefined) {
      obj.metastoreServiceConfig = MetastoreServiceConfig.toJSON(message.metastoreServiceConfig);
    }
    if (message.sparkHistoryServerConfig !== undefined) {
      obj.sparkHistoryServerConfig = SparkHistoryServerConfig.toJSON(message.sparkHistoryServerConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SparkProperties>): SparkProperties {
    return SparkProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparkProperties>): SparkProperties {
    const message = createBaseSparkProperties();
    message.serviceAccountId = object.serviceAccountId ?? "";
    message.metastoreServiceConfig =
      (object.metastoreServiceConfig !== undefined && object.metastoreServiceConfig !== null)
        ? MetastoreServiceConfig.fromPartial(object.metastoreServiceConfig)
        : undefined;
    message.sparkHistoryServerConfig =
      (object.sparkHistoryServerConfig !== undefined && object.sparkHistoryServerConfig !== null)
        ? SparkHistoryServerConfig.fromPartial(object.sparkHistoryServerConfig)
        : undefined;
    return message;
  },
};

function createBaseSalesforceDataCloudProperties(): SalesforceDataCloudProperties {
  return { instanceUri: "", identity: "", tenantId: "" };
}

export const SalesforceDataCloudProperties: MessageFns<SalesforceDataCloudProperties> = {
  encode(message: SalesforceDataCloudProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceUri !== "") {
      writer.uint32(10).string(message.instanceUri);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.tenantId !== "") {
      writer.uint32(26).string(message.tenantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SalesforceDataCloudProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSalesforceDataCloudProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tenantId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SalesforceDataCloudProperties {
    return {
      instanceUri: isSet(object.instanceUri) ? globalThis.String(object.instanceUri) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
    };
  },

  toJSON(message: SalesforceDataCloudProperties): unknown {
    const obj: any = {};
    if (message.instanceUri !== "") {
      obj.instanceUri = message.instanceUri;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    return obj;
  },

  create(base?: DeepPartial<SalesforceDataCloudProperties>): SalesforceDataCloudProperties {
    return SalesforceDataCloudProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SalesforceDataCloudProperties>): SalesforceDataCloudProperties {
    const message = createBaseSalesforceDataCloudProperties();
    message.instanceUri = object.instanceUri ?? "";
    message.identity = object.identity ?? "";
    message.tenantId = object.tenantId ?? "";
    return message;
  },
};

/** Manages external data source connections and credentials. */
export type ConnectionServiceDefinition = typeof ConnectionServiceDefinition;
export const ConnectionServiceDefinition = {
  name: "ConnectionService",
  fullName: "google.cloud.bigquery.connection.v1.ConnectionService",
  methods: {
    /** Creates a new connection. */
    createConnection: {
      name: "CreateConnection",
      requestType: CreateConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns specified connection. */
    getConnection: {
      name: "GetConnection",
      requestType: GetConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a list of connections in the given project. */
    listConnections: {
      name: "ListConnections",
      requestType: ListConnectionsRequest,
      requestStream: false,
      responseType: ListConnectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified connection. For security reasons, also resets
     * credential if connection properties are in the update field mask.
     */
    updateConnection: {
      name: "UpdateConnection",
      requestType: UpdateConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              27,
              110,
              97,
              109,
              101,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes connection and associated credential. */
    deleteConnection: {
      name: "DeleteConnection",
      requestType: DeleteConnectionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for a resource.
     * Returns an empty policy if the resource exists and does not have a policy
     * set.
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 114, 101, 115, 111, 117, 114, 99, 101, 44, 111, 112, 116, 105, 111, 110, 115])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on the specified resource. Replaces any
     * existing policy.
     *
     * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the specified resource.
     * If the resource does not exist, this will return an empty set of
     * permissions, not a `NOT_FOUND` error.
     *
     * Note: This operation is designed to be used for building permission-aware
     * UIs and command-line tools, not for authorization checking. This operation
     * may "fail open" without warning.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConnectionServiceImplementation<CallContextExt = {}> {
  /** Creates a new connection. */
  createConnection(
    request: CreateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Connection>>;
  /** Returns specified connection. */
  getConnection(request: GetConnectionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Connection>>;
  /** Returns a list of connections in the given project. */
  listConnections(
    request: ListConnectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConnectionsResponse>>;
  /**
   * Updates the specified connection. For security reasons, also resets
   * credential if connection properties are in the update field mask.
   */
  updateConnection(
    request: UpdateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Connection>>;
  /** Deletes connection and associated credential. */
  deleteConnection(
    request: DeleteConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Gets the access control policy for a resource.
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * If the resource does not exist, this will return an empty set of
   * permissions, not a `NOT_FOUND` error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface ConnectionServiceClient<CallOptionsExt = {}> {
  /** Creates a new connection. */
  createConnection(
    request: DeepPartial<CreateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Returns specified connection. */
  getConnection(
    request: DeepPartial<GetConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Returns a list of connections in the given project. */
  listConnections(
    request: DeepPartial<ListConnectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConnectionsResponse>;
  /**
   * Updates the specified connection. For security reasons, also resets
   * credential if connection properties are in the update field mask.
   */
  updateConnection(
    request: DeepPartial<UpdateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Deletes connection and associated credential. */
  deleteConnection(
    request: DeepPartial<DeleteConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Gets the access control policy for a resource.
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * If the resource does not exist, this will return an empty set of
   * permissions, not a `NOT_FOUND` error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
