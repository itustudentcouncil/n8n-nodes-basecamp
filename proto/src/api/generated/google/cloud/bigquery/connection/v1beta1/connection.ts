// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/connection/v1beta1/connection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../../iam/v1/iam_policy.js";
import { Policy } from "../../../../iam/v1/policy.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { UInt32Value } from "../../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.bigquery.connection.v1beta1";

/**
 * The request for
 * [ConnectionService.CreateConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.CreateConnection].
 */
export interface CreateConnectionRequest {
  /**
   * Required. Parent resource name.
   * Must be in the format `projects/{project_id}/locations/{location_id}`
   */
  parent: string;
  /** Optional. Connection id that should be assigned to the created connection. */
  connectionId: string;
  /** Required. Connection to create. */
  connection: Connection | undefined;
}

/**
 * The request for
 * [ConnectionService.GetConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.GetConnection].
 */
export interface GetConnectionRequest {
  /**
   * Required. Name of the requested connection, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
}

/**
 * The request for
 * [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1beta1.ConnectionService.ListConnections].
 */
export interface ListConnectionsRequest {
  /**
   * Required. Parent resource name.
   * Must be in the form: `projects/{project_id}/locations/{location_id}`
   */
  parent: string;
  /** Required. Maximum number of results per page. */
  maxResults:
    | number
    | undefined;
  /** Page token. */
  pageToken: string;
}

/**
 * The response for
 * [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1beta1.ConnectionService.ListConnections].
 */
export interface ListConnectionsResponse {
  /** Next page token. */
  nextPageToken: string;
  /** List of connections. */
  connections: Connection[];
}

/**
 * The request for
 * [ConnectionService.UpdateConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.UpdateConnection].
 */
export interface UpdateConnectionRequest {
  /**
   * Required. Name of the connection to update, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
  /** Required. Connection containing the updated fields. */
  connection:
    | Connection
    | undefined;
  /** Required. Update mask for the connection fields to be updated. */
  updateMask: string[] | undefined;
}

/**
 * The request for
 * [ConnectionService.UpdateConnectionCredential][google.cloud.bigquery.connection.v1beta1.ConnectionService.UpdateConnectionCredential].
 */
export interface UpdateConnectionCredentialRequest {
  /**
   * Required. Name of the connection, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}/credential`
   */
  name: string;
  /** Required. Credential to use with the connection. */
  credential: ConnectionCredential | undefined;
}

/** The request for [ConnectionService.DeleteConnectionRequest][]. */
export interface DeleteConnectionRequest {
  /**
   * Required. Name of the deleted connection, for example:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
}

/**
 * Configuration parameters to establish connection with an external data
 * source, except the credential attributes.
 */
export interface Connection {
  /**
   * The resource name of the connection in the form of:
   * `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
   */
  name: string;
  /** User provided display name for the connection. */
  friendlyName: string;
  /** User provided description. */
  description: string;
  /** Cloud SQL properties. */
  cloudSql?:
    | CloudSqlProperties
    | undefined;
  /** Output only. The creation timestamp of the connection. */
  creationTime: Long;
  /** Output only. The last update timestamp of the connection. */
  lastModifiedTime: Long;
  /** Output only. True, if credential is configured for this connection. */
  hasCredential: boolean;
}

/** Credential to use with a connection. */
export interface ConnectionCredential {
  /** Credential for Cloud SQL database. */
  cloudSql?: CloudSqlCredential | undefined;
}

/** Connection properties specific to the Cloud SQL. */
export interface CloudSqlProperties {
  /** Cloud SQL instance ID in the form `project:location:instance`. */
  instanceId: string;
  /** Database name. */
  database: string;
  /** Type of the Cloud SQL database. */
  type: CloudSqlProperties_DatabaseType;
  /** Input only. Cloud SQL credential. */
  credential:
    | CloudSqlCredential
    | undefined;
  /**
   * Output only. The account ID of the service used for the purpose of this
   * connection.
   *
   * When the connection is used in the context of an operation in
   * BigQuery, this service account will serve as the identity being used for
   * connecting to the CloudSQL instance specified in this connection.
   */
  serviceAccountId: string;
}

/** Supported Cloud SQL database types. */
export enum CloudSqlProperties_DatabaseType {
  /** DATABASE_TYPE_UNSPECIFIED - Unspecified database type. */
  DATABASE_TYPE_UNSPECIFIED = 0,
  /** POSTGRES - Cloud SQL for PostgreSQL. */
  POSTGRES = 1,
  /** MYSQL - Cloud SQL for MySQL. */
  MYSQL = 2,
  UNRECOGNIZED = -1,
}

export function cloudSqlProperties_DatabaseTypeFromJSON(object: any): CloudSqlProperties_DatabaseType {
  switch (object) {
    case 0:
    case "DATABASE_TYPE_UNSPECIFIED":
      return CloudSqlProperties_DatabaseType.DATABASE_TYPE_UNSPECIFIED;
    case 1:
    case "POSTGRES":
      return CloudSqlProperties_DatabaseType.POSTGRES;
    case 2:
    case "MYSQL":
      return CloudSqlProperties_DatabaseType.MYSQL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudSqlProperties_DatabaseType.UNRECOGNIZED;
  }
}

export function cloudSqlProperties_DatabaseTypeToJSON(object: CloudSqlProperties_DatabaseType): string {
  switch (object) {
    case CloudSqlProperties_DatabaseType.DATABASE_TYPE_UNSPECIFIED:
      return "DATABASE_TYPE_UNSPECIFIED";
    case CloudSqlProperties_DatabaseType.POSTGRES:
      return "POSTGRES";
    case CloudSqlProperties_DatabaseType.MYSQL:
      return "MYSQL";
    case CloudSqlProperties_DatabaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Credential info for the Cloud SQL. */
export interface CloudSqlCredential {
  /** The username for the credential. */
  username: string;
  /** The password for the credential. */
  password: string;
}

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { parent: "", connectionId: "", connection: undefined };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.parent = object.parent ?? "";
    message.connectionId = object.connectionId ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseGetConnectionRequest(): GetConnectionRequest {
  return { name: "" };
}

export const GetConnectionRequest: MessageFns<GetConnectionRequest> = {
  encode(message: GetConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    return GetConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    const message = createBaseGetConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { parent: "", maxResults: undefined, pageToken: "" };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.maxResults !== undefined) {
      UInt32Value.encode({ value: message.maxResults! }, writer.uint32(18).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxResults = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      maxResults: isSet(object.maxResults) ? Number(object.maxResults) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.maxResults !== undefined) {
      obj.maxResults = message.maxResults;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.parent = object.parent ?? "";
    message.maxResults = object.maxResults ?? undefined;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { nextPageToken: "", connections: [] };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextPageToken !== "") {
      writer.uint32(10).string(message.nextPageToken);
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.nextPageToken = object.nextPageToken ?? "";
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateConnectionRequest(): UpdateConnectionRequest {
  return { name: "", connection: undefined, updateMask: undefined };
}

export const UpdateConnectionRequest: MessageFns<UpdateConnectionRequest> = {
  encode(message: UpdateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    return UpdateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    const message = createBaseUpdateConnectionRequest();
    message.name = object.name ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateConnectionCredentialRequest(): UpdateConnectionCredentialRequest {
  return { name: "", credential: undefined };
}

export const UpdateConnectionCredentialRequest: MessageFns<UpdateConnectionCredentialRequest> = {
  encode(message: UpdateConnectionCredentialRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.credential !== undefined) {
      ConnectionCredential.encode(message.credential, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionCredentialRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionCredentialRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.credential = ConnectionCredential.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionCredentialRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      credential: isSet(object.credential) ? ConnectionCredential.fromJSON(object.credential) : undefined,
    };
  },

  toJSON(message: UpdateConnectionCredentialRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.credential !== undefined) {
      obj.credential = ConnectionCredential.toJSON(message.credential);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionCredentialRequest>): UpdateConnectionCredentialRequest {
    return UpdateConnectionCredentialRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionCredentialRequest>): UpdateConnectionCredentialRequest {
    const message = createBaseUpdateConnectionCredentialRequest();
    message.name = object.name ?? "";
    message.credential = (object.credential !== undefined && object.credential !== null)
      ? ConnectionCredential.fromPartial(object.credential)
      : undefined;
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { name: "" };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseConnection(): Connection {
  return {
    name: "",
    friendlyName: "",
    description: "",
    cloudSql: undefined,
    creationTime: Long.ZERO,
    lastModifiedTime: Long.ZERO,
    hasCredential: false,
  };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.friendlyName !== "") {
      writer.uint32(18).string(message.friendlyName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.cloudSql !== undefined) {
      CloudSqlProperties.encode(message.cloudSql, writer.uint32(34).fork()).join();
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.creationTime.toString());
    }
    if (!message.lastModifiedTime.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastModifiedTime.toString());
    }
    if (message.hasCredential !== false) {
      writer.uint32(56).bool(message.hasCredential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.friendlyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudSql = CloudSqlProperties.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.creationTime = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lastModifiedTime = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hasCredential = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      friendlyName: isSet(object.friendlyName) ? globalThis.String(object.friendlyName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      cloudSql: isSet(object.cloudSql) ? CloudSqlProperties.fromJSON(object.cloudSql) : undefined,
      creationTime: isSet(object.creationTime) ? Long.fromValue(object.creationTime) : Long.ZERO,
      lastModifiedTime: isSet(object.lastModifiedTime) ? Long.fromValue(object.lastModifiedTime) : Long.ZERO,
      hasCredential: isSet(object.hasCredential) ? globalThis.Boolean(object.hasCredential) : false,
    };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.friendlyName !== "") {
      obj.friendlyName = message.friendlyName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.cloudSql !== undefined) {
      obj.cloudSql = CloudSqlProperties.toJSON(message.cloudSql);
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      obj.creationTime = (message.creationTime || Long.ZERO).toString();
    }
    if (!message.lastModifiedTime.equals(Long.ZERO)) {
      obj.lastModifiedTime = (message.lastModifiedTime || Long.ZERO).toString();
    }
    if (message.hasCredential !== false) {
      obj.hasCredential = message.hasCredential;
    }
    return obj;
  },

  create(base?: DeepPartial<Connection>): Connection {
    return Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection>): Connection {
    const message = createBaseConnection();
    message.name = object.name ?? "";
    message.friendlyName = object.friendlyName ?? "";
    message.description = object.description ?? "";
    message.cloudSql = (object.cloudSql !== undefined && object.cloudSql !== null)
      ? CloudSqlProperties.fromPartial(object.cloudSql)
      : undefined;
    message.creationTime = (object.creationTime !== undefined && object.creationTime !== null)
      ? Long.fromValue(object.creationTime)
      : Long.ZERO;
    message.lastModifiedTime = (object.lastModifiedTime !== undefined && object.lastModifiedTime !== null)
      ? Long.fromValue(object.lastModifiedTime)
      : Long.ZERO;
    message.hasCredential = object.hasCredential ?? false;
    return message;
  },
};

function createBaseConnectionCredential(): ConnectionCredential {
  return { cloudSql: undefined };
}

export const ConnectionCredential: MessageFns<ConnectionCredential> = {
  encode(message: ConnectionCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudSql !== undefined) {
      CloudSqlCredential.encode(message.cloudSql, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudSql = CloudSqlCredential.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionCredential {
    return { cloudSql: isSet(object.cloudSql) ? CloudSqlCredential.fromJSON(object.cloudSql) : undefined };
  },

  toJSON(message: ConnectionCredential): unknown {
    const obj: any = {};
    if (message.cloudSql !== undefined) {
      obj.cloudSql = CloudSqlCredential.toJSON(message.cloudSql);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionCredential>): ConnectionCredential {
    return ConnectionCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionCredential>): ConnectionCredential {
    const message = createBaseConnectionCredential();
    message.cloudSql = (object.cloudSql !== undefined && object.cloudSql !== null)
      ? CloudSqlCredential.fromPartial(object.cloudSql)
      : undefined;
    return message;
  },
};

function createBaseCloudSqlProperties(): CloudSqlProperties {
  return { instanceId: "", database: "", type: 0, credential: undefined, serviceAccountId: "" };
}

export const CloudSqlProperties: MessageFns<CloudSqlProperties> = {
  encode(message: CloudSqlProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.credential !== undefined) {
      CloudSqlCredential.encode(message.credential, writer.uint32(34).fork()).join();
    }
    if (message.serviceAccountId !== "") {
      writer.uint32(42).string(message.serviceAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.credential = CloudSqlCredential.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlProperties {
    return {
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      type: isSet(object.type) ? cloudSqlProperties_DatabaseTypeFromJSON(object.type) : 0,
      credential: isSet(object.credential) ? CloudSqlCredential.fromJSON(object.credential) : undefined,
      serviceAccountId: isSet(object.serviceAccountId) ? globalThis.String(object.serviceAccountId) : "",
    };
  },

  toJSON(message: CloudSqlProperties): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.type !== 0) {
      obj.type = cloudSqlProperties_DatabaseTypeToJSON(message.type);
    }
    if (message.credential !== undefined) {
      obj.credential = CloudSqlCredential.toJSON(message.credential);
    }
    if (message.serviceAccountId !== "") {
      obj.serviceAccountId = message.serviceAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlProperties>): CloudSqlProperties {
    return CloudSqlProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlProperties>): CloudSqlProperties {
    const message = createBaseCloudSqlProperties();
    message.instanceId = object.instanceId ?? "";
    message.database = object.database ?? "";
    message.type = object.type ?? 0;
    message.credential = (object.credential !== undefined && object.credential !== null)
      ? CloudSqlCredential.fromPartial(object.credential)
      : undefined;
    message.serviceAccountId = object.serviceAccountId ?? "";
    return message;
  },
};

function createBaseCloudSqlCredential(): CloudSqlCredential {
  return { username: "", password: "" };
}

export const CloudSqlCredential: MessageFns<CloudSqlCredential> = {
  encode(message: CloudSqlCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSqlCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSqlCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSqlCredential {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: CloudSqlCredential): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSqlCredential>): CloudSqlCredential {
    return CloudSqlCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSqlCredential>): CloudSqlCredential {
    const message = createBaseCloudSqlCredential();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

/** Manages external data source connections and credentials. */
export type ConnectionServiceDefinition = typeof ConnectionServiceDefinition;
export const ConnectionServiceDefinition = {
  name: "ConnectionService",
  fullName: "google.cloud.bigquery.connection.v1beta1.ConnectionService",
  methods: {
    /** Creates a new connection. */
    createConnection: {
      name: "CreateConnection",
      requestType: CreateConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns specified connection. */
    getConnection: {
      name: "GetConnection",
      requestType: GetConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a list of connections in the given project. */
    listConnections: {
      name: "ListConnections",
      requestType: ListConnectionsRequest,
      requestStream: false,
      responseType: ListConnectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 109, 97, 120, 95, 114, 101, 115, 117, 108, 116, 115]),
          ],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified connection. For security reasons, also resets
     * credential if connection properties are in the update field mask.
     */
    updateConnection: {
      name: "UpdateConnection",
      requestType: UpdateConnectionRequest,
      requestStream: false,
      responseType: Connection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              27,
              110,
              97,
              109,
              101,
              44,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              10,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Sets the credential for the specified connection. */
    updateConnectionCredential: {
      name: "UpdateConnectionCredential",
      requestType: UpdateConnectionCredentialRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 99, 114, 101, 100, 101, 110, 116, 105, 97, 108])],
          578365826: [
            Buffer.from([
              77,
              58,
              10,
              99,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              50,
              63,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes connection and associated credential. */
    deleteConnection: {
      name: "DeleteConnection",
      requestType: DeleteConnectionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for a resource.
     * Returns an empty policy if the resource exists and does not have a policy
     * set.
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 114, 101, 115, 111, 117, 114, 99, 101, 44, 111, 112, 116, 105, 111, 110, 115])],
          578365826: [
            Buffer.from([
              74,
              58,
              1,
              42,
              34,
              69,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on the specified resource. Replaces any
     * existing policy.
     *
     * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              74,
              58,
              1,
              42,
              34,
              69,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the specified resource.
     * If the resource does not exist, this will return an empty set of
     * permissions, not a `NOT_FOUND` error.
     *
     * Note: This operation is designed to be used for building permission-aware
     * UIs and command-line tools, not for authorization checking. This operation
     * may "fail open" without warning.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConnectionServiceImplementation<CallContextExt = {}> {
  /** Creates a new connection. */
  createConnection(
    request: CreateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Connection>>;
  /** Returns specified connection. */
  getConnection(request: GetConnectionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Connection>>;
  /** Returns a list of connections in the given project. */
  listConnections(
    request: ListConnectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConnectionsResponse>>;
  /**
   * Updates the specified connection. For security reasons, also resets
   * credential if connection properties are in the update field mask.
   */
  updateConnection(
    request: UpdateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Connection>>;
  /** Sets the credential for the specified connection. */
  updateConnectionCredential(
    request: UpdateConnectionCredentialRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Deletes connection and associated credential. */
  deleteConnection(
    request: DeleteConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Gets the access control policy for a resource.
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * If the resource does not exist, this will return an empty set of
   * permissions, not a `NOT_FOUND` error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface ConnectionServiceClient<CallOptionsExt = {}> {
  /** Creates a new connection. */
  createConnection(
    request: DeepPartial<CreateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Returns specified connection. */
  getConnection(
    request: DeepPartial<GetConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Returns a list of connections in the given project. */
  listConnections(
    request: DeepPartial<ListConnectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConnectionsResponse>;
  /**
   * Updates the specified connection. For security reasons, also resets
   * credential if connection properties are in the update field mask.
   */
  updateConnection(
    request: DeepPartial<UpdateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Connection>;
  /** Sets the credential for the specified connection. */
  updateConnectionCredential(
    request: DeepPartial<UpdateConnectionCredentialRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Deletes connection and associated credential. */
  deleteConnection(
    request: DeepPartial<DeleteConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Gets the access control policy for a resource.
   * Returns an empty policy if the resource exists and does not have a policy
   * set.
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy on the specified resource. Replaces any
   * existing policy.
   *
   * Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the specified resource.
   * If the resource does not exist, this will return an empty set of
   * permissions, not a `NOT_FOUND` error.
   *
   * Note: This operation is designed to be used for building permission-aware
   * UIs and command-line tools, not for authorization checking. This operation
   * may "fail open" without warning.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
