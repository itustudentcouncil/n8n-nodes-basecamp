// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/v2/standard_sql.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.bigquery.v2";

/**
 * The data type of a variable such as a function argument.
 * Examples include:
 *
 * * INT64: `{"typeKind": "INT64"}`
 *
 * * ARRAY<STRING>:
 *
 *     {
 *       "typeKind": "ARRAY",
 *       "arrayElementType": {"typeKind": "STRING"}
 *     }
 *
 * * STRUCT<x STRING, y ARRAY<DATE>>:
 *
 *     {
 *       "typeKind": "STRUCT",
 *       "structType":
 *       {
 *         "fields":
 *         [
 *           {
 *             "name": "x",
 *             "type": {"typeKind": "STRING"}
 *           },
 *           {
 *             "name": "y",
 *             "type":
 *             {
 *               "typeKind": "ARRAY",
 *               "arrayElementType": {"typeKind": "DATE"}
 *             }
 *           }
 *         ]
 *       }
 *     }
 *
 * * RANGE<DATE>:
 *
 *     {
 *       "typeKind": "RANGE",
 *       "rangeElementType": {"typeKind": "DATE"}
 *     }
 */
export interface StandardSqlDataType {
  /**
   * Required. The top level type of this field.
   * Can be any GoogleSQL data type (e.g., "INT64", "DATE", "ARRAY").
   */
  typeKind: StandardSqlDataType_TypeKind;
  /** The type of the array's elements, if type_kind = "ARRAY". */
  arrayElementType?:
    | StandardSqlDataType
    | undefined;
  /** The fields of this struct, in order, if type_kind = "STRUCT". */
  structType?:
    | StandardSqlStructType
    | undefined;
  /** The type of the range's elements, if type_kind = "RANGE". */
  rangeElementType?: StandardSqlDataType | undefined;
}

/** The kind of the datatype. */
export enum StandardSqlDataType_TypeKind {
  /** TYPE_KIND_UNSPECIFIED - Invalid type. */
  TYPE_KIND_UNSPECIFIED = 0,
  /** INT64 - Encoded as a string in decimal format. */
  INT64 = 2,
  /** BOOL - Encoded as a boolean "false" or "true". */
  BOOL = 5,
  /** FLOAT64 - Encoded as a number, or string "NaN", "Infinity" or "-Infinity". */
  FLOAT64 = 7,
  /** STRING - Encoded as a string value. */
  STRING = 8,
  /** BYTES - Encoded as a base64 string per RFC 4648, section 4. */
  BYTES = 9,
  /**
   * TIMESTAMP - Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
   * 1985-04-12T23:20:50.52Z
   */
  TIMESTAMP = 19,
  /** DATE - Encoded as RFC 3339 full-date format string: 1985-04-12 */
  DATE = 10,
  /** TIME - Encoded as RFC 3339 partial-time format string: 23:20:50.52 */
  TIME = 20,
  /** DATETIME - Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52 */
  DATETIME = 21,
  /** INTERVAL - Encoded as fully qualified 3 part: 0-5 15 2:30:45.6 */
  INTERVAL = 26,
  /** GEOGRAPHY - Encoded as WKT */
  GEOGRAPHY = 22,
  /** NUMERIC - Encoded as a decimal string. */
  NUMERIC = 23,
  /** BIGNUMERIC - Encoded as a decimal string. */
  BIGNUMERIC = 24,
  /** JSON - Encoded as a string. */
  JSON = 25,
  /** ARRAY - Encoded as a list with types matching Type.array_type. */
  ARRAY = 16,
  /**
   * STRUCT - Encoded as a list with fields of type Type.struct_type[i]. List is used
   * because a JSON object cannot have duplicate field names.
   */
  STRUCT = 17,
  /**
   * RANGE - Encoded as a pair with types matching range_element_type. Pairs must
   * begin with "[", end with ")", and be separated by ", ".
   */
  RANGE = 29,
  UNRECOGNIZED = -1,
}

export function standardSqlDataType_TypeKindFromJSON(object: any): StandardSqlDataType_TypeKind {
  switch (object) {
    case 0:
    case "TYPE_KIND_UNSPECIFIED":
      return StandardSqlDataType_TypeKind.TYPE_KIND_UNSPECIFIED;
    case 2:
    case "INT64":
      return StandardSqlDataType_TypeKind.INT64;
    case 5:
    case "BOOL":
      return StandardSqlDataType_TypeKind.BOOL;
    case 7:
    case "FLOAT64":
      return StandardSqlDataType_TypeKind.FLOAT64;
    case 8:
    case "STRING":
      return StandardSqlDataType_TypeKind.STRING;
    case 9:
    case "BYTES":
      return StandardSqlDataType_TypeKind.BYTES;
    case 19:
    case "TIMESTAMP":
      return StandardSqlDataType_TypeKind.TIMESTAMP;
    case 10:
    case "DATE":
      return StandardSqlDataType_TypeKind.DATE;
    case 20:
    case "TIME":
      return StandardSqlDataType_TypeKind.TIME;
    case 21:
    case "DATETIME":
      return StandardSqlDataType_TypeKind.DATETIME;
    case 26:
    case "INTERVAL":
      return StandardSqlDataType_TypeKind.INTERVAL;
    case 22:
    case "GEOGRAPHY":
      return StandardSqlDataType_TypeKind.GEOGRAPHY;
    case 23:
    case "NUMERIC":
      return StandardSqlDataType_TypeKind.NUMERIC;
    case 24:
    case "BIGNUMERIC":
      return StandardSqlDataType_TypeKind.BIGNUMERIC;
    case 25:
    case "JSON":
      return StandardSqlDataType_TypeKind.JSON;
    case 16:
    case "ARRAY":
      return StandardSqlDataType_TypeKind.ARRAY;
    case 17:
    case "STRUCT":
      return StandardSqlDataType_TypeKind.STRUCT;
    case 29:
    case "RANGE":
      return StandardSqlDataType_TypeKind.RANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StandardSqlDataType_TypeKind.UNRECOGNIZED;
  }
}

export function standardSqlDataType_TypeKindToJSON(object: StandardSqlDataType_TypeKind): string {
  switch (object) {
    case StandardSqlDataType_TypeKind.TYPE_KIND_UNSPECIFIED:
      return "TYPE_KIND_UNSPECIFIED";
    case StandardSqlDataType_TypeKind.INT64:
      return "INT64";
    case StandardSqlDataType_TypeKind.BOOL:
      return "BOOL";
    case StandardSqlDataType_TypeKind.FLOAT64:
      return "FLOAT64";
    case StandardSqlDataType_TypeKind.STRING:
      return "STRING";
    case StandardSqlDataType_TypeKind.BYTES:
      return "BYTES";
    case StandardSqlDataType_TypeKind.TIMESTAMP:
      return "TIMESTAMP";
    case StandardSqlDataType_TypeKind.DATE:
      return "DATE";
    case StandardSqlDataType_TypeKind.TIME:
      return "TIME";
    case StandardSqlDataType_TypeKind.DATETIME:
      return "DATETIME";
    case StandardSqlDataType_TypeKind.INTERVAL:
      return "INTERVAL";
    case StandardSqlDataType_TypeKind.GEOGRAPHY:
      return "GEOGRAPHY";
    case StandardSqlDataType_TypeKind.NUMERIC:
      return "NUMERIC";
    case StandardSqlDataType_TypeKind.BIGNUMERIC:
      return "BIGNUMERIC";
    case StandardSqlDataType_TypeKind.JSON:
      return "JSON";
    case StandardSqlDataType_TypeKind.ARRAY:
      return "ARRAY";
    case StandardSqlDataType_TypeKind.STRUCT:
      return "STRUCT";
    case StandardSqlDataType_TypeKind.RANGE:
      return "RANGE";
    case StandardSqlDataType_TypeKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A field or a column. */
export interface StandardSqlField {
  /** Optional. The name of this field. Can be absent for struct fields. */
  name: string;
  /**
   * Optional. The type of this parameter. Absent if not explicitly
   * specified (e.g., CREATE FUNCTION statement can omit the return type;
   * in this case the output parameter does not have this "type" field).
   */
  type: StandardSqlDataType | undefined;
}

/** The representation of a SQL STRUCT type. */
export interface StandardSqlStructType {
  /** Fields within the struct. */
  fields: StandardSqlField[];
}

/** A table type */
export interface StandardSqlTableType {
  /** The columns in this table type */
  columns: StandardSqlField[];
}

function createBaseStandardSqlDataType(): StandardSqlDataType {
  return { typeKind: 0, arrayElementType: undefined, structType: undefined, rangeElementType: undefined };
}

export const StandardSqlDataType: MessageFns<StandardSqlDataType> = {
  encode(message: StandardSqlDataType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeKind !== 0) {
      writer.uint32(8).int32(message.typeKind);
    }
    if (message.arrayElementType !== undefined) {
      StandardSqlDataType.encode(message.arrayElementType, writer.uint32(18).fork()).join();
    }
    if (message.structType !== undefined) {
      StandardSqlStructType.encode(message.structType, writer.uint32(26).fork()).join();
    }
    if (message.rangeElementType !== undefined) {
      StandardSqlDataType.encode(message.rangeElementType, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSqlDataType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSqlDataType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.typeKind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arrayElementType = StandardSqlDataType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.structType = StandardSqlStructType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rangeElementType = StandardSqlDataType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSqlDataType {
    return {
      typeKind: isSet(object.typeKind) ? standardSqlDataType_TypeKindFromJSON(object.typeKind) : 0,
      arrayElementType: isSet(object.arrayElementType)
        ? StandardSqlDataType.fromJSON(object.arrayElementType)
        : undefined,
      structType: isSet(object.structType) ? StandardSqlStructType.fromJSON(object.structType) : undefined,
      rangeElementType: isSet(object.rangeElementType)
        ? StandardSqlDataType.fromJSON(object.rangeElementType)
        : undefined,
    };
  },

  toJSON(message: StandardSqlDataType): unknown {
    const obj: any = {};
    if (message.typeKind !== 0) {
      obj.typeKind = standardSqlDataType_TypeKindToJSON(message.typeKind);
    }
    if (message.arrayElementType !== undefined) {
      obj.arrayElementType = StandardSqlDataType.toJSON(message.arrayElementType);
    }
    if (message.structType !== undefined) {
      obj.structType = StandardSqlStructType.toJSON(message.structType);
    }
    if (message.rangeElementType !== undefined) {
      obj.rangeElementType = StandardSqlDataType.toJSON(message.rangeElementType);
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSqlDataType>): StandardSqlDataType {
    return StandardSqlDataType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSqlDataType>): StandardSqlDataType {
    const message = createBaseStandardSqlDataType();
    message.typeKind = object.typeKind ?? 0;
    message.arrayElementType = (object.arrayElementType !== undefined && object.arrayElementType !== null)
      ? StandardSqlDataType.fromPartial(object.arrayElementType)
      : undefined;
    message.structType = (object.structType !== undefined && object.structType !== null)
      ? StandardSqlStructType.fromPartial(object.structType)
      : undefined;
    message.rangeElementType = (object.rangeElementType !== undefined && object.rangeElementType !== null)
      ? StandardSqlDataType.fromPartial(object.rangeElementType)
      : undefined;
    return message;
  },
};

function createBaseStandardSqlField(): StandardSqlField {
  return { name: "", type: undefined };
}

export const StandardSqlField: MessageFns<StandardSqlField> = {
  encode(message: StandardSqlField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== undefined) {
      StandardSqlDataType.encode(message.type, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSqlField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSqlField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = StandardSqlDataType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSqlField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? StandardSqlDataType.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: StandardSqlField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined) {
      obj.type = StandardSqlDataType.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSqlField>): StandardSqlField {
    return StandardSqlField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSqlField>): StandardSqlField {
    const message = createBaseStandardSqlField();
    message.name = object.name ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? StandardSqlDataType.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseStandardSqlStructType(): StandardSqlStructType {
  return { fields: [] };
}

export const StandardSqlStructType: MessageFns<StandardSqlStructType> = {
  encode(message: StandardSqlStructType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      StandardSqlField.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSqlStructType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSqlStructType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(StandardSqlField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSqlStructType {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => StandardSqlField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StandardSqlStructType): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => StandardSqlField.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSqlStructType>): StandardSqlStructType {
    return StandardSqlStructType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSqlStructType>): StandardSqlStructType {
    const message = createBaseStandardSqlStructType();
    message.fields = object.fields?.map((e) => StandardSqlField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStandardSqlTableType(): StandardSqlTableType {
  return { columns: [] };
}

export const StandardSqlTableType: MessageFns<StandardSqlTableType> = {
  encode(message: StandardSqlTableType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      StandardSqlField.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSqlTableType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSqlTableType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(StandardSqlField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSqlTableType {
    return {
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => StandardSqlField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StandardSqlTableType): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => StandardSqlField.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSqlTableType>): StandardSqlTableType {
    return StandardSqlTableType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSqlTableType>): StandardSqlTableType {
    const message = createBaseStandardSqlTableType();
    message.columns = object.columns?.map((e) => StandardSqlField.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
