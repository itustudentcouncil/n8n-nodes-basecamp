// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/datatransfer/v1/transfer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../../protobuf/struct.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { StringValue } from "../../../../protobuf/wrappers.js";
import { Status } from "../../../../rpc/status.js";

export const protobufPackage = "google.cloud.bigquery.datatransfer.v1";

/**
 * DEPRECATED. Represents data transfer type.
 *
 * @deprecated
 */
export enum TransferType {
  /** TRANSFER_TYPE_UNSPECIFIED - Invalid or Unknown transfer type placeholder. */
  TRANSFER_TYPE_UNSPECIFIED = 0,
  /** BATCH - Batch data transfer. */
  BATCH = 1,
  /**
   * STREAMING - Streaming data transfer. Streaming data source currently doesn't
   * support multiple transfer configs per project.
   */
  STREAMING = 2,
  UNRECOGNIZED = -1,
}

export function transferTypeFromJSON(object: any): TransferType {
  switch (object) {
    case 0:
    case "TRANSFER_TYPE_UNSPECIFIED":
      return TransferType.TRANSFER_TYPE_UNSPECIFIED;
    case 1:
    case "BATCH":
      return TransferType.BATCH;
    case 2:
    case "STREAMING":
      return TransferType.STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferType.UNRECOGNIZED;
  }
}

export function transferTypeToJSON(object: TransferType): string {
  switch (object) {
    case TransferType.TRANSFER_TYPE_UNSPECIFIED:
      return "TRANSFER_TYPE_UNSPECIFIED";
    case TransferType.BATCH:
      return "BATCH";
    case TransferType.STREAMING:
      return "STREAMING";
    case TransferType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents data transfer run state. */
export enum TransferState {
  /** TRANSFER_STATE_UNSPECIFIED - State placeholder (0). */
  TRANSFER_STATE_UNSPECIFIED = 0,
  /**
   * PENDING - Data transfer is scheduled and is waiting to be picked up by
   * data transfer backend (2).
   */
  PENDING = 2,
  /** RUNNING - Data transfer is in progress (3). */
  RUNNING = 3,
  /** SUCCEEDED - Data transfer completed successfully (4). */
  SUCCEEDED = 4,
  /** FAILED - Data transfer failed (5). */
  FAILED = 5,
  /** CANCELLED - Data transfer is cancelled (6). */
  CANCELLED = 6,
  UNRECOGNIZED = -1,
}

export function transferStateFromJSON(object: any): TransferState {
  switch (object) {
    case 0:
    case "TRANSFER_STATE_UNSPECIFIED":
      return TransferState.TRANSFER_STATE_UNSPECIFIED;
    case 2:
    case "PENDING":
      return TransferState.PENDING;
    case 3:
    case "RUNNING":
      return TransferState.RUNNING;
    case 4:
    case "SUCCEEDED":
      return TransferState.SUCCEEDED;
    case 5:
    case "FAILED":
      return TransferState.FAILED;
    case 6:
    case "CANCELLED":
      return TransferState.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferState.UNRECOGNIZED;
  }
}

export function transferStateToJSON(object: TransferState): string {
  switch (object) {
    case TransferState.TRANSFER_STATE_UNSPECIFIED:
      return "TRANSFER_STATE_UNSPECIFIED";
    case TransferState.PENDING:
      return "PENDING";
    case TransferState.RUNNING:
      return "RUNNING";
    case TransferState.SUCCEEDED:
      return "SUCCEEDED";
    case TransferState.FAILED:
      return "FAILED";
    case TransferState.CANCELLED:
      return "CANCELLED";
    case TransferState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents preferences for sending email notifications for transfer run
 * events.
 */
export interface EmailPreferences {
  /** If true, email notifications will be sent on transfer run failures. */
  enableFailureEmail: boolean;
}

/** Options customizing the data transfer schedule. */
export interface ScheduleOptions {
  /**
   * If true, automatic scheduling of data transfer runs for this configuration
   * will be disabled. The runs can be started on ad-hoc basis using
   * StartManualTransferRuns API. When automatic scheduling is disabled, the
   * TransferConfig.schedule field will be ignored.
   */
  disableAutoScheduling: boolean;
  /**
   * Specifies time to start scheduling transfer runs. The first run will be
   * scheduled at or after the start time according to a recurrence pattern
   * defined in the schedule string. The start time can be changed at any
   * moment. The time when a data transfer can be triggered manually is not
   * limited by this option.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Defines time to stop scheduling transfer runs. A transfer run cannot be
   * scheduled at or after the end time. The end time can be changed at any
   * moment. The time when a data transfer can be triggered manually is not
   * limited by this option.
   */
  endTime: Date | undefined;
}

/** Information about a user. */
export interface UserInfo {
  /** E-mail address of the user. */
  email?: string | undefined;
}

/**
 * Represents a data transfer configuration. A transfer configuration
 * contains all metadata needed to perform a data transfer. For example,
 * `destination_dataset_id` specifies where data should be stored.
 * When a new transfer configuration is created, the specified
 * `destination_dataset_id` is created when needed and shared with the
 * appropriate data source service account.
 */
export interface TransferConfig {
  /**
   * Identifier. The resource name of the transfer config.
   * Transfer config names have the form either
   * `projects/{project_id}/locations/{region}/transferConfigs/{config_id}` or
   * `projects/{project_id}/transferConfigs/{config_id}`,
   * where `config_id` is usually a UUID, even though it is not
   * guaranteed or required. The name is ignored when creating a transfer
   * config.
   */
  name: string;
  /** The BigQuery target dataset id. */
  destinationDatasetId?:
    | string
    | undefined;
  /** User specified display name for the data transfer. */
  displayName: string;
  /**
   * Data source ID. This cannot be changed once data transfer is created. The
   * full list of available data source IDs can be returned through an API call:
   * https://cloud.google.com/bigquery-transfer/docs/reference/datatransfer/rest/v1/projects.locations.dataSources/list
   */
  dataSourceId: string;
  /**
   * Parameters specific to each data source. For more information see the
   * bq tab in the 'Setting up a data transfer' section for each data source.
   * For example the parameters for Cloud Storage transfers are listed here:
   * https://cloud.google.com/bigquery-transfer/docs/cloud-storage-transfer#bq
   */
  params:
    | { [key: string]: any }
    | undefined;
  /**
   * Data transfer schedule.
   * If the data source does not support a custom schedule, this should be
   * empty. If it is empty, the default value for the data source will be used.
   * The specified times are in UTC.
   * Examples of valid format:
   * `1st,3rd monday of month 15:30`,
   * `every wed,fri of jan,jun 13:15`, and
   * `first sunday of quarter 00:00`.
   * See more explanation about the format here:
   * https://cloud.google.com/appengine/docs/flexible/python/scheduling-jobs-with-cron-yaml#the_schedule_format
   *
   * NOTE: The minimum interval time between recurring transfers depends on the
   * data source; refer to the documentation for your data source.
   */
  schedule: string;
  /** Options customizing the data transfer schedule. */
  scheduleOptions:
    | ScheduleOptions
    | undefined;
  /**
   * The number of days to look back to automatically refresh the data.
   * For example, if `data_refresh_window_days = 10`, then every day
   * BigQuery reingests data for [today-10, today-1], rather than ingesting data
   * for just [today-1].
   * Only valid if the data source supports the feature. Set the value to 0
   * to use the default value.
   */
  dataRefreshWindowDays: number;
  /**
   * Is this config disabled. When set to true, no runs will be scheduled for
   * this transfer config.
   */
  disabled: boolean;
  /** Output only. Data transfer modification time. Ignored by server on input. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Next time when data transfer will run. */
  nextRunTime:
    | Date
    | undefined;
  /** Output only. State of the most recently updated transfer run. */
  state: TransferState;
  /** Deprecated. Unique ID of the user on whose behalf transfer is done. */
  userId: Long;
  /** Output only. Region in which BigQuery dataset is located. */
  datasetRegion: string;
  /**
   * Pub/Sub topic where notifications will be sent after transfer runs
   * associated with this transfer config finish.
   *
   * The format for specifying a pubsub topic is:
   * `projects/{project_id}/topics/{topic_id}`
   */
  notificationPubsubTopic: string;
  /**
   * Email notifications will be sent according to these preferences
   * to the email address of the user who owns this transfer config.
   */
  emailPreferences:
    | EmailPreferences
    | undefined;
  /**
   * Output only. Information about the user whose credentials are used to
   * transfer data. Populated only for `transferConfigs.get` requests. In case
   * the user information is not available, this field will not be populated.
   */
  ownerInfo?:
    | UserInfo
    | undefined;
  /**
   * The encryption configuration part. Currently, it is only used for the
   * optional KMS key name. The BigQuery service account of your project must be
   * granted permissions to use the key. Read methods will return the key name
   * applied in effect. Write methods will apply the key if it is present, or
   * otherwise try to apply project default keys if it is absent.
   */
  encryptionConfiguration: EncryptionConfiguration | undefined;
}

/** Represents the encryption configuration for a transfer. */
export interface EncryptionConfiguration {
  /** The name of the KMS key used for encrypting BigQuery data. */
  kmsKeyName: string | undefined;
}

/** Represents a data transfer run. */
export interface TransferRun {
  /**
   * Identifier. The resource name of the transfer run.
   * Transfer run names have the form
   * `projects/{project_id}/locations/{location}/transferConfigs/{config_id}/runs/{run_id}`.
   * The name is ignored when creating a transfer run.
   */
  name: string;
  /** Minimum time after which a transfer run can be started. */
  scheduleTime:
    | Date
    | undefined;
  /**
   * For batch transfer runs, specifies the date and time of the data should be
   * ingested.
   */
  runTime:
    | Date
    | undefined;
  /** Status of the transfer run. */
  errorStatus:
    | Status
    | undefined;
  /**
   * Output only. Time when transfer run was started.
   * Parameter ignored by server for input requests.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Time when transfer run ended.
   * Parameter ignored by server for input requests.
   */
  endTime:
    | Date
    | undefined;
  /** Output only. Last time the data transfer run state was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Parameters specific to each data source. For more information
   * see the bq tab in the 'Setting up a data transfer' section for each data
   * source. For example the parameters for Cloud Storage transfers are listed
   * here:
   * https://cloud.google.com/bigquery-transfer/docs/cloud-storage-transfer#bq
   */
  params:
    | { [key: string]: any }
    | undefined;
  /** Output only. The BigQuery target dataset id. */
  destinationDatasetId?:
    | string
    | undefined;
  /** Output only. Data source id. */
  dataSourceId: string;
  /** Data transfer run state. Ignored for input requests. */
  state: TransferState;
  /** Deprecated. Unique ID of the user on whose behalf transfer is done. */
  userId: Long;
  /**
   * Output only. Describes the schedule of this transfer run if it was
   * created as part of a regular schedule. For batch transfer runs that are
   * scheduled manually, this is empty.
   * NOTE: the system might choose to delay the schedule depending on the
   * current load, so `schedule_time` doesn't always match this.
   */
  schedule: string;
  /**
   * Output only. Pub/Sub topic where a notification will be sent after this
   * transfer run finishes.
   *
   * The format for specifying a pubsub topic is:
   * `projects/{project_id}/topics/{topic_id}`
   */
  notificationPubsubTopic: string;
  /**
   * Output only. Email notifications will be sent according to these
   * preferences to the email address of the user who owns the transfer config
   * this run was derived from.
   */
  emailPreferences: EmailPreferences | undefined;
}

/** Represents a user facing message for a particular data transfer run. */
export interface TransferMessage {
  /** Time when message was logged. */
  messageTime:
    | Date
    | undefined;
  /** Message severity. */
  severity: TransferMessage_MessageSeverity;
  /** Message text. */
  messageText: string;
}

/** Represents data transfer user facing message severity. */
export enum TransferMessage_MessageSeverity {
  /** MESSAGE_SEVERITY_UNSPECIFIED - No severity specified. */
  MESSAGE_SEVERITY_UNSPECIFIED = 0,
  /** INFO - Informational message. */
  INFO = 1,
  /** WARNING - Warning message. */
  WARNING = 2,
  /** ERROR - Error message. */
  ERROR = 3,
  UNRECOGNIZED = -1,
}

export function transferMessage_MessageSeverityFromJSON(object: any): TransferMessage_MessageSeverity {
  switch (object) {
    case 0:
    case "MESSAGE_SEVERITY_UNSPECIFIED":
      return TransferMessage_MessageSeverity.MESSAGE_SEVERITY_UNSPECIFIED;
    case 1:
    case "INFO":
      return TransferMessage_MessageSeverity.INFO;
    case 2:
    case "WARNING":
      return TransferMessage_MessageSeverity.WARNING;
    case 3:
    case "ERROR":
      return TransferMessage_MessageSeverity.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferMessage_MessageSeverity.UNRECOGNIZED;
  }
}

export function transferMessage_MessageSeverityToJSON(object: TransferMessage_MessageSeverity): string {
  switch (object) {
    case TransferMessage_MessageSeverity.MESSAGE_SEVERITY_UNSPECIFIED:
      return "MESSAGE_SEVERITY_UNSPECIFIED";
    case TransferMessage_MessageSeverity.INFO:
      return "INFO";
    case TransferMessage_MessageSeverity.WARNING:
      return "WARNING";
    case TransferMessage_MessageSeverity.ERROR:
      return "ERROR";
    case TransferMessage_MessageSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseEmailPreferences(): EmailPreferences {
  return { enableFailureEmail: false };
}

export const EmailPreferences: MessageFns<EmailPreferences> = {
  encode(message: EmailPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableFailureEmail !== false) {
      writer.uint32(8).bool(message.enableFailureEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableFailureEmail = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailPreferences {
    return {
      enableFailureEmail: isSet(object.enableFailureEmail) ? globalThis.Boolean(object.enableFailureEmail) : false,
    };
  },

  toJSON(message: EmailPreferences): unknown {
    const obj: any = {};
    if (message.enableFailureEmail !== false) {
      obj.enableFailureEmail = message.enableFailureEmail;
    }
    return obj;
  },

  create(base?: DeepPartial<EmailPreferences>): EmailPreferences {
    return EmailPreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmailPreferences>): EmailPreferences {
    const message = createBaseEmailPreferences();
    message.enableFailureEmail = object.enableFailureEmail ?? false;
    return message;
  },
};

function createBaseScheduleOptions(): ScheduleOptions {
  return { disableAutoScheduling: false, startTime: undefined, endTime: undefined };
}

export const ScheduleOptions: MessageFns<ScheduleOptions> = {
  encode(message: ScheduleOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disableAutoScheduling !== false) {
      writer.uint32(24).bool(message.disableAutoScheduling);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.disableAutoScheduling = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleOptions {
    return {
      disableAutoScheduling: isSet(object.disableAutoScheduling)
        ? globalThis.Boolean(object.disableAutoScheduling)
        : false,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ScheduleOptions): unknown {
    const obj: any = {};
    if (message.disableAutoScheduling !== false) {
      obj.disableAutoScheduling = message.disableAutoScheduling;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ScheduleOptions>): ScheduleOptions {
    return ScheduleOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduleOptions>): ScheduleOptions {
    const message = createBaseScheduleOptions();
    message.disableAutoScheduling = object.disableAutoScheduling ?? false;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { email: undefined };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return { email: isSet(object.email) ? globalThis.String(object.email) : undefined };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.email = object.email ?? undefined;
    return message;
  },
};

function createBaseTransferConfig(): TransferConfig {
  return {
    name: "",
    destinationDatasetId: undefined,
    displayName: "",
    dataSourceId: "",
    params: undefined,
    schedule: "",
    scheduleOptions: undefined,
    dataRefreshWindowDays: 0,
    disabled: false,
    updateTime: undefined,
    nextRunTime: undefined,
    state: 0,
    userId: Long.ZERO,
    datasetRegion: "",
    notificationPubsubTopic: "",
    emailPreferences: undefined,
    ownerInfo: undefined,
    encryptionConfiguration: undefined,
  };
}

export const TransferConfig: MessageFns<TransferConfig> = {
  encode(message: TransferConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.destinationDatasetId !== undefined) {
      writer.uint32(18).string(message.destinationDatasetId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.dataSourceId !== "") {
      writer.uint32(42).string(message.dataSourceId);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(74).fork()).join();
    }
    if (message.schedule !== "") {
      writer.uint32(58).string(message.schedule);
    }
    if (message.scheduleOptions !== undefined) {
      ScheduleOptions.encode(message.scheduleOptions, writer.uint32(194).fork()).join();
    }
    if (message.dataRefreshWindowDays !== 0) {
      writer.uint32(96).int32(message.dataRefreshWindowDays);
    }
    if (message.disabled !== false) {
      writer.uint32(104).bool(message.disabled);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.nextRunTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRunTime), writer.uint32(66).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (!message.userId.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.userId.toString());
    }
    if (message.datasetRegion !== "") {
      writer.uint32(114).string(message.datasetRegion);
    }
    if (message.notificationPubsubTopic !== "") {
      writer.uint32(122).string(message.notificationPubsubTopic);
    }
    if (message.emailPreferences !== undefined) {
      EmailPreferences.encode(message.emailPreferences, writer.uint32(146).fork()).join();
    }
    if (message.ownerInfo !== undefined) {
      UserInfo.encode(message.ownerInfo, writer.uint32(218).fork()).join();
    }
    if (message.encryptionConfiguration !== undefined) {
      EncryptionConfiguration.encode(message.encryptionConfiguration, writer.uint32(226).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationDatasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataSourceId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.schedule = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.scheduleOptions = ScheduleOptions.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.dataRefreshWindowDays = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nextRunTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.userId = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.datasetRegion = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.notificationPubsubTopic = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.emailPreferences = EmailPreferences.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.ownerInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.encryptionConfiguration = EncryptionConfiguration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationDatasetId: isSet(object.destinationDatasetId)
        ? globalThis.String(object.destinationDatasetId)
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      dataSourceId: isSet(object.dataSourceId) ? globalThis.String(object.dataSourceId) : "",
      params: isObject(object.params) ? object.params : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      scheduleOptions: isSet(object.scheduleOptions) ? ScheduleOptions.fromJSON(object.scheduleOptions) : undefined,
      dataRefreshWindowDays: isSet(object.dataRefreshWindowDays) ? globalThis.Number(object.dataRefreshWindowDays) : 0,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      nextRunTime: isSet(object.nextRunTime) ? fromJsonTimestamp(object.nextRunTime) : undefined,
      state: isSet(object.state) ? transferStateFromJSON(object.state) : 0,
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.ZERO,
      datasetRegion: isSet(object.datasetRegion) ? globalThis.String(object.datasetRegion) : "",
      notificationPubsubTopic: isSet(object.notificationPubsubTopic)
        ? globalThis.String(object.notificationPubsubTopic)
        : "",
      emailPreferences: isSet(object.emailPreferences) ? EmailPreferences.fromJSON(object.emailPreferences) : undefined,
      ownerInfo: isSet(object.ownerInfo) ? UserInfo.fromJSON(object.ownerInfo) : undefined,
      encryptionConfiguration: isSet(object.encryptionConfiguration)
        ? EncryptionConfiguration.fromJSON(object.encryptionConfiguration)
        : undefined,
    };
  },

  toJSON(message: TransferConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationDatasetId !== undefined) {
      obj.destinationDatasetId = message.destinationDatasetId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.dataSourceId !== "") {
      obj.dataSourceId = message.dataSourceId;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.scheduleOptions !== undefined) {
      obj.scheduleOptions = ScheduleOptions.toJSON(message.scheduleOptions);
    }
    if (message.dataRefreshWindowDays !== 0) {
      obj.dataRefreshWindowDays = Math.round(message.dataRefreshWindowDays);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.nextRunTime !== undefined) {
      obj.nextRunTime = message.nextRunTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = transferStateToJSON(message.state);
    }
    if (!message.userId.equals(Long.ZERO)) {
      obj.userId = (message.userId || Long.ZERO).toString();
    }
    if (message.datasetRegion !== "") {
      obj.datasetRegion = message.datasetRegion;
    }
    if (message.notificationPubsubTopic !== "") {
      obj.notificationPubsubTopic = message.notificationPubsubTopic;
    }
    if (message.emailPreferences !== undefined) {
      obj.emailPreferences = EmailPreferences.toJSON(message.emailPreferences);
    }
    if (message.ownerInfo !== undefined) {
      obj.ownerInfo = UserInfo.toJSON(message.ownerInfo);
    }
    if (message.encryptionConfiguration !== undefined) {
      obj.encryptionConfiguration = EncryptionConfiguration.toJSON(message.encryptionConfiguration);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferConfig>): TransferConfig {
    return TransferConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferConfig>): TransferConfig {
    const message = createBaseTransferConfig();
    message.name = object.name ?? "";
    message.destinationDatasetId = object.destinationDatasetId ?? undefined;
    message.displayName = object.displayName ?? "";
    message.dataSourceId = object.dataSourceId ?? "";
    message.params = object.params ?? undefined;
    message.schedule = object.schedule ?? "";
    message.scheduleOptions = (object.scheduleOptions !== undefined && object.scheduleOptions !== null)
      ? ScheduleOptions.fromPartial(object.scheduleOptions)
      : undefined;
    message.dataRefreshWindowDays = object.dataRefreshWindowDays ?? 0;
    message.disabled = object.disabled ?? false;
    message.updateTime = object.updateTime ?? undefined;
    message.nextRunTime = object.nextRunTime ?? undefined;
    message.state = object.state ?? 0;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.ZERO;
    message.datasetRegion = object.datasetRegion ?? "";
    message.notificationPubsubTopic = object.notificationPubsubTopic ?? "";
    message.emailPreferences = (object.emailPreferences !== undefined && object.emailPreferences !== null)
      ? EmailPreferences.fromPartial(object.emailPreferences)
      : undefined;
    message.ownerInfo = (object.ownerInfo !== undefined && object.ownerInfo !== null)
      ? UserInfo.fromPartial(object.ownerInfo)
      : undefined;
    message.encryptionConfiguration =
      (object.encryptionConfiguration !== undefined && object.encryptionConfiguration !== null)
        ? EncryptionConfiguration.fromPartial(object.encryptionConfiguration)
        : undefined;
    return message;
  },
};

function createBaseEncryptionConfiguration(): EncryptionConfiguration {
  return { kmsKeyName: undefined };
}

export const EncryptionConfiguration: MessageFns<EncryptionConfiguration> = {
  encode(message: EncryptionConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKeyName !== undefined) {
      StringValue.encode({ value: message.kmsKeyName! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptionConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKeyName = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptionConfiguration {
    return { kmsKeyName: isSet(object.kmsKeyName) ? String(object.kmsKeyName) : undefined };
  },

  toJSON(message: EncryptionConfiguration): unknown {
    const obj: any = {};
    if (message.kmsKeyName !== undefined) {
      obj.kmsKeyName = message.kmsKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptionConfiguration>): EncryptionConfiguration {
    return EncryptionConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptionConfiguration>): EncryptionConfiguration {
    const message = createBaseEncryptionConfiguration();
    message.kmsKeyName = object.kmsKeyName ?? undefined;
    return message;
  },
};

function createBaseTransferRun(): TransferRun {
  return {
    name: "",
    scheduleTime: undefined,
    runTime: undefined,
    errorStatus: undefined,
    startTime: undefined,
    endTime: undefined,
    updateTime: undefined,
    params: undefined,
    destinationDatasetId: undefined,
    dataSourceId: "",
    state: 0,
    userId: Long.ZERO,
    schedule: "",
    notificationPubsubTopic: "",
    emailPreferences: undefined,
  };
}

export const TransferRun: MessageFns<TransferRun> = {
  encode(message: TransferRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(26).fork()).join();
    }
    if (message.runTime !== undefined) {
      Timestamp.encode(toTimestamp(message.runTime), writer.uint32(82).fork()).join();
    }
    if (message.errorStatus !== undefined) {
      Status.encode(message.errorStatus, writer.uint32(170).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(74).fork()).join();
    }
    if (message.destinationDatasetId !== undefined) {
      writer.uint32(18).string(message.destinationDatasetId);
    }
    if (message.dataSourceId !== "") {
      writer.uint32(58).string(message.dataSourceId);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (!message.userId.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.userId.toString());
    }
    if (message.schedule !== "") {
      writer.uint32(98).string(message.schedule);
    }
    if (message.notificationPubsubTopic !== "") {
      writer.uint32(186).string(message.notificationPubsubTopic);
    }
    if (message.emailPreferences !== undefined) {
      EmailPreferences.encode(message.emailPreferences, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.runTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.errorStatus = Status.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationDatasetId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataSourceId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.userId = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.schedule = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.notificationPubsubTopic = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.emailPreferences = EmailPreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferRun {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      runTime: isSet(object.runTime) ? fromJsonTimestamp(object.runTime) : undefined,
      errorStatus: isSet(object.errorStatus) ? Status.fromJSON(object.errorStatus) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      params: isObject(object.params) ? object.params : undefined,
      destinationDatasetId: isSet(object.destinationDatasetId)
        ? globalThis.String(object.destinationDatasetId)
        : undefined,
      dataSourceId: isSet(object.dataSourceId) ? globalThis.String(object.dataSourceId) : "",
      state: isSet(object.state) ? transferStateFromJSON(object.state) : 0,
      userId: isSet(object.userId) ? Long.fromValue(object.userId) : Long.ZERO,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      notificationPubsubTopic: isSet(object.notificationPubsubTopic)
        ? globalThis.String(object.notificationPubsubTopic)
        : "",
      emailPreferences: isSet(object.emailPreferences) ? EmailPreferences.fromJSON(object.emailPreferences) : undefined,
    };
  },

  toJSON(message: TransferRun): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.runTime !== undefined) {
      obj.runTime = message.runTime.toISOString();
    }
    if (message.errorStatus !== undefined) {
      obj.errorStatus = Status.toJSON(message.errorStatus);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    if (message.destinationDatasetId !== undefined) {
      obj.destinationDatasetId = message.destinationDatasetId;
    }
    if (message.dataSourceId !== "") {
      obj.dataSourceId = message.dataSourceId;
    }
    if (message.state !== 0) {
      obj.state = transferStateToJSON(message.state);
    }
    if (!message.userId.equals(Long.ZERO)) {
      obj.userId = (message.userId || Long.ZERO).toString();
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.notificationPubsubTopic !== "") {
      obj.notificationPubsubTopic = message.notificationPubsubTopic;
    }
    if (message.emailPreferences !== undefined) {
      obj.emailPreferences = EmailPreferences.toJSON(message.emailPreferences);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferRun>): TransferRun {
    return TransferRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferRun>): TransferRun {
    const message = createBaseTransferRun();
    message.name = object.name ?? "";
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.runTime = object.runTime ?? undefined;
    message.errorStatus = (object.errorStatus !== undefined && object.errorStatus !== null)
      ? Status.fromPartial(object.errorStatus)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.params = object.params ?? undefined;
    message.destinationDatasetId = object.destinationDatasetId ?? undefined;
    message.dataSourceId = object.dataSourceId ?? "";
    message.state = object.state ?? 0;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? Long.fromValue(object.userId)
      : Long.ZERO;
    message.schedule = object.schedule ?? "";
    message.notificationPubsubTopic = object.notificationPubsubTopic ?? "";
    message.emailPreferences = (object.emailPreferences !== undefined && object.emailPreferences !== null)
      ? EmailPreferences.fromPartial(object.emailPreferences)
      : undefined;
    return message;
  },
};

function createBaseTransferMessage(): TransferMessage {
  return { messageTime: undefined, severity: 0, messageText: "" };
}

export const TransferMessage: MessageFns<TransferMessage> = {
  encode(message: TransferMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageTime !== undefined) {
      Timestamp.encode(toTimestamp(message.messageTime), writer.uint32(10).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    if (message.messageText !== "") {
      writer.uint32(26).string(message.messageText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferMessage {
    return {
      messageTime: isSet(object.messageTime) ? fromJsonTimestamp(object.messageTime) : undefined,
      severity: isSet(object.severity) ? transferMessage_MessageSeverityFromJSON(object.severity) : 0,
      messageText: isSet(object.messageText) ? globalThis.String(object.messageText) : "",
    };
  },

  toJSON(message: TransferMessage): unknown {
    const obj: any = {};
    if (message.messageTime !== undefined) {
      obj.messageTime = message.messageTime.toISOString();
    }
    if (message.severity !== 0) {
      obj.severity = transferMessage_MessageSeverityToJSON(message.severity);
    }
    if (message.messageText !== "") {
      obj.messageText = message.messageText;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferMessage>): TransferMessage {
    return TransferMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferMessage>): TransferMessage {
    const message = createBaseTransferMessage();
    message.messageTime = object.messageTime ?? undefined;
    message.severity = object.severity ?? 0;
    message.messageText = object.messageText ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
