// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/migration/v2alpha/migration_entities.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../../protobuf/any.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { ErrorInfo } from "../../../../rpc/error_details.js";
import { AssessmentOrchestrationResultDetails, AssessmentTaskDetails } from "./assessment_task.js";
import { ResourceErrorDetail } from "./migration_error_details.js";
import { TimeSeries } from "./migration_metrics.js";
import { TranslationTaskDetails } from "./translation_task.js";

export const protobufPackage = "google.cloud.bigquery.migration.v2alpha";

/**
 * A migration workflow which specifies what needs to be done for an EDW
 * migration.
 */
export interface MigrationWorkflow {
  /**
   * Output only. Immutable. The unique identifier for the migration workflow. The ID is
   * server-generated.
   *
   * Example: `projects/123/locations/us/workflows/345`
   */
  name: string;
  /**
   * The display name of the workflow. This can be set to give a workflow
   * a descriptive name. There is no guarantee or enforcement of uniqueness.
   */
  displayName: string;
  /**
   * The tasks in a workflow in a named map. The name (i.e. key) has no
   * meaning and is merely a convenient way to address a specific task
   * in a workflow.
   */
  tasks: { [key: string]: MigrationTask };
  /** Output only. That status of the workflow. */
  state: MigrationWorkflow_State;
  /** Time when the workflow was created. */
  createTime:
    | Date
    | undefined;
  /** Time when the workflow was last updated. */
  lastUpdateTime: Date | undefined;
}

/** Possible migration workflow states. */
export enum MigrationWorkflow_State {
  /** STATE_UNSPECIFIED - Workflow state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * DRAFT - Workflow is in draft status, i.e. tasks are not yet eligible for
   * execution.
   */
  DRAFT = 1,
  /** RUNNING - Workflow is running (i.e. tasks are eligible for execution). */
  RUNNING = 2,
  /**
   * PAUSED - Workflow is paused. Tasks currently in progress may continue, but no
   * further tasks will be scheduled.
   */
  PAUSED = 3,
  /**
   * COMPLETED - Workflow is complete. There should not be any task in a non-terminal
   * state, but if they are (e.g. forced termination), they will not be
   * scheduled.
   */
  COMPLETED = 4,
  UNRECOGNIZED = -1,
}

export function migrationWorkflow_StateFromJSON(object: any): MigrationWorkflow_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MigrationWorkflow_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return MigrationWorkflow_State.DRAFT;
    case 2:
    case "RUNNING":
      return MigrationWorkflow_State.RUNNING;
    case 3:
    case "PAUSED":
      return MigrationWorkflow_State.PAUSED;
    case 4:
    case "COMPLETED":
      return MigrationWorkflow_State.COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationWorkflow_State.UNRECOGNIZED;
  }
}

export function migrationWorkflow_StateToJSON(object: MigrationWorkflow_State): string {
  switch (object) {
    case MigrationWorkflow_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MigrationWorkflow_State.DRAFT:
      return "DRAFT";
    case MigrationWorkflow_State.RUNNING:
      return "RUNNING";
    case MigrationWorkflow_State.PAUSED:
      return "PAUSED";
    case MigrationWorkflow_State.COMPLETED:
      return "COMPLETED";
    case MigrationWorkflow_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MigrationWorkflow_TasksEntry {
  key: string;
  value: MigrationTask | undefined;
}

/**
 * A single task for a migration which has details about the configuration of
 * the task.
 */
export interface MigrationTask {
  /** Task configuration for Assessment. */
  assessmentTaskDetails?:
    | AssessmentTaskDetails
    | undefined;
  /** Task configuration for Batch/Offline SQL Translation. */
  translationTaskDetails?:
    | TranslationTaskDetails
    | undefined;
  /** Output only. Immutable. The unique identifier for the migration task. The ID is server-generated. */
  id: string;
  /** The type of the task. This must be a supported task type. */
  type: string;
  /**
   * DEPRECATED! Use one of the task_details below.
   * The details of the task. The type URL must be one of the supported task
   * details messages and correspond to the Task's type.
   */
  details:
    | Any
    | undefined;
  /** Output only. The current state of the task. */
  state: MigrationTask_State;
  /** Output only. An explanation that may be populated when the task is in FAILED state. */
  processingError:
    | ErrorInfo
    | undefined;
  /** Time when the task was created. */
  createTime:
    | Date
    | undefined;
  /** Time when the task was last updated. */
  lastUpdateTime:
    | Date
    | undefined;
  /** Output only. Additional information about the orchestration. */
  orchestrationResult: MigrationTaskOrchestrationResult | undefined;
}

/** Possible states of a migration task. */
export enum MigrationTask_State {
  /** STATE_UNSPECIFIED - The state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The task is waiting for orchestration. */
  PENDING = 1,
  /** ORCHESTRATING - The task is assigned to an orchestrator. */
  ORCHESTRATING = 2,
  /** RUNNING - The task is running, i.e. its subtasks are ready for execution. */
  RUNNING = 3,
  /**
   * PAUSED - Tha task is paused. Assigned subtasks can continue, but no new subtasks
   * will be scheduled.
   */
  PAUSED = 4,
  /** SUCCEEDED - The task finished successfully. */
  SUCCEEDED = 5,
  /** FAILED - The task finished unsuccessfully. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function migrationTask_StateFromJSON(object: any): MigrationTask_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MigrationTask_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return MigrationTask_State.PENDING;
    case 2:
    case "ORCHESTRATING":
      return MigrationTask_State.ORCHESTRATING;
    case 3:
    case "RUNNING":
      return MigrationTask_State.RUNNING;
    case 4:
    case "PAUSED":
      return MigrationTask_State.PAUSED;
    case 5:
    case "SUCCEEDED":
      return MigrationTask_State.SUCCEEDED;
    case 6:
    case "FAILED":
      return MigrationTask_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationTask_State.UNRECOGNIZED;
  }
}

export function migrationTask_StateToJSON(object: MigrationTask_State): string {
  switch (object) {
    case MigrationTask_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MigrationTask_State.PENDING:
      return "PENDING";
    case MigrationTask_State.ORCHESTRATING:
      return "ORCHESTRATING";
    case MigrationTask_State.RUNNING:
      return "RUNNING";
    case MigrationTask_State.PAUSED:
      return "PAUSED";
    case MigrationTask_State.SUCCEEDED:
      return "SUCCEEDED";
    case MigrationTask_State.FAILED:
      return "FAILED";
    case MigrationTask_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A subtask for a migration which carries details about the configuration of
 * the subtask. The content of the details should not matter to the end user,
 * but is a contract between the subtask creator and subtask worker.
 */
export interface MigrationSubtask {
  /**
   * Output only. Immutable. The resource name for the migration subtask. The ID is
   * server-generated.
   *
   * Example: `projects/123/locations/us/workflows/345/subtasks/678`
   */
  name: string;
  /** The unique ID of the task to which this subtask belongs. */
  taskId: string;
  /**
   * The type of the Subtask. The migration service does not check whether this
   * is a known type. It is up to the task creator (i.e. orchestrator or worker)
   * to ensure it only creates subtasks for which there are compatible workers
   * polling for Subtasks.
   */
  type: string;
  /** Output only. The current state of the subtask. */
  state: MigrationSubtask_State;
  /** Output only. An explanation that may be populated when the task is in FAILED state. */
  processingError:
    | ErrorInfo
    | undefined;
  /**
   * Output only. Provides details to errors and issues encountered while processing the
   * subtask. Presence of error details does not mean that the subtask failed.
   */
  resourceErrorDetails: ResourceErrorDetail[];
  /**
   * The number or resources with errors. Note: This is not the total
   * number of errors as each resource can have more than one error.
   * This is used to indicate truncation by having a `resource_error_count`
   * that is higher than the size of `resource_error_details`.
   */
  resourceErrorCount: number;
  /** Time when the subtask was created. */
  createTime:
    | Date
    | undefined;
  /** Time when the subtask was last updated. */
  lastUpdateTime:
    | Date
    | undefined;
  /** The metrics for the subtask. */
  metrics: TimeSeries[];
}

/** Possible states of a migration subtask. */
export enum MigrationSubtask_State {
  /** STATE_UNSPECIFIED - The state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The subtask is ready, i.e. it is ready for execution. */
  ACTIVE = 1,
  /** RUNNING - The subtask is running, i.e. it is assigned to a worker for execution. */
  RUNNING = 2,
  /** SUCCEEDED - The subtask finished successfully. */
  SUCCEEDED = 3,
  /** FAILED - The subtask finished unsuccessfully. */
  FAILED = 4,
  /**
   * PAUSED - The subtask is paused, i.e., it will not be scheduled. If it was already
   * assigned,it might still finish but no new lease renewals will be granted.
   */
  PAUSED = 5,
  UNRECOGNIZED = -1,
}

export function migrationSubtask_StateFromJSON(object: any): MigrationSubtask_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MigrationSubtask_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return MigrationSubtask_State.ACTIVE;
    case 2:
    case "RUNNING":
      return MigrationSubtask_State.RUNNING;
    case 3:
    case "SUCCEEDED":
      return MigrationSubtask_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return MigrationSubtask_State.FAILED;
    case 5:
    case "PAUSED":
      return MigrationSubtask_State.PAUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationSubtask_State.UNRECOGNIZED;
  }
}

export function migrationSubtask_StateToJSON(object: MigrationSubtask_State): string {
  switch (object) {
    case MigrationSubtask_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MigrationSubtask_State.ACTIVE:
      return "ACTIVE";
    case MigrationSubtask_State.RUNNING:
      return "RUNNING";
    case MigrationSubtask_State.SUCCEEDED:
      return "SUCCEEDED";
    case MigrationSubtask_State.FAILED:
      return "FAILED";
    case MigrationSubtask_State.PAUSED:
      return "PAUSED";
    case MigrationSubtask_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Additional information from the orchestrator when it is done with the
 * task orchestration.
 */
export interface MigrationTaskOrchestrationResult {
  /** Details specific to assessment task types. */
  assessmentDetails?: AssessmentOrchestrationResultDetails | undefined;
}

function createBaseMigrationWorkflow(): MigrationWorkflow {
  return { name: "", displayName: "", tasks: {}, state: 0, createTime: undefined, lastUpdateTime: undefined };
}

export const MigrationWorkflow: MessageFns<MigrationWorkflow> = {
  encode(message: MigrationWorkflow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    Object.entries(message.tasks).forEach(([key, value]) => {
      MigrationWorkflow_TasksEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationWorkflow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationWorkflow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MigrationWorkflow_TasksEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.tasks[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationWorkflow {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      tasks: isObject(object.tasks)
        ? Object.entries(object.tasks).reduce<{ [key: string]: MigrationTask }>((acc, [key, value]) => {
          acc[key] = MigrationTask.fromJSON(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? migrationWorkflow_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
    };
  },

  toJSON(message: MigrationWorkflow): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.tasks) {
      const entries = Object.entries(message.tasks);
      if (entries.length > 0) {
        obj.tasks = {};
        entries.forEach(([k, v]) => {
          obj.tasks[k] = MigrationTask.toJSON(v);
        });
      }
    }
    if (message.state !== 0) {
      obj.state = migrationWorkflow_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationWorkflow>): MigrationWorkflow {
    return MigrationWorkflow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationWorkflow>): MigrationWorkflow {
    const message = createBaseMigrationWorkflow();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.tasks = Object.entries(object.tasks ?? {}).reduce<{ [key: string]: MigrationTask }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = MigrationTask.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    return message;
  },
};

function createBaseMigrationWorkflow_TasksEntry(): MigrationWorkflow_TasksEntry {
  return { key: "", value: undefined };
}

export const MigrationWorkflow_TasksEntry: MessageFns<MigrationWorkflow_TasksEntry> = {
  encode(message: MigrationWorkflow_TasksEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MigrationTask.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationWorkflow_TasksEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationWorkflow_TasksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = MigrationTask.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationWorkflow_TasksEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MigrationTask.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MigrationWorkflow_TasksEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MigrationTask.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationWorkflow_TasksEntry>): MigrationWorkflow_TasksEntry {
    return MigrationWorkflow_TasksEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationWorkflow_TasksEntry>): MigrationWorkflow_TasksEntry {
    const message = createBaseMigrationWorkflow_TasksEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MigrationTask.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMigrationTask(): MigrationTask {
  return {
    assessmentTaskDetails: undefined,
    translationTaskDetails: undefined,
    id: "",
    type: "",
    details: undefined,
    state: 0,
    processingError: undefined,
    createTime: undefined,
    lastUpdateTime: undefined,
    orchestrationResult: undefined,
  };
}

export const MigrationTask: MessageFns<MigrationTask> = {
  encode(message: MigrationTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assessmentTaskDetails !== undefined) {
      AssessmentTaskDetails.encode(message.assessmentTaskDetails, writer.uint32(98).fork()).join();
    }
    if (message.translationTaskDetails !== undefined) {
      TranslationTaskDetails.encode(message.translationTaskDetails, writer.uint32(106).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.details !== undefined) {
      Any.encode(message.details, writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.processingError !== undefined) {
      ErrorInfo.encode(message.processingError, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(58).fork()).join();
    }
    if (message.orchestrationResult !== undefined) {
      MigrationTaskOrchestrationResult.encode(message.orchestrationResult, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.assessmentTaskDetails = AssessmentTaskDetails.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.translationTaskDetails = TranslationTaskDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = Any.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.processingError = ErrorInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.orchestrationResult = MigrationTaskOrchestrationResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationTask {
    return {
      assessmentTaskDetails: isSet(object.assessmentTaskDetails)
        ? AssessmentTaskDetails.fromJSON(object.assessmentTaskDetails)
        : undefined,
      translationTaskDetails: isSet(object.translationTaskDetails)
        ? TranslationTaskDetails.fromJSON(object.translationTaskDetails)
        : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      details: isSet(object.details) ? Any.fromJSON(object.details) : undefined,
      state: isSet(object.state) ? migrationTask_StateFromJSON(object.state) : 0,
      processingError: isSet(object.processingError) ? ErrorInfo.fromJSON(object.processingError) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
      orchestrationResult: isSet(object.orchestrationResult)
        ? MigrationTaskOrchestrationResult.fromJSON(object.orchestrationResult)
        : undefined,
    };
  },

  toJSON(message: MigrationTask): unknown {
    const obj: any = {};
    if (message.assessmentTaskDetails !== undefined) {
      obj.assessmentTaskDetails = AssessmentTaskDetails.toJSON(message.assessmentTaskDetails);
    }
    if (message.translationTaskDetails !== undefined) {
      obj.translationTaskDetails = TranslationTaskDetails.toJSON(message.translationTaskDetails);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.details !== undefined) {
      obj.details = Any.toJSON(message.details);
    }
    if (message.state !== 0) {
      obj.state = migrationTask_StateToJSON(message.state);
    }
    if (message.processingError !== undefined) {
      obj.processingError = ErrorInfo.toJSON(message.processingError);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    if (message.orchestrationResult !== undefined) {
      obj.orchestrationResult = MigrationTaskOrchestrationResult.toJSON(message.orchestrationResult);
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationTask>): MigrationTask {
    return MigrationTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationTask>): MigrationTask {
    const message = createBaseMigrationTask();
    message.assessmentTaskDetails =
      (object.assessmentTaskDetails !== undefined && object.assessmentTaskDetails !== null)
        ? AssessmentTaskDetails.fromPartial(object.assessmentTaskDetails)
        : undefined;
    message.translationTaskDetails =
      (object.translationTaskDetails !== undefined && object.translationTaskDetails !== null)
        ? TranslationTaskDetails.fromPartial(object.translationTaskDetails)
        : undefined;
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.details = (object.details !== undefined && object.details !== null)
      ? Any.fromPartial(object.details)
      : undefined;
    message.state = object.state ?? 0;
    message.processingError = (object.processingError !== undefined && object.processingError !== null)
      ? ErrorInfo.fromPartial(object.processingError)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    message.orchestrationResult = (object.orchestrationResult !== undefined && object.orchestrationResult !== null)
      ? MigrationTaskOrchestrationResult.fromPartial(object.orchestrationResult)
      : undefined;
    return message;
  },
};

function createBaseMigrationSubtask(): MigrationSubtask {
  return {
    name: "",
    taskId: "",
    type: "",
    state: 0,
    processingError: undefined,
    resourceErrorDetails: [],
    resourceErrorCount: 0,
    createTime: undefined,
    lastUpdateTime: undefined,
    metrics: [],
  };
}

export const MigrationSubtask: MessageFns<MigrationSubtask> = {
  encode(message: MigrationSubtask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.processingError !== undefined) {
      ErrorInfo.encode(message.processingError, writer.uint32(50).fork()).join();
    }
    for (const v of message.resourceErrorDetails) {
      ResourceErrorDetail.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.resourceErrorCount !== 0) {
      writer.uint32(104).int32(message.resourceErrorCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(66).fork()).join();
    }
    for (const v of message.metrics) {
      TimeSeries.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationSubtask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationSubtask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.processingError = ErrorInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.resourceErrorDetails.push(ResourceErrorDetail.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.resourceErrorCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.metrics.push(TimeSeries.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationSubtask {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      state: isSet(object.state) ? migrationSubtask_StateFromJSON(object.state) : 0,
      processingError: isSet(object.processingError) ? ErrorInfo.fromJSON(object.processingError) : undefined,
      resourceErrorDetails: globalThis.Array.isArray(object?.resourceErrorDetails)
        ? object.resourceErrorDetails.map((e: any) => ResourceErrorDetail.fromJSON(e))
        : [],
      resourceErrorCount: isSet(object.resourceErrorCount) ? globalThis.Number(object.resourceErrorCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => TimeSeries.fromJSON(e)) : [],
    };
  },

  toJSON(message: MigrationSubtask): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.state !== 0) {
      obj.state = migrationSubtask_StateToJSON(message.state);
    }
    if (message.processingError !== undefined) {
      obj.processingError = ErrorInfo.toJSON(message.processingError);
    }
    if (message.resourceErrorDetails?.length) {
      obj.resourceErrorDetails = message.resourceErrorDetails.map((e) => ResourceErrorDetail.toJSON(e));
    }
    if (message.resourceErrorCount !== 0) {
      obj.resourceErrorCount = Math.round(message.resourceErrorCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => TimeSeries.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationSubtask>): MigrationSubtask {
    return MigrationSubtask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationSubtask>): MigrationSubtask {
    const message = createBaseMigrationSubtask();
    message.name = object.name ?? "";
    message.taskId = object.taskId ?? "";
    message.type = object.type ?? "";
    message.state = object.state ?? 0;
    message.processingError = (object.processingError !== undefined && object.processingError !== null)
      ? ErrorInfo.fromPartial(object.processingError)
      : undefined;
    message.resourceErrorDetails = object.resourceErrorDetails?.map((e) => ResourceErrorDetail.fromPartial(e)) || [];
    message.resourceErrorCount = object.resourceErrorCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    message.metrics = object.metrics?.map((e) => TimeSeries.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMigrationTaskOrchestrationResult(): MigrationTaskOrchestrationResult {
  return { assessmentDetails: undefined };
}

export const MigrationTaskOrchestrationResult: MessageFns<MigrationTaskOrchestrationResult> = {
  encode(message: MigrationTaskOrchestrationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assessmentDetails !== undefined) {
      AssessmentOrchestrationResultDetails.encode(message.assessmentDetails, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationTaskOrchestrationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationTaskOrchestrationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assessmentDetails = AssessmentOrchestrationResultDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationTaskOrchestrationResult {
    return {
      assessmentDetails: isSet(object.assessmentDetails)
        ? AssessmentOrchestrationResultDetails.fromJSON(object.assessmentDetails)
        : undefined,
    };
  },

  toJSON(message: MigrationTaskOrchestrationResult): unknown {
    const obj: any = {};
    if (message.assessmentDetails !== undefined) {
      obj.assessmentDetails = AssessmentOrchestrationResultDetails.toJSON(message.assessmentDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationTaskOrchestrationResult>): MigrationTaskOrchestrationResult {
    return MigrationTaskOrchestrationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationTaskOrchestrationResult>): MigrationTaskOrchestrationResult {
    const message = createBaseMigrationTaskOrchestrationResult();
    message.assessmentDetails = (object.assessmentDetails !== undefined && object.assessmentDetails !== null)
      ? AssessmentOrchestrationResultDetails.fromPartial(object.assessmentDetails)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
