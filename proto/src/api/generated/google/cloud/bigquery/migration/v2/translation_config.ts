// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/migration/v2/translation_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.bigquery.migration.v2";

/**
 * The translation config to capture necessary settings for a translation task
 * and subtask.
 */
export interface TranslationConfigDetails {
  /** The Cloud Storage path for a directory of files to translate in a task. */
  gcsSourcePath?:
    | string
    | undefined;
  /** The Cloud Storage path to write back the corresponding input files to. */
  gcsTargetPath?:
    | string
    | undefined;
  /** The mapping of objects to their desired output names in list form. */
  nameMappingList?:
    | ObjectNameMappingList
    | undefined;
  /** The dialect of the input files. */
  sourceDialect:
    | Dialect
    | undefined;
  /** The target dialect for the engine to translate the input to. */
  targetDialect:
    | Dialect
    | undefined;
  /** The default source environment values for the translation. */
  sourceEnv:
    | SourceEnv
    | undefined;
  /** The indicator to show translation request initiator. */
  requestSource: string;
  /**
   * The types of output to generate, e.g. sql, metadata etc. If not specified,
   * a default set of targets will be generated. Some additional target types
   * may be slower to generate. See the documentation for the set of available
   * target types.
   */
  targetTypes: string[];
}

/** The possible dialect options for translation. */
export interface Dialect {
  /** The BigQuery dialect */
  bigqueryDialect?:
    | BigQueryDialect
    | undefined;
  /** The HiveQL dialect */
  hiveqlDialect?:
    | HiveQLDialect
    | undefined;
  /** The Redshift dialect */
  redshiftDialect?:
    | RedshiftDialect
    | undefined;
  /** The Teradata dialect */
  teradataDialect?:
    | TeradataDialect
    | undefined;
  /** The Oracle dialect */
  oracleDialect?:
    | OracleDialect
    | undefined;
  /** The SparkSQL dialect */
  sparksqlDialect?:
    | SparkSQLDialect
    | undefined;
  /** The Snowflake dialect */
  snowflakeDialect?:
    | SnowflakeDialect
    | undefined;
  /** The Netezza dialect */
  netezzaDialect?:
    | NetezzaDialect
    | undefined;
  /** The Azure Synapse dialect */
  azureSynapseDialect?:
    | AzureSynapseDialect
    | undefined;
  /** The Vertica dialect */
  verticaDialect?:
    | VerticaDialect
    | undefined;
  /** The SQL Server dialect */
  sqlServerDialect?:
    | SQLServerDialect
    | undefined;
  /** The Postgresql dialect */
  postgresqlDialect?:
    | PostgresqlDialect
    | undefined;
  /** The Presto dialect */
  prestoDialect?:
    | PrestoDialect
    | undefined;
  /** The MySQL dialect */
  mysqlDialect?:
    | MySQLDialect
    | undefined;
  /** DB2 dialect */
  db2Dialect?:
    | DB2Dialect
    | undefined;
  /** SQLite dialect */
  sqliteDialect?:
    | SQLiteDialect
    | undefined;
  /** Greenplum dialect */
  greenplumDialect?: GreenplumDialect | undefined;
}

/** The dialect definition for BigQuery. */
export interface BigQueryDialect {
}

/** The dialect definition for HiveQL. */
export interface HiveQLDialect {
}

/** The dialect definition for Redshift. */
export interface RedshiftDialect {
}

/** The dialect definition for Teradata. */
export interface TeradataDialect {
  /** Which Teradata sub-dialect mode the user specifies. */
  mode: TeradataDialect_Mode;
}

/** The sub-dialect options for Teradata. */
export enum TeradataDialect_Mode {
  /** MODE_UNSPECIFIED - Unspecified mode. */
  MODE_UNSPECIFIED = 0,
  /** SQL - Teradata SQL mode. */
  SQL = 1,
  /** BTEQ - BTEQ mode (which includes SQL). */
  BTEQ = 2,
  UNRECOGNIZED = -1,
}

export function teradataDialect_ModeFromJSON(object: any): TeradataDialect_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return TeradataDialect_Mode.MODE_UNSPECIFIED;
    case 1:
    case "SQL":
      return TeradataDialect_Mode.SQL;
    case 2:
    case "BTEQ":
      return TeradataDialect_Mode.BTEQ;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TeradataDialect_Mode.UNRECOGNIZED;
  }
}

export function teradataDialect_ModeToJSON(object: TeradataDialect_Mode): string {
  switch (object) {
    case TeradataDialect_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case TeradataDialect_Mode.SQL:
      return "SQL";
    case TeradataDialect_Mode.BTEQ:
      return "BTEQ";
    case TeradataDialect_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The dialect definition for Oracle. */
export interface OracleDialect {
}

/** The dialect definition for SparkSQL. */
export interface SparkSQLDialect {
}

/** The dialect definition for Snowflake. */
export interface SnowflakeDialect {
}

/** The dialect definition for Netezza. */
export interface NetezzaDialect {
}

/** The dialect definition for Azure Synapse. */
export interface AzureSynapseDialect {
}

/** The dialect definition for Vertica. */
export interface VerticaDialect {
}

/** The dialect definition for SQL Server. */
export interface SQLServerDialect {
}

/** The dialect definition for Postgresql. */
export interface PostgresqlDialect {
}

/** The dialect definition for Presto. */
export interface PrestoDialect {
}

/** The dialect definition for MySQL. */
export interface MySQLDialect {
}

/** The dialect definition for DB2. */
export interface DB2Dialect {
}

/** The dialect definition for SQLite. */
export interface SQLiteDialect {
}

/** The dialect definition for Greenplum. */
export interface GreenplumDialect {
}

/**
 * Represents a map of name mappings using a list of key:value proto messages of
 * existing name to desired output name.
 */
export interface ObjectNameMappingList {
  /** The elements of the object name map. */
  nameMap: ObjectNameMapping[];
}

/**
 * Represents a key-value pair of NameMappingKey to NameMappingValue to
 * represent the mapping of SQL names from the input value to desired output.
 */
export interface ObjectNameMapping {
  /** The name of the object in source that is being mapped. */
  source:
    | NameMappingKey
    | undefined;
  /** The desired target name of the object that is being mapped. */
  target: NameMappingValue | undefined;
}

/**
 * The potential components of a full name mapping that will be mapped
 * during translation in the source data warehouse.
 */
export interface NameMappingKey {
  /** The type of object that is being mapped. */
  type: NameMappingKey_Type;
  /**
   * The database name (BigQuery project ID equivalent in the source data
   * warehouse).
   */
  database: string;
  /** The schema name (BigQuery dataset equivalent in the source data warehouse). */
  schema: string;
  /**
   * The relation name (BigQuery table or view equivalent in the source data
   * warehouse).
   */
  relation: string;
  /**
   * The attribute name (BigQuery column equivalent in the source data
   * warehouse).
   */
  attribute: string;
}

/** The type of the object that is being mapped. */
export enum NameMappingKey_Type {
  /** TYPE_UNSPECIFIED - Unspecified name mapping type. */
  TYPE_UNSPECIFIED = 0,
  /** DATABASE - The object being mapped is a database. */
  DATABASE = 1,
  /** SCHEMA - The object being mapped is a schema. */
  SCHEMA = 2,
  /** RELATION - The object being mapped is a relation. */
  RELATION = 3,
  /** ATTRIBUTE - The object being mapped is an attribute. */
  ATTRIBUTE = 4,
  /** RELATION_ALIAS - The object being mapped is a relation alias. */
  RELATION_ALIAS = 5,
  /** ATTRIBUTE_ALIAS - The object being mapped is a an attribute alias. */
  ATTRIBUTE_ALIAS = 6,
  /** FUNCTION - The object being mapped is a function. */
  FUNCTION = 7,
  UNRECOGNIZED = -1,
}

export function nameMappingKey_TypeFromJSON(object: any): NameMappingKey_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return NameMappingKey_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DATABASE":
      return NameMappingKey_Type.DATABASE;
    case 2:
    case "SCHEMA":
      return NameMappingKey_Type.SCHEMA;
    case 3:
    case "RELATION":
      return NameMappingKey_Type.RELATION;
    case 4:
    case "ATTRIBUTE":
      return NameMappingKey_Type.ATTRIBUTE;
    case 5:
    case "RELATION_ALIAS":
      return NameMappingKey_Type.RELATION_ALIAS;
    case 6:
    case "ATTRIBUTE_ALIAS":
      return NameMappingKey_Type.ATTRIBUTE_ALIAS;
    case 7:
    case "FUNCTION":
      return NameMappingKey_Type.FUNCTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NameMappingKey_Type.UNRECOGNIZED;
  }
}

export function nameMappingKey_TypeToJSON(object: NameMappingKey_Type): string {
  switch (object) {
    case NameMappingKey_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case NameMappingKey_Type.DATABASE:
      return "DATABASE";
    case NameMappingKey_Type.SCHEMA:
      return "SCHEMA";
    case NameMappingKey_Type.RELATION:
      return "RELATION";
    case NameMappingKey_Type.ATTRIBUTE:
      return "ATTRIBUTE";
    case NameMappingKey_Type.RELATION_ALIAS:
      return "RELATION_ALIAS";
    case NameMappingKey_Type.ATTRIBUTE_ALIAS:
      return "ATTRIBUTE_ALIAS";
    case NameMappingKey_Type.FUNCTION:
      return "FUNCTION";
    case NameMappingKey_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The potential components of a full name mapping that will be mapped
 * during translation in the target data warehouse.
 */
export interface NameMappingValue {
  /**
   * The database name (BigQuery project ID equivalent in the target data
   * warehouse).
   */
  database: string;
  /** The schema name (BigQuery dataset equivalent in the target data warehouse). */
  schema: string;
  /**
   * The relation name (BigQuery table or view equivalent in the target data
   * warehouse).
   */
  relation: string;
  /**
   * The attribute name (BigQuery column equivalent in the target data
   * warehouse).
   */
  attribute: string;
}

/** Represents the default source environment values for the translation. */
export interface SourceEnv {
  /**
   * The default database name to fully qualify SQL objects when their database
   * name is missing.
   */
  defaultDatabase: string;
  /**
   * The schema search path. When SQL objects are missing schema name,
   * translation engine will search through this list to find the value.
   */
  schemaSearchPath: string[];
  /**
   * Optional. Expects a valid BigQuery dataset ID that exists, e.g.,
   * project-123.metadata_store_123.  If specified, translation will search and
   * read the required schema information from a metadata store in this dataset.
   * If metadata store doesn't exist, translation will parse the metadata file
   * and upload the schema info to a temp table in the dataset to speed up
   * future translation jobs.
   */
  metadataStoreDataset: string;
}

function createBaseTranslationConfigDetails(): TranslationConfigDetails {
  return {
    gcsSourcePath: undefined,
    gcsTargetPath: undefined,
    nameMappingList: undefined,
    sourceDialect: undefined,
    targetDialect: undefined,
    sourceEnv: undefined,
    requestSource: "",
    targetTypes: [],
  };
}

export const TranslationConfigDetails: MessageFns<TranslationConfigDetails> = {
  encode(message: TranslationConfigDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSourcePath !== undefined) {
      writer.uint32(10).string(message.gcsSourcePath);
    }
    if (message.gcsTargetPath !== undefined) {
      writer.uint32(18).string(message.gcsTargetPath);
    }
    if (message.nameMappingList !== undefined) {
      ObjectNameMappingList.encode(message.nameMappingList, writer.uint32(42).fork()).join();
    }
    if (message.sourceDialect !== undefined) {
      Dialect.encode(message.sourceDialect, writer.uint32(26).fork()).join();
    }
    if (message.targetDialect !== undefined) {
      Dialect.encode(message.targetDialect, writer.uint32(34).fork()).join();
    }
    if (message.sourceEnv !== undefined) {
      SourceEnv.encode(message.sourceEnv, writer.uint32(50).fork()).join();
    }
    if (message.requestSource !== "") {
      writer.uint32(66).string(message.requestSource);
    }
    for (const v of message.targetTypes) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslationConfigDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslationConfigDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSourcePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsTargetPath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nameMappingList = ObjectNameMappingList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceDialect = Dialect.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetDialect = Dialect.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceEnv = SourceEnv.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.requestSource = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.targetTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslationConfigDetails {
    return {
      gcsSourcePath: isSet(object.gcsSourcePath) ? globalThis.String(object.gcsSourcePath) : undefined,
      gcsTargetPath: isSet(object.gcsTargetPath) ? globalThis.String(object.gcsTargetPath) : undefined,
      nameMappingList: isSet(object.nameMappingList)
        ? ObjectNameMappingList.fromJSON(object.nameMappingList)
        : undefined,
      sourceDialect: isSet(object.sourceDialect) ? Dialect.fromJSON(object.sourceDialect) : undefined,
      targetDialect: isSet(object.targetDialect) ? Dialect.fromJSON(object.targetDialect) : undefined,
      sourceEnv: isSet(object.sourceEnv) ? SourceEnv.fromJSON(object.sourceEnv) : undefined,
      requestSource: isSet(object.requestSource) ? globalThis.String(object.requestSource) : "",
      targetTypes: globalThis.Array.isArray(object?.targetTypes)
        ? object.targetTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TranslationConfigDetails): unknown {
    const obj: any = {};
    if (message.gcsSourcePath !== undefined) {
      obj.gcsSourcePath = message.gcsSourcePath;
    }
    if (message.gcsTargetPath !== undefined) {
      obj.gcsTargetPath = message.gcsTargetPath;
    }
    if (message.nameMappingList !== undefined) {
      obj.nameMappingList = ObjectNameMappingList.toJSON(message.nameMappingList);
    }
    if (message.sourceDialect !== undefined) {
      obj.sourceDialect = Dialect.toJSON(message.sourceDialect);
    }
    if (message.targetDialect !== undefined) {
      obj.targetDialect = Dialect.toJSON(message.targetDialect);
    }
    if (message.sourceEnv !== undefined) {
      obj.sourceEnv = SourceEnv.toJSON(message.sourceEnv);
    }
    if (message.requestSource !== "") {
      obj.requestSource = message.requestSource;
    }
    if (message.targetTypes?.length) {
      obj.targetTypes = message.targetTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<TranslationConfigDetails>): TranslationConfigDetails {
    return TranslationConfigDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslationConfigDetails>): TranslationConfigDetails {
    const message = createBaseTranslationConfigDetails();
    message.gcsSourcePath = object.gcsSourcePath ?? undefined;
    message.gcsTargetPath = object.gcsTargetPath ?? undefined;
    message.nameMappingList = (object.nameMappingList !== undefined && object.nameMappingList !== null)
      ? ObjectNameMappingList.fromPartial(object.nameMappingList)
      : undefined;
    message.sourceDialect = (object.sourceDialect !== undefined && object.sourceDialect !== null)
      ? Dialect.fromPartial(object.sourceDialect)
      : undefined;
    message.targetDialect = (object.targetDialect !== undefined && object.targetDialect !== null)
      ? Dialect.fromPartial(object.targetDialect)
      : undefined;
    message.sourceEnv = (object.sourceEnv !== undefined && object.sourceEnv !== null)
      ? SourceEnv.fromPartial(object.sourceEnv)
      : undefined;
    message.requestSource = object.requestSource ?? "";
    message.targetTypes = object.targetTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseDialect(): Dialect {
  return {
    bigqueryDialect: undefined,
    hiveqlDialect: undefined,
    redshiftDialect: undefined,
    teradataDialect: undefined,
    oracleDialect: undefined,
    sparksqlDialect: undefined,
    snowflakeDialect: undefined,
    netezzaDialect: undefined,
    azureSynapseDialect: undefined,
    verticaDialect: undefined,
    sqlServerDialect: undefined,
    postgresqlDialect: undefined,
    prestoDialect: undefined,
    mysqlDialect: undefined,
    db2Dialect: undefined,
    sqliteDialect: undefined,
    greenplumDialect: undefined,
  };
}

export const Dialect: MessageFns<Dialect> = {
  encode(message: Dialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bigqueryDialect !== undefined) {
      BigQueryDialect.encode(message.bigqueryDialect, writer.uint32(10).fork()).join();
    }
    if (message.hiveqlDialect !== undefined) {
      HiveQLDialect.encode(message.hiveqlDialect, writer.uint32(18).fork()).join();
    }
    if (message.redshiftDialect !== undefined) {
      RedshiftDialect.encode(message.redshiftDialect, writer.uint32(26).fork()).join();
    }
    if (message.teradataDialect !== undefined) {
      TeradataDialect.encode(message.teradataDialect, writer.uint32(34).fork()).join();
    }
    if (message.oracleDialect !== undefined) {
      OracleDialect.encode(message.oracleDialect, writer.uint32(42).fork()).join();
    }
    if (message.sparksqlDialect !== undefined) {
      SparkSQLDialect.encode(message.sparksqlDialect, writer.uint32(50).fork()).join();
    }
    if (message.snowflakeDialect !== undefined) {
      SnowflakeDialect.encode(message.snowflakeDialect, writer.uint32(58).fork()).join();
    }
    if (message.netezzaDialect !== undefined) {
      NetezzaDialect.encode(message.netezzaDialect, writer.uint32(66).fork()).join();
    }
    if (message.azureSynapseDialect !== undefined) {
      AzureSynapseDialect.encode(message.azureSynapseDialect, writer.uint32(74).fork()).join();
    }
    if (message.verticaDialect !== undefined) {
      VerticaDialect.encode(message.verticaDialect, writer.uint32(82).fork()).join();
    }
    if (message.sqlServerDialect !== undefined) {
      SQLServerDialect.encode(message.sqlServerDialect, writer.uint32(90).fork()).join();
    }
    if (message.postgresqlDialect !== undefined) {
      PostgresqlDialect.encode(message.postgresqlDialect, writer.uint32(98).fork()).join();
    }
    if (message.prestoDialect !== undefined) {
      PrestoDialect.encode(message.prestoDialect, writer.uint32(106).fork()).join();
    }
    if (message.mysqlDialect !== undefined) {
      MySQLDialect.encode(message.mysqlDialect, writer.uint32(114).fork()).join();
    }
    if (message.db2Dialect !== undefined) {
      DB2Dialect.encode(message.db2Dialect, writer.uint32(122).fork()).join();
    }
    if (message.sqliteDialect !== undefined) {
      SQLiteDialect.encode(message.sqliteDialect, writer.uint32(130).fork()).join();
    }
    if (message.greenplumDialect !== undefined) {
      GreenplumDialect.encode(message.greenplumDialect, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bigqueryDialect = BigQueryDialect.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hiveqlDialect = HiveQLDialect.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.redshiftDialect = RedshiftDialect.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.teradataDialect = TeradataDialect.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oracleDialect = OracleDialect.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sparksqlDialect = SparkSQLDialect.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.snowflakeDialect = SnowflakeDialect.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.netezzaDialect = NetezzaDialect.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.azureSynapseDialect = AzureSynapseDialect.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.verticaDialect = VerticaDialect.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sqlServerDialect = SQLServerDialect.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.postgresqlDialect = PostgresqlDialect.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.prestoDialect = PrestoDialect.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.mysqlDialect = MySQLDialect.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.db2Dialect = DB2Dialect.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.sqliteDialect = SQLiteDialect.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.greenplumDialect = GreenplumDialect.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dialect {
    return {
      bigqueryDialect: isSet(object.bigqueryDialect) ? BigQueryDialect.fromJSON(object.bigqueryDialect) : undefined,
      hiveqlDialect: isSet(object.hiveqlDialect) ? HiveQLDialect.fromJSON(object.hiveqlDialect) : undefined,
      redshiftDialect: isSet(object.redshiftDialect) ? RedshiftDialect.fromJSON(object.redshiftDialect) : undefined,
      teradataDialect: isSet(object.teradataDialect) ? TeradataDialect.fromJSON(object.teradataDialect) : undefined,
      oracleDialect: isSet(object.oracleDialect) ? OracleDialect.fromJSON(object.oracleDialect) : undefined,
      sparksqlDialect: isSet(object.sparksqlDialect) ? SparkSQLDialect.fromJSON(object.sparksqlDialect) : undefined,
      snowflakeDialect: isSet(object.snowflakeDialect) ? SnowflakeDialect.fromJSON(object.snowflakeDialect) : undefined,
      netezzaDialect: isSet(object.netezzaDialect) ? NetezzaDialect.fromJSON(object.netezzaDialect) : undefined,
      azureSynapseDialect: isSet(object.azureSynapseDialect)
        ? AzureSynapseDialect.fromJSON(object.azureSynapseDialect)
        : undefined,
      verticaDialect: isSet(object.verticaDialect) ? VerticaDialect.fromJSON(object.verticaDialect) : undefined,
      sqlServerDialect: isSet(object.sqlServerDialect) ? SQLServerDialect.fromJSON(object.sqlServerDialect) : undefined,
      postgresqlDialect: isSet(object.postgresqlDialect)
        ? PostgresqlDialect.fromJSON(object.postgresqlDialect)
        : undefined,
      prestoDialect: isSet(object.prestoDialect) ? PrestoDialect.fromJSON(object.prestoDialect) : undefined,
      mysqlDialect: isSet(object.mysqlDialect) ? MySQLDialect.fromJSON(object.mysqlDialect) : undefined,
      db2Dialect: isSet(object.db2Dialect) ? DB2Dialect.fromJSON(object.db2Dialect) : undefined,
      sqliteDialect: isSet(object.sqliteDialect) ? SQLiteDialect.fromJSON(object.sqliteDialect) : undefined,
      greenplumDialect: isSet(object.greenplumDialect) ? GreenplumDialect.fromJSON(object.greenplumDialect) : undefined,
    };
  },

  toJSON(message: Dialect): unknown {
    const obj: any = {};
    if (message.bigqueryDialect !== undefined) {
      obj.bigqueryDialect = BigQueryDialect.toJSON(message.bigqueryDialect);
    }
    if (message.hiveqlDialect !== undefined) {
      obj.hiveqlDialect = HiveQLDialect.toJSON(message.hiveqlDialect);
    }
    if (message.redshiftDialect !== undefined) {
      obj.redshiftDialect = RedshiftDialect.toJSON(message.redshiftDialect);
    }
    if (message.teradataDialect !== undefined) {
      obj.teradataDialect = TeradataDialect.toJSON(message.teradataDialect);
    }
    if (message.oracleDialect !== undefined) {
      obj.oracleDialect = OracleDialect.toJSON(message.oracleDialect);
    }
    if (message.sparksqlDialect !== undefined) {
      obj.sparksqlDialect = SparkSQLDialect.toJSON(message.sparksqlDialect);
    }
    if (message.snowflakeDialect !== undefined) {
      obj.snowflakeDialect = SnowflakeDialect.toJSON(message.snowflakeDialect);
    }
    if (message.netezzaDialect !== undefined) {
      obj.netezzaDialect = NetezzaDialect.toJSON(message.netezzaDialect);
    }
    if (message.azureSynapseDialect !== undefined) {
      obj.azureSynapseDialect = AzureSynapseDialect.toJSON(message.azureSynapseDialect);
    }
    if (message.verticaDialect !== undefined) {
      obj.verticaDialect = VerticaDialect.toJSON(message.verticaDialect);
    }
    if (message.sqlServerDialect !== undefined) {
      obj.sqlServerDialect = SQLServerDialect.toJSON(message.sqlServerDialect);
    }
    if (message.postgresqlDialect !== undefined) {
      obj.postgresqlDialect = PostgresqlDialect.toJSON(message.postgresqlDialect);
    }
    if (message.prestoDialect !== undefined) {
      obj.prestoDialect = PrestoDialect.toJSON(message.prestoDialect);
    }
    if (message.mysqlDialect !== undefined) {
      obj.mysqlDialect = MySQLDialect.toJSON(message.mysqlDialect);
    }
    if (message.db2Dialect !== undefined) {
      obj.db2Dialect = DB2Dialect.toJSON(message.db2Dialect);
    }
    if (message.sqliteDialect !== undefined) {
      obj.sqliteDialect = SQLiteDialect.toJSON(message.sqliteDialect);
    }
    if (message.greenplumDialect !== undefined) {
      obj.greenplumDialect = GreenplumDialect.toJSON(message.greenplumDialect);
    }
    return obj;
  },

  create(base?: DeepPartial<Dialect>): Dialect {
    return Dialect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dialect>): Dialect {
    const message = createBaseDialect();
    message.bigqueryDialect = (object.bigqueryDialect !== undefined && object.bigqueryDialect !== null)
      ? BigQueryDialect.fromPartial(object.bigqueryDialect)
      : undefined;
    message.hiveqlDialect = (object.hiveqlDialect !== undefined && object.hiveqlDialect !== null)
      ? HiveQLDialect.fromPartial(object.hiveqlDialect)
      : undefined;
    message.redshiftDialect = (object.redshiftDialect !== undefined && object.redshiftDialect !== null)
      ? RedshiftDialect.fromPartial(object.redshiftDialect)
      : undefined;
    message.teradataDialect = (object.teradataDialect !== undefined && object.teradataDialect !== null)
      ? TeradataDialect.fromPartial(object.teradataDialect)
      : undefined;
    message.oracleDialect = (object.oracleDialect !== undefined && object.oracleDialect !== null)
      ? OracleDialect.fromPartial(object.oracleDialect)
      : undefined;
    message.sparksqlDialect = (object.sparksqlDialect !== undefined && object.sparksqlDialect !== null)
      ? SparkSQLDialect.fromPartial(object.sparksqlDialect)
      : undefined;
    message.snowflakeDialect = (object.snowflakeDialect !== undefined && object.snowflakeDialect !== null)
      ? SnowflakeDialect.fromPartial(object.snowflakeDialect)
      : undefined;
    message.netezzaDialect = (object.netezzaDialect !== undefined && object.netezzaDialect !== null)
      ? NetezzaDialect.fromPartial(object.netezzaDialect)
      : undefined;
    message.azureSynapseDialect = (object.azureSynapseDialect !== undefined && object.azureSynapseDialect !== null)
      ? AzureSynapseDialect.fromPartial(object.azureSynapseDialect)
      : undefined;
    message.verticaDialect = (object.verticaDialect !== undefined && object.verticaDialect !== null)
      ? VerticaDialect.fromPartial(object.verticaDialect)
      : undefined;
    message.sqlServerDialect = (object.sqlServerDialect !== undefined && object.sqlServerDialect !== null)
      ? SQLServerDialect.fromPartial(object.sqlServerDialect)
      : undefined;
    message.postgresqlDialect = (object.postgresqlDialect !== undefined && object.postgresqlDialect !== null)
      ? PostgresqlDialect.fromPartial(object.postgresqlDialect)
      : undefined;
    message.prestoDialect = (object.prestoDialect !== undefined && object.prestoDialect !== null)
      ? PrestoDialect.fromPartial(object.prestoDialect)
      : undefined;
    message.mysqlDialect = (object.mysqlDialect !== undefined && object.mysqlDialect !== null)
      ? MySQLDialect.fromPartial(object.mysqlDialect)
      : undefined;
    message.db2Dialect = (object.db2Dialect !== undefined && object.db2Dialect !== null)
      ? DB2Dialect.fromPartial(object.db2Dialect)
      : undefined;
    message.sqliteDialect = (object.sqliteDialect !== undefined && object.sqliteDialect !== null)
      ? SQLiteDialect.fromPartial(object.sqliteDialect)
      : undefined;
    message.greenplumDialect = (object.greenplumDialect !== undefined && object.greenplumDialect !== null)
      ? GreenplumDialect.fromPartial(object.greenplumDialect)
      : undefined;
    return message;
  },
};

function createBaseBigQueryDialect(): BigQueryDialect {
  return {};
}

export const BigQueryDialect: MessageFns<BigQueryDialect> = {
  encode(_: BigQueryDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BigQueryDialect {
    return {};
  },

  toJSON(_: BigQueryDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BigQueryDialect>): BigQueryDialect {
    return BigQueryDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BigQueryDialect>): BigQueryDialect {
    const message = createBaseBigQueryDialect();
    return message;
  },
};

function createBaseHiveQLDialect(): HiveQLDialect {
  return {};
}

export const HiveQLDialect: MessageFns<HiveQLDialect> = {
  encode(_: HiveQLDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HiveQLDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHiveQLDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HiveQLDialect {
    return {};
  },

  toJSON(_: HiveQLDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HiveQLDialect>): HiveQLDialect {
    return HiveQLDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HiveQLDialect>): HiveQLDialect {
    const message = createBaseHiveQLDialect();
    return message;
  },
};

function createBaseRedshiftDialect(): RedshiftDialect {
  return {};
}

export const RedshiftDialect: MessageFns<RedshiftDialect> = {
  encode(_: RedshiftDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedshiftDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedshiftDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RedshiftDialect {
    return {};
  },

  toJSON(_: RedshiftDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RedshiftDialect>): RedshiftDialect {
    return RedshiftDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RedshiftDialect>): RedshiftDialect {
    const message = createBaseRedshiftDialect();
    return message;
  },
};

function createBaseTeradataDialect(): TeradataDialect {
  return { mode: 0 };
}

export const TeradataDialect: MessageFns<TeradataDialect> = {
  encode(message: TeradataDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TeradataDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeradataDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeradataDialect {
    return { mode: isSet(object.mode) ? teradataDialect_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: TeradataDialect): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = teradataDialect_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<TeradataDialect>): TeradataDialect {
    return TeradataDialect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TeradataDialect>): TeradataDialect {
    const message = createBaseTeradataDialect();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseOracleDialect(): OracleDialect {
  return {};
}

export const OracleDialect: MessageFns<OracleDialect> = {
  encode(_: OracleDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OracleDialect {
    return {};
  },

  toJSON(_: OracleDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<OracleDialect>): OracleDialect {
    return OracleDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<OracleDialect>): OracleDialect {
    const message = createBaseOracleDialect();
    return message;
  },
};

function createBaseSparkSQLDialect(): SparkSQLDialect {
  return {};
}

export const SparkSQLDialect: MessageFns<SparkSQLDialect> = {
  encode(_: SparkSQLDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkSQLDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkSQLDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SparkSQLDialect {
    return {};
  },

  toJSON(_: SparkSQLDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SparkSQLDialect>): SparkSQLDialect {
    return SparkSQLDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SparkSQLDialect>): SparkSQLDialect {
    const message = createBaseSparkSQLDialect();
    return message;
  },
};

function createBaseSnowflakeDialect(): SnowflakeDialect {
  return {};
}

export const SnowflakeDialect: MessageFns<SnowflakeDialect> = {
  encode(_: SnowflakeDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnowflakeDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnowflakeDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SnowflakeDialect {
    return {};
  },

  toJSON(_: SnowflakeDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SnowflakeDialect>): SnowflakeDialect {
    return SnowflakeDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SnowflakeDialect>): SnowflakeDialect {
    const message = createBaseSnowflakeDialect();
    return message;
  },
};

function createBaseNetezzaDialect(): NetezzaDialect {
  return {};
}

export const NetezzaDialect: MessageFns<NetezzaDialect> = {
  encode(_: NetezzaDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetezzaDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetezzaDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NetezzaDialect {
    return {};
  },

  toJSON(_: NetezzaDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<NetezzaDialect>): NetezzaDialect {
    return NetezzaDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NetezzaDialect>): NetezzaDialect {
    const message = createBaseNetezzaDialect();
    return message;
  },
};

function createBaseAzureSynapseDialect(): AzureSynapseDialect {
  return {};
}

export const AzureSynapseDialect: MessageFns<AzureSynapseDialect> = {
  encode(_: AzureSynapseDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AzureSynapseDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAzureSynapseDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AzureSynapseDialect {
    return {};
  },

  toJSON(_: AzureSynapseDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AzureSynapseDialect>): AzureSynapseDialect {
    return AzureSynapseDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AzureSynapseDialect>): AzureSynapseDialect {
    const message = createBaseAzureSynapseDialect();
    return message;
  },
};

function createBaseVerticaDialect(): VerticaDialect {
  return {};
}

export const VerticaDialect: MessageFns<VerticaDialect> = {
  encode(_: VerticaDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerticaDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerticaDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VerticaDialect {
    return {};
  },

  toJSON(_: VerticaDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<VerticaDialect>): VerticaDialect {
    return VerticaDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<VerticaDialect>): VerticaDialect {
    const message = createBaseVerticaDialect();
    return message;
  },
};

function createBaseSQLServerDialect(): SQLServerDialect {
  return {};
}

export const SQLServerDialect: MessageFns<SQLServerDialect> = {
  encode(_: SQLServerDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLServerDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLServerDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SQLServerDialect {
    return {};
  },

  toJSON(_: SQLServerDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SQLServerDialect>): SQLServerDialect {
    return SQLServerDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SQLServerDialect>): SQLServerDialect {
    const message = createBaseSQLServerDialect();
    return message;
  },
};

function createBasePostgresqlDialect(): PostgresqlDialect {
  return {};
}

export const PostgresqlDialect: MessageFns<PostgresqlDialect> = {
  encode(_: PostgresqlDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostgresqlDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostgresqlDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PostgresqlDialect {
    return {};
  },

  toJSON(_: PostgresqlDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PostgresqlDialect>): PostgresqlDialect {
    return PostgresqlDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PostgresqlDialect>): PostgresqlDialect {
    const message = createBasePostgresqlDialect();
    return message;
  },
};

function createBasePrestoDialect(): PrestoDialect {
  return {};
}

export const PrestoDialect: MessageFns<PrestoDialect> = {
  encode(_: PrestoDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrestoDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrestoDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PrestoDialect {
    return {};
  },

  toJSON(_: PrestoDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PrestoDialect>): PrestoDialect {
    return PrestoDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PrestoDialect>): PrestoDialect {
    const message = createBasePrestoDialect();
    return message;
  },
};

function createBaseMySQLDialect(): MySQLDialect {
  return {};
}

export const MySQLDialect: MessageFns<MySQLDialect> = {
  encode(_: MySQLDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MySQLDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySQLDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MySQLDialect {
    return {};
  },

  toJSON(_: MySQLDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MySQLDialect>): MySQLDialect {
    return MySQLDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MySQLDialect>): MySQLDialect {
    const message = createBaseMySQLDialect();
    return message;
  },
};

function createBaseDB2Dialect(): DB2Dialect {
  return {};
}

export const DB2Dialect: MessageFns<DB2Dialect> = {
  encode(_: DB2Dialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DB2Dialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDB2Dialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DB2Dialect {
    return {};
  },

  toJSON(_: DB2Dialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DB2Dialect>): DB2Dialect {
    return DB2Dialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DB2Dialect>): DB2Dialect {
    const message = createBaseDB2Dialect();
    return message;
  },
};

function createBaseSQLiteDialect(): SQLiteDialect {
  return {};
}

export const SQLiteDialect: MessageFns<SQLiteDialect> = {
  encode(_: SQLiteDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SQLiteDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSQLiteDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SQLiteDialect {
    return {};
  },

  toJSON(_: SQLiteDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SQLiteDialect>): SQLiteDialect {
    return SQLiteDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SQLiteDialect>): SQLiteDialect {
    const message = createBaseSQLiteDialect();
    return message;
  },
};

function createBaseGreenplumDialect(): GreenplumDialect {
  return {};
}

export const GreenplumDialect: MessageFns<GreenplumDialect> = {
  encode(_: GreenplumDialect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GreenplumDialect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGreenplumDialect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GreenplumDialect {
    return {};
  },

  toJSON(_: GreenplumDialect): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GreenplumDialect>): GreenplumDialect {
    return GreenplumDialect.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GreenplumDialect>): GreenplumDialect {
    const message = createBaseGreenplumDialect();
    return message;
  },
};

function createBaseObjectNameMappingList(): ObjectNameMappingList {
  return { nameMap: [] };
}

export const ObjectNameMappingList: MessageFns<ObjectNameMappingList> = {
  encode(message: ObjectNameMappingList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nameMap) {
      ObjectNameMapping.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectNameMappingList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectNameMappingList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nameMap.push(ObjectNameMapping.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectNameMappingList {
    return {
      nameMap: globalThis.Array.isArray(object?.nameMap)
        ? object.nameMap.map((e: any) => ObjectNameMapping.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ObjectNameMappingList): unknown {
    const obj: any = {};
    if (message.nameMap?.length) {
      obj.nameMap = message.nameMap.map((e) => ObjectNameMapping.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectNameMappingList>): ObjectNameMappingList {
    return ObjectNameMappingList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectNameMappingList>): ObjectNameMappingList {
    const message = createBaseObjectNameMappingList();
    message.nameMap = object.nameMap?.map((e) => ObjectNameMapping.fromPartial(e)) || [];
    return message;
  },
};

function createBaseObjectNameMapping(): ObjectNameMapping {
  return { source: undefined, target: undefined };
}

export const ObjectNameMapping: MessageFns<ObjectNameMapping> = {
  encode(message: ObjectNameMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      NameMappingKey.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.target !== undefined) {
      NameMappingValue.encode(message.target, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectNameMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectNameMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = NameMappingKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = NameMappingValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectNameMapping {
    return {
      source: isSet(object.source) ? NameMappingKey.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? NameMappingValue.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: ObjectNameMapping): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = NameMappingKey.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = NameMappingValue.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectNameMapping>): ObjectNameMapping {
    return ObjectNameMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectNameMapping>): ObjectNameMapping {
    const message = createBaseObjectNameMapping();
    message.source = (object.source !== undefined && object.source !== null)
      ? NameMappingKey.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? NameMappingValue.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseNameMappingKey(): NameMappingKey {
  return { type: 0, database: "", schema: "", relation: "", attribute: "" };
}

export const NameMappingKey: MessageFns<NameMappingKey> = {
  encode(message: NameMappingKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    if (message.relation !== "") {
      writer.uint32(34).string(message.relation);
    }
    if (message.attribute !== "") {
      writer.uint32(42).string(message.attribute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NameMappingKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNameMappingKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.relation = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attribute = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NameMappingKey {
    return {
      type: isSet(object.type) ? nameMappingKey_TypeFromJSON(object.type) : 0,
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      relation: isSet(object.relation) ? globalThis.String(object.relation) : "",
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
    };
  },

  toJSON(message: NameMappingKey): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = nameMappingKey_TypeToJSON(message.type);
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    return obj;
  },

  create(base?: DeepPartial<NameMappingKey>): NameMappingKey {
    return NameMappingKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NameMappingKey>): NameMappingKey {
    const message = createBaseNameMappingKey();
    message.type = object.type ?? 0;
    message.database = object.database ?? "";
    message.schema = object.schema ?? "";
    message.relation = object.relation ?? "";
    message.attribute = object.attribute ?? "";
    return message;
  },
};

function createBaseNameMappingValue(): NameMappingValue {
  return { database: "", schema: "", relation: "", attribute: "" };
}

export const NameMappingValue: MessageFns<NameMappingValue> = {
  encode(message: NameMappingValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== "") {
      writer.uint32(10).string(message.database);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.relation !== "") {
      writer.uint32(26).string(message.relation);
    }
    if (message.attribute !== "") {
      writer.uint32(34).string(message.attribute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NameMappingValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNameMappingValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.database = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relation = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attribute = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NameMappingValue {
    return {
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      relation: isSet(object.relation) ? globalThis.String(object.relation) : "",
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
    };
  },

  toJSON(message: NameMappingValue): unknown {
    const obj: any = {};
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    return obj;
  },

  create(base?: DeepPartial<NameMappingValue>): NameMappingValue {
    return NameMappingValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NameMappingValue>): NameMappingValue {
    const message = createBaseNameMappingValue();
    message.database = object.database ?? "";
    message.schema = object.schema ?? "";
    message.relation = object.relation ?? "";
    message.attribute = object.attribute ?? "";
    return message;
  },
};

function createBaseSourceEnv(): SourceEnv {
  return { defaultDatabase: "", schemaSearchPath: [], metadataStoreDataset: "" };
}

export const SourceEnv: MessageFns<SourceEnv> = {
  encode(message: SourceEnv, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultDatabase !== "") {
      writer.uint32(10).string(message.defaultDatabase);
    }
    for (const v of message.schemaSearchPath) {
      writer.uint32(18).string(v!);
    }
    if (message.metadataStoreDataset !== "") {
      writer.uint32(26).string(message.metadataStoreDataset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceEnv {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceEnv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultDatabase = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schemaSearchPath.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadataStoreDataset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceEnv {
    return {
      defaultDatabase: isSet(object.defaultDatabase) ? globalThis.String(object.defaultDatabase) : "",
      schemaSearchPath: globalThis.Array.isArray(object?.schemaSearchPath)
        ? object.schemaSearchPath.map((e: any) => globalThis.String(e))
        : [],
      metadataStoreDataset: isSet(object.metadataStoreDataset) ? globalThis.String(object.metadataStoreDataset) : "",
    };
  },

  toJSON(message: SourceEnv): unknown {
    const obj: any = {};
    if (message.defaultDatabase !== "") {
      obj.defaultDatabase = message.defaultDatabase;
    }
    if (message.schemaSearchPath?.length) {
      obj.schemaSearchPath = message.schemaSearchPath;
    }
    if (message.metadataStoreDataset !== "") {
      obj.metadataStoreDataset = message.metadataStoreDataset;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceEnv>): SourceEnv {
    return SourceEnv.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceEnv>): SourceEnv {
    const message = createBaseSourceEnv();
    message.defaultDatabase = object.defaultDatabase ?? "";
    message.schemaSearchPath = object.schemaSearchPath?.map((e) => e) || [];
    message.metadataStoreDataset = object.metadataStoreDataset ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
