// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/migration/v2alpha/migration_metrics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Distribution } from "../../../../api/distribution.js";
import {
  MetricDescriptor_MetricKind,
  metricDescriptor_MetricKindFromJSON,
  metricDescriptor_MetricKindToJSON,
  MetricDescriptor_ValueType,
  metricDescriptor_ValueTypeFromJSON,
  metricDescriptor_ValueTypeToJSON,
} from "../../../../api/metric.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.bigquery.migration.v2alpha";

/** The metrics object for a SubTask. */
export interface TimeSeries {
  /**
   * Required. The name of the metric.
   *
   * If the metric is not known by the service yet, it will be auto-created.
   */
  metric: string;
  /** Required. The value type of the time series. */
  valueType: MetricDescriptor_ValueType;
  /**
   * Optional. The metric kind of the time series.
   *
   * If present, it must be the same as the metric kind of the associated
   * metric. If the associated metric's descriptor must be auto-created, then
   * this field specifies the metric kind of the new descriptor and must be
   * either `GAUGE` (the default) or `CUMULATIVE`.
   */
  metricKind: MetricDescriptor_MetricKind;
  /**
   * Required. The data points of this time series. When listing time series, points are
   * returned in reverse time order.
   *
   * When creating a time series, this field must contain exactly one point and
   * the point's type must be the same as the value type of the associated
   * metric. If the associated metric's descriptor must be auto-created, then
   * the value type of the descriptor is determined by the point's type, which
   * must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
   */
  points: Point[];
}

/** A single data point in a time series. */
export interface Point {
  /**
   * The time interval to which the data point applies.  For `GAUGE` metrics,
   * the start time does not need to be supplied, but if it is supplied, it must
   * equal the end time.  For `DELTA` metrics, the start and end time should
   * specify a non-zero interval, with subsequent points specifying contiguous
   * and non-overlapping intervals.  For `CUMULATIVE` metrics, the start and end
   * time should specify a non-zero interval, with subsequent points specifying
   * the same start time and increasing end times, until an event resets the
   * cumulative value to zero and sets a new start time for the following
   * points.
   */
  interval:
    | TimeInterval
    | undefined;
  /** The value of the data point. */
  value: TypedValue | undefined;
}

/**
 * A time interval extending just after a start time through an end time.
 * If the start time is the same as the end time, then the interval
 * represents a single point in time.
 */
export interface TimeInterval {
  /**
   * Optional. The beginning of the time interval.  The default value
   * for the start time is the end time. The start time must not be
   * later than the end time.
   */
  startTime:
    | Date
    | undefined;
  /** Required. The end of the time interval. */
  endTime: Date | undefined;
}

/** A single strongly-typed value. */
export interface TypedValue {
  /** A Boolean value: `true` or `false`. */
  boolValue?:
    | boolean
    | undefined;
  /** A 64-bit integer. Its range is approximately +/-9.2x10^18. */
  int64Value?:
    | Long
    | undefined;
  /**
   * A 64-bit double-precision floating-point number. Its magnitude
   * is approximately +/-10^(+/-300) and it has 16 significant digits of
   * precision.
   */
  doubleValue?:
    | number
    | undefined;
  /** A variable-length string value. */
  stringValue?:
    | string
    | undefined;
  /** A distribution value. */
  distributionValue?: Distribution | undefined;
}

function createBaseTimeSeries(): TimeSeries {
  return { metric: "", valueType: 0, metricKind: 0, points: [] };
}

export const TimeSeries: MessageFns<TimeSeries> = {
  encode(message: TimeSeries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== "") {
      writer.uint32(10).string(message.metric);
    }
    if (message.valueType !== 0) {
      writer.uint32(16).int32(message.valueType);
    }
    if (message.metricKind !== 0) {
      writer.uint32(24).int32(message.metricKind);
    }
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metric = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metricKind = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeries {
    return {
      metric: isSet(object.metric) ? globalThis.String(object.metric) : "",
      valueType: isSet(object.valueType) ? metricDescriptor_ValueTypeFromJSON(object.valueType) : 0,
      metricKind: isSet(object.metricKind) ? metricDescriptor_MetricKindFromJSON(object.metricKind) : 0,
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [],
    };
  },

  toJSON(message: TimeSeries): unknown {
    const obj: any = {};
    if (message.metric !== "") {
      obj.metric = message.metric;
    }
    if (message.valueType !== 0) {
      obj.valueType = metricDescriptor_ValueTypeToJSON(message.valueType);
    }
    if (message.metricKind !== 0) {
      obj.metricKind = metricDescriptor_MetricKindToJSON(message.metricKind);
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeries>): TimeSeries {
    return TimeSeries.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeries>): TimeSeries {
    const message = createBaseTimeSeries();
    message.metric = object.metric ?? "";
    message.valueType = object.valueType ?? 0;
    message.metricKind = object.metricKind ?? 0;
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBasePoint(): Point {
  return { interval: undefined, value: undefined };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interval !== undefined) {
      TimeInterval.encode(message.interval, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      TypedValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interval = TimeInterval.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TypedValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      interval: isSet(object.interval) ? TimeInterval.fromJSON(object.interval) : undefined,
      value: isSet(object.value) ? TypedValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.interval !== undefined) {
      obj.interval = TimeInterval.toJSON(message.interval);
    }
    if (message.value !== undefined) {
      obj.value = TypedValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Point>): Point {
    return Point.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Point>): Point {
    const message = createBasePoint();
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? TimeInterval.fromPartial(object.interval)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? TypedValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTimeInterval(): TimeInterval {
  return { startTime: undefined, endTime: undefined };
}

export const TimeInterval: MessageFns<TimeInterval> = {
  encode(message: TimeInterval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeInterval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeInterval {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeInterval): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeInterval>): TimeInterval {
    return TimeInterval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeInterval>): TimeInterval {
    const message = createBaseTimeInterval();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseTypedValue(): TypedValue {
  return {
    boolValue: undefined,
    int64Value: undefined,
    doubleValue: undefined,
    stringValue: undefined,
    distributionValue: undefined,
  };
}

export const TypedValue: MessageFns<TypedValue> = {
  encode(message: TypedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boolValue !== undefined) {
      writer.uint32(8).bool(message.boolValue);
    }
    if (message.int64Value !== undefined) {
      writer.uint32(16).int64(message.int64Value.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(25).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(34).string(message.stringValue);
    }
    if (message.distributionValue !== undefined) {
      Distribution.encode(message.distributionValue, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distributionValue = Distribution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypedValue {
    return {
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      distributionValue: isSet(object.distributionValue) ? Distribution.fromJSON(object.distributionValue) : undefined,
    };
  },

  toJSON(message: TypedValue): unknown {
    const obj: any = {};
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.distributionValue !== undefined) {
      obj.distributionValue = Distribution.toJSON(message.distributionValue);
    }
    return obj;
  },

  create(base?: DeepPartial<TypedValue>): TypedValue {
    return TypedValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypedValue>): TypedValue {
    const message = createBaseTypedValue();
    message.boolValue = object.boolValue ?? undefined;
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.distributionValue = (object.distributionValue !== undefined && object.distributionValue !== null)
      ? Distribution.fromPartial(object.distributionValue)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
