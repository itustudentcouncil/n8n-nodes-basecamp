// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1/purge_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { GcsSource } from "./import_config.js";

export const protobufPackage = "google.cloud.discoveryengine.v1";

/** Request message for PurgeUserEvents method. */
export interface PurgeUserEventsRequest {
  /**
   * Required. The resource name of the catalog under which the events are
   * created. The format is
   * `projects/{project}/locations/global/collections/{collection}/dataStores/{dataStore}`
   */
  parent: string;
  /**
   * Required. The filter string to specify the events to be deleted with a
   * length limit of 5,000 characters. The eligible fields for filtering are:
   *
   * * `eventType`: Double quoted
   * [UserEvent.event_type][google.cloud.discoveryengine.v1.UserEvent.event_type]
   * string.
   * * `eventTime`: in ISO 8601 "zulu" format.
   * * `userPseudoId`: Double quoted string. Specifying this will delete all
   *   events associated with a visitor.
   * * `userId`: Double quoted string. Specifying this will delete all events
   *   associated with a user.
   *
   * Examples:
   *
   * * Deleting all events in a time range:
   *   `eventTime > "2012-04-23T18:25:43.511Z"
   *   eventTime < "2012-04-23T18:30:43.511Z"`
   * * Deleting specific eventType:
   *   `eventType = "search"`
   * * Deleting all events for a specific visitor:
   *   `userPseudoId = "visitor1024"`
   * * Deleting all events inside a DataStore:
   *   `*`
   *
   * The filtering fields are assumed to have an implicit AND.
   */
  filter: string;
  /**
   * The `force` field is currently not supported. Purge user event requests
   * will permanently delete all purgeable events. Once the development is
   * complete:
   * If `force` is set to false, the method will return the expected
   * purge count without deleting any user events. This field will default to
   * false if not included in the request.
   */
  force: boolean;
}

/**
 * Response of the PurgeUserEventsRequest. If the long running operation is
 * successfully done, then this message is returned by the
 * google.longrunning.Operations.response field.
 */
export interface PurgeUserEventsResponse {
  /** The total count of events purged as a result of the operation. */
  purgeCount: Long;
}

/**
 * Metadata related to the progress of the PurgeUserEvents operation.
 * This will be returned by the google.longrunning.Operation.metadata field.
 */
export interface PurgeUserEventsMetadata {
  /** Operation create time. */
  createTime:
    | Date
    | undefined;
  /**
   * Operation last update time. If the operation is done, this is also the
   * finish time.
   */
  updateTime:
    | Date
    | undefined;
  /** Count of entries that were deleted successfully. */
  successCount: Long;
  /** Count of entries that encountered errors while processing. */
  failureCount: Long;
}

/** Configuration of destination for Purge related errors. */
export interface PurgeErrorConfig {
  /**
   * Cloud Storage prefix for purge errors. This must be an empty,
   * existing Cloud Storage directory. Purge errors are written to
   * sharded files in this directory, one per line, as a JSON-encoded
   * `google.rpc.Status` message.
   */
  gcsPrefix?: string | undefined;
}

/**
 * Request message for
 * [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
 * method.
 */
export interface PurgeDocumentsRequest {
  /**
   * Cloud Storage location for the input content.
   * Supported `data_schema`:
   * * `document_id`: One valid
   * [Document.id][google.cloud.discoveryengine.v1.Document.id] per line.
   */
  gcsSource?:
    | GcsSource
    | undefined;
  /** Inline source for the input content for purge. */
  inlineSource?:
    | PurgeDocumentsRequest_InlineSource
    | undefined;
  /**
   * Required. The parent resource name, such as
   * `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
   */
  parent: string;
  /**
   * Required. Filter matching documents to purge. Only currently supported
   * value is
   * `*` (all items).
   */
  filter: string;
  /** The desired location of errors incurred during the purge. */
  errorConfig:
    | PurgeErrorConfig
    | undefined;
  /**
   * Actually performs the purge. If `force` is set to false, return the
   * expected purge count without deleting any documents.
   */
  force: boolean;
}

/**
 * The inline source for the input config for
 * [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
 * method.
 */
export interface PurgeDocumentsRequest_InlineSource {
  /**
   * Required. A list of full resource name of documents to purge. In the
   * format
   * `projects/* /locations/* /collections/* /dataStores/* /branches/* /documents/*`.
   * Recommended max of 100 items.
   */
  documents: string[];
}

/**
 * Response message for
 * [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
 * method. If the long running operation is successfully done, then this message
 * is returned by the google.longrunning.Operations.response field.
 */
export interface PurgeDocumentsResponse {
  /** The total count of documents purged as a result of the operation. */
  purgeCount: Long;
  /**
   * A sample of document names that will be deleted. Only populated if `force`
   * is set to false. A max of 100 names will be returned and the names are
   * chosen at random.
   */
  purgeSample: string[];
}

/**
 * Metadata related to the progress of the PurgeDocuments operation.
 * This will be returned by the google.longrunning.Operation.metadata field.
 */
export interface PurgeDocumentsMetadata {
  /** Operation create time. */
  createTime:
    | Date
    | undefined;
  /**
   * Operation last update time. If the operation is done, this is also the
   * finish time.
   */
  updateTime:
    | Date
    | undefined;
  /** Count of entries that were deleted successfully. */
  successCount: Long;
  /** Count of entries that encountered errors while processing. */
  failureCount: Long;
  /** Count of entries that were ignored as entries were not found. */
  ignoredCount: Long;
}

/**
 * Request message for
 * [CompletionService.PurgeSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]
 * method.
 */
export interface PurgeSuggestionDenyListEntriesRequest {
  /**
   * Required. The parent data store resource name for which to import denylist
   * entries. Follows pattern projects/* /locations/* /collections/* /dataStores/*.
   */
  parent: string;
}

/**
 * Response message for
 * [CompletionService.PurgeSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]
 * method.
 */
export interface PurgeSuggestionDenyListEntriesResponse {
  /** Number of suggestion deny list entries purged. */
  purgeCount: Long;
  /** A sample of errors encountered while processing the request. */
  errorSamples: Status[];
}

/**
 * Metadata related to the progress of the PurgeSuggestionDenyListEntries
 * operation. This is returned by the google.longrunning.Operation.metadata
 * field.
 */
export interface PurgeSuggestionDenyListEntriesMetadata {
  /** Operation create time. */
  createTime:
    | Date
    | undefined;
  /**
   * Operation last update time. If the operation is done, this is also the
   * finish time.
   */
  updateTime: Date | undefined;
}

/**
 * Request message for
 * [CompletionService.PurgeCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]
 * method.
 */
export interface PurgeCompletionSuggestionsRequest {
  /**
   * Required. The parent data store resource name for which to purge completion
   * suggestions. Follows pattern
   * projects/* /locations/* /collections/* /dataStores/*.
   */
  parent: string;
}

/**
 * Response message for
 * [CompletionService.PurgeCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]
 * method.
 */
export interface PurgeCompletionSuggestionsResponse {
  /** Whether the completion suggestions were successfully purged. */
  purgeSucceeded: boolean;
  /** A sample of errors encountered while processing the request. */
  errorSamples: Status[];
}

/**
 * Metadata related to the progress of the PurgeCompletionSuggestions
 * operation. This is returned by the google.longrunning.Operation.metadata
 * field.
 */
export interface PurgeCompletionSuggestionsMetadata {
  /** Operation create time. */
  createTime:
    | Date
    | undefined;
  /**
   * Operation last update time. If the operation is done, this is also the
   * finish time.
   */
  updateTime: Date | undefined;
}

function createBasePurgeUserEventsRequest(): PurgeUserEventsRequest {
  return { parent: "", filter: "", force: false };
}

export const PurgeUserEventsRequest: MessageFns<PurgeUserEventsRequest> = {
  encode(message: PurgeUserEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeUserEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeUserEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeUserEventsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: PurgeUserEventsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeUserEventsRequest>): PurgeUserEventsRequest {
    return PurgeUserEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeUserEventsRequest>): PurgeUserEventsRequest {
    const message = createBasePurgeUserEventsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBasePurgeUserEventsResponse(): PurgeUserEventsResponse {
  return { purgeCount: Long.ZERO };
}

export const PurgeUserEventsResponse: MessageFns<PurgeUserEventsResponse> = {
  encode(message: PurgeUserEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.purgeCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.purgeCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeUserEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeUserEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.purgeCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeUserEventsResponse {
    return { purgeCount: isSet(object.purgeCount) ? Long.fromValue(object.purgeCount) : Long.ZERO };
  },

  toJSON(message: PurgeUserEventsResponse): unknown {
    const obj: any = {};
    if (!message.purgeCount.equals(Long.ZERO)) {
      obj.purgeCount = (message.purgeCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeUserEventsResponse>): PurgeUserEventsResponse {
    return PurgeUserEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeUserEventsResponse>): PurgeUserEventsResponse {
    const message = createBasePurgeUserEventsResponse();
    message.purgeCount = (object.purgeCount !== undefined && object.purgeCount !== null)
      ? Long.fromValue(object.purgeCount)
      : Long.ZERO;
    return message;
  },
};

function createBasePurgeUserEventsMetadata(): PurgeUserEventsMetadata {
  return { createTime: undefined, updateTime: undefined, successCount: Long.ZERO, failureCount: Long.ZERO };
}

export const PurgeUserEventsMetadata: MessageFns<PurgeUserEventsMetadata> = {
  encode(message: PurgeUserEventsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    if (!message.successCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.successCount.toString());
    }
    if (!message.failureCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.failureCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeUserEventsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeUserEventsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.successCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeUserEventsMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      successCount: isSet(object.successCount) ? Long.fromValue(object.successCount) : Long.ZERO,
      failureCount: isSet(object.failureCount) ? Long.fromValue(object.failureCount) : Long.ZERO,
    };
  },

  toJSON(message: PurgeUserEventsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (!message.successCount.equals(Long.ZERO)) {
      obj.successCount = (message.successCount || Long.ZERO).toString();
    }
    if (!message.failureCount.equals(Long.ZERO)) {
      obj.failureCount = (message.failureCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeUserEventsMetadata>): PurgeUserEventsMetadata {
    return PurgeUserEventsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeUserEventsMetadata>): PurgeUserEventsMetadata {
    const message = createBasePurgeUserEventsMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.successCount = (object.successCount !== undefined && object.successCount !== null)
      ? Long.fromValue(object.successCount)
      : Long.ZERO;
    message.failureCount = (object.failureCount !== undefined && object.failureCount !== null)
      ? Long.fromValue(object.failureCount)
      : Long.ZERO;
    return message;
  },
};

function createBasePurgeErrorConfig(): PurgeErrorConfig {
  return { gcsPrefix: undefined };
}

export const PurgeErrorConfig: MessageFns<PurgeErrorConfig> = {
  encode(message: PurgeErrorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsPrefix !== undefined) {
      writer.uint32(10).string(message.gcsPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeErrorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeErrorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeErrorConfig {
    return { gcsPrefix: isSet(object.gcsPrefix) ? globalThis.String(object.gcsPrefix) : undefined };
  },

  toJSON(message: PurgeErrorConfig): unknown {
    const obj: any = {};
    if (message.gcsPrefix !== undefined) {
      obj.gcsPrefix = message.gcsPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeErrorConfig>): PurgeErrorConfig {
    return PurgeErrorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeErrorConfig>): PurgeErrorConfig {
    const message = createBasePurgeErrorConfig();
    message.gcsPrefix = object.gcsPrefix ?? undefined;
    return message;
  },
};

function createBasePurgeDocumentsRequest(): PurgeDocumentsRequest {
  return {
    gcsSource: undefined,
    inlineSource: undefined,
    parent: "",
    filter: "",
    errorConfig: undefined,
    force: false,
  };
}

export const PurgeDocumentsRequest: MessageFns<PurgeDocumentsRequest> = {
  encode(message: PurgeDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(42).fork()).join();
    }
    if (message.inlineSource !== undefined) {
      PurgeDocumentsRequest_InlineSource.encode(message.inlineSource, writer.uint32(50).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.errorConfig !== undefined) {
      PurgeErrorConfig.encode(message.errorConfig, writer.uint32(58).fork()).join();
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inlineSource = PurgeDocumentsRequest_InlineSource.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorConfig = PurgeErrorConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeDocumentsRequest {
    return {
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      inlineSource: isSet(object.inlineSource)
        ? PurgeDocumentsRequest_InlineSource.fromJSON(object.inlineSource)
        : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      errorConfig: isSet(object.errorConfig) ? PurgeErrorConfig.fromJSON(object.errorConfig) : undefined,
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: PurgeDocumentsRequest): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.inlineSource !== undefined) {
      obj.inlineSource = PurgeDocumentsRequest_InlineSource.toJSON(message.inlineSource);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.errorConfig !== undefined) {
      obj.errorConfig = PurgeErrorConfig.toJSON(message.errorConfig);
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeDocumentsRequest>): PurgeDocumentsRequest {
    return PurgeDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeDocumentsRequest>): PurgeDocumentsRequest {
    const message = createBasePurgeDocumentsRequest();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.inlineSource = (object.inlineSource !== undefined && object.inlineSource !== null)
      ? PurgeDocumentsRequest_InlineSource.fromPartial(object.inlineSource)
      : undefined;
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.errorConfig = (object.errorConfig !== undefined && object.errorConfig !== null)
      ? PurgeErrorConfig.fromPartial(object.errorConfig)
      : undefined;
    message.force = object.force ?? false;
    return message;
  },
};

function createBasePurgeDocumentsRequest_InlineSource(): PurgeDocumentsRequest_InlineSource {
  return { documents: [] };
}

export const PurgeDocumentsRequest_InlineSource: MessageFns<PurgeDocumentsRequest_InlineSource> = {
  encode(message: PurgeDocumentsRequest_InlineSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeDocumentsRequest_InlineSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeDocumentsRequest_InlineSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documents.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeDocumentsRequest_InlineSource {
    return {
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PurgeDocumentsRequest_InlineSource): unknown {
    const obj: any = {};
    if (message.documents?.length) {
      obj.documents = message.documents;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeDocumentsRequest_InlineSource>): PurgeDocumentsRequest_InlineSource {
    return PurgeDocumentsRequest_InlineSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeDocumentsRequest_InlineSource>): PurgeDocumentsRequest_InlineSource {
    const message = createBasePurgeDocumentsRequest_InlineSource();
    message.documents = object.documents?.map((e) => e) || [];
    return message;
  },
};

function createBasePurgeDocumentsResponse(): PurgeDocumentsResponse {
  return { purgeCount: Long.ZERO, purgeSample: [] };
}

export const PurgeDocumentsResponse: MessageFns<PurgeDocumentsResponse> = {
  encode(message: PurgeDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.purgeCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.purgeCount.toString());
    }
    for (const v of message.purgeSample) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.purgeCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.purgeSample.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeDocumentsResponse {
    return {
      purgeCount: isSet(object.purgeCount) ? Long.fromValue(object.purgeCount) : Long.ZERO,
      purgeSample: globalThis.Array.isArray(object?.purgeSample)
        ? object.purgeSample.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PurgeDocumentsResponse): unknown {
    const obj: any = {};
    if (!message.purgeCount.equals(Long.ZERO)) {
      obj.purgeCount = (message.purgeCount || Long.ZERO).toString();
    }
    if (message.purgeSample?.length) {
      obj.purgeSample = message.purgeSample;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeDocumentsResponse>): PurgeDocumentsResponse {
    return PurgeDocumentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeDocumentsResponse>): PurgeDocumentsResponse {
    const message = createBasePurgeDocumentsResponse();
    message.purgeCount = (object.purgeCount !== undefined && object.purgeCount !== null)
      ? Long.fromValue(object.purgeCount)
      : Long.ZERO;
    message.purgeSample = object.purgeSample?.map((e) => e) || [];
    return message;
  },
};

function createBasePurgeDocumentsMetadata(): PurgeDocumentsMetadata {
  return {
    createTime: undefined,
    updateTime: undefined,
    successCount: Long.ZERO,
    failureCount: Long.ZERO,
    ignoredCount: Long.ZERO,
  };
}

export const PurgeDocumentsMetadata: MessageFns<PurgeDocumentsMetadata> = {
  encode(message: PurgeDocumentsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    if (!message.successCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.successCount.toString());
    }
    if (!message.failureCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.failureCount.toString());
    }
    if (!message.ignoredCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.ignoredCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeDocumentsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeDocumentsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.successCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ignoredCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeDocumentsMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      successCount: isSet(object.successCount) ? Long.fromValue(object.successCount) : Long.ZERO,
      failureCount: isSet(object.failureCount) ? Long.fromValue(object.failureCount) : Long.ZERO,
      ignoredCount: isSet(object.ignoredCount) ? Long.fromValue(object.ignoredCount) : Long.ZERO,
    };
  },

  toJSON(message: PurgeDocumentsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (!message.successCount.equals(Long.ZERO)) {
      obj.successCount = (message.successCount || Long.ZERO).toString();
    }
    if (!message.failureCount.equals(Long.ZERO)) {
      obj.failureCount = (message.failureCount || Long.ZERO).toString();
    }
    if (!message.ignoredCount.equals(Long.ZERO)) {
      obj.ignoredCount = (message.ignoredCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeDocumentsMetadata>): PurgeDocumentsMetadata {
    return PurgeDocumentsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeDocumentsMetadata>): PurgeDocumentsMetadata {
    const message = createBasePurgeDocumentsMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.successCount = (object.successCount !== undefined && object.successCount !== null)
      ? Long.fromValue(object.successCount)
      : Long.ZERO;
    message.failureCount = (object.failureCount !== undefined && object.failureCount !== null)
      ? Long.fromValue(object.failureCount)
      : Long.ZERO;
    message.ignoredCount = (object.ignoredCount !== undefined && object.ignoredCount !== null)
      ? Long.fromValue(object.ignoredCount)
      : Long.ZERO;
    return message;
  },
};

function createBasePurgeSuggestionDenyListEntriesRequest(): PurgeSuggestionDenyListEntriesRequest {
  return { parent: "" };
}

export const PurgeSuggestionDenyListEntriesRequest: MessageFns<PurgeSuggestionDenyListEntriesRequest> = {
  encode(message: PurgeSuggestionDenyListEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeSuggestionDenyListEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeSuggestionDenyListEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeSuggestionDenyListEntriesRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: PurgeSuggestionDenyListEntriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeSuggestionDenyListEntriesRequest>): PurgeSuggestionDenyListEntriesRequest {
    return PurgeSuggestionDenyListEntriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeSuggestionDenyListEntriesRequest>): PurgeSuggestionDenyListEntriesRequest {
    const message = createBasePurgeSuggestionDenyListEntriesRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBasePurgeSuggestionDenyListEntriesResponse(): PurgeSuggestionDenyListEntriesResponse {
  return { purgeCount: Long.ZERO, errorSamples: [] };
}

export const PurgeSuggestionDenyListEntriesResponse: MessageFns<PurgeSuggestionDenyListEntriesResponse> = {
  encode(message: PurgeSuggestionDenyListEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.purgeCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.purgeCount.toString());
    }
    for (const v of message.errorSamples) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeSuggestionDenyListEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeSuggestionDenyListEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.purgeCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorSamples.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeSuggestionDenyListEntriesResponse {
    return {
      purgeCount: isSet(object.purgeCount) ? Long.fromValue(object.purgeCount) : Long.ZERO,
      errorSamples: globalThis.Array.isArray(object?.errorSamples)
        ? object.errorSamples.map((e: any) => Status.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PurgeSuggestionDenyListEntriesResponse): unknown {
    const obj: any = {};
    if (!message.purgeCount.equals(Long.ZERO)) {
      obj.purgeCount = (message.purgeCount || Long.ZERO).toString();
    }
    if (message.errorSamples?.length) {
      obj.errorSamples = message.errorSamples.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeSuggestionDenyListEntriesResponse>): PurgeSuggestionDenyListEntriesResponse {
    return PurgeSuggestionDenyListEntriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeSuggestionDenyListEntriesResponse>): PurgeSuggestionDenyListEntriesResponse {
    const message = createBasePurgeSuggestionDenyListEntriesResponse();
    message.purgeCount = (object.purgeCount !== undefined && object.purgeCount !== null)
      ? Long.fromValue(object.purgeCount)
      : Long.ZERO;
    message.errorSamples = object.errorSamples?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBasePurgeSuggestionDenyListEntriesMetadata(): PurgeSuggestionDenyListEntriesMetadata {
  return { createTime: undefined, updateTime: undefined };
}

export const PurgeSuggestionDenyListEntriesMetadata: MessageFns<PurgeSuggestionDenyListEntriesMetadata> = {
  encode(message: PurgeSuggestionDenyListEntriesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeSuggestionDenyListEntriesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeSuggestionDenyListEntriesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeSuggestionDenyListEntriesMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: PurgeSuggestionDenyListEntriesMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeSuggestionDenyListEntriesMetadata>): PurgeSuggestionDenyListEntriesMetadata {
    return PurgeSuggestionDenyListEntriesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeSuggestionDenyListEntriesMetadata>): PurgeSuggestionDenyListEntriesMetadata {
    const message = createBasePurgeSuggestionDenyListEntriesMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBasePurgeCompletionSuggestionsRequest(): PurgeCompletionSuggestionsRequest {
  return { parent: "" };
}

export const PurgeCompletionSuggestionsRequest: MessageFns<PurgeCompletionSuggestionsRequest> = {
  encode(message: PurgeCompletionSuggestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeCompletionSuggestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeCompletionSuggestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeCompletionSuggestionsRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: PurgeCompletionSuggestionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeCompletionSuggestionsRequest>): PurgeCompletionSuggestionsRequest {
    return PurgeCompletionSuggestionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeCompletionSuggestionsRequest>): PurgeCompletionSuggestionsRequest {
    const message = createBasePurgeCompletionSuggestionsRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBasePurgeCompletionSuggestionsResponse(): PurgeCompletionSuggestionsResponse {
  return { purgeSucceeded: false, errorSamples: [] };
}

export const PurgeCompletionSuggestionsResponse: MessageFns<PurgeCompletionSuggestionsResponse> = {
  encode(message: PurgeCompletionSuggestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeSucceeded !== false) {
      writer.uint32(8).bool(message.purgeSucceeded);
    }
    for (const v of message.errorSamples) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeCompletionSuggestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeCompletionSuggestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.purgeSucceeded = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorSamples.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeCompletionSuggestionsResponse {
    return {
      purgeSucceeded: isSet(object.purgeSucceeded) ? globalThis.Boolean(object.purgeSucceeded) : false,
      errorSamples: globalThis.Array.isArray(object?.errorSamples)
        ? object.errorSamples.map((e: any) => Status.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PurgeCompletionSuggestionsResponse): unknown {
    const obj: any = {};
    if (message.purgeSucceeded !== false) {
      obj.purgeSucceeded = message.purgeSucceeded;
    }
    if (message.errorSamples?.length) {
      obj.errorSamples = message.errorSamples.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeCompletionSuggestionsResponse>): PurgeCompletionSuggestionsResponse {
    return PurgeCompletionSuggestionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeCompletionSuggestionsResponse>): PurgeCompletionSuggestionsResponse {
    const message = createBasePurgeCompletionSuggestionsResponse();
    message.purgeSucceeded = object.purgeSucceeded ?? false;
    message.errorSamples = object.errorSamples?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBasePurgeCompletionSuggestionsMetadata(): PurgeCompletionSuggestionsMetadata {
  return { createTime: undefined, updateTime: undefined };
}

export const PurgeCompletionSuggestionsMetadata: MessageFns<PurgeCompletionSuggestionsMetadata> = {
  encode(message: PurgeCompletionSuggestionsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeCompletionSuggestionsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeCompletionSuggestionsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeCompletionSuggestionsMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: PurgeCompletionSuggestionsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeCompletionSuggestionsMetadata>): PurgeCompletionSuggestionsMetadata {
    return PurgeCompletionSuggestionsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeCompletionSuggestionsMetadata>): PurgeCompletionSuggestionsMetadata {
    const message = createBasePurgeCompletionSuggestionsMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
