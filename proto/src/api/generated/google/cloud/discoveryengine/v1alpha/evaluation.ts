// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1alpha/evaluation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { SearchRequest } from "./search_service.js";

export const protobufPackage = "google.cloud.discoveryengine.v1alpha";

/**
 * An evaluation is a single execution (or run) of an evaluation process. It
 * encapsulates the state of the evaluation and the resulting data.
 */
export interface Evaluation {
  /**
   * Identifier. The full resource name of the
   * [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation], in the
   * format of
   * `projects/{project}/locations/{location}/evaluations/{evaluation}`.
   *
   * This field must be a UTF-8 encoded string with a length limit of 1024
   * characters.
   */
  name: string;
  /** Required. The specification of the evaluation. */
  evaluationSpec:
    | Evaluation_EvaluationSpec
    | undefined;
  /**
   * Output only. The metrics produced by the evaluation, averaged across all
   * [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]s in the
   * [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet].
   *
   * Only populated when the evaluation's state is SUCCEEDED.
   */
  qualityMetrics:
    | QualityMetrics
    | undefined;
  /** Output only. The state of the evaluation. */
  state: Evaluation_State;
  /**
   * Output only. The error that occurred during evaluation. Only populated when
   * the evaluation's state is FAILED.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. Timestamp the
   * [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation] was created
   * at.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp the
   * [Evaluation][google.cloud.discoveryengine.v1alpha.Evaluation] was completed
   * at.
   */
  endTime:
    | Date
    | undefined;
  /** Output only. A sample of errors encountered while processing the request. */
  errorSamples: Status[];
}

/** Describes the state of an evaluation. */
export enum Evaluation_State {
  /** STATE_UNSPECIFIED - The evaluation is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The service is preparing to run the evaluation. */
  PENDING = 1,
  /** RUNNING - The evaluation is in progress. */
  RUNNING = 2,
  /** SUCCEEDED - The evaluation completed successfully. */
  SUCCEEDED = 3,
  /** FAILED - The evaluation failed. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function evaluation_StateFromJSON(object: any): Evaluation_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Evaluation_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Evaluation_State.PENDING;
    case 2:
    case "RUNNING":
      return Evaluation_State.RUNNING;
    case 3:
    case "SUCCEEDED":
      return Evaluation_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Evaluation_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Evaluation_State.UNRECOGNIZED;
  }
}

export function evaluation_StateToJSON(object: Evaluation_State): string {
  switch (object) {
    case Evaluation_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Evaluation_State.PENDING:
      return "PENDING";
    case Evaluation_State.RUNNING:
      return "RUNNING";
    case Evaluation_State.SUCCEEDED:
      return "SUCCEEDED";
    case Evaluation_State.FAILED:
      return "FAILED";
    case Evaluation_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes the specification of the evaluation. */
export interface Evaluation_EvaluationSpec {
  /**
   * Required. The search request that is used to perform the evaluation.
   *
   * Only the following fields within SearchRequest are supported; if any
   * other fields are provided, an UNSUPPORTED error will be returned:
   *
   * * [SearchRequest.serving_config][google.cloud.discoveryengine.v1alpha.SearchRequest.serving_config]
   * * [SearchRequest.branch][google.cloud.discoveryengine.v1alpha.SearchRequest.branch]
   * * [SearchRequest.canonical_filter][google.cloud.discoveryengine.v1alpha.SearchRequest.canonical_filter]
   * * [SearchRequest.query_expansion_spec][google.cloud.discoveryengine.v1alpha.SearchRequest.query_expansion_spec]
   * * [SearchRequest.spell_correction_spec][google.cloud.discoveryengine.v1alpha.SearchRequest.spell_correction_spec]
   * * [SearchRequest.content_search_spec][google.cloud.discoveryengine.v1alpha.SearchRequest.content_search_spec]
   * * [SearchRequest.user_pseudo_id][google.cloud.discoveryengine.v1alpha.SearchRequest.user_pseudo_id]
   */
  searchRequest?:
    | SearchRequest
    | undefined;
  /** Required. The specification of the query set. */
  querySetSpec: Evaluation_EvaluationSpec_QuerySetSpec | undefined;
}

/** Describes the specification of the query set. */
export interface Evaluation_EvaluationSpec_QuerySetSpec {
  /**
   * Required. The full resource name of the
   * [SampleQuerySet][google.cloud.discoveryengine.v1alpha.SampleQuerySet]
   * used for the evaluation, in the format of
   * `projects/{project}/locations/{location}/sampleQuerySets/{sampleQuerySet}`.
   */
  sampleQuerySet: string;
}

/** Describes the metrics produced by the evaluation. */
export interface QualityMetrics {
  /**
   * Recall per document, at various top-k cutoff levels.
   *
   * Recall is the fraction of relevant documents retrieved out of all
   * relevant documents.
   *
   * Example (top-5):
   *  * For a single
   *  [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery], If 3 out
   *  of 5 relevant documents are retrieved in the top-5, recall@5 = 3/5 = 0.6
   */
  docRecall:
    | QualityMetrics_TopkMetrics
    | undefined;
  /**
   * Precision per document, at various top-k cutoff levels.
   *
   * Precision is the fraction of retrieved documents that are relevant.
   *
   * Example (top-5):
   *  * For a single
   *  [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery], If 4 out
   *  of 5 retrieved documents in the top-5 are relevant, precision@5 = 4/5 =
   *  0.8
   */
  docPrecision:
    | QualityMetrics_TopkMetrics
    | undefined;
  /**
   * Normalized discounted cumulative gain (NDCG) per document, at various top-k
   * cutoff levels.
   *
   * NDCG measures the ranking quality, giving higher relevance to top
   * results.
   *
   * Example (top-3):
   *  Suppose [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]
   *  with three retrieved documents (D1, D2, D3) and binary relevance
   *  judgements (1 for relevant, 0 for not relevant):
   *
   *   Retrieved:  [D3 (0), D1 (1), D2 (1)]
   *   Ideal:      [D1 (1), D2 (1), D3 (0)]
   *
   *   Calculate NDCG@3 for each
   *   [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]:
   *    * DCG@3: 0/log2(1+1) + 1/log2(2+1) + 1/log2(3+1) = 1.13
   *    * Ideal DCG@3: 1/log2(1+1) + 1/log2(2+1) + 0/log2(3+1) = 1.63
   *    * NDCG@3: 1.13/1.63 = 0.693
   */
  docNdcg:
    | QualityMetrics_TopkMetrics
    | undefined;
  /**
   * Recall per page, at various top-k cutoff levels.
   *
   * Recall is the fraction of relevant pages retrieved out of all relevant
   * pages.
   *
   * Example (top-5):
   *  * For a single
   *  [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery], if 3 out
   *  of 5 relevant pages are retrieved in the top-5, recall@5 = 3/5 = 0.6
   */
  pageRecall:
    | QualityMetrics_TopkMetrics
    | undefined;
  /**
   * Normalized discounted cumulative gain (NDCG) per page, at various top-k
   * cutoff levels.
   *
   * NDCG measures the ranking quality, giving higher relevance to top
   * results.
   *
   * Example (top-3):
   *  Suppose [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]
   *  with three retrieved pages (P1, P2, P3) and binary relevance judgements (1
   *  for relevant, 0 for not relevant):
   *
   *   Retrieved:  [P3 (0), P1 (1), P2 (1)]
   *   Ideal:      [P1 (1), P2 (1), P3 (0)]
   *
   *   Calculate NDCG@3 for
   *   [SampleQuery][google.cloud.discoveryengine.v1alpha.SampleQuery]:
   *    * DCG@3: 0/log2(1+1) + 1/log2(2+1) + 1/log2(3+1) = 1.13
   *    * Ideal DCG@3: 1/log2(1+1) + 1/log2(2+1) + 0/log2(3+1) = 1.63
   *    * NDCG@3: 1.13/1.63 = 0.693
   */
  pageNdcg: QualityMetrics_TopkMetrics | undefined;
}

/** Stores the metric values at specific top-k levels. */
export interface QualityMetrics_TopkMetrics {
  /** The top-1 value. */
  top1: number;
  /** The top-3 value. */
  top3: number;
  /** The top-5 value. */
  top5: number;
  /** The top-10 value. */
  top10: number;
}

function createBaseEvaluation(): Evaluation {
  return {
    name: "",
    evaluationSpec: undefined,
    qualityMetrics: undefined,
    state: 0,
    error: undefined,
    createTime: undefined,
    endTime: undefined,
    errorSamples: [],
  };
}

export const Evaluation: MessageFns<Evaluation> = {
  encode(message: Evaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.evaluationSpec !== undefined) {
      Evaluation_EvaluationSpec.encode(message.evaluationSpec, writer.uint32(18).fork()).join();
    }
    if (message.qualityMetrics !== undefined) {
      QualityMetrics.encode(message.qualityMetrics, writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    for (const v of message.errorSamples) {
      Status.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.evaluationSpec = Evaluation_EvaluationSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.qualityMetrics = QualityMetrics.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.errorSamples.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      evaluationSpec: isSet(object.evaluationSpec)
        ? Evaluation_EvaluationSpec.fromJSON(object.evaluationSpec)
        : undefined,
      qualityMetrics: isSet(object.qualityMetrics) ? QualityMetrics.fromJSON(object.qualityMetrics) : undefined,
      state: isSet(object.state) ? evaluation_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      errorSamples: globalThis.Array.isArray(object?.errorSamples)
        ? object.errorSamples.map((e: any) => Status.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Evaluation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.evaluationSpec !== undefined) {
      obj.evaluationSpec = Evaluation_EvaluationSpec.toJSON(message.evaluationSpec);
    }
    if (message.qualityMetrics !== undefined) {
      obj.qualityMetrics = QualityMetrics.toJSON(message.qualityMetrics);
    }
    if (message.state !== 0) {
      obj.state = evaluation_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.errorSamples?.length) {
      obj.errorSamples = message.errorSamples.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation>): Evaluation {
    return Evaluation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation>): Evaluation {
    const message = createBaseEvaluation();
    message.name = object.name ?? "";
    message.evaluationSpec = (object.evaluationSpec !== undefined && object.evaluationSpec !== null)
      ? Evaluation_EvaluationSpec.fromPartial(object.evaluationSpec)
      : undefined;
    message.qualityMetrics = (object.qualityMetrics !== undefined && object.qualityMetrics !== null)
      ? QualityMetrics.fromPartial(object.qualityMetrics)
      : undefined;
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.errorSamples = object.errorSamples?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvaluation_EvaluationSpec(): Evaluation_EvaluationSpec {
  return { searchRequest: undefined, querySetSpec: undefined };
}

export const Evaluation_EvaluationSpec: MessageFns<Evaluation_EvaluationSpec> = {
  encode(message: Evaluation_EvaluationSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchRequest !== undefined) {
      SearchRequest.encode(message.searchRequest, writer.uint32(18).fork()).join();
    }
    if (message.querySetSpec !== undefined) {
      Evaluation_EvaluationSpec_QuerySetSpec.encode(message.querySetSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_EvaluationSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_EvaluationSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchRequest = SearchRequest.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.querySetSpec = Evaluation_EvaluationSpec_QuerySetSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_EvaluationSpec {
    return {
      searchRequest: isSet(object.searchRequest) ? SearchRequest.fromJSON(object.searchRequest) : undefined,
      querySetSpec: isSet(object.querySetSpec)
        ? Evaluation_EvaluationSpec_QuerySetSpec.fromJSON(object.querySetSpec)
        : undefined,
    };
  },

  toJSON(message: Evaluation_EvaluationSpec): unknown {
    const obj: any = {};
    if (message.searchRequest !== undefined) {
      obj.searchRequest = SearchRequest.toJSON(message.searchRequest);
    }
    if (message.querySetSpec !== undefined) {
      obj.querySetSpec = Evaluation_EvaluationSpec_QuerySetSpec.toJSON(message.querySetSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_EvaluationSpec>): Evaluation_EvaluationSpec {
    return Evaluation_EvaluationSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_EvaluationSpec>): Evaluation_EvaluationSpec {
    const message = createBaseEvaluation_EvaluationSpec();
    message.searchRequest = (object.searchRequest !== undefined && object.searchRequest !== null)
      ? SearchRequest.fromPartial(object.searchRequest)
      : undefined;
    message.querySetSpec = (object.querySetSpec !== undefined && object.querySetSpec !== null)
      ? Evaluation_EvaluationSpec_QuerySetSpec.fromPartial(object.querySetSpec)
      : undefined;
    return message;
  },
};

function createBaseEvaluation_EvaluationSpec_QuerySetSpec(): Evaluation_EvaluationSpec_QuerySetSpec {
  return { sampleQuerySet: "" };
}

export const Evaluation_EvaluationSpec_QuerySetSpec: MessageFns<Evaluation_EvaluationSpec_QuerySetSpec> = {
  encode(message: Evaluation_EvaluationSpec_QuerySetSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleQuerySet !== "") {
      writer.uint32(10).string(message.sampleQuerySet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_EvaluationSpec_QuerySetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_EvaluationSpec_QuerySetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sampleQuerySet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_EvaluationSpec_QuerySetSpec {
    return { sampleQuerySet: isSet(object.sampleQuerySet) ? globalThis.String(object.sampleQuerySet) : "" };
  },

  toJSON(message: Evaluation_EvaluationSpec_QuerySetSpec): unknown {
    const obj: any = {};
    if (message.sampleQuerySet !== "") {
      obj.sampleQuerySet = message.sampleQuerySet;
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_EvaluationSpec_QuerySetSpec>): Evaluation_EvaluationSpec_QuerySetSpec {
    return Evaluation_EvaluationSpec_QuerySetSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_EvaluationSpec_QuerySetSpec>): Evaluation_EvaluationSpec_QuerySetSpec {
    const message = createBaseEvaluation_EvaluationSpec_QuerySetSpec();
    message.sampleQuerySet = object.sampleQuerySet ?? "";
    return message;
  },
};

function createBaseQualityMetrics(): QualityMetrics {
  return {
    docRecall: undefined,
    docPrecision: undefined,
    docNdcg: undefined,
    pageRecall: undefined,
    pageNdcg: undefined,
  };
}

export const QualityMetrics: MessageFns<QualityMetrics> = {
  encode(message: QualityMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.docRecall !== undefined) {
      QualityMetrics_TopkMetrics.encode(message.docRecall, writer.uint32(10).fork()).join();
    }
    if (message.docPrecision !== undefined) {
      QualityMetrics_TopkMetrics.encode(message.docPrecision, writer.uint32(18).fork()).join();
    }
    if (message.docNdcg !== undefined) {
      QualityMetrics_TopkMetrics.encode(message.docNdcg, writer.uint32(26).fork()).join();
    }
    if (message.pageRecall !== undefined) {
      QualityMetrics_TopkMetrics.encode(message.pageRecall, writer.uint32(34).fork()).join();
    }
    if (message.pageNdcg !== undefined) {
      QualityMetrics_TopkMetrics.encode(message.pageNdcg, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QualityMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQualityMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.docRecall = QualityMetrics_TopkMetrics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.docPrecision = QualityMetrics_TopkMetrics.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.docNdcg = QualityMetrics_TopkMetrics.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageRecall = QualityMetrics_TopkMetrics.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageNdcg = QualityMetrics_TopkMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QualityMetrics {
    return {
      docRecall: isSet(object.docRecall) ? QualityMetrics_TopkMetrics.fromJSON(object.docRecall) : undefined,
      docPrecision: isSet(object.docPrecision) ? QualityMetrics_TopkMetrics.fromJSON(object.docPrecision) : undefined,
      docNdcg: isSet(object.docNdcg) ? QualityMetrics_TopkMetrics.fromJSON(object.docNdcg) : undefined,
      pageRecall: isSet(object.pageRecall) ? QualityMetrics_TopkMetrics.fromJSON(object.pageRecall) : undefined,
      pageNdcg: isSet(object.pageNdcg) ? QualityMetrics_TopkMetrics.fromJSON(object.pageNdcg) : undefined,
    };
  },

  toJSON(message: QualityMetrics): unknown {
    const obj: any = {};
    if (message.docRecall !== undefined) {
      obj.docRecall = QualityMetrics_TopkMetrics.toJSON(message.docRecall);
    }
    if (message.docPrecision !== undefined) {
      obj.docPrecision = QualityMetrics_TopkMetrics.toJSON(message.docPrecision);
    }
    if (message.docNdcg !== undefined) {
      obj.docNdcg = QualityMetrics_TopkMetrics.toJSON(message.docNdcg);
    }
    if (message.pageRecall !== undefined) {
      obj.pageRecall = QualityMetrics_TopkMetrics.toJSON(message.pageRecall);
    }
    if (message.pageNdcg !== undefined) {
      obj.pageNdcg = QualityMetrics_TopkMetrics.toJSON(message.pageNdcg);
    }
    return obj;
  },

  create(base?: DeepPartial<QualityMetrics>): QualityMetrics {
    return QualityMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QualityMetrics>): QualityMetrics {
    const message = createBaseQualityMetrics();
    message.docRecall = (object.docRecall !== undefined && object.docRecall !== null)
      ? QualityMetrics_TopkMetrics.fromPartial(object.docRecall)
      : undefined;
    message.docPrecision = (object.docPrecision !== undefined && object.docPrecision !== null)
      ? QualityMetrics_TopkMetrics.fromPartial(object.docPrecision)
      : undefined;
    message.docNdcg = (object.docNdcg !== undefined && object.docNdcg !== null)
      ? QualityMetrics_TopkMetrics.fromPartial(object.docNdcg)
      : undefined;
    message.pageRecall = (object.pageRecall !== undefined && object.pageRecall !== null)
      ? QualityMetrics_TopkMetrics.fromPartial(object.pageRecall)
      : undefined;
    message.pageNdcg = (object.pageNdcg !== undefined && object.pageNdcg !== null)
      ? QualityMetrics_TopkMetrics.fromPartial(object.pageNdcg)
      : undefined;
    return message;
  },
};

function createBaseQualityMetrics_TopkMetrics(): QualityMetrics_TopkMetrics {
  return { top1: 0, top3: 0, top5: 0, top10: 0 };
}

export const QualityMetrics_TopkMetrics: MessageFns<QualityMetrics_TopkMetrics> = {
  encode(message: QualityMetrics_TopkMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.top1 !== 0) {
      writer.uint32(9).double(message.top1);
    }
    if (message.top3 !== 0) {
      writer.uint32(17).double(message.top3);
    }
    if (message.top5 !== 0) {
      writer.uint32(25).double(message.top5);
    }
    if (message.top10 !== 0) {
      writer.uint32(33).double(message.top10);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QualityMetrics_TopkMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQualityMetrics_TopkMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.top1 = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.top3 = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.top5 = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.top10 = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QualityMetrics_TopkMetrics {
    return {
      top1: isSet(object.top1) ? globalThis.Number(object.top1) : 0,
      top3: isSet(object.top3) ? globalThis.Number(object.top3) : 0,
      top5: isSet(object.top5) ? globalThis.Number(object.top5) : 0,
      top10: isSet(object.top10) ? globalThis.Number(object.top10) : 0,
    };
  },

  toJSON(message: QualityMetrics_TopkMetrics): unknown {
    const obj: any = {};
    if (message.top1 !== 0) {
      obj.top1 = message.top1;
    }
    if (message.top3 !== 0) {
      obj.top3 = message.top3;
    }
    if (message.top5 !== 0) {
      obj.top5 = message.top5;
    }
    if (message.top10 !== 0) {
      obj.top10 = message.top10;
    }
    return obj;
  },

  create(base?: DeepPartial<QualityMetrics_TopkMetrics>): QualityMetrics_TopkMetrics {
    return QualityMetrics_TopkMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QualityMetrics_TopkMetrics>): QualityMetrics_TopkMetrics {
    const message = createBaseQualityMetrics_TopkMetrics();
    message.top1 = object.top1 ?? 0;
    message.top3 = object.top3 ?? 0;
    message.top5 = object.top5 ?? 0;
    message.top10 = object.top10 ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
