// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1beta/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.discoveryengine.v1beta";

/**
 * The industry vertical associated with the
 * [DataStore][google.cloud.discoveryengine.v1beta.DataStore].
 */
export enum IndustryVertical {
  /** INDUSTRY_VERTICAL_UNSPECIFIED - Value used when unset. */
  INDUSTRY_VERTICAL_UNSPECIFIED = 0,
  /**
   * GENERIC - The generic vertical for documents that are not specific to any industry
   * vertical.
   */
  GENERIC = 1,
  /** MEDIA - The media industry vertical. */
  MEDIA = 2,
  /** HEALTHCARE_FHIR - The healthcare FHIR vertical. */
  HEALTHCARE_FHIR = 7,
  UNRECOGNIZED = -1,
}

export function industryVerticalFromJSON(object: any): IndustryVertical {
  switch (object) {
    case 0:
    case "INDUSTRY_VERTICAL_UNSPECIFIED":
      return IndustryVertical.INDUSTRY_VERTICAL_UNSPECIFIED;
    case 1:
    case "GENERIC":
      return IndustryVertical.GENERIC;
    case 2:
    case "MEDIA":
      return IndustryVertical.MEDIA;
    case 7:
    case "HEALTHCARE_FHIR":
      return IndustryVertical.HEALTHCARE_FHIR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IndustryVertical.UNRECOGNIZED;
  }
}

export function industryVerticalToJSON(object: IndustryVertical): string {
  switch (object) {
    case IndustryVertical.INDUSTRY_VERTICAL_UNSPECIFIED:
      return "INDUSTRY_VERTICAL_UNSPECIFIED";
    case IndustryVertical.GENERIC:
      return "GENERIC";
    case IndustryVertical.MEDIA:
      return "MEDIA";
    case IndustryVertical.HEALTHCARE_FHIR:
      return "HEALTHCARE_FHIR";
    case IndustryVertical.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of solution. */
export enum SolutionType {
  /** SOLUTION_TYPE_UNSPECIFIED - Default value. */
  SOLUTION_TYPE_UNSPECIFIED = 0,
  /** SOLUTION_TYPE_RECOMMENDATION - Used for Recommendations AI. */
  SOLUTION_TYPE_RECOMMENDATION = 1,
  /** SOLUTION_TYPE_SEARCH - Used for Discovery Search. */
  SOLUTION_TYPE_SEARCH = 2,
  /** SOLUTION_TYPE_CHAT - Used for use cases related to the Generative AI agent. */
  SOLUTION_TYPE_CHAT = 3,
  /**
   * SOLUTION_TYPE_GENERATIVE_CHAT - Used for use cases related to the Generative Chat agent.
   * It's used for Generative chat engine only, the associated data stores
   * must enrolled with `SOLUTION_TYPE_CHAT` solution.
   */
  SOLUTION_TYPE_GENERATIVE_CHAT = 4,
  UNRECOGNIZED = -1,
}

export function solutionTypeFromJSON(object: any): SolutionType {
  switch (object) {
    case 0:
    case "SOLUTION_TYPE_UNSPECIFIED":
      return SolutionType.SOLUTION_TYPE_UNSPECIFIED;
    case 1:
    case "SOLUTION_TYPE_RECOMMENDATION":
      return SolutionType.SOLUTION_TYPE_RECOMMENDATION;
    case 2:
    case "SOLUTION_TYPE_SEARCH":
      return SolutionType.SOLUTION_TYPE_SEARCH;
    case 3:
    case "SOLUTION_TYPE_CHAT":
      return SolutionType.SOLUTION_TYPE_CHAT;
    case 4:
    case "SOLUTION_TYPE_GENERATIVE_CHAT":
      return SolutionType.SOLUTION_TYPE_GENERATIVE_CHAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SolutionType.UNRECOGNIZED;
  }
}

export function solutionTypeToJSON(object: SolutionType): string {
  switch (object) {
    case SolutionType.SOLUTION_TYPE_UNSPECIFIED:
      return "SOLUTION_TYPE_UNSPECIFIED";
    case SolutionType.SOLUTION_TYPE_RECOMMENDATION:
      return "SOLUTION_TYPE_RECOMMENDATION";
    case SolutionType.SOLUTION_TYPE_SEARCH:
      return "SOLUTION_TYPE_SEARCH";
    case SolutionType.SOLUTION_TYPE_CHAT:
      return "SOLUTION_TYPE_CHAT";
    case SolutionType.SOLUTION_TYPE_GENERATIVE_CHAT:
      return "SOLUTION_TYPE_GENERATIVE_CHAT";
    case SolutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines a further subdivision of `SolutionType`.
 * Specifically applies to
 * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_SEARCH].
 */
export enum SearchUseCase {
  /** SEARCH_USE_CASE_UNSPECIFIED - Value used when unset. Will not occur in CSS. */
  SEARCH_USE_CASE_UNSPECIFIED = 0,
  /**
   * SEARCH_USE_CASE_SEARCH - Search use case. Expects the traffic has a non-empty
   * [query][google.cloud.discoveryengine.v1beta.SearchRequest.query].
   */
  SEARCH_USE_CASE_SEARCH = 1,
  /**
   * SEARCH_USE_CASE_BROWSE - Browse use case. Expects the traffic has an empty
   * [query][google.cloud.discoveryengine.v1beta.SearchRequest.query].
   */
  SEARCH_USE_CASE_BROWSE = 2,
  UNRECOGNIZED = -1,
}

export function searchUseCaseFromJSON(object: any): SearchUseCase {
  switch (object) {
    case 0:
    case "SEARCH_USE_CASE_UNSPECIFIED":
      return SearchUseCase.SEARCH_USE_CASE_UNSPECIFIED;
    case 1:
    case "SEARCH_USE_CASE_SEARCH":
      return SearchUseCase.SEARCH_USE_CASE_SEARCH;
    case 2:
    case "SEARCH_USE_CASE_BROWSE":
      return SearchUseCase.SEARCH_USE_CASE_BROWSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchUseCase.UNRECOGNIZED;
  }
}

export function searchUseCaseToJSON(object: SearchUseCase): string {
  switch (object) {
    case SearchUseCase.SEARCH_USE_CASE_UNSPECIFIED:
      return "SEARCH_USE_CASE_UNSPECIFIED";
    case SearchUseCase.SEARCH_USE_CASE_SEARCH:
      return "SEARCH_USE_CASE_SEARCH";
    case SearchUseCase.SEARCH_USE_CASE_BROWSE:
      return "SEARCH_USE_CASE_BROWSE";
    case SearchUseCase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Tiers of search features. Different tiers might have different
 * pricing. To learn more, check the pricing documentation.
 */
export enum SearchTier {
  /** SEARCH_TIER_UNSPECIFIED - Default value when the enum is unspecified. This is invalid to use. */
  SEARCH_TIER_UNSPECIFIED = 0,
  /** SEARCH_TIER_STANDARD - Standard tier. */
  SEARCH_TIER_STANDARD = 1,
  /** SEARCH_TIER_ENTERPRISE - Enterprise tier. */
  SEARCH_TIER_ENTERPRISE = 2,
  UNRECOGNIZED = -1,
}

export function searchTierFromJSON(object: any): SearchTier {
  switch (object) {
    case 0:
    case "SEARCH_TIER_UNSPECIFIED":
      return SearchTier.SEARCH_TIER_UNSPECIFIED;
    case 1:
    case "SEARCH_TIER_STANDARD":
      return SearchTier.SEARCH_TIER_STANDARD;
    case 2:
    case "SEARCH_TIER_ENTERPRISE":
      return SearchTier.SEARCH_TIER_ENTERPRISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchTier.UNRECOGNIZED;
  }
}

export function searchTierToJSON(object: SearchTier): string {
  switch (object) {
    case SearchTier.SEARCH_TIER_UNSPECIFIED:
      return "SEARCH_TIER_UNSPECIFIED";
    case SearchTier.SEARCH_TIER_STANDARD:
      return "SEARCH_TIER_STANDARD";
    case SearchTier.SEARCH_TIER_ENTERPRISE:
      return "SEARCH_TIER_ENTERPRISE";
    case SearchTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Add-on that provides additional functionality for search. */
export enum SearchAddOn {
  /** SEARCH_ADD_ON_UNSPECIFIED - Default value when the enum is unspecified. This is invalid to use. */
  SEARCH_ADD_ON_UNSPECIFIED = 0,
  /** SEARCH_ADD_ON_LLM - Large language model add-on. */
  SEARCH_ADD_ON_LLM = 1,
  UNRECOGNIZED = -1,
}

export function searchAddOnFromJSON(object: any): SearchAddOn {
  switch (object) {
    case 0:
    case "SEARCH_ADD_ON_UNSPECIFIED":
      return SearchAddOn.SEARCH_ADD_ON_UNSPECIFIED;
    case 1:
    case "SEARCH_ADD_ON_LLM":
      return SearchAddOn.SEARCH_ADD_ON_LLM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchAddOn.UNRECOGNIZED;
  }
}

export function searchAddOnToJSON(object: SearchAddOn): string {
  switch (object) {
    case SearchAddOn.SEARCH_ADD_ON_UNSPECIFIED:
      return "SEARCH_ADD_ON_UNSPECIFIED";
    case SearchAddOn.SEARCH_ADD_ON_LLM:
      return "SEARCH_ADD_ON_LLM";
    case SearchAddOn.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A floating point interval. */
export interface Interval {
  /** Inclusive lower bound. */
  minimum?:
    | number
    | undefined;
  /** Exclusive lower bound. */
  exclusiveMinimum?:
    | number
    | undefined;
  /** Inclusive upper bound. */
  maximum?:
    | number
    | undefined;
  /** Exclusive upper bound. */
  exclusiveMaximum?: number | undefined;
}

/**
 * A custom attribute that is not explicitly modeled in a resource, e.g.
 * [UserEvent][google.cloud.discoveryengine.v1beta.UserEvent].
 */
export interface CustomAttribute {
  /**
   * The textual values of this custom attribute. For example, `["yellow",
   * "green"]` when the key is "color".
   *
   * Empty string is not allowed. Otherwise, an `INVALID_ARGUMENT` error is
   * returned.
   *
   * Exactly one of
   * [CustomAttribute.text][google.cloud.discoveryengine.v1beta.CustomAttribute.text]
   * or
   * [CustomAttribute.numbers][google.cloud.discoveryengine.v1beta.CustomAttribute.numbers]
   * should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  text: string[];
  /**
   * The numerical values of this custom attribute. For example, `[2.3, 15.4]`
   * when the key is "lengths_cm".
   *
   * Exactly one of
   * [CustomAttribute.text][google.cloud.discoveryengine.v1beta.CustomAttribute.text]
   * or
   * [CustomAttribute.numbers][google.cloud.discoveryengine.v1beta.CustomAttribute.numbers]
   * should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  numbers: number[];
}

/** Information of an end user. */
export interface UserInfo {
  /**
   * Highly recommended for logged-in users. Unique identifier for logged-in
   * user, such as a user name. Don't set for anonymous users.
   *
   * Always use a hashed value for this ID.
   *
   * Don't set the field to the same fixed ID for different users. This mixes
   * the event history of those users together, which results in degraded
   * model quality.
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  userId: string;
  /**
   * User agent as included in the HTTP header.
   *
   * The field must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   *
   * This should not be set when using the client side event reporting with
   * GTM or JavaScript tag in
   * [UserEventService.CollectUserEvent][google.cloud.discoveryengine.v1beta.UserEventService.CollectUserEvent]
   * or if
   * [UserEvent.direct_user_request][google.cloud.discoveryengine.v1beta.UserEvent.direct_user_request]
   * is set.
   */
  userAgent: string;
}

/** Defines embedding config, used for bring your own embeddings feature. */
export interface EmbeddingConfig {
  /** Full field path in the schema mapped as embedding field. */
  fieldPath: string;
}

/** Double list. */
export interface DoubleList {
  /** Double values. */
  values: number[];
}

function createBaseInterval(): Interval {
  return { minimum: undefined, exclusiveMinimum: undefined, maximum: undefined, exclusiveMaximum: undefined };
}

export const Interval: MessageFns<Interval> = {
  encode(message: Interval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimum !== undefined) {
      writer.uint32(9).double(message.minimum);
    }
    if (message.exclusiveMinimum !== undefined) {
      writer.uint32(17).double(message.exclusiveMinimum);
    }
    if (message.maximum !== undefined) {
      writer.uint32(25).double(message.maximum);
    }
    if (message.exclusiveMaximum !== undefined) {
      writer.uint32(33).double(message.exclusiveMaximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.minimum = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.exclusiveMinimum = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.maximum = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.exclusiveMaximum = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interval {
    return {
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : undefined,
      exclusiveMinimum: isSet(object.exclusiveMinimum) ? globalThis.Number(object.exclusiveMinimum) : undefined,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : undefined,
      exclusiveMaximum: isSet(object.exclusiveMaximum) ? globalThis.Number(object.exclusiveMaximum) : undefined,
    };
  },

  toJSON(message: Interval): unknown {
    const obj: any = {};
    if (message.minimum !== undefined) {
      obj.minimum = message.minimum;
    }
    if (message.exclusiveMinimum !== undefined) {
      obj.exclusiveMinimum = message.exclusiveMinimum;
    }
    if (message.maximum !== undefined) {
      obj.maximum = message.maximum;
    }
    if (message.exclusiveMaximum !== undefined) {
      obj.exclusiveMaximum = message.exclusiveMaximum;
    }
    return obj;
  },

  create(base?: DeepPartial<Interval>): Interval {
    return Interval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interval>): Interval {
    const message = createBaseInterval();
    message.minimum = object.minimum ?? undefined;
    message.exclusiveMinimum = object.exclusiveMinimum ?? undefined;
    message.maximum = object.maximum ?? undefined;
    message.exclusiveMaximum = object.exclusiveMaximum ?? undefined;
    return message;
  },
};

function createBaseCustomAttribute(): CustomAttribute {
  return { text: [], numbers: [] };
}

export const CustomAttribute: MessageFns<CustomAttribute> = {
  encode(message: CustomAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.text) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.numbers) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text.push(reader.string());
          continue;
        case 2:
          if (tag === 17) {
            message.numbers.push(reader.double());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAttribute {
    return {
      text: globalThis.Array.isArray(object?.text) ? object.text.map((e: any) => globalThis.String(e)) : [],
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CustomAttribute): unknown {
    const obj: any = {};
    if (message.text?.length) {
      obj.text = message.text;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAttribute>): CustomAttribute {
    return CustomAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAttribute>): CustomAttribute {
    const message = createBaseCustomAttribute();
    message.text = object.text?.map((e) => e) || [];
    message.numbers = object.numbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { userId: "", userAgent: "" };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userAgent !== "") {
      writer.uint32(18).string(message.userAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userAgent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.userAgent = object.userAgent ?? "";
    return message;
  },
};

function createBaseEmbeddingConfig(): EmbeddingConfig {
  return { fieldPath: "" };
}

export const EmbeddingConfig: MessageFns<EmbeddingConfig> = {
  encode(message: EmbeddingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddingConfig {
    return { fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "" };
  },

  toJSON(message: EmbeddingConfig): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    return obj;
  },

  create(base?: DeepPartial<EmbeddingConfig>): EmbeddingConfig {
    return EmbeddingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmbeddingConfig>): EmbeddingConfig {
    const message = createBaseEmbeddingConfig();
    message.fieldPath = object.fieldPath ?? "";
    return message;
  },
};

function createBaseDoubleList(): DoubleList {
  return { values: [] };
}

export const DoubleList: MessageFns<DoubleList> = {
  encode(message: DoubleList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleList {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DoubleList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleList>): DoubleList {
    return DoubleList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleList>): DoubleList {
    const message = createBaseDoubleList();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
